use std::{mem::offset_of, any::Any, option::Option, sync::Arc};
use tokio::sync::Mutex;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData,
        TypeObject, TypeFunctions, LockedTypeObject, BoxedTypeObject,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_game_shared_types(registry: &mut TypeRegistry) {
    registry.register_type(FADETRACKDATA_TYPE_INFO);
    registry.register_type(FADETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(FADETRACKKEYFRAME_TYPE_INFO);
    registry.register_type(FADETRACKKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(FADETRACKKEYFRAMETYPE_TYPE_INFO);
    registry.register_type(FADETRACKKEYFRAMETYPE_ARRAY_TYPE_INFO);
    registry.register_type(TRACKBUILDERDATA_TYPE_INFO);
    registry.register_type(TRACKBUILDERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ACTORTOBLUEPRINTGUIDROW_TYPE_INFO);
    registry.register_type(ACTORTOBLUEPRINTGUIDROW_ARRAY_TYPE_INFO);
    registry.register_type(CUTSCENESAVEDSETTINGSDATA_TYPE_INFO);
    registry.register_type(CUTSCENESAVEDSETTINGSDATA_ARRAY_TYPE_INFO);
    registry.register_type(IMPORTTARGET_TYPE_INFO);
    registry.register_type(IMPORTTARGET_ARRAY_TYPE_INFO);
    registry.register_type(IMPORTERSOURCE_TYPE_INFO);
    registry.register_type(IMPORTERSOURCE_ARRAY_TYPE_INFO);
    registry.register_type(CUTSCENESAVEDSETTINGS_PATHTYPE_TYPE_INFO);
    registry.register_type(CUTSCENESAVEDSETTINGS_PATHTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CUTSCENEQUALITYLEVEL_TYPE_INFO);
    registry.register_type(CUTSCENEQUALITYLEVEL_ARRAY_TYPE_INFO);
    registry.register_type(CUTSCENEACTORTYPE_TYPE_INFO);
    registry.register_type(CUTSCENEACTORTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CAMERATRACKDATA_TYPE_INFO);
    registry.register_type(CAMERATRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERATRACKBASEDATA_TYPE_INFO);
    registry.register_type(CAMERATRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERALOOKATLAYERDATA_TYPE_INFO);
    registry.register_type(CAMERALOOKATLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAFOCUSTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERAFOCUSTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADOFTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERADOFTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERADIRECTORTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORTRACKBASEDATA_TYPE_INFO);
    registry.register_type(CAMERADIRECTORTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORKEYFRAME_TYPE_INFO);
    registry.register_type(CAMERADIRECTORKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACUTBEHAVIOR_TYPE_INFO);
    registry.register_type(CAMERACUTBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORPROXYTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERADIRECTORPROXYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORPROXYKEYFRAME_TYPE_INFO);
    registry.register_type(CAMERADIRECTORPROXYKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACUTVISIBILITYTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERACUTVISIBILITYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACUTVISIBILITYKEYFRAME_TYPE_INFO);
    registry.register_type(CAMERACUTVISIBILITYKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAATTACHTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(CAMERAATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ATTACHTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(ATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTTRAJECTORYTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(ANTTRAJECTORYTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTSLOTTRACKDATA_TYPE_INFO);
    registry.register_type(ANTSLOTTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTSIGNALTRACKDATA_TYPE_INFO);
    registry.register_type(ANTSIGNALTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTENUMTRACKDATA_TYPE_INFO);
    registry.register_type(ANTENUMTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTENUMKEYFRAME_TYPE_INFO);
    registry.register_type(ANTENUMKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(ANTVEC3TRACKDATA_TYPE_INFO);
    registry.register_type(ANTVEC3TRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTINTTRACKDATA_TYPE_INFO);
    registry.register_type(ANTINTTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTFLOATTRACKDATA_TYPE_INFO);
    registry.register_type(ANTFLOATTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTBOOLTRACKDATA_TYPE_INFO);
    registry.register_type(ANTBOOLTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTEVALTRACKDATA_TYPE_INFO);
    registry.register_type(ANTEVALTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTCONTROLTRACKDATA_TYPE_INFO);
    registry.register_type(ANTCONTROLTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TELEPORTKEYFRAME_TYPE_INFO);
    registry.register_type(TELEPORTKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(ANTBONETRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(ANTBONETRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTBONETRACKDATA_TYPE_INFO);
    registry.register_type(ANTBONETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTBONEANIMATIONTRACKDATA_TYPE_INFO);
    registry.register_type(ANTBONEANIMATIONTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTANIMATABLECAMERATRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(ANTANIMATABLECAMERATRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTANIMATABLECAMERATRACKDATA_TYPE_INFO);
    registry.register_type(ANTANIMATABLECAMERATRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPOSETRACKDATA_TYPE_INFO);
    registry.register_type(ANIMATIONPOSETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPOSELAYERROOTDATA_TYPE_INFO);
    registry.register_type(ANIMATIONPOSELAYERROOTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPOSELAYERDATA_TYPE_INFO);
    registry.register_type(ANIMATIONPOSELAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPOSEKEYFRAME_TYPE_INFO);
    registry.register_type(ANIMATIONPOSEKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(SQT_TYPE_INFO);
    registry.register_type(SQT_ARRAY_TYPE_INFO);
    registry.register_type(VEC3VALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC3VALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3RECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC3RECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALIDATETRACKDATA_TYPE_INFO);
    registry.register_type(VALIDATETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO);
    registry.register_type(VALIDATEPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALIDATELINKTRACKBASEDATA_TYPE_INFO);
    registry.register_type(VALIDATELINKTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMVALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(TRANSFORMVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMRECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(TRANSFORMRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDTRACKDATA_TYPE_INFO);
    registry.register_type(RECORDTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRIMMEDRECORDINGRANGE_TYPE_INFO);
    registry.register_type(TRIMMEDRECORDINGRANGE_ARRAY_TYPE_INFO);
    registry.register_type(TRIMMINGRANGEKEYFRAME_TYPE_INFO);
    registry.register_type(TRIMMINGRANGEKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(RECORDLINKTRACKBASEDATA_TYPE_INFO);
    registry.register_type(RECORDLINKTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO);
    registry.register_type(RECORDPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERPOSEVALIDATETRACKDATA_TYPE_INFO);
    registry.register_type(CHARACTERPOSEVALIDATETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(POSEVALIDATETRACKDATA_TYPE_INFO);
    registry.register_type(POSEVALIDATETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERPOSERECORDTRACKDATA_TYPE_INFO);
    registry.register_type(CHARACTERPOSERECORDTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(POSERECORDTRACKDATA_TYPE_INFO);
    registry.register_type(POSERECORDTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTVALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(INTVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTRECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(INTRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATVALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(FLOATVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEANTGAMESTATEENTITYDATA_TYPE_INFO);
    registry.register_type(WRITEANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READANTGAMESTATEENTITYDATA_TYPE_INFO);
    registry.register_type(READANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVECTOR3TRANSFORMGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVECTOR3GAMESTATE_TYPE_INFO);
    registry.register_type(WRITEVECTOR3GAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEQUATERNIONGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEQUATERNIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEBOOLGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEBOOLGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEINTGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEINTGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEFLOATGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEFLOATGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEENUMERATIONGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEENUMERATIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO);
    registry.register_type(READVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READQUATERNIONGAMESTATE_TYPE_INFO);
    registry.register_type(READQUATERNIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READVECTOR3TRANSFORMGAMESTATE_TYPE_INFO);
    registry.register_type(READVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READVECTOR3GAMESTATE_TYPE_INFO);
    registry.register_type(READVECTOR3GAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READBOOLGAMESTATE_TYPE_INFO);
    registry.register_type(READBOOLGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READINTGAMESTATE_TYPE_INFO);
    registry.register_type(READINTGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READFLOATGAMESTATE_TYPE_INFO);
    registry.register_type(READFLOATGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READENUMERATIONGAMESTATE_TYPE_INFO);
    registry.register_type(READENUMERATIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEANTGAMESTATEDATA_TYPE_INFO);
    registry.register_type(WRITEANTGAMESTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(READANTGAMESTATEDATA_TYPE_INFO);
    registry.register_type(READANTGAMESTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTGAMESTATEDATA_TYPE_INFO);
    registry.register_type(ANTGAMESTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(ANTEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTEVENTDATA_TYPE_INFO);
    registry.register_type(ANTEVENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPROXYBANKDATA_TYPE_INFO);
    registry.register_type(ANIMATIONPROXYBANKDATA_ARRAY_TYPE_INFO);
    registry.register_type(BONEFAKEPHYSICSDATA_TYPE_INFO);
    registry.register_type(BONEFAKEPHYSICSDATA_ARRAY_TYPE_INFO);
    registry.register_type(ADDFAKECOLLISIONENTITYDATA_TYPE_INFO);
    registry.register_type(ADDFAKECOLLISIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDVEHICLETRACKDATA_TYPE_INFO);
    registry.register_type(RECORDVEHICLETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDROOTTRANSFORMTRACKDATA_TYPE_INFO);
    registry.register_type(RECORDROOTTRANSFORMTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDENTRYINPUTTRACKDATA_TYPE_INFO);
    registry.register_type(RECORDENTRYINPUTTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDENTRYINPUTTYPE_TYPE_INFO);
    registry.register_type(RECORDENTRYINPUTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRACKDATA_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRACKUPDATEINFO_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRACKUPDATEINFO_ARRAY_TYPE_INFO);
    registry.register_type(PATHTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(PATHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(GROUNDATTACHTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(GROUNDATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(GROUNDATTACHMETHOD_TYPE_INFO);
    registry.register_type(GROUNDATTACHMETHOD_ARRAY_TYPE_INFO);
    registry.register_type(GAMEPLAYCAMERATRACKDATA_TYPE_INFO);
    registry.register_type(GAMEPLAYCAMERATRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAWFILEDATAASSET_TYPE_INFO);
    registry.register_type(RAWFILEDATAASSET_ARRAY_TYPE_INFO);
    registry.register_type(RAWFILERESOURCEASSET_TYPE_INFO);
    registry.register_type(RAWFILERESOURCEASSET_ARRAY_TYPE_INFO);
    registry.register_type(RAWFILEASSET_TYPE_INFO);
    registry.register_type(RAWFILEASSET_ARRAY_TYPE_INFO);
    registry.register_type(PLAYANIMATIONVISUALIZERENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYANIMATIONVISUALIZERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENANIMATIONENTITYBINDING_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENANIMATIONENTITYBINDING_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCESTATGROUP_TYPE_INFO);
    registry.register_type(PERSISTENCESTATGROUP_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCESTATTABLE_TYPE_INFO);
    registry.register_type(PERSISTENCESTATTABLE_ARRAY_TYPE_INFO);
    registry.register_type(ABSTRACTPERSISTENCEDATA_TYPE_INFO);
    registry.register_type(ABSTRACTPERSISTENCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEHISTORYTYPE_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEHISTORYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ABSTRACTLEADERBOARDDATA_TYPE_INFO);
    registry.register_type(ABSTRACTLEADERBOARDDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCEGAMEDATA_TYPE_INFO);
    registry.register_type(PERSISTENCEGAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCEDATA_TYPE_INFO);
    registry.register_type(RICHPRESENCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCEPROPERTY_TYPE_INFO);
    registry.register_type(RICHPRESENCEPROPERTY_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCEPROPERTYTYPE_TYPE_INFO);
    registry.register_type(RICHPRESENCEPROPERTYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTSETTING_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTSETTING_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXT_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXT_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTVALUEWITHKEY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTVALUEWITHKEY_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTVALUE_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTVALUE_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCEPRESENCESTRING_TYPE_INFO);
    registry.register_type(RICHPRESENCEPRESENCESTRING_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCEDATA_TYPE_INFO);
    registry.register_type(PERSISTENCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCECONSUMABLEMAPPING_TYPE_INFO);
    registry.register_type(PERSISTENCECONSUMABLEMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCEGAMETYPE_TYPE_INFO);
    registry.register_type(PERSISTENCEGAMETYPE_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCERETENTIONPOLICY_TYPE_INFO);
    registry.register_type(PERSISTENCERETENTIONPOLICY_ARRAY_TYPE_INFO);
    registry.register_type(STATPERIOD_TYPE_INFO);
    registry.register_type(STATPERIOD_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATESTATREF_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATESTATREF_ARRAY_TYPE_INFO);
    registry.register_type(ABSTRACTPERSISTENTSTATREF_TYPE_INFO);
    registry.register_type(ABSTRACTPERSISTENTSTATREF_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATE_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATE_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATEDATA_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEDATAKIND_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEDATAKIND_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEDATATYPE_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEDATATYPE_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETYPE_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETYPE_ARRAY_TYPE_INFO);
    registry.register_type(CONSUMABLEGROUP_TYPE_INFO);
    registry.register_type(CONSUMABLEGROUP_ARRAY_TYPE_INFO);
    registry.register_type(PA2TARGETCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PA2TARGETCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PA2TARGETPROPERTIES_TYPE_INFO);
    registry.register_type(PA2TARGETPROPERTIES_ARRAY_TYPE_INFO);
    registry.register_type(PA2BONELIST_TYPE_INFO);
    registry.register_type(PA2BONELIST_ARRAY_TYPE_INFO);
    registry.register_type(PA2BONE_TYPE_INFO);
    registry.register_type(PA2BONE_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTHIGHLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTHIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERINVEHICLESCENARIOENTITYDATA_TYPE_INFO);
    registry.register_type(CHARACTERINVEHICLESCENARIOENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTIPLEACTORSCENARIOENTITYDATA_TYPE_INFO);
    registry.register_type(MULTIPLEACTORSCENARIOENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BILLBOARDTRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(BILLBOARDTRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BILLBOARDTRANSFORMROTATIONAXIS_TYPE_INFO);
    registry.register_type(BILLBOARDTRANSFORMROTATIONAXIS_ARRAY_TYPE_INFO);
    registry.register_type(WATERDEPTHENTITYDATA_TYPE_INFO);
    registry.register_type(WATERDEPTHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSNAPTOGROUNDENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMSNAPTOGROUNDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESHEMITTERDYNAMICSTATE_TYPE_INFO);
    registry.register_type(MESHEMITTERDYNAMICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MESHEMITTERSTATICSTATE_TYPE_INFO);
    registry.register_type(MESHEMITTERSTATICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MESHEMITTERCONTROLENTITYDATA_TYPE_INFO);
    registry.register_type(MESHEMITTERCONTROLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLDYNAMICSTATE_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLDYNAMICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLSTATICSTATE_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLSTATICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLENTITYDATA_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLTYPE_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLTYPE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYVFXENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYVFXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VFXLOCATIONCONTROL_TYPE_INFO);
    registry.register_type(VFXLOCATIONCONTROL_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYEREVENTENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYEREVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERITERATORENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERITERATORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INCLUSIONSETTINGENTITYDATA_TYPE_INFO);
    registry.register_type(INCLUSIONSETTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TELEPORTENTITYDATA_TYPE_INFO);
    registry.register_type(TELEPORTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STREAMINGGATEENTITYDATA_TYPE_INFO);
    registry.register_type(STREAMINGGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZECHARACTERENTITYDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZECHARACTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZEBASEENTITYDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZEBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTAREAQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTAREAQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREAQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(AREAQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREAPROXIMITYENTITYDATA_TYPE_INFO);
    registry.register_type(AREAPROXIMITYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTRESTRICTIONENTITYDATA_TYPE_INFO);
    registry.register_type(INPUTRESTRICTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTIFSWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTIFSWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEAMFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(TEAMFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLATFORMSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(PLATFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTMEMORYENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTMEMORYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPEEDEVENTGATEENTITYDATA_TYPE_INFO);
    registry.register_type(SPEEDEVENTGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCOMPAREGATEENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTCOMPAREGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCOMPAREGATETYPE_TYPE_INFO);
    registry.register_type(EVENTCOMPAREGATETYPE_ARRAY_TYPE_INFO);
    registry.register_type(SAVEGAMELOADEDENTITYDATA_TYPE_INFO);
    registry.register_type(SAVEGAMELOADEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SAVEENTITYDATA_TYPE_INFO);
    registry.register_type(SAVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARTENTITYDATA_TYPE_INFO);
    registry.register_type(STARTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARTPOINTENTITYDATA_TYPE_INFO);
    registry.register_type(STARTPOINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SERVERSTARTPOINTLOADEDFROMDSUBLEVELMESSAGE_TYPE_INFO);
    registry.register_type(MAPMARKERENTITYDATA_TYPE_INFO);
    registry.register_type(MAPMARKERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MAPMARKERCOLORTYPE_TYPE_INFO);
    registry.register_type(MAPMARKERCOLORTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MAPMARKERTYPE_TYPE_INFO);
    registry.register_type(MAPMARKERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MESSAGEENTITYDATA_TYPE_INFO);
    registry.register_type(MESSAGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESSAGEENTITYINFO_TYPE_INFO);
    registry.register_type(MESSAGEENTITYINFO_ARRAY_TYPE_INFO);
    registry.register_type(TACTICALOBJECTIVEENTITYDATA_TYPE_INFO);
    registry.register_type(TACTICALOBJECTIVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LEVELCONTROLENTITYDATA_TYPE_INFO);
    registry.register_type(LEVELCONTROLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTIVEENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTIVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESSAGERECIEVER_TYPE_INFO);
    registry.register_type(MESSAGERECIEVER_ARRAY_TYPE_INFO);
    registry.register_type(MISSIONOBJECTIVEHUDDATA_TYPE_INFO);
    registry.register_type(MISSIONOBJECTIVEHUDDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTIVETYPE_TYPE_INFO);
    registry.register_type(OBJECTIVETYPE_ARRAY_TYPE_INFO);
    registry.register_type(FADEENTITYDATA_TYPE_INFO);
    registry.register_type(FADEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BLINKTYPE_TYPE_INFO);
    registry.register_type(BLINKTYPE_ARRAY_TYPE_INFO);
    registry.register_type(KILLALLENTITYDATA_TYPE_INFO);
    registry.register_type(KILLALLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(KILLALLPLAYERENUM_TYPE_INFO);
    registry.register_type(KILLALLPLAYERENUM_ARRAY_TYPE_INFO);
    registry.register_type(WAYPOINTTRIGGERENTITYBASEDATA_TYPE_INFO);
    registry.register_type(WAYPOINTTRIGGERENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMBATAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(COMBATAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SURROUNDINGGEOMETRYENTITYDATA_TYPE_INFO);
    registry.register_type(SURROUNDINGGEOMETRYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(UICOMBATAREAENTITYDATA_TYPE_INFO);
    registry.register_type(UICOMBATAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALLOWEDVEHICLESDATA_TYPE_INFO);
    registry.register_type(ALLOWEDVEHICLESDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEATHAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(DEATHAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HUMANPLAYERENTITYDATA_TYPE_INFO);
    registry.register_type(HUMANPLAYERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HUMANPLAYERPROXYENTITYDATA_TYPE_INFO);
    registry.register_type(HUMANPLAYERPROXYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEAMENTITYDATA_TYPE_INFO);
    registry.register_type(TEAMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEAMDATA_TYPE_INFO);
    registry.register_type(TEAMDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICAVOIDANCEENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICAVOIDANCEMODE_TYPE_INFO);
    registry.register_type(DYNAMICAVOIDANCEMODE_ARRAY_TYPE_INFO);
    registry.register_type(ANTDYNAMICAVOIDANCEBINDING_TYPE_INFO);
    registry.register_type(ANTDYNAMICAVOIDANCEBINDING_ARRAY_TYPE_INFO);
    registry.register_type(DRIVERSTATICOBJECTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DRIVERSTATICOBJECTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DRIVERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DRIVERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DRIVERSETTINGS_TYPE_INFO);
    registry.register_type(DRIVERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(REGULATEDSTEERING_TYPE_INFO);
    registry.register_type(REGULATEDSTEERING_ARRAY_TYPE_INFO);
    registry.register_type(PID_TYPE_INFO);
    registry.register_type(PID_ARRAY_TYPE_INFO);
    registry.register_type(DIFFICULTYINDEXENTITYDATA_TYPE_INFO);
    registry.register_type(DIFFICULTYINDEXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIFFICULTYDATAS_TYPE_INFO);
    registry.register_type(DIFFICULTYDATAS_ARRAY_TYPE_INFO);
    registry.register_type(DIFFICULTYDATA_TYPE_INFO);
    registry.register_type(DIFFICULTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIFFICULTY_TYPE_INFO);
    registry.register_type(DIFFICULTY_ARRAY_TYPE_INFO);
    registry.register_type(GAMEAIDIFFICULTYDATA_TYPE_INFO);
    registry.register_type(GAMEAIDIFFICULTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKEDUNLOCK_TYPE_INFO);
    registry.register_type(NETWORKEDUNLOCK_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZECHARACTERDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZECHARACTERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZEVISUAL_TYPE_INFO);
    registry.register_type(CUSTOMIZEVISUAL_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKPLAYERSELECTEDUNLOCKASSETSMESSAGE_TYPE_INFO);
    registry.register_type(CAMOUNLOCKSELECTION_TYPE_INFO);
    registry.register_type(CAMOUNLOCKSELECTION_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECUSTOMIZATIONASSET_TYPE_INFO);
    registry.register_type(VEHICLECUSTOMIZATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERCUSTOMIZATIONASSET_TYPE_INFO);
    registry.register_type(CHARACTERCUSTOMIZATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONUNLOCKPARTS_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONUNLOCKPARTS_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONTABLE_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONTABLE_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEVISUALCUSTOMIZATIONASSET_TYPE_INFO);
    registry.register_type(VEHICLEVISUALCUSTOMIZATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(TEXTUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(TEXTUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHADERTEXTUREUNLOCKPARTCOLLECTION_TYPE_INFO);
    registry.register_type(SHADERTEXTUREUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(SHADERCOLORUNLOCKPARTCOLLECTION_TYPE_INFO);
    registry.register_type(SHADERCOLORUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO);
    registry.register_type(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZEDMESHMATERIALSDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZEDMESHMATERIALSDATA_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKABLETEXTURESLICECOLLECTION_TYPE_INFO);
    registry.register_type(UNLOCKABLETEXTURESLICECOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKABLETEXTURECOLLECTION_TYPE_INFO);
    registry.register_type(UNLOCKABLETEXTURECOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKABLECOLORCOLLECTION_TYPE_INFO);
    registry.register_type(UNLOCKABLECOLORCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKABLESHADERPARAMETERVALUECOLLECTION_TYPE_INFO);
    registry.register_type(UNLOCKABLESHADERPARAMETERVALUECOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(TEXTURESLICEUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(TEXTURESLICEUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTUREASSETUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(TEXTUREASSETUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTUREUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(TEXTUREUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTUREREFERENCE_TYPE_INFO);
    registry.register_type(TEXTUREREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(COLORUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(COLORUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLORREFERENCE_TYPE_INFO);
    registry.register_type(COLORREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(AREAIMMUNITYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AREAIMMUNITYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WATERDEPTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WATERDEPTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LADDERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(LADDERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYTOCOMPONENTSRESETMESSAGE_TYPE_INFO);
    registry.register_type(ALTERNATECAMERAVIEWDATA_TYPE_INFO);
    registry.register_type(ALTERNATECAMERAVIEWDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLLISIONEFFECTSPAWNCOMPONENTDATA_TYPE_INFO);
    registry.register_type(COLLISIONEFFECTSPAWNCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(EFFECTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(EFFECTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONCONSTANTS_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONCONSTANTS_ARRAY_TYPE_INFO);
    registry.register_type(REGULARCAMERAVIEWDATA_TYPE_INFO);
    registry.register_type(REGULARCAMERAVIEWDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTSUPPRESSIONDATA_TYPE_INFO);
    registry.register_type(INPUTSUPPRESSIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONCLASSIFICATION_TYPE_INFO);
    registry.register_type(WEAPONCLASSIFICATION_ARRAY_TYPE_INFO);
    registry.register_type(BUOYANTPARTSDATA_TYPE_INFO);
    registry.register_type(BUOYANTPARTSDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUOYANTPARTS_TYPE_INFO);
    registry.register_type(BUOYANTPARTS_ARRAY_TYPE_INFO);
    registry.register_type(SKELETONCOLLISIONDATA_TYPE_INFO);
    registry.register_type(SKELETONCOLLISIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(BONECOLLISIONDATA_TYPE_INFO);
    registry.register_type(BONECOLLISIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONEDATA_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONESNAPAIMDATA_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONESNAPAIMDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONEPRIORITIESDATA_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONEPRIORITIESDATA_ARRAY_TYPE_INFO);
    registry.register_type(HITREACTIONTYPE_TYPE_INFO);
    registry.register_type(HITREACTIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(PITCHMODIFIER_TYPE_INFO);
    registry.register_type(PITCHMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(ACTIONSUPPRESSOR_TYPE_INFO);
    registry.register_type(ACTIONSUPPRESSOR_ARRAY_TYPE_INFO);
    registry.register_type(GROUPCOMPONENTDATA_TYPE_INFO);
    registry.register_type(GROUPCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLORPALETTE_TYPE_INFO);
    registry.register_type(COLORPALETTE_ARRAY_TYPE_INFO);
    registry.register_type(OBBCOLLISIONENTITYDATA_TYPE_INFO);
    registry.register_type(OBBCOLLISIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPHERECOLLISIONENTITYDATA_TYPE_INFO);
    registry.register_type(SPHERECOLLISIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTGAMESETTINGS_TYPE_INFO);
    registry.register_type(CLIENTGAMESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERTOCOMPONENTSONKILLEDMESSAGE_TYPE_INFO);
    registry.register_type(CHARACTERENTITYDATA_TYPE_INFO);
    registry.register_type(CHARACTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSOUNDDATA_TYPE_INFO);
    registry.register_type(CHARACTERSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSONVIEWMODE_TYPE_INFO);
    registry.register_type(PERSONVIEWMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERENTITYDEATHTYPE_TYPE_INFO);
    registry.register_type(CHARACTERENTITYDEATHTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERENTITYHITDIRECTION_TYPE_INFO);
    registry.register_type(CHARACTERENTITYHITDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERMESHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERMESHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERCUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERTOCOMPONENTSONACTIVEVIEWCHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(CHARACTERMASTERPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERMASTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARELATIVEINPUTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CAMERARELATIVEINPUTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTINPUTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ANTINPUTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTDRIVENCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ANTDRIVENCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERCAMERACOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERCAMERACOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERCAMERAENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERCAMERAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TARGETMODE_TYPE_INFO);
    registry.register_type(TARGETMODE_ARRAY_TYPE_INFO);
    registry.register_type(TARGETCAMERAENTITYDATA_TYPE_INFO);
    registry.register_type(TARGETCAMERAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOOKATCAMERAENTITYDATA_TYPE_INFO);
    registry.register_type(LOOKATCAMERAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAENTITYDATA_TYPE_INFO);
    registry.register_type(CAMERAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAENTITYBASEDATA_TYPE_INFO);
    registry.register_type(CAMERAENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPOSUREMODE_TYPE_INFO);
    registry.register_type(EXPOSUREMODE_ARRAY_TYPE_INFO);
    registry.register_type(CAMERALENSPRESET_TYPE_INFO);
    registry.register_type(CAMERALENSPRESET_ARRAY_TYPE_INFO);
    registry.register_type(CAMERABODYPRESET_TYPE_INFO);
    registry.register_type(CAMERABODYPRESET_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECAMERADATA_TYPE_INFO);
    registry.register_type(VEHICLECAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERALEAPDATA_TYPE_INFO);
    registry.register_type(CAMERALEAPDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICCAMERADATA_TYPE_INFO);
    registry.register_type(STATICCAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(CHASECAMERADATA_TYPE_INFO);
    registry.register_type(CHASECAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(FPSCAMERADATA_TYPE_INFO);
    registry.register_type(FPSCAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(HUDIMPACTDATA_TYPE_INFO);
    registry.register_type(HUDIMPACTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BLUREFFECTDATA_TYPE_INFO);
    registry.register_type(BLUREFFECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TURNEFFECTDATA_TYPE_INFO);
    registry.register_type(TURNEFFECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERASINECURVEDATA_TYPE_INFO);
    registry.register_type(CAMERASINECURVEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUILDCONFIGFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(BUILDCONFIGFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERASSET_TYPE_INFO);
    registry.register_type(CHARACTERASSET_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEASSET_TYPE_INFO);
    registry.register_type(VEHICLEASSET_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERBLUEPRINT_TYPE_INFO);
    registry.register_type(CHARACTERBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEBLUEPRINT_TYPE_INFO);
    registry.register_type(VEHICLEBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_TYPE_INFO);
    registry.register_type(BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANGERHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BANGERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANGERPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BANGERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANGERENTITYDATA_TYPE_INFO);
    registry.register_type(BANGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WORLDRENDERERSWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(WORLDRENDERERSWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CANNEDSCENARIOENTITYDATA_TYPE_INFO);
    registry.register_type(CANNEDSCENARIOENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WARPANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(WARPANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WARPANIMATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WARPANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CANNEDANIMATIONBINDING_TYPE_INFO);
    registry.register_type(CANNEDANIMATIONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(WARPANIMATIONBINDING_TYPE_INFO);
    registry.register_type(WARPANIMATIONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(WARNINGSYSTEMCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WARNINGSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WARNINGPLAYERTYPE_TYPE_INFO);
    registry.register_type(WARNINGPLAYERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(LENSFLARECOMPONENTDATA_TYPE_INFO);
    registry.register_type(LENSFLARECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPHEREREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO);
    registry.register_type(SPHEREREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOXREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO);
    registry.register_type(BOXREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO);
    registry.register_type(REFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LIGHTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(LIGHTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEINPUTSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLEINPUTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(HEALTHZONEINFO_TYPE_INFO);
    registry.register_type(HEALTHZONEINFO_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECAMERACONTROLBINDING_TYPE_INFO);
    registry.register_type(VEHICLECAMERACONTROLBINDING_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERREADBINDING_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERREADBINDING_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERBINDING_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERBINDING_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTCAMERATOCOMPONENTSINITMESSAGE_TYPE_INFO);
    registry.register_type(VEHICLETOCOMPONENTSSTARTDISABLEDDAMAGEDMESSAGE_TYPE_INFO);
    registry.register_type(CLIENTVEHICLETOCOMPONENTSHEALTHCHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(VEHICLEENTITYDATA_TYPE_INFO);
    registry.register_type(VEHICLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLESOUNDCATEGORY_TYPE_INFO);
    registry.register_type(AIVEHICLESOUNDCATEGORY_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATEDDRIVERENTITYDATA_TYPE_INFO);
    registry.register_type(ANIMATEDDRIVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(NORMALIZESETTINGS_TYPE_INFO);
    registry.register_type(NORMALIZESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESOUNDDATA_TYPE_INFO);
    registry.register_type(VEHICLESOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLELOCKABLEINFODATA_TYPE_INFO);
    registry.register_type(VEHICLELOCKABLEINFODATA_ARRAY_TYPE_INFO);
    registry.register_type(ANGLEOFIMPACTDATA_TYPE_INFO);
    registry.register_type(ANGLEOFIMPACTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MPMODEDATA_TYPE_INFO);
    registry.register_type(MPMODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEHEALTHZONEDATA_TYPE_INFO);
    registry.register_type(VEHICLEHEALTHZONEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEHUDDATA_TYPE_INFO);
    registry.register_type(VEHICLEHUDDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHILDMOVINGBODYDATA_TYPE_INFO);
    registry.register_type(CHILDMOVINGBODYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHILDROTATIONBODYDATA_TYPE_INFO);
    registry.register_type(CHILDROTATIONBODYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(IKCOMPONENTDATA_TYPE_INFO);
    registry.register_type(IKCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHASSISCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHASSISCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLDATA_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLPERSPEEDDATA_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLPERSPEEDDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLENUM_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLENUM_ARRAY_TYPE_INFO);
    registry.register_type(LANDINGGEARLOGICDATA_TYPE_INFO);
    registry.register_type(LANDINGGEARLOGICDATA_ARRAY_TYPE_INFO);
    registry.register_type(LANDINGGEARCONDITIONDATA_TYPE_INFO);
    registry.register_type(LANDINGGEARCONDITIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEWATEREFFECTDATA_TYPE_INFO);
    registry.register_type(VEHICLEWATEREFFECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEEXITPOINTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEEXITPOINTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACOMPONENTDATA_TYPE_INFO);
    registry.register_type(CAMERACOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANCECAMERADATA_TYPE_INFO);
    registry.register_type(STANCECAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(TURRETROTATIONINFO_TYPE_INFO);
    registry.register_type(TURRETROTATIONINFO_ARRAY_TYPE_INFO);
    registry.register_type(ROTATIONCHANNEL_TYPE_INFO);
    registry.register_type(ROTATIONCHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(CHILDBARRELCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHILDBARRELCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALIGNMENTDATA_TYPE_INFO);
    registry.register_type(ALIGNMENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROTORCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ROTORCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROTORMODELDATA_TYPE_INFO);
    registry.register_type(ROTORMODELDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRACKCOMPONENTDATA_TYPE_INFO);
    registry.register_type(TRACKCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(FAKEPHYSICSMESHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(FAKEPHYSICSMESHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MESHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECUSTOMIZATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLECUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEMESHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEMESHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROTATIONAXISENUM_TYPE_INFO);
    registry.register_type(ROTATIONAXISENUM_ARRAY_TYPE_INFO);
    registry.register_type(TRACKWHEELCOMPONENTDATA_TYPE_INFO);
    registry.register_type(TRACKWHEELCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WHEELCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WHEELCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANCEFILTERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STANCEFILTERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENGINECOMPONENTDATA_TYPE_INFO);
    registry.register_type(ENGINECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHILDCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHILDCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTRYCOMPONENTSOUNDDATA_TYPE_INFO);
    registry.register_type(ENTRYCOMPONENTSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANCESWITCHSOUNDDATA_TYPE_INFO);
    registry.register_type(STANCESWITCHSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACOMPONENTSOUNDDATA_TYPE_INFO);
    registry.register_type(CAMERACOMPONENTSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASICUNLOCKINFO_TYPE_INFO);
    registry.register_type(BASICUNLOCKINFO_ARRAY_TYPE_INFO);
    registry.register_type(VALUEUNLOCKASSET_TYPE_INFO);
    registry.register_type(VALUEUNLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(BOOLUNLOCKVALUEPAIR_TYPE_INFO);
    registry.register_type(BOOLUNLOCKVALUEPAIR_ARRAY_TYPE_INFO);
    registry.register_type(INTUNLOCKVALUEPAIR_TYPE_INFO);
    registry.register_type(INTUNLOCKVALUEPAIR_ARRAY_TYPE_INFO);
    registry.register_type(FLOATUNLOCKVALUEPAIR_TYPE_INFO);
    registry.register_type(FLOATUNLOCKVALUEPAIR_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKVALUEPAIR_TYPE_INFO);
    registry.register_type(UNLOCKVALUEPAIR_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKASSETPAIR_TYPE_INFO);
    registry.register_type(UNLOCKASSETPAIR_ARRAY_TYPE_INFO);
    registry.register_type(VISUALUNLOCKASSET_TYPE_INFO);
    registry.register_type(VISUALUNLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBLUEPRINTBUNDLE_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBLUEPRINTBUNDLE_ARRAY_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBUNDLEASSET_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBUNDLEASSET_ARRAY_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBUNDLEMODE_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBUNDLEMODE_ARRAY_TYPE_INFO);
    registry.register_type(MULTIUNLOCKASSET_TYPE_INFO);
    registry.register_type(MULTIUNLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKASSET_TYPE_INFO);
    registry.register_type(UNLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(MESHANDVARIATIONPAIR_TYPE_INFO);
    registry.register_type(MESHANDVARIATIONPAIR_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKASSETBASE_TYPE_INFO);
    registry.register_type(UNLOCKASSETBASE_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKAVAILABILITY_TYPE_INFO);
    registry.register_type(UNLOCKAVAILABILITY_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKUSERDATABASE_TYPE_INFO);
    registry.register_type(UNLOCKUSERDATABASE_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKCOMPONENTDATA_TYPE_INFO);
    registry.register_type(UNLOCKCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKSPAWNTYPE_TYPE_INFO);
    registry.register_type(UNLOCKSPAWNTYPE_ARRAY_TYPE_INFO);
    registry.register_type(UIMESSAGETYPE_TYPE_INFO);
    registry.register_type(UIMESSAGETYPE_ARRAY_TYPE_INFO);
    registry.register_type(LIGHTDIMMERENTITYDATA_TYPE_INFO);
    registry.register_type(LIGHTDIMMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(KINECTSERVICEDATA_TYPE_INFO);
    registry.register_type(KINECTSERVICEDATA_ARRAY_TYPE_INFO);
    registry.register_type(UIWORLDICONBEHAVIOR_TYPE_INFO);
    registry.register_type(UIWORLDICONBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(UICOMBATAREAASSET_TYPE_INFO);
    registry.register_type(UICOMBATAREAASSET_ARRAY_TYPE_INFO);
    registry.register_type(SPOTTINGTYPE_TYPE_INFO);
    registry.register_type(SPOTTINGTYPE_ARRAY_TYPE_INFO);
    registry.register_type(UIPARTDATA_TYPE_INFO);
    registry.register_type(UIPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCKINGTYPEASSET_TYPE_INFO);
    registry.register_type(LOCKINGTYPEASSET_ARRAY_TYPE_INFO);
    registry.register_type(CROSSHAIRTYPEASSET_TYPE_INFO);
    registry.register_type(CROSSHAIRTYPEASSET_ARRAY_TYPE_INFO);
    registry.register_type(UIPARTPROPERTYLIST_TYPE_INFO);
    registry.register_type(UIPARTPROPERTYLIST_ARRAY_TYPE_INFO);
    registry.register_type(UIPARTPROPERTIES_TYPE_INFO);
    registry.register_type(UIPARTPROPERTIES_ARRAY_TYPE_INFO);
    registry.register_type(UIHUDICON_TYPE_INFO);
    registry.register_type(UIHUDICON_ARRAY_TYPE_INFO);
    registry.register_type(UIPARTIDENTIFIER_TYPE_INFO);
    registry.register_type(UIPARTIDENTIFIER_ARRAY_TYPE_INFO);
    registry.register_type(COLLISIONMETHODENUM_TYPE_INFO);
    registry.register_type(COLLISIONMETHODENUM_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELGROUPHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELGROUPHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELGROUPPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELGROUPPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELGROUPENTITYDATA_TYPE_INFO);
    registry.register_type(STATICMODELGROUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELGROUPMEMBERDATA_TYPE_INFO);
    registry.register_type(STATICMODELGROUPMEMBERDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMESPLINEENTITYDATA_TYPE_INFO);
    registry.register_type(GAMESPLINEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMESPLINEDATA_TYPE_INFO);
    registry.register_type(GAMESPLINEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LICENSEEGAMESETTINGS_TYPE_INFO);
    registry.register_type(LICENSEEGAMESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SIGNIFICANCESETTINGS_TYPE_INFO);
    registry.register_type(SIGNIFICANCESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SKU_TYPE_INFO);
    registry.register_type(SKU_ARRAY_TYPE_INFO);
    registry.register_type(INTERACTIONENTITYDATA_TYPE_INFO);
    registry.register_type(INTERACTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PREDESTRUCTIONENTITYDATA_TYPE_INFO);
    registry.register_type(PREDESTRUCTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONENTITYDATA_TYPE_INFO);
    registry.register_type(EXPLOSIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONWINDFORCEDATA_TYPE_INFO);
    registry.register_type(EXPLOSIONWINDFORCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEINDICATIONTYPE_TYPE_INFO);
    registry.register_type(DAMAGEINDICATIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICGAMEPHYSICSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERANIMATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VOICEOVERANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERMANAGERCONTROLENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVERMANAGERCONTROLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DETACHEDSOUNDLISTENERENTITYDATA_TYPE_INFO);
    registry.register_type(DETACHEDSOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDLISTENERENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDAREAENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONENTITYTRACKINFO_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONENTITYTRACKINFO_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SERVERPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO);
    registry.register_type(CLIENTPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO);
    registry.register_type(PLAYANIMATIONDATA_TYPE_INFO);
    registry.register_type(PLAYANIMATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(FBPROXYCONTROLLERENTITYDATA_TYPE_INFO);
    registry.register_type(FBPROXYCONTROLLERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FBPROXYCONTROLLERENTITYBINDING_TYPE_INFO);
    registry.register_type(FBPROXYCONTROLLERENTITYBINDING_ARRAY_TYPE_INFO);
    registry.register_type(FACEPOSERENTITYDATA_TYPE_INFO);
    registry.register_type(FACEPOSERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSYNCREACHEDCLIENTMESSAGE_TYPE_INFO);
    registry.register_type(EVENTSYNCENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTSYNCENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PLAYERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMEENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(GAMEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTENTRYIDENUM_TYPE_INFO);
    registry.register_type(ANTENTRYIDENUM_ARRAY_TYPE_INFO);
    registry.register_type(ENTITLEMENTQUERY_TYPE_INFO);
    registry.register_type(ENTITLEMENTQUERY_ARRAY_TYPE_INFO);
    registry.register_type(ENTITLEMENTDATA_TYPE_INFO);
    registry.register_type(ENTITLEMENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLATFORMPROJECTID_TYPE_INFO);
    registry.register_type(PLATFORMPROJECTID_ARRAY_TYPE_INFO);
    registry.register_type(ENTITLEMENTPLATFORMTYPE_TYPE_INFO);
    registry.register_type(ENTITLEMENTPLATFORMTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ENTITLEMENTTYPE_TYPE_INFO);
    registry.register_type(ENTITLEMENTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ENSEMBLEPUBLISHERENTITYDATA_TYPE_INFO);
    registry.register_type(ENSEMBLEPUBLISHERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICMODELHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DYNAMICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICMODELPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DYNAMICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICMODELENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(NETFIRESTARTERCELL_TYPE_INFO);
    registry.register_type(NETFIRESTARTERCELL_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICFIREENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICFIREENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICFIRECELLFXASSET_TYPE_INFO);
    registry.register_type(DYNAMICFIRECELLFXASSET_ARRAY_TYPE_INFO);
    registry.register_type(CELLFX_TYPE_INFO);
    registry.register_type(CELLFX_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERLOOKATTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(CHARACTERLOOKATTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(UNDERFIRETRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(UNDERFIRETRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERINPUTTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERINPUTTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAENTERAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(CAMERAENTERAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERSECTIONTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(INTERSECTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERSECTIONTRIGGERCONDITION_TYPE_INFO);
    registry.register_type(INTERSECTIONTRIGGERCONDITION_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERTAKEOVERTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERTAKEOVERTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(DAMAGEAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLEARAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(CLEARAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESTATETRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(VEHICLESTATETRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERPOSEACTION_TYPE_INFO);
    registry.register_type(CHARACTERPOSEACTION_ARRAY_TYPE_INFO);
    registry.register_type(DELAYTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(DELAYTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTIPLETRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(MULTIPLETRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRIGGEREVENTENTITYDATA_TYPE_INFO);
    registry.register_type(TRIGGEREVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMBATACTIONTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(COMBATACTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GEOMETRYTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(GEOMETRYTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(AREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREATRIGGERINCLUDE_TYPE_INFO);
    registry.register_type(AREATRIGGERINCLUDE_ARRAY_TYPE_INFO);
    registry.register_type(TRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(TRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTPARTBOUNDINGBOXENTITYDATA_TYPE_INFO);
    registry.register_type(TESTPARTBOUNDINGBOXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ASSERTTIMEBOMBENTITYDATA_TYPE_INFO);
    registry.register_type(ASSERTTIMEBOMBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ASSERTTIMEBOMBBLUEPRINT_TYPE_INFO);
    registry.register_type(ASSERTTIMEBOMBBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(ATTACHMENTVERIFICATIONENTITYDATA_TYPE_INFO);
    registry.register_type(ATTACHMENTVERIFICATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLOSESTPOINTENTITYDATA_TYPE_INFO);
    registry.register_type(CLOSESTPOINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(JOINTVALIDATIONENTITYDATA_TYPE_INFO);
    registry.register_type(JOINTVALIDATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTPRESSENTITYDATA_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTPRESSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTPLAYBACKENTITYDATA_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTPLAYBACKENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTRECORDERENTITYDATA_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTRECORDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGGINGENTITYDATA_TYPE_INFO);
    registry.register_type(LOGGINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DESTRUCTIONCOMMANDENTITYDATA_TYPE_INFO);
    registry.register_type(DESTRUCTIONCOMMANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTPOINTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTPOINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERMOVEMENTSEQUENCEDATA_TYPE_INFO);
    registry.register_type(SOLDIERMOVEMENTSEQUENCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDEDINPUTDATA_TYPE_INFO);
    registry.register_type(RECORDEDINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTRECORDERDATA_TYPE_INFO);
    registry.register_type(INPUTRECORDERDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTRECORDERTRACKDATA_TYPE_INFO);
    registry.register_type(INPUTRECORDERTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONDATA_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAACTIONDATA_TYPE_INFO);
    registry.register_type(CAMERAACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAMOVEMENTACTIONMODE_TYPE_INFO);
    registry.register_type(CAMERAMOVEMENTACTIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONTIMEDATA_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONTIMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONRANDOMIZERDATA_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONRANDOMIZERDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONGROUPDATA_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONGROUPDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONROOT_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONROOT_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONDATA_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(ASSERTENTITYDATA_TYPE_INFO);
    registry.register_type(ASSERTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKDEBUGENTITYDATA_TYPE_INFO);
    registry.register_type(LINKDEBUGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELTAVIEWERTABLEENTITYDATA_TYPE_INFO);
    registry.register_type(DELTAVIEWERTABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELTAVIEWERMODE_TYPE_INFO);
    registry.register_type(DELTAVIEWERMODE_ARRAY_TYPE_INFO);
    registry.register_type(DELTAVIEWERCOLUMN_TYPE_INFO);
    registry.register_type(DELTAVIEWERCOLUMN_ARRAY_TYPE_INFO);
    registry.register_type(DELTAVIEWERCOLUMNVALUETYPE_TYPE_INFO);
    registry.register_type(DELTAVIEWERCOLUMNVALUETYPE_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYDEBUGENTITYDATA_TYPE_INFO);
    registry.register_type(PROPERTYDEBUGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYDEBUGGRAPHMODE_TYPE_INFO);
    registry.register_type(PROPERTYDEBUGGRAPHMODE_ARRAY_TYPE_INFO);
    registry.register_type(PRINTDEBUGTEXTENTITYDATA_TYPE_INFO);
    registry.register_type(PRINTDEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCULLIDCULLABLEEFFECTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTCULLIDCULLABLEEFFECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCULLIDCULLABLEEFFECTMODE_TYPE_INFO);
    registry.register_type(TESTCULLIDCULLABLEEFFECTMODE_ARRAY_TYPE_INFO);
    registry.register_type(TESTEFFECTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTEFFECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCASEENTITYEFFECTDATA_TYPE_INFO);
    registry.register_type(TESTCASEENTITYEFFECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCREENSHOTCOMPARISONENTITYDATA_TYPE_INFO);
    registry.register_type(SCREENSHOTCOMPARISONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCOMPONENTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTCOMPONENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTPHYSICSENTITYDATA_TYPE_INFO);
    registry.register_type(TESTPHYSICSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCASEENTITYDATA_TYPE_INFO);
    registry.register_type(TESTCASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGMENUITEMENTITYDATA_TYPE_INFO);
    registry.register_type(DEBUGMENUITEMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGMENUITEMTYPE_TYPE_INFO);
    registry.register_type(DEBUGMENUITEMTYPE_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGMENUSUBMENUENTITYDATA_TYPE_INFO);
    registry.register_type(DEBUGMENUSUBMENUENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONSOLECOMMANDTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(CONSOLECOMMANDTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONSOLECOMMANDENTITYDATA_TYPE_INFO);
    registry.register_type(CONSOLECOMMANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGTEXTENTITYDATA_TYPE_INFO);
    registry.register_type(DEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCOLLISIONEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTCOLLISIONEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCOLLISIONEVENTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(TESTCOLLISIONEVENTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TERRAINDYNAMICDECALENTITYDATA_TYPE_INFO);
    registry.register_type(TERRAINDYNAMICDECALENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SYNCEDSEQUENCEENTITYDATA_TYPE_INFO);
    registry.register_type(SYNCEDSEQUENCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMESUBVIEWDATA_TYPE_INFO);
    registry.register_type(GAMESUBVIEWDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPECTATORSUBVIEWDATA_TYPE_INFO);
    registry.register_type(SPECTATORSUBVIEWDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBLEVELSTATUSENTITYDATA_TYPE_INFO);
    registry.register_type(SUBLEVELSTATUSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBLEVELPRELOADENTITYDATA_TYPE_INFO);
    registry.register_type(SUBLEVELPRELOADENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERACTABLESTATICMODELENTITYDATA_TYPE_INFO);
    registry.register_type(INTERACTABLESTATICMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FENCEMODELENTITYDATA_TYPE_INFO);
    registry.register_type(FENCEMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LADDERENTITYDATA_TYPE_INFO);
    registry.register_type(LADDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELENTITYDATA_TYPE_INFO);
    registry.register_type(STATICMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELNETWORKINFO_TYPE_INFO);
    registry.register_type(STATICMODELNETWORKINFO_ARRAY_TYPE_INFO);
    registry.register_type(CHILDSTATICMODELNETWORKINFO_TYPE_INFO);
    registry.register_type(CHILDSTATICMODELNETWORKINFO_ARRAY_TYPE_INFO);
    registry.register_type(INDEXRANGE_TYPE_INFO);
    registry.register_type(INDEXRANGE_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSPARTINFO_TYPE_INFO);
    registry.register_type(PHYSICSPARTINFO_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESPAWNREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(VEHICLESPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSPAWNREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(CHARACTERSPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERTOCOMPONENTSSPAWNTEMPLATEMESSAGE_TYPE_INFO);
    registry.register_type(CHARACTERSPAWNTEMPLATEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALTERNATESPAWNENTITYDATA_TYPE_INFO);
    registry.register_type(ALTERNATESPAWNENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMEBEHAVIOURTEMPLATEDATA_TYPE_INFO);
    registry.register_type(GAMEBEHAVIOURTEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMESENSINGTEMPLATEDATA_TYPE_INFO);
    registry.register_type(GAMESENSINGTEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONSPAWNTEMPLATE_TYPE_INFO);
    registry.register_type(ANIMATIONSPAWNTEMPLATE_ARRAY_TYPE_INFO);
    registry.register_type(SPAWNREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(SPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTRYENTERRESTRICTION_TYPE_INFO);
    registry.register_type(ENTRYENTERRESTRICTION_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERSPAWNTYPE_TYPE_INFO);
    registry.register_type(PLAYERSPAWNTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SLOWMOTIONENTITYDATA_TYPE_INFO);
    registry.register_type(SLOWMOTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLLISIONNETSTATE_TYPE_INFO);
    registry.register_type(COLLISIONNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(SERVERSETTINGS_TYPE_INFO);
    registry.register_type(SERVERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CONGESTIONCONTROLSETTINGS_TYPE_INFO);
    registry.register_type(CONGESTIONCONTROLSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(MODELANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(MODELANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MODELANIMATIONTRANSFORMTYPE_TYPE_INFO);
    registry.register_type(MODELANIMATIONTRANSFORMTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MODELANIMATIONUPDATEORDER_TYPE_INFO);
    registry.register_type(MODELANIMATIONUPDATEORDER_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONENUMERATIONCHOICEENTITYDATA_TYPE_INFO);
    registry.register_type(ANIMATIONENUMERATIONCHOICEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONENUMERATIONENTITYDATA_TYPE_INFO);
    registry.register_type(ANIMATIONENUMERATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONSIGNALENTITYDATA_TYPE_INFO);
    registry.register_type(ANIMATIONSIGNALENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCORINGVISIBILITYTYPE_TYPE_INFO);
    registry.register_type(SCORINGVISIBILITYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(FLOATRECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(FLOATRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLVALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(BOOLVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLRECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(BOOLRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SYNCEDTIMELINESTATECHANGEMESSAGEBASE_TYPE_INFO);
    registry.register_type(SHAREDLOCKGATEENTITYDATA_TYPE_INFO);
    registry.register_type(SHAREDLOCKGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDLOCKOBSERVERENTITYDATA_TYPE_INFO);
    registry.register_type(SHAREDLOCKOBSERVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDLOCKCONTROLLERENTITYDATA_TYPE_INFO);
    registry.register_type(SHAREDLOCKCONTROLLERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDLOCKBASEENTITYDATA_TYPE_INFO);
    registry.register_type(SHAREDLOCKBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDLOCKASSET_TYPE_INFO);
    registry.register_type(SHAREDLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(MORPHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MORPHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLEMODELHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BREAKABLEMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLEMODELPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BREAKABLEMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLEMODELTOCOMPONENTSSPAWNPARTOBJECTSONCOLLAPSEMESSAGE_TYPE_INFO);
    registry.register_type(BREAKABLEMODELTOCOMPONENTSCOLLAPSEMESSAGE_TYPE_INFO);
    registry.register_type(BREAKABLEMODELENTITYDATA_TYPE_INFO);
    registry.register_type(BREAKABLEMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EDGEMODELCOMPONENTDATA_TYPE_INFO);
    registry.register_type(EDGEMODELCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTNETWORKID_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTNETWORKID_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLEPARTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BREAKABLEPARTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAWFILEDATA_TYPE_INFO);
    registry.register_type(RAWFILEDATA_ARRAY_TYPE_INFO);
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct FadeTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub keyframes: Vec<Option<LockedTypeObject /* FadeTrackKeyframe */>>,
    pub fade_screen: bool,
    pub fade_u_i: bool,
    pub fade_audio: bool,
    pub fade_movie: bool,
    pub fade_rumble: bool,
    pub block_input: bool,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait FadeTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* FadeTrackKeyframe */>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* FadeTrackKeyframe */>>;
    fn fade_screen(&self) -> &bool;
    fn fade_screen_mut(&mut self) -> &mut bool;
    fn fade_u_i(&self) -> &bool;
    fn fade_u_i_mut(&mut self) -> &mut bool;
    fn fade_audio(&self) -> &bool;
    fn fade_audio_mut(&mut self) -> &mut bool;
    fn fade_movie(&self) -> &bool;
    fn fade_movie_mut(&mut self) -> &mut bool;
    fn fade_rumble(&self) -> &bool;
    fn fade_rumble_mut(&mut self) -> &mut bool;
    fn block_input(&self) -> &bool;
    fn block_input_mut(&mut self) -> &mut bool;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl FadeTrackDataTrait for FadeTrackData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* FadeTrackKeyframe */>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* FadeTrackKeyframe */>> {
        &mut self.keyframes
    }
    fn fade_screen(&self) -> &bool {
        &self.fade_screen
    }
    fn fade_screen_mut(&mut self) -> &mut bool {
        &mut self.fade_screen
    }
    fn fade_u_i(&self) -> &bool {
        &self.fade_u_i
    }
    fn fade_u_i_mut(&mut self) -> &mut bool {
        &mut self.fade_u_i
    }
    fn fade_audio(&self) -> &bool {
        &self.fade_audio
    }
    fn fade_audio_mut(&mut self) -> &mut bool {
        &mut self.fade_audio
    }
    fn fade_movie(&self) -> &bool {
        &self.fade_movie
    }
    fn fade_movie_mut(&mut self) -> &mut bool {
        &mut self.fade_movie
    }
    fn fade_rumble(&self) -> &bool {
        &self.fade_rumble
    }
    fn fade_rumble_mut(&mut self) -> &mut bool {
        &mut self.fade_rumble
    }
    fn block_input(&self) -> &bool {
        &self.block_input
    }
    fn block_input_mut(&mut self) -> &mut bool {
        &mut self.block_input
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::timeline::TimelineTrackDataTrait for FadeTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for FadeTrackData {
}

impl super::core::DataBusPeerTrait for FadeTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FadeTrackData {
}

impl super::core::DataContainerTrait for FadeTrackData {
}

pub static FADETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackData",
    name_hash: 3131099932,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(FadeTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FadeTrackData as Default>::default())),
            create_boxed: || Box::new(<FadeTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                name_hash: 2213598044,
                flags: MemberInfoFlags::new(144),
                field_type: "FadeTrackKeyframe-Array",
                rust_offset: offset_of!(FadeTrackData, keyframes),
            },
            FieldInfoData {
                name: "FadeScreen",
                name_hash: 1880126671,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_screen),
            },
            FieldInfoData {
                name: "FadeUI",
                name_hash: 2515973727,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_u_i),
            },
            FieldInfoData {
                name: "FadeAudio",
                name_hash: 3169106133,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_audio),
            },
            FieldInfoData {
                name: "FadeMovie",
                name_hash: 3182278683,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_movie),
            },
            FieldInfoData {
                name: "FadeRumble",
                name_hash: 1825215970,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_rumble),
            },
            FieldInfoData {
                name: "BlockInput",
                name_hash: 3730121914,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, block_input),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(FadeTrackData, local_player_id),
            },
        ],
    }),
    array_type: Some(FADETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FadeTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        FADETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FADETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackData-Array",
    name_hash: 951943976,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FadeTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FadeTrackKeyframe {
    pub _glacier_base: super::core::DataContainer,
    pub time: f32,
    pub length: f32,
    pub fade_type: FadeTrackKeyframeType,
}

pub trait FadeTrackKeyframeTrait: super::core::DataContainerTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
    fn fade_type(&self) -> &FadeTrackKeyframeType;
    fn fade_type_mut(&mut self) -> &mut FadeTrackKeyframeType;
}

impl FadeTrackKeyframeTrait for FadeTrackKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
    fn fade_type(&self) -> &FadeTrackKeyframeType {
        &self.fade_type
    }
    fn fade_type_mut(&mut self) -> &mut FadeTrackKeyframeType {
        &mut self.fade_type
    }
}

impl super::core::DataContainerTrait for FadeTrackKeyframe {
}

pub static FADETRACKKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackKeyframe",
    name_hash: 3419347366,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(FadeTrackKeyframe, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FadeTrackKeyframe as Default>::default())),
            create_boxed: || Box::new(<FadeTrackKeyframe as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FadeTrackKeyframe, time),
            },
            FieldInfoData {
                name: "Length",
                name_hash: 2906827577,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FadeTrackKeyframe, length),
            },
            FieldInfoData {
                name: "FadeType",
                name_hash: 4001206363,
                flags: MemberInfoFlags::new(0),
                field_type: "FadeTrackKeyframeType",
                rust_offset: offset_of!(FadeTrackKeyframe, fade_type),
            },
        ],
    }),
    array_type: Some(FADETRACKKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FadeTrackKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        FADETRACKKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FADETRACKKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackKeyframe-Array",
    name_hash: 1255302674,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FadeTrackKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum FadeTrackKeyframeType {
    #[default]
    FadeTrackKeyframeType_FadeOut = 0,
    FadeTrackKeyframeType_FadeIn = 1,
    FadeTrackKeyframeTypeCount = 2,
}

pub static FADETRACKKEYFRAMETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackKeyframeType",
    name_hash: 3947968542,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(FADETRACKKEYFRAMETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FadeTrackKeyframeType {
    fn type_info(&self) -> &'static TypeInfo {
        FADETRACKKEYFRAMETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FADETRACKKEYFRAMETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackKeyframeType-Array",
    name_hash: 1391978794,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FadeTrackKeyframeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TrackBuilderData {
    pub _glacier_base: super::timeline::TimelineExtraData,
}

pub trait TrackBuilderDataTrait: super::timeline::TimelineExtraDataTrait {
}

impl TrackBuilderDataTrait for TrackBuilderData {
}

impl super::timeline::TimelineExtraDataTrait for TrackBuilderData {
}

impl super::core::DataContainerTrait for TrackBuilderData {
}

pub static TRACKBUILDERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackBuilderData",
    name_hash: 1289253755,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINEEXTRADATA_TYPE_INFO),
        super_class_offset: offset_of!(TrackBuilderData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrackBuilderData as Default>::default())),
            create_boxed: || Box::new(<TrackBuilderData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRACKBUILDERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TrackBuilderData {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKBUILDERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRACKBUILDERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackBuilderData-Array",
    name_hash: 936758095,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrackBuilderData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ActorToBlueprintGuidRow {
}

pub trait ActorToBlueprintGuidRowTrait: TypeObject {
}

impl ActorToBlueprintGuidRowTrait for ActorToBlueprintGuidRow {
}

pub static ACTORTOBLUEPRINTGUIDROW_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActorToBlueprintGuidRow",
    name_hash: 324017263,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ActorToBlueprintGuidRow as Default>::default())),
            create_boxed: || Box::new(<ActorToBlueprintGuidRow as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ACTORTOBLUEPRINTGUIDROW_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ActorToBlueprintGuidRow {
    fn type_info(&self) -> &'static TypeInfo {
        ACTORTOBLUEPRINTGUIDROW_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ACTORTOBLUEPRINTGUIDROW_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActorToBlueprintGuidRow-Array",
    name_hash: 1062541915,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ActorToBlueprintGuidRow"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CutsceneSavedSettingsData {
    pub _glacier_base: super::timeline::TimelineExtraData,
}

pub trait CutsceneSavedSettingsDataTrait: super::timeline::TimelineExtraDataTrait {
}

impl CutsceneSavedSettingsDataTrait for CutsceneSavedSettingsData {
}

impl super::timeline::TimelineExtraDataTrait for CutsceneSavedSettingsData {
}

impl super::core::DataContainerTrait for CutsceneSavedSettingsData {
}

pub static CUTSCENESAVEDSETTINGSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneSavedSettingsData",
    name_hash: 976132457,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINEEXTRADATA_TYPE_INFO),
        super_class_offset: offset_of!(CutsceneSavedSettingsData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CutsceneSavedSettingsData as Default>::default())),
            create_boxed: || Box::new(<CutsceneSavedSettingsData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CUTSCENESAVEDSETTINGSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CutsceneSavedSettingsData {
    fn type_info(&self) -> &'static TypeInfo {
        CUTSCENESAVEDSETTINGSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUTSCENESAVEDSETTINGSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneSavedSettingsData-Array",
    name_hash: 158429277,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CutsceneSavedSettingsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ImportTarget {
}

pub trait ImportTargetTrait: TypeObject {
}

impl ImportTargetTrait for ImportTarget {
}

pub static IMPORTTARGET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImportTarget",
    name_hash: 2549904137,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ImportTarget as Default>::default())),
            create_boxed: || Box::new(<ImportTarget as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(IMPORTTARGET_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ImportTarget {
    fn type_info(&self) -> &'static TypeInfo {
        IMPORTTARGET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static IMPORTTARGET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImportTarget-Array",
    name_hash: 1898940605,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ImportTarget"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ImporterSource {
    #[default]
    DCC = 0,
    ANT = 1,
}

pub static IMPORTERSOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImporterSource",
    name_hash: 1801453426,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(IMPORTERSOURCE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ImporterSource {
    fn type_info(&self) -> &'static TypeInfo {
        IMPORTERSOURCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static IMPORTERSOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImporterSource-Array",
    name_hash: 2406184518,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ImporterSource"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CutsceneSavedSettingsPathType {
    #[default]
    PathType_Absolute = 0,
    PathType_Relative = 1,
}

pub static CUTSCENESAVEDSETTINGS_PATHTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneSavedSettings_PathType",
    name_hash: 1551501491,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CUTSCENESAVEDSETTINGS_PATHTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CutsceneSavedSettingsPathType {
    fn type_info(&self) -> &'static TypeInfo {
        CUTSCENESAVEDSETTINGS_PATHTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUTSCENESAVEDSETTINGS_PATHTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneSavedSettings_PathType-Array",
    name_hash: 1423897607,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CutsceneSavedSettings_PathType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CutsceneQualityLevel {
    #[default]
    CutsceneQualityLevel_Invalid = 4294967295,
    CutsceneQualityLevel_Low = 0,
    CutsceneQualityLevel_Medium = 1,
    CutsceneQualityLevel_High = 2,
    CutsceneQualityLevel_VeryHigh = 3,
    CutsceneQualityLevel_Uncompressed = 4,
}

pub static CUTSCENEQUALITYLEVEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneQualityLevel",
    name_hash: 1779706914,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CUTSCENEQUALITYLEVEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CutsceneQualityLevel {
    fn type_info(&self) -> &'static TypeInfo {
        CUTSCENEQUALITYLEVEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUTSCENEQUALITYLEVEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneQualityLevel-Array",
    name_hash: 3170609814,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CutsceneQualityLevel"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CutsceneActorType {
    #[default]
    Invalid = 4294967295,
    Character = 0,
    Camera = 1,
    SchematicProp = 2,
    Prop = 3,
    Max = 4,
}

pub static CUTSCENEACTORTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneActorType",
    name_hash: 342160810,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CUTSCENEACTORTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CutsceneActorType {
    fn type_info(&self) -> &'static TypeInfo {
        CUTSCENEACTORTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUTSCENEACTORTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneActorType-Array",
    name_hash: 480047134,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CutsceneActorType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraTrackData {
    pub _glacier_base: PhysicalCameraTrackData,
    pub layered_transform_track: Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>,
}

pub trait CameraTrackDataTrait: PhysicalCameraTrackDataTrait {
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
}

impl CameraTrackDataTrait for CameraTrackData {
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &mut self.layered_transform_track
    }
}

impl PhysicalCameraTrackDataTrait for CameraTrackData {
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children_mut()
    }
}

impl CameraTrackBaseDataTrait for CameraTrackData {
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraTrackData {
}

impl super::core::DataBusPeerTrait for CameraTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraTrackData {
}

impl super::core::DataContainerTrait for CameraTrackData {
}

pub static CAMERATRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTrackData",
    name_hash: 2120493411,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICALCAMERATRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraTrackData as Default>::default())),
            create_boxed: || Box::new(<CameraTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LayeredTransformTrack",
                name_hash: 76253860,
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(CameraTrackData, layered_transform_track),
            },
        ],
    }),
    array_type: Some(CAMERATRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERATRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERATRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTrackData-Array",
    name_hash: 4206878039,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraTrackBaseData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub transition_data_pack: Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */>,
}

pub trait CameraTrackBaseDataTrait: super::timeline::TimelineTrackDataTrait {
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */>;
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */>;
}

impl CameraTrackBaseDataTrait for CameraTrackBaseData {
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        &self.transition_data_pack
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        &mut self.transition_data_pack
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraTrackBaseData {
}

impl super::core::DataBusPeerTrait for CameraTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraTrackBaseData {
}

impl super::core::DataContainerTrait for CameraTrackBaseData {
}

pub static CAMERATRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTrackBaseData",
    name_hash: 45839478,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraTrackBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraTrackBaseData as Default>::default())),
            create_boxed: || Box::new(<CameraTrackBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TransitionDataPack",
                name_hash: 600691939,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraTransitionEffectDataPack",
                rust_offset: offset_of!(CameraTrackBaseData, transition_data_pack),
            },
        ],
    }),
    array_type: Some(CAMERATRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CameraTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERATRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERATRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTrackBaseData-Array",
    name_hash: 2114607426,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraLookAtLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub look_at_transform_track: Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>,
}

pub trait CameraLookAtLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn look_at_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
    fn look_at_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
}

impl CameraLookAtLayerDataTrait for CameraLookAtLayerData {
    fn look_at_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &self.look_at_transform_track
    }
    fn look_at_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &mut self.look_at_transform_track
    }
}

impl super::timeline::TransformLayerDataTrait for CameraLookAtLayerData {
    fn weight(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraLookAtLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraLookAtLayerData {
}

impl super::core::DataBusPeerTrait for CameraLookAtLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraLookAtLayerData {
}

impl super::core::DataContainerTrait for CameraLookAtLayerData {
}

pub static CAMERALOOKATLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLookAtLayerData",
    name_hash: 4119172125,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraLookAtLayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraLookAtLayerData as Default>::default())),
            create_boxed: || Box::new(<CameraLookAtLayerData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LookAtTransformTrack",
                name_hash: 1843567284,
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(CameraLookAtLayerData, look_at_transform_track),
            },
        ],
    }),
    array_type: Some(CAMERALOOKATLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraLookAtLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERALOOKATLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERALOOKATLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLookAtLayerData-Array",
    name_hash: 1142939561,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraLookAtLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraFocusTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub default_transform: super::core::LinearTransform,
    pub layered_transform_track: Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>,
}

pub trait CameraFocusTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn default_transform(&self) -> &super::core::LinearTransform;
    fn default_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
}

impl CameraFocusTrackDataTrait for CameraFocusTrackData {
    fn default_transform(&self) -> &super::core::LinearTransform {
        &self.default_transform
    }
    fn default_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.default_transform
    }
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &mut self.layered_transform_track
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraFocusTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraFocusTrackData {
}

impl super::core::DataBusPeerTrait for CameraFocusTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraFocusTrackData {
}

impl super::core::DataContainerTrait for CameraFocusTrackData {
}

pub static CAMERAFOCUSTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraFocusTrackData",
    name_hash: 4269759023,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraFocusTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraFocusTrackData as Default>::default())),
            create_boxed: || Box::new(<CameraFocusTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultTransform",
                name_hash: 1812491362,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CameraFocusTrackData, default_transform),
            },
            FieldInfoData {
                name: "LayeredTransformTrack",
                name_hash: 76253860,
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(CameraFocusTrackData, layered_transform_track),
            },
        ],
    }),
    array_type: Some(CAMERAFOCUSTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraFocusTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAFOCUSTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAFOCUSTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraFocusTrackData-Array",
    name_hash: 3844581275,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraFocusTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraDofTrackData {
    pub _glacier_base: super::timeline::EntityTrackBaseData,
}

pub trait CameraDofTrackDataTrait: super::timeline::EntityTrackBaseDataTrait {
}

impl CameraDofTrackDataTrait for CameraDofTrackData {
}

impl super::timeline::EntityTrackBaseDataTrait for CameraDofTrackData {
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children_mut()
    }
    fn inherited_to_child_conversation_lines(&self) -> &bool {
        self._glacier_base.inherited_to_child_conversation_lines()
    }
    fn inherited_to_child_conversation_lines_mut(&mut self) -> &mut bool {
        self._glacier_base.inherited_to_child_conversation_lines_mut()
    }
    fn required(&self) -> &bool {
        self._glacier_base.required()
    }
    fn required_mut(&mut self) -> &mut bool {
        self._glacier_base.required_mut()
    }
    fn handle_deleted_entity(&self) -> &bool {
        self._glacier_base.handle_deleted_entity()
    }
    fn handle_deleted_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.handle_deleted_entity_mut()
    }
    fn entity_sharing_policy(&self) -> &super::timeline::EntityTrackSharingPolicy {
        self._glacier_base.entity_sharing_policy()
    }
    fn entity_sharing_policy_mut(&mut self) -> &mut super::timeline::EntityTrackSharingPolicy {
        self._glacier_base.entity_sharing_policy_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraDofTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraDofTrackData {
}

impl super::core::DataBusPeerTrait for CameraDofTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraDofTrackData {
}

impl super::core::DataContainerTrait for CameraDofTrackData {
}

pub static CAMERADOFTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDofTrackData",
    name_hash: 3638011886,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::ENTITYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraDofTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDofTrackData as Default>::default())),
            create_boxed: || Box::new(<CameraDofTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CAMERADOFTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDofTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADOFTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADOFTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDofTrackData-Array",
    name_hash: 1129038042,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDofTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraDirectorTrackData {
    pub _glacier_base: CameraDirectorTrackBaseData,
    pub keyframes: Vec<Option<LockedTypeObject /* CameraDirectorKeyframe */>>,
}

pub trait CameraDirectorTrackDataTrait: CameraDirectorTrackBaseDataTrait {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* CameraDirectorKeyframe */>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CameraDirectorKeyframe */>>;
}

impl CameraDirectorTrackDataTrait for CameraDirectorTrackData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* CameraDirectorKeyframe */>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CameraDirectorKeyframe */>> {
        &mut self.keyframes
    }
}

impl CameraDirectorTrackBaseDataTrait for CameraDirectorTrackData {
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children_mut()
    }
    fn post_timeline_camera(&self) -> &Option<LockedTypeObject /* CameraTrackBaseData */> {
        self._glacier_base.post_timeline_camera()
    }
    fn post_timeline_camera_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraTrackBaseData */> {
        self._glacier_base.post_timeline_camera_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraDirectorTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraDirectorTrackData {
}

impl super::core::DataBusPeerTrait for CameraDirectorTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraDirectorTrackData {
}

impl super::core::DataContainerTrait for CameraDirectorTrackData {
}

pub static CAMERADIRECTORTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorTrackData",
    name_hash: 3001090515,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERADIRECTORTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraDirectorTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorTrackData as Default>::default())),
            create_boxed: || Box::new(<CameraDirectorTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                name_hash: 2213598044,
                flags: MemberInfoFlags::new(144),
                field_type: "CameraDirectorKeyframe-Array",
                rust_offset: offset_of!(CameraDirectorTrackData, keyframes),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDirectorTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorTrackData-Array",
    name_hash: 3463433447,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraDirectorTrackBaseData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub children: Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>,
    pub post_timeline_camera: Option<LockedTypeObject /* CameraTrackBaseData */>,
}

pub trait CameraDirectorTrackBaseDataTrait: super::timeline::TimelineTrackDataTrait {
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
    fn post_timeline_camera(&self) -> &Option<LockedTypeObject /* CameraTrackBaseData */>;
    fn post_timeline_camera_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraTrackBaseData */>;
}

impl CameraDirectorTrackBaseDataTrait for CameraDirectorTrackBaseData {
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &self.children
    }
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &mut self.children
    }
    fn post_timeline_camera(&self) -> &Option<LockedTypeObject /* CameraTrackBaseData */> {
        &self.post_timeline_camera
    }
    fn post_timeline_camera_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraTrackBaseData */> {
        &mut self.post_timeline_camera
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraDirectorTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraDirectorTrackBaseData {
}

impl super::core::DataBusPeerTrait for CameraDirectorTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraDirectorTrackBaseData {
}

impl super::core::DataContainerTrait for CameraDirectorTrackBaseData {
}

pub static CAMERADIRECTORTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorTrackBaseData",
    name_hash: 1636144774,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraDirectorTrackBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorTrackBaseData as Default>::default())),
            create_boxed: || Box::new(<CameraDirectorTrackBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Children",
                name_hash: 1297796054,
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(CameraDirectorTrackBaseData, children),
            },
            FieldInfoData {
                name: "PostTimelineCamera",
                name_hash: 74490623,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraTrackBaseData",
                rust_offset: offset_of!(CameraDirectorTrackBaseData, post_timeline_camera),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CameraDirectorTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorTrackBaseData-Array",
    name_hash: 3985048498,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraDirectorKeyframe {
    pub _glacier_base: super::timeline::TimelineKeyframeData,
    pub time: f32,
    pub camera_track: Option<LockedTypeObject /* CameraTrackBaseData */>,
    pub camera_cut_behavior: CameraCutBehavior,
    pub parent_director_track: Option<LockedTypeObject /* CameraDirectorTrackBaseData */>,
}

pub trait CameraDirectorKeyframeTrait: super::timeline::TimelineKeyframeDataTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn camera_track(&self) -> &Option<LockedTypeObject /* CameraTrackBaseData */>;
    fn camera_track_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraTrackBaseData */>;
    fn camera_cut_behavior(&self) -> &CameraCutBehavior;
    fn camera_cut_behavior_mut(&mut self) -> &mut CameraCutBehavior;
    fn parent_director_track(&self) -> &Option<LockedTypeObject /* CameraDirectorTrackBaseData */>;
    fn parent_director_track_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraDirectorTrackBaseData */>;
}

impl CameraDirectorKeyframeTrait for CameraDirectorKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn camera_track(&self) -> &Option<LockedTypeObject /* CameraTrackBaseData */> {
        &self.camera_track
    }
    fn camera_track_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraTrackBaseData */> {
        &mut self.camera_track
    }
    fn camera_cut_behavior(&self) -> &CameraCutBehavior {
        &self.camera_cut_behavior
    }
    fn camera_cut_behavior_mut(&mut self) -> &mut CameraCutBehavior {
        &mut self.camera_cut_behavior
    }
    fn parent_director_track(&self) -> &Option<LockedTypeObject /* CameraDirectorTrackBaseData */> {
        &self.parent_director_track
    }
    fn parent_director_track_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraDirectorTrackBaseData */> {
        &mut self.parent_director_track
    }
}

impl super::timeline::TimelineKeyframeDataTrait for CameraDirectorKeyframe {
}

impl super::core::DataContainerTrait for CameraDirectorKeyframe {
}

pub static CAMERADIRECTORKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorKeyframe",
    name_hash: 2174731526,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINEKEYFRAMEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraDirectorKeyframe, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorKeyframe as Default>::default())),
            create_boxed: || Box::new(<CameraDirectorKeyframe as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraDirectorKeyframe, time),
            },
            FieldInfoData {
                name: "CameraTrack",
                name_hash: 3165350035,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraTrackBaseData",
                rust_offset: offset_of!(CameraDirectorKeyframe, camera_track),
            },
            FieldInfoData {
                name: "CameraCutBehavior",
                name_hash: 2152221842,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraCutBehavior",
                rust_offset: offset_of!(CameraDirectorKeyframe, camera_cut_behavior),
            },
            FieldInfoData {
                name: "ParentDirectorTrack",
                name_hash: 3434684678,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraDirectorTrackBaseData",
                rust_offset: offset_of!(CameraDirectorKeyframe, parent_director_track),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDirectorKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorKeyframe-Array",
    name_hash: 2905215538,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CameraCutBehavior {
    #[default]
    CameraCutBehavior_CameraCut = 0,
    CameraCutBehavior_StraightCut = 1,
    CameraCutBehavior_Continuous = 2,
}

pub static CAMERACUTBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutBehavior",
    name_hash: 2152221842,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CAMERACUTBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CameraCutBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACUTBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERACUTBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutBehavior-Array",
    name_hash: 726487974,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraCutBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraDirectorProxyTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub children: Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>,
    pub keyframes: Vec<Option<LockedTypeObject /* CameraDirectorProxyKeyframe */>>,
}

pub trait CameraDirectorProxyTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* CameraDirectorProxyKeyframe */>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CameraDirectorProxyKeyframe */>>;
}

impl CameraDirectorProxyTrackDataTrait for CameraDirectorProxyTrackData {
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &self.children
    }
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &mut self.children
    }
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* CameraDirectorProxyKeyframe */>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CameraDirectorProxyKeyframe */>> {
        &mut self.keyframes
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraDirectorProxyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraDirectorProxyTrackData {
}

impl super::core::DataBusPeerTrait for CameraDirectorProxyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraDirectorProxyTrackData {
}

impl super::core::DataContainerTrait for CameraDirectorProxyTrackData {
}

pub static CAMERADIRECTORPROXYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorProxyTrackData",
    name_hash: 3212204127,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraDirectorProxyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorProxyTrackData as Default>::default())),
            create_boxed: || Box::new(<CameraDirectorProxyTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Children",
                name_hash: 1297796054,
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(CameraDirectorProxyTrackData, children),
            },
            FieldInfoData {
                name: "Keyframes",
                name_hash: 2213598044,
                flags: MemberInfoFlags::new(144),
                field_type: "CameraDirectorProxyKeyframe-Array",
                rust_offset: offset_of!(CameraDirectorProxyTrackData, keyframes),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORPROXYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDirectorProxyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORPROXYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORPROXYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorProxyTrackData-Array",
    name_hash: 671812971,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorProxyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraDirectorProxyKeyframe {
    pub _glacier_base: super::core::DataContainer,
    pub time: f32,
    pub jump_cut: bool,
}

pub trait CameraDirectorProxyKeyframeTrait: super::core::DataContainerTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn jump_cut(&self) -> &bool;
    fn jump_cut_mut(&mut self) -> &mut bool;
}

impl CameraDirectorProxyKeyframeTrait for CameraDirectorProxyKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn jump_cut(&self) -> &bool {
        &self.jump_cut
    }
    fn jump_cut_mut(&mut self) -> &mut bool {
        &mut self.jump_cut
    }
}

impl super::core::DataContainerTrait for CameraDirectorProxyKeyframe {
}

pub static CAMERADIRECTORPROXYKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorProxyKeyframe",
    name_hash: 2589136906,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CameraDirectorProxyKeyframe, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorProxyKeyframe as Default>::default())),
            create_boxed: || Box::new(<CameraDirectorProxyKeyframe as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraDirectorProxyKeyframe, time),
            },
            FieldInfoData {
                name: "JumpCut",
                name_hash: 198892549,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraDirectorProxyKeyframe, jump_cut),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORPROXYKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDirectorProxyKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORPROXYKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORPROXYKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorProxyKeyframe-Array",
    name_hash: 2198819646,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorProxyKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraCutVisibilityTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub set_initial_visibility_on_start: bool,
    pub initial_visibility: bool,
    pub visibility: bool,
    pub keyframes: Vec<Option<LockedTypeObject /* CameraCutVisibilityKeyframe */>>,
    pub start_time: f32,
    pub end_time: f32,
}

pub trait CameraCutVisibilityTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn set_initial_visibility_on_start(&self) -> &bool;
    fn set_initial_visibility_on_start_mut(&mut self) -> &mut bool;
    fn initial_visibility(&self) -> &bool;
    fn initial_visibility_mut(&mut self) -> &mut bool;
    fn visibility(&self) -> &bool;
    fn visibility_mut(&mut self) -> &mut bool;
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* CameraCutVisibilityKeyframe */>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CameraCutVisibilityKeyframe */>>;
    fn start_time(&self) -> &f32;
    fn start_time_mut(&mut self) -> &mut f32;
    fn end_time(&self) -> &f32;
    fn end_time_mut(&mut self) -> &mut f32;
}

impl CameraCutVisibilityTrackDataTrait for CameraCutVisibilityTrackData {
    fn set_initial_visibility_on_start(&self) -> &bool {
        &self.set_initial_visibility_on_start
    }
    fn set_initial_visibility_on_start_mut(&mut self) -> &mut bool {
        &mut self.set_initial_visibility_on_start
    }
    fn initial_visibility(&self) -> &bool {
        &self.initial_visibility
    }
    fn initial_visibility_mut(&mut self) -> &mut bool {
        &mut self.initial_visibility
    }
    fn visibility(&self) -> &bool {
        &self.visibility
    }
    fn visibility_mut(&mut self) -> &mut bool {
        &mut self.visibility
    }
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* CameraCutVisibilityKeyframe */>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CameraCutVisibilityKeyframe */>> {
        &mut self.keyframes
    }
    fn start_time(&self) -> &f32 {
        &self.start_time
    }
    fn start_time_mut(&mut self) -> &mut f32 {
        &mut self.start_time
    }
    fn end_time(&self) -> &f32 {
        &self.end_time
    }
    fn end_time_mut(&mut self) -> &mut f32 {
        &mut self.end_time
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraCutVisibilityTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraCutVisibilityTrackData {
}

impl super::core::DataBusPeerTrait for CameraCutVisibilityTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraCutVisibilityTrackData {
}

impl super::core::DataContainerTrait for CameraCutVisibilityTrackData {
}

pub static CAMERACUTVISIBILITYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutVisibilityTrackData",
    name_hash: 3902098311,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraCutVisibilityTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraCutVisibilityTrackData as Default>::default())),
            create_boxed: || Box::new(<CameraCutVisibilityTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SetInitialVisibilityOnStart",
                name_hash: 553686174,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, set_initial_visibility_on_start),
            },
            FieldInfoData {
                name: "InitialVisibility",
                name_hash: 1067630877,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, initial_visibility),
            },
            FieldInfoData {
                name: "Visibility",
                name_hash: 1708270083,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, visibility),
            },
            FieldInfoData {
                name: "Keyframes",
                name_hash: 2213598044,
                flags: MemberInfoFlags::new(144),
                field_type: "CameraCutVisibilityKeyframe-Array",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, keyframes),
            },
            FieldInfoData {
                name: "StartTime",
                name_hash: 3727579056,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, start_time),
            },
            FieldInfoData {
                name: "EndTime",
                name_hash: 4286530879,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, end_time),
            },
        ],
    }),
    array_type: Some(CAMERACUTVISIBILITYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraCutVisibilityTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACUTVISIBILITYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERACUTVISIBILITYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutVisibilityTrackData-Array",
    name_hash: 3978398771,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraCutVisibilityTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraCutVisibilityKeyframe {
    pub _glacier_base: super::core::DataContainer,
    pub time: f32,
    pub guid_chain: Vec<glacier_util::guid::Guid>,
}

pub trait CameraCutVisibilityKeyframeTrait: super::core::DataContainerTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn guid_chain(&self) -> &Vec<glacier_util::guid::Guid>;
    fn guid_chain_mut(&mut self) -> &mut Vec<glacier_util::guid::Guid>;
}

impl CameraCutVisibilityKeyframeTrait for CameraCutVisibilityKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn guid_chain(&self) -> &Vec<glacier_util::guid::Guid> {
        &self.guid_chain
    }
    fn guid_chain_mut(&mut self) -> &mut Vec<glacier_util::guid::Guid> {
        &mut self.guid_chain
    }
}

impl super::core::DataContainerTrait for CameraCutVisibilityKeyframe {
}

pub static CAMERACUTVISIBILITYKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutVisibilityKeyframe",
    name_hash: 3666417362,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CameraCutVisibilityKeyframe, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraCutVisibilityKeyframe as Default>::default())),
            create_boxed: || Box::new(<CameraCutVisibilityKeyframe as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraCutVisibilityKeyframe, time),
            },
            FieldInfoData {
                name: "GuidChain",
                name_hash: 851720151,
                flags: MemberInfoFlags::new(144),
                field_type: "Guid-Array",
                rust_offset: offset_of!(CameraCutVisibilityKeyframe, guid_chain),
            },
        ],
    }),
    array_type: Some(CAMERACUTVISIBILITYKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraCutVisibilityKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACUTVISIBILITYKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERACUTVISIBILITYKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutVisibilityKeyframe-Array",
    name_hash: 4049407590,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraCutVisibilityKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraAttachTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
}

pub trait CameraAttachTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
}

impl CameraAttachTransformLayerDataTrait for CameraAttachTransformLayerData {
}

impl super::timeline::TransformLayerDataTrait for CameraAttachTransformLayerData {
    fn weight(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraAttachTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraAttachTransformLayerData {
}

impl super::core::DataBusPeerTrait for CameraAttachTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraAttachTransformLayerData {
}

impl super::core::DataContainerTrait for CameraAttachTransformLayerData {
}

pub static CAMERAATTACHTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraAttachTransformLayerData",
    name_hash: 1640488744,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraAttachTransformLayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraAttachTransformLayerData as Default>::default())),
            create_boxed: || Box::new(<CameraAttachTransformLayerData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CAMERAATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraAttachTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAATTACHTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraAttachTransformLayerData-Array",
    name_hash: 263225500,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraAttachTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AttachTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub attach_entity: Option<LockedTypeObject /* super::entity::GameObjectData */>,
    pub attach_offset: super::core::LinearTransform,
    pub child_bone_name: String,
    pub parent_bone_name: String,
    pub attach_entity_guid_chain: Vec<glacier_util::guid::Guid>,
    pub force_use_parent_trajectory_transform: bool,
}

pub trait AttachTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn attach_entity(&self) -> &Option<LockedTypeObject /* super::entity::GameObjectData */>;
    fn attach_entity_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::GameObjectData */>;
    fn attach_offset(&self) -> &super::core::LinearTransform;
    fn attach_offset_mut(&mut self) -> &mut super::core::LinearTransform;
    fn child_bone_name(&self) -> &String;
    fn child_bone_name_mut(&mut self) -> &mut String;
    fn parent_bone_name(&self) -> &String;
    fn parent_bone_name_mut(&mut self) -> &mut String;
    fn attach_entity_guid_chain(&self) -> &Vec<glacier_util::guid::Guid>;
    fn attach_entity_guid_chain_mut(&mut self) -> &mut Vec<glacier_util::guid::Guid>;
    fn force_use_parent_trajectory_transform(&self) -> &bool;
    fn force_use_parent_trajectory_transform_mut(&mut self) -> &mut bool;
}

impl AttachTransformLayerDataTrait for AttachTransformLayerData {
    fn attach_entity(&self) -> &Option<LockedTypeObject /* super::entity::GameObjectData */> {
        &self.attach_entity
    }
    fn attach_entity_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::GameObjectData */> {
        &mut self.attach_entity
    }
    fn attach_offset(&self) -> &super::core::LinearTransform {
        &self.attach_offset
    }
    fn attach_offset_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.attach_offset
    }
    fn child_bone_name(&self) -> &String {
        &self.child_bone_name
    }
    fn child_bone_name_mut(&mut self) -> &mut String {
        &mut self.child_bone_name
    }
    fn parent_bone_name(&self) -> &String {
        &self.parent_bone_name
    }
    fn parent_bone_name_mut(&mut self) -> &mut String {
        &mut self.parent_bone_name
    }
    fn attach_entity_guid_chain(&self) -> &Vec<glacier_util::guid::Guid> {
        &self.attach_entity_guid_chain
    }
    fn attach_entity_guid_chain_mut(&mut self) -> &mut Vec<glacier_util::guid::Guid> {
        &mut self.attach_entity_guid_chain
    }
    fn force_use_parent_trajectory_transform(&self) -> &bool {
        &self.force_use_parent_trajectory_transform
    }
    fn force_use_parent_trajectory_transform_mut(&mut self) -> &mut bool {
        &mut self.force_use_parent_trajectory_transform
    }
}

impl super::timeline::TransformLayerDataTrait for AttachTransformLayerData {
    fn weight(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for AttachTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for AttachTransformLayerData {
}

impl super::core::DataBusPeerTrait for AttachTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AttachTransformLayerData {
}

impl super::core::DataContainerTrait for AttachTransformLayerData {
}

pub static ATTACHTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttachTransformLayerData",
    name_hash: 2647378385,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        super_class_offset: offset_of!(AttachTransformLayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AttachTransformLayerData as Default>::default())),
            create_boxed: || Box::new(<AttachTransformLayerData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AttachEntity",
                name_hash: 18464949,
                flags: MemberInfoFlags::new(0),
                field_type: "GameObjectData",
                rust_offset: offset_of!(AttachTransformLayerData, attach_entity),
            },
            FieldInfoData {
                name: "AttachOffset",
                name_hash: 4087467523,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AttachTransformLayerData, attach_offset),
            },
            FieldInfoData {
                name: "ChildBoneName",
                name_hash: 4274354190,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AttachTransformLayerData, child_bone_name),
            },
            FieldInfoData {
                name: "ParentBoneName",
                name_hash: 3146124696,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AttachTransformLayerData, parent_bone_name),
            },
            FieldInfoData {
                name: "AttachEntityGuidChain",
                name_hash: 673475495,
                flags: MemberInfoFlags::new(144),
                field_type: "Guid-Array",
                rust_offset: offset_of!(AttachTransformLayerData, attach_entity_guid_chain),
            },
            FieldInfoData {
                name: "ForceUseParentTrajectoryTransform",
                name_hash: 2273463184,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AttachTransformLayerData, force_use_parent_trajectory_transform),
            },
        ],
    }),
    array_type: Some(ATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AttachTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ATTACHTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttachTransformLayerData-Array",
    name_hash: 2795789285,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AttachTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTTrajectoryTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
}

pub trait ANTTrajectoryTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
}

impl ANTTrajectoryTransformLayerDataTrait for ANTTrajectoryTransformLayerData {
}

impl super::timeline::TransformLayerDataTrait for ANTTrajectoryTransformLayerData {
    fn weight(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTTrajectoryTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTTrajectoryTransformLayerData {
}

impl super::core::DataBusPeerTrait for ANTTrajectoryTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTTrajectoryTransformLayerData {
}

impl super::core::DataContainerTrait for ANTTrajectoryTransformLayerData {
}

pub static ANTTRAJECTORYTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTTrajectoryTransformLayerData",
    name_hash: 3529792634,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTTrajectoryTransformLayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTTrajectoryTransformLayerData as Default>::default())),
            create_boxed: || Box::new(<ANTTrajectoryTransformLayerData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANTTRAJECTORYTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTTrajectoryTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTTRAJECTORYTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTTRAJECTORYTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTTrajectoryTransformLayerData-Array",
    name_hash: 1409347406,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTTrajectoryTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTSlotTrackData {
    pub _glacier_base: super::timeline::PropertyTrackBaseData,
    pub slot_name: String,
}

pub trait ANTSlotTrackDataTrait: super::timeline::PropertyTrackBaseDataTrait {
    fn slot_name(&self) -> &String;
    fn slot_name_mut(&mut self) -> &mut String;
}

impl ANTSlotTrackDataTrait for ANTSlotTrackData {
    fn slot_name(&self) -> &String {
        &self.slot_name
    }
    fn slot_name_mut(&mut self) -> &mut String {
        &mut self.slot_name
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTSlotTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTSlotTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTSlotTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTSlotTrackData {
}

impl super::core::DataBusPeerTrait for ANTSlotTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTSlotTrackData {
}

impl super::core::DataContainerTrait for ANTSlotTrackData {
}

pub static ANTSLOTTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTSlotTrackData",
    name_hash: 2876403653,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::PROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTSlotTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTSlotTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTSlotTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SlotName",
                name_hash: 3918019622,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ANTSlotTrackData, slot_name),
            },
        ],
    }),
    array_type: Some(ANTSLOTTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTSlotTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTSLOTTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTSLOTTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTSlotTrackData-Array",
    name_hash: 1843161073,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTSlotTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTSignalTrackData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub signal_tracks: Vec<Option<LockedTypeObject /* super::timeline::PropertyTrackBaseData */>>,
}

pub trait ANTSignalTrackDataTrait: super::timeline::LinkTrackDataTrait {
    fn signal_tracks(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::PropertyTrackBaseData */>>;
    fn signal_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::PropertyTrackBaseData */>>;
}

impl ANTSignalTrackDataTrait for ANTSignalTrackData {
    fn signal_tracks(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::PropertyTrackBaseData */>> {
        &self.signal_tracks
    }
    fn signal_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::PropertyTrackBaseData */>> {
        &mut self.signal_tracks
    }
}

impl super::timeline::LinkTrackDataTrait for ANTSignalTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTSignalTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTSignalTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTSignalTrackData {
}

impl super::core::DataBusPeerTrait for ANTSignalTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTSignalTrackData {
}

impl super::core::DataContainerTrait for ANTSignalTrackData {
}

pub static ANTSIGNALTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTSignalTrackData",
    name_hash: 1410459967,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTSignalTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTSignalTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTSignalTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SignalTracks",
                name_hash: 508732263,
                flags: MemberInfoFlags::new(144),
                field_type: "PropertyTrackBaseData-Array",
                rust_offset: offset_of!(ANTSignalTrackData, signal_tracks),
            },
        ],
    }),
    array_type: Some(ANTSIGNALTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTSignalTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTSIGNALTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTSIGNALTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTSignalTrackData-Array",
    name_hash: 935083659,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTSignalTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTEnumTrackData {
    pub _glacier_base: super::timeline::PropertyTrackBaseData,
    pub keyframes: Vec<BoxedTypeObject /* ANTEnumKeyframe */>,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: i32,
}

pub trait ANTEnumTrackDataTrait: super::timeline::PropertyTrackBaseDataTrait {
    fn keyframes(&self) -> &Vec<BoxedTypeObject /* ANTEnumKeyframe */>;
    fn keyframes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* ANTEnumKeyframe */>;
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &i32;
    fn reset_value_mut(&mut self) -> &mut i32;
}

impl ANTEnumTrackDataTrait for ANTEnumTrackData {
    fn keyframes(&self) -> &Vec<BoxedTypeObject /* ANTEnumKeyframe */> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* ANTEnumKeyframe */> {
        &mut self.keyframes
    }
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &i32 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut i32 {
        &mut self.reset_value
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTEnumTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTEnumTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTEnumTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTEnumTrackData {
}

impl super::core::DataBusPeerTrait for ANTEnumTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTEnumTrackData {
}

impl super::core::DataContainerTrait for ANTEnumTrackData {
}

pub static ANTENUMTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEnumTrackData",
    name_hash: 964639474,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::PROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTEnumTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTEnumTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTEnumTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                name_hash: 2213598044,
                flags: MemberInfoFlags::new(144),
                field_type: "ANTEnumKeyframe-Array",
                rust_offset: offset_of!(ANTEnumTrackData, keyframes),
            },
            FieldInfoData {
                name: "Signal",
                name_hash: 3351504027,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTEnumTrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                name_hash: 3249666794,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTEnumTrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                name_hash: 3178763515,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ANTEnumTrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTENUMTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTEnumTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTENUMTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTENUMTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEnumTrackData-Array",
    name_hash: 1642680774,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTEnumTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTEnumKeyframe {
    pub time: f32,
    pub value: i32,
}

pub trait ANTEnumKeyframeTrait: TypeObject {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl ANTEnumKeyframeTrait for ANTEnumKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

pub static ANTENUMKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEnumKeyframe",
    name_hash: 242894663,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTEnumKeyframe as Default>::default())),
            create_boxed: || Box::new(<ANTEnumKeyframe as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ANTEnumKeyframe, time),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ANTEnumKeyframe, value),
            },
        ],
    }),
    array_type: Some(ANTENUMKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ANTEnumKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        ANTENUMKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTENUMKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEnumKeyframe-Array",
    name_hash: 4193523827,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTEnumKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTVec3TrackData {
    pub _glacier_base: super::timeline::Vec3TrackData,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: super::core::Vec3,
}

pub trait ANTVec3TrackDataTrait: super::timeline::Vec3TrackDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &super::core::Vec3;
    fn reset_value_mut(&mut self) -> &mut super::core::Vec3;
}

impl ANTVec3TrackDataTrait for ANTVec3TrackData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &super::core::Vec3 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.reset_value
    }
}

impl super::timeline::Vec3TrackDataTrait for ANTVec3TrackData {
    fn x(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.x()
    }
    fn x_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.x_mut()
    }
    fn y(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.y()
    }
    fn y_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.y_mut()
    }
    fn z(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.z()
    }
    fn z_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.z_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTVec3TrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTVec3TrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTVec3TrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTVec3TrackData {
}

impl super::core::DataBusPeerTrait for ANTVec3TrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTVec3TrackData {
}

impl super::core::DataContainerTrait for ANTVec3TrackData {
}

pub static ANTVEC3TRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTVec3TrackData",
    name_hash: 3390358402,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::VEC3TRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTVec3TrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTVec3TrackData as Default>::default())),
            create_boxed: || Box::new(<ANTVec3TrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                name_hash: 3351504027,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTVec3TrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                name_hash: 3249666794,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTVec3TrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                name_hash: 3178763515,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ANTVec3TrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTVEC3TRACKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ANTVec3TrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTVEC3TRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTVEC3TRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTVec3TrackData-Array",
    name_hash: 549733046,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTVec3TrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTIntTrackData {
    pub _glacier_base: super::timeline::IntTrackData,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: i32,
}

pub trait ANTIntTrackDataTrait: super::timeline::IntTrackDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &i32;
    fn reset_value_mut(&mut self) -> &mut i32;
}

impl ANTIntTrackDataTrait for ANTIntTrackData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &i32 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut i32 {
        &mut self.reset_value
    }
}

impl super::timeline::IntTrackDataTrait for ANTIntTrackData {
    fn keyframes(&self) -> &Vec<BoxedTypeObject /* super::timeline::IntKeyframe */> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::timeline::IntKeyframe */> {
        self._glacier_base.keyframes_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTIntTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTIntTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTIntTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTIntTrackData {
}

impl super::core::DataBusPeerTrait for ANTIntTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTIntTrackData {
}

impl super::core::DataContainerTrait for ANTIntTrackData {
}

pub static ANTINTTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTIntTrackData",
    name_hash: 440741906,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::INTTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTIntTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTIntTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTIntTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                name_hash: 3351504027,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTIntTrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                name_hash: 3249666794,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTIntTrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                name_hash: 3178763515,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ANTIntTrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTINTTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTIntTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTINTTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTINTTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTIntTrackData-Array",
    name_hash: 3007764262,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTIntTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTFloatTrackData {
    pub _glacier_base: super::timeline::FloatTrackData,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: f32,
}

pub trait ANTFloatTrackDataTrait: super::timeline::FloatTrackDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &f32;
    fn reset_value_mut(&mut self) -> &mut f32;
}

impl ANTFloatTrackDataTrait for ANTFloatTrackData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &f32 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut f32 {
        &mut self.reset_value
    }
}

impl super::timeline::FloatTrackDataTrait for ANTFloatTrackData {
    fn curve_data(&self) -> &Option<LockedTypeObject /* super::timeline::CurveData */> {
        self._glacier_base.curve_data()
    }
    fn curve_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::CurveData */> {
        self._glacier_base.curve_data_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTFloatTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTFloatTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTFloatTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTFloatTrackData {
}

impl super::core::DataBusPeerTrait for ANTFloatTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTFloatTrackData {
}

impl super::core::DataContainerTrait for ANTFloatTrackData {
}

pub static ANTFLOATTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTFloatTrackData",
    name_hash: 2604431249,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::FLOATTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTFloatTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTFloatTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTFloatTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                name_hash: 3351504027,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTFloatTrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                name_hash: 3249666794,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTFloatTrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                name_hash: 3178763515,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ANTFloatTrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTFLOATTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTFloatTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTFLOATTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTFLOATTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTFloatTrackData-Array",
    name_hash: 3616823589,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTFloatTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTBoolTrackData {
    pub _glacier_base: super::timeline::BoolTrackData,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: bool,
}

pub trait ANTBoolTrackDataTrait: super::timeline::BoolTrackDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &bool;
    fn reset_value_mut(&mut self) -> &mut bool;
}

impl ANTBoolTrackDataTrait for ANTBoolTrackData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &bool {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut bool {
        &mut self.reset_value
    }
}

impl super::timeline::BoolTrackDataTrait for ANTBoolTrackData {
    fn keyframes(&self) -> &Vec<BoxedTypeObject /* super::timeline::BoolKeyframe */> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::timeline::BoolKeyframe */> {
        self._glacier_base.keyframes_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTBoolTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTBoolTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTBoolTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTBoolTrackData {
}

impl super::core::DataBusPeerTrait for ANTBoolTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTBoolTrackData {
}

impl super::core::DataContainerTrait for ANTBoolTrackData {
}

pub static ANTBOOLTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoolTrackData",
    name_hash: 1489025903,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::BOOLTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTBoolTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTBoolTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTBoolTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                name_hash: 3351504027,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTBoolTrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                name_hash: 3249666794,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoolTrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                name_hash: 3178763515,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoolTrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTBOOLTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTBoolTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTBOOLTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTBOOLTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoolTrackData-Array",
    name_hash: 1149303131,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTBoolTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTEvalTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub eval_data: Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */>,
}

pub trait ANTEvalTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn eval_data(&self) -> &Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */>;
    fn eval_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */>;
}

impl ANTEvalTrackDataTrait for ANTEvalTrackData {
    fn eval_data(&self) -> &Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */> {
        &self.eval_data
    }
    fn eval_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */> {
        &mut self.eval_data
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTEvalTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTEvalTrackData {
}

impl super::core::DataBusPeerTrait for ANTEvalTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTEvalTrackData {
}

impl super::core::DataContainerTrait for ANTEvalTrackData {
}

pub static ANTEVALTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEvalTrackData",
    name_hash: 2538367263,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTEvalTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTEvalTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTEvalTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EvalData",
                name_hash: 1831397003,
                flags: MemberInfoFlags::new(0),
                field_type: "ANTEvaluatorData",
                rust_offset: offset_of!(ANTEvalTrackData, eval_data),
            },
        ],
    }),
    array_type: Some(ANTEVALTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTEvalTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTEVALTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTEVALTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEvalTrackData-Array",
    name_hash: 1898638763,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTEvalTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTControlTrackData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub eval_data: Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */>,
    pub teleport_keyframes: Vec<BoxedTypeObject /* TeleportKeyframe */>,
    pub hide_when_no_clip: bool,
    pub force_disable_animation_l_o_d: bool,
    pub allow_previous_animations_to_carry_forward: bool,
}

pub trait ANTControlTrackDataTrait: super::timeline::LinkTrackDataTrait {
    fn eval_data(&self) -> &Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */>;
    fn eval_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */>;
    fn teleport_keyframes(&self) -> &Vec<BoxedTypeObject /* TeleportKeyframe */>;
    fn teleport_keyframes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TeleportKeyframe */>;
    fn hide_when_no_clip(&self) -> &bool;
    fn hide_when_no_clip_mut(&mut self) -> &mut bool;
    fn force_disable_animation_l_o_d(&self) -> &bool;
    fn force_disable_animation_l_o_d_mut(&mut self) -> &mut bool;
    fn allow_previous_animations_to_carry_forward(&self) -> &bool;
    fn allow_previous_animations_to_carry_forward_mut(&mut self) -> &mut bool;
}

impl ANTControlTrackDataTrait for ANTControlTrackData {
    fn eval_data(&self) -> &Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */> {
        &self.eval_data
    }
    fn eval_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_timeline::ANTEvaluatorData */> {
        &mut self.eval_data
    }
    fn teleport_keyframes(&self) -> &Vec<BoxedTypeObject /* TeleportKeyframe */> {
        &self.teleport_keyframes
    }
    fn teleport_keyframes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TeleportKeyframe */> {
        &mut self.teleport_keyframes
    }
    fn hide_when_no_clip(&self) -> &bool {
        &self.hide_when_no_clip
    }
    fn hide_when_no_clip_mut(&mut self) -> &mut bool {
        &mut self.hide_when_no_clip
    }
    fn force_disable_animation_l_o_d(&self) -> &bool {
        &self.force_disable_animation_l_o_d
    }
    fn force_disable_animation_l_o_d_mut(&mut self) -> &mut bool {
        &mut self.force_disable_animation_l_o_d
    }
    fn allow_previous_animations_to_carry_forward(&self) -> &bool {
        &self.allow_previous_animations_to_carry_forward
    }
    fn allow_previous_animations_to_carry_forward_mut(&mut self) -> &mut bool {
        &mut self.allow_previous_animations_to_carry_forward
    }
}

impl super::timeline::LinkTrackDataTrait for ANTControlTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTControlTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTControlTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTControlTrackData {
}

impl super::core::DataBusPeerTrait for ANTControlTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTControlTrackData {
}

impl super::core::DataContainerTrait for ANTControlTrackData {
}

pub static ANTCONTROLTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTControlTrackData",
    name_hash: 3515402182,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTControlTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTControlTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTControlTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EvalData",
                name_hash: 1831397003,
                flags: MemberInfoFlags::new(0),
                field_type: "ANTEvaluatorData",
                rust_offset: offset_of!(ANTControlTrackData, eval_data),
            },
            FieldInfoData {
                name: "TeleportKeyframes",
                name_hash: 3329633053,
                flags: MemberInfoFlags::new(144),
                field_type: "TeleportKeyframe-Array",
                rust_offset: offset_of!(ANTControlTrackData, teleport_keyframes),
            },
            FieldInfoData {
                name: "HideWhenNoClip",
                name_hash: 3625267206,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTControlTrackData, hide_when_no_clip),
            },
            FieldInfoData {
                name: "ForceDisableAnimationLOD",
                name_hash: 1403774109,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTControlTrackData, force_disable_animation_l_o_d),
            },
            FieldInfoData {
                name: "AllowPreviousAnimationsToCarryForward",
                name_hash: 1717980051,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTControlTrackData, allow_previous_animations_to_carry_forward),
            },
        ],
    }),
    array_type: Some(ANTCONTROLTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTControlTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTCONTROLTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTCONTROLTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTControlTrackData-Array",
    name_hash: 1095394674,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTControlTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TeleportKeyframe {
    pub time: f32,
}

pub trait TeleportKeyframeTrait: TypeObject {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
}

impl TeleportKeyframeTrait for TeleportKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
}

pub static TELEPORTKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeleportKeyframe",
    name_hash: 361199022,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeleportKeyframe as Default>::default())),
            create_boxed: || Box::new(<TeleportKeyframe as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TeleportKeyframe, time),
            },
        ],
    }),
    array_type: Some(TELEPORTKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TeleportKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        TELEPORTKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TELEPORTKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeleportKeyframe-Array",
    name_hash: 786374170,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeleportKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTBoneTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub bone_name: String,
}

pub trait ANTBoneTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
}

impl ANTBoneTransformLayerDataTrait for ANTBoneTransformLayerData {
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
}

impl super::timeline::TransformLayerDataTrait for ANTBoneTransformLayerData {
    fn weight(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTBoneTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTBoneTransformLayerData {
}

impl super::core::DataBusPeerTrait for ANTBoneTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTBoneTransformLayerData {
}

impl super::core::DataContainerTrait for ANTBoneTransformLayerData {
}

pub static ANTBONETRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneTransformLayerData",
    name_hash: 2876454951,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTBoneTransformLayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTBoneTransformLayerData as Default>::default())),
            create_boxed: || Box::new(<ANTBoneTransformLayerData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BoneName",
                name_hash: 1590647844,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ANTBoneTransformLayerData, bone_name),
            },
        ],
    }),
    array_type: Some(ANTBONETRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTBoneTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTBONETRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTBONETRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneTransformLayerData-Array",
    name_hash: 4203391379,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTBoneTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTBoneTrackData {
    pub _glacier_base: super::timeline::LayeredTransformTrackData,
    pub bone_name: String,
    pub apply_layered_transform: bool,
    pub relative_to_parent: bool,
    pub apply90_degree_correction: bool,
}

pub trait ANTBoneTrackDataTrait: super::timeline::LayeredTransformTrackDataTrait {
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
    fn apply_layered_transform(&self) -> &bool;
    fn apply_layered_transform_mut(&mut self) -> &mut bool;
    fn relative_to_parent(&self) -> &bool;
    fn relative_to_parent_mut(&mut self) -> &mut bool;
    fn apply90_degree_correction(&self) -> &bool;
    fn apply90_degree_correction_mut(&mut self) -> &mut bool;
}

impl ANTBoneTrackDataTrait for ANTBoneTrackData {
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
    fn apply_layered_transform(&self) -> &bool {
        &self.apply_layered_transform
    }
    fn apply_layered_transform_mut(&mut self) -> &mut bool {
        &mut self.apply_layered_transform
    }
    fn relative_to_parent(&self) -> &bool {
        &self.relative_to_parent
    }
    fn relative_to_parent_mut(&mut self) -> &mut bool {
        &mut self.relative_to_parent
    }
    fn apply90_degree_correction(&self) -> &bool {
        &self.apply90_degree_correction
    }
    fn apply90_degree_correction_mut(&mut self) -> &mut bool {
        &mut self.apply90_degree_correction
    }
}

impl super::timeline::LayeredTransformTrackDataTrait for ANTBoneTrackData {
    fn layer_tracks(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TransformLayerData */>> {
        self._glacier_base.layer_tracks()
    }
    fn layer_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TransformLayerData */>> {
        self._glacier_base.layer_tracks_mut()
    }
    fn use_timeline_space(&self) -> &bool {
        self._glacier_base.use_timeline_space()
    }
    fn use_timeline_space_mut(&mut self) -> &mut bool {
        self._glacier_base.use_timeline_space_mut()
    }
    fn transform_space_enabled(&self) -> &bool {
        self._glacier_base.transform_space_enabled()
    }
    fn transform_space_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.transform_space_enabled_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTBoneTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTBoneTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTBoneTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTBoneTrackData {
}

impl super::core::DataBusPeerTrait for ANTBoneTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTBoneTrackData {
}

impl super::core::DataContainerTrait for ANTBoneTrackData {
}

pub static ANTBONETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneTrackData",
    name_hash: 372788871,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LAYEREDTRANSFORMTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTBoneTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTBoneTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTBoneTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BoneName",
                name_hash: 1590647844,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ANTBoneTrackData, bone_name),
            },
            FieldInfoData {
                name: "ApplyLayeredTransform",
                name_hash: 2541686175,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoneTrackData, apply_layered_transform),
            },
            FieldInfoData {
                name: "RelativeToParent",
                name_hash: 1891411894,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoneTrackData, relative_to_parent),
            },
            FieldInfoData {
                name: "Apply90DegreeCorrection",
                name_hash: 882084858,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoneTrackData, apply90_degree_correction),
            },
        ],
    }),
    array_type: Some(ANTBONETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTBoneTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTBONETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTBONETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneTrackData-Array",
    name_hash: 2008731443,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTBoneTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTBoneAnimationTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub layered_transform_track: Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>,
    pub ant_eval_track: Option<LockedTypeObject /* ANTEvalTrackData */>,
    pub bone_tracks: Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>,
}

pub trait ANTBoneAnimationTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
    fn ant_eval_track(&self) -> &Option<LockedTypeObject /* ANTEvalTrackData */>;
    fn ant_eval_track_mut(&mut self) -> &mut Option<LockedTypeObject /* ANTEvalTrackData */>;
    fn bone_tracks(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
    fn bone_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
}

impl ANTBoneAnimationTrackDataTrait for ANTBoneAnimationTrackData {
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &mut self.layered_transform_track
    }
    fn ant_eval_track(&self) -> &Option<LockedTypeObject /* ANTEvalTrackData */> {
        &self.ant_eval_track
    }
    fn ant_eval_track_mut(&mut self) -> &mut Option<LockedTypeObject /* ANTEvalTrackData */> {
        &mut self.ant_eval_track
    }
    fn bone_tracks(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &self.bone_tracks
    }
    fn bone_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &mut self.bone_tracks
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTBoneAnimationTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTBoneAnimationTrackData {
}

impl super::core::DataBusPeerTrait for ANTBoneAnimationTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTBoneAnimationTrackData {
}

impl super::core::DataContainerTrait for ANTBoneAnimationTrackData {
}

pub static ANTBONEANIMATIONTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneAnimationTrackData",
    name_hash: 2858082449,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTBoneAnimationTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTBoneAnimationTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTBoneAnimationTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LayeredTransformTrack",
                name_hash: 76253860,
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(ANTBoneAnimationTrackData, layered_transform_track),
            },
            FieldInfoData {
                name: "AntEvalTrack",
                name_hash: 481914351,
                flags: MemberInfoFlags::new(0),
                field_type: "ANTEvalTrackData",
                rust_offset: offset_of!(ANTBoneAnimationTrackData, ant_eval_track),
            },
            FieldInfoData {
                name: "BoneTracks",
                name_hash: 1565739807,
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(ANTBoneAnimationTrackData, bone_tracks),
            },
        ],
    }),
    array_type: Some(ANTBONEANIMATIONTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTBoneAnimationTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTBONEANIMATIONTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTBONEANIMATIONTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneAnimationTrackData-Array",
    name_hash: 3894247973,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTBoneAnimationTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTAnimatableCameraTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
}

pub trait ANTAnimatableCameraTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
}

impl ANTAnimatableCameraTransformLayerDataTrait for ANTAnimatableCameraTransformLayerData {
}

impl super::timeline::TransformLayerDataTrait for ANTAnimatableCameraTransformLayerData {
    fn weight(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTAnimatableCameraTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTAnimatableCameraTransformLayerData {
}

impl super::core::DataBusPeerTrait for ANTAnimatableCameraTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTAnimatableCameraTransformLayerData {
}

impl super::core::DataContainerTrait for ANTAnimatableCameraTransformLayerData {
}

pub static ANTANIMATABLECAMERATRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTAnimatableCameraTransformLayerData",
    name_hash: 1633773516,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTAnimatableCameraTransformLayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTAnimatableCameraTransformLayerData as Default>::default())),
            create_boxed: || Box::new(<ANTAnimatableCameraTransformLayerData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANTANIMATABLECAMERATRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTAnimatableCameraTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTANIMATABLECAMERATRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTANIMATABLECAMERATRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTAnimatableCameraTransformLayerData-Array",
    name_hash: 1633806456,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTAnimatableCameraTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ANTAnimatableCameraTrackData {
    pub _glacier_base: PhysicalCameraTrackData,
    pub layered_transform_track: Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>,
    pub ant_control_track: Option<LockedTypeObject /* ANTControlTrackData */>,
    pub camera_actor: super::ant::AntRef,
}

pub trait ANTAnimatableCameraTrackDataTrait: PhysicalCameraTrackDataTrait {
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
    fn ant_control_track(&self) -> &Option<LockedTypeObject /* ANTControlTrackData */>;
    fn ant_control_track_mut(&mut self) -> &mut Option<LockedTypeObject /* ANTControlTrackData */>;
    fn camera_actor(&self) -> &super::ant::AntRef;
    fn camera_actor_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ANTAnimatableCameraTrackDataTrait for ANTAnimatableCameraTrackData {
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &mut self.layered_transform_track
    }
    fn ant_control_track(&self) -> &Option<LockedTypeObject /* ANTControlTrackData */> {
        &self.ant_control_track
    }
    fn ant_control_track_mut(&mut self) -> &mut Option<LockedTypeObject /* ANTControlTrackData */> {
        &mut self.ant_control_track
    }
    fn camera_actor(&self) -> &super::ant::AntRef {
        &self.camera_actor
    }
    fn camera_actor_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.camera_actor
    }
}

impl PhysicalCameraTrackDataTrait for ANTAnimatableCameraTrackData {
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children_mut()
    }
}

impl CameraTrackBaseDataTrait for ANTAnimatableCameraTrackData {
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTAnimatableCameraTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTAnimatableCameraTrackData {
}

impl super::core::DataBusPeerTrait for ANTAnimatableCameraTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTAnimatableCameraTrackData {
}

impl super::core::DataContainerTrait for ANTAnimatableCameraTrackData {
}

pub static ANTANIMATABLECAMERATRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTAnimatableCameraTrackData",
    name_hash: 637186764,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICALCAMERATRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ANTAnimatableCameraTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTAnimatableCameraTrackData as Default>::default())),
            create_boxed: || Box::new(<ANTAnimatableCameraTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LayeredTransformTrack",
                name_hash: 76253860,
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(ANTAnimatableCameraTrackData, layered_transform_track),
            },
            FieldInfoData {
                name: "AntControlTrack",
                name_hash: 1022018294,
                flags: MemberInfoFlags::new(0),
                field_type: "ANTControlTrackData",
                rust_offset: offset_of!(ANTAnimatableCameraTrackData, ant_control_track),
            },
            FieldInfoData {
                name: "CameraActor",
                name_hash: 3196590327,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTAnimatableCameraTrackData, camera_actor),
            },
        ],
    }),
    array_type: Some(ANTANIMATABLECAMERATRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTAnimatableCameraTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTANIMATABLECAMERATRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTANIMATABLECAMERATRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTAnimatableCameraTrackData-Array",
    name_hash: 3297211256,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTAnimatableCameraTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimationPoseTrackData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub layer_tracks: Vec<Option<LockedTypeObject /* AnimationPoseLayerData */>>,
}

pub trait AnimationPoseTrackDataTrait: super::timeline::LinkTrackDataTrait {
    fn layer_tracks(&self) -> &Vec<Option<LockedTypeObject /* AnimationPoseLayerData */>>;
    fn layer_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* AnimationPoseLayerData */>>;
}

impl AnimationPoseTrackDataTrait for AnimationPoseTrackData {
    fn layer_tracks(&self) -> &Vec<Option<LockedTypeObject /* AnimationPoseLayerData */>> {
        &self.layer_tracks
    }
    fn layer_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* AnimationPoseLayerData */>> {
        &mut self.layer_tracks
    }
}

impl super::timeline::LinkTrackDataTrait for AnimationPoseTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for AnimationPoseTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for AnimationPoseTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for AnimationPoseTrackData {
}

impl super::core::DataBusPeerTrait for AnimationPoseTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationPoseTrackData {
}

impl super::core::DataContainerTrait for AnimationPoseTrackData {
}

pub static ANIMATIONPOSETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseTrackData",
    name_hash: 3069809829,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(AnimationPoseTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationPoseTrackData as Default>::default())),
            create_boxed: || Box::new(<AnimationPoseTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LayerTracks",
                name_hash: 948975898,
                flags: MemberInfoFlags::new(144),
                field_type: "AnimationPoseLayerData-Array",
                rust_offset: offset_of!(AnimationPoseTrackData, layer_tracks),
            },
        ],
    }),
    array_type: Some(ANIMATIONPOSETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationPoseTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPOSETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPOSETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseTrackData-Array",
    name_hash: 3813403921,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationPoseTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimationPoseLayerRootData {
    pub _glacier_base: super::timeline::GroupTrackRootData,
    pub keyframes: Vec<Option<LockedTypeObject /* AnimationPoseKeyframe */>>,
}

pub trait AnimationPoseLayerRootDataTrait: super::timeline::GroupTrackRootDataTrait {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* AnimationPoseKeyframe */>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* AnimationPoseKeyframe */>>;
}

impl AnimationPoseLayerRootDataTrait for AnimationPoseLayerRootData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* AnimationPoseKeyframe */>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* AnimationPoseKeyframe */>> {
        &mut self.keyframes
    }
}

impl super::timeline::GroupTrackRootDataTrait for AnimationPoseLayerRootData {
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        self._glacier_base.children_mut()
    }
}

impl super::core::AssetTrait for AnimationPoseLayerRootData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AnimationPoseLayerRootData {
}

pub static ANIMATIONPOSELAYERROOTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseLayerRootData",
    name_hash: 1240030991,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::GROUPTRACKROOTDATA_TYPE_INFO),
        super_class_offset: offset_of!(AnimationPoseLayerRootData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationPoseLayerRootData as Default>::default())),
            create_boxed: || Box::new(<AnimationPoseLayerRootData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                name_hash: 2213598044,
                flags: MemberInfoFlags::new(144),
                field_type: "AnimationPoseKeyframe-Array",
                rust_offset: offset_of!(AnimationPoseLayerRootData, keyframes),
            },
        ],
    }),
    array_type: Some(ANIMATIONPOSELAYERROOTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationPoseLayerRootData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPOSELAYERROOTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPOSELAYERROOTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseLayerRootData-Array",
    name_hash: 1335204795,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationPoseLayerRootData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimationPoseLayerData {
    pub _glacier_base: super::timeline::GroupTrackData,
}

pub trait AnimationPoseLayerDataTrait: super::timeline::GroupTrackDataTrait {
}

impl AnimationPoseLayerDataTrait for AnimationPoseLayerData {
}

impl super::timeline::GroupTrackDataTrait for AnimationPoseLayerData {
    fn root_data(&self) -> &Option<LockedTypeObject /* super::timeline::GroupTrackRootData */> {
        self._glacier_base.root_data()
    }
    fn root_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::GroupTrackRootData */> {
        self._glacier_base.root_data_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for AnimationPoseLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for AnimationPoseLayerData {
}

impl super::core::DataBusPeerTrait for AnimationPoseLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationPoseLayerData {
}

impl super::core::DataContainerTrait for AnimationPoseLayerData {
}

pub static ANIMATIONPOSELAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseLayerData",
    name_hash: 1889028105,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::GROUPTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(AnimationPoseLayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationPoseLayerData as Default>::default())),
            create_boxed: || Box::new(<AnimationPoseLayerData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANIMATIONPOSELAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationPoseLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPOSELAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPOSELAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseLayerData-Array",
    name_hash: 1184308669,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationPoseLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimationPoseKeyframe {
    pub _glacier_base: super::timeline::TimelineKeyframeData,
    pub time: f32,
    pub pose: Vec<BoxedTypeObject /* Sqt */>,
}

pub trait AnimationPoseKeyframeTrait: super::timeline::TimelineKeyframeDataTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn pose(&self) -> &Vec<BoxedTypeObject /* Sqt */>;
    fn pose_mut(&mut self) -> &mut Vec<BoxedTypeObject /* Sqt */>;
}

impl AnimationPoseKeyframeTrait for AnimationPoseKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn pose(&self) -> &Vec<BoxedTypeObject /* Sqt */> {
        &self.pose
    }
    fn pose_mut(&mut self) -> &mut Vec<BoxedTypeObject /* Sqt */> {
        &mut self.pose
    }
}

impl super::timeline::TimelineKeyframeDataTrait for AnimationPoseKeyframe {
}

impl super::core::DataContainerTrait for AnimationPoseKeyframe {
}

pub static ANIMATIONPOSEKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseKeyframe",
    name_hash: 3063420976,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINEKEYFRAMEDATA_TYPE_INFO),
        super_class_offset: offset_of!(AnimationPoseKeyframe, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationPoseKeyframe as Default>::default())),
            create_boxed: || Box::new(<AnimationPoseKeyframe as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AnimationPoseKeyframe, time),
            },
            FieldInfoData {
                name: "Pose",
                name_hash: 2089458956,
                flags: MemberInfoFlags::new(144),
                field_type: "Sqt-Array",
                rust_offset: offset_of!(AnimationPoseKeyframe, pose),
            },
        ],
    }),
    array_type: Some(ANIMATIONPOSEKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationPoseKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPOSEKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPOSEKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseKeyframe-Array",
    name_hash: 85648772,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationPoseKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Sqt {
    pub scale: super::core::Vec3,
    pub quat_value: super::core::Vec4,
    pub translation: super::core::Vec3,
}

pub trait SqtTrait: TypeObject {
    fn scale(&self) -> &super::core::Vec3;
    fn scale_mut(&mut self) -> &mut super::core::Vec3;
    fn quat_value(&self) -> &super::core::Vec4;
    fn quat_value_mut(&mut self) -> &mut super::core::Vec4;
    fn translation(&self) -> &super::core::Vec3;
    fn translation_mut(&mut self) -> &mut super::core::Vec3;
}

impl SqtTrait for Sqt {
    fn scale(&self) -> &super::core::Vec3 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.scale
    }
    fn quat_value(&self) -> &super::core::Vec4 {
        &self.quat_value
    }
    fn quat_value_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.quat_value
    }
    fn translation(&self) -> &super::core::Vec3 {
        &self.translation
    }
    fn translation_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.translation
    }
}

pub static SQT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Sqt",
    name_hash: 193465811,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Sqt as Default>::default())),
            create_boxed: || Box::new(<Sqt as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Scale",
                name_hash: 231223453,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Sqt, scale),
            },
            FieldInfoData {
                name: "QuatValue",
                name_hash: 4237524351,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(Sqt, quat_value),
            },
            FieldInfoData {
                name: "Translation",
                name_hash: 2696156750,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Sqt, translation),
            },
        ],
    }),
    array_type: Some(SQT_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Sqt {
    fn type_info(&self) -> &'static TypeInfo {
        SQT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SQT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Sqt-Array",
    name_hash: 2200951015,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("Sqt"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3ValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait Vec3ValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl Vec3ValidatePropertyTrackDataTrait for Vec3ValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for Vec3ValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for Vec3ValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for Vec3ValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for Vec3ValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for Vec3ValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for Vec3ValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec3ValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for Vec3ValidatePropertyTrackData {
}

pub static VEC3VALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ValidatePropertyTrackData",
    name_hash: 1880936632,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec3ValidatePropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ValidatePropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<Vec3ValidatePropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3VALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3ValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3VALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3VALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ValidatePropertyTrackData-Array",
    name_hash: 1827101196,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("Vec3ValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct Vec3RecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait Vec3RecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl Vec3RecordPropertyTrackDataTrait for Vec3RecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for Vec3RecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for Vec3RecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for Vec3RecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for Vec3RecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for Vec3RecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for Vec3RecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec3RecordPropertyTrackData {
}

impl super::core::DataContainerTrait for Vec3RecordPropertyTrackData {
}

pub static VEC3RECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3RecordPropertyTrackData",
    name_hash: 3679639027,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(Vec3RecordPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3RecordPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<Vec3RecordPropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3RECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3RecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3RECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3RECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3RecordPropertyTrackData-Array",
    name_hash: 1068544455,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("Vec3RecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ValidateTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub children: Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>,
    pub recorded_data: Option<LockedTypeObject /* super::timeline::GroupTrackRootData */>,
}

pub trait ValidateTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
    fn recorded_data(&self) -> &Option<LockedTypeObject /* super::timeline::GroupTrackRootData */>;
    fn recorded_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::GroupTrackRootData */>;
}

impl ValidateTrackDataTrait for ValidateTrackData {
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &self.children
    }
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &mut self.children
    }
    fn recorded_data(&self) -> &Option<LockedTypeObject /* super::timeline::GroupTrackRootData */> {
        &self.recorded_data
    }
    fn recorded_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::GroupTrackRootData */> {
        &mut self.recorded_data
    }
}

impl super::timeline::TimelineTrackDataTrait for ValidateTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ValidateTrackData {
}

impl super::core::DataBusPeerTrait for ValidateTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ValidateTrackData {
}

impl super::core::DataContainerTrait for ValidateTrackData {
}

pub static VALIDATETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidateTrackData",
    name_hash: 1300811292,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ValidateTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValidateTrackData as Default>::default())),
            create_boxed: || Box::new(<ValidateTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Children",
                name_hash: 1297796054,
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(ValidateTrackData, children),
            },
            FieldInfoData {
                name: "RecordedData",
                name_hash: 2392591513,
                flags: MemberInfoFlags::new(0),
                field_type: "GroupTrackRootData",
                rust_offset: offset_of!(ValidateTrackData, recorded_data),
            },
        ],
    }),
    array_type: Some(VALIDATETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValidateTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VALIDATETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALIDATETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidateTrackData-Array",
    name_hash: 1213974056,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ValidateTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ValidatePropertyTrackBaseData {
    pub _glacier_base: super::timeline::PropertyReaderTrackBaseData,
    pub recorded_data_track: Option<LockedTypeObject /* super::timeline::TimelineTrackData */>,
    pub auto_generated: bool,
    pub recorded_key_time_data: glacier_reflect::builtin::ResourceRef,
    pub recorded_key_value_data: glacier_reflect::builtin::ResourceRef,
}

pub trait ValidatePropertyTrackBaseDataTrait: super::timeline::PropertyReaderTrackBaseDataTrait {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */>;
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */>;
    fn auto_generated(&self) -> &bool;
    fn auto_generated_mut(&mut self) -> &mut bool;
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
}

impl ValidatePropertyTrackBaseDataTrait for ValidatePropertyTrackBaseData {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        &self.recorded_data_track
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        &mut self.recorded_data_track
    }
    fn auto_generated(&self) -> &bool {
        &self.auto_generated
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        &mut self.auto_generated
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.recorded_key_time_data
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.recorded_key_time_data
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.recorded_key_value_data
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.recorded_key_value_data
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for ValidatePropertyTrackBaseData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for ValidatePropertyTrackBaseData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ValidatePropertyTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ValidatePropertyTrackBaseData {
}

impl super::core::DataBusPeerTrait for ValidatePropertyTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ValidatePropertyTrackBaseData {
}

impl super::core::DataContainerTrait for ValidatePropertyTrackBaseData {
}

pub static VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidatePropertyTrackBaseData",
    name_hash: 1606142926,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::PROPERTYREADERTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ValidatePropertyTrackBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValidatePropertyTrackBaseData as Default>::default())),
            create_boxed: || Box::new(<ValidatePropertyTrackBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RecordedDataTrack",
                name_hash: 1993586902,
                flags: MemberInfoFlags::new(0),
                field_type: "TimelineTrackData",
                rust_offset: offset_of!(ValidatePropertyTrackBaseData, recorded_data_track),
            },
            FieldInfoData {
                name: "AutoGenerated",
                name_hash: 358098181,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ValidatePropertyTrackBaseData, auto_generated),
            },
            FieldInfoData {
                name: "RecordedKeyTimeData",
                name_hash: 1581993819,
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(ValidatePropertyTrackBaseData, recorded_key_time_data),
            },
            FieldInfoData {
                name: "RecordedKeyValueData",
                name_hash: 3993997125,
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(ValidatePropertyTrackBaseData, recorded_key_value_data),
            },
        ],
    }),
    array_type: Some(VALIDATEPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ValidatePropertyTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALIDATEPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidatePropertyTrackBaseData-Array",
    name_hash: 2502935930,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ValidatePropertyTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ValidateLinkTrackBaseData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub recorded_data_track: Option<LockedTypeObject /* super::timeline::TimelineTrackData */>,
    pub auto_generated: bool,
    pub recorded_key_time_data: glacier_reflect::builtin::ResourceRef,
    pub recorded_key_value_data: glacier_reflect::builtin::ResourceRef,
}

pub trait ValidateLinkTrackBaseDataTrait: super::timeline::LinkTrackDataTrait {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */>;
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */>;
    fn auto_generated(&self) -> &bool;
    fn auto_generated_mut(&mut self) -> &mut bool;
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
}

impl ValidateLinkTrackBaseDataTrait for ValidateLinkTrackBaseData {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        &self.recorded_data_track
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        &mut self.recorded_data_track
    }
    fn auto_generated(&self) -> &bool {
        &self.auto_generated
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        &mut self.auto_generated
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.recorded_key_time_data
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.recorded_key_time_data
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.recorded_key_value_data
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.recorded_key_value_data
    }
}

impl super::timeline::LinkTrackDataTrait for ValidateLinkTrackBaseData {
}

impl super::timeline::SchematicPinTrackDataTrait for ValidateLinkTrackBaseData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ValidateLinkTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ValidateLinkTrackBaseData {
}

impl super::core::DataBusPeerTrait for ValidateLinkTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ValidateLinkTrackBaseData {
}

impl super::core::DataContainerTrait for ValidateLinkTrackBaseData {
}

pub static VALIDATELINKTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidateLinkTrackBaseData",
    name_hash: 2739610409,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(ValidateLinkTrackBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValidateLinkTrackBaseData as Default>::default())),
            create_boxed: || Box::new(<ValidateLinkTrackBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RecordedDataTrack",
                name_hash: 1993586902,
                flags: MemberInfoFlags::new(0),
                field_type: "TimelineTrackData",
                rust_offset: offset_of!(ValidateLinkTrackBaseData, recorded_data_track),
            },
            FieldInfoData {
                name: "AutoGenerated",
                name_hash: 358098181,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ValidateLinkTrackBaseData, auto_generated),
            },
            FieldInfoData {
                name: "RecordedKeyTimeData",
                name_hash: 1581993819,
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(ValidateLinkTrackBaseData, recorded_key_time_data),
            },
            FieldInfoData {
                name: "RecordedKeyValueData",
                name_hash: 3993997125,
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(ValidateLinkTrackBaseData, recorded_key_value_data),
            },
        ],
    }),
    array_type: Some(VALIDATELINKTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ValidateLinkTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        VALIDATELINKTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALIDATELINKTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidateLinkTrackBaseData-Array",
    name_hash: 1953368477,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ValidateLinkTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait TransformValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl TransformValidatePropertyTrackDataTrait for TransformValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for TransformValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for TransformValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for TransformValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for TransformValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for TransformValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for TransformValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for TransformValidatePropertyTrackData {
}

pub static TRANSFORMVALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformValidatePropertyTrackData",
    name_hash: 2797317943,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformValidatePropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformValidatePropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<TransformValidatePropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMVALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformValidatePropertyTrackData-Array",
    name_hash: 1839409283,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TransformValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformRecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait TransformRecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl TransformRecordPropertyTrackDataTrait for TransformRecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for TransformRecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for TransformRecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for TransformRecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for TransformRecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for TransformRecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for TransformRecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformRecordPropertyTrackData {
}

impl super::core::DataContainerTrait for TransformRecordPropertyTrackData {
}

pub static TRANSFORMRECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformRecordPropertyTrackData",
    name_hash: 1236886012,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformRecordPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformRecordPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<TransformRecordPropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformRecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMRECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformRecordPropertyTrackData-Array",
    name_hash: 519539144,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TransformRecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RecordTrackData {
    pub _glacier_base: super::timeline::GroupTrackData,
}

pub trait RecordTrackDataTrait: super::timeline::GroupTrackDataTrait {
}

impl RecordTrackDataTrait for RecordTrackData {
}

impl super::timeline::GroupTrackDataTrait for RecordTrackData {
    fn root_data(&self) -> &Option<LockedTypeObject /* super::timeline::GroupTrackRootData */> {
        self._glacier_base.root_data()
    }
    fn root_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::GroupTrackRootData */> {
        self._glacier_base.root_data_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordTrackData {
}

impl super::core::DataBusPeerTrait for RecordTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordTrackData {
}

impl super::core::DataContainerTrait for RecordTrackData {
}

pub static RECORDTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordTrackData",
    name_hash: 1058979479,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::GROUPTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(RecordTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordTrackData as Default>::default())),
            create_boxed: || Box::new(<RecordTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(RECORDTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordTrackData-Array",
    name_hash: 2135426851,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TrimmedRecordingRange {
    pub start_frame: i32,
    pub end_frame: i32,
}

pub trait TrimmedRecordingRangeTrait: TypeObject {
    fn start_frame(&self) -> &i32;
    fn start_frame_mut(&mut self) -> &mut i32;
    fn end_frame(&self) -> &i32;
    fn end_frame_mut(&mut self) -> &mut i32;
}

impl TrimmedRecordingRangeTrait for TrimmedRecordingRange {
    fn start_frame(&self) -> &i32 {
        &self.start_frame
    }
    fn start_frame_mut(&mut self) -> &mut i32 {
        &mut self.start_frame
    }
    fn end_frame(&self) -> &i32 {
        &self.end_frame
    }
    fn end_frame_mut(&mut self) -> &mut i32 {
        &mut self.end_frame
    }
}

pub static TRIMMEDRECORDINGRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrimmedRecordingRange",
    name_hash: 4174751257,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrimmedRecordingRange as Default>::default())),
            create_boxed: || Box::new(<TrimmedRecordingRange as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StartFrame",
                name_hash: 2730145720,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TrimmedRecordingRange, start_frame),
            },
            FieldInfoData {
                name: "EndFrame",
                name_hash: 4000923543,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TrimmedRecordingRange, end_frame),
            },
        ],
    }),
    array_type: Some(TRIMMEDRECORDINGRANGE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TrimmedRecordingRange {
    fn type_info(&self) -> &'static TypeInfo {
        TRIMMEDRECORDINGRANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TRIMMEDRECORDINGRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrimmedRecordingRange-Array",
    name_hash: 4202021805,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrimmedRecordingRange"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TrimmingRangeKeyframe {
    pub _glacier_base: super::core::DataContainer,
    pub time: f32,
    pub length: f32,
}

pub trait TrimmingRangeKeyframeTrait: super::core::DataContainerTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
}

impl TrimmingRangeKeyframeTrait for TrimmingRangeKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
}

impl super::core::DataContainerTrait for TrimmingRangeKeyframe {
}

pub static TRIMMINGRANGEKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrimmingRangeKeyframe",
    name_hash: 2310348991,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(TrimmingRangeKeyframe, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrimmingRangeKeyframe as Default>::default())),
            create_boxed: || Box::new(<TrimmingRangeKeyframe as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrimmingRangeKeyframe, time),
            },
            FieldInfoData {
                name: "Length",
                name_hash: 2906827577,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrimmingRangeKeyframe, length),
            },
        ],
    }),
    array_type: Some(TRIMMINGRANGEKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TrimmingRangeKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        TRIMMINGRANGEKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRIMMINGRANGEKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrimmingRangeKeyframe-Array",
    name_hash: 466294283,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrimmingRangeKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RecordLinkTrackBaseData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub keyframes: Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>>,
    pub trimmed_recording_ranges: Vec<BoxedTypeObject /* TrimmedRecordingRange */>,
}

pub trait RecordLinkTrackBaseDataTrait: super::timeline::LinkTrackDataTrait {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>>;
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */>;
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */>;
}

impl RecordLinkTrackBaseDataTrait for RecordLinkTrackBaseData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        &mut self.keyframes
    }
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        &self.trimmed_recording_ranges
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        &mut self.trimmed_recording_ranges
    }
}

impl super::timeline::LinkTrackDataTrait for RecordLinkTrackBaseData {
}

impl super::timeline::SchematicPinTrackDataTrait for RecordLinkTrackBaseData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordLinkTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordLinkTrackBaseData {
}

impl super::core::DataBusPeerTrait for RecordLinkTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordLinkTrackBaseData {
}

impl super::core::DataContainerTrait for RecordLinkTrackBaseData {
}

pub static RECORDLINKTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordLinkTrackBaseData",
    name_hash: 3588143266,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(RecordLinkTrackBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordLinkTrackBaseData as Default>::default())),
            create_boxed: || Box::new(<RecordLinkTrackBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                name_hash: 2213598044,
                flags: MemberInfoFlags::new(144),
                field_type: "TrimmingRangeKeyframe-Array",
                rust_offset: offset_of!(RecordLinkTrackBaseData, keyframes),
            },
            FieldInfoData {
                name: "TrimmedRecordingRanges",
                name_hash: 327838026,
                flags: MemberInfoFlags::new(144),
                field_type: "TrimmedRecordingRange-Array",
                rust_offset: offset_of!(RecordLinkTrackBaseData, trimmed_recording_ranges),
            },
        ],
    }),
    array_type: Some(RECORDLINKTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RecordLinkTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDLINKTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDLINKTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordLinkTrackBaseData-Array",
    name_hash: 2929563414,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordLinkTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RecordPropertyTrackBaseData {
    pub _glacier_base: super::timeline::PropertyReaderTrackBaseData,
    pub keyframes: Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>>,
    pub trimmed_recording_ranges: Vec<BoxedTypeObject /* TrimmedRecordingRange */>,
}

pub trait RecordPropertyTrackBaseDataTrait: super::timeline::PropertyReaderTrackBaseDataTrait {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>>;
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */>;
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */>;
}

impl RecordPropertyTrackBaseDataTrait for RecordPropertyTrackBaseData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        &mut self.keyframes
    }
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        &self.trimmed_recording_ranges
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        &mut self.trimmed_recording_ranges
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for RecordPropertyTrackBaseData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for RecordPropertyTrackBaseData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordPropertyTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordPropertyTrackBaseData {
}

impl super::core::DataBusPeerTrait for RecordPropertyTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordPropertyTrackBaseData {
}

impl super::core::DataContainerTrait for RecordPropertyTrackBaseData {
}

pub static RECORDPROPERTYTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordPropertyTrackBaseData",
    name_hash: 1409987973,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::PROPERTYREADERTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(RecordPropertyTrackBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordPropertyTrackBaseData as Default>::default())),
            create_boxed: || Box::new(<RecordPropertyTrackBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                name_hash: 2213598044,
                flags: MemberInfoFlags::new(144),
                field_type: "TrimmingRangeKeyframe-Array",
                rust_offset: offset_of!(RecordPropertyTrackBaseData, keyframes),
            },
            FieldInfoData {
                name: "TrimmedRecordingRanges",
                name_hash: 327838026,
                flags: MemberInfoFlags::new(144),
                field_type: "TrimmedRecordingRange-Array",
                rust_offset: offset_of!(RecordPropertyTrackBaseData, trimmed_recording_ranges),
            },
        ],
    }),
    array_type: Some(RECORDPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RecordPropertyTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDPROPERTYTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordPropertyTrackBaseData-Array",
    name_hash: 1598422321,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordPropertyTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterPoseValidateTrackData {
    pub _glacier_base: PoseValidateTrackData,
}

pub trait CharacterPoseValidateTrackDataTrait: PoseValidateTrackDataTrait {
}

impl CharacterPoseValidateTrackDataTrait for CharacterPoseValidateTrackData {
}

impl PoseValidateTrackDataTrait for CharacterPoseValidateTrackData {
}

impl ValidateLinkTrackBaseDataTrait for CharacterPoseValidateTrackData {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for CharacterPoseValidateTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for CharacterPoseValidateTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CharacterPoseValidateTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterPoseValidateTrackData {
}

impl super::core::DataBusPeerTrait for CharacterPoseValidateTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterPoseValidateTrackData {
}

impl super::core::DataContainerTrait for CharacterPoseValidateTrackData {
}

pub static CHARACTERPOSEVALIDATETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseValidateTrackData",
    name_hash: 2186155436,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(POSEVALIDATETRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterPoseValidateTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterPoseValidateTrackData as Default>::default())),
            create_boxed: || Box::new(<CharacterPoseValidateTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERPOSEVALIDATETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterPoseValidateTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERPOSEVALIDATETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERPOSEVALIDATETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseValidateTrackData-Array",
    name_hash: 1675969816,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterPoseValidateTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PoseValidateTrackData {
    pub _glacier_base: ValidateLinkTrackBaseData,
}

pub trait PoseValidateTrackDataTrait: ValidateLinkTrackBaseDataTrait {
}

impl PoseValidateTrackDataTrait for PoseValidateTrackData {
}

impl ValidateLinkTrackBaseDataTrait for PoseValidateTrackData {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for PoseValidateTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for PoseValidateTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for PoseValidateTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for PoseValidateTrackData {
}

impl super::core::DataBusPeerTrait for PoseValidateTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PoseValidateTrackData {
}

impl super::core::DataContainerTrait for PoseValidateTrackData {
}

pub static POSEVALIDATETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseValidateTrackData",
    name_hash: 2651422581,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATELINKTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(PoseValidateTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PoseValidateTrackData as Default>::default())),
            create_boxed: || Box::new(<PoseValidateTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(POSEVALIDATETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PoseValidateTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        POSEVALIDATETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static POSEVALIDATETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseValidateTrackData-Array",
    name_hash: 3920883777,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PoseValidateTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterPoseRecordTrackData {
    pub _glacier_base: PoseRecordTrackData,
}

pub trait CharacterPoseRecordTrackDataTrait: PoseRecordTrackDataTrait {
}

impl CharacterPoseRecordTrackDataTrait for CharacterPoseRecordTrackData {
}

impl PoseRecordTrackDataTrait for CharacterPoseRecordTrackData {
    fn bones_to_record(&self) -> &super::entity::BoneSelection {
        self._glacier_base.bones_to_record()
    }
    fn bones_to_record_mut(&mut self) -> &mut super::entity::BoneSelection {
        self._glacier_base.bones_to_record_mut()
    }
}

impl RecordLinkTrackBaseDataTrait for CharacterPoseRecordTrackData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for CharacterPoseRecordTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for CharacterPoseRecordTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CharacterPoseRecordTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterPoseRecordTrackData {
}

impl super::core::DataBusPeerTrait for CharacterPoseRecordTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterPoseRecordTrackData {
}

impl super::core::DataContainerTrait for CharacterPoseRecordTrackData {
}

pub static CHARACTERPOSERECORDTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseRecordTrackData",
    name_hash: 553565351,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(POSERECORDTRACKDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterPoseRecordTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterPoseRecordTrackData as Default>::default())),
            create_boxed: || Box::new(<CharacterPoseRecordTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERPOSERECORDTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterPoseRecordTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERPOSERECORDTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERPOSERECORDTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseRecordTrackData-Array",
    name_hash: 2965868051,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterPoseRecordTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PoseRecordTrackData {
    pub _glacier_base: RecordLinkTrackBaseData,
    pub bones_to_record: super::entity::BoneSelection,
}

pub trait PoseRecordTrackDataTrait: RecordLinkTrackBaseDataTrait {
    fn bones_to_record(&self) -> &super::entity::BoneSelection;
    fn bones_to_record_mut(&mut self) -> &mut super::entity::BoneSelection;
}

impl PoseRecordTrackDataTrait for PoseRecordTrackData {
    fn bones_to_record(&self) -> &super::entity::BoneSelection {
        &self.bones_to_record
    }
    fn bones_to_record_mut(&mut self) -> &mut super::entity::BoneSelection {
        &mut self.bones_to_record
    }
}

impl RecordLinkTrackBaseDataTrait for PoseRecordTrackData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for PoseRecordTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for PoseRecordTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for PoseRecordTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for PoseRecordTrackData {
}

impl super::core::DataBusPeerTrait for PoseRecordTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PoseRecordTrackData {
}

impl super::core::DataContainerTrait for PoseRecordTrackData {
}

pub static POSERECORDTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseRecordTrackData",
    name_hash: 1242664702,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDLINKTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(PoseRecordTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PoseRecordTrackData as Default>::default())),
            create_boxed: || Box::new(<PoseRecordTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BonesToRecord",
                name_hash: 759163142,
                flags: MemberInfoFlags::new(0),
                field_type: "BoneSelection",
                rust_offset: offset_of!(PoseRecordTrackData, bones_to_record),
            },
        ],
    }),
    array_type: Some(POSERECORDTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PoseRecordTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        POSERECORDTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static POSERECORDTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseRecordTrackData-Array",
    name_hash: 2544480202,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PoseRecordTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait IntValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl IntValidatePropertyTrackDataTrait for IntValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for IntValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for IntValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for IntValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for IntValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for IntValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for IntValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for IntValidatePropertyTrackData {
}

pub static INTVALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntValidatePropertyTrackData",
    name_hash: 3164037640,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(IntValidatePropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntValidatePropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<IntValidatePropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        INTVALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntValidatePropertyTrackData-Array",
    name_hash: 70706236,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntRecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait IntRecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl IntRecordPropertyTrackDataTrait for IntRecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for IntRecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for IntRecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for IntRecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for IntRecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for IntRecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for IntRecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntRecordPropertyTrackData {
}

impl super::core::DataContainerTrait for IntRecordPropertyTrackData {
}

pub static INTRECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntRecordPropertyTrackData",
    name_hash: 533970371,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(IntRecordPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntRecordPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<IntRecordPropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntRecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        INTRECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntRecordPropertyTrackData-Array",
    name_hash: 2649538807,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntRecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait FloatValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl FloatValidatePropertyTrackDataTrait for FloatValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for FloatValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for FloatValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for FloatValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for FloatValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for FloatValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for FloatValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for FloatValidatePropertyTrackData {
}

pub static FLOATVALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatValidatePropertyTrackData",
    name_hash: 3136564683,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(FloatValidatePropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatValidatePropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<FloatValidatePropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATVALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatValidatePropertyTrackData-Array",
    name_hash: 3458239743,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FloatValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteAntGameStateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub ant_game_states: Vec<Option<LockedTypeObject /* WriteAntGameStateData */>>,
    pub write_continuously: bool,
    pub write_once_on_spawn: bool,
    pub write_on_property_changed: bool,
    pub num_properties: i32,
    pub num_ant_assets: i32,
}

pub trait WriteAntGameStateEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn ant_game_states(&self) -> &Vec<Option<LockedTypeObject /* WriteAntGameStateData */>>;
    fn ant_game_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* WriteAntGameStateData */>>;
    fn write_continuously(&self) -> &bool;
    fn write_continuously_mut(&mut self) -> &mut bool;
    fn write_once_on_spawn(&self) -> &bool;
    fn write_once_on_spawn_mut(&mut self) -> &mut bool;
    fn write_on_property_changed(&self) -> &bool;
    fn write_on_property_changed_mut(&mut self) -> &mut bool;
    fn num_properties(&self) -> &i32;
    fn num_properties_mut(&mut self) -> &mut i32;
    fn num_ant_assets(&self) -> &i32;
    fn num_ant_assets_mut(&mut self) -> &mut i32;
}

impl WriteAntGameStateEntityDataTrait for WriteAntGameStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn ant_game_states(&self) -> &Vec<Option<LockedTypeObject /* WriteAntGameStateData */>> {
        &self.ant_game_states
    }
    fn ant_game_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* WriteAntGameStateData */>> {
        &mut self.ant_game_states
    }
    fn write_continuously(&self) -> &bool {
        &self.write_continuously
    }
    fn write_continuously_mut(&mut self) -> &mut bool {
        &mut self.write_continuously
    }
    fn write_once_on_spawn(&self) -> &bool {
        &self.write_once_on_spawn
    }
    fn write_once_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.write_once_on_spawn
    }
    fn write_on_property_changed(&self) -> &bool {
        &self.write_on_property_changed
    }
    fn write_on_property_changed_mut(&mut self) -> &mut bool {
        &mut self.write_on_property_changed
    }
    fn num_properties(&self) -> &i32 {
        &self.num_properties
    }
    fn num_properties_mut(&mut self) -> &mut i32 {
        &mut self.num_properties
    }
    fn num_ant_assets(&self) -> &i32 {
        &self.num_ant_assets
    }
    fn num_ant_assets_mut(&mut self) -> &mut i32 {
        &mut self.num_ant_assets
    }
}

impl super::entity::EntityDataTrait for WriteAntGameStateEntityData {
}

impl super::entity::GameObjectDataTrait for WriteAntGameStateEntityData {
}

impl super::core::DataBusPeerTrait for WriteAntGameStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WriteAntGameStateEntityData {
}

impl super::core::DataContainerTrait for WriteAntGameStateEntityData {
}

pub static WRITEANTGAMESTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteAntGameStateEntityData",
    name_hash: 3841596049,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteAntGameStateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteAntGameStateEntityData as Default>::default())),
            create_boxed: || Box::new(<WriteAntGameStateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WriteAntGameStateEntityData, realm),
            },
            FieldInfoData {
                name: "AntGameStates",
                name_hash: 1141188948,
                flags: MemberInfoFlags::new(144),
                field_type: "WriteAntGameStateData-Array",
                rust_offset: offset_of!(WriteAntGameStateEntityData, ant_game_states),
            },
            FieldInfoData {
                name: "WriteContinuously",
                name_hash: 1368646912,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WriteAntGameStateEntityData, write_continuously),
            },
            FieldInfoData {
                name: "WriteOnceOnSpawn",
                name_hash: 681619557,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WriteAntGameStateEntityData, write_once_on_spawn),
            },
            FieldInfoData {
                name: "WriteOnPropertyChanged",
                name_hash: 129711612,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WriteAntGameStateEntityData, write_on_property_changed),
            },
            FieldInfoData {
                name: "NumProperties",
                name_hash: 4031008786,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteAntGameStateEntityData, num_properties),
            },
            FieldInfoData {
                name: "NumAntAssets",
                name_hash: 2573234379,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteAntGameStateEntityData, num_ant_assets),
            },
        ],
    }),
    array_type: Some(WRITEANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteAntGameStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEANTGAMESTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteAntGameStateEntityData-Array",
    name_hash: 264256549,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteAntGameStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadAntGameStateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub ant_game_states: Vec<Option<LockedTypeObject /* ReadAntGameStateData */>>,
    pub start_reading_continously_on_spawn: bool,
    pub read_once_on_spawn: bool,
    pub num_properties: i32,
    pub num_ant_assets: i32,
}

pub trait ReadAntGameStateEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn ant_game_states(&self) -> &Vec<Option<LockedTypeObject /* ReadAntGameStateData */>>;
    fn ant_game_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ReadAntGameStateData */>>;
    fn start_reading_continously_on_spawn(&self) -> &bool;
    fn start_reading_continously_on_spawn_mut(&mut self) -> &mut bool;
    fn read_once_on_spawn(&self) -> &bool;
    fn read_once_on_spawn_mut(&mut self) -> &mut bool;
    fn num_properties(&self) -> &i32;
    fn num_properties_mut(&mut self) -> &mut i32;
    fn num_ant_assets(&self) -> &i32;
    fn num_ant_assets_mut(&mut self) -> &mut i32;
}

impl ReadAntGameStateEntityDataTrait for ReadAntGameStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn ant_game_states(&self) -> &Vec<Option<LockedTypeObject /* ReadAntGameStateData */>> {
        &self.ant_game_states
    }
    fn ant_game_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ReadAntGameStateData */>> {
        &mut self.ant_game_states
    }
    fn start_reading_continously_on_spawn(&self) -> &bool {
        &self.start_reading_continously_on_spawn
    }
    fn start_reading_continously_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.start_reading_continously_on_spawn
    }
    fn read_once_on_spawn(&self) -> &bool {
        &self.read_once_on_spawn
    }
    fn read_once_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.read_once_on_spawn
    }
    fn num_properties(&self) -> &i32 {
        &self.num_properties
    }
    fn num_properties_mut(&mut self) -> &mut i32 {
        &mut self.num_properties
    }
    fn num_ant_assets(&self) -> &i32 {
        &self.num_ant_assets
    }
    fn num_ant_assets_mut(&mut self) -> &mut i32 {
        &mut self.num_ant_assets
    }
}

impl super::entity::EntityDataTrait for ReadAntGameStateEntityData {
}

impl super::entity::GameObjectDataTrait for ReadAntGameStateEntityData {
}

impl super::core::DataBusPeerTrait for ReadAntGameStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReadAntGameStateEntityData {
}

impl super::core::DataContainerTrait for ReadAntGameStateEntityData {
}

pub static READANTGAMESTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadAntGameStateEntityData",
    name_hash: 3082844798,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadAntGameStateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadAntGameStateEntityData as Default>::default())),
            create_boxed: || Box::new(<ReadAntGameStateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ReadAntGameStateEntityData, realm),
            },
            FieldInfoData {
                name: "AntGameStates",
                name_hash: 1141188948,
                flags: MemberInfoFlags::new(144),
                field_type: "ReadAntGameStateData-Array",
                rust_offset: offset_of!(ReadAntGameStateEntityData, ant_game_states),
            },
            FieldInfoData {
                name: "StartReadingContinouslyOnSpawn",
                name_hash: 3590049344,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReadAntGameStateEntityData, start_reading_continously_on_spawn),
            },
            FieldInfoData {
                name: "ReadOnceOnSpawn",
                name_hash: 773521066,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReadAntGameStateEntityData, read_once_on_spawn),
            },
            FieldInfoData {
                name: "NumProperties",
                name_hash: 4031008786,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ReadAntGameStateEntityData, num_properties),
            },
            FieldInfoData {
                name: "NumAntAssets",
                name_hash: 2573234379,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ReadAntGameStateEntityData, num_ant_assets),
            },
        ],
    }),
    array_type: Some(READANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadAntGameStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READANTGAMESTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadAntGameStateEntityData-Array",
    name_hash: 1119566666,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadAntGameStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteVector3AndQuaternionGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state_vec: super::ant::AntRef,
    pub game_state_quat: super::ant::AntRef,
    pub value: super::core::LinearTransform,
}

pub trait WriteVector3AndQuaternionGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state_vec(&self) -> &super::ant::AntRef;
    fn game_state_vec_mut(&mut self) -> &mut super::ant::AntRef;
    fn game_state_quat(&self) -> &super::ant::AntRef;
    fn game_state_quat_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &super::core::LinearTransform;
    fn value_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl WriteVector3AndQuaternionGameStateTrait for WriteVector3AndQuaternionGameState {
    fn game_state_vec(&self) -> &super::ant::AntRef {
        &self.game_state_vec
    }
    fn game_state_vec_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state_vec
    }
    fn game_state_quat(&self) -> &super::ant::AntRef {
        &self.game_state_quat
    }
    fn game_state_quat_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state_quat
    }
    fn value(&self) -> &super::core::LinearTransform {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteVector3AndQuaternionGameState {
}

impl AntGameStateDataTrait for WriteVector3AndQuaternionGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteVector3AndQuaternionGameState {
}

pub static WRITEVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3AndQuaternionGameState",
    name_hash: 1224256672,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteVector3AndQuaternionGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVector3AndQuaternionGameState as Default>::default())),
            create_boxed: || Box::new(<WriteVector3AndQuaternionGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameStateVec",
                name_hash: 2296203820,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteVector3AndQuaternionGameState, game_state_vec),
            },
            FieldInfoData {
                name: "GameStateQuat",
                name_hash: 2760191725,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteVector3AndQuaternionGameState, game_state_quat),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WriteVector3AndQuaternionGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WriteVector3AndQuaternionGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3AndQuaternionGameState-Array",
    name_hash: 942019092,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteVector3AndQuaternionGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteVector3TransformGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: super::core::LinearTransform,
}

pub trait WriteVector3TransformGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &super::core::LinearTransform;
    fn value_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl WriteVector3TransformGameStateTrait for WriteVector3TransformGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &super::core::LinearTransform {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteVector3TransformGameState {
}

impl AntGameStateDataTrait for WriteVector3TransformGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteVector3TransformGameState {
}

pub static WRITEVECTOR3TRANSFORMGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3TransformGameState",
    name_hash: 3531715623,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteVector3TransformGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVector3TransformGameState as Default>::default())),
            create_boxed: || Box::new(<WriteVector3TransformGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteVector3TransformGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WriteVector3TransformGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WriteVector3TransformGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVECTOR3TRANSFORMGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3TransformGameState-Array",
    name_hash: 3917882771,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteVector3TransformGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteVector3GameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: super::core::Vec3,
}

pub trait WriteVector3GameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &super::core::Vec3;
    fn value_mut(&mut self) -> &mut super::core::Vec3;
}

impl WriteVector3GameStateTrait for WriteVector3GameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &super::core::Vec3 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteVector3GameState {
}

impl AntGameStateDataTrait for WriteVector3GameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteVector3GameState {
}

pub static WRITEVECTOR3GAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3GameState",
    name_hash: 1625570987,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteVector3GameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVector3GameState as Default>::default())),
            create_boxed: || Box::new(<WriteVector3GameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteVector3GameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(WriteVector3GameState, value),
            },
        ],
    }),
    array_type: Some(WRITEVECTOR3GAMESTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WriteVector3GameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVECTOR3GAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEVECTOR3GAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3GameState-Array",
    name_hash: 3162914335,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteVector3GameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteQuaternionGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: super::core::LinearTransform,
}

pub trait WriteQuaternionGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &super::core::LinearTransform;
    fn value_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl WriteQuaternionGameStateTrait for WriteQuaternionGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &super::core::LinearTransform {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteQuaternionGameState {
}

impl AntGameStateDataTrait for WriteQuaternionGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteQuaternionGameState {
}

pub static WRITEQUATERNIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteQuaternionGameState",
    name_hash: 2300787489,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteQuaternionGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteQuaternionGameState as Default>::default())),
            create_boxed: || Box::new(<WriteQuaternionGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteQuaternionGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WriteQuaternionGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEQUATERNIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WriteQuaternionGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEQUATERNIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEQUATERNIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteQuaternionGameState-Array",
    name_hash: 2407056789,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteQuaternionGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteBoolGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: bool,
}

pub trait WriteBoolGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &bool;
    fn value_mut(&mut self) -> &mut bool;
}

impl WriteBoolGameStateTrait for WriteBoolGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &bool {
        &self.value
    }
    fn value_mut(&mut self) -> &mut bool {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteBoolGameState {
}

impl AntGameStateDataTrait for WriteBoolGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteBoolGameState {
}

pub static WRITEBOOLGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteBoolGameState",
    name_hash: 530660559,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteBoolGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteBoolGameState as Default>::default())),
            create_boxed: || Box::new(<WriteBoolGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteBoolGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WriteBoolGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEBOOLGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteBoolGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEBOOLGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEBOOLGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteBoolGameState-Array",
    name_hash: 190614011,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteBoolGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteIntGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: i32,
}

pub trait WriteIntGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl WriteIntGameStateTrait for WriteIntGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteIntGameState {
}

impl AntGameStateDataTrait for WriteIntGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteIntGameState {
}

pub static WRITEINTGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteIntGameState",
    name_hash: 2260875570,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteIntGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteIntGameState as Default>::default())),
            create_boxed: || Box::new(<WriteIntGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteIntGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteIntGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEINTGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteIntGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEINTGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEINTGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteIntGameState-Array",
    name_hash: 2832351110,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteIntGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteFloatGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: f32,
}

pub trait WriteFloatGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl WriteFloatGameStateTrait for WriteFloatGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteFloatGameState {
}

impl AntGameStateDataTrait for WriteFloatGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteFloatGameState {
}

pub static WRITEFLOATGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteFloatGameState",
    name_hash: 3300886705,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteFloatGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteFloatGameState as Default>::default())),
            create_boxed: || Box::new(<WriteFloatGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteFloatGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WriteFloatGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEFLOATGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteFloatGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEFLOATGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEFLOATGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteFloatGameState-Array",
    name_hash: 2701916933,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteFloatGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteEnumerationGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: i32,
}

pub trait WriteEnumerationGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl WriteEnumerationGameStateTrait for WriteEnumerationGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteEnumerationGameState {
}

impl AntGameStateDataTrait for WriteEnumerationGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteEnumerationGameState {
}

pub static WRITEENUMERATIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteEnumerationGameState",
    name_hash: 428453176,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteEnumerationGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteEnumerationGameState as Default>::default())),
            create_boxed: || Box::new(<WriteEnumerationGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteEnumerationGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteEnumerationGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEENUMERATIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteEnumerationGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEENUMERATIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEENUMERATIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteEnumerationGameState-Array",
    name_hash: 10983052,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteEnumerationGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadVector3AndQuaternionGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state_vec: super::ant::AntRef,
    pub game_state_quat: super::ant::AntRef,
}

pub trait ReadVector3AndQuaternionGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state_vec(&self) -> &super::ant::AntRef;
    fn game_state_vec_mut(&mut self) -> &mut super::ant::AntRef;
    fn game_state_quat(&self) -> &super::ant::AntRef;
    fn game_state_quat_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadVector3AndQuaternionGameStateTrait for ReadVector3AndQuaternionGameState {
    fn game_state_vec(&self) -> &super::ant::AntRef {
        &self.game_state_vec
    }
    fn game_state_vec_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state_vec
    }
    fn game_state_quat(&self) -> &super::ant::AntRef {
        &self.game_state_quat
    }
    fn game_state_quat_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state_quat
    }
}

impl ReadAntGameStateDataTrait for ReadVector3AndQuaternionGameState {
}

impl AntGameStateDataTrait for ReadVector3AndQuaternionGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadVector3AndQuaternionGameState {
}

pub static READVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3AndQuaternionGameState",
    name_hash: 270797359,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadVector3AndQuaternionGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVector3AndQuaternionGameState as Default>::default())),
            create_boxed: || Box::new(<ReadVector3AndQuaternionGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameStateVec",
                name_hash: 2296203820,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadVector3AndQuaternionGameState, game_state_vec),
            },
            FieldInfoData {
                name: "GameStateQuat",
                name_hash: 2760191725,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadVector3AndQuaternionGameState, game_state_quat),
            },
        ],
    }),
    array_type: Some(READVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVector3AndQuaternionGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3AndQuaternionGameState-Array",
    name_hash: 2878363547,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadVector3AndQuaternionGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadQuaternionGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadQuaternionGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadQuaternionGameStateTrait for ReadQuaternionGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadQuaternionGameState {
}

impl AntGameStateDataTrait for ReadQuaternionGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadQuaternionGameState {
}

pub static READQUATERNIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadQuaternionGameState",
    name_hash: 2178811374,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadQuaternionGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadQuaternionGameState as Default>::default())),
            create_boxed: || Box::new(<ReadQuaternionGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadQuaternionGameState, game_state),
            },
        ],
    }),
    array_type: Some(READQUATERNIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadQuaternionGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READQUATERNIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READQUATERNIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadQuaternionGameState-Array",
    name_hash: 4213219034,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadQuaternionGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadVector3TransformGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadVector3TransformGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadVector3TransformGameStateTrait for ReadVector3TransformGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadVector3TransformGameState {
}

impl AntGameStateDataTrait for ReadVector3TransformGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadVector3TransformGameState {
}

pub static READVECTOR3TRANSFORMGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3TransformGameState",
    name_hash: 3174625896,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadVector3TransformGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVector3TransformGameState as Default>::default())),
            create_boxed: || Box::new(<ReadVector3TransformGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadVector3TransformGameState, game_state),
            },
        ],
    }),
    array_type: Some(READVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVector3TransformGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READVECTOR3TRANSFORMGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3TransformGameState-Array",
    name_hash: 1143931996,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadVector3TransformGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadVector3GameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadVector3GameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadVector3GameStateTrait for ReadVector3GameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadVector3GameState {
}

impl AntGameStateDataTrait for ReadVector3GameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadVector3GameState {
}

pub static READVECTOR3GAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3GameState",
    name_hash: 1155064772,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadVector3GameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVector3GameState as Default>::default())),
            create_boxed: || Box::new(<ReadVector3GameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadVector3GameState, game_state),
            },
        ],
    }),
    array_type: Some(READVECTOR3GAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVector3GameState {
    fn type_info(&self) -> &'static TypeInfo {
        READVECTOR3GAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READVECTOR3GAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3GameState-Array",
    name_hash: 3037137008,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadVector3GameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadBoolGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadBoolGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadBoolGameStateTrait for ReadBoolGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadBoolGameState {
}

impl AntGameStateDataTrait for ReadBoolGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadBoolGameState {
}

pub static READBOOLGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadBoolGameState",
    name_hash: 2801735488,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadBoolGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadBoolGameState as Default>::default())),
            create_boxed: || Box::new(<ReadBoolGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadBoolGameState, game_state),
            },
        ],
    }),
    array_type: Some(READBOOLGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadBoolGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READBOOLGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READBOOLGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadBoolGameState-Array",
    name_hash: 3517328884,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadBoolGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadIntGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadIntGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadIntGameStateTrait for ReadIntGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadIntGameState {
}

impl AntGameStateDataTrait for ReadIntGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadIntGameState {
}

pub static READINTGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadIntGameState",
    name_hash: 2400978653,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadIntGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadIntGameState as Default>::default())),
            create_boxed: || Box::new(<ReadIntGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadIntGameState, game_state),
            },
        ],
    }),
    array_type: Some(READINTGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadIntGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READINTGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READINTGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadIntGameState-Array",
    name_hash: 1479369449,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadIntGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadFloatGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadFloatGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadFloatGameStateTrait for ReadFloatGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadFloatGameState {
}

impl AntGameStateDataTrait for ReadFloatGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadFloatGameState {
}

pub static READFLOATGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadFloatGameState",
    name_hash: 3604840286,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadFloatGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadFloatGameState as Default>::default())),
            create_boxed: || Box::new(<ReadFloatGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadFloatGameState, game_state),
            },
        ],
    }),
    array_type: Some(READFLOATGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadFloatGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READFLOATGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READFLOATGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadFloatGameState-Array",
    name_hash: 1715265770,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadFloatGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadEnumerationGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadEnumerationGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadEnumerationGameStateTrait for ReadEnumerationGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadEnumerationGameState {
}

impl AntGameStateDataTrait for ReadEnumerationGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadEnumerationGameState {
}

pub static READENUMERATIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadEnumerationGameState",
    name_hash: 692517335,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadEnumerationGameState, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadEnumerationGameState as Default>::default())),
            create_boxed: || Box::new(<ReadEnumerationGameState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                name_hash: 3955851036,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadEnumerationGameState, game_state),
            },
        ],
    }),
    array_type: Some(READENUMERATIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadEnumerationGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READENUMERATIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READENUMERATIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadEnumerationGameState-Array",
    name_hash: 1219457763,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadEnumerationGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WriteAntGameStateData {
    pub _glacier_base: AntGameStateData,
}

pub trait WriteAntGameStateDataTrait: AntGameStateDataTrait {
}

impl WriteAntGameStateDataTrait for WriteAntGameStateData {
}

impl AntGameStateDataTrait for WriteAntGameStateData {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteAntGameStateData {
}

pub static WRITEANTGAMESTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteAntGameStateData",
    name_hash: 2778373898,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(WriteAntGameStateData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteAntGameStateData as Default>::default())),
            create_boxed: || Box::new(<WriteAntGameStateData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEANTGAMESTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteAntGameStateData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEANTGAMESTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEANTGAMESTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteAntGameStateData-Array",
    name_hash: 2644515390,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteAntGameStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReadAntGameStateData {
    pub _glacier_base: AntGameStateData,
}

pub trait ReadAntGameStateDataTrait: AntGameStateDataTrait {
}

impl ReadAntGameStateDataTrait for ReadAntGameStateData {
}

impl AntGameStateDataTrait for ReadAntGameStateData {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadAntGameStateData {
}

pub static READANTGAMESTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadAntGameStateData",
    name_hash: 3056251557,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ANTGAMESTATEDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReadAntGameStateData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadAntGameStateData as Default>::default())),
            create_boxed: || Box::new(<ReadAntGameStateData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(READANTGAMESTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadAntGameStateData {
    fn type_info(&self) -> &'static TypeInfo {
        READANTGAMESTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READANTGAMESTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadAntGameStateData-Array",
    name_hash: 375098129,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadAntGameStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AntGameStateData {
    pub _glacier_base: super::core::DataContainer,
    pub property_hash: i32,
}

pub trait AntGameStateDataTrait: super::core::DataContainerTrait {
    fn property_hash(&self) -> &i32;
    fn property_hash_mut(&mut self) -> &mut i32;
}

impl AntGameStateDataTrait for AntGameStateData {
    fn property_hash(&self) -> &i32 {
        &self.property_hash
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        &mut self.property_hash
    }
}

impl super::core::DataContainerTrait for AntGameStateData {
}

pub static ANTGAMESTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntGameStateData",
    name_hash: 2559982647,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AntGameStateData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntGameStateData as Default>::default())),
            create_boxed: || Box::new(<AntGameStateData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PropertyHash",
                name_hash: 3997998064,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AntGameStateData, property_hash),
            },
        ],
    }),
    array_type: Some(ANTGAMESTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AntGameStateData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTGAMESTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTGAMESTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntGameStateData-Array",
    name_hash: 2926802307,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntGameStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AntEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub require_link: bool,
    pub send_as_player_event: bool,
    pub on_enter_events: Vec<BoxedTypeObject /* AntEventData */>,
    pub on_update_events: Vec<BoxedTypeObject /* AntEventData */>,
    pub on_leave_events: Vec<BoxedTypeObject /* AntEventData */>,
    pub auto_activate: bool,
}

pub trait AntEventEntityDataTrait: super::entity::EntityDataTrait {
    fn require_link(&self) -> &bool;
    fn require_link_mut(&mut self) -> &mut bool;
    fn send_as_player_event(&self) -> &bool;
    fn send_as_player_event_mut(&mut self) -> &mut bool;
    fn on_enter_events(&self) -> &Vec<BoxedTypeObject /* AntEventData */>;
    fn on_enter_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* AntEventData */>;
    fn on_update_events(&self) -> &Vec<BoxedTypeObject /* AntEventData */>;
    fn on_update_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* AntEventData */>;
    fn on_leave_events(&self) -> &Vec<BoxedTypeObject /* AntEventData */>;
    fn on_leave_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* AntEventData */>;
    fn auto_activate(&self) -> &bool;
    fn auto_activate_mut(&mut self) -> &mut bool;
}

impl AntEventEntityDataTrait for AntEventEntityData {
    fn require_link(&self) -> &bool {
        &self.require_link
    }
    fn require_link_mut(&mut self) -> &mut bool {
        &mut self.require_link
    }
    fn send_as_player_event(&self) -> &bool {
        &self.send_as_player_event
    }
    fn send_as_player_event_mut(&mut self) -> &mut bool {
        &mut self.send_as_player_event
    }
    fn on_enter_events(&self) -> &Vec<BoxedTypeObject /* AntEventData */> {
        &self.on_enter_events
    }
    fn on_enter_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* AntEventData */> {
        &mut self.on_enter_events
    }
    fn on_update_events(&self) -> &Vec<BoxedTypeObject /* AntEventData */> {
        &self.on_update_events
    }
    fn on_update_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* AntEventData */> {
        &mut self.on_update_events
    }
    fn on_leave_events(&self) -> &Vec<BoxedTypeObject /* AntEventData */> {
        &self.on_leave_events
    }
    fn on_leave_events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* AntEventData */> {
        &mut self.on_leave_events
    }
    fn auto_activate(&self) -> &bool {
        &self.auto_activate
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        &mut self.auto_activate
    }
}

impl super::entity::EntityDataTrait for AntEventEntityData {
}

impl super::entity::GameObjectDataTrait for AntEventEntityData {
}

impl super::core::DataBusPeerTrait for AntEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AntEventEntityData {
}

impl super::core::DataContainerTrait for AntEventEntityData {
}

pub static ANTEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEventEntityData",
    name_hash: 2862149145,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AntEventEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntEventEntityData as Default>::default())),
            create_boxed: || Box::new(<AntEventEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RequireLink",
                name_hash: 1301532168,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntEventEntityData, require_link),
            },
            FieldInfoData {
                name: "SendAsPlayerEvent",
                name_hash: 2177775476,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntEventEntityData, send_as_player_event),
            },
            FieldInfoData {
                name: "OnEnterEvents",
                name_hash: 3335046611,
                flags: MemberInfoFlags::new(144),
                field_type: "AntEventData-Array",
                rust_offset: offset_of!(AntEventEntityData, on_enter_events),
            },
            FieldInfoData {
                name: "OnUpdateEvents",
                name_hash: 1556391722,
                flags: MemberInfoFlags::new(144),
                field_type: "AntEventData-Array",
                rust_offset: offset_of!(AntEventEntityData, on_update_events),
            },
            FieldInfoData {
                name: "OnLeaveEvents",
                name_hash: 514519232,
                flags: MemberInfoFlags::new(144),
                field_type: "AntEventData-Array",
                rust_offset: offset_of!(AntEventEntityData, on_leave_events),
            },
            FieldInfoData {
                name: "AutoActivate",
                name_hash: 778899923,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntEventEntityData, auto_activate),
            },
        ],
    }),
    array_type: Some(ANTEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AntEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEventEntityData-Array",
    name_hash: 328141741,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AntEventData {
    pub tag_id: i32,
    pub event: super::entity::EventSpec,
}

pub trait AntEventDataTrait: TypeObject {
    fn tag_id(&self) -> &i32;
    fn tag_id_mut(&mut self) -> &mut i32;
    fn event(&self) -> &super::entity::EventSpec;
    fn event_mut(&mut self) -> &mut super::entity::EventSpec;
}

impl AntEventDataTrait for AntEventData {
    fn tag_id(&self) -> &i32 {
        &self.tag_id
    }
    fn tag_id_mut(&mut self) -> &mut i32 {
        &mut self.tag_id
    }
    fn event(&self) -> &super::entity::EventSpec {
        &self.event
    }
    fn event_mut(&mut self) -> &mut super::entity::EventSpec {
        &mut self.event
    }
}

pub static ANTEVENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEventData",
    name_hash: 4173491330,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntEventData as Default>::default())),
            create_boxed: || Box::new(<AntEventData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TagId",
                name_hash: 227597338,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AntEventData, tag_id),
            },
            FieldInfoData {
                name: "Event",
                name_hash: 201427689,
                flags: MemberInfoFlags::new(0),
                field_type: "EventSpec",
                rust_offset: offset_of!(AntEventData, event),
            },
        ],
    }),
    array_type: Some(ANTEVENTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AntEventData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTEVENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTEVENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEventData-Array",
    name_hash: 256682934,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntEventData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimationProxyBankData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub proxy_bank: super::ant::AntRef,
    pub proxy_bank_pointer: super::ant::AntRef,
}

pub trait AnimationProxyBankDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn proxy_bank(&self) -> &super::ant::AntRef;
    fn proxy_bank_mut(&mut self) -> &mut super::ant::AntRef;
    fn proxy_bank_pointer(&self) -> &super::ant::AntRef;
    fn proxy_bank_pointer_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AnimationProxyBankDataTrait for AnimationProxyBankData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn proxy_bank(&self) -> &super::ant::AntRef {
        &self.proxy_bank
    }
    fn proxy_bank_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.proxy_bank
    }
    fn proxy_bank_pointer(&self) -> &super::ant::AntRef {
        &self.proxy_bank_pointer
    }
    fn proxy_bank_pointer_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.proxy_bank_pointer
    }
}

impl super::entity::EntityDataTrait for AnimationProxyBankData {
}

impl super::entity::GameObjectDataTrait for AnimationProxyBankData {
}

impl super::core::DataBusPeerTrait for AnimationProxyBankData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationProxyBankData {
}

impl super::core::DataContainerTrait for AnimationProxyBankData {
}

pub static ANIMATIONPROXYBANKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationProxyBankData",
    name_hash: 3753129929,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AnimationProxyBankData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationProxyBankData as Default>::default())),
            create_boxed: || Box::new(<AnimationProxyBankData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AnimationProxyBankData, realm),
            },
            FieldInfoData {
                name: "ProxyBank",
                name_hash: 238136399,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationProxyBankData, proxy_bank),
            },
            FieldInfoData {
                name: "ProxyBankPointer",
                name_hash: 3550976564,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationProxyBankData, proxy_bank_pointer),
            },
        ],
    }),
    array_type: Some(ANIMATIONPROXYBANKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationProxyBankData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPROXYBANKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPROXYBANKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationProxyBankData-Array",
    name_hash: 2945703421,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationProxyBankData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoneFakePhysicsData {
    pub _glacier_base: super::core::DataContainer,
    pub fake_physics: Option<LockedTypeObject /* super::physics::FakePhysicsData */>,
    pub bone_name: String,
    pub bone_id: i32,
}

pub trait BoneFakePhysicsDataTrait: super::core::DataContainerTrait {
    fn fake_physics(&self) -> &Option<LockedTypeObject /* super::physics::FakePhysicsData */>;
    fn fake_physics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::FakePhysicsData */>;
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
    fn bone_id(&self) -> &i32;
    fn bone_id_mut(&mut self) -> &mut i32;
}

impl BoneFakePhysicsDataTrait for BoneFakePhysicsData {
    fn fake_physics(&self) -> &Option<LockedTypeObject /* super::physics::FakePhysicsData */> {
        &self.fake_physics
    }
    fn fake_physics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::FakePhysicsData */> {
        &mut self.fake_physics
    }
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
    fn bone_id(&self) -> &i32 {
        &self.bone_id
    }
    fn bone_id_mut(&mut self) -> &mut i32 {
        &mut self.bone_id
    }
}

impl super::core::DataContainerTrait for BoneFakePhysicsData {
}

pub static BONEFAKEPHYSICSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneFakePhysicsData",
    name_hash: 3369051985,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(BoneFakePhysicsData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoneFakePhysicsData as Default>::default())),
            create_boxed: || Box::new(<BoneFakePhysicsData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FakePhysics",
                name_hash: 3614234055,
                flags: MemberInfoFlags::new(0),
                field_type: "FakePhysicsData",
                rust_offset: offset_of!(BoneFakePhysicsData, fake_physics),
            },
            FieldInfoData {
                name: "BoneName",
                name_hash: 1590647844,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BoneFakePhysicsData, bone_name),
            },
            FieldInfoData {
                name: "BoneId",
                name_hash: 2679406126,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BoneFakePhysicsData, bone_id),
            },
        ],
    }),
    array_type: Some(BONEFAKEPHYSICSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoneFakePhysicsData {
    fn type_info(&self) -> &'static TypeInfo {
        BONEFAKEPHYSICSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BONEFAKEPHYSICSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneFakePhysicsData-Array",
    name_hash: 1266178405,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoneFakePhysicsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AddFakeCollisionEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub apply_to_all_parts: bool,
    pub part_index: u32,
    pub position: super::core::Vec3,
    pub normal: super::core::Vec3,
    pub speed: f32,
    pub material: super::entity::MaterialDecl,
    pub impulse_direction: super::core::Vec3,
    pub impulse_magnitude: f32,
    pub damage: f32,
}

pub trait AddFakeCollisionEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn apply_to_all_parts(&self) -> &bool;
    fn apply_to_all_parts_mut(&mut self) -> &mut bool;
    fn part_index(&self) -> &u32;
    fn part_index_mut(&mut self) -> &mut u32;
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn normal(&self) -> &super::core::Vec3;
    fn normal_mut(&mut self) -> &mut super::core::Vec3;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
    fn material(&self) -> &super::entity::MaterialDecl;
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn impulse_direction(&self) -> &super::core::Vec3;
    fn impulse_direction_mut(&mut self) -> &mut super::core::Vec3;
    fn impulse_magnitude(&self) -> &f32;
    fn impulse_magnitude_mut(&mut self) -> &mut f32;
    fn damage(&self) -> &f32;
    fn damage_mut(&mut self) -> &mut f32;
}

impl AddFakeCollisionEntityDataTrait for AddFakeCollisionEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn apply_to_all_parts(&self) -> &bool {
        &self.apply_to_all_parts
    }
    fn apply_to_all_parts_mut(&mut self) -> &mut bool {
        &mut self.apply_to_all_parts
    }
    fn part_index(&self) -> &u32 {
        &self.part_index
    }
    fn part_index_mut(&mut self) -> &mut u32 {
        &mut self.part_index
    }
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn normal(&self) -> &super::core::Vec3 {
        &self.normal
    }
    fn normal_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.normal
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material
    }
    fn impulse_direction(&self) -> &super::core::Vec3 {
        &self.impulse_direction
    }
    fn impulse_direction_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.impulse_direction
    }
    fn impulse_magnitude(&self) -> &f32 {
        &self.impulse_magnitude
    }
    fn impulse_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.impulse_magnitude
    }
    fn damage(&self) -> &f32 {
        &self.damage
    }
    fn damage_mut(&mut self) -> &mut f32 {
        &mut self.damage
    }
}

impl super::entity::EntityDataTrait for AddFakeCollisionEntityData {
}

impl super::entity::GameObjectDataTrait for AddFakeCollisionEntityData {
}

impl super::core::DataBusPeerTrait for AddFakeCollisionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AddFakeCollisionEntityData {
}

impl super::core::DataContainerTrait for AddFakeCollisionEntityData {
}

pub static ADDFAKECOLLISIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddFakeCollisionEntityData",
    name_hash: 1298954456,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AddFakeCollisionEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AddFakeCollisionEntityData as Default>::default())),
            create_boxed: || Box::new(<AddFakeCollisionEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AddFakeCollisionEntityData, realm),
            },
            FieldInfoData {
                name: "ApplyToAllParts",
                name_hash: 2266383439,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AddFakeCollisionEntityData, apply_to_all_parts),
            },
            FieldInfoData {
                name: "PartIndex",
                name_hash: 3213901068,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AddFakeCollisionEntityData, part_index),
            },
            FieldInfoData {
                name: "Position",
                name_hash: 3402582524,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AddFakeCollisionEntityData, position),
            },
            FieldInfoData {
                name: "Normal",
                name_hash: 2827188502,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AddFakeCollisionEntityData, normal),
            },
            FieldInfoData {
                name: "Speed",
                name_hash: 230887042,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AddFakeCollisionEntityData, speed),
            },
            FieldInfoData {
                name: "Material",
                name_hash: 845639918,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(AddFakeCollisionEntityData, material),
            },
            FieldInfoData {
                name: "ImpulseDirection",
                name_hash: 569274299,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AddFakeCollisionEntityData, impulse_direction),
            },
            FieldInfoData {
                name: "ImpulseMagnitude",
                name_hash: 677802098,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AddFakeCollisionEntityData, impulse_magnitude),
            },
            FieldInfoData {
                name: "Damage",
                name_hash: 2589892334,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AddFakeCollisionEntityData, damage),
            },
        ],
    }),
    array_type: Some(ADDFAKECOLLISIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AddFakeCollisionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ADDFAKECOLLISIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ADDFAKECOLLISIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddFakeCollisionEntityData-Array",
    name_hash: 906548076,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AddFakeCollisionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RecordVehicleTrackData {
    pub _glacier_base: super::timeline::RecordTrackBaseData,
    pub children_tracks: Vec<Option<LockedTypeObject /* super::timeline::RecordTrackChildrenData */>>,
}

pub trait RecordVehicleTrackDataTrait: super::timeline::RecordTrackBaseDataTrait {
    fn children_tracks(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::RecordTrackChildrenData */>>;
    fn children_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::RecordTrackChildrenData */>>;
}

impl RecordVehicleTrackDataTrait for RecordVehicleTrackData {
    fn children_tracks(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::RecordTrackChildrenData */>> {
        &self.children_tracks
    }
    fn children_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::RecordTrackChildrenData */>> {
        &mut self.children_tracks
    }
}

impl super::timeline::RecordTrackBaseDataTrait for RecordVehicleTrackData {
    fn frames_to_skip_per_key(&self) -> &i32 {
        self._glacier_base.frames_to_skip_per_key()
    }
    fn frames_to_skip_per_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.frames_to_skip_per_key_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for RecordVehicleTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for RecordVehicleTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordVehicleTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordVehicleTrackData {
}

impl super::core::DataBusPeerTrait for RecordVehicleTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordVehicleTrackData {
}

impl super::core::DataContainerTrait for RecordVehicleTrackData {
}

pub static RECORDVEHICLETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordVehicleTrackData",
    name_hash: 1708884559,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::RECORDTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(RecordVehicleTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordVehicleTrackData as Default>::default())),
            create_boxed: || Box::new(<RecordVehicleTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ChildrenTracks",
                name_hash: 2657868138,
                flags: MemberInfoFlags::new(144),
                field_type: "RecordTrackChildrenData-Array",
                rust_offset: offset_of!(RecordVehicleTrackData, children_tracks),
            },
        ],
    }),
    array_type: Some(RECORDVEHICLETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordVehicleTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDVEHICLETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDVEHICLETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordVehicleTrackData-Array",
    name_hash: 2224353147,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordVehicleTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RecordRootTransformTrackData {
    pub _glacier_base: super::timeline::RecordTrackChildrenData,
    pub layered_transform_track: Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>,
    pub keyed_transform_track: Option<LockedTypeObject /* super::timeline::KeyedTransformLayerData */>,
}

pub trait RecordRootTransformTrackDataTrait: super::timeline::RecordTrackChildrenDataTrait {
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */>;
    fn keyed_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::KeyedTransformLayerData */>;
    fn keyed_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::KeyedTransformLayerData */>;
}

impl RecordRootTransformTrackDataTrait for RecordRootTransformTrackData {
    fn layered_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::LayeredTransformTrackData */> {
        &mut self.layered_transform_track
    }
    fn keyed_transform_track(&self) -> &Option<LockedTypeObject /* super::timeline::KeyedTransformLayerData */> {
        &self.keyed_transform_track
    }
    fn keyed_transform_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::KeyedTransformLayerData */> {
        &mut self.keyed_transform_track
    }
}

impl super::timeline::RecordTrackChildrenDataTrait for RecordRootTransformTrackData {
}

impl super::timeline::RecordTrackBaseDataTrait for RecordRootTransformTrackData {
    fn frames_to_skip_per_key(&self) -> &i32 {
        self._glacier_base.frames_to_skip_per_key()
    }
    fn frames_to_skip_per_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.frames_to_skip_per_key_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for RecordRootTransformTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for RecordRootTransformTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordRootTransformTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordRootTransformTrackData {
}

impl super::core::DataBusPeerTrait for RecordRootTransformTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordRootTransformTrackData {
}

impl super::core::DataContainerTrait for RecordRootTransformTrackData {
}

pub static RECORDROOTTRANSFORMTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordRootTransformTrackData",
    name_hash: 3961900189,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::RECORDTRACKCHILDRENDATA_TYPE_INFO),
        super_class_offset: offset_of!(RecordRootTransformTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordRootTransformTrackData as Default>::default())),
            create_boxed: || Box::new(<RecordRootTransformTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LayeredTransformTrack",
                name_hash: 76253860,
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(RecordRootTransformTrackData, layered_transform_track),
            },
            FieldInfoData {
                name: "KeyedTransformTrack",
                name_hash: 1126076112,
                flags: MemberInfoFlags::new(0),
                field_type: "KeyedTransformLayerData",
                rust_offset: offset_of!(RecordRootTransformTrackData, keyed_transform_track),
            },
        ],
    }),
    array_type: Some(RECORDROOTTRANSFORMTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordRootTransformTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDROOTTRANSFORMTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDROOTTRANSFORMTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordRootTransformTrackData-Array",
    name_hash: 3978852393,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordRootTransformTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RecordEntryInputTrackData {
    pub _glacier_base: super::timeline::RecordTrackChildrenData,
    pub entry_id: u32,
    pub fire_input: Option<LockedTypeObject /* super::timeline::FloatTrackData */>,
    pub pitch_input: Option<LockedTypeObject /* super::timeline::FloatTrackData */>,
    pub yaw_input: Option<LockedTypeObject /* super::timeline::FloatTrackData */>,
    pub roll_input: Option<LockedTypeObject /* super::timeline::FloatTrackData */>,
    pub throttle_input: Option<LockedTypeObject /* super::timeline::FloatTrackData */>,
    pub digital_bit_flags_input: Option<LockedTypeObject /* super::timeline::FloatTrackData */>,
    pub aiming_yaw: Option<LockedTypeObject /* super::timeline::FloatTrackData */>,
    pub aiming_pitch: Option<LockedTypeObject /* super::timeline::FloatTrackData */>,
}

pub trait RecordEntryInputTrackDataTrait: super::timeline::RecordTrackChildrenDataTrait {
    fn entry_id(&self) -> &u32;
    fn entry_id_mut(&mut self) -> &mut u32;
    fn fire_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn fire_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn pitch_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn pitch_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn yaw_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn yaw_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn roll_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn roll_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn throttle_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn throttle_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn digital_bit_flags_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn digital_bit_flags_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn aiming_yaw(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn aiming_yaw_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn aiming_pitch(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn aiming_pitch_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
}

impl RecordEntryInputTrackDataTrait for RecordEntryInputTrackData {
    fn entry_id(&self) -> &u32 {
        &self.entry_id
    }
    fn entry_id_mut(&mut self) -> &mut u32 {
        &mut self.entry_id
    }
    fn fire_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &self.fire_input
    }
    fn fire_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &mut self.fire_input
    }
    fn pitch_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &self.pitch_input
    }
    fn pitch_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &mut self.pitch_input
    }
    fn yaw_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &self.yaw_input
    }
    fn yaw_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &mut self.yaw_input
    }
    fn roll_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &self.roll_input
    }
    fn roll_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &mut self.roll_input
    }
    fn throttle_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &self.throttle_input
    }
    fn throttle_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &mut self.throttle_input
    }
    fn digital_bit_flags_input(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &self.digital_bit_flags_input
    }
    fn digital_bit_flags_input_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &mut self.digital_bit_flags_input
    }
    fn aiming_yaw(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &self.aiming_yaw
    }
    fn aiming_yaw_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &mut self.aiming_yaw
    }
    fn aiming_pitch(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &self.aiming_pitch
    }
    fn aiming_pitch_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &mut self.aiming_pitch
    }
}

impl super::timeline::RecordTrackChildrenDataTrait for RecordEntryInputTrackData {
}

impl super::timeline::RecordTrackBaseDataTrait for RecordEntryInputTrackData {
    fn frames_to_skip_per_key(&self) -> &i32 {
        self._glacier_base.frames_to_skip_per_key()
    }
    fn frames_to_skip_per_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.frames_to_skip_per_key_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for RecordEntryInputTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for RecordEntryInputTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordEntryInputTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordEntryInputTrackData {
}

impl super::core::DataBusPeerTrait for RecordEntryInputTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordEntryInputTrackData {
}

impl super::core::DataContainerTrait for RecordEntryInputTrackData {
}

pub static RECORDENTRYINPUTTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordEntryInputTrackData",
    name_hash: 207626357,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::RECORDTRACKCHILDRENDATA_TYPE_INFO),
        super_class_offset: offset_of!(RecordEntryInputTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordEntryInputTrackData as Default>::default())),
            create_boxed: || Box::new(<RecordEntryInputTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EntryId",
                name_hash: 8254652,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RecordEntryInputTrackData, entry_id),
            },
            FieldInfoData {
                name: "FireInput",
                name_hash: 1561777387,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, fire_input),
            },
            FieldInfoData {
                name: "PitchInput",
                name_hash: 3051633781,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, pitch_input),
            },
            FieldInfoData {
                name: "YawInput",
                name_hash: 1470517436,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, yaw_input),
            },
            FieldInfoData {
                name: "RollInput",
                name_hash: 3562090830,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, roll_input),
            },
            FieldInfoData {
                name: "ThrottleInput",
                name_hash: 4085115451,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, throttle_input),
            },
            FieldInfoData {
                name: "DigitalBitFlagsInput",
                name_hash: 3182081193,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, digital_bit_flags_input),
            },
            FieldInfoData {
                name: "AimingYaw",
                name_hash: 3507601359,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, aiming_yaw),
            },
            FieldInfoData {
                name: "AimingPitch",
                name_hash: 1543798374,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, aiming_pitch),
            },
        ],
    }),
    array_type: Some(RECORDENTRYINPUTTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordEntryInputTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDENTRYINPUTTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDENTRYINPUTTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordEntryInputTrackData-Array",
    name_hash: 2696892737,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordEntryInputTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RecordEntryInputType {
    #[default]
    RecordEntryInputType_FireInput = 0,
    RecordEntryInputType_PitchInput = 1,
    RecordEntryInputType_YawInput = 2,
    RecordEntryInputType_RollInput = 3,
    RecordEntryInputType_ThrottleInput = 4,
    RecordEntryInputType_DigitalBitFlagsInput = 5,
    RecordEntryInputType_AimingYaw = 6,
    RecordEntryInputType_AimingPitch = 7,
    RecordEntryInputTypeCount = 8,
}

pub static RECORDENTRYINPUTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordEntryInputType",
    name_hash: 572195922,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(RECORDENTRYINPUTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RecordEntryInputType {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDENTRYINPUTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RECORDENTRYINPUTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordEntryInputType-Array",
    name_hash: 151722982,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordEntryInputType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PhysicalCameraTrackData {
    pub _glacier_base: CameraTrackBaseData,
    pub physical_camera_body: Option<LockedTypeObject /* CameraBodyPreset */>,
    pub physical_camera_lens: Option<LockedTypeObject /* CameraLensPreset */>,
    pub exposure_mode: ExposureMode,
    pub auto_exposure_method: super::render_base::AutoExposureMethod,
    pub children: Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>,
}

pub trait PhysicalCameraTrackDataTrait: CameraTrackBaseDataTrait {
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */>;
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */>;
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */>;
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */>;
    fn exposure_mode(&self) -> &ExposureMode;
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode;
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod;
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod;
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>>;
}

impl PhysicalCameraTrackDataTrait for PhysicalCameraTrackData {
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */> {
        &self.physical_camera_body
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */> {
        &mut self.physical_camera_body
    }
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */> {
        &self.physical_camera_lens
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */> {
        &mut self.physical_camera_lens
    }
    fn exposure_mode(&self) -> &ExposureMode {
        &self.exposure_mode
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        &mut self.exposure_mode
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        &self.auto_exposure_method
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        &mut self.auto_exposure_method
    }
    fn children(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &self.children
    }
    fn children_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackData */>> {
        &mut self.children
    }
}

impl CameraTrackBaseDataTrait for PhysicalCameraTrackData {
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for PhysicalCameraTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for PhysicalCameraTrackData {
}

impl super::core::DataBusPeerTrait for PhysicalCameraTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PhysicalCameraTrackData {
}

impl super::core::DataContainerTrait for PhysicalCameraTrackData {
}

pub static PHYSICALCAMERATRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTrackData",
    name_hash: 111012950,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(PhysicalCameraTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicalCameraTrackData as Default>::default())),
            create_boxed: || Box::new(<PhysicalCameraTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicalCameraBody",
                name_hash: 3562743577,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraBodyPreset",
                rust_offset: offset_of!(PhysicalCameraTrackData, physical_camera_body),
            },
            FieldInfoData {
                name: "PhysicalCameraLens",
                name_hash: 3562665885,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraLensPreset",
                rust_offset: offset_of!(PhysicalCameraTrackData, physical_camera_lens),
            },
            FieldInfoData {
                name: "ExposureMode",
                name_hash: 3564732021,
                flags: MemberInfoFlags::new(0),
                field_type: "ExposureMode",
                rust_offset: offset_of!(PhysicalCameraTrackData, exposure_mode),
            },
            FieldInfoData {
                name: "AutoExposureMethod",
                name_hash: 2459920774,
                flags: MemberInfoFlags::new(0),
                field_type: "AutoExposureMethod",
                rust_offset: offset_of!(PhysicalCameraTrackData, auto_exposure_method),
            },
            FieldInfoData {
                name: "Children",
                name_hash: 1297796054,
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(PhysicalCameraTrackData, children),
            },
        ],
    }),
    array_type: Some(PHYSICALCAMERATRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicalCameraTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICALCAMERATRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHYSICALCAMERATRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTrackData-Array",
    name_hash: 2942022114,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicalCameraTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PhysicalCameraTrackUpdateInfo {
    pub transform: super::core::LinearTransform,
    pub field_of_view: f32,
    pub focal_length: f32,
    pub focus_distance: f32,
    pub exposure_compensation: f32,
    pub aperture: f32,
    pub shutter_speed: f32,
    pub e_v: f32,
    pub i_s_o: f32,
    pub spot_meter_scale: f32,
    pub spot_meter_offset_x: f32,
    pub spot_meter_offset_y: f32,
    pub near_plane: f32,
    pub far_plane: f32,
}

pub trait PhysicalCameraTrackUpdateInfoTrait: TypeObject {
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn field_of_view(&self) -> &f32;
    fn field_of_view_mut(&mut self) -> &mut f32;
    fn focal_length(&self) -> &f32;
    fn focal_length_mut(&mut self) -> &mut f32;
    fn focus_distance(&self) -> &f32;
    fn focus_distance_mut(&mut self) -> &mut f32;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn aperture(&self) -> &f32;
    fn aperture_mut(&mut self) -> &mut f32;
    fn shutter_speed(&self) -> &f32;
    fn shutter_speed_mut(&mut self) -> &mut f32;
    fn e_v(&self) -> &f32;
    fn e_v_mut(&mut self) -> &mut f32;
    fn i_s_o(&self) -> &f32;
    fn i_s_o_mut(&mut self) -> &mut f32;
    fn spot_meter_scale(&self) -> &f32;
    fn spot_meter_scale_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_x(&self) -> &f32;
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_y(&self) -> &f32;
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32;
    fn near_plane(&self) -> &f32;
    fn near_plane_mut(&mut self) -> &mut f32;
    fn far_plane(&self) -> &f32;
    fn far_plane_mut(&mut self) -> &mut f32;
}

impl PhysicalCameraTrackUpdateInfoTrait for PhysicalCameraTrackUpdateInfo {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn field_of_view(&self) -> &f32 {
        &self.field_of_view
    }
    fn field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view
    }
    fn focal_length(&self) -> &f32 {
        &self.focal_length
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        &mut self.focal_length
    }
    fn focus_distance(&self) -> &f32 {
        &self.focus_distance
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        &mut self.focus_distance
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn aperture(&self) -> &f32 {
        &self.aperture
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        &mut self.aperture
    }
    fn shutter_speed(&self) -> &f32 {
        &self.shutter_speed
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        &mut self.shutter_speed
    }
    fn e_v(&self) -> &f32 {
        &self.e_v
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        &mut self.e_v
    }
    fn i_s_o(&self) -> &f32 {
        &self.i_s_o
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        &mut self.i_s_o
    }
    fn spot_meter_scale(&self) -> &f32 {
        &self.spot_meter_scale
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_scale
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        &self.spot_meter_offset_x
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_x
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        &self.spot_meter_offset_y
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_y
    }
    fn near_plane(&self) -> &f32 {
        &self.near_plane
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        &mut self.near_plane
    }
    fn far_plane(&self) -> &f32 {
        &self.far_plane
    }
    fn far_plane_mut(&mut self) -> &mut f32 {
        &mut self.far_plane
    }
}

pub static PHYSICALCAMERATRACKUPDATEINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTrackUpdateInfo",
    name_hash: 98190905,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicalCameraTrackUpdateInfo as Default>::default())),
            create_boxed: || Box::new(<PhysicalCameraTrackUpdateInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                name_hash: 2270319721,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, transform),
            },
            FieldInfoData {
                name: "FieldOfView",
                name_hash: 2227716035,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, field_of_view),
            },
            FieldInfoData {
                name: "FocalLength",
                name_hash: 1499741854,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, focal_length),
            },
            FieldInfoData {
                name: "FocusDistance",
                name_hash: 1402926186,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, focus_distance),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                name_hash: 3835253666,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, exposure_compensation),
            },
            FieldInfoData {
                name: "Aperture",
                name_hash: 1885994293,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, aperture),
            },
            FieldInfoData {
                name: "ShutterSpeed",
                name_hash: 488177211,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, shutter_speed),
            },
            FieldInfoData {
                name: "EV",
                name_hash: 5861814,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, e_v),
            },
            FieldInfoData {
                name: "ISO",
                name_hash: 193452880,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, i_s_o),
            },
            FieldInfoData {
                name: "SpotMeterScale",
                name_hash: 1691011758,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, spot_meter_scale),
            },
            FieldInfoData {
                name: "SpotMeterOffsetX",
                name_hash: 3433992131,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, spot_meter_offset_x),
            },
            FieldInfoData {
                name: "SpotMeterOffsetY",
                name_hash: 3433992130,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, spot_meter_offset_y),
            },
            FieldInfoData {
                name: "NearPlane",
                name_hash: 3156145579,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, near_plane),
            },
            FieldInfoData {
                name: "FarPlane",
                name_hash: 192290566,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, far_plane),
            },
        ],
    }),
    array_type: Some(PHYSICALCAMERATRACKUPDATEINFO_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PhysicalCameraTrackUpdateInfo {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICALCAMERATRACKUPDATEINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PHYSICALCAMERATRACKUPDATEINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTrackUpdateInfo-Array",
    name_hash: 1277047949,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicalCameraTrackUpdateInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PathTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub path_entity_guid: glacier_util::guid::Guid,
    pub force_upright: bool,
    pub up_axis: super::core::Vec3,
    pub timing_curve: Option<LockedTypeObject /* super::timeline::FloatTrackData */>,
    pub attach_offset: super::core::LinearTransform,
}

pub trait PathTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn path_entity_guid(&self) -> &glacier_util::guid::Guid;
    fn path_entity_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn force_upright(&self) -> &bool;
    fn force_upright_mut(&mut self) -> &mut bool;
    fn up_axis(&self) -> &super::core::Vec3;
    fn up_axis_mut(&mut self) -> &mut super::core::Vec3;
    fn timing_curve(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn timing_curve_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */>;
    fn attach_offset(&self) -> &super::core::LinearTransform;
    fn attach_offset_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl PathTransformLayerDataTrait for PathTransformLayerData {
    fn path_entity_guid(&self) -> &glacier_util::guid::Guid {
        &self.path_entity_guid
    }
    fn path_entity_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.path_entity_guid
    }
    fn force_upright(&self) -> &bool {
        &self.force_upright
    }
    fn force_upright_mut(&mut self) -> &mut bool {
        &mut self.force_upright
    }
    fn up_axis(&self) -> &super::core::Vec3 {
        &self.up_axis
    }
    fn up_axis_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.up_axis
    }
    fn timing_curve(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &self.timing_curve
    }
    fn timing_curve_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        &mut self.timing_curve
    }
    fn attach_offset(&self) -> &super::core::LinearTransform {
        &self.attach_offset
    }
    fn attach_offset_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.attach_offset
    }
}

impl super::timeline::TransformLayerDataTrait for PathTransformLayerData {
    fn weight(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for PathTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for PathTransformLayerData {
}

impl super::core::DataBusPeerTrait for PathTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PathTransformLayerData {
}

impl super::core::DataContainerTrait for PathTransformLayerData {
}

pub static PATHTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathTransformLayerData",
    name_hash: 1875429591,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        super_class_offset: offset_of!(PathTransformLayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PathTransformLayerData as Default>::default())),
            create_boxed: || Box::new(<PathTransformLayerData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PathEntityGuid",
                name_hash: 1922468812,
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(PathTransformLayerData, path_entity_guid),
            },
            FieldInfoData {
                name: "ForceUpright",
                name_hash: 2184276957,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PathTransformLayerData, force_upright),
            },
            FieldInfoData {
                name: "UpAxis",
                name_hash: 2936645795,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PathTransformLayerData, up_axis),
            },
            FieldInfoData {
                name: "TimingCurve",
                name_hash: 2679769986,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(PathTransformLayerData, timing_curve),
            },
            FieldInfoData {
                name: "AttachOffset",
                name_hash: 4087467523,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PathTransformLayerData, attach_offset),
            },
        ],
    }),
    array_type: Some(PATHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PathTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        PATHTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PATHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathTransformLayerData-Array",
    name_hash: 51413475,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PathTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GroundAttachTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub attach_method: GroundAttachMethod,
    pub raycast_start_height: f32,
    pub raycast_end_height: f32,
    pub allow_above_ground: bool,
}

pub trait GroundAttachTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn attach_method(&self) -> &GroundAttachMethod;
    fn attach_method_mut(&mut self) -> &mut GroundAttachMethod;
    fn raycast_start_height(&self) -> &f32;
    fn raycast_start_height_mut(&mut self) -> &mut f32;
    fn raycast_end_height(&self) -> &f32;
    fn raycast_end_height_mut(&mut self) -> &mut f32;
    fn allow_above_ground(&self) -> &bool;
    fn allow_above_ground_mut(&mut self) -> &mut bool;
}

impl GroundAttachTransformLayerDataTrait for GroundAttachTransformLayerData {
    fn attach_method(&self) -> &GroundAttachMethod {
        &self.attach_method
    }
    fn attach_method_mut(&mut self) -> &mut GroundAttachMethod {
        &mut self.attach_method
    }
    fn raycast_start_height(&self) -> &f32 {
        &self.raycast_start_height
    }
    fn raycast_start_height_mut(&mut self) -> &mut f32 {
        &mut self.raycast_start_height
    }
    fn raycast_end_height(&self) -> &f32 {
        &self.raycast_end_height
    }
    fn raycast_end_height_mut(&mut self) -> &mut f32 {
        &mut self.raycast_end_height
    }
    fn allow_above_ground(&self) -> &bool {
        &self.allow_above_ground
    }
    fn allow_above_ground_mut(&mut self) -> &mut bool {
        &mut self.allow_above_ground
    }
}

impl super::timeline::TransformLayerDataTrait for GroundAttachTransformLayerData {
    fn weight(&self) -> &Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::FloatTrackData */> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for GroundAttachTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for GroundAttachTransformLayerData {
}

impl super::core::DataBusPeerTrait for GroundAttachTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GroundAttachTransformLayerData {
}

impl super::core::DataContainerTrait for GroundAttachTransformLayerData {
}

pub static GROUNDATTACHTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundAttachTransformLayerData",
    name_hash: 2243539892,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        super_class_offset: offset_of!(GroundAttachTransformLayerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GroundAttachTransformLayerData as Default>::default())),
            create_boxed: || Box::new(<GroundAttachTransformLayerData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AttachMethod",
                name_hash: 4008719569,
                flags: MemberInfoFlags::new(0),
                field_type: "GroundAttachMethod",
                rust_offset: offset_of!(GroundAttachTransformLayerData, attach_method),
            },
            FieldInfoData {
                name: "RaycastStartHeight",
                name_hash: 2230317141,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GroundAttachTransformLayerData, raycast_start_height),
            },
            FieldInfoData {
                name: "RaycastEndHeight",
                name_hash: 3004021338,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GroundAttachTransformLayerData, raycast_end_height),
            },
            FieldInfoData {
                name: "AllowAboveGround",
                name_hash: 811224806,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GroundAttachTransformLayerData, allow_above_ground),
            },
        ],
    }),
    array_type: Some(GROUNDATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GroundAttachTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        GROUNDATTACHTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GROUNDATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundAttachTransformLayerData-Array",
    name_hash: 170053376,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GroundAttachTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GroundAttachMethod {
    #[default]
    GroundAttachMethod_SyncRaycast = 0,
    GroundAttachMethod_AsyncRaycast = 1,
}

pub static GROUNDATTACHMETHOD_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundAttachMethod",
    name_hash: 3048357876,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(GROUNDATTACHMETHOD_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GroundAttachMethod {
    fn type_info(&self) -> &'static TypeInfo {
        GROUNDATTACHMETHOD_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GROUNDATTACHMETHOD_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundAttachMethod-Array",
    name_hash: 1663011776,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GroundAttachMethod"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameplayCameraTrackData {
    pub _glacier_base: CameraTrackBaseData,
}

pub trait GameplayCameraTrackDataTrait: CameraTrackBaseDataTrait {
}

impl GameplayCameraTrackDataTrait for GameplayCameraTrackData {
}

impl CameraTrackBaseDataTrait for GameplayCameraTrackData {
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for GameplayCameraTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for GameplayCameraTrackData {
}

impl super::core::DataBusPeerTrait for GameplayCameraTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameplayCameraTrackData {
}

impl super::core::DataContainerTrait for GameplayCameraTrackData {
}

pub static GAMEPLAYCAMERATRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayCameraTrackData",
    name_hash: 2489620521,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(GameplayCameraTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameplayCameraTrackData as Default>::default())),
            create_boxed: || Box::new(<GameplayCameraTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMEPLAYCAMERATRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameplayCameraTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEPLAYCAMERATRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEPLAYCAMERATRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayCameraTrackData-Array",
    name_hash: 1913339549,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameplayCameraTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RawFileDataAsset {
    pub _glacier_base: RawFileAsset,
    pub raw_data: Vec<u8>,
    pub size: u32,
}

pub trait RawFileDataAssetTrait: RawFileAssetTrait {
    fn raw_data(&self) -> &Vec<u8>;
    fn raw_data_mut(&mut self) -> &mut Vec<u8>;
    fn size(&self) -> &u32;
    fn size_mut(&mut self) -> &mut u32;
}

impl RawFileDataAssetTrait for RawFileDataAsset {
    fn raw_data(&self) -> &Vec<u8> {
        &self.raw_data
    }
    fn raw_data_mut(&mut self) -> &mut Vec<u8> {
        &mut self.raw_data
    }
    fn size(&self) -> &u32 {
        &self.size
    }
    fn size_mut(&mut self) -> &mut u32 {
        &mut self.size
    }
}

impl RawFileAssetTrait for RawFileDataAsset {
}

impl super::core::AssetTrait for RawFileDataAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RawFileDataAsset {
}

pub static RAWFILEDATAASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileDataAsset",
    name_hash: 3728526951,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RAWFILEASSET_TYPE_INFO),
        super_class_offset: offset_of!(RawFileDataAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RawFileDataAsset as Default>::default())),
            create_boxed: || Box::new(<RawFileDataAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RawData",
                name_hash: 1456371441,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(RawFileDataAsset, raw_data),
            },
            FieldInfoData {
                name: "Size",
                name_hash: 2089429248,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RawFileDataAsset, size),
            },
        ],
    }),
    array_type: Some(RAWFILEDATAASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RawFileDataAsset {
    fn type_info(&self) -> &'static TypeInfo {
        RAWFILEDATAASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RAWFILEDATAASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileDataAsset-Array",
    name_hash: 1191178323,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RawFileDataAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RawFileResourceAsset {
    pub _glacier_base: RawFileAsset,
    pub resource: glacier_reflect::builtin::ResourceRef,
}

pub trait RawFileResourceAssetTrait: RawFileAssetTrait {
    fn resource(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn resource_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
}

impl RawFileResourceAssetTrait for RawFileResourceAsset {
    fn resource(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.resource
    }
    fn resource_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.resource
    }
}

impl RawFileAssetTrait for RawFileResourceAsset {
}

impl super::core::AssetTrait for RawFileResourceAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RawFileResourceAsset {
}

pub static RAWFILERESOURCEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileResourceAsset",
    name_hash: 578100317,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RAWFILEASSET_TYPE_INFO),
        super_class_offset: offset_of!(RawFileResourceAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RawFileResourceAsset as Default>::default())),
            create_boxed: || Box::new(<RawFileResourceAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Resource",
                name_hash: 74513935,
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(RawFileResourceAsset, resource),
            },
        ],
    }),
    array_type: Some(RAWFILERESOURCEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RawFileResourceAsset {
    fn type_info(&self) -> &'static TypeInfo {
        RAWFILERESOURCEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RAWFILERESOURCEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileResourceAsset-Array",
    name_hash: 1314953321,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RawFileResourceAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RawFileAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait RawFileAssetTrait: super::core::AssetTrait {
}

impl RawFileAssetTrait for RawFileAsset {
}

impl super::core::AssetTrait for RawFileAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RawFileAsset {
}

pub static RAWFILEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileAsset",
    name_hash: 277704791,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(RawFileAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RawFileAsset as Default>::default())),
            create_boxed: || Box::new(<RawFileAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(RAWFILEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RawFileAsset {
    fn type_info(&self) -> &'static TypeInfo {
        RAWFILEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RAWFILEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileAsset-Array",
    name_hash: 3784624483,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RawFileAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayAnimationVisualizerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
}

pub trait PlayAnimationVisualizerEntityDataTrait: super::entity::SpatialEntityDataTrait {
}

impl PlayAnimationVisualizerEntityDataTrait for PlayAnimationVisualizerEntityData {
}

impl super::entity::SpatialEntityDataTrait for PlayAnimationVisualizerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PlayAnimationVisualizerEntityData {
}

impl super::entity::GameObjectDataTrait for PlayAnimationVisualizerEntityData {
}

impl super::core::DataBusPeerTrait for PlayAnimationVisualizerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayAnimationVisualizerEntityData {
}

impl super::core::DataContainerTrait for PlayAnimationVisualizerEntityData {
}

pub static PLAYANIMATIONVISUALIZERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationVisualizerEntityData",
    name_hash: 84908524,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlayAnimationVisualizerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayAnimationVisualizerEntityData as Default>::default())),
            create_boxed: || Box::new(<PlayAnimationVisualizerEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(PLAYANIMATIONVISUALIZERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayAnimationVisualizerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYANIMATIONVISUALIZERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYANIMATIONVISUALIZERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationVisualizerEntityData-Array",
    name_hash: 1887762904,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayAnimationVisualizerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PhysicsDrivenAnimationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub binding: PhysicsDrivenAnimationEntityBinding,
    pub animation_entity_space_priority: i32,
}

pub trait PhysicsDrivenAnimationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn binding(&self) -> &PhysicsDrivenAnimationEntityBinding;
    fn binding_mut(&mut self) -> &mut PhysicsDrivenAnimationEntityBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
}

impl PhysicsDrivenAnimationEntityDataTrait for PhysicsDrivenAnimationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn binding(&self) -> &PhysicsDrivenAnimationEntityBinding {
        &self.binding
    }
    fn binding_mut(&mut self) -> &mut PhysicsDrivenAnimationEntityBinding {
        &mut self.binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
}

impl super::entity::EntityDataTrait for PhysicsDrivenAnimationEntityData {
}

impl super::entity::GameObjectDataTrait for PhysicsDrivenAnimationEntityData {
}

impl super::core::DataBusPeerTrait for PhysicsDrivenAnimationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PhysicsDrivenAnimationEntityData {
}

impl super::core::DataContainerTrait for PhysicsDrivenAnimationEntityData {
}

pub static PHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenAnimationEntityData",
    name_hash: 2872055729,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PhysicsDrivenAnimationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsDrivenAnimationEntityData as Default>::default())),
            create_boxed: || Box::new(<PhysicsDrivenAnimationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityData, realm),
            },
            FieldInfoData {
                name: "Binding",
                name_hash: 2590060228,
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsDrivenAnimationEntityBinding",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityData, binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                name_hash: 4041607518,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityData, animation_entity_space_priority),
            },
        ],
    }),
    array_type: Some(PHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsDrivenAnimationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenAnimationEntityData-Array",
    name_hash: 1668008453,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicsDrivenAnimationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PhysicsDrivenAnimationEntityBinding {
    pub physics_motion_target: super::ant::AntRef,
    pub aim_left_right: super::ant::AntRef,
    pub aim_up_down: super::ant::AntRef,
    pub crouch: super::ant::AntRef,
    pub force_set_trajectory: super::ant::AntRef,
    pub in_air: super::ant::AntRef,
    pub skydive: super::ant::AntRef,
    pub parachute: super::ant::AntRef,
    pub swim: super::ant::AntRef,
    pub input_backward: super::ant::AntRef,
    pub input_forward: super::ant::AntRef,
    pub input_left: super::ant::AntRef,
    pub input_right: super::ant::AntRef,
    pub input_exclusive_backward: super::ant::AntRef,
    pub input_exclusive_forward: super::ant::AntRef,
    pub input_exclusive_left: super::ant::AntRef,
    pub input_exclusive_right: super::ant::AntRef,
    pub is_enemy: super::ant::AntRef,
    pub jump: super::ant::AntRef,
    pub lean_left_right: super::ant::AntRef,
    pub prone: super::ant::AntRef,
    pub sprint: super::ant::AntRef,
    pub ground_supported: super::ant::AntRef,
    pub ground_normal: super::ant::AntRef,
    pub ground_distance: super::ant::AntRef,
    pub ground_angle_z: super::ant::AntRef,
    pub ground_angle_x: super::ant::AntRef,
    pub ground_angle_facing_pitch: super::ant::AntRef,
    pub ground_angle_facing_roll: super::ant::AntRef,
    pub is_client_animatable: super::ant::AntRef,
    pub vertical_impact: super::ant::AntRef,
    pub vertical_impact_speed: super::ant::AntRef,
    pub false_signal: super::ant::AntRef,
    pub lock_arms_to_camera_weight: super::ant::AntRef,
    pub wind_direction: super::ant::AntRef,
    pub wind_strength: super::ant::AntRef,
    pub water_depth: super::ant::AntRef,
    pub eye_water_depth: super::ant::AntRef,
}

pub trait PhysicsDrivenAnimationEntityBindingTrait: TypeObject {
    fn physics_motion_target(&self) -> &super::ant::AntRef;
    fn physics_motion_target_mut(&mut self) -> &mut super::ant::AntRef;
    fn aim_left_right(&self) -> &super::ant::AntRef;
    fn aim_left_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn aim_up_down(&self) -> &super::ant::AntRef;
    fn aim_up_down_mut(&mut self) -> &mut super::ant::AntRef;
    fn crouch(&self) -> &super::ant::AntRef;
    fn crouch_mut(&mut self) -> &mut super::ant::AntRef;
    fn force_set_trajectory(&self) -> &super::ant::AntRef;
    fn force_set_trajectory_mut(&mut self) -> &mut super::ant::AntRef;
    fn in_air(&self) -> &super::ant::AntRef;
    fn in_air_mut(&mut self) -> &mut super::ant::AntRef;
    fn skydive(&self) -> &super::ant::AntRef;
    fn skydive_mut(&mut self) -> &mut super::ant::AntRef;
    fn parachute(&self) -> &super::ant::AntRef;
    fn parachute_mut(&mut self) -> &mut super::ant::AntRef;
    fn swim(&self) -> &super::ant::AntRef;
    fn swim_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_backward(&self) -> &super::ant::AntRef;
    fn input_backward_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_forward(&self) -> &super::ant::AntRef;
    fn input_forward_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_left(&self) -> &super::ant::AntRef;
    fn input_left_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_right(&self) -> &super::ant::AntRef;
    fn input_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_exclusive_backward(&self) -> &super::ant::AntRef;
    fn input_exclusive_backward_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_exclusive_forward(&self) -> &super::ant::AntRef;
    fn input_exclusive_forward_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_exclusive_left(&self) -> &super::ant::AntRef;
    fn input_exclusive_left_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_exclusive_right(&self) -> &super::ant::AntRef;
    fn input_exclusive_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_enemy(&self) -> &super::ant::AntRef;
    fn is_enemy_mut(&mut self) -> &mut super::ant::AntRef;
    fn jump(&self) -> &super::ant::AntRef;
    fn jump_mut(&mut self) -> &mut super::ant::AntRef;
    fn lean_left_right(&self) -> &super::ant::AntRef;
    fn lean_left_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn prone(&self) -> &super::ant::AntRef;
    fn prone_mut(&mut self) -> &mut super::ant::AntRef;
    fn sprint(&self) -> &super::ant::AntRef;
    fn sprint_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_supported(&self) -> &super::ant::AntRef;
    fn ground_supported_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_normal(&self) -> &super::ant::AntRef;
    fn ground_normal_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_distance(&self) -> &super::ant::AntRef;
    fn ground_distance_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_angle_z(&self) -> &super::ant::AntRef;
    fn ground_angle_z_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_angle_x(&self) -> &super::ant::AntRef;
    fn ground_angle_x_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_angle_facing_pitch(&self) -> &super::ant::AntRef;
    fn ground_angle_facing_pitch_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_angle_facing_roll(&self) -> &super::ant::AntRef;
    fn ground_angle_facing_roll_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_client_animatable(&self) -> &super::ant::AntRef;
    fn is_client_animatable_mut(&mut self) -> &mut super::ant::AntRef;
    fn vertical_impact(&self) -> &super::ant::AntRef;
    fn vertical_impact_mut(&mut self) -> &mut super::ant::AntRef;
    fn vertical_impact_speed(&self) -> &super::ant::AntRef;
    fn vertical_impact_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn false_signal(&self) -> &super::ant::AntRef;
    fn false_signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn lock_arms_to_camera_weight(&self) -> &super::ant::AntRef;
    fn lock_arms_to_camera_weight_mut(&mut self) -> &mut super::ant::AntRef;
    fn wind_direction(&self) -> &super::ant::AntRef;
    fn wind_direction_mut(&mut self) -> &mut super::ant::AntRef;
    fn wind_strength(&self) -> &super::ant::AntRef;
    fn wind_strength_mut(&mut self) -> &mut super::ant::AntRef;
    fn water_depth(&self) -> &super::ant::AntRef;
    fn water_depth_mut(&mut self) -> &mut super::ant::AntRef;
    fn eye_water_depth(&self) -> &super::ant::AntRef;
    fn eye_water_depth_mut(&mut self) -> &mut super::ant::AntRef;
}

impl PhysicsDrivenAnimationEntityBindingTrait for PhysicsDrivenAnimationEntityBinding {
    fn physics_motion_target(&self) -> &super::ant::AntRef {
        &self.physics_motion_target
    }
    fn physics_motion_target_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.physics_motion_target
    }
    fn aim_left_right(&self) -> &super::ant::AntRef {
        &self.aim_left_right
    }
    fn aim_left_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.aim_left_right
    }
    fn aim_up_down(&self) -> &super::ant::AntRef {
        &self.aim_up_down
    }
    fn aim_up_down_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.aim_up_down
    }
    fn crouch(&self) -> &super::ant::AntRef {
        &self.crouch
    }
    fn crouch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.crouch
    }
    fn force_set_trajectory(&self) -> &super::ant::AntRef {
        &self.force_set_trajectory
    }
    fn force_set_trajectory_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.force_set_trajectory
    }
    fn in_air(&self) -> &super::ant::AntRef {
        &self.in_air
    }
    fn in_air_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_air
    }
    fn skydive(&self) -> &super::ant::AntRef {
        &self.skydive
    }
    fn skydive_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.skydive
    }
    fn parachute(&self) -> &super::ant::AntRef {
        &self.parachute
    }
    fn parachute_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.parachute
    }
    fn swim(&self) -> &super::ant::AntRef {
        &self.swim
    }
    fn swim_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.swim
    }
    fn input_backward(&self) -> &super::ant::AntRef {
        &self.input_backward
    }
    fn input_backward_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_backward
    }
    fn input_forward(&self) -> &super::ant::AntRef {
        &self.input_forward
    }
    fn input_forward_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_forward
    }
    fn input_left(&self) -> &super::ant::AntRef {
        &self.input_left
    }
    fn input_left_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_left
    }
    fn input_right(&self) -> &super::ant::AntRef {
        &self.input_right
    }
    fn input_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_right
    }
    fn input_exclusive_backward(&self) -> &super::ant::AntRef {
        &self.input_exclusive_backward
    }
    fn input_exclusive_backward_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_exclusive_backward
    }
    fn input_exclusive_forward(&self) -> &super::ant::AntRef {
        &self.input_exclusive_forward
    }
    fn input_exclusive_forward_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_exclusive_forward
    }
    fn input_exclusive_left(&self) -> &super::ant::AntRef {
        &self.input_exclusive_left
    }
    fn input_exclusive_left_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_exclusive_left
    }
    fn input_exclusive_right(&self) -> &super::ant::AntRef {
        &self.input_exclusive_right
    }
    fn input_exclusive_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_exclusive_right
    }
    fn is_enemy(&self) -> &super::ant::AntRef {
        &self.is_enemy
    }
    fn is_enemy_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_enemy
    }
    fn jump(&self) -> &super::ant::AntRef {
        &self.jump
    }
    fn jump_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.jump
    }
    fn lean_left_right(&self) -> &super::ant::AntRef {
        &self.lean_left_right
    }
    fn lean_left_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.lean_left_right
    }
    fn prone(&self) -> &super::ant::AntRef {
        &self.prone
    }
    fn prone_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.prone
    }
    fn sprint(&self) -> &super::ant::AntRef {
        &self.sprint
    }
    fn sprint_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.sprint
    }
    fn ground_supported(&self) -> &super::ant::AntRef {
        &self.ground_supported
    }
    fn ground_supported_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_supported
    }
    fn ground_normal(&self) -> &super::ant::AntRef {
        &self.ground_normal
    }
    fn ground_normal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_normal
    }
    fn ground_distance(&self) -> &super::ant::AntRef {
        &self.ground_distance
    }
    fn ground_distance_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_distance
    }
    fn ground_angle_z(&self) -> &super::ant::AntRef {
        &self.ground_angle_z
    }
    fn ground_angle_z_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_angle_z
    }
    fn ground_angle_x(&self) -> &super::ant::AntRef {
        &self.ground_angle_x
    }
    fn ground_angle_x_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_angle_x
    }
    fn ground_angle_facing_pitch(&self) -> &super::ant::AntRef {
        &self.ground_angle_facing_pitch
    }
    fn ground_angle_facing_pitch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_angle_facing_pitch
    }
    fn ground_angle_facing_roll(&self) -> &super::ant::AntRef {
        &self.ground_angle_facing_roll
    }
    fn ground_angle_facing_roll_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_angle_facing_roll
    }
    fn is_client_animatable(&self) -> &super::ant::AntRef {
        &self.is_client_animatable
    }
    fn is_client_animatable_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_client_animatable
    }
    fn vertical_impact(&self) -> &super::ant::AntRef {
        &self.vertical_impact
    }
    fn vertical_impact_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vertical_impact
    }
    fn vertical_impact_speed(&self) -> &super::ant::AntRef {
        &self.vertical_impact_speed
    }
    fn vertical_impact_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vertical_impact_speed
    }
    fn false_signal(&self) -> &super::ant::AntRef {
        &self.false_signal
    }
    fn false_signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.false_signal
    }
    fn lock_arms_to_camera_weight(&self) -> &super::ant::AntRef {
        &self.lock_arms_to_camera_weight
    }
    fn lock_arms_to_camera_weight_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.lock_arms_to_camera_weight
    }
    fn wind_direction(&self) -> &super::ant::AntRef {
        &self.wind_direction
    }
    fn wind_direction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.wind_direction
    }
    fn wind_strength(&self) -> &super::ant::AntRef {
        &self.wind_strength
    }
    fn wind_strength_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.wind_strength
    }
    fn water_depth(&self) -> &super::ant::AntRef {
        &self.water_depth
    }
    fn water_depth_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.water_depth
    }
    fn eye_water_depth(&self) -> &super::ant::AntRef {
        &self.eye_water_depth
    }
    fn eye_water_depth_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.eye_water_depth
    }
}

pub static PHYSICSDRIVENANIMATIONENTITYBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenAnimationEntityBinding",
    name_hash: 3425635456,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsDrivenAnimationEntityBinding as Default>::default())),
            create_boxed: || Box::new(<PhysicsDrivenAnimationEntityBinding as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsMotionTarget",
                name_hash: 615009921,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, physics_motion_target),
            },
            FieldInfoData {
                name: "AimLeftRight",
                name_hash: 159833211,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, aim_left_right),
            },
            FieldInfoData {
                name: "AimUpDown",
                name_hash: 2778567511,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, aim_up_down),
            },
            FieldInfoData {
                name: "Crouch",
                name_hash: 2729602053,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, crouch),
            },
            FieldInfoData {
                name: "ForceSetTrajectory",
                name_hash: 622503969,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, force_set_trajectory),
            },
            FieldInfoData {
                name: "InAir",
                name_hash: 214471736,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, in_air),
            },
            FieldInfoData {
                name: "Skydive",
                name_hash: 2978576858,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, skydive),
            },
            FieldInfoData {
                name: "Parachute",
                name_hash: 2952549480,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, parachute),
            },
            FieldInfoData {
                name: "Swim",
                name_hash: 2089393637,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, swim),
            },
            FieldInfoData {
                name: "InputBackward",
                name_hash: 1803140280,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_backward),
            },
            FieldInfoData {
                name: "InputForward",
                name_hash: 1377055592,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_forward),
            },
            FieldInfoData {
                name: "InputLeft",
                name_hash: 2652303016,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_left),
            },
            FieldInfoData {
                name: "InputRight",
                name_hash: 1586915283,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_right),
            },
            FieldInfoData {
                name: "InputExclusiveBackward",
                name_hash: 3718019510,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_exclusive_backward),
            },
            FieldInfoData {
                name: "InputExclusiveForward",
                name_hash: 2660357286,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_exclusive_forward),
            },
            FieldInfoData {
                name: "InputExclusiveLeft",
                name_hash: 3215857702,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_exclusive_left),
            },
            FieldInfoData {
                name: "InputExclusiveRight",
                name_hash: 3036685469,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_exclusive_right),
            },
            FieldInfoData {
                name: "IsEnemy",
                name_hash: 2758954501,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, is_enemy),
            },
            FieldInfoData {
                name: "Jump",
                name_hash: 2089106695,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, jump),
            },
            FieldInfoData {
                name: "LeanLeftRight",
                name_hash: 1838371096,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, lean_left_right),
            },
            FieldInfoData {
                name: "Prone",
                name_hash: 231940067,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, prone),
            },
            FieldInfoData {
                name: "Sprint",
                name_hash: 3324856903,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, sprint),
            },
            FieldInfoData {
                name: "GroundSupported",
                name_hash: 3938707566,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_supported),
            },
            FieldInfoData {
                name: "GroundNormal",
                name_hash: 3081183731,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_normal),
            },
            FieldInfoData {
                name: "GroundDistance",
                name_hash: 1468700707,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_distance),
            },
            FieldInfoData {
                name: "GroundAngleZ",
                name_hash: 2681866779,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_angle_z),
            },
            FieldInfoData {
                name: "GroundAngleX",
                name_hash: 2681866777,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_angle_x),
            },
            FieldInfoData {
                name: "GroundAngleFacingPitch",
                name_hash: 3899008643,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_angle_facing_pitch),
            },
            FieldInfoData {
                name: "GroundAngleFacingRoll",
                name_hash: 3111815000,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_angle_facing_roll),
            },
            FieldInfoData {
                name: "IsClientAnimatable",
                name_hash: 2825869266,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, is_client_animatable),
            },
            FieldInfoData {
                name: "VerticalImpact",
                name_hash: 2494325141,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, vertical_impact),
            },
            FieldInfoData {
                name: "VerticalImpactSpeed",
                name_hash: 62140690,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, vertical_impact_speed),
            },
            FieldInfoData {
                name: "FalseSignal",
                name_hash: 486591334,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, false_signal),
            },
            FieldInfoData {
                name: "LockArmsToCameraWeight",
                name_hash: 4025942465,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, lock_arms_to_camera_weight),
            },
            FieldInfoData {
                name: "WindDirection",
                name_hash: 3147800788,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, wind_direction),
            },
            FieldInfoData {
                name: "WindStrength",
                name_hash: 3768589012,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, wind_strength),
            },
            FieldInfoData {
                name: "WaterDepth",
                name_hash: 14084381,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, water_depth),
            },
            FieldInfoData {
                name: "EyeWaterDepth",
                name_hash: 415840516,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, eye_water_depth),
            },
        ],
    }),
    array_type: Some(PHYSICSDRIVENANIMATIONENTITYBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PhysicsDrivenAnimationEntityBinding {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSDRIVENANIMATIONENTITYBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PHYSICSDRIVENANIMATIONENTITYBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenAnimationEntityBinding-Array",
    name_hash: 2416251572,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicsDrivenAnimationEntityBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PersistenceStatGroup {
    pub _glacier_base: super::core::DataContainer,
    pub group_name: String,
}

pub trait PersistenceStatGroupTrait: super::core::DataContainerTrait {
    fn group_name(&self) -> &String;
    fn group_name_mut(&mut self) -> &mut String;
}

impl PersistenceStatGroupTrait for PersistenceStatGroup {
    fn group_name(&self) -> &String {
        &self.group_name
    }
    fn group_name_mut(&mut self) -> &mut String {
        &mut self.group_name
    }
}

impl super::core::DataContainerTrait for PersistenceStatGroup {
}

pub static PERSISTENCESTATGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceStatGroup",
    name_hash: 1715771999,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(PersistenceStatGroup, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceStatGroup as Default>::default())),
            create_boxed: || Box::new(<PersistenceStatGroup as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GroupName",
                name_hash: 3178263901,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistenceStatGroup, group_name),
            },
        ],
    }),
    array_type: Some(PERSISTENCESTATGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceStatGroup {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCESTATGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCESTATGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceStatGroup-Array",
    name_hash: 3036860267,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceStatGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PersistenceStatTable {
    pub _glacier_base: super::core::DataContainer,
    pub table_name: String,
    pub owner_persistence_data: Option<LockedTypeObject /* AbstractPersistenceData */>,
}

pub trait PersistenceStatTableTrait: super::core::DataContainerTrait {
    fn table_name(&self) -> &String;
    fn table_name_mut(&mut self) -> &mut String;
    fn owner_persistence_data(&self) -> &Option<LockedTypeObject /* AbstractPersistenceData */>;
    fn owner_persistence_data_mut(&mut self) -> &mut Option<LockedTypeObject /* AbstractPersistenceData */>;
}

impl PersistenceStatTableTrait for PersistenceStatTable {
    fn table_name(&self) -> &String {
        &self.table_name
    }
    fn table_name_mut(&mut self) -> &mut String {
        &mut self.table_name
    }
    fn owner_persistence_data(&self) -> &Option<LockedTypeObject /* AbstractPersistenceData */> {
        &self.owner_persistence_data
    }
    fn owner_persistence_data_mut(&mut self) -> &mut Option<LockedTypeObject /* AbstractPersistenceData */> {
        &mut self.owner_persistence_data
    }
}

impl super::core::DataContainerTrait for PersistenceStatTable {
}

pub static PERSISTENCESTATTABLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceStatTable",
    name_hash: 1728205598,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(PersistenceStatTable, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceStatTable as Default>::default())),
            create_boxed: || Box::new(<PersistenceStatTable as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TableName",
                name_hash: 3117168284,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistenceStatTable, table_name),
            },
            FieldInfoData {
                name: "OwnerPersistenceData",
                name_hash: 1012363171,
                flags: MemberInfoFlags::new(0),
                field_type: "AbstractPersistenceData",
                rust_offset: offset_of!(PersistenceStatTable, owner_persistence_data),
            },
        ],
    }),
    array_type: Some(PERSISTENCESTATTABLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceStatTable {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCESTATTABLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCESTATTABLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceStatTable-Array",
    name_hash: 1943094314,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceStatTable"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AbstractPersistenceData {
    pub _glacier_base: super::core::Asset,
}

pub trait AbstractPersistenceDataTrait: super::core::AssetTrait {
}

impl AbstractPersistenceDataTrait for AbstractPersistenceData {
}

impl super::core::AssetTrait for AbstractPersistenceData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AbstractPersistenceData {
}

pub static ABSTRACTPERSISTENCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractPersistenceData",
    name_hash: 2542231714,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(AbstractPersistenceData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbstractPersistenceData as Default>::default())),
            create_boxed: || Box::new(<AbstractPersistenceData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ABSTRACTPERSISTENCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbstractPersistenceData {
    fn type_info(&self) -> &'static TypeInfo {
        ABSTRACTPERSISTENCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ABSTRACTPERSISTENCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractPersistenceData-Array",
    name_hash: 1176780566,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AbstractPersistenceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistentValueHistoryType {
    #[default]
    PersistentValueHistoryType_None = 0,
    PersistentValueHistoryType_Delta = 1,
    PersistentValueHistoryType_DeltaAndAbsolute = 2,
    PersistentValueHistoryType_HistoryOnly = 3,
}

pub static PERSISTENTVALUEHISTORYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueHistoryType",
    name_hash: 3983793073,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENTVALUEHISTORYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistentValueHistoryType {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUEHISTORYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUEHISTORYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueHistoryType-Array",
    name_hash: 2725416453,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueHistoryType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AbstractLeaderboardData {
    pub _glacier_base: super::core::DataContainer,
    pub leaderboard_name: String,
}

pub trait AbstractLeaderboardDataTrait: super::core::DataContainerTrait {
    fn leaderboard_name(&self) -> &String;
    fn leaderboard_name_mut(&mut self) -> &mut String;
}

impl AbstractLeaderboardDataTrait for AbstractLeaderboardData {
    fn leaderboard_name(&self) -> &String {
        &self.leaderboard_name
    }
    fn leaderboard_name_mut(&mut self) -> &mut String {
        &mut self.leaderboard_name
    }
}

impl super::core::DataContainerTrait for AbstractLeaderboardData {
}

pub static ABSTRACTLEADERBOARDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractLeaderboardData",
    name_hash: 3666564884,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AbstractLeaderboardData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbstractLeaderboardData as Default>::default())),
            create_boxed: || Box::new(<AbstractLeaderboardData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LeaderboardName",
                name_hash: 2718976483,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AbstractLeaderboardData, leaderboard_name),
            },
        ],
    }),
    array_type: Some(ABSTRACTLEADERBOARDDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AbstractLeaderboardData {
    fn type_info(&self) -> &'static TypeInfo {
        ABSTRACTLEADERBOARDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ABSTRACTLEADERBOARDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractLeaderboardData-Array",
    name_hash: 3068244768,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AbstractLeaderboardData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PersistenceGameData {
    pub _glacier_base: super::core::Asset,
    pub assets: Vec<Option<LockedTypeObject /* super::core::Asset */>>,
}

pub trait PersistenceGameDataTrait: super::core::AssetTrait {
    fn assets(&self) -> &Vec<Option<LockedTypeObject /* super::core::Asset */>>;
    fn assets_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::Asset */>>;
}

impl PersistenceGameDataTrait for PersistenceGameData {
    fn assets(&self) -> &Vec<Option<LockedTypeObject /* super::core::Asset */>> {
        &self.assets
    }
    fn assets_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::core::Asset */>> {
        &mut self.assets
    }
}

impl super::core::AssetTrait for PersistenceGameData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PersistenceGameData {
}

pub static PERSISTENCEGAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceGameData",
    name_hash: 682228364,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(PersistenceGameData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceGameData as Default>::default())),
            create_boxed: || Box::new(<PersistenceGameData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Assets",
                name_hash: 2502242534,
                flags: MemberInfoFlags::new(144),
                field_type: "Asset-Array",
                rust_offset: offset_of!(PersistenceGameData, assets),
            },
        ],
    }),
    array_type: Some(PERSISTENCEGAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceGameData {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCEGAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCEGAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceGameData-Array",
    name_hash: 3896085176,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceGameData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RichPresenceData {
    pub _glacier_base: super::core::Asset,
    pub presence_modes: Vec<Option<LockedTypeObject /* RichPresencePresenceString */>>,
    pub default_mode: Option<LockedTypeObject /* RichPresencePresenceString */>,
    pub inactive_mode: Option<LockedTypeObject /* RichPresencePresenceString */>,
    pub contexts: Vec<Option<LockedTypeObject /* RichPresenceContext */>>,
    pub properties: Vec<BoxedTypeObject /* RichPresenceProperty */>,
}

pub trait RichPresenceDataTrait: super::core::AssetTrait {
    fn presence_modes(&self) -> &Vec<Option<LockedTypeObject /* RichPresencePresenceString */>>;
    fn presence_modes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* RichPresencePresenceString */>>;
    fn default_mode(&self) -> &Option<LockedTypeObject /* RichPresencePresenceString */>;
    fn default_mode_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresencePresenceString */>;
    fn inactive_mode(&self) -> &Option<LockedTypeObject /* RichPresencePresenceString */>;
    fn inactive_mode_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresencePresenceString */>;
    fn contexts(&self) -> &Vec<Option<LockedTypeObject /* RichPresenceContext */>>;
    fn contexts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* RichPresenceContext */>>;
    fn properties(&self) -> &Vec<BoxedTypeObject /* RichPresenceProperty */>;
    fn properties_mut(&mut self) -> &mut Vec<BoxedTypeObject /* RichPresenceProperty */>;
}

impl RichPresenceDataTrait for RichPresenceData {
    fn presence_modes(&self) -> &Vec<Option<LockedTypeObject /* RichPresencePresenceString */>> {
        &self.presence_modes
    }
    fn presence_modes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* RichPresencePresenceString */>> {
        &mut self.presence_modes
    }
    fn default_mode(&self) -> &Option<LockedTypeObject /* RichPresencePresenceString */> {
        &self.default_mode
    }
    fn default_mode_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresencePresenceString */> {
        &mut self.default_mode
    }
    fn inactive_mode(&self) -> &Option<LockedTypeObject /* RichPresencePresenceString */> {
        &self.inactive_mode
    }
    fn inactive_mode_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresencePresenceString */> {
        &mut self.inactive_mode
    }
    fn contexts(&self) -> &Vec<Option<LockedTypeObject /* RichPresenceContext */>> {
        &self.contexts
    }
    fn contexts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* RichPresenceContext */>> {
        &mut self.contexts
    }
    fn properties(&self) -> &Vec<BoxedTypeObject /* RichPresenceProperty */> {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut Vec<BoxedTypeObject /* RichPresenceProperty */> {
        &mut self.properties
    }
}

impl super::core::AssetTrait for RichPresenceData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RichPresenceData {
}

pub static RICHPRESENCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceData",
    name_hash: 2013223484,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(RichPresenceData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceData as Default>::default())),
            create_boxed: || Box::new(<RichPresenceData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PresenceModes",
                name_hash: 1792573772,
                flags: MemberInfoFlags::new(144),
                field_type: "RichPresencePresenceString-Array",
                rust_offset: offset_of!(RichPresenceData, presence_modes),
            },
            FieldInfoData {
                name: "DefaultMode",
                name_hash: 2014189229,
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresencePresenceString",
                rust_offset: offset_of!(RichPresenceData, default_mode),
            },
            FieldInfoData {
                name: "InactiveMode",
                name_hash: 2860645485,
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresencePresenceString",
                rust_offset: offset_of!(RichPresenceData, inactive_mode),
            },
            FieldInfoData {
                name: "Contexts",
                name_hash: 333666601,
                flags: MemberInfoFlags::new(144),
                field_type: "RichPresenceContext-Array",
                rust_offset: offset_of!(RichPresenceData, contexts),
            },
            FieldInfoData {
                name: "Properties",
                name_hash: 1506334468,
                flags: MemberInfoFlags::new(144),
                field_type: "RichPresenceProperty-Array",
                rust_offset: offset_of!(RichPresenceData, properties),
            },
        ],
    }),
    array_type: Some(RICHPRESENCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceData {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceData-Array",
    name_hash: 3744117128,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RichPresenceProperty {
    pub name: String,
    pub property_type: RichPresencePropertyType,
}

pub trait RichPresencePropertyTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn property_type(&self) -> &RichPresencePropertyType;
    fn property_type_mut(&mut self) -> &mut RichPresencePropertyType;
}

impl RichPresencePropertyTrait for RichPresenceProperty {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn property_type(&self) -> &RichPresencePropertyType {
        &self.property_type
    }
    fn property_type_mut(&mut self) -> &mut RichPresencePropertyType {
        &mut self.property_type
    }
}

pub static RICHPRESENCEPROPERTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceProperty",
    name_hash: 3591956971,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceProperty as Default>::default())),
            create_boxed: || Box::new(<RichPresenceProperty as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                name_hash: 2088949890,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceProperty, name),
            },
            FieldInfoData {
                name: "PropertyType",
                name_hash: 3998420506,
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresencePropertyType",
                rust_offset: offset_of!(RichPresenceProperty, property_type),
            },
        ],
    }),
    array_type: Some(RICHPRESENCEPROPERTY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceProperty {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCEPROPERTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RICHPRESENCEPROPERTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceProperty-Array",
    name_hash: 3064093151,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceProperty"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RichPresencePropertyType {
    #[default]
    RichPresencePropertyType_Float = 0,
    RichPresencePropertyType_Integer = 1,
    RichPresencePropertyType_LongFloat = 2,
    RichPresencePropertyType_LongInteger = 3,
}

pub static RICHPRESENCEPROPERTYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresencePropertyType",
    name_hash: 2867315091,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(RICHPRESENCEPROPERTYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RichPresencePropertyType {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCEPROPERTYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RICHPRESENCEPROPERTYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresencePropertyType-Array",
    name_hash: 2873596967,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresencePropertyType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RichPresenceContextSetting {
    pub context: Option<LockedTypeObject /* RichPresenceContext */>,
    pub value: Option<LockedTypeObject /* RichPresenceContextValue */>,
}

pub trait RichPresenceContextSettingTrait: TypeObject {
    fn context(&self) -> &Option<LockedTypeObject /* RichPresenceContext */>;
    fn context_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresenceContext */>;
    fn value(&self) -> &Option<LockedTypeObject /* RichPresenceContextValue */>;
    fn value_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresenceContextValue */>;
}

impl RichPresenceContextSettingTrait for RichPresenceContextSetting {
    fn context(&self) -> &Option<LockedTypeObject /* RichPresenceContext */> {
        &self.context
    }
    fn context_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresenceContext */> {
        &mut self.context
    }
    fn value(&self) -> &Option<LockedTypeObject /* RichPresenceContextValue */> {
        &self.value
    }
    fn value_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresenceContextValue */> {
        &mut self.value
    }
}

pub static RICHPRESENCECONTEXTSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextSetting",
    name_hash: 2379624421,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceContextSetting as Default>::default())),
            create_boxed: || Box::new(<RichPresenceContextSetting as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Context",
                name_hash: 3654325786,
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresenceContext",
                rust_offset: offset_of!(RichPresenceContextSetting, context),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresenceContextValue",
                rust_offset: offset_of!(RichPresenceContextSetting, value),
            },
        ],
    }),
    array_type: Some(RICHPRESENCECONTEXTSETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceContextSetting {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCECONTEXTSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RICHPRESENCECONTEXTSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextSetting-Array",
    name_hash: 969947345,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceContextSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RichPresenceContext {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub values: Vec<Option<LockedTypeObject /* RichPresenceContextValue */>>,
    pub default_value: Option<LockedTypeObject /* RichPresenceContextValue */>,
    pub index: u8,
    pub stat_code: String,
}

pub trait RichPresenceContextTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn values(&self) -> &Vec<Option<LockedTypeObject /* RichPresenceContextValue */>>;
    fn values_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* RichPresenceContextValue */>>;
    fn default_value(&self) -> &Option<LockedTypeObject /* RichPresenceContextValue */>;
    fn default_value_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresenceContextValue */>;
    fn index(&self) -> &u8;
    fn index_mut(&mut self) -> &mut u8;
    fn stat_code(&self) -> &String;
    fn stat_code_mut(&mut self) -> &mut String;
}

impl RichPresenceContextTrait for RichPresenceContext {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn values(&self) -> &Vec<Option<LockedTypeObject /* RichPresenceContextValue */>> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* RichPresenceContextValue */>> {
        &mut self.values
    }
    fn default_value(&self) -> &Option<LockedTypeObject /* RichPresenceContextValue */> {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut Option<LockedTypeObject /* RichPresenceContextValue */> {
        &mut self.default_value
    }
    fn index(&self) -> &u8 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut u8 {
        &mut self.index
    }
    fn stat_code(&self) -> &String {
        &self.stat_code
    }
    fn stat_code_mut(&mut self) -> &mut String {
        &mut self.stat_code
    }
}

impl super::core::DataContainerTrait for RichPresenceContext {
}

pub static RICHPRESENCECONTEXT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContext",
    name_hash: 2808108083,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(RichPresenceContext, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceContext as Default>::default())),
            create_boxed: || Box::new(<RichPresenceContext as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                name_hash: 2088949890,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceContext, name),
            },
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "RichPresenceContextValue-Array",
                rust_offset: offset_of!(RichPresenceContext, values),
            },
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresenceContextValue",
                rust_offset: offset_of!(RichPresenceContext, default_value),
            },
            FieldInfoData {
                name: "Index",
                name_hash: 214509467,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RichPresenceContext, index),
            },
            FieldInfoData {
                name: "StatCode",
                name_hash: 3117339322,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceContext, stat_code),
            },
        ],
    }),
    array_type: Some(RICHPRESENCECONTEXT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceContext {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCECONTEXT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCECONTEXT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContext-Array",
    name_hash: 2167398279,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceContext"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RichPresenceContextValueWithKey {
    pub _glacier_base: RichPresenceContextValue,
    pub key: String,
}

pub trait RichPresenceContextValueWithKeyTrait: RichPresenceContextValueTrait {
    fn key(&self) -> &String;
    fn key_mut(&mut self) -> &mut String;
}

impl RichPresenceContextValueWithKeyTrait for RichPresenceContextValueWithKey {
    fn key(&self) -> &String {
        &self.key
    }
    fn key_mut(&mut self) -> &mut String {
        &mut self.key
    }
}

impl RichPresenceContextValueTrait for RichPresenceContextValueWithKey {
    fn s_i_d(&self) -> &String {
        self._glacier_base.s_i_d()
    }
    fn s_i_d_mut(&mut self) -> &mut String {
        self._glacier_base.s_i_d_mut()
    }
    fn index(&self) -> &u8 {
        self._glacier_base.index()
    }
    fn index_mut(&mut self) -> &mut u8 {
        self._glacier_base.index_mut()
    }
}

impl super::core::DataContainerTrait for RichPresenceContextValueWithKey {
}

pub static RICHPRESENCECONTEXTVALUEWITHKEY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextValueWithKey",
    name_hash: 848131757,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RICHPRESENCECONTEXTVALUE_TYPE_INFO),
        super_class_offset: offset_of!(RichPresenceContextValueWithKey, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceContextValueWithKey as Default>::default())),
            create_boxed: || Box::new(<RichPresenceContextValueWithKey as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Key",
                name_hash: 193457490,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceContextValueWithKey, key),
            },
        ],
    }),
    array_type: Some(RICHPRESENCECONTEXTVALUEWITHKEY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceContextValueWithKey {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCECONTEXTVALUEWITHKEY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCECONTEXTVALUEWITHKEY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextValueWithKey-Array",
    name_hash: 2906696473,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceContextValueWithKey"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RichPresenceContextValue {
    pub _glacier_base: super::core::DataContainer,
    pub s_i_d: String,
    pub index: u8,
}

pub trait RichPresenceContextValueTrait: super::core::DataContainerTrait {
    fn s_i_d(&self) -> &String;
    fn s_i_d_mut(&mut self) -> &mut String;
    fn index(&self) -> &u8;
    fn index_mut(&mut self) -> &mut u8;
}

impl RichPresenceContextValueTrait for RichPresenceContextValue {
    fn s_i_d(&self) -> &String {
        &self.s_i_d
    }
    fn s_i_d_mut(&mut self) -> &mut String {
        &mut self.s_i_d
    }
    fn index(&self) -> &u8 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut u8 {
        &mut self.index
    }
}

impl super::core::DataContainerTrait for RichPresenceContextValue {
}

pub static RICHPRESENCECONTEXTVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextValue",
    name_hash: 2936087640,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(RichPresenceContextValue, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceContextValue as Default>::default())),
            create_boxed: || Box::new(<RichPresenceContextValue as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SID",
                name_hash: 193467547,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceContextValue, s_i_d),
            },
            FieldInfoData {
                name: "Index",
                name_hash: 214509467,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RichPresenceContextValue, index),
            },
        ],
    }),
    array_type: Some(RICHPRESENCECONTEXTVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceContextValue {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCECONTEXTVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCECONTEXTVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextValue-Array",
    name_hash: 441458412,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceContextValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RichPresencePresenceString {
    pub _glacier_base: super::core::DataContainer,
    pub s_i_d: String,
    pub interpolated: bool,
    pub index: u8,
}

pub trait RichPresencePresenceStringTrait: super::core::DataContainerTrait {
    fn s_i_d(&self) -> &String;
    fn s_i_d_mut(&mut self) -> &mut String;
    fn interpolated(&self) -> &bool;
    fn interpolated_mut(&mut self) -> &mut bool;
    fn index(&self) -> &u8;
    fn index_mut(&mut self) -> &mut u8;
}

impl RichPresencePresenceStringTrait for RichPresencePresenceString {
    fn s_i_d(&self) -> &String {
        &self.s_i_d
    }
    fn s_i_d_mut(&mut self) -> &mut String {
        &mut self.s_i_d
    }
    fn interpolated(&self) -> &bool {
        &self.interpolated
    }
    fn interpolated_mut(&mut self) -> &mut bool {
        &mut self.interpolated
    }
    fn index(&self) -> &u8 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut u8 {
        &mut self.index
    }
}

impl super::core::DataContainerTrait for RichPresencePresenceString {
}

pub static RICHPRESENCEPRESENCESTRING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresencePresenceString",
    name_hash: 3064376448,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(RichPresencePresenceString, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresencePresenceString as Default>::default())),
            create_boxed: || Box::new(<RichPresencePresenceString as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SID",
                name_hash: 193467547,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresencePresenceString, s_i_d),
            },
            FieldInfoData {
                name: "Interpolated",
                name_hash: 3956040102,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RichPresencePresenceString, interpolated),
            },
            FieldInfoData {
                name: "Index",
                name_hash: 214509467,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RichPresencePresenceString, index),
            },
        ],
    }),
    array_type: Some(RICHPRESENCEPRESENCESTRING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresencePresenceString {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCEPRESENCESTRING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCEPRESENCESTRING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresencePresenceString-Array",
    name_hash: 2645865140,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresencePresenceString"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PersistenceData {
    pub _glacier_base: AbstractPersistenceData,
    pub persistence_name: String,
    pub club_persistence_name: String,
    pub delta_game_reports: bool,
    pub values: Vec<BoxedTypeObject /* PersistentValueTemplateData */>,
    pub server_default_group: Option<LockedTypeObject /* PersistenceStatGroup */>,
    pub client_default_group: Option<LockedTypeObject /* PersistenceStatGroup */>,
    pub retention_policy: Option<LockedTypeObject /* PersistenceRetentionPolicy */>,
    pub history_daily: bool,
    pub history_weekly: bool,
    pub history_monthly: bool,
    pub output_properties: bool,
    pub consumable_mappings: Vec<BoxedTypeObject /* PersistenceConsumableMapping */>,
}

pub trait PersistenceDataTrait: AbstractPersistenceDataTrait {
    fn persistence_name(&self) -> &String;
    fn persistence_name_mut(&mut self) -> &mut String;
    fn club_persistence_name(&self) -> &String;
    fn club_persistence_name_mut(&mut self) -> &mut String;
    fn delta_game_reports(&self) -> &bool;
    fn delta_game_reports_mut(&mut self) -> &mut bool;
    fn values(&self) -> &Vec<BoxedTypeObject /* PersistentValueTemplateData */>;
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PersistentValueTemplateData */>;
    fn server_default_group(&self) -> &Option<LockedTypeObject /* PersistenceStatGroup */>;
    fn server_default_group_mut(&mut self) -> &mut Option<LockedTypeObject /* PersistenceStatGroup */>;
    fn client_default_group(&self) -> &Option<LockedTypeObject /* PersistenceStatGroup */>;
    fn client_default_group_mut(&mut self) -> &mut Option<LockedTypeObject /* PersistenceStatGroup */>;
    fn retention_policy(&self) -> &Option<LockedTypeObject /* PersistenceRetentionPolicy */>;
    fn retention_policy_mut(&mut self) -> &mut Option<LockedTypeObject /* PersistenceRetentionPolicy */>;
    fn history_daily(&self) -> &bool;
    fn history_daily_mut(&mut self) -> &mut bool;
    fn history_weekly(&self) -> &bool;
    fn history_weekly_mut(&mut self) -> &mut bool;
    fn history_monthly(&self) -> &bool;
    fn history_monthly_mut(&mut self) -> &mut bool;
    fn output_properties(&self) -> &bool;
    fn output_properties_mut(&mut self) -> &mut bool;
    fn consumable_mappings(&self) -> &Vec<BoxedTypeObject /* PersistenceConsumableMapping */>;
    fn consumable_mappings_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PersistenceConsumableMapping */>;
}

impl PersistenceDataTrait for PersistenceData {
    fn persistence_name(&self) -> &String {
        &self.persistence_name
    }
    fn persistence_name_mut(&mut self) -> &mut String {
        &mut self.persistence_name
    }
    fn club_persistence_name(&self) -> &String {
        &self.club_persistence_name
    }
    fn club_persistence_name_mut(&mut self) -> &mut String {
        &mut self.club_persistence_name
    }
    fn delta_game_reports(&self) -> &bool {
        &self.delta_game_reports
    }
    fn delta_game_reports_mut(&mut self) -> &mut bool {
        &mut self.delta_game_reports
    }
    fn values(&self) -> &Vec<BoxedTypeObject /* PersistentValueTemplateData */> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PersistentValueTemplateData */> {
        &mut self.values
    }
    fn server_default_group(&self) -> &Option<LockedTypeObject /* PersistenceStatGroup */> {
        &self.server_default_group
    }
    fn server_default_group_mut(&mut self) -> &mut Option<LockedTypeObject /* PersistenceStatGroup */> {
        &mut self.server_default_group
    }
    fn client_default_group(&self) -> &Option<LockedTypeObject /* PersistenceStatGroup */> {
        &self.client_default_group
    }
    fn client_default_group_mut(&mut self) -> &mut Option<LockedTypeObject /* PersistenceStatGroup */> {
        &mut self.client_default_group
    }
    fn retention_policy(&self) -> &Option<LockedTypeObject /* PersistenceRetentionPolicy */> {
        &self.retention_policy
    }
    fn retention_policy_mut(&mut self) -> &mut Option<LockedTypeObject /* PersistenceRetentionPolicy */> {
        &mut self.retention_policy
    }
    fn history_daily(&self) -> &bool {
        &self.history_daily
    }
    fn history_daily_mut(&mut self) -> &mut bool {
        &mut self.history_daily
    }
    fn history_weekly(&self) -> &bool {
        &self.history_weekly
    }
    fn history_weekly_mut(&mut self) -> &mut bool {
        &mut self.history_weekly
    }
    fn history_monthly(&self) -> &bool {
        &self.history_monthly
    }
    fn history_monthly_mut(&mut self) -> &mut bool {
        &mut self.history_monthly
    }
    fn output_properties(&self) -> &bool {
        &self.output_properties
    }
    fn output_properties_mut(&mut self) -> &mut bool {
        &mut self.output_properties
    }
    fn consumable_mappings(&self) -> &Vec<BoxedTypeObject /* PersistenceConsumableMapping */> {
        &self.consumable_mappings
    }
    fn consumable_mappings_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PersistenceConsumableMapping */> {
        &mut self.consumable_mappings
    }
}

impl AbstractPersistenceDataTrait for PersistenceData {
}

impl super::core::AssetTrait for PersistenceData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PersistenceData {
}

pub static PERSISTENCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceData",
    name_hash: 1594145186,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTPERSISTENCEDATA_TYPE_INFO),
        super_class_offset: offset_of!(PersistenceData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceData as Default>::default())),
            create_boxed: || Box::new(<PersistenceData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PersistenceName",
                name_hash: 1594500373,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistenceData, persistence_name),
            },
            FieldInfoData {
                name: "ClubPersistenceName",
                name_hash: 1035208813,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistenceData, club_persistence_name),
            },
            FieldInfoData {
                name: "DeltaGameReports",
                name_hash: 1383796302,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, delta_game_reports),
            },
            FieldInfoData {
                name: "Values",
                name_hash: 3142410589,
                flags: MemberInfoFlags::new(144),
                field_type: "PersistentValueTemplateData-Array",
                rust_offset: offset_of!(PersistenceData, values),
            },
            FieldInfoData {
                name: "ServerDefaultGroup",
                name_hash: 1370365556,
                flags: MemberInfoFlags::new(0),
                field_type: "PersistenceStatGroup",
                rust_offset: offset_of!(PersistenceData, server_default_group),
            },
            FieldInfoData {
                name: "ClientDefaultGroup",
                name_hash: 2136132136,
                flags: MemberInfoFlags::new(0),
                field_type: "PersistenceStatGroup",
                rust_offset: offset_of!(PersistenceData, client_default_group),
            },
            FieldInfoData {
                name: "RetentionPolicy",
                name_hash: 1323382353,
                flags: MemberInfoFlags::new(0),
                field_type: "PersistenceRetentionPolicy",
                rust_offset: offset_of!(PersistenceData, retention_policy),
            },
            FieldInfoData {
                name: "HistoryDaily",
                name_hash: 2252214046,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, history_daily),
            },
            FieldInfoData {
                name: "HistoryWeekly",
                name_hash: 1752784430,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, history_weekly),
            },
            FieldInfoData {
                name: "HistoryMonthly",
                name_hash: 3030502658,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, history_monthly),
            },
            FieldInfoData {
                name: "OutputProperties",
                name_hash: 1376339771,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, output_properties),
            },
            FieldInfoData {
                name: "ConsumableMappings",
                name_hash: 420464793,
                flags: MemberInfoFlags::new(144),
                field_type: "PersistenceConsumableMapping-Array",
                rust_offset: offset_of!(PersistenceData, consumable_mappings),
            },
        ],
    }),
    array_type: Some(PERSISTENCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceData {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceData-Array",
    name_hash: 4135606294,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PersistenceConsumableMapping {
    pub group: ConsumableGroup,
}

pub trait PersistenceConsumableMappingTrait: TypeObject {
    fn group(&self) -> &ConsumableGroup;
    fn group_mut(&mut self) -> &mut ConsumableGroup;
}

impl PersistenceConsumableMappingTrait for PersistenceConsumableMapping {
    fn group(&self) -> &ConsumableGroup {
        &self.group
    }
    fn group_mut(&mut self) -> &mut ConsumableGroup {
        &mut self.group
    }
}

pub static PERSISTENCECONSUMABLEMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceConsumableMapping",
    name_hash: 815888093,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceConsumableMapping as Default>::default())),
            create_boxed: || Box::new(<PersistenceConsumableMapping as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Group",
                name_hash: 208130522,
                flags: MemberInfoFlags::new(0),
                field_type: "ConsumableGroup",
                rust_offset: offset_of!(PersistenceConsumableMapping, group),
            },
        ],
    }),
    array_type: Some(PERSISTENCECONSUMABLEMAPPING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PersistenceConsumableMapping {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCECONSUMABLEMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENCECONSUMABLEMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceConsumableMapping-Array",
    name_hash: 3288781545,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceConsumableMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistenceGameType {
    #[default]
    PersistenceGameType_Singleplayer = 0,
    PersistenceGameType_Cooperative = 1,
    PersistenceGameType_Multiplayer = 2,
    PersistenceGameType_Count = 3,
}

pub static PERSISTENCEGAMETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceGameType",
    name_hash: 681661956,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENCEGAMETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistenceGameType {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCEGAMETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENCEGAMETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceGameType-Array",
    name_hash: 4087884336,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceGameType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PersistenceRetentionPolicy {
    pub _glacier_base: super::core::Asset,
    pub daily_history_count: i32,
    pub weekly_history_count: i32,
    pub monthly_history_count: i32,
}

pub trait PersistenceRetentionPolicyTrait: super::core::AssetTrait {
    fn daily_history_count(&self) -> &i32;
    fn daily_history_count_mut(&mut self) -> &mut i32;
    fn weekly_history_count(&self) -> &i32;
    fn weekly_history_count_mut(&mut self) -> &mut i32;
    fn monthly_history_count(&self) -> &i32;
    fn monthly_history_count_mut(&mut self) -> &mut i32;
}

impl PersistenceRetentionPolicyTrait for PersistenceRetentionPolicy {
    fn daily_history_count(&self) -> &i32 {
        &self.daily_history_count
    }
    fn daily_history_count_mut(&mut self) -> &mut i32 {
        &mut self.daily_history_count
    }
    fn weekly_history_count(&self) -> &i32 {
        &self.weekly_history_count
    }
    fn weekly_history_count_mut(&mut self) -> &mut i32 {
        &mut self.weekly_history_count
    }
    fn monthly_history_count(&self) -> &i32 {
        &self.monthly_history_count
    }
    fn monthly_history_count_mut(&mut self) -> &mut i32 {
        &mut self.monthly_history_count
    }
}

impl super::core::AssetTrait for PersistenceRetentionPolicy {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PersistenceRetentionPolicy {
}

pub static PERSISTENCERETENTIONPOLICY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceRetentionPolicy",
    name_hash: 3711030502,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(PersistenceRetentionPolicy, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceRetentionPolicy as Default>::default())),
            create_boxed: || Box::new(<PersistenceRetentionPolicy as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DailyHistoryCount",
                name_hash: 2827768221,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PersistenceRetentionPolicy, daily_history_count),
            },
            FieldInfoData {
                name: "WeeklyHistoryCount",
                name_hash: 808067565,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PersistenceRetentionPolicy, weekly_history_count),
            },
            FieldInfoData {
                name: "MonthlyHistoryCount",
                name_hash: 345590273,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PersistenceRetentionPolicy, monthly_history_count),
            },
        ],
    }),
    array_type: Some(PERSISTENCERETENTIONPOLICY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceRetentionPolicy {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCERETENTIONPOLICY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCERETENTIONPOLICY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceRetentionPolicy-Array",
    name_hash: 1565807058,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceRetentionPolicy"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum StatPeriod {
    #[default]
    StatPeriod_AllTime = 0,
    StatPeriod_Monthly = 1,
    StatPeriod_Weekly = 2,
    StatPeriod_Daily = 3,
    StatPeriod_Size = 4,
    StatPeriod_Error = 5,
}

pub static STATPERIOD_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StatPeriod",
    name_hash: 1311571570,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(STATPERIOD_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for StatPeriod {
    fn type_info(&self) -> &'static TypeInfo {
        STATPERIOD_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STATPERIOD_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StatPeriod-Array",
    name_hash: 2646324550,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StatPeriod"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PersistentValueTemplateStatRef {
    pub _glacier_base: AbstractPersistentStatRef,
    pub definition: Option<LockedTypeObject /* PersistentValueTemplate */>,
}

pub trait PersistentValueTemplateStatRefTrait: AbstractPersistentStatRefTrait {
    fn definition(&self) -> &Option<LockedTypeObject /* PersistentValueTemplate */>;
    fn definition_mut(&mut self) -> &mut Option<LockedTypeObject /* PersistentValueTemplate */>;
}

impl PersistentValueTemplateStatRefTrait for PersistentValueTemplateStatRef {
    fn definition(&self) -> &Option<LockedTypeObject /* PersistentValueTemplate */> {
        &self.definition
    }
    fn definition_mut(&mut self) -> &mut Option<LockedTypeObject /* PersistentValueTemplate */> {
        &mut self.definition
    }
}

impl AbstractPersistentStatRefTrait for PersistentValueTemplateStatRef {
}

impl super::core::DataContainerTrait for PersistentValueTemplateStatRef {
}

pub static PERSISTENTVALUETEMPLATESTATREF_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplateStatRef",
    name_hash: 1781469752,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTPERSISTENTSTATREF_TYPE_INFO),
        super_class_offset: offset_of!(PersistentValueTemplateStatRef, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistentValueTemplateStatRef as Default>::default())),
            create_boxed: || Box::new(<PersistentValueTemplateStatRef as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Definition",
                name_hash: 2980331600,
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueTemplate",
                rust_offset: offset_of!(PersistentValueTemplateStatRef, definition),
            },
        ],
    }),
    array_type: Some(PERSISTENTVALUETEMPLATESTATREF_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistentValueTemplateStatRef {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUETEMPLATESTATREF_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENTVALUETEMPLATESTATREF_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplateStatRef-Array",
    name_hash: 855948172,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueTemplateStatRef"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AbstractPersistentStatRef {
    pub _glacier_base: super::core::DataContainer,
}

pub trait AbstractPersistentStatRefTrait: super::core::DataContainerTrait {
}

impl AbstractPersistentStatRefTrait for AbstractPersistentStatRef {
}

impl super::core::DataContainerTrait for AbstractPersistentStatRef {
}

pub static ABSTRACTPERSISTENTSTATREF_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractPersistentStatRef",
    name_hash: 1877282243,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AbstractPersistentStatRef, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbstractPersistentStatRef as Default>::default())),
            create_boxed: || Box::new(<AbstractPersistentStatRef as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ABSTRACTPERSISTENTSTATREF_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbstractPersistentStatRef {
    fn type_info(&self) -> &'static TypeInfo {
        ABSTRACTPERSISTENTSTATREF_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ABSTRACTPERSISTENTSTATREF_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractPersistentStatRef-Array",
    name_hash: 700059895,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AbstractPersistentStatRef"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PersistentValueTemplate {
    pub _glacier_base: super::core::DataContainer,
    pub data: PersistentValueTemplateData,
    pub derived_formula_refs: Vec<Option<LockedTypeObject /* AbstractPersistentStatRef */>>,
}

pub trait PersistentValueTemplateTrait: super::core::DataContainerTrait {
    fn data(&self) -> &PersistentValueTemplateData;
    fn data_mut(&mut self) -> &mut PersistentValueTemplateData;
    fn derived_formula_refs(&self) -> &Vec<Option<LockedTypeObject /* AbstractPersistentStatRef */>>;
    fn derived_formula_refs_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* AbstractPersistentStatRef */>>;
}

impl PersistentValueTemplateTrait for PersistentValueTemplate {
    fn data(&self) -> &PersistentValueTemplateData {
        &self.data
    }
    fn data_mut(&mut self) -> &mut PersistentValueTemplateData {
        &mut self.data
    }
    fn derived_formula_refs(&self) -> &Vec<Option<LockedTypeObject /* AbstractPersistentStatRef */>> {
        &self.derived_formula_refs
    }
    fn derived_formula_refs_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* AbstractPersistentStatRef */>> {
        &mut self.derived_formula_refs
    }
}

impl super::core::DataContainerTrait for PersistentValueTemplate {
}

pub static PERSISTENTVALUETEMPLATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplate",
    name_hash: 3443084187,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(PersistentValueTemplate, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistentValueTemplate as Default>::default())),
            create_boxed: || Box::new(<PersistentValueTemplate as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Data",
                name_hash: 2088730869,
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueTemplateData",
                rust_offset: offset_of!(PersistentValueTemplate, data),
            },
            FieldInfoData {
                name: "DerivedFormulaRefs",
                name_hash: 98984868,
                flags: MemberInfoFlags::new(144),
                field_type: "AbstractPersistentStatRef-Array",
                rust_offset: offset_of!(PersistentValueTemplate, derived_formula_refs),
            },
        ],
    }),
    array_type: Some(PERSISTENTVALUETEMPLATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistentValueTemplate {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUETEMPLATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENTVALUETEMPLATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplate-Array",
    name_hash: 2912420399,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueTemplate"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PersistentValueTemplateData {
    pub name: String,
    pub default_value: String,
    pub default_float_value: f32,
    pub value_type: PersistentValueType,
    pub data_type: PersistentValueDataType,
    pub history_type: PersistentValueHistoryType,
    pub club_stat: bool,
}

pub trait PersistentValueTemplateDataTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn default_value(&self) -> &String;
    fn default_value_mut(&mut self) -> &mut String;
    fn default_float_value(&self) -> &f32;
    fn default_float_value_mut(&mut self) -> &mut f32;
    fn value_type(&self) -> &PersistentValueType;
    fn value_type_mut(&mut self) -> &mut PersistentValueType;
    fn data_type(&self) -> &PersistentValueDataType;
    fn data_type_mut(&mut self) -> &mut PersistentValueDataType;
    fn history_type(&self) -> &PersistentValueHistoryType;
    fn history_type_mut(&mut self) -> &mut PersistentValueHistoryType;
    fn club_stat(&self) -> &bool;
    fn club_stat_mut(&mut self) -> &mut bool;
}

impl PersistentValueTemplateDataTrait for PersistentValueTemplateData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn default_value(&self) -> &String {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut String {
        &mut self.default_value
    }
    fn default_float_value(&self) -> &f32 {
        &self.default_float_value
    }
    fn default_float_value_mut(&mut self) -> &mut f32 {
        &mut self.default_float_value
    }
    fn value_type(&self) -> &PersistentValueType {
        &self.value_type
    }
    fn value_type_mut(&mut self) -> &mut PersistentValueType {
        &mut self.value_type
    }
    fn data_type(&self) -> &PersistentValueDataType {
        &self.data_type
    }
    fn data_type_mut(&mut self) -> &mut PersistentValueDataType {
        &mut self.data_type
    }
    fn history_type(&self) -> &PersistentValueHistoryType {
        &self.history_type
    }
    fn history_type_mut(&mut self) -> &mut PersistentValueHistoryType {
        &mut self.history_type
    }
    fn club_stat(&self) -> &bool {
        &self.club_stat
    }
    fn club_stat_mut(&mut self) -> &mut bool {
        &mut self.club_stat
    }
}

pub static PERSISTENTVALUETEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplateData",
    name_hash: 431771755,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistentValueTemplateData as Default>::default())),
            create_boxed: || Box::new(<PersistentValueTemplateData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                name_hash: 2088949890,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistentValueTemplateData, name),
            },
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistentValueTemplateData, default_value),
            },
            FieldInfoData {
                name: "DefaultFloatValue",
                name_hash: 233760917,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PersistentValueTemplateData, default_float_value),
            },
            FieldInfoData {
                name: "ValueType",
                name_hash: 1235276758,
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueType",
                rust_offset: offset_of!(PersistentValueTemplateData, value_type),
            },
            FieldInfoData {
                name: "DataType",
                name_hash: 3249006477,
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueDataType",
                rust_offset: offset_of!(PersistentValueTemplateData, data_type),
            },
            FieldInfoData {
                name: "HistoryType",
                name_hash: 2541675455,
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueHistoryType",
                rust_offset: offset_of!(PersistentValueTemplateData, history_type),
            },
            FieldInfoData {
                name: "ClubStat",
                name_hash: 1509129999,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistentValueTemplateData, club_stat),
            },
        ],
    }),
    array_type: Some(PERSISTENTVALUETEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistentValueTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUETEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUETEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplateData-Array",
    name_hash: 433627231,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistentValueDataKind {
    #[default]
    PersistentValueDataKind_Raw = 0,
    PersistentValueDataKind_Seconds = 1,
    PersistentValueDataKind_Minutes = 2,
    PersistentValueDataKind_Hours = 3,
    PersistentValueDataKind_Percent = 4,
}

pub static PERSISTENTVALUEDATAKIND_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueDataKind",
    name_hash: 1712115315,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENTVALUEDATAKIND_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistentValueDataKind {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUEDATAKIND_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUEDATAKIND_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueDataKind-Array",
    name_hash: 421726791,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueDataKind"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistentValueDataType {
    #[default]
    PersistentValueDataType_Decimal = 0,
    PersistentValueDataType_Integer = 1,
    PersistentValueDataType_String = 2,
}

pub static PERSISTENTVALUEDATATYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueDataType",
    name_hash: 1712150595,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENTVALUEDATATYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistentValueDataType {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUEDATATYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUEDATATYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueDataType-Array",
    name_hash: 4035984247,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueDataType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistentValueType {
    #[default]
    PersistentValueType_Set = 0,
    PersistentValueType_High = 1,
    PersistentValueType_Low = 2,
    PersistentValueType_Increment = 3,
    PersistentValueType_Decrement = 4,
}

pub static PERSISTENTVALUETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueType",
    name_hash: 4199653171,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENTVALUETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistentValueType {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueType-Array",
    name_hash: 3568134791,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ConsumableGroup {
    #[default]
    ConsumableGroup_0 = 0,
    ConsumableGroup_1 = 1,
    ConsumableGroup_2 = 2,
    ConsumableGroup_3 = 3,
    ConsumableGroup_4 = 4,
    ConsumableGroup_5 = 5,
    ConsumableGroup_6 = 6,
    ConsumableGroup_7 = 7,
    ConsumableGroup_Count = 8,
}

pub static CONSUMABLEGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsumableGroup",
    name_hash: 869617913,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CONSUMABLEGROUP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ConsumableGroup {
    fn type_info(&self) -> &'static TypeInfo {
        CONSUMABLEGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CONSUMABLEGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsumableGroup-Array",
    name_hash: 1438027725,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ConsumableGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PA2TargetComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub target_properties: Option<LockedTypeObject /* PA2TargetProperties */>,
}

pub trait PA2TargetComponentDataTrait: super::entity::GameComponentDataTrait {
    fn target_properties(&self) -> &Option<LockedTypeObject /* PA2TargetProperties */>;
    fn target_properties_mut(&mut self) -> &mut Option<LockedTypeObject /* PA2TargetProperties */>;
}

impl PA2TargetComponentDataTrait for PA2TargetComponentData {
    fn target_properties(&self) -> &Option<LockedTypeObject /* PA2TargetProperties */> {
        &self.target_properties
    }
    fn target_properties_mut(&mut self) -> &mut Option<LockedTypeObject /* PA2TargetProperties */> {
        &mut self.target_properties
    }
}

impl super::entity::GameComponentDataTrait for PA2TargetComponentData {
}

impl super::entity::ComponentDataTrait for PA2TargetComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for PA2TargetComponentData {
}

impl super::core::DataBusPeerTrait for PA2TargetComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PA2TargetComponentData {
}

impl super::core::DataContainerTrait for PA2TargetComponentData {
}

pub static PA2TARGETCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2TargetComponentData",
    name_hash: 3871165704,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(PA2TargetComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PA2TargetComponentData as Default>::default())),
            create_boxed: || Box::new(<PA2TargetComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TargetProperties",
                name_hash: 292123733,
                flags: MemberInfoFlags::new(0),
                field_type: "PA2TargetProperties",
                rust_offset: offset_of!(PA2TargetComponentData, target_properties),
            },
        ],
    }),
    array_type: Some(PA2TARGETCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PA2TargetComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PA2TARGETCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PA2TARGETCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2TargetComponentData-Array",
    name_hash: 736169788,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PA2TargetComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PA2TargetProperties {
    pub _glacier_base: super::core::Asset,
    pub bone_targets: Vec<Option<LockedTypeObject /* PA2BoneList */>>,
}

pub trait PA2TargetPropertiesTrait: super::core::AssetTrait {
    fn bone_targets(&self) -> &Vec<Option<LockedTypeObject /* PA2BoneList */>>;
    fn bone_targets_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PA2BoneList */>>;
}

impl PA2TargetPropertiesTrait for PA2TargetProperties {
    fn bone_targets(&self) -> &Vec<Option<LockedTypeObject /* PA2BoneList */>> {
        &self.bone_targets
    }
    fn bone_targets_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PA2BoneList */>> {
        &mut self.bone_targets
    }
}

impl super::core::AssetTrait for PA2TargetProperties {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PA2TargetProperties {
}

pub static PA2TARGETPROPERTIES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2TargetProperties",
    name_hash: 3420905526,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(PA2TargetProperties, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PA2TargetProperties as Default>::default())),
            create_boxed: || Box::new(<PA2TargetProperties as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BoneTargets",
                name_hash: 701138625,
                flags: MemberInfoFlags::new(144),
                field_type: "PA2BoneList-Array",
                rust_offset: offset_of!(PA2TargetProperties, bone_targets),
            },
        ],
    }),
    array_type: Some(PA2TARGETPROPERTIES_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PA2TargetProperties {
    fn type_info(&self) -> &'static TypeInfo {
        PA2TARGETPROPERTIES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PA2TARGETPROPERTIES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2TargetProperties-Array",
    name_hash: 2547504258,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PA2TargetProperties"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PA2BoneList {
    pub _glacier_base: super::core::DataContainer,
    pub bones: Vec<Option<LockedTypeObject /* PA2Bone */>>,
}

pub trait PA2BoneListTrait: super::core::DataContainerTrait {
    fn bones(&self) -> &Vec<Option<LockedTypeObject /* PA2Bone */>>;
    fn bones_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PA2Bone */>>;
}

impl PA2BoneListTrait for PA2BoneList {
    fn bones(&self) -> &Vec<Option<LockedTypeObject /* PA2Bone */>> {
        &self.bones
    }
    fn bones_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* PA2Bone */>> {
        &mut self.bones
    }
}

impl super::core::DataContainerTrait for PA2BoneList {
}

pub static PA2BONELIST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2BoneList",
    name_hash: 1351479234,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(PA2BoneList, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PA2BoneList as Default>::default())),
            create_boxed: || Box::new(<PA2BoneList as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Bones",
                name_hash: 211344688,
                flags: MemberInfoFlags::new(144),
                field_type: "PA2Bone-Array",
                rust_offset: offset_of!(PA2BoneList, bones),
            },
        ],
    }),
    array_type: Some(PA2BONELIST_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PA2BoneList {
    fn type_info(&self) -> &'static TypeInfo {
        PA2BONELIST_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PA2BONELIST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2BoneList-Array",
    name_hash: 676192118,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PA2BoneList"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PA2Bone {
    pub _glacier_base: super::core::DataContainer,
    pub bone: u32,
}

pub trait PA2BoneTrait: super::core::DataContainerTrait {
    fn bone(&self) -> &u32;
    fn bone_mut(&mut self) -> &mut u32;
}

impl PA2BoneTrait for PA2Bone {
    fn bone(&self) -> &u32 {
        &self.bone
    }
    fn bone_mut(&mut self) -> &mut u32 {
        &mut self.bone
    }
}

impl super::core::DataContainerTrait for PA2Bone {
}

pub static PA2BONE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2Bone",
    name_hash: 2790115904,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(PA2Bone, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PA2Bone as Default>::default())),
            create_boxed: || Box::new(<PA2Bone as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Bone",
                name_hash: 2088812771,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PA2Bone, bone),
            },
        ],
    }),
    array_type: Some(PA2BONE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PA2Bone {
    fn type_info(&self) -> &'static TypeInfo {
        PA2BONE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PA2BONE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2Bone-Array",
    name_hash: 2347704564,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PA2Bone"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectHighlightEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub player_id: super::core::LocalPlayerId,
    pub object_highlight_type: super::world_base::ObjectHighlightType,
    pub index: i32,
    pub enable: bool,
    pub draw_at_foreground: bool,
    pub is_mask: bool,
}

pub trait ObjectHighlightEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn player_id(&self) -> &super::core::LocalPlayerId;
    fn player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
    fn object_highlight_type(&self) -> &super::world_base::ObjectHighlightType;
    fn object_highlight_type_mut(&mut self) -> &mut super::world_base::ObjectHighlightType;
    fn index(&self) -> &i32;
    fn index_mut(&mut self) -> &mut i32;
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn draw_at_foreground(&self) -> &bool;
    fn draw_at_foreground_mut(&mut self) -> &mut bool;
    fn is_mask(&self) -> &bool;
    fn is_mask_mut(&mut self) -> &mut bool;
}

impl ObjectHighlightEntityDataTrait for ObjectHighlightEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn player_id(&self) -> &super::core::LocalPlayerId {
        &self.player_id
    }
    fn player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.player_id
    }
    fn object_highlight_type(&self) -> &super::world_base::ObjectHighlightType {
        &self.object_highlight_type
    }
    fn object_highlight_type_mut(&mut self) -> &mut super::world_base::ObjectHighlightType {
        &mut self.object_highlight_type
    }
    fn index(&self) -> &i32 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut i32 {
        &mut self.index
    }
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn draw_at_foreground(&self) -> &bool {
        &self.draw_at_foreground
    }
    fn draw_at_foreground_mut(&mut self) -> &mut bool {
        &mut self.draw_at_foreground
    }
    fn is_mask(&self) -> &bool {
        &self.is_mask
    }
    fn is_mask_mut(&mut self) -> &mut bool {
        &mut self.is_mask
    }
}

impl super::entity::EntityDataTrait for ObjectHighlightEntityData {
}

impl super::entity::GameObjectDataTrait for ObjectHighlightEntityData {
}

impl super::core::DataBusPeerTrait for ObjectHighlightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectHighlightEntityData {
}

impl super::core::DataContainerTrait for ObjectHighlightEntityData {
}

pub static OBJECTHIGHLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectHighlightEntityData",
    name_hash: 1712176971,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ObjectHighlightEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectHighlightEntityData as Default>::default())),
            create_boxed: || Box::new(<ObjectHighlightEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ObjectHighlightEntityData, realm),
            },
            FieldInfoData {
                name: "PlayerId",
                name_hash: 927541883,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(ObjectHighlightEntityData, player_id),
            },
            FieldInfoData {
                name: "ObjectHighlightType",
                name_hash: 4251092312,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectHighlightType",
                rust_offset: offset_of!(ObjectHighlightEntityData, object_highlight_type),
            },
            FieldInfoData {
                name: "Index",
                name_hash: 214509467,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObjectHighlightEntityData, index),
            },
            FieldInfoData {
                name: "Enable",
                name_hash: 2342790116,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectHighlightEntityData, enable),
            },
            FieldInfoData {
                name: "DrawAtForeground",
                name_hash: 1585878123,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectHighlightEntityData, draw_at_foreground),
            },
            FieldInfoData {
                name: "IsMask",
                name_hash: 2816478955,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectHighlightEntityData, is_mask),
            },
        ],
    }),
    array_type: Some(OBJECTHIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectHighlightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTHIGHLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTHIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectHighlightEntityData-Array",
    name_hash: 3783343743,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ObjectHighlightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterInVehicleScenarioEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub scenario_ant_ref: super::ant::AntRef,
    pub level_id: i32,
    pub scenario_id: i32,
    pub actor_id: i32,
    pub part_id: i32,
    pub enabled: bool,
}

pub trait CharacterInVehicleScenarioEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn scenario_ant_ref(&self) -> &super::ant::AntRef;
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef;
    fn level_id(&self) -> &i32;
    fn level_id_mut(&mut self) -> &mut i32;
    fn scenario_id(&self) -> &i32;
    fn scenario_id_mut(&mut self) -> &mut i32;
    fn actor_id(&self) -> &i32;
    fn actor_id_mut(&mut self) -> &mut i32;
    fn part_id(&self) -> &i32;
    fn part_id_mut(&mut self) -> &mut i32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl CharacterInVehicleScenarioEntityDataTrait for CharacterInVehicleScenarioEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn scenario_ant_ref(&self) -> &super::ant::AntRef {
        &self.scenario_ant_ref
    }
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.scenario_ant_ref
    }
    fn level_id(&self) -> &i32 {
        &self.level_id
    }
    fn level_id_mut(&mut self) -> &mut i32 {
        &mut self.level_id
    }
    fn scenario_id(&self) -> &i32 {
        &self.scenario_id
    }
    fn scenario_id_mut(&mut self) -> &mut i32 {
        &mut self.scenario_id
    }
    fn actor_id(&self) -> &i32 {
        &self.actor_id
    }
    fn actor_id_mut(&mut self) -> &mut i32 {
        &mut self.actor_id
    }
    fn part_id(&self) -> &i32 {
        &self.part_id
    }
    fn part_id_mut(&mut self) -> &mut i32 {
        &mut self.part_id
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for CharacterInVehicleScenarioEntityData {
}

impl super::entity::GameObjectDataTrait for CharacterInVehicleScenarioEntityData {
}

impl super::core::DataBusPeerTrait for CharacterInVehicleScenarioEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterInVehicleScenarioEntityData {
}

impl super::core::DataContainerTrait for CharacterInVehicleScenarioEntityData {
}

pub static CHARACTERINVEHICLESCENARIOENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterInVehicleScenarioEntityData",
    name_hash: 3303167814,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterInVehicleScenarioEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterInVehicleScenarioEntityData as Default>::default())),
            create_boxed: || Box::new(<CharacterInVehicleScenarioEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, realm),
            },
            FieldInfoData {
                name: "ScenarioAntRef",
                name_hash: 3249359201,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, scenario_ant_ref),
            },
            FieldInfoData {
                name: "LevelId",
                name_hash: 1464675646,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, level_id),
            },
            FieldInfoData {
                name: "ScenarioId",
                name_hash: 3278128294,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, scenario_id),
            },
            FieldInfoData {
                name: "ActorId",
                name_hash: 373715747,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, actor_id),
            },
            FieldInfoData {
                name: "PartId",
                name_hash: 3371573631,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, part_id),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, enabled),
            },
        ],
    }),
    array_type: Some(CHARACTERINVEHICLESCENARIOENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterInVehicleScenarioEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERINVEHICLESCENARIOENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERINVEHICLESCENARIOENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterInVehicleScenarioEntityData-Array",
    name_hash: 3631322354,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterInVehicleScenarioEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MultipleActorScenarioEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub world_space: bool,
    pub world_space_connect_transform: super::core::LinearTransform,
    pub scenario_ant_ref: super::ant::AntRef,
    pub level_choice: i32,
    pub scenario_choice: i32,
    pub aligning_enabled: bool,
    pub use_input_event_player_as_player1: bool,
    pub actor1: i32,
    pub actor1_part: i32,
    pub actor1_second_part: i32,
    pub actor2: i32,
    pub actor2_part: i32,
    pub actor2_second_part: i32,
    pub actor3: i32,
    pub actor3_part: i32,
    pub actor3_second_part: i32,
    pub actor4: i32,
    pub actor4_part: i32,
    pub actor4_second_part: i32,
    pub actor5: i32,
    pub actor5_part: i32,
    pub actor5_second_part: i32,
    pub actor6: i32,
    pub actor6_part: i32,
    pub actor6_second_part: i32,
    pub scenario_active: bool,
    pub actor1_prepared: bool,
    pub actor2_prepared: bool,
    pub actor3_prepared: bool,
    pub actor4_prepared: bool,
    pub actor5_prepared: bool,
    pub actor6_prepared: bool,
    pub check_actor1_finished: bool,
    pub check_actor2_finished: bool,
    pub check_actor3_finished: bool,
    pub check_actor4_finished: bool,
    pub check_actor5_finished: bool,
    pub check_actor6_finished: bool,
    pub external_time: f32,
    pub use_external_time: bool,
    pub realm: super::core::Realm,
}

pub trait MultipleActorScenarioEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn world_space(&self) -> &bool;
    fn world_space_mut(&mut self) -> &mut bool;
    fn world_space_connect_transform(&self) -> &super::core::LinearTransform;
    fn world_space_connect_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn scenario_ant_ref(&self) -> &super::ant::AntRef;
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef;
    fn level_choice(&self) -> &i32;
    fn level_choice_mut(&mut self) -> &mut i32;
    fn scenario_choice(&self) -> &i32;
    fn scenario_choice_mut(&mut self) -> &mut i32;
    fn aligning_enabled(&self) -> &bool;
    fn aligning_enabled_mut(&mut self) -> &mut bool;
    fn use_input_event_player_as_player1(&self) -> &bool;
    fn use_input_event_player_as_player1_mut(&mut self) -> &mut bool;
    fn actor1(&self) -> &i32;
    fn actor1_mut(&mut self) -> &mut i32;
    fn actor1_part(&self) -> &i32;
    fn actor1_part_mut(&mut self) -> &mut i32;
    fn actor1_second_part(&self) -> &i32;
    fn actor1_second_part_mut(&mut self) -> &mut i32;
    fn actor2(&self) -> &i32;
    fn actor2_mut(&mut self) -> &mut i32;
    fn actor2_part(&self) -> &i32;
    fn actor2_part_mut(&mut self) -> &mut i32;
    fn actor2_second_part(&self) -> &i32;
    fn actor2_second_part_mut(&mut self) -> &mut i32;
    fn actor3(&self) -> &i32;
    fn actor3_mut(&mut self) -> &mut i32;
    fn actor3_part(&self) -> &i32;
    fn actor3_part_mut(&mut self) -> &mut i32;
    fn actor3_second_part(&self) -> &i32;
    fn actor3_second_part_mut(&mut self) -> &mut i32;
    fn actor4(&self) -> &i32;
    fn actor4_mut(&mut self) -> &mut i32;
    fn actor4_part(&self) -> &i32;
    fn actor4_part_mut(&mut self) -> &mut i32;
    fn actor4_second_part(&self) -> &i32;
    fn actor4_second_part_mut(&mut self) -> &mut i32;
    fn actor5(&self) -> &i32;
    fn actor5_mut(&mut self) -> &mut i32;
    fn actor5_part(&self) -> &i32;
    fn actor5_part_mut(&mut self) -> &mut i32;
    fn actor5_second_part(&self) -> &i32;
    fn actor5_second_part_mut(&mut self) -> &mut i32;
    fn actor6(&self) -> &i32;
    fn actor6_mut(&mut self) -> &mut i32;
    fn actor6_part(&self) -> &i32;
    fn actor6_part_mut(&mut self) -> &mut i32;
    fn actor6_second_part(&self) -> &i32;
    fn actor6_second_part_mut(&mut self) -> &mut i32;
    fn scenario_active(&self) -> &bool;
    fn scenario_active_mut(&mut self) -> &mut bool;
    fn actor1_prepared(&self) -> &bool;
    fn actor1_prepared_mut(&mut self) -> &mut bool;
    fn actor2_prepared(&self) -> &bool;
    fn actor2_prepared_mut(&mut self) -> &mut bool;
    fn actor3_prepared(&self) -> &bool;
    fn actor3_prepared_mut(&mut self) -> &mut bool;
    fn actor4_prepared(&self) -> &bool;
    fn actor4_prepared_mut(&mut self) -> &mut bool;
    fn actor5_prepared(&self) -> &bool;
    fn actor5_prepared_mut(&mut self) -> &mut bool;
    fn actor6_prepared(&self) -> &bool;
    fn actor6_prepared_mut(&mut self) -> &mut bool;
    fn check_actor1_finished(&self) -> &bool;
    fn check_actor1_finished_mut(&mut self) -> &mut bool;
    fn check_actor2_finished(&self) -> &bool;
    fn check_actor2_finished_mut(&mut self) -> &mut bool;
    fn check_actor3_finished(&self) -> &bool;
    fn check_actor3_finished_mut(&mut self) -> &mut bool;
    fn check_actor4_finished(&self) -> &bool;
    fn check_actor4_finished_mut(&mut self) -> &mut bool;
    fn check_actor5_finished(&self) -> &bool;
    fn check_actor5_finished_mut(&mut self) -> &mut bool;
    fn check_actor6_finished(&self) -> &bool;
    fn check_actor6_finished_mut(&mut self) -> &mut bool;
    fn external_time(&self) -> &f32;
    fn external_time_mut(&mut self) -> &mut f32;
    fn use_external_time(&self) -> &bool;
    fn use_external_time_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl MultipleActorScenarioEntityDataTrait for MultipleActorScenarioEntityData {
    fn world_space(&self) -> &bool {
        &self.world_space
    }
    fn world_space_mut(&mut self) -> &mut bool {
        &mut self.world_space
    }
    fn world_space_connect_transform(&self) -> &super::core::LinearTransform {
        &self.world_space_connect_transform
    }
    fn world_space_connect_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.world_space_connect_transform
    }
    fn scenario_ant_ref(&self) -> &super::ant::AntRef {
        &self.scenario_ant_ref
    }
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.scenario_ant_ref
    }
    fn level_choice(&self) -> &i32 {
        &self.level_choice
    }
    fn level_choice_mut(&mut self) -> &mut i32 {
        &mut self.level_choice
    }
    fn scenario_choice(&self) -> &i32 {
        &self.scenario_choice
    }
    fn scenario_choice_mut(&mut self) -> &mut i32 {
        &mut self.scenario_choice
    }
    fn aligning_enabled(&self) -> &bool {
        &self.aligning_enabled
    }
    fn aligning_enabled_mut(&mut self) -> &mut bool {
        &mut self.aligning_enabled
    }
    fn use_input_event_player_as_player1(&self) -> &bool {
        &self.use_input_event_player_as_player1
    }
    fn use_input_event_player_as_player1_mut(&mut self) -> &mut bool {
        &mut self.use_input_event_player_as_player1
    }
    fn actor1(&self) -> &i32 {
        &self.actor1
    }
    fn actor1_mut(&mut self) -> &mut i32 {
        &mut self.actor1
    }
    fn actor1_part(&self) -> &i32 {
        &self.actor1_part
    }
    fn actor1_part_mut(&mut self) -> &mut i32 {
        &mut self.actor1_part
    }
    fn actor1_second_part(&self) -> &i32 {
        &self.actor1_second_part
    }
    fn actor1_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor1_second_part
    }
    fn actor2(&self) -> &i32 {
        &self.actor2
    }
    fn actor2_mut(&mut self) -> &mut i32 {
        &mut self.actor2
    }
    fn actor2_part(&self) -> &i32 {
        &self.actor2_part
    }
    fn actor2_part_mut(&mut self) -> &mut i32 {
        &mut self.actor2_part
    }
    fn actor2_second_part(&self) -> &i32 {
        &self.actor2_second_part
    }
    fn actor2_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor2_second_part
    }
    fn actor3(&self) -> &i32 {
        &self.actor3
    }
    fn actor3_mut(&mut self) -> &mut i32 {
        &mut self.actor3
    }
    fn actor3_part(&self) -> &i32 {
        &self.actor3_part
    }
    fn actor3_part_mut(&mut self) -> &mut i32 {
        &mut self.actor3_part
    }
    fn actor3_second_part(&self) -> &i32 {
        &self.actor3_second_part
    }
    fn actor3_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor3_second_part
    }
    fn actor4(&self) -> &i32 {
        &self.actor4
    }
    fn actor4_mut(&mut self) -> &mut i32 {
        &mut self.actor4
    }
    fn actor4_part(&self) -> &i32 {
        &self.actor4_part
    }
    fn actor4_part_mut(&mut self) -> &mut i32 {
        &mut self.actor4_part
    }
    fn actor4_second_part(&self) -> &i32 {
        &self.actor4_second_part
    }
    fn actor4_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor4_second_part
    }
    fn actor5(&self) -> &i32 {
        &self.actor5
    }
    fn actor5_mut(&mut self) -> &mut i32 {
        &mut self.actor5
    }
    fn actor5_part(&self) -> &i32 {
        &self.actor5_part
    }
    fn actor5_part_mut(&mut self) -> &mut i32 {
        &mut self.actor5_part
    }
    fn actor5_second_part(&self) -> &i32 {
        &self.actor5_second_part
    }
    fn actor5_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor5_second_part
    }
    fn actor6(&self) -> &i32 {
        &self.actor6
    }
    fn actor6_mut(&mut self) -> &mut i32 {
        &mut self.actor6
    }
    fn actor6_part(&self) -> &i32 {
        &self.actor6_part
    }
    fn actor6_part_mut(&mut self) -> &mut i32 {
        &mut self.actor6_part
    }
    fn actor6_second_part(&self) -> &i32 {
        &self.actor6_second_part
    }
    fn actor6_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor6_second_part
    }
    fn scenario_active(&self) -> &bool {
        &self.scenario_active
    }
    fn scenario_active_mut(&mut self) -> &mut bool {
        &mut self.scenario_active
    }
    fn actor1_prepared(&self) -> &bool {
        &self.actor1_prepared
    }
    fn actor1_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor1_prepared
    }
    fn actor2_prepared(&self) -> &bool {
        &self.actor2_prepared
    }
    fn actor2_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor2_prepared
    }
    fn actor3_prepared(&self) -> &bool {
        &self.actor3_prepared
    }
    fn actor3_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor3_prepared
    }
    fn actor4_prepared(&self) -> &bool {
        &self.actor4_prepared
    }
    fn actor4_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor4_prepared
    }
    fn actor5_prepared(&self) -> &bool {
        &self.actor5_prepared
    }
    fn actor5_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor5_prepared
    }
    fn actor6_prepared(&self) -> &bool {
        &self.actor6_prepared
    }
    fn actor6_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor6_prepared
    }
    fn check_actor1_finished(&self) -> &bool {
        &self.check_actor1_finished
    }
    fn check_actor1_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor1_finished
    }
    fn check_actor2_finished(&self) -> &bool {
        &self.check_actor2_finished
    }
    fn check_actor2_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor2_finished
    }
    fn check_actor3_finished(&self) -> &bool {
        &self.check_actor3_finished
    }
    fn check_actor3_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor3_finished
    }
    fn check_actor4_finished(&self) -> &bool {
        &self.check_actor4_finished
    }
    fn check_actor4_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor4_finished
    }
    fn check_actor5_finished(&self) -> &bool {
        &self.check_actor5_finished
    }
    fn check_actor5_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor5_finished
    }
    fn check_actor6_finished(&self) -> &bool {
        &self.check_actor6_finished
    }
    fn check_actor6_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor6_finished
    }
    fn external_time(&self) -> &f32 {
        &self.external_time
    }
    fn external_time_mut(&mut self) -> &mut f32 {
        &mut self.external_time
    }
    fn use_external_time(&self) -> &bool {
        &self.use_external_time
    }
    fn use_external_time_mut(&mut self) -> &mut bool {
        &mut self.use_external_time
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::SpatialEntityDataTrait for MultipleActorScenarioEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for MultipleActorScenarioEntityData {
}

impl super::entity::GameObjectDataTrait for MultipleActorScenarioEntityData {
}

impl super::core::DataBusPeerTrait for MultipleActorScenarioEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MultipleActorScenarioEntityData {
}

impl super::core::DataContainerTrait for MultipleActorScenarioEntityData {
}

pub static MULTIPLEACTORSCENARIOENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleActorScenarioEntityData",
    name_hash: 1064947611,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(MultipleActorScenarioEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultipleActorScenarioEntityData as Default>::default())),
            create_boxed: || Box::new(<MultipleActorScenarioEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "WorldSpace",
                name_hash: 632957315,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, world_space),
            },
            FieldInfoData {
                name: "WorldSpaceConnectTransform",
                name_hash: 1100259089,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, world_space_connect_transform),
            },
            FieldInfoData {
                name: "ScenarioAntRef",
                name_hash: 3249359201,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, scenario_ant_ref),
            },
            FieldInfoData {
                name: "LevelChoice",
                name_hash: 1514666168,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, level_choice),
            },
            FieldInfoData {
                name: "ScenarioChoice",
                name_hash: 3315992608,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, scenario_choice),
            },
            FieldInfoData {
                name: "AligningEnabled",
                name_hash: 1454127501,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, aligning_enabled),
            },
            FieldInfoData {
                name: "UseInputEventPlayerAsPlayer1",
                name_hash: 2839224479,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, use_input_event_player_as_player1),
            },
            FieldInfoData {
                name: "Actor1",
                name_hash: 2484184607,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor1),
            },
            FieldInfoData {
                name: "Actor1Part",
                name_hash: 4068170024,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor1_part),
            },
            FieldInfoData {
                name: "Actor1SecondPart",
                name_hash: 3245706712,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor1_second_part),
            },
            FieldInfoData {
                name: "Actor2",
                name_hash: 2484184604,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor2),
            },
            FieldInfoData {
                name: "Actor2Part",
                name_hash: 4069073131,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor2_part),
            },
            FieldInfoData {
                name: "Actor2SecondPart",
                name_hash: 1494016859,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor2_second_part),
            },
            FieldInfoData {
                name: "Actor3",
                name_hash: 2484184605,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor3),
            },
            FieldInfoData {
                name: "Actor3Part",
                name_hash: 4070394026,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor3_part),
            },
            FieldInfoData {
                name: "Actor3SecondPart",
                name_hash: 2441148378,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor3_second_part),
            },
            FieldInfoData {
                name: "Actor4",
                name_hash: 2484184602,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor4),
            },
            FieldInfoData {
                name: "Actor4Part",
                name_hash: 4062105453,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor4_part),
            },
            FieldInfoData {
                name: "Actor4SecondPart",
                name_hash: 3250112349,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor4_second_part),
            },
            FieldInfoData {
                name: "Actor5",
                name_hash: 2484184603,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor5),
            },
            FieldInfoData {
                name: "Actor5Part",
                name_hash: 4063426348,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor5_part),
            },
            FieldInfoData {
                name: "Actor5SecondPart",
                name_hash: 4197243868,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor5_second_part),
            },
            FieldInfoData {
                name: "Actor6",
                name_hash: 2484184600,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor6),
            },
            FieldInfoData {
                name: "Actor6Part",
                name_hash: 4064329455,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor6_part),
            },
            FieldInfoData {
                name: "Actor6SecondPart",
                name_hash: 2445554015,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor6_second_part),
            },
            FieldInfoData {
                name: "ScenarioActive",
                name_hash: 3253317991,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, scenario_active),
            },
            FieldInfoData {
                name: "Actor1Prepared",
                name_hash: 3975066650,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor1_prepared),
            },
            FieldInfoData {
                name: "Actor2Prepared",
                name_hash: 2878190105,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor2_prepared),
            },
            FieldInfoData {
                name: "Actor3Prepared",
                name_hash: 770618392,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor3_prepared),
            },
            FieldInfoData {
                name: "Actor4Prepared",
                name_hash: 2873438751,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor4_prepared),
            },
            FieldInfoData {
                name: "Actor5Prepared",
                name_hash: 765867038,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor5_prepared),
            },
            FieldInfoData {
                name: "Actor6Prepared",
                name_hash: 3963957789,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor6_prepared),
            },
            FieldInfoData {
                name: "CheckActor1Finished",
                name_hash: 2061362539,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor1_finished),
            },
            FieldInfoData {
                name: "CheckActor2Finished",
                name_hash: 4180155688,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor2_finished),
            },
            FieldInfoData {
                name: "CheckActor3Finished",
                name_hash: 2998814185,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor3_finished),
            },
            FieldInfoData {
                name: "CheckActor4Finished",
                name_hash: 1137974702,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor4_finished),
            },
            FieldInfoData {
                name: "CheckActor5Finished",
                name_hash: 4251600495,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor5_finished),
            },
            FieldInfoData {
                name: "CheckActor6Finished",
                name_hash: 2075426348,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor6_finished),
            },
            FieldInfoData {
                name: "ExternalTime",
                name_hash: 2162678253,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, external_time),
            },
            FieldInfoData {
                name: "UseExternalTime",
                name_hash: 2902061742,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, use_external_time),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, realm),
            },
        ],
    }),
    array_type: Some(MULTIPLEACTORSCENARIOENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MultipleActorScenarioEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTIPLEACTORSCENARIOENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTIPLEACTORSCENARIOENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleActorScenarioEntityData-Array",
    name_hash: 3609953839,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MultipleActorScenarioEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BillboardTransformEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub rotation_axis: BillboardTransformRotationAxis,
    pub ignore_translation: bool,
    pub r#in: super::core::LinearTransform,
}

pub trait BillboardTransformEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn rotation_axis(&self) -> &BillboardTransformRotationAxis;
    fn rotation_axis_mut(&mut self) -> &mut BillboardTransformRotationAxis;
    fn ignore_translation(&self) -> &bool;
    fn ignore_translation_mut(&mut self) -> &mut bool;
    fn r#in(&self) -> &super::core::LinearTransform;
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl BillboardTransformEntityDataTrait for BillboardTransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn rotation_axis(&self) -> &BillboardTransformRotationAxis {
        &self.rotation_axis
    }
    fn rotation_axis_mut(&mut self) -> &mut BillboardTransformRotationAxis {
        &mut self.rotation_axis
    }
    fn ignore_translation(&self) -> &bool {
        &self.ignore_translation
    }
    fn ignore_translation_mut(&mut self) -> &mut bool {
        &mut self.ignore_translation
    }
    fn r#in(&self) -> &super::core::LinearTransform {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.r#in
    }
}

impl super::entity::SpatialEntityDataTrait for BillboardTransformEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for BillboardTransformEntityData {
}

impl super::entity::GameObjectDataTrait for BillboardTransformEntityData {
}

impl super::core::DataBusPeerTrait for BillboardTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BillboardTransformEntityData {
}

impl super::core::DataContainerTrait for BillboardTransformEntityData {
}

pub static BILLBOARDTRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BillboardTransformEntityData",
    name_hash: 600413715,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BillboardTransformEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BillboardTransformEntityData as Default>::default())),
            create_boxed: || Box::new(<BillboardTransformEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BillboardTransformEntityData, realm),
            },
            FieldInfoData {
                name: "RotationAxis",
                name_hash: 3148542130,
                flags: MemberInfoFlags::new(0),
                field_type: "BillboardTransformRotationAxis",
                rust_offset: offset_of!(BillboardTransformEntityData, rotation_axis),
            },
            FieldInfoData {
                name: "IgnoreTranslation",
                name_hash: 347138390,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BillboardTransformEntityData, ignore_translation),
            },
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(BillboardTransformEntityData, r#in),
            },
        ],
    }),
    array_type: Some(BILLBOARDTRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BillboardTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BILLBOARDTRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BILLBOARDTRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BillboardTransformEntityData-Array",
    name_hash: 1079431335,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BillboardTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BillboardTransformRotationAxis {
    #[default]
    BillboardTransformRotationAxis_All = 0,
    BillboardTransformRotationAxis_X = 1,
    BillboardTransformRotationAxis_Y = 2,
    BillboardTransformRotationAxis_Z = 3,
}

pub static BILLBOARDTRANSFORMROTATIONAXIS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BillboardTransformRotationAxis",
    name_hash: 996616079,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BILLBOARDTRANSFORMROTATIONAXIS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BillboardTransformRotationAxis {
    fn type_info(&self) -> &'static TypeInfo {
        BILLBOARDTRANSFORMROTATIONAXIS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BILLBOARDTRANSFORMROTATIONAXIS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BillboardTransformRotationAxis-Array",
    name_hash: 2808595515,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BillboardTransformRotationAxis"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WaterDepthEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub default_enabled: bool,
}

pub trait WaterDepthEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_enabled(&self) -> &bool;
    fn default_enabled_mut(&mut self) -> &mut bool;
}

impl WaterDepthEntityDataTrait for WaterDepthEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_enabled(&self) -> &bool {
        &self.default_enabled
    }
    fn default_enabled_mut(&mut self) -> &mut bool {
        &mut self.default_enabled
    }
}

impl super::entity::SpatialEntityDataTrait for WaterDepthEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for WaterDepthEntityData {
}

impl super::entity::GameObjectDataTrait for WaterDepthEntityData {
}

impl super::core::DataBusPeerTrait for WaterDepthEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WaterDepthEntityData {
}

impl super::core::DataContainerTrait for WaterDepthEntityData {
}

pub static WATERDEPTHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterDepthEntityData",
    name_hash: 2000001718,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(WaterDepthEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaterDepthEntityData as Default>::default())),
            create_boxed: || Box::new(<WaterDepthEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WaterDepthEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultEnabled",
                name_hash: 1919222475,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthEntityData, default_enabled),
            },
        ],
    }),
    array_type: Some(WATERDEPTHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WaterDepthEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WATERDEPTHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WATERDEPTHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterDepthEntityData-Array",
    name_hash: 1390964482,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WaterDepthEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TransformSnapToGroundEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub r#in: super::core::LinearTransform,
    pub distance_to_ground: f32,
    pub ray_cast_length: f32,
    pub ray_cast_up_offset: f32,
    pub align_with_ground_normal: bool,
    pub ignore_water: bool,
}

pub trait TransformSnapToGroundEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn r#in(&self) -> &super::core::LinearTransform;
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform;
    fn distance_to_ground(&self) -> &f32;
    fn distance_to_ground_mut(&mut self) -> &mut f32;
    fn ray_cast_length(&self) -> &f32;
    fn ray_cast_length_mut(&mut self) -> &mut f32;
    fn ray_cast_up_offset(&self) -> &f32;
    fn ray_cast_up_offset_mut(&mut self) -> &mut f32;
    fn align_with_ground_normal(&self) -> &bool;
    fn align_with_ground_normal_mut(&mut self) -> &mut bool;
    fn ignore_water(&self) -> &bool;
    fn ignore_water_mut(&mut self) -> &mut bool;
}

impl TransformSnapToGroundEntityDataTrait for TransformSnapToGroundEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn r#in(&self) -> &super::core::LinearTransform {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.r#in
    }
    fn distance_to_ground(&self) -> &f32 {
        &self.distance_to_ground
    }
    fn distance_to_ground_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_ground
    }
    fn ray_cast_length(&self) -> &f32 {
        &self.ray_cast_length
    }
    fn ray_cast_length_mut(&mut self) -> &mut f32 {
        &mut self.ray_cast_length
    }
    fn ray_cast_up_offset(&self) -> &f32 {
        &self.ray_cast_up_offset
    }
    fn ray_cast_up_offset_mut(&mut self) -> &mut f32 {
        &mut self.ray_cast_up_offset
    }
    fn align_with_ground_normal(&self) -> &bool {
        &self.align_with_ground_normal
    }
    fn align_with_ground_normal_mut(&mut self) -> &mut bool {
        &mut self.align_with_ground_normal
    }
    fn ignore_water(&self) -> &bool {
        &self.ignore_water
    }
    fn ignore_water_mut(&mut self) -> &mut bool {
        &mut self.ignore_water
    }
}

impl super::entity::EntityDataTrait for TransformSnapToGroundEntityData {
}

impl super::entity::GameObjectDataTrait for TransformSnapToGroundEntityData {
}

impl super::core::DataBusPeerTrait for TransformSnapToGroundEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformSnapToGroundEntityData {
}

impl super::core::DataContainerTrait for TransformSnapToGroundEntityData {
}

pub static TRANSFORMSNAPTOGROUNDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSnapToGroundEntityData",
    name_hash: 4183516656,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TransformSnapToGroundEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSnapToGroundEntityData as Default>::default())),
            create_boxed: || Box::new(<TransformSnapToGroundEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                name_hash: 5862146,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, r#in),
            },
            FieldInfoData {
                name: "DistanceToGround",
                name_hash: 3638863832,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, distance_to_ground),
            },
            FieldInfoData {
                name: "RayCastLength",
                name_hash: 2786399190,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, ray_cast_length),
            },
            FieldInfoData {
                name: "RayCastUpOffset",
                name_hash: 2052773058,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, ray_cast_up_offset),
            },
            FieldInfoData {
                name: "AlignWithGroundNormal",
                name_hash: 387843516,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, align_with_ground_normal),
            },
            FieldInfoData {
                name: "IgnoreWater",
                name_hash: 1586478952,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, ignore_water),
            },
        ],
    }),
    array_type: Some(TRANSFORMSNAPTOGROUNDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformSnapToGroundEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSNAPTOGROUNDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMSNAPTOGROUNDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSnapToGroundEntityData-Array",
    name_hash: 88966084,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TransformSnapToGroundEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MeshEmitterDynamicState {
}

pub trait MeshEmitterDynamicStateTrait: TypeObject {
}

impl MeshEmitterDynamicStateTrait for MeshEmitterDynamicState {
}

pub static MESHEMITTERDYNAMICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterDynamicState",
    name_hash: 110467426,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshEmitterDynamicState as Default>::default())),
            create_boxed: || Box::new(<MeshEmitterDynamicState as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(MESHEMITTERDYNAMICSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MeshEmitterDynamicState {
    fn type_info(&self) -> &'static TypeInfo {
        MESHEMITTERDYNAMICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MESHEMITTERDYNAMICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterDynamicState-Array",
    name_hash: 3076114518,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshEmitterDynamicState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MeshEmitterStaticState {
    pub mesh_emitter: Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */>,
    pub transform_space: super::state_stream::TransformSpaceHandle,
    pub field_flag_changed0: u8,
}

pub trait MeshEmitterStaticStateTrait: TypeObject {
    fn mesh_emitter(&self) -> &Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */>;
    fn mesh_emitter_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */>;
    fn transform_space(&self) -> &super::state_stream::TransformSpaceHandle;
    fn transform_space_mut(&mut self) -> &mut super::state_stream::TransformSpaceHandle;
    fn field_flag_changed0(&self) -> &u8;
    fn field_flag_changed0_mut(&mut self) -> &mut u8;
}

impl MeshEmitterStaticStateTrait for MeshEmitterStaticState {
    fn mesh_emitter(&self) -> &Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */> {
        &self.mesh_emitter
    }
    fn mesh_emitter_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */> {
        &mut self.mesh_emitter
    }
    fn transform_space(&self) -> &super::state_stream::TransformSpaceHandle {
        &self.transform_space
    }
    fn transform_space_mut(&mut self) -> &mut super::state_stream::TransformSpaceHandle {
        &mut self.transform_space
    }
    fn field_flag_changed0(&self) -> &u8 {
        &self.field_flag_changed0
    }
    fn field_flag_changed0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_changed0
    }
}

pub static MESHEMITTERSTATICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterStaticState",
    name_hash: 1493078255,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshEmitterStaticState as Default>::default())),
            create_boxed: || Box::new(<MeshEmitterStaticState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MeshEmitter",
                name_hash: 75090976,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshEmitterBaseAsset",
                rust_offset: offset_of!(MeshEmitterStaticState, mesh_emitter),
            },
            FieldInfoData {
                name: "TransformSpace",
                name_hash: 3602558253,
                flags: MemberInfoFlags::new(0),
                field_type: "TransformSpaceHandle",
                rust_offset: offset_of!(MeshEmitterStaticState, transform_space),
            },
            FieldInfoData {
                name: "FieldFlagChanged0",
                name_hash: 4279507097,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(MeshEmitterStaticState, field_flag_changed0),
            },
        ],
    }),
    array_type: Some(MESHEMITTERSTATICSTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeshEmitterStaticState {
    fn type_info(&self) -> &'static TypeInfo {
        MESHEMITTERSTATICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MESHEMITTERSTATICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterStaticState-Array",
    name_hash: 1881730779,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshEmitterStaticState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MeshEmitterControlEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub mesh_emitter: Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */>,
}

pub trait MeshEmitterControlEntityDataTrait: super::entity::EntityDataTrait {
    fn mesh_emitter(&self) -> &Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */>;
    fn mesh_emitter_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */>;
}

impl MeshEmitterControlEntityDataTrait for MeshEmitterControlEntityData {
    fn mesh_emitter(&self) -> &Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */> {
        &self.mesh_emitter
    }
    fn mesh_emitter_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::MeshEmitterBaseAsset */> {
        &mut self.mesh_emitter
    }
}

impl super::entity::EntityDataTrait for MeshEmitterControlEntityData {
}

impl super::entity::GameObjectDataTrait for MeshEmitterControlEntityData {
}

impl super::core::DataBusPeerTrait for MeshEmitterControlEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MeshEmitterControlEntityData {
}

impl super::core::DataContainerTrait for MeshEmitterControlEntityData {
}

pub static MESHEMITTERCONTROLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterControlEntityData",
    name_hash: 541876876,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(MeshEmitterControlEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshEmitterControlEntityData as Default>::default())),
            create_boxed: || Box::new(<MeshEmitterControlEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MeshEmitter",
                name_hash: 75090976,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshEmitterBaseAsset",
                rust_offset: offset_of!(MeshEmitterControlEntityData, mesh_emitter),
            },
        ],
    }),
    array_type: Some(MESHEMITTERCONTROLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeshEmitterControlEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MESHEMITTERCONTROLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHEMITTERCONTROLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterControlEntityData-Array",
    name_hash: 973730488,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshEmitterControlEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MemoryPoolControlDynamicState {
}

pub trait MemoryPoolControlDynamicStateTrait: TypeObject {
}

impl MemoryPoolControlDynamicStateTrait for MemoryPoolControlDynamicState {
}

pub static MEMORYPOOLCONTROLDYNAMICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlDynamicState",
    name_hash: 99864317,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MemoryPoolControlDynamicState as Default>::default())),
            create_boxed: || Box::new(<MemoryPoolControlDynamicState as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(MEMORYPOOLCONTROLDYNAMICSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MemoryPoolControlDynamicState {
    fn type_info(&self) -> &'static TypeInfo {
        MEMORYPOOLCONTROLDYNAMICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MEMORYPOOLCONTROLDYNAMICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlDynamicState-Array",
    name_hash: 293288905,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MemoryPoolControlDynamicState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MemoryPoolControlStaticState {
    pub memory_pool: MemoryPoolControlType,
    pub memory_target_override_k_b: i32,
    pub field_flag_changed0: u8,
}

pub trait MemoryPoolControlStaticStateTrait: TypeObject {
    fn memory_pool(&self) -> &MemoryPoolControlType;
    fn memory_pool_mut(&mut self) -> &mut MemoryPoolControlType;
    fn memory_target_override_k_b(&self) -> &i32;
    fn memory_target_override_k_b_mut(&mut self) -> &mut i32;
    fn field_flag_changed0(&self) -> &u8;
    fn field_flag_changed0_mut(&mut self) -> &mut u8;
}

impl MemoryPoolControlStaticStateTrait for MemoryPoolControlStaticState {
    fn memory_pool(&self) -> &MemoryPoolControlType {
        &self.memory_pool
    }
    fn memory_pool_mut(&mut self) -> &mut MemoryPoolControlType {
        &mut self.memory_pool
    }
    fn memory_target_override_k_b(&self) -> &i32 {
        &self.memory_target_override_k_b
    }
    fn memory_target_override_k_b_mut(&mut self) -> &mut i32 {
        &mut self.memory_target_override_k_b
    }
    fn field_flag_changed0(&self) -> &u8 {
        &self.field_flag_changed0
    }
    fn field_flag_changed0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_changed0
    }
}

pub static MEMORYPOOLCONTROLSTATICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlStaticState",
    name_hash: 2592651024,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MemoryPoolControlStaticState as Default>::default())),
            create_boxed: || Box::new(<MemoryPoolControlStaticState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MemoryPool",
                name_hash: 1308429112,
                flags: MemberInfoFlags::new(0),
                field_type: "MemoryPoolControlType",
                rust_offset: offset_of!(MemoryPoolControlStaticState, memory_pool),
            },
            FieldInfoData {
                name: "MemoryTargetOverrideKB",
                name_hash: 4234994536,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MemoryPoolControlStaticState, memory_target_override_k_b),
            },
            FieldInfoData {
                name: "FieldFlagChanged0",
                name_hash: 4279507097,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(MemoryPoolControlStaticState, field_flag_changed0),
            },
        ],
    }),
    array_type: Some(MEMORYPOOLCONTROLSTATICSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MemoryPoolControlStaticState {
    fn type_info(&self) -> &'static TypeInfo {
        MEMORYPOOLCONTROLSTATICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MEMORYPOOLCONTROLSTATICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlStaticState-Array",
    name_hash: 1982293284,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MemoryPoolControlStaticState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MemoryPoolControlEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub memory_pool: MemoryPoolControlType,
    pub activate_override_on_init: bool,
    pub memory_target_override_k_b: i32,
}

pub trait MemoryPoolControlEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn memory_pool(&self) -> &MemoryPoolControlType;
    fn memory_pool_mut(&mut self) -> &mut MemoryPoolControlType;
    fn activate_override_on_init(&self) -> &bool;
    fn activate_override_on_init_mut(&mut self) -> &mut bool;
    fn memory_target_override_k_b(&self) -> &i32;
    fn memory_target_override_k_b_mut(&mut self) -> &mut i32;
}

impl MemoryPoolControlEntityDataTrait for MemoryPoolControlEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn memory_pool(&self) -> &MemoryPoolControlType {
        &self.memory_pool
    }
    fn memory_pool_mut(&mut self) -> &mut MemoryPoolControlType {
        &mut self.memory_pool
    }
    fn activate_override_on_init(&self) -> &bool {
        &self.activate_override_on_init
    }
    fn activate_override_on_init_mut(&mut self) -> &mut bool {
        &mut self.activate_override_on_init
    }
    fn memory_target_override_k_b(&self) -> &i32 {
        &self.memory_target_override_k_b
    }
    fn memory_target_override_k_b_mut(&mut self) -> &mut i32 {
        &mut self.memory_target_override_k_b
    }
}

impl super::entity::EntityDataTrait for MemoryPoolControlEntityData {
}

impl super::entity::GameObjectDataTrait for MemoryPoolControlEntityData {
}

impl super::core::DataBusPeerTrait for MemoryPoolControlEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MemoryPoolControlEntityData {
}

impl super::core::DataContainerTrait for MemoryPoolControlEntityData {
}

pub static MEMORYPOOLCONTROLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlEntityData",
    name_hash: 1193233556,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(MemoryPoolControlEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MemoryPoolControlEntityData as Default>::default())),
            create_boxed: || Box::new(<MemoryPoolControlEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MemoryPoolControlEntityData, realm),
            },
            FieldInfoData {
                name: "MemoryPool",
                name_hash: 1308429112,
                flags: MemberInfoFlags::new(0),
                field_type: "MemoryPoolControlType",
                rust_offset: offset_of!(MemoryPoolControlEntityData, memory_pool),
            },
            FieldInfoData {
                name: "ActivateOverrideOnInit",
                name_hash: 54976147,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MemoryPoolControlEntityData, activate_override_on_init),
            },
            FieldInfoData {
                name: "MemoryTargetOverrideKB",
                name_hash: 4234994536,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MemoryPoolControlEntityData, memory_target_override_k_b),
            },
        ],
    }),
    array_type: Some(MEMORYPOOLCONTROLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MemoryPoolControlEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MEMORYPOOLCONTROLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MEMORYPOOLCONTROLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlEntityData-Array",
    name_hash: 4277651616,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MemoryPoolControlEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MemoryPoolControlType {
    #[default]
    MemoryPoolControlType_Texture = 0,
    MemoryPoolControlType_Mesh = 1,
    MemoryPoolControlType_Max = 2,
}

pub static MEMORYPOOLCONTROLTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlType",
    name_hash: 916241031,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MEMORYPOOLCONTROLTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MemoryPoolControlType {
    fn type_info(&self) -> &'static TypeInfo {
        MEMORYPOOLCONTROLTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MEMORYPOOLCONTROLTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlType-Array",
    name_hash: 3837803315,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MemoryPoolControlType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayVFXEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub visual_effect: Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>,
    pub effect_location: VFXLocationControl,
    pub location_a: VFXLocationControl,
    pub location_b: VFXLocationControl,
    pub location_c: VFXLocationControl,
    pub raw_transform_effect_location: super::core::LinearTransform,
    pub raw_transform_location_a: super::core::LinearTransform,
    pub raw_transform_location_b: super::core::LinearTransform,
    pub raw_transform_location_c: super::core::LinearTransform,
}

pub trait PlayVFXEntityDataTrait: super::entity::EntityDataTrait {
    fn visual_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn visual_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn effect_location(&self) -> &VFXLocationControl;
    fn effect_location_mut(&mut self) -> &mut VFXLocationControl;
    fn location_a(&self) -> &VFXLocationControl;
    fn location_a_mut(&mut self) -> &mut VFXLocationControl;
    fn location_b(&self) -> &VFXLocationControl;
    fn location_b_mut(&mut self) -> &mut VFXLocationControl;
    fn location_c(&self) -> &VFXLocationControl;
    fn location_c_mut(&mut self) -> &mut VFXLocationControl;
    fn raw_transform_effect_location(&self) -> &super::core::LinearTransform;
    fn raw_transform_effect_location_mut(&mut self) -> &mut super::core::LinearTransform;
    fn raw_transform_location_a(&self) -> &super::core::LinearTransform;
    fn raw_transform_location_a_mut(&mut self) -> &mut super::core::LinearTransform;
    fn raw_transform_location_b(&self) -> &super::core::LinearTransform;
    fn raw_transform_location_b_mut(&mut self) -> &mut super::core::LinearTransform;
    fn raw_transform_location_c(&self) -> &super::core::LinearTransform;
    fn raw_transform_location_c_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl PlayVFXEntityDataTrait for PlayVFXEntityData {
    fn visual_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &self.visual_effect
    }
    fn visual_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &mut self.visual_effect
    }
    fn effect_location(&self) -> &VFXLocationControl {
        &self.effect_location
    }
    fn effect_location_mut(&mut self) -> &mut VFXLocationControl {
        &mut self.effect_location
    }
    fn location_a(&self) -> &VFXLocationControl {
        &self.location_a
    }
    fn location_a_mut(&mut self) -> &mut VFXLocationControl {
        &mut self.location_a
    }
    fn location_b(&self) -> &VFXLocationControl {
        &self.location_b
    }
    fn location_b_mut(&mut self) -> &mut VFXLocationControl {
        &mut self.location_b
    }
    fn location_c(&self) -> &VFXLocationControl {
        &self.location_c
    }
    fn location_c_mut(&mut self) -> &mut VFXLocationControl {
        &mut self.location_c
    }
    fn raw_transform_effect_location(&self) -> &super::core::LinearTransform {
        &self.raw_transform_effect_location
    }
    fn raw_transform_effect_location_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.raw_transform_effect_location
    }
    fn raw_transform_location_a(&self) -> &super::core::LinearTransform {
        &self.raw_transform_location_a
    }
    fn raw_transform_location_a_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.raw_transform_location_a
    }
    fn raw_transform_location_b(&self) -> &super::core::LinearTransform {
        &self.raw_transform_location_b
    }
    fn raw_transform_location_b_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.raw_transform_location_b
    }
    fn raw_transform_location_c(&self) -> &super::core::LinearTransform {
        &self.raw_transform_location_c
    }
    fn raw_transform_location_c_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.raw_transform_location_c
    }
}

impl super::entity::EntityDataTrait for PlayVFXEntityData {
}

impl super::entity::GameObjectDataTrait for PlayVFXEntityData {
}

impl super::core::DataBusPeerTrait for PlayVFXEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayVFXEntityData {
}

impl super::core::DataContainerTrait for PlayVFXEntityData {
}

pub static PLAYVFXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayVFXEntityData",
    name_hash: 874051074,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlayVFXEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayVFXEntityData as Default>::default())),
            create_boxed: || Box::new(<PlayVFXEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "VisualEffect",
                name_hash: 1246567558,
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(PlayVFXEntityData, visual_effect),
            },
            FieldInfoData {
                name: "EffectLocation",
                name_hash: 3309277839,
                flags: MemberInfoFlags::new(0),
                field_type: "VFXLocationControl",
                rust_offset: offset_of!(PlayVFXEntityData, effect_location),
            },
            FieldInfoData {
                name: "LocationA",
                name_hash: 781255737,
                flags: MemberInfoFlags::new(0),
                field_type: "VFXLocationControl",
                rust_offset: offset_of!(PlayVFXEntityData, location_a),
            },
            FieldInfoData {
                name: "LocationB",
                name_hash: 781255738,
                flags: MemberInfoFlags::new(0),
                field_type: "VFXLocationControl",
                rust_offset: offset_of!(PlayVFXEntityData, location_b),
            },
            FieldInfoData {
                name: "LocationC",
                name_hash: 781255739,
                flags: MemberInfoFlags::new(0),
                field_type: "VFXLocationControl",
                rust_offset: offset_of!(PlayVFXEntityData, location_c),
            },
            FieldInfoData {
                name: "RawTransformEffectLocation",
                name_hash: 4008641767,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayVFXEntityData, raw_transform_effect_location),
            },
            FieldInfoData {
                name: "RawTransformLocationA",
                name_hash: 428283601,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayVFXEntityData, raw_transform_location_a),
            },
            FieldInfoData {
                name: "RawTransformLocationB",
                name_hash: 428283602,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayVFXEntityData, raw_transform_location_b),
            },
            FieldInfoData {
                name: "RawTransformLocationC",
                name_hash: 428283603,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayVFXEntityData, raw_transform_location_c),
            },
        ],
    }),
    array_type: Some(PLAYVFXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayVFXEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYVFXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYVFXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayVFXEntityData-Array",
    name_hash: 1522816310,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayVFXEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VFXLocationControl {
    pub attachment: i32,
    pub stay_attached: bool,
    pub preserve_orientation: bool,
    pub offset_from_character_forward: bool,
    pub offset: super::core::LinearTransform,
}

pub trait VFXLocationControlTrait: TypeObject {
    fn attachment(&self) -> &i32;
    fn attachment_mut(&mut self) -> &mut i32;
    fn stay_attached(&self) -> &bool;
    fn stay_attached_mut(&mut self) -> &mut bool;
    fn preserve_orientation(&self) -> &bool;
    fn preserve_orientation_mut(&mut self) -> &mut bool;
    fn offset_from_character_forward(&self) -> &bool;
    fn offset_from_character_forward_mut(&mut self) -> &mut bool;
    fn offset(&self) -> &super::core::LinearTransform;
    fn offset_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl VFXLocationControlTrait for VFXLocationControl {
    fn attachment(&self) -> &i32 {
        &self.attachment
    }
    fn attachment_mut(&mut self) -> &mut i32 {
        &mut self.attachment
    }
    fn stay_attached(&self) -> &bool {
        &self.stay_attached
    }
    fn stay_attached_mut(&mut self) -> &mut bool {
        &mut self.stay_attached
    }
    fn preserve_orientation(&self) -> &bool {
        &self.preserve_orientation
    }
    fn preserve_orientation_mut(&mut self) -> &mut bool {
        &mut self.preserve_orientation
    }
    fn offset_from_character_forward(&self) -> &bool {
        &self.offset_from_character_forward
    }
    fn offset_from_character_forward_mut(&mut self) -> &mut bool {
        &mut self.offset_from_character_forward
    }
    fn offset(&self) -> &super::core::LinearTransform {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.offset
    }
}

pub static VFXLOCATIONCONTROL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VFXLocationControl",
    name_hash: 353153623,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VFXLocationControl as Default>::default())),
            create_boxed: || Box::new(<VFXLocationControl as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Attachment",
                name_hash: 1150297756,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VFXLocationControl, attachment),
            },
            FieldInfoData {
                name: "StayAttached",
                name_hash: 2074383536,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VFXLocationControl, stay_attached),
            },
            FieldInfoData {
                name: "PreserveOrientation",
                name_hash: 257154115,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VFXLocationControl, preserve_orientation),
            },
            FieldInfoData {
                name: "OffsetFromCharacterForward",
                name_hash: 1474884956,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VFXLocationControl, offset_from_character_forward),
            },
            FieldInfoData {
                name: "Offset",
                name_hash: 2871410728,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(VFXLocationControl, offset),
            },
        ],
    }),
    array_type: Some(VFXLOCATIONCONTROL_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VFXLocationControl {
    fn type_info(&self) -> &'static TypeInfo {
        VFXLOCATIONCONTROL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VFXLOCATIONCONTROL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VFXLocationControl-Array",
    name_hash: 2365426531,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VFXLocationControl"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LocalPlayerEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub all_local_players: bool,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait LocalPlayerEventEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn all_local_players(&self) -> &bool;
    fn all_local_players_mut(&mut self) -> &mut bool;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl LocalPlayerEventEntityDataTrait for LocalPlayerEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn all_local_players(&self) -> &bool {
        &self.all_local_players
    }
    fn all_local_players_mut(&mut self) -> &mut bool {
        &mut self.all_local_players
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for LocalPlayerEventEntityData {
}

impl super::entity::GameObjectDataTrait for LocalPlayerEventEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlayerEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalPlayerEventEntityData {
}

impl super::core::DataContainerTrait for LocalPlayerEventEntityData {
}

pub static LOCALPLAYEREVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerEventEntityData",
    name_hash: 367984476,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LocalPlayerEventEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerEventEntityData as Default>::default())),
            create_boxed: || Box::new(<LocalPlayerEventEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocalPlayerEventEntityData, realm),
            },
            FieldInfoData {
                name: "AllLocalPlayers",
                name_hash: 4272258473,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LocalPlayerEventEntityData, all_local_players),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LocalPlayerEventEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(LOCALPLAYEREVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYEREVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALPLAYEREVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerEventEntityData-Array",
    name_hash: 1916135400,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LocalPlayerEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayerIteratorEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub team: super::gameplay_sim::TeamId,
    pub alive: bool,
    pub randomize_from_start: bool,
}

pub trait PlayerIteratorEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn alive(&self) -> &bool;
    fn alive_mut(&mut self) -> &mut bool;
    fn randomize_from_start(&self) -> &bool;
    fn randomize_from_start_mut(&mut self) -> &mut bool;
}

impl PlayerIteratorEntityDataTrait for PlayerIteratorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn alive(&self) -> &bool {
        &self.alive
    }
    fn alive_mut(&mut self) -> &mut bool {
        &mut self.alive
    }
    fn randomize_from_start(&self) -> &bool {
        &self.randomize_from_start
    }
    fn randomize_from_start_mut(&mut self) -> &mut bool {
        &mut self.randomize_from_start
    }
}

impl super::entity::EntityDataTrait for PlayerIteratorEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerIteratorEntityData {
}

impl super::core::DataBusPeerTrait for PlayerIteratorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerIteratorEntityData {
}

impl super::core::DataContainerTrait for PlayerIteratorEntityData {
}

pub static PLAYERITERATORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerIteratorEntityData",
    name_hash: 3402314943,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlayerIteratorEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerIteratorEntityData as Default>::default())),
            create_boxed: || Box::new(<PlayerIteratorEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayerIteratorEntityData, realm),
            },
            FieldInfoData {
                name: "Team",
                name_hash: 2089309528,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(PlayerIteratorEntityData, team),
            },
            FieldInfoData {
                name: "Alive",
                name_hash: 205659826,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerIteratorEntityData, alive),
            },
            FieldInfoData {
                name: "RandomizeFromStart",
                name_hash: 16372094,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerIteratorEntityData, randomize_from_start),
            },
        ],
    }),
    array_type: Some(PLAYERITERATORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerIteratorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERITERATORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERITERATORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerIteratorEntityData-Array",
    name_hash: 3793758731,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerIteratorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct InclusionSettingEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub setting: String,
    pub settings: Vec<String>,
}

pub trait InclusionSettingEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn setting(&self) -> &String;
    fn setting_mut(&mut self) -> &mut String;
    fn settings(&self) -> &Vec<String>;
    fn settings_mut(&mut self) -> &mut Vec<String>;
}

impl InclusionSettingEntityDataTrait for InclusionSettingEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn setting(&self) -> &String {
        &self.setting
    }
    fn setting_mut(&mut self) -> &mut String {
        &mut self.setting
    }
    fn settings(&self) -> &Vec<String> {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut Vec<String> {
        &mut self.settings
    }
}

impl super::entity::EntityDataTrait for InclusionSettingEntityData {
}

impl super::entity::GameObjectDataTrait for InclusionSettingEntityData {
}

impl super::core::DataBusPeerTrait for InclusionSettingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for InclusionSettingEntityData {
}

impl super::core::DataContainerTrait for InclusionSettingEntityData {
}

pub static INCLUSIONSETTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InclusionSettingEntityData",
    name_hash: 3530613982,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(InclusionSettingEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InclusionSettingEntityData as Default>::default())),
            create_boxed: || Box::new(<InclusionSettingEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(InclusionSettingEntityData, realm),
            },
            FieldInfoData {
                name: "Setting",
                name_hash: 2752851091,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(InclusionSettingEntityData, setting),
            },
            FieldInfoData {
                name: "Settings",
                name_hash: 649772672,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(InclusionSettingEntityData, settings),
            },
        ],
    }),
    array_type: Some(INCLUSIONSETTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InclusionSettingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INCLUSIONSETTINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INCLUSIONSETTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InclusionSettingEntityData-Array",
    name_hash: 3139855978,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InclusionSettingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TeleportEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub new_position_transform: super::core::LinearTransform,
    pub check_below_ground: bool,
    pub default_teleport_player: bool,
}

pub trait TeleportEntityDataTrait: super::entity::EntityDataTrait {
    fn new_position_transform(&self) -> &super::core::LinearTransform;
    fn new_position_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn check_below_ground(&self) -> &bool;
    fn check_below_ground_mut(&mut self) -> &mut bool;
    fn default_teleport_player(&self) -> &bool;
    fn default_teleport_player_mut(&mut self) -> &mut bool;
}

impl TeleportEntityDataTrait for TeleportEntityData {
    fn new_position_transform(&self) -> &super::core::LinearTransform {
        &self.new_position_transform
    }
    fn new_position_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.new_position_transform
    }
    fn check_below_ground(&self) -> &bool {
        &self.check_below_ground
    }
    fn check_below_ground_mut(&mut self) -> &mut bool {
        &mut self.check_below_ground
    }
    fn default_teleport_player(&self) -> &bool {
        &self.default_teleport_player
    }
    fn default_teleport_player_mut(&mut self) -> &mut bool {
        &mut self.default_teleport_player
    }
}

impl super::entity::EntityDataTrait for TeleportEntityData {
}

impl super::entity::GameObjectDataTrait for TeleportEntityData {
}

impl super::core::DataBusPeerTrait for TeleportEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TeleportEntityData {
}

impl super::core::DataContainerTrait for TeleportEntityData {
}

pub static TELEPORTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeleportEntityData",
    name_hash: 2364363663,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TeleportEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeleportEntityData as Default>::default())),
            create_boxed: || Box::new(<TeleportEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "NewPositionTransform",
                name_hash: 3509343660,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TeleportEntityData, new_position_transform),
            },
            FieldInfoData {
                name: "CheckBelowGround",
                name_hash: 2487096021,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeleportEntityData, check_below_ground),
            },
            FieldInfoData {
                name: "DefaultTeleportPlayer",
                name_hash: 2067879484,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeleportEntityData, default_teleport_player),
            },
        ],
    }),
    array_type: Some(TELEPORTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TeleportEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TELEPORTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TELEPORTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeleportEntityData-Array",
    name_hash: 2279534651,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeleportEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StreamingGateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub timeout: f32,
}

pub trait StreamingGateEntityDataTrait: super::entity::EntityDataTrait {
    fn timeout(&self) -> &f32;
    fn timeout_mut(&mut self) -> &mut f32;
}

impl StreamingGateEntityDataTrait for StreamingGateEntityData {
    fn timeout(&self) -> &f32 {
        &self.timeout
    }
    fn timeout_mut(&mut self) -> &mut f32 {
        &mut self.timeout
    }
}

impl super::entity::EntityDataTrait for StreamingGateEntityData {
}

impl super::entity::GameObjectDataTrait for StreamingGateEntityData {
}

impl super::core::DataBusPeerTrait for StreamingGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StreamingGateEntityData {
}

impl super::core::DataContainerTrait for StreamingGateEntityData {
}

pub static STREAMINGGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamingGateEntityData",
    name_hash: 3175071685,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(StreamingGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StreamingGateEntityData as Default>::default())),
            create_boxed: || Box::new(<StreamingGateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Timeout",
                name_hash: 3344700766,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StreamingGateEntityData, timeout),
            },
        ],
    }),
    array_type: Some(STREAMINGGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamingGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMINGGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STREAMINGGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamingGateEntityData-Array",
    name_hash: 409319409,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StreamingGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomizeCharacterEntityData {
    pub _glacier_base: CustomizeBaseEntityData,
    pub customize_character_data: Option<LockedTypeObject /* CustomizeCharacterData */>,
}

pub trait CustomizeCharacterEntityDataTrait: CustomizeBaseEntityDataTrait {
    fn customize_character_data(&self) -> &Option<LockedTypeObject /* CustomizeCharacterData */>;
    fn customize_character_data_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizeCharacterData */>;
}

impl CustomizeCharacterEntityDataTrait for CustomizeCharacterEntityData {
    fn customize_character_data(&self) -> &Option<LockedTypeObject /* CustomizeCharacterData */> {
        &self.customize_character_data
    }
    fn customize_character_data_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizeCharacterData */> {
        &mut self.customize_character_data
    }
}

impl CustomizeBaseEntityDataTrait for CustomizeCharacterEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::entity::EntityDataTrait for CustomizeCharacterEntityData {
}

impl super::entity::GameObjectDataTrait for CustomizeCharacterEntityData {
}

impl super::core::DataBusPeerTrait for CustomizeCharacterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CustomizeCharacterEntityData {
}

impl super::core::DataContainerTrait for CustomizeCharacterEntityData {
}

pub static CUSTOMIZECHARACTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeCharacterEntityData",
    name_hash: 1494072338,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CUSTOMIZEBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CustomizeCharacterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeCharacterEntityData as Default>::default())),
            create_boxed: || Box::new(<CustomizeCharacterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "CustomizeCharacterData",
                name_hash: 3784213897,
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizeCharacterData",
                rust_offset: offset_of!(CustomizeCharacterEntityData, customize_character_data),
            },
        ],
    }),
    array_type: Some(CUSTOMIZECHARACTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizeCharacterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZECHARACTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZECHARACTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeCharacterEntityData-Array",
    name_hash: 3242746662,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizeCharacterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomizeBaseEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait CustomizeBaseEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl CustomizeBaseEntityDataTrait for CustomizeBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for CustomizeBaseEntityData {
}

impl super::entity::GameObjectDataTrait for CustomizeBaseEntityData {
}

impl super::core::DataBusPeerTrait for CustomizeBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CustomizeBaseEntityData {
}

impl super::core::DataContainerTrait for CustomizeBaseEntityData {
}

pub static CUSTOMIZEBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeBaseEntityData",
    name_hash: 1769078878,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CustomizeBaseEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeBaseEntityData as Default>::default())),
            create_boxed: || Box::new(<CustomizeBaseEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CustomizeBaseEntityData, realm),
            },
        ],
    }),
    array_type: Some(CUSTOMIZEBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CustomizeBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZEBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZEBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeBaseEntityData-Array",
    name_hash: 2960007658,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizeBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LocalPlayerFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait LocalPlayerFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl LocalPlayerFilterEntityDataTrait for LocalPlayerFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for LocalPlayerFilterEntityData {
}

impl super::entity::GameObjectDataTrait for LocalPlayerFilterEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlayerFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalPlayerFilterEntityData {
}

impl super::core::DataContainerTrait for LocalPlayerFilterEntityData {
}

pub static LOCALPLAYERFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerFilterEntityData",
    name_hash: 188149680,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LocalPlayerFilterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerFilterEntityData as Default>::default())),
            create_boxed: || Box::new(<LocalPlayerFilterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocalPlayerFilterEntityData, realm),
            },
        ],
    }),
    array_type: Some(LOCALPLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALPLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerFilterEntityData-Array",
    name_hash: 2120047876,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LocalPlayerFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayerFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub invert_filter: bool,
    pub forward_to_spectators: bool,
}

pub trait PlayerFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn invert_filter(&self) -> &bool;
    fn invert_filter_mut(&mut self) -> &mut bool;
    fn forward_to_spectators(&self) -> &bool;
    fn forward_to_spectators_mut(&mut self) -> &mut bool;
}

impl PlayerFilterEntityDataTrait for PlayerFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn invert_filter(&self) -> &bool {
        &self.invert_filter
    }
    fn invert_filter_mut(&mut self) -> &mut bool {
        &mut self.invert_filter
    }
    fn forward_to_spectators(&self) -> &bool {
        &self.forward_to_spectators
    }
    fn forward_to_spectators_mut(&mut self) -> &mut bool {
        &mut self.forward_to_spectators
    }
}

impl super::entity::EntityDataTrait for PlayerFilterEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerFilterEntityData {
}

impl super::core::DataBusPeerTrait for PlayerFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerFilterEntityData {
}

impl super::core::DataContainerTrait for PlayerFilterEntityData {
}

pub static PLAYERFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerFilterEntityData",
    name_hash: 4144475613,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlayerFilterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerFilterEntityData as Default>::default())),
            create_boxed: || Box::new(<PlayerFilterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayerFilterEntityData, realm),
            },
            FieldInfoData {
                name: "InvertFilter",
                name_hash: 2846947863,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerFilterEntityData, invert_filter),
            },
            FieldInfoData {
                name: "ForwardToSpectators",
                name_hash: 1753756911,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerFilterEntityData, forward_to_spectators),
            },
        ],
    }),
    array_type: Some(PLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerFilterEntityData-Array",
    name_hash: 33180137,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectAreaQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub geometry_transform: super::core::LinearTransform,
    pub radius: f32,
}

pub trait ObjectAreaQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn geometry_transform(&self) -> &super::core::LinearTransform;
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
}

impl ObjectAreaQueryEntityDataTrait for ObjectAreaQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn geometry_transform(&self) -> &super::core::LinearTransform {
        &self.geometry_transform
    }
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.geometry_transform
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
}

impl super::entity::EntityDataTrait for ObjectAreaQueryEntityData {
}

impl super::entity::GameObjectDataTrait for ObjectAreaQueryEntityData {
}

impl super::core::DataBusPeerTrait for ObjectAreaQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectAreaQueryEntityData {
}

impl super::core::DataContainerTrait for ObjectAreaQueryEntityData {
}

pub static OBJECTAREAQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaQueryEntityData",
    name_hash: 416014374,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ObjectAreaQueryEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectAreaQueryEntityData as Default>::default())),
            create_boxed: || Box::new(<ObjectAreaQueryEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ObjectAreaQueryEntityData, realm),
            },
            FieldInfoData {
                name: "GeometryTransform",
                name_hash: 2190311347,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ObjectAreaQueryEntityData, geometry_transform),
            },
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectAreaQueryEntityData, radius),
            },
        ],
    }),
    array_type: Some(OBJECTAREAQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObjectAreaQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTAREAQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTAREAQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaQueryEntityData-Array",
    name_hash: 1827277970,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ObjectAreaQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AreaQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub enabled: bool,
    pub geometry_transform: super::core::LinearTransform,
    pub use_character_entity: bool,
    pub radius: f32,
    pub use_radius_with_geometry_transform: bool,
    pub query_using_extra_player_in_double_player_event: bool,
    pub only_query_if_on_different_teams: bool,
}

pub trait AreaQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn geometry_transform(&self) -> &super::core::LinearTransform;
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn use_character_entity(&self) -> &bool;
    fn use_character_entity_mut(&mut self) -> &mut bool;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn use_radius_with_geometry_transform(&self) -> &bool;
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool;
    fn query_using_extra_player_in_double_player_event(&self) -> &bool;
    fn query_using_extra_player_in_double_player_event_mut(&mut self) -> &mut bool;
    fn only_query_if_on_different_teams(&self) -> &bool;
    fn only_query_if_on_different_teams_mut(&mut self) -> &mut bool;
}

impl AreaQueryEntityDataTrait for AreaQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn geometry_transform(&self) -> &super::core::LinearTransform {
        &self.geometry_transform
    }
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.geometry_transform
    }
    fn use_character_entity(&self) -> &bool {
        &self.use_character_entity
    }
    fn use_character_entity_mut(&mut self) -> &mut bool {
        &mut self.use_character_entity
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn use_radius_with_geometry_transform(&self) -> &bool {
        &self.use_radius_with_geometry_transform
    }
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool {
        &mut self.use_radius_with_geometry_transform
    }
    fn query_using_extra_player_in_double_player_event(&self) -> &bool {
        &self.query_using_extra_player_in_double_player_event
    }
    fn query_using_extra_player_in_double_player_event_mut(&mut self) -> &mut bool {
        &mut self.query_using_extra_player_in_double_player_event
    }
    fn only_query_if_on_different_teams(&self) -> &bool {
        &self.only_query_if_on_different_teams
    }
    fn only_query_if_on_different_teams_mut(&mut self) -> &mut bool {
        &mut self.only_query_if_on_different_teams
    }
}

impl super::entity::EntityDataTrait for AreaQueryEntityData {
}

impl super::entity::GameObjectDataTrait for AreaQueryEntityData {
}

impl super::core::DataBusPeerTrait for AreaQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AreaQueryEntityData {
}

impl super::core::DataContainerTrait for AreaQueryEntityData {
}

pub static AREAQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaQueryEntityData",
    name_hash: 1240491571,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AreaQueryEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AreaQueryEntityData as Default>::default())),
            create_boxed: || Box::new(<AreaQueryEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AreaQueryEntityData, realm),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, enabled),
            },
            FieldInfoData {
                name: "GeometryTransform",
                name_hash: 2190311347,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AreaQueryEntityData, geometry_transform),
            },
            FieldInfoData {
                name: "UseCharacterEntity",
                name_hash: 3044350724,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, use_character_entity),
            },
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaQueryEntityData, radius),
            },
            FieldInfoData {
                name: "UseRadiusWithGeometryTransform",
                name_hash: 2458636042,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, use_radius_with_geometry_transform),
            },
            FieldInfoData {
                name: "QueryUsingExtraPlayerInDoublePlayerEvent",
                name_hash: 3221783437,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, query_using_extra_player_in_double_player_event),
            },
            FieldInfoData {
                name: "OnlyQueryIfOnDifferentTeams",
                name_hash: 3681407198,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, only_query_if_on_different_teams),
            },
        ],
    }),
    array_type: Some(AREAQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AreaQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AREAQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AREAQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaQueryEntityData-Array",
    name_hash: 1745187207,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AreaProximityEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub auto_start: bool,
    pub update_pass: super::entity::UpdatePass,
    pub proximity_distance: f32,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait AreaProximityEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn update_pass(&self) -> &super::entity::UpdatePass;
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass;
    fn proximity_distance(&self) -> &f32;
    fn proximity_distance_mut(&mut self) -> &mut f32;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl AreaProximityEntityDataTrait for AreaProximityEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn update_pass(&self) -> &super::entity::UpdatePass {
        &self.update_pass
    }
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        &mut self.update_pass
    }
    fn proximity_distance(&self) -> &f32 {
        &self.proximity_distance
    }
    fn proximity_distance_mut(&mut self) -> &mut f32 {
        &mut self.proximity_distance
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for AreaProximityEntityData {
}

impl super::entity::GameObjectDataTrait for AreaProximityEntityData {
}

impl super::core::DataBusPeerTrait for AreaProximityEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AreaProximityEntityData {
}

impl super::core::DataContainerTrait for AreaProximityEntityData {
}

pub static AREAPROXIMITYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaProximityEntityData",
    name_hash: 3756072364,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AreaProximityEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AreaProximityEntityData as Default>::default())),
            create_boxed: || Box::new(<AreaProximityEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AreaProximityEntityData, realm),
            },
            FieldInfoData {
                name: "AutoStart",
                name_hash: 792615882,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaProximityEntityData, auto_start),
            },
            FieldInfoData {
                name: "UpdatePass",
                name_hash: 2270785669,
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(AreaProximityEntityData, update_pass),
            },
            FieldInfoData {
                name: "ProximityDistance",
                name_hash: 3313540371,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaProximityEntityData, proximity_distance),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(AreaProximityEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(AREAPROXIMITYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AreaProximityEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AREAPROXIMITYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AREAPROXIMITYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaProximityEntityData-Array",
    name_hash: 899566872,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaProximityEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct InputRestrictionEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub override_previous_input_restriction: bool,
    pub apply_restrictions_to_specific_player: bool,
    pub disabled_inputs: Vec<i32>,
}

pub trait InputRestrictionEntityDataTrait: super::entity::EntityDataTrait {
    fn override_previous_input_restriction(&self) -> &bool;
    fn override_previous_input_restriction_mut(&mut self) -> &mut bool;
    fn apply_restrictions_to_specific_player(&self) -> &bool;
    fn apply_restrictions_to_specific_player_mut(&mut self) -> &mut bool;
    fn disabled_inputs(&self) -> &Vec<i32>;
    fn disabled_inputs_mut(&mut self) -> &mut Vec<i32>;
}

impl InputRestrictionEntityDataTrait for InputRestrictionEntityData {
    fn override_previous_input_restriction(&self) -> &bool {
        &self.override_previous_input_restriction
    }
    fn override_previous_input_restriction_mut(&mut self) -> &mut bool {
        &mut self.override_previous_input_restriction
    }
    fn apply_restrictions_to_specific_player(&self) -> &bool {
        &self.apply_restrictions_to_specific_player
    }
    fn apply_restrictions_to_specific_player_mut(&mut self) -> &mut bool {
        &mut self.apply_restrictions_to_specific_player
    }
    fn disabled_inputs(&self) -> &Vec<i32> {
        &self.disabled_inputs
    }
    fn disabled_inputs_mut(&mut self) -> &mut Vec<i32> {
        &mut self.disabled_inputs
    }
}

impl super::entity::EntityDataTrait for InputRestrictionEntityData {
}

impl super::entity::GameObjectDataTrait for InputRestrictionEntityData {
}

impl super::core::DataBusPeerTrait for InputRestrictionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for InputRestrictionEntityData {
}

impl super::core::DataContainerTrait for InputRestrictionEntityData {
}

pub static INPUTRESTRICTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRestrictionEntityData",
    name_hash: 2359474860,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(InputRestrictionEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputRestrictionEntityData as Default>::default())),
            create_boxed: || Box::new(<InputRestrictionEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "OverridePreviousInputRestriction",
                name_hash: 2082064290,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputRestrictionEntityData, override_previous_input_restriction),
            },
            FieldInfoData {
                name: "ApplyRestrictionsToSpecificPlayer",
                name_hash: 3694371998,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputRestrictionEntityData, apply_restrictions_to_specific_player),
            },
            FieldInfoData {
                name: "DisabledInputs",
                name_hash: 2589704560,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(InputRestrictionEntityData, disabled_inputs),
            },
        ],
    }),
    array_type: Some(INPUTRESTRICTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputRestrictionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTRESTRICTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INPUTRESTRICTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRestrictionEntityData-Array",
    name_hash: 643934744,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InputRestrictionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventIfSwitchEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub start_state: bool,
    pub run_once: bool,
}

pub trait EventIfSwitchEntityDataTrait: super::entity::EntityDataTrait {
    fn start_state(&self) -> &bool;
    fn start_state_mut(&mut self) -> &mut bool;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
}

impl EventIfSwitchEntityDataTrait for EventIfSwitchEntityData {
    fn start_state(&self) -> &bool {
        &self.start_state
    }
    fn start_state_mut(&mut self) -> &mut bool {
        &mut self.start_state
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
}

impl super::entity::EntityDataTrait for EventIfSwitchEntityData {
}

impl super::entity::GameObjectDataTrait for EventIfSwitchEntityData {
}

impl super::core::DataBusPeerTrait for EventIfSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventIfSwitchEntityData {
}

impl super::core::DataContainerTrait for EventIfSwitchEntityData {
}

pub static EVENTIFSWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventIfSwitchEntityData",
    name_hash: 2518835423,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EventIfSwitchEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventIfSwitchEntityData as Default>::default())),
            create_boxed: || Box::new(<EventIfSwitchEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StartState",
                name_hash: 2753617170,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventIfSwitchEntityData, start_state),
            },
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventIfSwitchEntityData, run_once),
            },
        ],
    }),
    array_type: Some(EVENTIFSWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventIfSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTIFSWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTIFSWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventIfSwitchEntityData-Array",
    name_hash: 2663085547,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventIfSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TeamFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub invert_filter: bool,
    pub team: super::gameplay_sim::TeamId,
    pub generate_event_for_every_matching_team_member: bool,
    pub get_team_from_player_event: bool,
}

pub trait TeamFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn invert_filter(&self) -> &bool;
    fn invert_filter_mut(&mut self) -> &mut bool;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn generate_event_for_every_matching_team_member(&self) -> &bool;
    fn generate_event_for_every_matching_team_member_mut(&mut self) -> &mut bool;
    fn get_team_from_player_event(&self) -> &bool;
    fn get_team_from_player_event_mut(&mut self) -> &mut bool;
}

impl TeamFilterEntityDataTrait for TeamFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn invert_filter(&self) -> &bool {
        &self.invert_filter
    }
    fn invert_filter_mut(&mut self) -> &mut bool {
        &mut self.invert_filter
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn generate_event_for_every_matching_team_member(&self) -> &bool {
        &self.generate_event_for_every_matching_team_member
    }
    fn generate_event_for_every_matching_team_member_mut(&mut self) -> &mut bool {
        &mut self.generate_event_for_every_matching_team_member
    }
    fn get_team_from_player_event(&self) -> &bool {
        &self.get_team_from_player_event
    }
    fn get_team_from_player_event_mut(&mut self) -> &mut bool {
        &mut self.get_team_from_player_event
    }
}

impl super::entity::EntityDataTrait for TeamFilterEntityData {
}

impl super::entity::GameObjectDataTrait for TeamFilterEntityData {
}

impl super::core::DataBusPeerTrait for TeamFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TeamFilterEntityData {
}

impl super::core::DataContainerTrait for TeamFilterEntityData {
}

pub static TEAMFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamFilterEntityData",
    name_hash: 3652334899,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TeamFilterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeamFilterEntityData as Default>::default())),
            create_boxed: || Box::new(<TeamFilterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TeamFilterEntityData, realm),
            },
            FieldInfoData {
                name: "InvertFilter",
                name_hash: 2846947863,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeamFilterEntityData, invert_filter),
            },
            FieldInfoData {
                name: "Team",
                name_hash: 2089309528,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(TeamFilterEntityData, team),
            },
            FieldInfoData {
                name: "GenerateEventForEveryMatchingTeamMember",
                name_hash: 2999321434,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeamFilterEntityData, generate_event_for_every_matching_team_member),
            },
            FieldInfoData {
                name: "GetTeamFromPlayerEvent",
                name_hash: 2165453447,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeamFilterEntityData, get_team_from_player_event),
            },
        ],
    }),
    array_type: Some(TEAMFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TeamFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TEAMFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEAMFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamFilterEntityData-Array",
    name_hash: 1537638535,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeamFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlatformSplitterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub run_once: bool,
    pub realm: super::core::Realm,
}

pub trait PlatformSplitterEntityDataTrait: super::entity::EntityDataTrait {
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl PlatformSplitterEntityDataTrait for PlatformSplitterEntityData {
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for PlatformSplitterEntityData {
}

impl super::entity::GameObjectDataTrait for PlatformSplitterEntityData {
}

impl super::core::DataBusPeerTrait for PlatformSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlatformSplitterEntityData {
}

impl super::core::DataContainerTrait for PlatformSplitterEntityData {
}

pub static PLATFORMSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformSplitterEntityData",
    name_hash: 242265152,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlatformSplitterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlatformSplitterEntityData as Default>::default())),
            create_boxed: || Box::new(<PlatformSplitterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlatformSplitterEntityData, run_once),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlatformSplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(PLATFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlatformSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLATFORMSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLATFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformSplitterEntityData-Array",
    name_hash: 4013130484,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlatformSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventSplitterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub run_once: bool,
    pub realm: super::core::Realm,
}

pub trait EventSplitterEntityDataTrait: super::entity::EntityDataTrait {
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl EventSplitterEntityDataTrait for EventSplitterEntityData {
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for EventSplitterEntityData {
}

impl super::entity::GameObjectDataTrait for EventSplitterEntityData {
}

impl super::core::DataBusPeerTrait for EventSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventSplitterEntityData {
}

impl super::core::DataContainerTrait for EventSplitterEntityData {
}

pub static EVENTSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSplitterEntityData",
    name_hash: 2147764467,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EventSplitterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSplitterEntityData as Default>::default())),
            create_boxed: || Box::new(<EventSplitterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventSplitterEntityData, run_once),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventSplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(EVENTSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSplitterEntityData-Array",
    name_hash: 1315726535,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventMemoryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait EventMemoryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl EventMemoryEntityDataTrait for EventMemoryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for EventMemoryEntityData {
}

impl super::entity::GameObjectDataTrait for EventMemoryEntityData {
}

impl super::core::DataBusPeerTrait for EventMemoryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventMemoryEntityData {
}

impl super::core::DataContainerTrait for EventMemoryEntityData {
}

pub static EVENTMEMORYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventMemoryEntityData",
    name_hash: 1523557091,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EventMemoryEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventMemoryEntityData as Default>::default())),
            create_boxed: || Box::new(<EventMemoryEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventMemoryEntityData, realm),
            },
        ],
    }),
    array_type: Some(EVENTMEMORYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventMemoryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTMEMORYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTMEMORYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventMemoryEntityData-Array",
    name_hash: 4282414807,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventMemoryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpeedEventGateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub min_speed: f32,
    pub max_speed: f32,
}

pub trait SpeedEventGateEntityDataTrait: super::entity::EntityDataTrait {
    fn min_speed(&self) -> &f32;
    fn min_speed_mut(&mut self) -> &mut f32;
    fn max_speed(&self) -> &f32;
    fn max_speed_mut(&mut self) -> &mut f32;
}

impl SpeedEventGateEntityDataTrait for SpeedEventGateEntityData {
    fn min_speed(&self) -> &f32 {
        &self.min_speed
    }
    fn min_speed_mut(&mut self) -> &mut f32 {
        &mut self.min_speed
    }
    fn max_speed(&self) -> &f32 {
        &self.max_speed
    }
    fn max_speed_mut(&mut self) -> &mut f32 {
        &mut self.max_speed
    }
}

impl super::entity::EntityDataTrait for SpeedEventGateEntityData {
}

impl super::entity::GameObjectDataTrait for SpeedEventGateEntityData {
}

impl super::core::DataBusPeerTrait for SpeedEventGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpeedEventGateEntityData {
}

impl super::core::DataContainerTrait for SpeedEventGateEntityData {
}

pub static SPEEDEVENTGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpeedEventGateEntityData",
    name_hash: 154966642,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SpeedEventGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpeedEventGateEntityData as Default>::default())),
            create_boxed: || Box::new(<SpeedEventGateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MinSpeed",
                name_hash: 3368183944,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeedEventGateEntityData, min_speed),
            },
            FieldInfoData {
                name: "MaxSpeed",
                name_hash: 396228950,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeedEventGateEntityData, max_speed),
            },
        ],
    }),
    array_type: Some(SPEEDEVENTGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpeedEventGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPEEDEVENTGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPEEDEVENTGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpeedEventGateEntityData-Array",
    name_hash: 2769310022,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SpeedEventGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventCompareGateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub value: i32,
    pub compare_type: EventCompareGateType,
    pub realm: super::core::Realm,
}

pub trait EventCompareGateEntityDataTrait: super::entity::EntityDataTrait {
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
    fn compare_type(&self) -> &EventCompareGateType;
    fn compare_type_mut(&mut self) -> &mut EventCompareGateType;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl EventCompareGateEntityDataTrait for EventCompareGateEntityData {
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
    fn compare_type(&self) -> &EventCompareGateType {
        &self.compare_type
    }
    fn compare_type_mut(&mut self) -> &mut EventCompareGateType {
        &mut self.compare_type
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for EventCompareGateEntityData {
}

impl super::entity::GameObjectDataTrait for EventCompareGateEntityData {
}

impl super::core::DataBusPeerTrait for EventCompareGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventCompareGateEntityData {
}

impl super::core::DataContainerTrait for EventCompareGateEntityData {
}

pub static EVENTCOMPAREGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventCompareGateEntityData",
    name_hash: 3551779666,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EventCompareGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventCompareGateEntityData as Default>::default())),
            create_boxed: || Box::new(<EventCompareGateEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EventCompareGateEntityData, value),
            },
            FieldInfoData {
                name: "CompareType",
                name_hash: 1481809914,
                flags: MemberInfoFlags::new(0),
                field_type: "EventCompareGateType",
                rust_offset: offset_of!(EventCompareGateEntityData, compare_type),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventCompareGateEntityData, realm),
            },
        ],
    }),
    array_type: Some(EVENTCOMPAREGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventCompareGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCOMPAREGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTCOMPAREGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventCompareGateEntityData-Array",
    name_hash: 3047764710,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventCompareGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EventCompareGateType {
    #[default]
    EventCompareGate_Equals = 0,
    EventCompareGate_NotEquals = 1,
    EventCompareGate_Less = 2,
    EventCompareGate_LessEquals = 3,
    EventCompareGate_Greater = 4,
    EventCompareGate_GreaterEquals = 5,
}

pub static EVENTCOMPAREGATETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventCompareGateType",
    name_hash: 3714752065,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(EVENTCOMPAREGATETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EventCompareGateType {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCOMPAREGATETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTCOMPAREGATETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventCompareGateType-Array",
    name_hash: 2359150709,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventCompareGateType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SaveGameLoadedEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait SaveGameLoadedEntityDataTrait: super::entity::EntityDataTrait {
}

impl SaveGameLoadedEntityDataTrait for SaveGameLoadedEntityData {
}

impl super::entity::EntityDataTrait for SaveGameLoadedEntityData {
}

impl super::entity::GameObjectDataTrait for SaveGameLoadedEntityData {
}

impl super::core::DataBusPeerTrait for SaveGameLoadedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SaveGameLoadedEntityData {
}

impl super::core::DataContainerTrait for SaveGameLoadedEntityData {
}

pub static SAVEGAMELOADEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SaveGameLoadedEntityData",
    name_hash: 3169536678,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SaveGameLoadedEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SaveGameLoadedEntityData as Default>::default())),
            create_boxed: || Box::new(<SaveGameLoadedEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SAVEGAMELOADEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SaveGameLoadedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SAVEGAMELOADEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SAVEGAMELOADEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SaveGameLoadedEntityData-Array",
    name_hash: 2257540882,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SaveGameLoadedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SaveEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub save_screen_texture: Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>,
    pub level_name: String,
    pub save_file_name: String,
    pub save_name_s_i_d: String,
    pub check_for_human_player: bool,
}

pub trait SaveEntityDataTrait: super::entity::EntityDataTrait {
    fn save_screen_texture(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
    fn save_screen_texture_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
    fn level_name(&self) -> &String;
    fn level_name_mut(&mut self) -> &mut String;
    fn save_file_name(&self) -> &String;
    fn save_file_name_mut(&mut self) -> &mut String;
    fn save_name_s_i_d(&self) -> &String;
    fn save_name_s_i_d_mut(&mut self) -> &mut String;
    fn check_for_human_player(&self) -> &bool;
    fn check_for_human_player_mut(&mut self) -> &mut bool;
}

impl SaveEntityDataTrait for SaveEntityData {
    fn save_screen_texture(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &self.save_screen_texture
    }
    fn save_screen_texture_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &mut self.save_screen_texture
    }
    fn level_name(&self) -> &String {
        &self.level_name
    }
    fn level_name_mut(&mut self) -> &mut String {
        &mut self.level_name
    }
    fn save_file_name(&self) -> &String {
        &self.save_file_name
    }
    fn save_file_name_mut(&mut self) -> &mut String {
        &mut self.save_file_name
    }
    fn save_name_s_i_d(&self) -> &String {
        &self.save_name_s_i_d
    }
    fn save_name_s_i_d_mut(&mut self) -> &mut String {
        &mut self.save_name_s_i_d
    }
    fn check_for_human_player(&self) -> &bool {
        &self.check_for_human_player
    }
    fn check_for_human_player_mut(&mut self) -> &mut bool {
        &mut self.check_for_human_player
    }
}

impl super::entity::EntityDataTrait for SaveEntityData {
}

impl super::entity::GameObjectDataTrait for SaveEntityData {
}

impl super::core::DataBusPeerTrait for SaveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SaveEntityData {
}

impl super::core::DataContainerTrait for SaveEntityData {
}

pub static SAVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SaveEntityData",
    name_hash: 2691457007,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SaveEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SaveEntityData as Default>::default())),
            create_boxed: || Box::new(<SaveEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SaveScreenTexture",
                name_hash: 1992725143,
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SaveEntityData, save_screen_texture),
            },
            FieldInfoData {
                name: "LevelName",
                name_hash: 1599082292,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SaveEntityData, level_name),
            },
            FieldInfoData {
                name: "SaveFileName",
                name_hash: 1526449829,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SaveEntityData, save_file_name),
            },
            FieldInfoData {
                name: "SaveNameSID",
                name_hash: 1206536541,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SaveEntityData, save_name_s_i_d),
            },
            FieldInfoData {
                name: "CheckForHumanPlayer",
                name_hash: 2331597556,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SaveEntityData, check_for_human_player),
            },
        ],
    }),
    array_type: Some(SAVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SaveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SAVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SAVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SaveEntityData-Array",
    name_hash: 745930203,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SaveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StartEntityData {
    pub _glacier_base: StartPointEntityData,
}

pub trait StartEntityDataTrait: StartPointEntityDataTrait {
}

impl StartEntityDataTrait for StartEntityData {
}

impl StartPointEntityDataTrait for StartEntityData {
    fn start_name(&self) -> &String {
        self._glacier_base.start_name()
    }
    fn start_name_mut(&mut self) -> &mut String {
        self._glacier_base.start_name_mut()
    }
}

impl super::entity::EntityDataTrait for StartEntityData {
}

impl super::entity::GameObjectDataTrait for StartEntityData {
}

impl super::core::DataBusPeerTrait for StartEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StartEntityData {
}

impl super::core::DataContainerTrait for StartEntityData {
}

pub static STARTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartEntityData",
    name_hash: 3062859342,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(STARTPOINTENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(StartEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StartEntityData as Default>::default())),
            create_boxed: || Box::new(<StartEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(STARTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StartEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STARTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STARTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartEntityData-Array",
    name_hash: 3414515706,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StartEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StartPointEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub start_name: String,
}

pub trait StartPointEntityDataTrait: super::entity::EntityDataTrait {
    fn start_name(&self) -> &String;
    fn start_name_mut(&mut self) -> &mut String;
}

impl StartPointEntityDataTrait for StartPointEntityData {
    fn start_name(&self) -> &String {
        &self.start_name
    }
    fn start_name_mut(&mut self) -> &mut String {
        &mut self.start_name
    }
}

impl super::entity::EntityDataTrait for StartPointEntityData {
}

impl super::entity::GameObjectDataTrait for StartPointEntityData {
}

impl super::core::DataBusPeerTrait for StartPointEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StartPointEntityData {
}

impl super::core::DataContainerTrait for StartPointEntityData {
}

pub static STARTPOINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartPointEntityData",
    name_hash: 3673861314,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(StartPointEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StartPointEntityData as Default>::default())),
            create_boxed: || Box::new(<StartPointEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StartName",
                name_hash: 3727215458,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(StartPointEntityData, start_name),
            },
        ],
    }),
    array_type: Some(STARTPOINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StartPointEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STARTPOINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STARTPOINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartPointEntityData-Array",
    name_hash: 2459196534,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StartPointEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ServerStartPointLoadedFromDSubLevelMessage {
}

pub trait ServerStartPointLoadedFromDSubLevelMessageTrait: TypeObject {
}

impl ServerStartPointLoadedFromDSubLevelMessageTrait for ServerStartPointLoadedFromDSubLevelMessage {
}

pub static SERVERSTARTPOINTLOADEDFROMDSUBLEVELMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerStartPointLoadedFromDSubLevelMessage",
    name_hash: 3038602080,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerStartPointLoadedFromDSubLevelMessage as Default>::default())),
            create_boxed: || Box::new(<ServerStartPointLoadedFromDSubLevelMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ServerStartPointLoadedFromDSubLevelMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERSTARTPOINTLOADEDFROMDSUBLEVELMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct MapMarkerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub sid: String,
    pub name_letter: String,
    pub nr_of_passengers: i32,
    pub nr_of_entries: i32,
    pub is_visible: bool,
    pub show_radius: f32,
    pub hide_radius: f32,
    pub blink_time: f32,
    pub marker_type: MapMarkerType,
    pub visible_for_team: super::gameplay_sim::TeamId,
    pub owner_team: super::gameplay_sim::TeamId,
    pub hud_icon: UIHudIcon,
    pub icon_name: String,
    pub icon_behavior: Option<LockedTypeObject /* UIWorldIconBehavior */>,
    pub vertical_offset: f32,
    pub show_air_target_box: bool,
    pub is_focus_point: bool,
    pub focus_point_radius: f32,
    pub focus_priority: i32,
    pub snap: bool,
    pub only_show_snapped: bool,
    pub use_marker_transform: bool,
    pub server_controlled_position: bool,
    pub position_static: bool,
    pub enabled: bool,
    pub show_distance_in_text: bool,
    pub progress_time: f32,
    pub progress: f32,
    pub tracked_players_in_range: u32,
    pub show_progress: bool,
    pub tracking_player_range: f32,
    pub instant_flag_return_radius: f32,
    pub progress_player_speed_up_percentage: f32,
    pub base_transform: super::core::Vec3,
    pub progress_time1_player: f32,
    pub progress_min_time: f32,
    pub visual_transform: super::core::LinearTransform,
}

pub trait MapMarkerEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn sid(&self) -> &String;
    fn sid_mut(&mut self) -> &mut String;
    fn name_letter(&self) -> &String;
    fn name_letter_mut(&mut self) -> &mut String;
    fn nr_of_passengers(&self) -> &i32;
    fn nr_of_passengers_mut(&mut self) -> &mut i32;
    fn nr_of_entries(&self) -> &i32;
    fn nr_of_entries_mut(&mut self) -> &mut i32;
    fn is_visible(&self) -> &bool;
    fn is_visible_mut(&mut self) -> &mut bool;
    fn show_radius(&self) -> &f32;
    fn show_radius_mut(&mut self) -> &mut f32;
    fn hide_radius(&self) -> &f32;
    fn hide_radius_mut(&mut self) -> &mut f32;
    fn blink_time(&self) -> &f32;
    fn blink_time_mut(&mut self) -> &mut f32;
    fn marker_type(&self) -> &MapMarkerType;
    fn marker_type_mut(&mut self) -> &mut MapMarkerType;
    fn visible_for_team(&self) -> &super::gameplay_sim::TeamId;
    fn visible_for_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn owner_team(&self) -> &super::gameplay_sim::TeamId;
    fn owner_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn hud_icon(&self) -> &UIHudIcon;
    fn hud_icon_mut(&mut self) -> &mut UIHudIcon;
    fn icon_name(&self) -> &String;
    fn icon_name_mut(&mut self) -> &mut String;
    fn icon_behavior(&self) -> &Option<LockedTypeObject /* UIWorldIconBehavior */>;
    fn icon_behavior_mut(&mut self) -> &mut Option<LockedTypeObject /* UIWorldIconBehavior */>;
    fn vertical_offset(&self) -> &f32;
    fn vertical_offset_mut(&mut self) -> &mut f32;
    fn show_air_target_box(&self) -> &bool;
    fn show_air_target_box_mut(&mut self) -> &mut bool;
    fn is_focus_point(&self) -> &bool;
    fn is_focus_point_mut(&mut self) -> &mut bool;
    fn focus_point_radius(&self) -> &f32;
    fn focus_point_radius_mut(&mut self) -> &mut f32;
    fn focus_priority(&self) -> &i32;
    fn focus_priority_mut(&mut self) -> &mut i32;
    fn snap(&self) -> &bool;
    fn snap_mut(&mut self) -> &mut bool;
    fn only_show_snapped(&self) -> &bool;
    fn only_show_snapped_mut(&mut self) -> &mut bool;
    fn use_marker_transform(&self) -> &bool;
    fn use_marker_transform_mut(&mut self) -> &mut bool;
    fn server_controlled_position(&self) -> &bool;
    fn server_controlled_position_mut(&mut self) -> &mut bool;
    fn position_static(&self) -> &bool;
    fn position_static_mut(&mut self) -> &mut bool;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn show_distance_in_text(&self) -> &bool;
    fn show_distance_in_text_mut(&mut self) -> &mut bool;
    fn progress_time(&self) -> &f32;
    fn progress_time_mut(&mut self) -> &mut f32;
    fn progress(&self) -> &f32;
    fn progress_mut(&mut self) -> &mut f32;
    fn tracked_players_in_range(&self) -> &u32;
    fn tracked_players_in_range_mut(&mut self) -> &mut u32;
    fn show_progress(&self) -> &bool;
    fn show_progress_mut(&mut self) -> &mut bool;
    fn tracking_player_range(&self) -> &f32;
    fn tracking_player_range_mut(&mut self) -> &mut f32;
    fn instant_flag_return_radius(&self) -> &f32;
    fn instant_flag_return_radius_mut(&mut self) -> &mut f32;
    fn progress_player_speed_up_percentage(&self) -> &f32;
    fn progress_player_speed_up_percentage_mut(&mut self) -> &mut f32;
    fn base_transform(&self) -> &super::core::Vec3;
    fn base_transform_mut(&mut self) -> &mut super::core::Vec3;
    fn progress_time1_player(&self) -> &f32;
    fn progress_time1_player_mut(&mut self) -> &mut f32;
    fn progress_min_time(&self) -> &f32;
    fn progress_min_time_mut(&mut self) -> &mut f32;
    fn visual_transform(&self) -> &super::core::LinearTransform;
    fn visual_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl MapMarkerEntityDataTrait for MapMarkerEntityData {
    fn sid(&self) -> &String {
        &self.sid
    }
    fn sid_mut(&mut self) -> &mut String {
        &mut self.sid
    }
    fn name_letter(&self) -> &String {
        &self.name_letter
    }
    fn name_letter_mut(&mut self) -> &mut String {
        &mut self.name_letter
    }
    fn nr_of_passengers(&self) -> &i32 {
        &self.nr_of_passengers
    }
    fn nr_of_passengers_mut(&mut self) -> &mut i32 {
        &mut self.nr_of_passengers
    }
    fn nr_of_entries(&self) -> &i32 {
        &self.nr_of_entries
    }
    fn nr_of_entries_mut(&mut self) -> &mut i32 {
        &mut self.nr_of_entries
    }
    fn is_visible(&self) -> &bool {
        &self.is_visible
    }
    fn is_visible_mut(&mut self) -> &mut bool {
        &mut self.is_visible
    }
    fn show_radius(&self) -> &f32 {
        &self.show_radius
    }
    fn show_radius_mut(&mut self) -> &mut f32 {
        &mut self.show_radius
    }
    fn hide_radius(&self) -> &f32 {
        &self.hide_radius
    }
    fn hide_radius_mut(&mut self) -> &mut f32 {
        &mut self.hide_radius
    }
    fn blink_time(&self) -> &f32 {
        &self.blink_time
    }
    fn blink_time_mut(&mut self) -> &mut f32 {
        &mut self.blink_time
    }
    fn marker_type(&self) -> &MapMarkerType {
        &self.marker_type
    }
    fn marker_type_mut(&mut self) -> &mut MapMarkerType {
        &mut self.marker_type
    }
    fn visible_for_team(&self) -> &super::gameplay_sim::TeamId {
        &self.visible_for_team
    }
    fn visible_for_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.visible_for_team
    }
    fn owner_team(&self) -> &super::gameplay_sim::TeamId {
        &self.owner_team
    }
    fn owner_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.owner_team
    }
    fn hud_icon(&self) -> &UIHudIcon {
        &self.hud_icon
    }
    fn hud_icon_mut(&mut self) -> &mut UIHudIcon {
        &mut self.hud_icon
    }
    fn icon_name(&self) -> &String {
        &self.icon_name
    }
    fn icon_name_mut(&mut self) -> &mut String {
        &mut self.icon_name
    }
    fn icon_behavior(&self) -> &Option<LockedTypeObject /* UIWorldIconBehavior */> {
        &self.icon_behavior
    }
    fn icon_behavior_mut(&mut self) -> &mut Option<LockedTypeObject /* UIWorldIconBehavior */> {
        &mut self.icon_behavior
    }
    fn vertical_offset(&self) -> &f32 {
        &self.vertical_offset
    }
    fn vertical_offset_mut(&mut self) -> &mut f32 {
        &mut self.vertical_offset
    }
    fn show_air_target_box(&self) -> &bool {
        &self.show_air_target_box
    }
    fn show_air_target_box_mut(&mut self) -> &mut bool {
        &mut self.show_air_target_box
    }
    fn is_focus_point(&self) -> &bool {
        &self.is_focus_point
    }
    fn is_focus_point_mut(&mut self) -> &mut bool {
        &mut self.is_focus_point
    }
    fn focus_point_radius(&self) -> &f32 {
        &self.focus_point_radius
    }
    fn focus_point_radius_mut(&mut self) -> &mut f32 {
        &mut self.focus_point_radius
    }
    fn focus_priority(&self) -> &i32 {
        &self.focus_priority
    }
    fn focus_priority_mut(&mut self) -> &mut i32 {
        &mut self.focus_priority
    }
    fn snap(&self) -> &bool {
        &self.snap
    }
    fn snap_mut(&mut self) -> &mut bool {
        &mut self.snap
    }
    fn only_show_snapped(&self) -> &bool {
        &self.only_show_snapped
    }
    fn only_show_snapped_mut(&mut self) -> &mut bool {
        &mut self.only_show_snapped
    }
    fn use_marker_transform(&self) -> &bool {
        &self.use_marker_transform
    }
    fn use_marker_transform_mut(&mut self) -> &mut bool {
        &mut self.use_marker_transform
    }
    fn server_controlled_position(&self) -> &bool {
        &self.server_controlled_position
    }
    fn server_controlled_position_mut(&mut self) -> &mut bool {
        &mut self.server_controlled_position
    }
    fn position_static(&self) -> &bool {
        &self.position_static
    }
    fn position_static_mut(&mut self) -> &mut bool {
        &mut self.position_static
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn show_distance_in_text(&self) -> &bool {
        &self.show_distance_in_text
    }
    fn show_distance_in_text_mut(&mut self) -> &mut bool {
        &mut self.show_distance_in_text
    }
    fn progress_time(&self) -> &f32 {
        &self.progress_time
    }
    fn progress_time_mut(&mut self) -> &mut f32 {
        &mut self.progress_time
    }
    fn progress(&self) -> &f32 {
        &self.progress
    }
    fn progress_mut(&mut self) -> &mut f32 {
        &mut self.progress
    }
    fn tracked_players_in_range(&self) -> &u32 {
        &self.tracked_players_in_range
    }
    fn tracked_players_in_range_mut(&mut self) -> &mut u32 {
        &mut self.tracked_players_in_range
    }
    fn show_progress(&self) -> &bool {
        &self.show_progress
    }
    fn show_progress_mut(&mut self) -> &mut bool {
        &mut self.show_progress
    }
    fn tracking_player_range(&self) -> &f32 {
        &self.tracking_player_range
    }
    fn tracking_player_range_mut(&mut self) -> &mut f32 {
        &mut self.tracking_player_range
    }
    fn instant_flag_return_radius(&self) -> &f32 {
        &self.instant_flag_return_radius
    }
    fn instant_flag_return_radius_mut(&mut self) -> &mut f32 {
        &mut self.instant_flag_return_radius
    }
    fn progress_player_speed_up_percentage(&self) -> &f32 {
        &self.progress_player_speed_up_percentage
    }
    fn progress_player_speed_up_percentage_mut(&mut self) -> &mut f32 {
        &mut self.progress_player_speed_up_percentage
    }
    fn base_transform(&self) -> &super::core::Vec3 {
        &self.base_transform
    }
    fn base_transform_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.base_transform
    }
    fn progress_time1_player(&self) -> &f32 {
        &self.progress_time1_player
    }
    fn progress_time1_player_mut(&mut self) -> &mut f32 {
        &mut self.progress_time1_player
    }
    fn progress_min_time(&self) -> &f32 {
        &self.progress_min_time
    }
    fn progress_min_time_mut(&mut self) -> &mut f32 {
        &mut self.progress_min_time
    }
    fn visual_transform(&self) -> &super::core::LinearTransform {
        &self.visual_transform
    }
    fn visual_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.visual_transform
    }
}

impl super::entity::SpatialEntityDataTrait for MapMarkerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for MapMarkerEntityData {
}

impl super::entity::GameObjectDataTrait for MapMarkerEntityData {
}

impl super::core::DataBusPeerTrait for MapMarkerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MapMarkerEntityData {
}

impl super::core::DataContainerTrait for MapMarkerEntityData {
}

pub static MAPMARKERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerEntityData",
    name_hash: 1607346192,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(MapMarkerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MapMarkerEntityData as Default>::default())),
            create_boxed: || Box::new(<MapMarkerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Sid",
                name_hash: 193466587,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MapMarkerEntityData, sid),
            },
            FieldInfoData {
                name: "NameLetter",
                name_hash: 349234012,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MapMarkerEntityData, name_letter),
            },
            FieldInfoData {
                name: "NrOfPassengers",
                name_hash: 1911822697,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MapMarkerEntityData, nr_of_passengers),
            },
            FieldInfoData {
                name: "NrOfEntries",
                name_hash: 909117378,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MapMarkerEntityData, nr_of_entries),
            },
            FieldInfoData {
                name: "IsVisible",
                name_hash: 4174428017,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, is_visible),
            },
            FieldInfoData {
                name: "ShowRadius",
                name_hash: 2284771454,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, show_radius),
            },
            FieldInfoData {
                name: "HideRadius",
                name_hash: 3315533693,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, hide_radius),
            },
            FieldInfoData {
                name: "BlinkTime",
                name_hash: 2878244914,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, blink_time),
            },
            FieldInfoData {
                name: "MarkerType",
                name_hash: 1033168991,
                flags: MemberInfoFlags::new(0),
                field_type: "MapMarkerType",
                rust_offset: offset_of!(MapMarkerEntityData, marker_type),
            },
            FieldInfoData {
                name: "VisibleForTeam",
                name_hash: 2554745645,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(MapMarkerEntityData, visible_for_team),
            },
            FieldInfoData {
                name: "OwnerTeam",
                name_hash: 2899763897,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(MapMarkerEntityData, owner_team),
            },
            FieldInfoData {
                name: "HudIcon",
                name_hash: 2639628855,
                flags: MemberInfoFlags::new(0),
                field_type: "UIHudIcon",
                rust_offset: offset_of!(MapMarkerEntityData, hud_icon),
            },
            FieldInfoData {
                name: "IconName",
                name_hash: 268503081,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MapMarkerEntityData, icon_name),
            },
            FieldInfoData {
                name: "IconBehavior",
                name_hash: 1793420834,
                flags: MemberInfoFlags::new(0),
                field_type: "UIWorldIconBehavior",
                rust_offset: offset_of!(MapMarkerEntityData, icon_behavior),
            },
            FieldInfoData {
                name: "VerticalOffset",
                name_hash: 2125919898,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, vertical_offset),
            },
            FieldInfoData {
                name: "ShowAirTargetBox",
                name_hash: 3649779096,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, show_air_target_box),
            },
            FieldInfoData {
                name: "IsFocusPoint",
                name_hash: 1984844159,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, is_focus_point),
            },
            FieldInfoData {
                name: "FocusPointRadius",
                name_hash: 3886659069,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, focus_point_radius),
            },
            FieldInfoData {
                name: "FocusPriority",
                name_hash: 3868773371,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MapMarkerEntityData, focus_priority),
            },
            FieldInfoData {
                name: "Snap",
                name_hash: 2089420457,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, snap),
            },
            FieldInfoData {
                name: "OnlyShowSnapped",
                name_hash: 1611417039,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, only_show_snapped),
            },
            FieldInfoData {
                name: "UseMarkerTransform",
                name_hash: 163061160,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, use_marker_transform),
            },
            FieldInfoData {
                name: "ServerControlledPosition",
                name_hash: 665139443,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, server_controlled_position),
            },
            FieldInfoData {
                name: "PositionStatic",
                name_hash: 3752266852,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, position_static),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, enabled),
            },
            FieldInfoData {
                name: "ShowDistanceInText",
                name_hash: 124481567,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, show_distance_in_text),
            },
            FieldInfoData {
                name: "ProgressTime",
                name_hash: 1938365101,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress_time),
            },
            FieldInfoData {
                name: "Progress",
                name_hash: 3002510520,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress),
            },
            FieldInfoData {
                name: "TrackedPlayersInRange",
                name_hash: 1098650803,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MapMarkerEntityData, tracked_players_in_range),
            },
            FieldInfoData {
                name: "ShowProgress",
                name_hash: 2139033243,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, show_progress),
            },
            FieldInfoData {
                name: "TrackingPlayerRange",
                name_hash: 1572595814,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, tracking_player_range),
            },
            FieldInfoData {
                name: "InstantFlagReturnRadius",
                name_hash: 1381394048,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, instant_flag_return_radius),
            },
            FieldInfoData {
                name: "ProgressPlayerSpeedUpPercentage",
                name_hash: 2861738545,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress_player_speed_up_percentage),
            },
            FieldInfoData {
                name: "BaseTransform",
                name_hash: 2733408796,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(MapMarkerEntityData, base_transform),
            },
            FieldInfoData {
                name: "ProgressTime1Player",
                name_hash: 3224499087,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress_time1_player),
            },
            FieldInfoData {
                name: "ProgressMinTime",
                name_hash: 1288296263,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress_min_time),
            },
            FieldInfoData {
                name: "VisualTransform",
                name_hash: 772400029,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(MapMarkerEntityData, visual_transform),
            },
        ],
    }),
    array_type: Some(MAPMARKERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MapMarkerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MAPMARKERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MAPMARKERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerEntityData-Array",
    name_hash: 3489502756,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MapMarkerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MapMarkerColorType {
    #[default]
    MMCTRed = 0,
    MMCTBlue = 1,
    MMCTGreen = 2,
}

pub static MAPMARKERCOLORTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerColorType",
    name_hash: 1691668030,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MAPMARKERCOLORTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MapMarkerColorType {
    fn type_info(&self) -> &'static TypeInfo {
        MAPMARKERCOLORTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MAPMARKERCOLORTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerColorType-Array",
    name_hash: 1434427018,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MapMarkerColorType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MapMarkerType {
    #[default]
    MMTMissionObjective = 0,
    MMTSecondaryMissionObjective = 1,
    MMTSoldier = 2,
    MMTVehicle = 3,
    MMTAmmoCrate = 4,
    MMTGeneric = 5,
    MMTFlag = 6,
    MMTTactical = 7,
    MMTWarning = 8,
}

pub static MAPMARKERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerType",
    name_hash: 4139058947,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MAPMARKERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MapMarkerType {
    fn type_info(&self) -> &'static TypeInfo {
        MAPMARKERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MAPMARKERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerType-Array",
    name_hash: 4240456119,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MapMarkerType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MessageEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub message_info: Option<LockedTypeObject /* MessageEntityInfo */>,
    pub enabled: bool,
}

pub trait MessageEntityDataTrait: super::entity::EntityDataTrait {
    fn message_info(&self) -> &Option<LockedTypeObject /* MessageEntityInfo */>;
    fn message_info_mut(&mut self) -> &mut Option<LockedTypeObject /* MessageEntityInfo */>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl MessageEntityDataTrait for MessageEntityData {
    fn message_info(&self) -> &Option<LockedTypeObject /* MessageEntityInfo */> {
        &self.message_info
    }
    fn message_info_mut(&mut self) -> &mut Option<LockedTypeObject /* MessageEntityInfo */> {
        &mut self.message_info
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for MessageEntityData {
}

impl super::entity::GameObjectDataTrait for MessageEntityData {
}

impl super::core::DataBusPeerTrait for MessageEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MessageEntityData {
}

impl super::core::DataContainerTrait for MessageEntityData {
}

pub static MESSAGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageEntityData",
    name_hash: 2887846373,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(MessageEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MessageEntityData as Default>::default())),
            create_boxed: || Box::new(<MessageEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MessageInfo",
                name_hash: 1055570368,
                flags: MemberInfoFlags::new(0),
                field_type: "MessageEntityInfo",
                rust_offset: offset_of!(MessageEntityData, message_info),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MessageEntityData, enabled),
            },
        ],
    }),
    array_type: Some(MESSAGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MessageEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MESSAGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESSAGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageEntityData-Array",
    name_hash: 2136380113,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MessageEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MessageEntityInfo {
    pub _glacier_base: super::core::DataContainer,
}

pub trait MessageEntityInfoTrait: super::core::DataContainerTrait {
}

impl MessageEntityInfoTrait for MessageEntityInfo {
}

impl super::core::DataContainerTrait for MessageEntityInfo {
}

pub static MESSAGEENTITYINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageEntityInfo",
    name_hash: 2888025307,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(MessageEntityInfo, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MessageEntityInfo as Default>::default())),
            create_boxed: || Box::new(<MessageEntityInfo as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(MESSAGEENTITYINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MessageEntityInfo {
    fn type_info(&self) -> &'static TypeInfo {
        MESSAGEENTITYINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESSAGEENTITYINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageEntityInfo-Array",
    name_hash: 267922415,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MessageEntityInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TacticalObjectiveEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub mission_sid: String,
    pub briefing_sid_team1: String,
    pub briefing_sid_team2: String,
    pub team1_timer: f32,
    pub team2_timer: f32,
}

pub trait TacticalObjectiveEntityDataTrait: super::entity::EntityDataTrait {
    fn mission_sid(&self) -> &String;
    fn mission_sid_mut(&mut self) -> &mut String;
    fn briefing_sid_team1(&self) -> &String;
    fn briefing_sid_team1_mut(&mut self) -> &mut String;
    fn briefing_sid_team2(&self) -> &String;
    fn briefing_sid_team2_mut(&mut self) -> &mut String;
    fn team1_timer(&self) -> &f32;
    fn team1_timer_mut(&mut self) -> &mut f32;
    fn team2_timer(&self) -> &f32;
    fn team2_timer_mut(&mut self) -> &mut f32;
}

impl TacticalObjectiveEntityDataTrait for TacticalObjectiveEntityData {
    fn mission_sid(&self) -> &String {
        &self.mission_sid
    }
    fn mission_sid_mut(&mut self) -> &mut String {
        &mut self.mission_sid
    }
    fn briefing_sid_team1(&self) -> &String {
        &self.briefing_sid_team1
    }
    fn briefing_sid_team1_mut(&mut self) -> &mut String {
        &mut self.briefing_sid_team1
    }
    fn briefing_sid_team2(&self) -> &String {
        &self.briefing_sid_team2
    }
    fn briefing_sid_team2_mut(&mut self) -> &mut String {
        &mut self.briefing_sid_team2
    }
    fn team1_timer(&self) -> &f32 {
        &self.team1_timer
    }
    fn team1_timer_mut(&mut self) -> &mut f32 {
        &mut self.team1_timer
    }
    fn team2_timer(&self) -> &f32 {
        &self.team2_timer
    }
    fn team2_timer_mut(&mut self) -> &mut f32 {
        &mut self.team2_timer
    }
}

impl super::entity::EntityDataTrait for TacticalObjectiveEntityData {
}

impl super::entity::GameObjectDataTrait for TacticalObjectiveEntityData {
}

impl super::core::DataBusPeerTrait for TacticalObjectiveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TacticalObjectiveEntityData {
}

impl super::core::DataContainerTrait for TacticalObjectiveEntityData {
}

pub static TACTICALOBJECTIVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TacticalObjectiveEntityData",
    name_hash: 1601926212,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TacticalObjectiveEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TacticalObjectiveEntityData as Default>::default())),
            create_boxed: || Box::new(<TacticalObjectiveEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MissionSid",
                name_hash: 1231602263,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TacticalObjectiveEntityData, mission_sid),
            },
            FieldInfoData {
                name: "BriefingSidTeam1",
                name_hash: 3340727469,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TacticalObjectiveEntityData, briefing_sid_team1),
            },
            FieldInfoData {
                name: "BriefingSidTeam2",
                name_hash: 3340727470,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TacticalObjectiveEntityData, briefing_sid_team2),
            },
            FieldInfoData {
                name: "Team1Timer",
                name_hash: 2082003598,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TacticalObjectiveEntityData, team1_timer),
            },
            FieldInfoData {
                name: "Team2Timer",
                name_hash: 2125739053,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TacticalObjectiveEntityData, team2_timer),
            },
        ],
    }),
    array_type: Some(TACTICALOBJECTIVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TacticalObjectiveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TACTICALOBJECTIVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TACTICALOBJECTIVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TacticalObjectiveEntityData-Array",
    name_hash: 7600368,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TacticalObjectiveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LevelControlEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub level_to_load: String,
    pub inclusion_options: String,
    pub start_point: String,
    pub roll_credits: bool,
    pub do_persistent_save: bool,
    pub check_single_player_level_installed: bool,
    pub force_reload_resources: bool,
    pub level_manager_initial_level: String,
}

pub trait LevelControlEntityDataTrait: super::entity::EntityDataTrait {
    fn level_to_load(&self) -> &String;
    fn level_to_load_mut(&mut self) -> &mut String;
    fn inclusion_options(&self) -> &String;
    fn inclusion_options_mut(&mut self) -> &mut String;
    fn start_point(&self) -> &String;
    fn start_point_mut(&mut self) -> &mut String;
    fn roll_credits(&self) -> &bool;
    fn roll_credits_mut(&mut self) -> &mut bool;
    fn do_persistent_save(&self) -> &bool;
    fn do_persistent_save_mut(&mut self) -> &mut bool;
    fn check_single_player_level_installed(&self) -> &bool;
    fn check_single_player_level_installed_mut(&mut self) -> &mut bool;
    fn force_reload_resources(&self) -> &bool;
    fn force_reload_resources_mut(&mut self) -> &mut bool;
    fn level_manager_initial_level(&self) -> &String;
    fn level_manager_initial_level_mut(&mut self) -> &mut String;
}

impl LevelControlEntityDataTrait for LevelControlEntityData {
    fn level_to_load(&self) -> &String {
        &self.level_to_load
    }
    fn level_to_load_mut(&mut self) -> &mut String {
        &mut self.level_to_load
    }
    fn inclusion_options(&self) -> &String {
        &self.inclusion_options
    }
    fn inclusion_options_mut(&mut self) -> &mut String {
        &mut self.inclusion_options
    }
    fn start_point(&self) -> &String {
        &self.start_point
    }
    fn start_point_mut(&mut self) -> &mut String {
        &mut self.start_point
    }
    fn roll_credits(&self) -> &bool {
        &self.roll_credits
    }
    fn roll_credits_mut(&mut self) -> &mut bool {
        &mut self.roll_credits
    }
    fn do_persistent_save(&self) -> &bool {
        &self.do_persistent_save
    }
    fn do_persistent_save_mut(&mut self) -> &mut bool {
        &mut self.do_persistent_save
    }
    fn check_single_player_level_installed(&self) -> &bool {
        &self.check_single_player_level_installed
    }
    fn check_single_player_level_installed_mut(&mut self) -> &mut bool {
        &mut self.check_single_player_level_installed
    }
    fn force_reload_resources(&self) -> &bool {
        &self.force_reload_resources
    }
    fn force_reload_resources_mut(&mut self) -> &mut bool {
        &mut self.force_reload_resources
    }
    fn level_manager_initial_level(&self) -> &String {
        &self.level_manager_initial_level
    }
    fn level_manager_initial_level_mut(&mut self) -> &mut String {
        &mut self.level_manager_initial_level
    }
}

impl super::entity::EntityDataTrait for LevelControlEntityData {
}

impl super::entity::GameObjectDataTrait for LevelControlEntityData {
}

impl super::core::DataBusPeerTrait for LevelControlEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LevelControlEntityData {
}

impl super::core::DataContainerTrait for LevelControlEntityData {
}

pub static LEVELCONTROLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelControlEntityData",
    name_hash: 2252502271,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LevelControlEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LevelControlEntityData as Default>::default())),
            create_boxed: || Box::new(<LevelControlEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LevelToLoad",
                name_hash: 932165454,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelControlEntityData, level_to_load),
            },
            FieldInfoData {
                name: "InclusionOptions",
                name_hash: 1857959091,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelControlEntityData, inclusion_options),
            },
            FieldInfoData {
                name: "StartPoint",
                name_hash: 2755831849,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelControlEntityData, start_point),
            },
            FieldInfoData {
                name: "RollCredits",
                name_hash: 3139123878,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelControlEntityData, roll_credits),
            },
            FieldInfoData {
                name: "DoPersistentSave",
                name_hash: 1668696298,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelControlEntityData, do_persistent_save),
            },
            FieldInfoData {
                name: "CheckSinglePlayerLevelInstalled",
                name_hash: 4198000540,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelControlEntityData, check_single_player_level_installed),
            },
            FieldInfoData {
                name: "ForceReloadResources",
                name_hash: 3211157744,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelControlEntityData, force_reload_resources),
            },
            FieldInfoData {
                name: "LevelManagerInitialLevel",
                name_hash: 992374984,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelControlEntityData, level_manager_initial_level),
            },
        ],
    }),
    array_type: Some(LEVELCONTROLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LevelControlEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LEVELCONTROLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LEVELCONTROLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelControlEntityData-Array",
    name_hash: 4049246923,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LevelControlEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ObjectiveEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub hud_data: Option<LockedTypeObject /* MissionObjectiveHudData */>,
    pub objective_type: ObjectiveType,
    pub display_time: f32,
    pub delay_time: f32,
    pub objective_sid: String,
    pub objective_brief_sid: String,
    pub success_sid: String,
    pub tutorial: bool,
    pub retrigger_success_on_show_objective: bool,
    pub reciever: MessageReciever,
    pub team_id: super::gameplay_sim::TeamId,
    pub squad_id: super::gameplay_sim::SquadId,
    pub display_success: bool,
}

pub trait ObjectiveEntityDataTrait: super::entity::EntityDataTrait {
    fn hud_data(&self) -> &Option<LockedTypeObject /* MissionObjectiveHudData */>;
    fn hud_data_mut(&mut self) -> &mut Option<LockedTypeObject /* MissionObjectiveHudData */>;
    fn objective_type(&self) -> &ObjectiveType;
    fn objective_type_mut(&mut self) -> &mut ObjectiveType;
    fn display_time(&self) -> &f32;
    fn display_time_mut(&mut self) -> &mut f32;
    fn delay_time(&self) -> &f32;
    fn delay_time_mut(&mut self) -> &mut f32;
    fn objective_sid(&self) -> &String;
    fn objective_sid_mut(&mut self) -> &mut String;
    fn objective_brief_sid(&self) -> &String;
    fn objective_brief_sid_mut(&mut self) -> &mut String;
    fn success_sid(&self) -> &String;
    fn success_sid_mut(&mut self) -> &mut String;
    fn tutorial(&self) -> &bool;
    fn tutorial_mut(&mut self) -> &mut bool;
    fn retrigger_success_on_show_objective(&self) -> &bool;
    fn retrigger_success_on_show_objective_mut(&mut self) -> &mut bool;
    fn reciever(&self) -> &MessageReciever;
    fn reciever_mut(&mut self) -> &mut MessageReciever;
    fn team_id(&self) -> &super::gameplay_sim::TeamId;
    fn team_id_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn squad_id(&self) -> &super::gameplay_sim::SquadId;
    fn squad_id_mut(&mut self) -> &mut super::gameplay_sim::SquadId;
    fn display_success(&self) -> &bool;
    fn display_success_mut(&mut self) -> &mut bool;
}

impl ObjectiveEntityDataTrait for ObjectiveEntityData {
    fn hud_data(&self) -> &Option<LockedTypeObject /* MissionObjectiveHudData */> {
        &self.hud_data
    }
    fn hud_data_mut(&mut self) -> &mut Option<LockedTypeObject /* MissionObjectiveHudData */> {
        &mut self.hud_data
    }
    fn objective_type(&self) -> &ObjectiveType {
        &self.objective_type
    }
    fn objective_type_mut(&mut self) -> &mut ObjectiveType {
        &mut self.objective_type
    }
    fn display_time(&self) -> &f32 {
        &self.display_time
    }
    fn display_time_mut(&mut self) -> &mut f32 {
        &mut self.display_time
    }
    fn delay_time(&self) -> &f32 {
        &self.delay_time
    }
    fn delay_time_mut(&mut self) -> &mut f32 {
        &mut self.delay_time
    }
    fn objective_sid(&self) -> &String {
        &self.objective_sid
    }
    fn objective_sid_mut(&mut self) -> &mut String {
        &mut self.objective_sid
    }
    fn objective_brief_sid(&self) -> &String {
        &self.objective_brief_sid
    }
    fn objective_brief_sid_mut(&mut self) -> &mut String {
        &mut self.objective_brief_sid
    }
    fn success_sid(&self) -> &String {
        &self.success_sid
    }
    fn success_sid_mut(&mut self) -> &mut String {
        &mut self.success_sid
    }
    fn tutorial(&self) -> &bool {
        &self.tutorial
    }
    fn tutorial_mut(&mut self) -> &mut bool {
        &mut self.tutorial
    }
    fn retrigger_success_on_show_objective(&self) -> &bool {
        &self.retrigger_success_on_show_objective
    }
    fn retrigger_success_on_show_objective_mut(&mut self) -> &mut bool {
        &mut self.retrigger_success_on_show_objective
    }
    fn reciever(&self) -> &MessageReciever {
        &self.reciever
    }
    fn reciever_mut(&mut self) -> &mut MessageReciever {
        &mut self.reciever
    }
    fn team_id(&self) -> &super::gameplay_sim::TeamId {
        &self.team_id
    }
    fn team_id_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_id
    }
    fn squad_id(&self) -> &super::gameplay_sim::SquadId {
        &self.squad_id
    }
    fn squad_id_mut(&mut self) -> &mut super::gameplay_sim::SquadId {
        &mut self.squad_id
    }
    fn display_success(&self) -> &bool {
        &self.display_success
    }
    fn display_success_mut(&mut self) -> &mut bool {
        &mut self.display_success
    }
}

impl super::entity::EntityDataTrait for ObjectiveEntityData {
}

impl super::entity::GameObjectDataTrait for ObjectiveEntityData {
}

impl super::core::DataBusPeerTrait for ObjectiveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectiveEntityData {
}

impl super::core::DataContainerTrait for ObjectiveEntityData {
}

pub static OBJECTIVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectiveEntityData",
    name_hash: 810453409,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ObjectiveEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectiveEntityData as Default>::default())),
            create_boxed: || Box::new(<ObjectiveEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "HudData",
                name_hash: 2639805868,
                flags: MemberInfoFlags::new(0),
                field_type: "MissionObjectiveHudData",
                rust_offset: offset_of!(ObjectiveEntityData, hud_data),
            },
            FieldInfoData {
                name: "ObjectiveType",
                name_hash: 4271777266,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectiveType",
                rust_offset: offset_of!(ObjectiveEntityData, objective_type),
            },
            FieldInfoData {
                name: "DisplayTime",
                name_hash: 1925139498,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectiveEntityData, display_time),
            },
            FieldInfoData {
                name: "DelayTime",
                name_hash: 3694246245,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectiveEntityData, delay_time),
            },
            FieldInfoData {
                name: "ObjectiveSid",
                name_hash: 2081694452,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ObjectiveEntityData, objective_sid),
            },
            FieldInfoData {
                name: "ObjectiveBriefSid",
                name_hash: 2106225038,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ObjectiveEntityData, objective_brief_sid),
            },
            FieldInfoData {
                name: "SuccessSid",
                name_hash: 1551323064,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ObjectiveEntityData, success_sid),
            },
            FieldInfoData {
                name: "Tutorial",
                name_hash: 3626722569,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectiveEntityData, tutorial),
            },
            FieldInfoData {
                name: "RetriggerSuccessOnShowObjective",
                name_hash: 1462402436,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectiveEntityData, retrigger_success_on_show_objective),
            },
            FieldInfoData {
                name: "Reciever",
                name_hash: 688681692,
                flags: MemberInfoFlags::new(0),
                field_type: "MessageReciever",
                rust_offset: offset_of!(ObjectiveEntityData, reciever),
            },
            FieldInfoData {
                name: "TeamId",
                name_hash: 3220374101,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(ObjectiveEntityData, team_id),
            },
            FieldInfoData {
                name: "SquadId",
                name_hash: 2312333818,
                flags: MemberInfoFlags::new(0),
                field_type: "SquadId",
                rust_offset: offset_of!(ObjectiveEntityData, squad_id),
            },
            FieldInfoData {
                name: "DisplaySuccess",
                name_hash: 4179535996,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectiveEntityData, display_success),
            },
        ],
    }),
    array_type: Some(OBJECTIVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectiveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTIVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTIVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectiveEntityData-Array",
    name_hash: 1719989269,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ObjectiveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MessageReciever {
    #[default]
    MrAll = 0,
    MrTeam = 1,
    MrTeamAndSquad = 2,
    MrPlayer = 3,
}

pub static MESSAGERECIEVER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageReciever",
    name_hash: 3953652439,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MESSAGERECIEVER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MessageReciever {
    fn type_info(&self) -> &'static TypeInfo {
        MESSAGERECIEVER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MESSAGERECIEVER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageReciever-Array",
    name_hash: 3089574883,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MessageReciever"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MissionObjectiveHudData {
    pub _glacier_base: super::core::DataContainer,
    pub camera_position: super::core::Vec3,
    pub camera_rotation: f32,
    pub camera_fov: f32,
    pub camera_distance: f32,
    pub camera_look_distance: f32,
    pub vertical_boundaries: super::core::Vec2,
    pub horizontal_boundaries: super::core::Vec2,
}

pub trait MissionObjectiveHudDataTrait: super::core::DataContainerTrait {
    fn camera_position(&self) -> &super::core::Vec3;
    fn camera_position_mut(&mut self) -> &mut super::core::Vec3;
    fn camera_rotation(&self) -> &f32;
    fn camera_rotation_mut(&mut self) -> &mut f32;
    fn camera_fov(&self) -> &f32;
    fn camera_fov_mut(&mut self) -> &mut f32;
    fn camera_distance(&self) -> &f32;
    fn camera_distance_mut(&mut self) -> &mut f32;
    fn camera_look_distance(&self) -> &f32;
    fn camera_look_distance_mut(&mut self) -> &mut f32;
    fn vertical_boundaries(&self) -> &super::core::Vec2;
    fn vertical_boundaries_mut(&mut self) -> &mut super::core::Vec2;
    fn horizontal_boundaries(&self) -> &super::core::Vec2;
    fn horizontal_boundaries_mut(&mut self) -> &mut super::core::Vec2;
}

impl MissionObjectiveHudDataTrait for MissionObjectiveHudData {
    fn camera_position(&self) -> &super::core::Vec3 {
        &self.camera_position
    }
    fn camera_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.camera_position
    }
    fn camera_rotation(&self) -> &f32 {
        &self.camera_rotation
    }
    fn camera_rotation_mut(&mut self) -> &mut f32 {
        &mut self.camera_rotation
    }
    fn camera_fov(&self) -> &f32 {
        &self.camera_fov
    }
    fn camera_fov_mut(&mut self) -> &mut f32 {
        &mut self.camera_fov
    }
    fn camera_distance(&self) -> &f32 {
        &self.camera_distance
    }
    fn camera_distance_mut(&mut self) -> &mut f32 {
        &mut self.camera_distance
    }
    fn camera_look_distance(&self) -> &f32 {
        &self.camera_look_distance
    }
    fn camera_look_distance_mut(&mut self) -> &mut f32 {
        &mut self.camera_look_distance
    }
    fn vertical_boundaries(&self) -> &super::core::Vec2 {
        &self.vertical_boundaries
    }
    fn vertical_boundaries_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.vertical_boundaries
    }
    fn horizontal_boundaries(&self) -> &super::core::Vec2 {
        &self.horizontal_boundaries
    }
    fn horizontal_boundaries_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.horizontal_boundaries
    }
}

impl super::core::DataContainerTrait for MissionObjectiveHudData {
}

pub static MISSIONOBJECTIVEHUDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MissionObjectiveHudData",
    name_hash: 1830100815,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(MissionObjectiveHudData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MissionObjectiveHudData as Default>::default())),
            create_boxed: || Box::new(<MissionObjectiveHudData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "CameraPosition",
                name_hash: 1421454469,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_position),
            },
            FieldInfoData {
                name: "CameraRotation",
                name_hash: 2168484520,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_rotation),
            },
            FieldInfoData {
                name: "CameraFov",
                name_hash: 1789541379,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_fov),
            },
            FieldInfoData {
                name: "CameraDistance",
                name_hash: 3954324415,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_distance),
            },
            FieldInfoData {
                name: "CameraLookDistance",
                name_hash: 3115939832,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_look_distance),
            },
            FieldInfoData {
                name: "VerticalBoundaries",
                name_hash: 402891209,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(MissionObjectiveHudData, vertical_boundaries),
            },
            FieldInfoData {
                name: "HorizontalBoundaries",
                name_hash: 2977590629,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(MissionObjectiveHudData, horizontal_boundaries),
            },
        ],
    }),
    array_type: Some(MISSIONOBJECTIVEHUDDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MissionObjectiveHudData {
    fn type_info(&self) -> &'static TypeInfo {
        MISSIONOBJECTIVEHUDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MISSIONOBJECTIVEHUDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MissionObjectiveHudData-Array",
    name_hash: 3385871483,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MissionObjectiveHudData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ObjectiveType {
    #[default]
    OTPrimary = 0,
    OTTactical = 1,
    OTChildMisson = 2,
}

pub static OBJECTIVETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectiveType",
    name_hash: 4271777266,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(OBJECTIVETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ObjectiveType {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTIVETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static OBJECTIVETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectiveType-Array",
    name_hash: 3142352070,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ObjectiveType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FadeEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub fade_screen: bool,
    pub fade_u_i: bool,
    pub fade_audio: bool,
    pub fade_movie: bool,
    pub fade_rumble: bool,
    pub system_fade: bool,
    pub block_input: bool,
    pub fade_time: f32,
    pub max_wait_faded_while_streaming_time: f32,
    pub start_faded: bool,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait FadeEntityDataTrait: super::entity::EntityDataTrait {
    fn fade_screen(&self) -> &bool;
    fn fade_screen_mut(&mut self) -> &mut bool;
    fn fade_u_i(&self) -> &bool;
    fn fade_u_i_mut(&mut self) -> &mut bool;
    fn fade_audio(&self) -> &bool;
    fn fade_audio_mut(&mut self) -> &mut bool;
    fn fade_movie(&self) -> &bool;
    fn fade_movie_mut(&mut self) -> &mut bool;
    fn fade_rumble(&self) -> &bool;
    fn fade_rumble_mut(&mut self) -> &mut bool;
    fn system_fade(&self) -> &bool;
    fn system_fade_mut(&mut self) -> &mut bool;
    fn block_input(&self) -> &bool;
    fn block_input_mut(&mut self) -> &mut bool;
    fn fade_time(&self) -> &f32;
    fn fade_time_mut(&mut self) -> &mut f32;
    fn max_wait_faded_while_streaming_time(&self) -> &f32;
    fn max_wait_faded_while_streaming_time_mut(&mut self) -> &mut f32;
    fn start_faded(&self) -> &bool;
    fn start_faded_mut(&mut self) -> &mut bool;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl FadeEntityDataTrait for FadeEntityData {
    fn fade_screen(&self) -> &bool {
        &self.fade_screen
    }
    fn fade_screen_mut(&mut self) -> &mut bool {
        &mut self.fade_screen
    }
    fn fade_u_i(&self) -> &bool {
        &self.fade_u_i
    }
    fn fade_u_i_mut(&mut self) -> &mut bool {
        &mut self.fade_u_i
    }
    fn fade_audio(&self) -> &bool {
        &self.fade_audio
    }
    fn fade_audio_mut(&mut self) -> &mut bool {
        &mut self.fade_audio
    }
    fn fade_movie(&self) -> &bool {
        &self.fade_movie
    }
    fn fade_movie_mut(&mut self) -> &mut bool {
        &mut self.fade_movie
    }
    fn fade_rumble(&self) -> &bool {
        &self.fade_rumble
    }
    fn fade_rumble_mut(&mut self) -> &mut bool {
        &mut self.fade_rumble
    }
    fn system_fade(&self) -> &bool {
        &self.system_fade
    }
    fn system_fade_mut(&mut self) -> &mut bool {
        &mut self.system_fade
    }
    fn block_input(&self) -> &bool {
        &self.block_input
    }
    fn block_input_mut(&mut self) -> &mut bool {
        &mut self.block_input
    }
    fn fade_time(&self) -> &f32 {
        &self.fade_time
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        &mut self.fade_time
    }
    fn max_wait_faded_while_streaming_time(&self) -> &f32 {
        &self.max_wait_faded_while_streaming_time
    }
    fn max_wait_faded_while_streaming_time_mut(&mut self) -> &mut f32 {
        &mut self.max_wait_faded_while_streaming_time
    }
    fn start_faded(&self) -> &bool {
        &self.start_faded
    }
    fn start_faded_mut(&mut self) -> &mut bool {
        &mut self.start_faded
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for FadeEntityData {
}

impl super::entity::GameObjectDataTrait for FadeEntityData {
}

impl super::core::DataBusPeerTrait for FadeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FadeEntityData {
}

impl super::core::DataContainerTrait for FadeEntityData {
}

pub static FADEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeEntityData",
    name_hash: 1459458888,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FadeEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FadeEntityData as Default>::default())),
            create_boxed: || Box::new(<FadeEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FadeScreen",
                name_hash: 1880126671,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_screen),
            },
            FieldInfoData {
                name: "FadeUI",
                name_hash: 2515973727,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_u_i),
            },
            FieldInfoData {
                name: "FadeAudio",
                name_hash: 3169106133,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_audio),
            },
            FieldInfoData {
                name: "FadeMovie",
                name_hash: 3182278683,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_movie),
            },
            FieldInfoData {
                name: "FadeRumble",
                name_hash: 1825215970,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_rumble),
            },
            FieldInfoData {
                name: "SystemFade",
                name_hash: 279794534,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, system_fade),
            },
            FieldInfoData {
                name: "BlockInput",
                name_hash: 3730121914,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, block_input),
            },
            FieldInfoData {
                name: "FadeTime",
                name_hash: 4001222838,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FadeEntityData, fade_time),
            },
            FieldInfoData {
                name: "MaxWaitFadedWhileStreamingTime",
                name_hash: 3945633230,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FadeEntityData, max_wait_faded_while_streaming_time),
            },
            FieldInfoData {
                name: "StartFaded",
                name_hash: 2729539719,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, start_faded),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(FadeEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(FADEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FadeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FADEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FADEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeEntityData-Array",
    name_hash: 2148599292,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FadeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BlinkType {
    #[default]
    BTHold = 0,
    BTBlink = 1,
    BTCount = 2,
}

pub static BLINKTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlinkType",
    name_hash: 2878228191,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BLINKTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BlinkType {
    fn type_info(&self) -> &'static TypeInfo {
        BLINKTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BLINKTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlinkType-Array",
    name_hash: 2868632555,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BlinkType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct KillAllEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub team: super::gameplay_sim::TeamId,
    pub kill_players: KillAllPlayerEnum,
    pub damage_giving_player: i32,
}

pub trait KillAllEntityDataTrait: super::entity::EntityDataTrait {
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn kill_players(&self) -> &KillAllPlayerEnum;
    fn kill_players_mut(&mut self) -> &mut KillAllPlayerEnum;
    fn damage_giving_player(&self) -> &i32;
    fn damage_giving_player_mut(&mut self) -> &mut i32;
}

impl KillAllEntityDataTrait for KillAllEntityData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn kill_players(&self) -> &KillAllPlayerEnum {
        &self.kill_players
    }
    fn kill_players_mut(&mut self) -> &mut KillAllPlayerEnum {
        &mut self.kill_players
    }
    fn damage_giving_player(&self) -> &i32 {
        &self.damage_giving_player
    }
    fn damage_giving_player_mut(&mut self) -> &mut i32 {
        &mut self.damage_giving_player
    }
}

impl super::entity::EntityDataTrait for KillAllEntityData {
}

impl super::entity::GameObjectDataTrait for KillAllEntityData {
}

impl super::core::DataBusPeerTrait for KillAllEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for KillAllEntityData {
}

impl super::core::DataContainerTrait for KillAllEntityData {
}

pub static KILLALLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillAllEntityData",
    name_hash: 2854950221,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(KillAllEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<KillAllEntityData as Default>::default())),
            create_boxed: || Box::new(<KillAllEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                name_hash: 2089309528,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(KillAllEntityData, team),
            },
            FieldInfoData {
                name: "KillPlayers",
                name_hash: 1681130759,
                flags: MemberInfoFlags::new(0),
                field_type: "KillAllPlayerEnum",
                rust_offset: offset_of!(KillAllEntityData, kill_players),
            },
            FieldInfoData {
                name: "DamageGivingPlayer",
                name_hash: 8022661,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(KillAllEntityData, damage_giving_player),
            },
        ],
    }),
    array_type: Some(KILLALLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for KillAllEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        KILLALLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static KILLALLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillAllEntityData-Array",
    name_hash: 2673510777,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("KillAllEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum KillAllPlayerEnum {
    #[default]
    KillAllPlayer_Both = 0,
    KillAllPlayer_HumanOnly = 1,
    KillAllPlayer_AIOnly = 2,
}

pub static KILLALLPLAYERENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillAllPlayerEnum",
    name_hash: 2107763430,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(KILLALLPLAYERENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for KillAllPlayerEnum {
    fn type_info(&self) -> &'static TypeInfo {
        KILLALLPLAYERENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static KILLALLPLAYERENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillAllPlayerEnum-Array",
    name_hash: 318564306,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("KillAllPlayerEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WaypointTriggerEntityBaseData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait WaypointTriggerEntityBaseDataTrait: super::entity::EntityDataTrait {
}

impl WaypointTriggerEntityBaseDataTrait for WaypointTriggerEntityBaseData {
}

impl super::entity::EntityDataTrait for WaypointTriggerEntityBaseData {
}

impl super::entity::GameObjectDataTrait for WaypointTriggerEntityBaseData {
}

impl super::core::DataBusPeerTrait for WaypointTriggerEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WaypointTriggerEntityBaseData {
}

impl super::core::DataContainerTrait for WaypointTriggerEntityBaseData {
}

pub static WAYPOINTTRIGGERENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointTriggerEntityBaseData",
    name_hash: 452347872,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(WaypointTriggerEntityBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaypointTriggerEntityBaseData as Default>::default())),
            create_boxed: || Box::new(<WaypointTriggerEntityBaseData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WAYPOINTTRIGGERENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaypointTriggerEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        WAYPOINTTRIGGERENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WAYPOINTTRIGGERENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointTriggerEntityBaseData-Array",
    name_hash: 2356616660,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WaypointTriggerEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CombatAreaTriggerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub time_to_return: u32,
    pub is_ai_allowed_outside: bool,
    pub team: super::gameplay_sim::TeamId,
    pub is_team_specific: bool,
    pub enabled: bool,
}

pub trait CombatAreaTriggerEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn time_to_return(&self) -> &u32;
    fn time_to_return_mut(&mut self) -> &mut u32;
    fn is_ai_allowed_outside(&self) -> &bool;
    fn is_ai_allowed_outside_mut(&mut self) -> &mut bool;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn is_team_specific(&self) -> &bool;
    fn is_team_specific_mut(&mut self) -> &mut bool;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl CombatAreaTriggerEntityDataTrait for CombatAreaTriggerEntityData {
    fn time_to_return(&self) -> &u32 {
        &self.time_to_return
    }
    fn time_to_return_mut(&mut self) -> &mut u32 {
        &mut self.time_to_return
    }
    fn is_ai_allowed_outside(&self) -> &bool {
        &self.is_ai_allowed_outside
    }
    fn is_ai_allowed_outside_mut(&mut self) -> &mut bool {
        &mut self.is_ai_allowed_outside
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn is_team_specific(&self) -> &bool {
        &self.is_team_specific
    }
    fn is_team_specific_mut(&mut self) -> &mut bool {
        &mut self.is_team_specific
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for CombatAreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CombatAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for CombatAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for CombatAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CombatAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for CombatAreaTriggerEntityData {
}

pub static COMBATAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatAreaTriggerEntityData",
    name_hash: 1893959447,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CombatAreaTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CombatAreaTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<CombatAreaTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TimeToReturn",
                name_hash: 2769825281,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, time_to_return),
            },
            FieldInfoData {
                name: "IsAiAllowedOutside",
                name_hash: 4144947226,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, is_ai_allowed_outside),
            },
            FieldInfoData {
                name: "Team",
                name_hash: 2089309528,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, team),
            },
            FieldInfoData {
                name: "IsTeamSpecific",
                name_hash: 3554635554,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, is_team_specific),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, enabled),
            },
        ],
    }),
    array_type: Some(COMBATAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CombatAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMBATAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMBATAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatAreaTriggerEntityData-Array",
    name_hash: 4037095331,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CombatAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SurroundingGeometryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub allowed_vehicle_list: Option<LockedTypeObject /* AllowedVehiclesData */>,
    pub combat_area: Option<LockedTypeObject /* CombatAreaTriggerEntityData */>,
    pub combat_area_index: u32,
    pub enabled: bool,
}

pub trait SurroundingGeometryEntityDataTrait: super::entity::EntityDataTrait {
    fn allowed_vehicle_list(&self) -> &Option<LockedTypeObject /* AllowedVehiclesData */>;
    fn allowed_vehicle_list_mut(&mut self) -> &mut Option<LockedTypeObject /* AllowedVehiclesData */>;
    fn combat_area(&self) -> &Option<LockedTypeObject /* CombatAreaTriggerEntityData */>;
    fn combat_area_mut(&mut self) -> &mut Option<LockedTypeObject /* CombatAreaTriggerEntityData */>;
    fn combat_area_index(&self) -> &u32;
    fn combat_area_index_mut(&mut self) -> &mut u32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl SurroundingGeometryEntityDataTrait for SurroundingGeometryEntityData {
    fn allowed_vehicle_list(&self) -> &Option<LockedTypeObject /* AllowedVehiclesData */> {
        &self.allowed_vehicle_list
    }
    fn allowed_vehicle_list_mut(&mut self) -> &mut Option<LockedTypeObject /* AllowedVehiclesData */> {
        &mut self.allowed_vehicle_list
    }
    fn combat_area(&self) -> &Option<LockedTypeObject /* CombatAreaTriggerEntityData */> {
        &self.combat_area
    }
    fn combat_area_mut(&mut self) -> &mut Option<LockedTypeObject /* CombatAreaTriggerEntityData */> {
        &mut self.combat_area
    }
    fn combat_area_index(&self) -> &u32 {
        &self.combat_area_index
    }
    fn combat_area_index_mut(&mut self) -> &mut u32 {
        &mut self.combat_area_index
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for SurroundingGeometryEntityData {
}

impl super::entity::GameObjectDataTrait for SurroundingGeometryEntityData {
}

impl super::core::DataBusPeerTrait for SurroundingGeometryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SurroundingGeometryEntityData {
}

impl super::core::DataContainerTrait for SurroundingGeometryEntityData {
}

pub static SURROUNDINGGEOMETRYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SurroundingGeometryEntityData",
    name_hash: 2535682690,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SurroundingGeometryEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SurroundingGeometryEntityData as Default>::default())),
            create_boxed: || Box::new(<SurroundingGeometryEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AllowedVehicleList",
                name_hash: 880039879,
                flags: MemberInfoFlags::new(0),
                field_type: "AllowedVehiclesData",
                rust_offset: offset_of!(SurroundingGeometryEntityData, allowed_vehicle_list),
            },
            FieldInfoData {
                name: "CombatArea",
                name_hash: 3144394660,
                flags: MemberInfoFlags::new(0),
                field_type: "CombatAreaTriggerEntityData",
                rust_offset: offset_of!(SurroundingGeometryEntityData, combat_area),
            },
            FieldInfoData {
                name: "CombatAreaIndex",
                name_hash: 2813446234,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SurroundingGeometryEntityData, combat_area_index),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SurroundingGeometryEntityData, enabled),
            },
        ],
    }),
    array_type: Some(SURROUNDINGGEOMETRYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SurroundingGeometryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SURROUNDINGGEOMETRYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SURROUNDINGGEOMETRYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SurroundingGeometryEntityData-Array",
    name_hash: 265957814,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SurroundingGeometryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UICombatAreaEntityData {
    pub _glacier_base: super::entity::GameObjectData,
    pub asset: Option<LockedTypeObject /* UICombatAreaAsset */>,
}

pub trait UICombatAreaEntityDataTrait: super::entity::GameObjectDataTrait {
    fn asset(&self) -> &Option<LockedTypeObject /* UICombatAreaAsset */>;
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UICombatAreaAsset */>;
}

impl UICombatAreaEntityDataTrait for UICombatAreaEntityData {
    fn asset(&self) -> &Option<LockedTypeObject /* UICombatAreaAsset */> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UICombatAreaAsset */> {
        &mut self.asset
    }
}

impl super::entity::GameObjectDataTrait for UICombatAreaEntityData {
}

impl super::core::DataBusPeerTrait for UICombatAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for UICombatAreaEntityData {
}

impl super::core::DataContainerTrait for UICombatAreaEntityData {
}

pub static UICOMBATAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UICombatAreaEntityData",
    name_hash: 4040384563,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(UICombatAreaEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UICombatAreaEntityData as Default>::default())),
            create_boxed: || Box::new(<UICombatAreaEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Asset",
                name_hash: 205976053,
                flags: MemberInfoFlags::new(0),
                field_type: "UICombatAreaAsset",
                rust_offset: offset_of!(UICombatAreaEntityData, asset),
            },
        ],
    }),
    array_type: Some(UICOMBATAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UICombatAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        UICOMBATAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UICOMBATAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UICombatAreaEntityData-Array",
    name_hash: 2411457415,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UICombatAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AllowedVehiclesData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait AllowedVehiclesDataTrait: super::core::DataContainerTrait {
}

impl AllowedVehiclesDataTrait for AllowedVehiclesData {
}

impl super::core::DataContainerTrait for AllowedVehiclesData {
}

pub static ALLOWEDVEHICLESDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AllowedVehiclesData",
    name_hash: 3247922214,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AllowedVehiclesData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AllowedVehiclesData as Default>::default())),
            create_boxed: || Box::new(<AllowedVehiclesData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ALLOWEDVEHICLESDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AllowedVehiclesData {
    fn type_info(&self) -> &'static TypeInfo {
        ALLOWEDVEHICLESDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ALLOWEDVEHICLESDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AllowedVehiclesData-Array",
    name_hash: 2002946194,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AllowedVehiclesData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DeathAreaTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub damage: f32,
    pub time_to_return: f32,
}

pub trait DeathAreaTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn damage(&self) -> &f32;
    fn damage_mut(&mut self) -> &mut f32;
    fn time_to_return(&self) -> &f32;
    fn time_to_return_mut(&mut self) -> &mut f32;
}

impl DeathAreaTriggerEntityDataTrait for DeathAreaTriggerEntityData {
    fn damage(&self) -> &f32 {
        &self.damage
    }
    fn damage_mut(&mut self) -> &mut f32 {
        &mut self.damage
    }
    fn time_to_return(&self) -> &f32 {
        &self.time_to_return
    }
    fn time_to_return_mut(&mut self) -> &mut f32 {
        &mut self.time_to_return
    }
}

impl TriggerEntityDataTrait for DeathAreaTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DeathAreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DeathAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for DeathAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for DeathAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DeathAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for DeathAreaTriggerEntityData {
}

pub static DEATHAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeathAreaTriggerEntityData",
    name_hash: 332589597,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DeathAreaTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeathAreaTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<DeathAreaTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Damage",
                name_hash: 2589892334,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DeathAreaTriggerEntityData, damage),
            },
            FieldInfoData {
                name: "TimeToReturn",
                name_hash: 2769825281,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DeathAreaTriggerEntityData, time_to_return),
            },
        ],
    }),
    array_type: Some(DEATHAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DeathAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEATHAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEATHAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeathAreaTriggerEntityData-Array",
    name_hash: 949335465,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeathAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct HumanPlayerEntityData {
    pub _glacier_base: HumanPlayerProxyEntityData,
    pub player_killed_delay: f32,
    pub post_revive_short_respawn_time: f32,
    pub max_revive_count: i32,
}

pub trait HumanPlayerEntityDataTrait: HumanPlayerProxyEntityDataTrait {
    fn player_killed_delay(&self) -> &f32;
    fn player_killed_delay_mut(&mut self) -> &mut f32;
    fn post_revive_short_respawn_time(&self) -> &f32;
    fn post_revive_short_respawn_time_mut(&mut self) -> &mut f32;
    fn max_revive_count(&self) -> &i32;
    fn max_revive_count_mut(&mut self) -> &mut i32;
}

impl HumanPlayerEntityDataTrait for HumanPlayerEntityData {
    fn player_killed_delay(&self) -> &f32 {
        &self.player_killed_delay
    }
    fn player_killed_delay_mut(&mut self) -> &mut f32 {
        &mut self.player_killed_delay
    }
    fn post_revive_short_respawn_time(&self) -> &f32 {
        &self.post_revive_short_respawn_time
    }
    fn post_revive_short_respawn_time_mut(&mut self) -> &mut f32 {
        &mut self.post_revive_short_respawn_time
    }
    fn max_revive_count(&self) -> &i32 {
        &self.max_revive_count
    }
    fn max_revive_count_mut(&mut self) -> &mut i32 {
        &mut self.max_revive_count
    }
}

impl HumanPlayerProxyEntityDataTrait for HumanPlayerEntityData {
    fn enable_on_died_on_melee_event(&self) -> &bool {
        self._glacier_base.enable_on_died_on_melee_event()
    }
    fn enable_on_died_on_melee_event_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_on_died_on_melee_event_mut()
    }
    fn enable_on_died_in_water_event(&self) -> &bool {
        self._glacier_base.enable_on_died_in_water_event()
    }
    fn enable_on_died_in_water_event_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_on_died_in_water_event_mut()
    }
}

impl super::entity::EntityDataTrait for HumanPlayerEntityData {
}

impl super::entity::GameObjectDataTrait for HumanPlayerEntityData {
}

impl super::core::DataBusPeerTrait for HumanPlayerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for HumanPlayerEntityData {
}

impl super::core::DataContainerTrait for HumanPlayerEntityData {
}

pub static HUMANPLAYERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HumanPlayerEntityData",
    name_hash: 2300457314,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(HUMANPLAYERPROXYENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(HumanPlayerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HumanPlayerEntityData as Default>::default())),
            create_boxed: || Box::new(<HumanPlayerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PlayerKilledDelay",
                name_hash: 277093856,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HumanPlayerEntityData, player_killed_delay),
            },
            FieldInfoData {
                name: "PostReviveShortRespawnTime",
                name_hash: 2349221229,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HumanPlayerEntityData, post_revive_short_respawn_time),
            },
            FieldInfoData {
                name: "MaxReviveCount",
                name_hash: 3358438409,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(HumanPlayerEntityData, max_revive_count),
            },
        ],
    }),
    array_type: Some(HUMANPLAYERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HumanPlayerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        HUMANPLAYERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HUMANPLAYERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HumanPlayerEntityData-Array",
    name_hash: 2482266198,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HumanPlayerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct HumanPlayerProxyEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enable_on_died_on_melee_event: bool,
    pub enable_on_died_in_water_event: bool,
}

pub trait HumanPlayerProxyEntityDataTrait: super::entity::EntityDataTrait {
    fn enable_on_died_on_melee_event(&self) -> &bool;
    fn enable_on_died_on_melee_event_mut(&mut self) -> &mut bool;
    fn enable_on_died_in_water_event(&self) -> &bool;
    fn enable_on_died_in_water_event_mut(&mut self) -> &mut bool;
}

impl HumanPlayerProxyEntityDataTrait for HumanPlayerProxyEntityData {
    fn enable_on_died_on_melee_event(&self) -> &bool {
        &self.enable_on_died_on_melee_event
    }
    fn enable_on_died_on_melee_event_mut(&mut self) -> &mut bool {
        &mut self.enable_on_died_on_melee_event
    }
    fn enable_on_died_in_water_event(&self) -> &bool {
        &self.enable_on_died_in_water_event
    }
    fn enable_on_died_in_water_event_mut(&mut self) -> &mut bool {
        &mut self.enable_on_died_in_water_event
    }
}

impl super::entity::EntityDataTrait for HumanPlayerProxyEntityData {
}

impl super::entity::GameObjectDataTrait for HumanPlayerProxyEntityData {
}

impl super::core::DataBusPeerTrait for HumanPlayerProxyEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for HumanPlayerProxyEntityData {
}

impl super::core::DataContainerTrait for HumanPlayerProxyEntityData {
}

pub static HUMANPLAYERPROXYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HumanPlayerProxyEntityData",
    name_hash: 1781597710,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(HumanPlayerProxyEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HumanPlayerProxyEntityData as Default>::default())),
            create_boxed: || Box::new(<HumanPlayerProxyEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EnableOnDiedOnMeleeEvent",
                name_hash: 1890226400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HumanPlayerProxyEntityData, enable_on_died_on_melee_event),
            },
            FieldInfoData {
                name: "EnableOnDiedInWaterEvent",
                name_hash: 3835624407,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HumanPlayerProxyEntityData, enable_on_died_in_water_event),
            },
        ],
    }),
    array_type: Some(HUMANPLAYERPROXYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HumanPlayerProxyEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        HUMANPLAYERPROXYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HUMANPLAYERPROXYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HumanPlayerProxyEntityData-Array",
    name_hash: 3395776314,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HumanPlayerProxyEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TeamEntityData {
    pub _glacier_base: super::gameplay_sim::GameplayTeamEntityData,
}

pub trait TeamEntityDataTrait: super::gameplay_sim::GameplayTeamEntityDataTrait {
}

impl TeamEntityDataTrait for TeamEntityData {
}

impl super::gameplay_sim::GameplayTeamEntityDataTrait for TeamEntityData {
    fn team(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::GameplayTeamData */> {
        self._glacier_base.team()
    }
    fn team_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::GameplayTeamData */> {
        self._glacier_base.team_mut()
    }
    fn id(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.id_mut()
    }
}

impl super::entity::EntityDataTrait for TeamEntityData {
}

impl super::entity::GameObjectDataTrait for TeamEntityData {
}

impl super::core::DataBusPeerTrait for TeamEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TeamEntityData {
}

impl super::core::DataContainerTrait for TeamEntityData {
}

pub static TEAMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamEntityData",
    name_hash: 2798632115,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPLAYTEAMENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TeamEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeamEntityData as Default>::default())),
            create_boxed: || Box::new(<TeamEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TEAMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TeamEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TEAMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEAMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamEntityData-Array",
    name_hash: 1034659847,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeamEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TeamData {
    pub _glacier_base: super::gameplay_sim::GameplayTeamData,
    pub soldier: Option<LockedTypeObject /* CharacterBlueprint */>,
    pub soldier_customization: Vec<Option<LockedTypeObject /* CharacterCustomizationAsset */>>,
    pub vehicle_customization: Vec<Option<LockedTypeObject /* VehicleCustomizationAsset */>>,
}

pub trait TeamDataTrait: super::gameplay_sim::GameplayTeamDataTrait {
    fn soldier(&self) -> &Option<LockedTypeObject /* CharacterBlueprint */>;
    fn soldier_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterBlueprint */>;
    fn soldier_customization(&self) -> &Vec<Option<LockedTypeObject /* CharacterCustomizationAsset */>>;
    fn soldier_customization_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CharacterCustomizationAsset */>>;
    fn vehicle_customization(&self) -> &Vec<Option<LockedTypeObject /* VehicleCustomizationAsset */>>;
    fn vehicle_customization_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VehicleCustomizationAsset */>>;
}

impl TeamDataTrait for TeamData {
    fn soldier(&self) -> &Option<LockedTypeObject /* CharacterBlueprint */> {
        &self.soldier
    }
    fn soldier_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterBlueprint */> {
        &mut self.soldier
    }
    fn soldier_customization(&self) -> &Vec<Option<LockedTypeObject /* CharacterCustomizationAsset */>> {
        &self.soldier_customization
    }
    fn soldier_customization_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CharacterCustomizationAsset */>> {
        &mut self.soldier_customization
    }
    fn vehicle_customization(&self) -> &Vec<Option<LockedTypeObject /* VehicleCustomizationAsset */>> {
        &self.vehicle_customization
    }
    fn vehicle_customization_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VehicleCustomizationAsset */>> {
        &mut self.vehicle_customization
    }
}

impl super::gameplay_sim::GameplayTeamDataTrait for TeamData {
    fn faction(&self) -> &super::gameplay_sim::FactionId {
        self._glacier_base.faction()
    }
    fn faction_mut(&mut self) -> &mut super::gameplay_sim::FactionId {
        self._glacier_base.faction_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for TeamData {
}

impl super::core::AssetTrait for TeamData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for TeamData {
}

pub static TEAMDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamData",
    name_hash: 2294546792,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPLAYTEAMDATA_TYPE_INFO),
        super_class_offset: offset_of!(TeamData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeamData as Default>::default())),
            create_boxed: || Box::new(<TeamData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Soldier",
                name_hash: 2844639087,
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterBlueprint",
                rust_offset: offset_of!(TeamData, soldier),
            },
            FieldInfoData {
                name: "SoldierCustomization",
                name_hash: 2197823922,
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterCustomizationAsset-Array",
                rust_offset: offset_of!(TeamData, soldier_customization),
            },
            FieldInfoData {
                name: "VehicleCustomization",
                name_hash: 448553568,
                flags: MemberInfoFlags::new(144),
                field_type: "VehicleCustomizationAsset-Array",
                rust_offset: offset_of!(TeamData, vehicle_customization),
            },
        ],
    }),
    array_type: Some(TEAMDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TeamData {
    fn type_info(&self) -> &'static TypeInfo {
        TEAMDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEAMDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamData-Array",
    name_hash: 4119417692,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeamData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DynamicAvoidanceEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub repel_others: DynamicAvoidanceMode,
    pub affected_by_repelling_force: bool,
    pub predicted_by_others: bool,
    pub report_predicted_collision: DynamicAvoidanceMode,
    pub collision_radius: f32,
    pub ant_binding: AntDynamicAvoidanceBinding,
    pub realm: super::core::Realm,
}

pub trait DynamicAvoidanceEntityDataTrait: super::entity::EntityDataTrait {
    fn repel_others(&self) -> &DynamicAvoidanceMode;
    fn repel_others_mut(&mut self) -> &mut DynamicAvoidanceMode;
    fn affected_by_repelling_force(&self) -> &bool;
    fn affected_by_repelling_force_mut(&mut self) -> &mut bool;
    fn predicted_by_others(&self) -> &bool;
    fn predicted_by_others_mut(&mut self) -> &mut bool;
    fn report_predicted_collision(&self) -> &DynamicAvoidanceMode;
    fn report_predicted_collision_mut(&mut self) -> &mut DynamicAvoidanceMode;
    fn collision_radius(&self) -> &f32;
    fn collision_radius_mut(&mut self) -> &mut f32;
    fn ant_binding(&self) -> &AntDynamicAvoidanceBinding;
    fn ant_binding_mut(&mut self) -> &mut AntDynamicAvoidanceBinding;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl DynamicAvoidanceEntityDataTrait for DynamicAvoidanceEntityData {
    fn repel_others(&self) -> &DynamicAvoidanceMode {
        &self.repel_others
    }
    fn repel_others_mut(&mut self) -> &mut DynamicAvoidanceMode {
        &mut self.repel_others
    }
    fn affected_by_repelling_force(&self) -> &bool {
        &self.affected_by_repelling_force
    }
    fn affected_by_repelling_force_mut(&mut self) -> &mut bool {
        &mut self.affected_by_repelling_force
    }
    fn predicted_by_others(&self) -> &bool {
        &self.predicted_by_others
    }
    fn predicted_by_others_mut(&mut self) -> &mut bool {
        &mut self.predicted_by_others
    }
    fn report_predicted_collision(&self) -> &DynamicAvoidanceMode {
        &self.report_predicted_collision
    }
    fn report_predicted_collision_mut(&mut self) -> &mut DynamicAvoidanceMode {
        &mut self.report_predicted_collision
    }
    fn collision_radius(&self) -> &f32 {
        &self.collision_radius
    }
    fn collision_radius_mut(&mut self) -> &mut f32 {
        &mut self.collision_radius
    }
    fn ant_binding(&self) -> &AntDynamicAvoidanceBinding {
        &self.ant_binding
    }
    fn ant_binding_mut(&mut self) -> &mut AntDynamicAvoidanceBinding {
        &mut self.ant_binding
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for DynamicAvoidanceEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicAvoidanceEntityData {
}

impl super::core::DataBusPeerTrait for DynamicAvoidanceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicAvoidanceEntityData {
}

impl super::core::DataContainerTrait for DynamicAvoidanceEntityData {
}

pub static DYNAMICAVOIDANCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAvoidanceEntityData",
    name_hash: 4129295943,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DynamicAvoidanceEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicAvoidanceEntityData as Default>::default())),
            create_boxed: || Box::new(<DynamicAvoidanceEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RepelOthers",
                name_hash: 2680634556,
                flags: MemberInfoFlags::new(0),
                field_type: "DynamicAvoidanceMode",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, repel_others),
            },
            FieldInfoData {
                name: "AffectedByRepellingForce",
                name_hash: 2759712179,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, affected_by_repelling_force),
            },
            FieldInfoData {
                name: "PredictedByOthers",
                name_hash: 1713837653,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, predicted_by_others),
            },
            FieldInfoData {
                name: "ReportPredictedCollision",
                name_hash: 690685961,
                flags: MemberInfoFlags::new(0),
                field_type: "DynamicAvoidanceMode",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, report_predicted_collision),
            },
            FieldInfoData {
                name: "CollisionRadius",
                name_hash: 1874505603,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, collision_radius),
            },
            FieldInfoData {
                name: "AntBinding",
                name_hash: 2293128415,
                flags: MemberInfoFlags::new(0),
                field_type: "AntDynamicAvoidanceBinding",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, ant_binding),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, realm),
            },
        ],
    }),
    array_type: Some(DYNAMICAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DynamicAvoidanceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICAVOIDANCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAvoidanceEntityData-Array",
    name_hash: 3465748339,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicAvoidanceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DynamicAvoidanceMode {
    #[default]
    DynamicAvoidanceMode_Never = 0,
    DynamicAvoidanceMode_WhenScripted = 1,
    DynamicAvoidanceMode_WhenNotScripted = 2,
    DynamicAvoidanceMode_Always = 3,
}

pub static DYNAMICAVOIDANCEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAvoidanceMode",
    name_hash: 2278461103,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DYNAMICAVOIDANCEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DynamicAvoidanceMode {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICAVOIDANCEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DYNAMICAVOIDANCEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAvoidanceMode-Array",
    name_hash: 1059863579,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicAvoidanceMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AntDynamicAvoidanceBinding {
    pub time_until_collision: super::ant::AntRef,
    pub distance_until_collision: super::ant::AntRef,
    pub normalized_velocity: super::ant::AntRef,
    pub speed: super::ant::AntRef,
}

pub trait AntDynamicAvoidanceBindingTrait: TypeObject {
    fn time_until_collision(&self) -> &super::ant::AntRef;
    fn time_until_collision_mut(&mut self) -> &mut super::ant::AntRef;
    fn distance_until_collision(&self) -> &super::ant::AntRef;
    fn distance_until_collision_mut(&mut self) -> &mut super::ant::AntRef;
    fn normalized_velocity(&self) -> &super::ant::AntRef;
    fn normalized_velocity_mut(&mut self) -> &mut super::ant::AntRef;
    fn speed(&self) -> &super::ant::AntRef;
    fn speed_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AntDynamicAvoidanceBindingTrait for AntDynamicAvoidanceBinding {
    fn time_until_collision(&self) -> &super::ant::AntRef {
        &self.time_until_collision
    }
    fn time_until_collision_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.time_until_collision
    }
    fn distance_until_collision(&self) -> &super::ant::AntRef {
        &self.distance_until_collision
    }
    fn distance_until_collision_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.distance_until_collision
    }
    fn normalized_velocity(&self) -> &super::ant::AntRef {
        &self.normalized_velocity
    }
    fn normalized_velocity_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.normalized_velocity
    }
    fn speed(&self) -> &super::ant::AntRef {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.speed
    }
}

pub static ANTDYNAMICAVOIDANCEBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntDynamicAvoidanceBinding",
    name_hash: 3073889814,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntDynamicAvoidanceBinding as Default>::default())),
            create_boxed: || Box::new(<AntDynamicAvoidanceBinding as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TimeUntilCollision",
                name_hash: 3142481924,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AntDynamicAvoidanceBinding, time_until_collision),
            },
            FieldInfoData {
                name: "DistanceUntilCollision",
                name_hash: 1945583762,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AntDynamicAvoidanceBinding, distance_until_collision),
            },
            FieldInfoData {
                name: "NormalizedVelocity",
                name_hash: 113203091,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AntDynamicAvoidanceBinding, normalized_velocity),
            },
            FieldInfoData {
                name: "Speed",
                name_hash: 230887042,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AntDynamicAvoidanceBinding, speed),
            },
        ],
    }),
    array_type: Some(ANTDYNAMICAVOIDANCEBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AntDynamicAvoidanceBinding {
    fn type_info(&self) -> &'static TypeInfo {
        ANTDYNAMICAVOIDANCEBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTDYNAMICAVOIDANCEBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntDynamicAvoidanceBinding-Array",
    name_hash: 576564002,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntDynamicAvoidanceBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DriverStaticObjectComponentData {
    pub _glacier_base: DriverComponentData,
    pub acceleration: f32,
    pub deceleration: f32,
    pub turning_radius: f32,
    pub turn_while_still: bool,
    pub align_with_ground_normal: bool,
}

pub trait DriverStaticObjectComponentDataTrait: DriverComponentDataTrait {
    fn acceleration(&self) -> &f32;
    fn acceleration_mut(&mut self) -> &mut f32;
    fn deceleration(&self) -> &f32;
    fn deceleration_mut(&mut self) -> &mut f32;
    fn turning_radius(&self) -> &f32;
    fn turning_radius_mut(&mut self) -> &mut f32;
    fn turn_while_still(&self) -> &bool;
    fn turn_while_still_mut(&mut self) -> &mut bool;
    fn align_with_ground_normal(&self) -> &bool;
    fn align_with_ground_normal_mut(&mut self) -> &mut bool;
}

impl DriverStaticObjectComponentDataTrait for DriverStaticObjectComponentData {
    fn acceleration(&self) -> &f32 {
        &self.acceleration
    }
    fn acceleration_mut(&mut self) -> &mut f32 {
        &mut self.acceleration
    }
    fn deceleration(&self) -> &f32 {
        &self.deceleration
    }
    fn deceleration_mut(&mut self) -> &mut f32 {
        &mut self.deceleration
    }
    fn turning_radius(&self) -> &f32 {
        &self.turning_radius
    }
    fn turning_radius_mut(&mut self) -> &mut f32 {
        &mut self.turning_radius
    }
    fn turn_while_still(&self) -> &bool {
        &self.turn_while_still
    }
    fn turn_while_still_mut(&mut self) -> &mut bool {
        &mut self.turn_while_still
    }
    fn align_with_ground_normal(&self) -> &bool {
        &self.align_with_ground_normal
    }
    fn align_with_ground_normal_mut(&mut self) -> &mut bool {
        &mut self.align_with_ground_normal
    }
}

impl DriverComponentDataTrait for DriverStaticObjectComponentData {
    fn wanted_speed(&self) -> &f32 {
        self._glacier_base.wanted_speed()
    }
    fn wanted_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.wanted_speed_mut()
    }
    fn settings(&self) -> &Option<LockedTypeObject /* DriverSettings */> {
        self._glacier_base.settings()
    }
    fn settings_mut(&mut self) -> &mut Option<LockedTypeObject /* DriverSettings */> {
        self._glacier_base.settings_mut()
    }
    fn control_vehicle(&self) -> &bool {
        self._glacier_base.control_vehicle()
    }
    fn control_vehicle_mut(&mut self) -> &mut bool {
        self._glacier_base.control_vehicle_mut()
    }
    fn invert_steering_on_reverse(&self) -> &bool {
        self._glacier_base.invert_steering_on_reverse()
    }
    fn invert_steering_on_reverse_mut(&mut self) -> &mut bool {
        self._glacier_base.invert_steering_on_reverse_mut()
    }
}

impl super::entity::GameComponentDataTrait for DriverStaticObjectComponentData {
}

impl super::entity::ComponentDataTrait for DriverStaticObjectComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DriverStaticObjectComponentData {
}

impl super::core::DataBusPeerTrait for DriverStaticObjectComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DriverStaticObjectComponentData {
}

impl super::core::DataContainerTrait for DriverStaticObjectComponentData {
}

pub static DRIVERSTATICOBJECTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverStaticObjectComponentData",
    name_hash: 1896980361,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DRIVERCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(DriverStaticObjectComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DriverStaticObjectComponentData as Default>::default())),
            create_boxed: || Box::new(<DriverStaticObjectComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Acceleration",
                name_hash: 62601415,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverStaticObjectComponentData, acceleration),
            },
            FieldInfoData {
                name: "Deceleration",
                name_hash: 8356516,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverStaticObjectComponentData, deceleration),
            },
            FieldInfoData {
                name: "TurningRadius",
                name_hash: 4134465344,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverStaticObjectComponentData, turning_radius),
            },
            FieldInfoData {
                name: "TurnWhileStill",
                name_hash: 2034681993,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverStaticObjectComponentData, turn_while_still),
            },
            FieldInfoData {
                name: "AlignWithGroundNormal",
                name_hash: 387843516,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverStaticObjectComponentData, align_with_ground_normal),
            },
        ],
    }),
    array_type: Some(DRIVERSTATICOBJECTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DriverStaticObjectComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DRIVERSTATICOBJECTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DRIVERSTATICOBJECTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverStaticObjectComponentData-Array",
    name_hash: 2241074493,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DriverStaticObjectComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DriverComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub wanted_speed: f32,
    pub settings: Option<LockedTypeObject /* DriverSettings */>,
    pub control_vehicle: bool,
    pub invert_steering_on_reverse: bool,
}

pub trait DriverComponentDataTrait: super::entity::GameComponentDataTrait {
    fn wanted_speed(&self) -> &f32;
    fn wanted_speed_mut(&mut self) -> &mut f32;
    fn settings(&self) -> &Option<LockedTypeObject /* DriverSettings */>;
    fn settings_mut(&mut self) -> &mut Option<LockedTypeObject /* DriverSettings */>;
    fn control_vehicle(&self) -> &bool;
    fn control_vehicle_mut(&mut self) -> &mut bool;
    fn invert_steering_on_reverse(&self) -> &bool;
    fn invert_steering_on_reverse_mut(&mut self) -> &mut bool;
}

impl DriverComponentDataTrait for DriverComponentData {
    fn wanted_speed(&self) -> &f32 {
        &self.wanted_speed
    }
    fn wanted_speed_mut(&mut self) -> &mut f32 {
        &mut self.wanted_speed
    }
    fn settings(&self) -> &Option<LockedTypeObject /* DriverSettings */> {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut Option<LockedTypeObject /* DriverSettings */> {
        &mut self.settings
    }
    fn control_vehicle(&self) -> &bool {
        &self.control_vehicle
    }
    fn control_vehicle_mut(&mut self) -> &mut bool {
        &mut self.control_vehicle
    }
    fn invert_steering_on_reverse(&self) -> &bool {
        &self.invert_steering_on_reverse
    }
    fn invert_steering_on_reverse_mut(&mut self) -> &mut bool {
        &mut self.invert_steering_on_reverse
    }
}

impl super::entity::GameComponentDataTrait for DriverComponentData {
}

impl super::entity::ComponentDataTrait for DriverComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DriverComponentData {
}

impl super::core::DataBusPeerTrait for DriverComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DriverComponentData {
}

impl super::core::DataContainerTrait for DriverComponentData {
}

pub static DRIVERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverComponentData",
    name_hash: 1740173060,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(DriverComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DriverComponentData as Default>::default())),
            create_boxed: || Box::new(<DriverComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "WantedSpeed",
                name_hash: 3561027151,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverComponentData, wanted_speed),
            },
            FieldInfoData {
                name: "Settings",
                name_hash: 649772672,
                flags: MemberInfoFlags::new(0),
                field_type: "DriverSettings",
                rust_offset: offset_of!(DriverComponentData, settings),
            },
            FieldInfoData {
                name: "ControlVehicle",
                name_hash: 1756850426,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverComponentData, control_vehicle),
            },
            FieldInfoData {
                name: "InvertSteeringOnReverse",
                name_hash: 91739811,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverComponentData, invert_steering_on_reverse),
            },
        ],
    }),
    array_type: Some(DRIVERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DriverComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DRIVERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DRIVERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverComponentData-Array",
    name_hash: 1984856880,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DriverComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DriverSettings {
    pub _glacier_base: super::core::Asset,
    pub use_corridor_to_limit_dynamic_radius: bool,
    pub use_inverted_input_to_get_unstuck: bool,
    pub use_inverted_input_for_points_within_turn_radius: bool,
    pub short_probe_distance: f32,
    pub long_probe_distance: f32,
    pub align_large_angle: f32,
    pub align_small_angle: f32,
    pub min_radius: f32,
    pub radius_growth_speed: f32,
    pub stopping_deceleration: f32,
    pub steering_sensitivity: f32,
    pub regulated_steering: Option<LockedTypeObject /* RegulatedSteering */>,
    pub max_brake_output: f32,
    pub min_brake_output: f32,
    pub square_brake_output: bool,
    pub look_ahead_time: f32,
    pub angle_diff_for_no_slowdown: f32,
    pub angle_diff_for_full_slowdown: f32,
    pub velocity_at_full_slowdown: f32,
    pub vel_diff_at_min_acc: f32,
    pub vel_diff_at_max_acc: f32,
    pub use_square_vel_diff_curve_acc: bool,
    pub min_acc: f32,
    pub max_acc: f32,
    pub vel_diff_at_min_dec: f32,
    pub vel_diff_at_max_dec: f32,
    pub use_square_vel_diff_curve_dec: bool,
    pub min_dec: f32,
    pub max_dec: f32,
    pub acc_diff_at_min_throttle_velocity_accelerating: f32,
    pub acc_diff_at_max_throttle_velocity_accelerating: f32,
    pub use_square_acc_diff_curve_acc: bool,
    pub min_throttle_velocity_accelerating: f32,
    pub max_throttle_velocity_accelerating: f32,
    pub acc_diff_at_min_throttle_velocity_decelerating: f32,
    pub acc_diff_at_max_throttle_velocity_decelerating: f32,
    pub use_square_acc_diff_curve_dec: bool,
    pub min_throttle_velocity_decelerating: f32,
    pub max_throttle_velocity_decelerating: f32,
    pub use_p_i_d_regulator: bool,
    pub p: f32,
    pub i: f32,
    pub d: f32,
    pub max_error: f32,
    pub max_sum_error: f32,
    pub max_p_term: f32,
    pub max_i_term: f32,
    pub max_d_term: f32,
    pub max_yaw_to_apply_sprint: f32,
    pub max_angle_diff_to_apply_sprint: f32,
    pub max_angular_velocity_to_apply_sprint: f32,
    pub min_velocity_to_apply_sprint: f32,
    pub include_y_difference: bool,
    pub look_ahead_aim_time: f32,
    pub min_look_ahead_dist: f32,
}

pub trait DriverSettingsTrait: super::core::AssetTrait {
    fn use_corridor_to_limit_dynamic_radius(&self) -> &bool;
    fn use_corridor_to_limit_dynamic_radius_mut(&mut self) -> &mut bool;
    fn use_inverted_input_to_get_unstuck(&self) -> &bool;
    fn use_inverted_input_to_get_unstuck_mut(&mut self) -> &mut bool;
    fn use_inverted_input_for_points_within_turn_radius(&self) -> &bool;
    fn use_inverted_input_for_points_within_turn_radius_mut(&mut self) -> &mut bool;
    fn short_probe_distance(&self) -> &f32;
    fn short_probe_distance_mut(&mut self) -> &mut f32;
    fn long_probe_distance(&self) -> &f32;
    fn long_probe_distance_mut(&mut self) -> &mut f32;
    fn align_large_angle(&self) -> &f32;
    fn align_large_angle_mut(&mut self) -> &mut f32;
    fn align_small_angle(&self) -> &f32;
    fn align_small_angle_mut(&mut self) -> &mut f32;
    fn min_radius(&self) -> &f32;
    fn min_radius_mut(&mut self) -> &mut f32;
    fn radius_growth_speed(&self) -> &f32;
    fn radius_growth_speed_mut(&mut self) -> &mut f32;
    fn stopping_deceleration(&self) -> &f32;
    fn stopping_deceleration_mut(&mut self) -> &mut f32;
    fn steering_sensitivity(&self) -> &f32;
    fn steering_sensitivity_mut(&mut self) -> &mut f32;
    fn regulated_steering(&self) -> &Option<LockedTypeObject /* RegulatedSteering */>;
    fn regulated_steering_mut(&mut self) -> &mut Option<LockedTypeObject /* RegulatedSteering */>;
    fn max_brake_output(&self) -> &f32;
    fn max_brake_output_mut(&mut self) -> &mut f32;
    fn min_brake_output(&self) -> &f32;
    fn min_brake_output_mut(&mut self) -> &mut f32;
    fn square_brake_output(&self) -> &bool;
    fn square_brake_output_mut(&mut self) -> &mut bool;
    fn look_ahead_time(&self) -> &f32;
    fn look_ahead_time_mut(&mut self) -> &mut f32;
    fn angle_diff_for_no_slowdown(&self) -> &f32;
    fn angle_diff_for_no_slowdown_mut(&mut self) -> &mut f32;
    fn angle_diff_for_full_slowdown(&self) -> &f32;
    fn angle_diff_for_full_slowdown_mut(&mut self) -> &mut f32;
    fn velocity_at_full_slowdown(&self) -> &f32;
    fn velocity_at_full_slowdown_mut(&mut self) -> &mut f32;
    fn vel_diff_at_min_acc(&self) -> &f32;
    fn vel_diff_at_min_acc_mut(&mut self) -> &mut f32;
    fn vel_diff_at_max_acc(&self) -> &f32;
    fn vel_diff_at_max_acc_mut(&mut self) -> &mut f32;
    fn use_square_vel_diff_curve_acc(&self) -> &bool;
    fn use_square_vel_diff_curve_acc_mut(&mut self) -> &mut bool;
    fn min_acc(&self) -> &f32;
    fn min_acc_mut(&mut self) -> &mut f32;
    fn max_acc(&self) -> &f32;
    fn max_acc_mut(&mut self) -> &mut f32;
    fn vel_diff_at_min_dec(&self) -> &f32;
    fn vel_diff_at_min_dec_mut(&mut self) -> &mut f32;
    fn vel_diff_at_max_dec(&self) -> &f32;
    fn vel_diff_at_max_dec_mut(&mut self) -> &mut f32;
    fn use_square_vel_diff_curve_dec(&self) -> &bool;
    fn use_square_vel_diff_curve_dec_mut(&mut self) -> &mut bool;
    fn min_dec(&self) -> &f32;
    fn min_dec_mut(&mut self) -> &mut f32;
    fn max_dec(&self) -> &f32;
    fn max_dec_mut(&mut self) -> &mut f32;
    fn acc_diff_at_min_throttle_velocity_accelerating(&self) -> &f32;
    fn acc_diff_at_min_throttle_velocity_accelerating_mut(&mut self) -> &mut f32;
    fn acc_diff_at_max_throttle_velocity_accelerating(&self) -> &f32;
    fn acc_diff_at_max_throttle_velocity_accelerating_mut(&mut self) -> &mut f32;
    fn use_square_acc_diff_curve_acc(&self) -> &bool;
    fn use_square_acc_diff_curve_acc_mut(&mut self) -> &mut bool;
    fn min_throttle_velocity_accelerating(&self) -> &f32;
    fn min_throttle_velocity_accelerating_mut(&mut self) -> &mut f32;
    fn max_throttle_velocity_accelerating(&self) -> &f32;
    fn max_throttle_velocity_accelerating_mut(&mut self) -> &mut f32;
    fn acc_diff_at_min_throttle_velocity_decelerating(&self) -> &f32;
    fn acc_diff_at_min_throttle_velocity_decelerating_mut(&mut self) -> &mut f32;
    fn acc_diff_at_max_throttle_velocity_decelerating(&self) -> &f32;
    fn acc_diff_at_max_throttle_velocity_decelerating_mut(&mut self) -> &mut f32;
    fn use_square_acc_diff_curve_dec(&self) -> &bool;
    fn use_square_acc_diff_curve_dec_mut(&mut self) -> &mut bool;
    fn min_throttle_velocity_decelerating(&self) -> &f32;
    fn min_throttle_velocity_decelerating_mut(&mut self) -> &mut f32;
    fn max_throttle_velocity_decelerating(&self) -> &f32;
    fn max_throttle_velocity_decelerating_mut(&mut self) -> &mut f32;
    fn use_p_i_d_regulator(&self) -> &bool;
    fn use_p_i_d_regulator_mut(&mut self) -> &mut bool;
    fn p(&self) -> &f32;
    fn p_mut(&mut self) -> &mut f32;
    fn i(&self) -> &f32;
    fn i_mut(&mut self) -> &mut f32;
    fn d(&self) -> &f32;
    fn d_mut(&mut self) -> &mut f32;
    fn max_error(&self) -> &f32;
    fn max_error_mut(&mut self) -> &mut f32;
    fn max_sum_error(&self) -> &f32;
    fn max_sum_error_mut(&mut self) -> &mut f32;
    fn max_p_term(&self) -> &f32;
    fn max_p_term_mut(&mut self) -> &mut f32;
    fn max_i_term(&self) -> &f32;
    fn max_i_term_mut(&mut self) -> &mut f32;
    fn max_d_term(&self) -> &f32;
    fn max_d_term_mut(&mut self) -> &mut f32;
    fn max_yaw_to_apply_sprint(&self) -> &f32;
    fn max_yaw_to_apply_sprint_mut(&mut self) -> &mut f32;
    fn max_angle_diff_to_apply_sprint(&self) -> &f32;
    fn max_angle_diff_to_apply_sprint_mut(&mut self) -> &mut f32;
    fn max_angular_velocity_to_apply_sprint(&self) -> &f32;
    fn max_angular_velocity_to_apply_sprint_mut(&mut self) -> &mut f32;
    fn min_velocity_to_apply_sprint(&self) -> &f32;
    fn min_velocity_to_apply_sprint_mut(&mut self) -> &mut f32;
    fn include_y_difference(&self) -> &bool;
    fn include_y_difference_mut(&mut self) -> &mut bool;
    fn look_ahead_aim_time(&self) -> &f32;
    fn look_ahead_aim_time_mut(&mut self) -> &mut f32;
    fn min_look_ahead_dist(&self) -> &f32;
    fn min_look_ahead_dist_mut(&mut self) -> &mut f32;
}

impl DriverSettingsTrait for DriverSettings {
    fn use_corridor_to_limit_dynamic_radius(&self) -> &bool {
        &self.use_corridor_to_limit_dynamic_radius
    }
    fn use_corridor_to_limit_dynamic_radius_mut(&mut self) -> &mut bool {
        &mut self.use_corridor_to_limit_dynamic_radius
    }
    fn use_inverted_input_to_get_unstuck(&self) -> &bool {
        &self.use_inverted_input_to_get_unstuck
    }
    fn use_inverted_input_to_get_unstuck_mut(&mut self) -> &mut bool {
        &mut self.use_inverted_input_to_get_unstuck
    }
    fn use_inverted_input_for_points_within_turn_radius(&self) -> &bool {
        &self.use_inverted_input_for_points_within_turn_radius
    }
    fn use_inverted_input_for_points_within_turn_radius_mut(&mut self) -> &mut bool {
        &mut self.use_inverted_input_for_points_within_turn_radius
    }
    fn short_probe_distance(&self) -> &f32 {
        &self.short_probe_distance
    }
    fn short_probe_distance_mut(&mut self) -> &mut f32 {
        &mut self.short_probe_distance
    }
    fn long_probe_distance(&self) -> &f32 {
        &self.long_probe_distance
    }
    fn long_probe_distance_mut(&mut self) -> &mut f32 {
        &mut self.long_probe_distance
    }
    fn align_large_angle(&self) -> &f32 {
        &self.align_large_angle
    }
    fn align_large_angle_mut(&mut self) -> &mut f32 {
        &mut self.align_large_angle
    }
    fn align_small_angle(&self) -> &f32 {
        &self.align_small_angle
    }
    fn align_small_angle_mut(&mut self) -> &mut f32 {
        &mut self.align_small_angle
    }
    fn min_radius(&self) -> &f32 {
        &self.min_radius
    }
    fn min_radius_mut(&mut self) -> &mut f32 {
        &mut self.min_radius
    }
    fn radius_growth_speed(&self) -> &f32 {
        &self.radius_growth_speed
    }
    fn radius_growth_speed_mut(&mut self) -> &mut f32 {
        &mut self.radius_growth_speed
    }
    fn stopping_deceleration(&self) -> &f32 {
        &self.stopping_deceleration
    }
    fn stopping_deceleration_mut(&mut self) -> &mut f32 {
        &mut self.stopping_deceleration
    }
    fn steering_sensitivity(&self) -> &f32 {
        &self.steering_sensitivity
    }
    fn steering_sensitivity_mut(&mut self) -> &mut f32 {
        &mut self.steering_sensitivity
    }
    fn regulated_steering(&self) -> &Option<LockedTypeObject /* RegulatedSteering */> {
        &self.regulated_steering
    }
    fn regulated_steering_mut(&mut self) -> &mut Option<LockedTypeObject /* RegulatedSteering */> {
        &mut self.regulated_steering
    }
    fn max_brake_output(&self) -> &f32 {
        &self.max_brake_output
    }
    fn max_brake_output_mut(&mut self) -> &mut f32 {
        &mut self.max_brake_output
    }
    fn min_brake_output(&self) -> &f32 {
        &self.min_brake_output
    }
    fn min_brake_output_mut(&mut self) -> &mut f32 {
        &mut self.min_brake_output
    }
    fn square_brake_output(&self) -> &bool {
        &self.square_brake_output
    }
    fn square_brake_output_mut(&mut self) -> &mut bool {
        &mut self.square_brake_output
    }
    fn look_ahead_time(&self) -> &f32 {
        &self.look_ahead_time
    }
    fn look_ahead_time_mut(&mut self) -> &mut f32 {
        &mut self.look_ahead_time
    }
    fn angle_diff_for_no_slowdown(&self) -> &f32 {
        &self.angle_diff_for_no_slowdown
    }
    fn angle_diff_for_no_slowdown_mut(&mut self) -> &mut f32 {
        &mut self.angle_diff_for_no_slowdown
    }
    fn angle_diff_for_full_slowdown(&self) -> &f32 {
        &self.angle_diff_for_full_slowdown
    }
    fn angle_diff_for_full_slowdown_mut(&mut self) -> &mut f32 {
        &mut self.angle_diff_for_full_slowdown
    }
    fn velocity_at_full_slowdown(&self) -> &f32 {
        &self.velocity_at_full_slowdown
    }
    fn velocity_at_full_slowdown_mut(&mut self) -> &mut f32 {
        &mut self.velocity_at_full_slowdown
    }
    fn vel_diff_at_min_acc(&self) -> &f32 {
        &self.vel_diff_at_min_acc
    }
    fn vel_diff_at_min_acc_mut(&mut self) -> &mut f32 {
        &mut self.vel_diff_at_min_acc
    }
    fn vel_diff_at_max_acc(&self) -> &f32 {
        &self.vel_diff_at_max_acc
    }
    fn vel_diff_at_max_acc_mut(&mut self) -> &mut f32 {
        &mut self.vel_diff_at_max_acc
    }
    fn use_square_vel_diff_curve_acc(&self) -> &bool {
        &self.use_square_vel_diff_curve_acc
    }
    fn use_square_vel_diff_curve_acc_mut(&mut self) -> &mut bool {
        &mut self.use_square_vel_diff_curve_acc
    }
    fn min_acc(&self) -> &f32 {
        &self.min_acc
    }
    fn min_acc_mut(&mut self) -> &mut f32 {
        &mut self.min_acc
    }
    fn max_acc(&self) -> &f32 {
        &self.max_acc
    }
    fn max_acc_mut(&mut self) -> &mut f32 {
        &mut self.max_acc
    }
    fn vel_diff_at_min_dec(&self) -> &f32 {
        &self.vel_diff_at_min_dec
    }
    fn vel_diff_at_min_dec_mut(&mut self) -> &mut f32 {
        &mut self.vel_diff_at_min_dec
    }
    fn vel_diff_at_max_dec(&self) -> &f32 {
        &self.vel_diff_at_max_dec
    }
    fn vel_diff_at_max_dec_mut(&mut self) -> &mut f32 {
        &mut self.vel_diff_at_max_dec
    }
    fn use_square_vel_diff_curve_dec(&self) -> &bool {
        &self.use_square_vel_diff_curve_dec
    }
    fn use_square_vel_diff_curve_dec_mut(&mut self) -> &mut bool {
        &mut self.use_square_vel_diff_curve_dec
    }
    fn min_dec(&self) -> &f32 {
        &self.min_dec
    }
    fn min_dec_mut(&mut self) -> &mut f32 {
        &mut self.min_dec
    }
    fn max_dec(&self) -> &f32 {
        &self.max_dec
    }
    fn max_dec_mut(&mut self) -> &mut f32 {
        &mut self.max_dec
    }
    fn acc_diff_at_min_throttle_velocity_accelerating(&self) -> &f32 {
        &self.acc_diff_at_min_throttle_velocity_accelerating
    }
    fn acc_diff_at_min_throttle_velocity_accelerating_mut(&mut self) -> &mut f32 {
        &mut self.acc_diff_at_min_throttle_velocity_accelerating
    }
    fn acc_diff_at_max_throttle_velocity_accelerating(&self) -> &f32 {
        &self.acc_diff_at_max_throttle_velocity_accelerating
    }
    fn acc_diff_at_max_throttle_velocity_accelerating_mut(&mut self) -> &mut f32 {
        &mut self.acc_diff_at_max_throttle_velocity_accelerating
    }
    fn use_square_acc_diff_curve_acc(&self) -> &bool {
        &self.use_square_acc_diff_curve_acc
    }
    fn use_square_acc_diff_curve_acc_mut(&mut self) -> &mut bool {
        &mut self.use_square_acc_diff_curve_acc
    }
    fn min_throttle_velocity_accelerating(&self) -> &f32 {
        &self.min_throttle_velocity_accelerating
    }
    fn min_throttle_velocity_accelerating_mut(&mut self) -> &mut f32 {
        &mut self.min_throttle_velocity_accelerating
    }
    fn max_throttle_velocity_accelerating(&self) -> &f32 {
        &self.max_throttle_velocity_accelerating
    }
    fn max_throttle_velocity_accelerating_mut(&mut self) -> &mut f32 {
        &mut self.max_throttle_velocity_accelerating
    }
    fn acc_diff_at_min_throttle_velocity_decelerating(&self) -> &f32 {
        &self.acc_diff_at_min_throttle_velocity_decelerating
    }
    fn acc_diff_at_min_throttle_velocity_decelerating_mut(&mut self) -> &mut f32 {
        &mut self.acc_diff_at_min_throttle_velocity_decelerating
    }
    fn acc_diff_at_max_throttle_velocity_decelerating(&self) -> &f32 {
        &self.acc_diff_at_max_throttle_velocity_decelerating
    }
    fn acc_diff_at_max_throttle_velocity_decelerating_mut(&mut self) -> &mut f32 {
        &mut self.acc_diff_at_max_throttle_velocity_decelerating
    }
    fn use_square_acc_diff_curve_dec(&self) -> &bool {
        &self.use_square_acc_diff_curve_dec
    }
    fn use_square_acc_diff_curve_dec_mut(&mut self) -> &mut bool {
        &mut self.use_square_acc_diff_curve_dec
    }
    fn min_throttle_velocity_decelerating(&self) -> &f32 {
        &self.min_throttle_velocity_decelerating
    }
    fn min_throttle_velocity_decelerating_mut(&mut self) -> &mut f32 {
        &mut self.min_throttle_velocity_decelerating
    }
    fn max_throttle_velocity_decelerating(&self) -> &f32 {
        &self.max_throttle_velocity_decelerating
    }
    fn max_throttle_velocity_decelerating_mut(&mut self) -> &mut f32 {
        &mut self.max_throttle_velocity_decelerating
    }
    fn use_p_i_d_regulator(&self) -> &bool {
        &self.use_p_i_d_regulator
    }
    fn use_p_i_d_regulator_mut(&mut self) -> &mut bool {
        &mut self.use_p_i_d_regulator
    }
    fn p(&self) -> &f32 {
        &self.p
    }
    fn p_mut(&mut self) -> &mut f32 {
        &mut self.p
    }
    fn i(&self) -> &f32 {
        &self.i
    }
    fn i_mut(&mut self) -> &mut f32 {
        &mut self.i
    }
    fn d(&self) -> &f32 {
        &self.d
    }
    fn d_mut(&mut self) -> &mut f32 {
        &mut self.d
    }
    fn max_error(&self) -> &f32 {
        &self.max_error
    }
    fn max_error_mut(&mut self) -> &mut f32 {
        &mut self.max_error
    }
    fn max_sum_error(&self) -> &f32 {
        &self.max_sum_error
    }
    fn max_sum_error_mut(&mut self) -> &mut f32 {
        &mut self.max_sum_error
    }
    fn max_p_term(&self) -> &f32 {
        &self.max_p_term
    }
    fn max_p_term_mut(&mut self) -> &mut f32 {
        &mut self.max_p_term
    }
    fn max_i_term(&self) -> &f32 {
        &self.max_i_term
    }
    fn max_i_term_mut(&mut self) -> &mut f32 {
        &mut self.max_i_term
    }
    fn max_d_term(&self) -> &f32 {
        &self.max_d_term
    }
    fn max_d_term_mut(&mut self) -> &mut f32 {
        &mut self.max_d_term
    }
    fn max_yaw_to_apply_sprint(&self) -> &f32 {
        &self.max_yaw_to_apply_sprint
    }
    fn max_yaw_to_apply_sprint_mut(&mut self) -> &mut f32 {
        &mut self.max_yaw_to_apply_sprint
    }
    fn max_angle_diff_to_apply_sprint(&self) -> &f32 {
        &self.max_angle_diff_to_apply_sprint
    }
    fn max_angle_diff_to_apply_sprint_mut(&mut self) -> &mut f32 {
        &mut self.max_angle_diff_to_apply_sprint
    }
    fn max_angular_velocity_to_apply_sprint(&self) -> &f32 {
        &self.max_angular_velocity_to_apply_sprint
    }
    fn max_angular_velocity_to_apply_sprint_mut(&mut self) -> &mut f32 {
        &mut self.max_angular_velocity_to_apply_sprint
    }
    fn min_velocity_to_apply_sprint(&self) -> &f32 {
        &self.min_velocity_to_apply_sprint
    }
    fn min_velocity_to_apply_sprint_mut(&mut self) -> &mut f32 {
        &mut self.min_velocity_to_apply_sprint
    }
    fn include_y_difference(&self) -> &bool {
        &self.include_y_difference
    }
    fn include_y_difference_mut(&mut self) -> &mut bool {
        &mut self.include_y_difference
    }
    fn look_ahead_aim_time(&self) -> &f32 {
        &self.look_ahead_aim_time
    }
    fn look_ahead_aim_time_mut(&mut self) -> &mut f32 {
        &mut self.look_ahead_aim_time
    }
    fn min_look_ahead_dist(&self) -> &f32 {
        &self.min_look_ahead_dist
    }
    fn min_look_ahead_dist_mut(&mut self) -> &mut f32 {
        &mut self.min_look_ahead_dist
    }
}

impl super::core::AssetTrait for DriverSettings {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for DriverSettings {
}

pub static DRIVERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverSettings",
    name_hash: 1356469694,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(DriverSettings, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DriverSettings as Default>::default())),
            create_boxed: || Box::new(<DriverSettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "UseCorridorToLimitDynamicRadius",
                name_hash: 1900393977,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_corridor_to_limit_dynamic_radius),
            },
            FieldInfoData {
                name: "UseInvertedInputToGetUnstuck",
                name_hash: 991692047,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_inverted_input_to_get_unstuck),
            },
            FieldInfoData {
                name: "UseInvertedInputForPointsWithinTurnRadius",
                name_hash: 3629228775,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_inverted_input_for_points_within_turn_radius),
            },
            FieldInfoData {
                name: "ShortProbeDistance",
                name_hash: 3447433502,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, short_probe_distance),
            },
            FieldInfoData {
                name: "LongProbeDistance",
                name_hash: 184505734,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, long_probe_distance),
            },
            FieldInfoData {
                name: "AlignLargeAngle",
                name_hash: 4166628212,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, align_large_angle),
            },
            FieldInfoData {
                name: "AlignSmallAngle",
                name_hash: 2525239318,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, align_small_angle),
            },
            FieldInfoData {
                name: "MinRadius",
                name_hash: 4053568023,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_radius),
            },
            FieldInfoData {
                name: "RadiusGrowthSpeed",
                name_hash: 2845828299,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, radius_growth_speed),
            },
            FieldInfoData {
                name: "StoppingDeceleration",
                name_hash: 2524085644,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, stopping_deceleration),
            },
            FieldInfoData {
                name: "SteeringSensitivity",
                name_hash: 1426555133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, steering_sensitivity),
            },
            FieldInfoData {
                name: "RegulatedSteering",
                name_hash: 3387634253,
                flags: MemberInfoFlags::new(0),
                field_type: "RegulatedSteering",
                rust_offset: offset_of!(DriverSettings, regulated_steering),
            },
            FieldInfoData {
                name: "MaxBrakeOutput",
                name_hash: 3490155569,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_brake_output),
            },
            FieldInfoData {
                name: "MinBrakeOutput",
                name_hash: 1016767471,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_brake_output),
            },
            FieldInfoData {
                name: "SquareBrakeOutput",
                name_hash: 4011213668,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, square_brake_output),
            },
            FieldInfoData {
                name: "LookAheadTime",
                name_hash: 3422362878,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, look_ahead_time),
            },
            FieldInfoData {
                name: "AngleDiffForNoSlowdown",
                name_hash: 2445158886,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, angle_diff_for_no_slowdown),
            },
            FieldInfoData {
                name: "AngleDiffForFullSlowdown",
                name_hash: 2342024436,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, angle_diff_for_full_slowdown),
            },
            FieldInfoData {
                name: "VelocityAtFullSlowdown",
                name_hash: 2165330977,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, velocity_at_full_slowdown),
            },
            FieldInfoData {
                name: "VelDiffAtMinAcc",
                name_hash: 391295721,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, vel_diff_at_min_acc),
            },
            FieldInfoData {
                name: "VelDiffAtMaxAcc",
                name_hash: 401137847,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, vel_diff_at_max_acc),
            },
            FieldInfoData {
                name: "UseSquareVelDiffCurveAcc",
                name_hash: 2792641955,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_square_vel_diff_curve_acc),
            },
            FieldInfoData {
                name: "MinAcc",
                name_hash: 2633700366,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_acc),
            },
            FieldInfoData {
                name: "MaxAcc",
                name_hash: 2642832976,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_acc),
            },
            FieldInfoData {
                name: "VelDiffAtMinDec",
                name_hash: 391300970,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, vel_diff_at_min_dec),
            },
            FieldInfoData {
                name: "VelDiffAtMaxDec",
                name_hash: 401134772,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, vel_diff_at_max_dec),
            },
            FieldInfoData {
                name: "UseSquareVelDiffCurveDec",
                name_hash: 2792647328,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_square_vel_diff_curve_dec),
            },
            FieldInfoData {
                name: "MinDec",
                name_hash: 2633695117,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_dec),
            },
            FieldInfoData {
                name: "MaxDec",
                name_hash: 2642836051,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_dec),
            },
            FieldInfoData {
                name: "AccDiffAtMinThrottleVelocityAccelerating",
                name_hash: 3857427267,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, acc_diff_at_min_throttle_velocity_accelerating),
            },
            FieldInfoData {
                name: "AccDiffAtMaxThrottleVelocityAccelerating",
                name_hash: 3986228061,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, acc_diff_at_max_throttle_velocity_accelerating),
            },
            FieldInfoData {
                name: "UseSquareAccDiffCurveAcc",
                name_hash: 3859833405,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_square_acc_diff_curve_acc),
            },
            FieldInfoData {
                name: "MinThrottleVelocityAccelerating",
                name_hash: 2561805594,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_throttle_velocity_accelerating),
            },
            FieldInfoData {
                name: "MaxThrottleVelocityAccelerating",
                name_hash: 1704883972,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_throttle_velocity_accelerating),
            },
            FieldInfoData {
                name: "AccDiffAtMinThrottleVelocityDecelerating",
                name_hash: 2612984288,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, acc_diff_at_min_throttle_velocity_decelerating),
            },
            FieldInfoData {
                name: "AccDiffAtMaxThrottleVelocityDecelerating",
                name_hash: 203251454,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, acc_diff_at_max_throttle_velocity_decelerating),
            },
            FieldInfoData {
                name: "UseSquareAccDiffCurveDec",
                name_hash: 3859830206,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_square_acc_diff_curve_dec),
            },
            FieldInfoData {
                name: "MinThrottleVelocityDecelerating",
                name_hash: 1371861369,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_throttle_velocity_decelerating),
            },
            FieldInfoData {
                name: "MaxThrottleVelocityDecelerating",
                name_hash: 203746407,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_throttle_velocity_decelerating),
            },
            FieldInfoData {
                name: "UsePIDRegulator",
                name_hash: 4246854618,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_p_i_d_regulator),
            },
            FieldInfoData {
                name: "P",
                name_hash: 177653,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, p),
            },
            FieldInfoData {
                name: "I",
                name_hash: 177644,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, i),
            },
            FieldInfoData {
                name: "D",
                name_hash: 177633,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, d),
            },
            FieldInfoData {
                name: "MaxError",
                name_hash: 421240457,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_error),
            },
            FieldInfoData {
                name: "MaxSumError",
                name_hash: 859402786,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_sum_error),
            },
            FieldInfoData {
                name: "MaxPTerm",
                name_hash: 396390927,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_p_term),
            },
            FieldInfoData {
                name: "MaxITerm",
                name_hash: 426983126,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_i_term),
            },
            FieldInfoData {
                name: "MaxDTerm",
                name_hash: 418681627,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_d_term),
            },
            FieldInfoData {
                name: "MaxYawToApplySprint",
                name_hash: 3013304403,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_yaw_to_apply_sprint),
            },
            FieldInfoData {
                name: "MaxAngleDiffToApplySprint",
                name_hash: 3499467120,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_angle_diff_to_apply_sprint),
            },
            FieldInfoData {
                name: "MaxAngularVelocityToApplySprint",
                name_hash: 3795038761,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_angular_velocity_to_apply_sprint),
            },
            FieldInfoData {
                name: "MinVelocityToApplySprint",
                name_hash: 240098261,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_velocity_to_apply_sprint),
            },
            FieldInfoData {
                name: "IncludeYDifference",
                name_hash: 69110999,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, include_y_difference),
            },
            FieldInfoData {
                name: "LookAheadAimTime",
                name_hash: 161286395,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, look_ahead_aim_time),
            },
            FieldInfoData {
                name: "MinLookAheadDist",
                name_hash: 2606402859,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_look_ahead_dist),
            },
        ],
    }),
    array_type: Some(DRIVERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DriverSettings {
    fn type_info(&self) -> &'static TypeInfo {
        DRIVERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DRIVERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverSettings-Array",
    name_hash: 1430029834,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DriverSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RegulatedSteering {
    pub _glacier_base: super::core::DataContainer,
    pub p_i_d: PID,
}

pub trait RegulatedSteeringTrait: super::core::DataContainerTrait {
    fn p_i_d(&self) -> &PID;
    fn p_i_d_mut(&mut self) -> &mut PID;
}

impl RegulatedSteeringTrait for RegulatedSteering {
    fn p_i_d(&self) -> &PID {
        &self.p_i_d
    }
    fn p_i_d_mut(&mut self) -> &mut PID {
        &mut self.p_i_d
    }
}

impl super::core::DataContainerTrait for RegulatedSteering {
}

pub static REGULATEDSTEERING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RegulatedSteering",
    name_hash: 3387634253,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(RegulatedSteering, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RegulatedSteering as Default>::default())),
            create_boxed: || Box::new(<RegulatedSteering as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PID",
                name_hash: 193466392,
                flags: MemberInfoFlags::new(0),
                field_type: "PID",
                rust_offset: offset_of!(RegulatedSteering, p_i_d),
            },
        ],
    }),
    array_type: Some(REGULATEDSTEERING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RegulatedSteering {
    fn type_info(&self) -> &'static TypeInfo {
        REGULATEDSTEERING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REGULATEDSTEERING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RegulatedSteering-Array",
    name_hash: 3892078201,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RegulatedSteering"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PID {
    pub p: f32,
    pub i: f32,
    pub d: f32,
    pub max_error: f32,
    pub max_p_term: f32,
    pub max_i_term: f32,
    pub max_d_term: f32,
    pub max_sum_error: f32,
}

pub trait PIDTrait: TypeObject {
    fn p(&self) -> &f32;
    fn p_mut(&mut self) -> &mut f32;
    fn i(&self) -> &f32;
    fn i_mut(&mut self) -> &mut f32;
    fn d(&self) -> &f32;
    fn d_mut(&mut self) -> &mut f32;
    fn max_error(&self) -> &f32;
    fn max_error_mut(&mut self) -> &mut f32;
    fn max_p_term(&self) -> &f32;
    fn max_p_term_mut(&mut self) -> &mut f32;
    fn max_i_term(&self) -> &f32;
    fn max_i_term_mut(&mut self) -> &mut f32;
    fn max_d_term(&self) -> &f32;
    fn max_d_term_mut(&mut self) -> &mut f32;
    fn max_sum_error(&self) -> &f32;
    fn max_sum_error_mut(&mut self) -> &mut f32;
}

impl PIDTrait for PID {
    fn p(&self) -> &f32 {
        &self.p
    }
    fn p_mut(&mut self) -> &mut f32 {
        &mut self.p
    }
    fn i(&self) -> &f32 {
        &self.i
    }
    fn i_mut(&mut self) -> &mut f32 {
        &mut self.i
    }
    fn d(&self) -> &f32 {
        &self.d
    }
    fn d_mut(&mut self) -> &mut f32 {
        &mut self.d
    }
    fn max_error(&self) -> &f32 {
        &self.max_error
    }
    fn max_error_mut(&mut self) -> &mut f32 {
        &mut self.max_error
    }
    fn max_p_term(&self) -> &f32 {
        &self.max_p_term
    }
    fn max_p_term_mut(&mut self) -> &mut f32 {
        &mut self.max_p_term
    }
    fn max_i_term(&self) -> &f32 {
        &self.max_i_term
    }
    fn max_i_term_mut(&mut self) -> &mut f32 {
        &mut self.max_i_term
    }
    fn max_d_term(&self) -> &f32 {
        &self.max_d_term
    }
    fn max_d_term_mut(&mut self) -> &mut f32 {
        &mut self.max_d_term
    }
    fn max_sum_error(&self) -> &f32 {
        &self.max_sum_error
    }
    fn max_sum_error_mut(&mut self) -> &mut f32 {
        &mut self.max_sum_error
    }
}

pub static PID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PID",
    name_hash: 193466392,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PID as Default>::default())),
            create_boxed: || Box::new(<PID as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "P",
                name_hash: 177653,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, p),
            },
            FieldInfoData {
                name: "I",
                name_hash: 177644,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, i),
            },
            FieldInfoData {
                name: "D",
                name_hash: 177633,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, d),
            },
            FieldInfoData {
                name: "MaxError",
                name_hash: 421240457,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_error),
            },
            FieldInfoData {
                name: "MaxPTerm",
                name_hash: 396390927,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_p_term),
            },
            FieldInfoData {
                name: "MaxITerm",
                name_hash: 426983126,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_i_term),
            },
            FieldInfoData {
                name: "MaxDTerm",
                name_hash: 418681627,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_d_term),
            },
            FieldInfoData {
                name: "MaxSumError",
                name_hash: 859402786,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_sum_error),
            },
        ],
    }),
    array_type: Some(PID_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PID {
    fn type_info(&self) -> &'static TypeInfo {
        PID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PID-Array",
    name_hash: 2885999148,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PID"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DifficultyIndexEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait DifficultyIndexEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl DifficultyIndexEntityDataTrait for DifficultyIndexEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for DifficultyIndexEntityData {
}

impl super::entity::GameObjectDataTrait for DifficultyIndexEntityData {
}

impl super::core::DataBusPeerTrait for DifficultyIndexEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DifficultyIndexEntityData {
}

impl super::core::DataContainerTrait for DifficultyIndexEntityData {
}

pub static DIFFICULTYINDEXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyIndexEntityData",
    name_hash: 1434977059,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DifficultyIndexEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DifficultyIndexEntityData as Default>::default())),
            create_boxed: || Box::new(<DifficultyIndexEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DifficultyIndexEntityData, realm),
            },
        ],
    }),
    array_type: Some(DIFFICULTYINDEXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DifficultyIndexEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DIFFICULTYINDEXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIFFICULTYINDEXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyIndexEntityData-Array",
    name_hash: 814483095,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DifficultyIndexEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DifficultyDatas {
    pub _glacier_base: super::gameplay_sim::DifficultyDatasBase,
    pub difficulties: Vec<Option<LockedTypeObject /* DifficultyData */>>,
}

pub trait DifficultyDatasTrait: super::gameplay_sim::DifficultyDatasBaseTrait {
    fn difficulties(&self) -> &Vec<Option<LockedTypeObject /* DifficultyData */>>;
    fn difficulties_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* DifficultyData */>>;
}

impl DifficultyDatasTrait for DifficultyDatas {
    fn difficulties(&self) -> &Vec<Option<LockedTypeObject /* DifficultyData */>> {
        &self.difficulties
    }
    fn difficulties_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* DifficultyData */>> {
        &mut self.difficulties
    }
}

impl super::gameplay_sim::DifficultyDatasBaseTrait for DifficultyDatas {
}

impl super::core::AssetTrait for DifficultyDatas {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for DifficultyDatas {
}

pub static DIFFICULTYDATAS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyDatas",
    name_hash: 289547381,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::DIFFICULTYDATASBASE_TYPE_INFO),
        super_class_offset: offset_of!(DifficultyDatas, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DifficultyDatas as Default>::default())),
            create_boxed: || Box::new(<DifficultyDatas as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Difficulties",
                name_hash: 850210768,
                flags: MemberInfoFlags::new(144),
                field_type: "DifficultyData-Array",
                rust_offset: offset_of!(DifficultyDatas, difficulties),
            },
        ],
    }),
    array_type: Some(DIFFICULTYDATAS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DifficultyDatas {
    fn type_info(&self) -> &'static TypeInfo {
        DIFFICULTYDATAS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIFFICULTYDATAS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyDatas-Array",
    name_hash: 806638913,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DifficultyDatas"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DifficultyData {
    pub _glacier_base: super::core::DataContainer,
    pub difficulty: Difficulty,
    pub game_type: PersistenceGameType,
    pub readable_name: String,
    pub human_health_modifier: f32,
    pub friends_health_modifier: f32,
    pub enemies_health_modifier: f32,
    pub friendly_damage_modifier: f32,
    pub vehicle_damage_modifier: f32,
    pub human_in_critical_health: f32,
    pub human_in_critical_health_damage_modifier: f32,
    pub human_regeneration_rate_modifier: f32,
    pub critical_fake_immortal_modifier: f32,
    pub interactive_man_down_damage_modifier: f32,
    pub interactive_man_down_time_multiplier: f32,
    pub interactive_man_down_revive_time: f32,
    pub adrenaline_kill_limit: i32,
    pub attract_distance_fall_off_modifier: super::core::Vec2,
    pub attract_soft_zone_modifier: f32,
    pub attract_user_input_multiplier_modifier: f32,
    pub sticky_box_modifier: super::core::Vec3,
    pub snap_zoom_post_time_no_input_modifier: f32,
    pub snap_zoom_post_time_modifier: f32,
    pub snap_box_modifier: super::core::Vec3,
    pub suck_zoom_modifier: f32,
    pub use_pitch_zoom_snap: bool,
    pub ai_bullet_damage_human_cooldown: f32,
    pub a_i_data: Option<LockedTypeObject /* GameAIDifficultyData */>,
}

pub trait DifficultyDataTrait: super::core::DataContainerTrait {
    fn difficulty(&self) -> &Difficulty;
    fn difficulty_mut(&mut self) -> &mut Difficulty;
    fn game_type(&self) -> &PersistenceGameType;
    fn game_type_mut(&mut self) -> &mut PersistenceGameType;
    fn readable_name(&self) -> &String;
    fn readable_name_mut(&mut self) -> &mut String;
    fn human_health_modifier(&self) -> &f32;
    fn human_health_modifier_mut(&mut self) -> &mut f32;
    fn friends_health_modifier(&self) -> &f32;
    fn friends_health_modifier_mut(&mut self) -> &mut f32;
    fn enemies_health_modifier(&self) -> &f32;
    fn enemies_health_modifier_mut(&mut self) -> &mut f32;
    fn friendly_damage_modifier(&self) -> &f32;
    fn friendly_damage_modifier_mut(&mut self) -> &mut f32;
    fn vehicle_damage_modifier(&self) -> &f32;
    fn vehicle_damage_modifier_mut(&mut self) -> &mut f32;
    fn human_in_critical_health(&self) -> &f32;
    fn human_in_critical_health_mut(&mut self) -> &mut f32;
    fn human_in_critical_health_damage_modifier(&self) -> &f32;
    fn human_in_critical_health_damage_modifier_mut(&mut self) -> &mut f32;
    fn human_regeneration_rate_modifier(&self) -> &f32;
    fn human_regeneration_rate_modifier_mut(&mut self) -> &mut f32;
    fn critical_fake_immortal_modifier(&self) -> &f32;
    fn critical_fake_immortal_modifier_mut(&mut self) -> &mut f32;
    fn interactive_man_down_damage_modifier(&self) -> &f32;
    fn interactive_man_down_damage_modifier_mut(&mut self) -> &mut f32;
    fn interactive_man_down_time_multiplier(&self) -> &f32;
    fn interactive_man_down_time_multiplier_mut(&mut self) -> &mut f32;
    fn interactive_man_down_revive_time(&self) -> &f32;
    fn interactive_man_down_revive_time_mut(&mut self) -> &mut f32;
    fn adrenaline_kill_limit(&self) -> &i32;
    fn adrenaline_kill_limit_mut(&mut self) -> &mut i32;
    fn attract_distance_fall_off_modifier(&self) -> &super::core::Vec2;
    fn attract_distance_fall_off_modifier_mut(&mut self) -> &mut super::core::Vec2;
    fn attract_soft_zone_modifier(&self) -> &f32;
    fn attract_soft_zone_modifier_mut(&mut self) -> &mut f32;
    fn attract_user_input_multiplier_modifier(&self) -> &f32;
    fn attract_user_input_multiplier_modifier_mut(&mut self) -> &mut f32;
    fn sticky_box_modifier(&self) -> &super::core::Vec3;
    fn sticky_box_modifier_mut(&mut self) -> &mut super::core::Vec3;
    fn snap_zoom_post_time_no_input_modifier(&self) -> &f32;
    fn snap_zoom_post_time_no_input_modifier_mut(&mut self) -> &mut f32;
    fn snap_zoom_post_time_modifier(&self) -> &f32;
    fn snap_zoom_post_time_modifier_mut(&mut self) -> &mut f32;
    fn snap_box_modifier(&self) -> &super::core::Vec3;
    fn snap_box_modifier_mut(&mut self) -> &mut super::core::Vec3;
    fn suck_zoom_modifier(&self) -> &f32;
    fn suck_zoom_modifier_mut(&mut self) -> &mut f32;
    fn use_pitch_zoom_snap(&self) -> &bool;
    fn use_pitch_zoom_snap_mut(&mut self) -> &mut bool;
    fn ai_bullet_damage_human_cooldown(&self) -> &f32;
    fn ai_bullet_damage_human_cooldown_mut(&mut self) -> &mut f32;
    fn a_i_data(&self) -> &Option<LockedTypeObject /* GameAIDifficultyData */>;
    fn a_i_data_mut(&mut self) -> &mut Option<LockedTypeObject /* GameAIDifficultyData */>;
}

impl DifficultyDataTrait for DifficultyData {
    fn difficulty(&self) -> &Difficulty {
        &self.difficulty
    }
    fn difficulty_mut(&mut self) -> &mut Difficulty {
        &mut self.difficulty
    }
    fn game_type(&self) -> &PersistenceGameType {
        &self.game_type
    }
    fn game_type_mut(&mut self) -> &mut PersistenceGameType {
        &mut self.game_type
    }
    fn readable_name(&self) -> &String {
        &self.readable_name
    }
    fn readable_name_mut(&mut self) -> &mut String {
        &mut self.readable_name
    }
    fn human_health_modifier(&self) -> &f32 {
        &self.human_health_modifier
    }
    fn human_health_modifier_mut(&mut self) -> &mut f32 {
        &mut self.human_health_modifier
    }
    fn friends_health_modifier(&self) -> &f32 {
        &self.friends_health_modifier
    }
    fn friends_health_modifier_mut(&mut self) -> &mut f32 {
        &mut self.friends_health_modifier
    }
    fn enemies_health_modifier(&self) -> &f32 {
        &self.enemies_health_modifier
    }
    fn enemies_health_modifier_mut(&mut self) -> &mut f32 {
        &mut self.enemies_health_modifier
    }
    fn friendly_damage_modifier(&self) -> &f32 {
        &self.friendly_damage_modifier
    }
    fn friendly_damage_modifier_mut(&mut self) -> &mut f32 {
        &mut self.friendly_damage_modifier
    }
    fn vehicle_damage_modifier(&self) -> &f32 {
        &self.vehicle_damage_modifier
    }
    fn vehicle_damage_modifier_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_damage_modifier
    }
    fn human_in_critical_health(&self) -> &f32 {
        &self.human_in_critical_health
    }
    fn human_in_critical_health_mut(&mut self) -> &mut f32 {
        &mut self.human_in_critical_health
    }
    fn human_in_critical_health_damage_modifier(&self) -> &f32 {
        &self.human_in_critical_health_damage_modifier
    }
    fn human_in_critical_health_damage_modifier_mut(&mut self) -> &mut f32 {
        &mut self.human_in_critical_health_damage_modifier
    }
    fn human_regeneration_rate_modifier(&self) -> &f32 {
        &self.human_regeneration_rate_modifier
    }
    fn human_regeneration_rate_modifier_mut(&mut self) -> &mut f32 {
        &mut self.human_regeneration_rate_modifier
    }
    fn critical_fake_immortal_modifier(&self) -> &f32 {
        &self.critical_fake_immortal_modifier
    }
    fn critical_fake_immortal_modifier_mut(&mut self) -> &mut f32 {
        &mut self.critical_fake_immortal_modifier
    }
    fn interactive_man_down_damage_modifier(&self) -> &f32 {
        &self.interactive_man_down_damage_modifier
    }
    fn interactive_man_down_damage_modifier_mut(&mut self) -> &mut f32 {
        &mut self.interactive_man_down_damage_modifier
    }
    fn interactive_man_down_time_multiplier(&self) -> &f32 {
        &self.interactive_man_down_time_multiplier
    }
    fn interactive_man_down_time_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.interactive_man_down_time_multiplier
    }
    fn interactive_man_down_revive_time(&self) -> &f32 {
        &self.interactive_man_down_revive_time
    }
    fn interactive_man_down_revive_time_mut(&mut self) -> &mut f32 {
        &mut self.interactive_man_down_revive_time
    }
    fn adrenaline_kill_limit(&self) -> &i32 {
        &self.adrenaline_kill_limit
    }
    fn adrenaline_kill_limit_mut(&mut self) -> &mut i32 {
        &mut self.adrenaline_kill_limit
    }
    fn attract_distance_fall_off_modifier(&self) -> &super::core::Vec2 {
        &self.attract_distance_fall_off_modifier
    }
    fn attract_distance_fall_off_modifier_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.attract_distance_fall_off_modifier
    }
    fn attract_soft_zone_modifier(&self) -> &f32 {
        &self.attract_soft_zone_modifier
    }
    fn attract_soft_zone_modifier_mut(&mut self) -> &mut f32 {
        &mut self.attract_soft_zone_modifier
    }
    fn attract_user_input_multiplier_modifier(&self) -> &f32 {
        &self.attract_user_input_multiplier_modifier
    }
    fn attract_user_input_multiplier_modifier_mut(&mut self) -> &mut f32 {
        &mut self.attract_user_input_multiplier_modifier
    }
    fn sticky_box_modifier(&self) -> &super::core::Vec3 {
        &self.sticky_box_modifier
    }
    fn sticky_box_modifier_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sticky_box_modifier
    }
    fn snap_zoom_post_time_no_input_modifier(&self) -> &f32 {
        &self.snap_zoom_post_time_no_input_modifier
    }
    fn snap_zoom_post_time_no_input_modifier_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_post_time_no_input_modifier
    }
    fn snap_zoom_post_time_modifier(&self) -> &f32 {
        &self.snap_zoom_post_time_modifier
    }
    fn snap_zoom_post_time_modifier_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_post_time_modifier
    }
    fn snap_box_modifier(&self) -> &super::core::Vec3 {
        &self.snap_box_modifier
    }
    fn snap_box_modifier_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.snap_box_modifier
    }
    fn suck_zoom_modifier(&self) -> &f32 {
        &self.suck_zoom_modifier
    }
    fn suck_zoom_modifier_mut(&mut self) -> &mut f32 {
        &mut self.suck_zoom_modifier
    }
    fn use_pitch_zoom_snap(&self) -> &bool {
        &self.use_pitch_zoom_snap
    }
    fn use_pitch_zoom_snap_mut(&mut self) -> &mut bool {
        &mut self.use_pitch_zoom_snap
    }
    fn ai_bullet_damage_human_cooldown(&self) -> &f32 {
        &self.ai_bullet_damage_human_cooldown
    }
    fn ai_bullet_damage_human_cooldown_mut(&mut self) -> &mut f32 {
        &mut self.ai_bullet_damage_human_cooldown
    }
    fn a_i_data(&self) -> &Option<LockedTypeObject /* GameAIDifficultyData */> {
        &self.a_i_data
    }
    fn a_i_data_mut(&mut self) -> &mut Option<LockedTypeObject /* GameAIDifficultyData */> {
        &mut self.a_i_data
    }
}

impl super::core::DataContainerTrait for DifficultyData {
}

pub static DIFFICULTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyData",
    name_hash: 2481634118,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(DifficultyData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DifficultyData as Default>::default())),
            create_boxed: || Box::new(<DifficultyData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Difficulty",
                name_hash: 3179608694,
                flags: MemberInfoFlags::new(0),
                field_type: "Difficulty",
                rust_offset: offset_of!(DifficultyData, difficulty),
            },
            FieldInfoData {
                name: "GameType",
                name_hash: 510356627,
                flags: MemberInfoFlags::new(0),
                field_type: "PersistenceGameType",
                rust_offset: offset_of!(DifficultyData, game_type),
            },
            FieldInfoData {
                name: "ReadableName",
                name_hash: 4148508410,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DifficultyData, readable_name),
            },
            FieldInfoData {
                name: "HumanHealthModifier",
                name_hash: 306426001,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, human_health_modifier),
            },
            FieldInfoData {
                name: "FriendsHealthModifier",
                name_hash: 1859236591,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, friends_health_modifier),
            },
            FieldInfoData {
                name: "EnemiesHealthModifier",
                name_hash: 2553763986,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, enemies_health_modifier),
            },
            FieldInfoData {
                name: "FriendlyDamageModifier",
                name_hash: 1576644830,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, friendly_damage_modifier),
            },
            FieldInfoData {
                name: "VehicleDamageModifier",
                name_hash: 3810411169,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, vehicle_damage_modifier),
            },
            FieldInfoData {
                name: "HumanInCriticalHealth",
                name_hash: 1275764554,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, human_in_critical_health),
            },
            FieldInfoData {
                name: "HumanInCriticalHealthDamageModifier",
                name_hash: 2030418966,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, human_in_critical_health_damage_modifier),
            },
            FieldInfoData {
                name: "HumanRegenerationRateModifier",
                name_hash: 1058415390,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, human_regeneration_rate_modifier),
            },
            FieldInfoData {
                name: "CriticalFakeImmortalModifier",
                name_hash: 2802952093,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, critical_fake_immortal_modifier),
            },
            FieldInfoData {
                name: "InteractiveManDownDamageModifier",
                name_hash: 1661744161,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, interactive_man_down_damage_modifier),
            },
            FieldInfoData {
                name: "InteractiveManDownTimeMultiplier",
                name_hash: 849153507,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, interactive_man_down_time_multiplier),
            },
            FieldInfoData {
                name: "InteractiveManDownReviveTime",
                name_hash: 2327289747,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, interactive_man_down_revive_time),
            },
            FieldInfoData {
                name: "AdrenalineKillLimit",
                name_hash: 2568704897,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DifficultyData, adrenaline_kill_limit),
            },
            FieldInfoData {
                name: "AttractDistanceFallOffModifier",
                name_hash: 3056523804,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(DifficultyData, attract_distance_fall_off_modifier),
            },
            FieldInfoData {
                name: "AttractSoftZoneModifier",
                name_hash: 2684655239,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, attract_soft_zone_modifier),
            },
            FieldInfoData {
                name: "AttractUserInputMultiplierModifier",
                name_hash: 1206890715,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, attract_user_input_multiplier_modifier),
            },
            FieldInfoData {
                name: "StickyBoxModifier",
                name_hash: 1564331544,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DifficultyData, sticky_box_modifier),
            },
            FieldInfoData {
                name: "SnapZoomPostTimeNoInputModifier",
                name_hash: 3625516307,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, snap_zoom_post_time_no_input_modifier),
            },
            FieldInfoData {
                name: "SnapZoomPostTimeModifier",
                name_hash: 40038276,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, snap_zoom_post_time_modifier),
            },
            FieldInfoData {
                name: "SnapBoxModifier",
                name_hash: 723092811,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DifficultyData, snap_box_modifier),
            },
            FieldInfoData {
                name: "SuckZoomModifier",
                name_hash: 4057650955,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, suck_zoom_modifier),
            },
            FieldInfoData {
                name: "UsePitchZoomSnap",
                name_hash: 2073450427,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DifficultyData, use_pitch_zoom_snap),
            },
            FieldInfoData {
                name: "AiBulletDamageHumanCooldown",
                name_hash: 3336443042,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, ai_bullet_damage_human_cooldown),
            },
            FieldInfoData {
                name: "AIData",
                name_hash: 2529950045,
                flags: MemberInfoFlags::new(0),
                field_type: "GameAIDifficultyData",
                rust_offset: offset_of!(DifficultyData, a_i_data),
            },
        ],
    }),
    array_type: Some(DIFFICULTYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DifficultyData {
    fn type_info(&self) -> &'static TypeInfo {
        DIFFICULTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIFFICULTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyData-Array",
    name_hash: 2369059058,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DifficultyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum Difficulty {
    #[default]
    Difficulty_Easy = 0,
    Difficulty_Medium = 1,
    Difficulty_Hard = 2,
    Difficulty_Hardcore = 3,
    Difficulty_None = 4,
}

pub static DIFFICULTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Difficulty",
    name_hash: 3179608694,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DIFFICULTY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Difficulty {
    fn type_info(&self) -> &'static TypeInfo {
        DIFFICULTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DIFFICULTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Difficulty-Array",
    name_hash: 1734369090,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("Difficulty"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameAIDifficultyData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait GameAIDifficultyDataTrait: super::core::DataContainerTrait {
}

impl GameAIDifficultyDataTrait for GameAIDifficultyData {
}

impl super::core::DataContainerTrait for GameAIDifficultyData {
}

pub static GAMEAIDIFFICULTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameAIDifficultyData",
    name_hash: 2734723264,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(GameAIDifficultyData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameAIDifficultyData as Default>::default())),
            create_boxed: || Box::new(<GameAIDifficultyData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMEAIDIFFICULTYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameAIDifficultyData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEAIDIFFICULTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEAIDIFFICULTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameAIDifficultyData-Array",
    name_hash: 3460089716,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameAIDifficultyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct NetworkedUnlock {
    pub networked_compartment_id: u16,
    pub unlock_id: u32,
}

pub trait NetworkedUnlockTrait: TypeObject {
    fn networked_compartment_id(&self) -> &u16;
    fn networked_compartment_id_mut(&mut self) -> &mut u16;
    fn unlock_id(&self) -> &u32;
    fn unlock_id_mut(&mut self) -> &mut u32;
}

impl NetworkedUnlockTrait for NetworkedUnlock {
    fn networked_compartment_id(&self) -> &u16 {
        &self.networked_compartment_id
    }
    fn networked_compartment_id_mut(&mut self) -> &mut u16 {
        &mut self.networked_compartment_id
    }
    fn unlock_id(&self) -> &u32 {
        &self.unlock_id
    }
    fn unlock_id_mut(&mut self) -> &mut u32 {
        &mut self.unlock_id
    }
}

pub static NETWORKEDUNLOCK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedUnlock",
    name_hash: 1420197930,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkedUnlock as Default>::default())),
            create_boxed: || Box::new(<NetworkedUnlock as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "NetworkedCompartmentId",
                name_hash: 3030908755,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(NetworkedUnlock, networked_compartment_id),
            },
            FieldInfoData {
                name: "UnlockId",
                name_hash: 2655233848,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(NetworkedUnlock, unlock_id),
            },
        ],
    }),
    array_type: Some(NETWORKEDUNLOCK_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for NetworkedUnlock {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKEDUNLOCK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NETWORKEDUNLOCK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedUnlock-Array",
    name_hash: 729569950,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("NetworkedUnlock"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomizeCharacterData {
    pub _glacier_base: super::core::Asset,
    pub restore_to_original_visual_state: bool,
    pub clear_visual_state: bool,
    pub visual_groups: Vec<BoxedTypeObject /* CustomizeVisual */>,
    pub unlocks: Vec<Option<LockedTypeObject /* UnlockAssetBase */>>,
    pub override_max_health: f32,
    pub override_critical_health_threshold: f32,
}

pub trait CustomizeCharacterDataTrait: super::core::AssetTrait {
    fn restore_to_original_visual_state(&self) -> &bool;
    fn restore_to_original_visual_state_mut(&mut self) -> &mut bool;
    fn clear_visual_state(&self) -> &bool;
    fn clear_visual_state_mut(&mut self) -> &mut bool;
    fn visual_groups(&self) -> &Vec<BoxedTypeObject /* CustomizeVisual */>;
    fn visual_groups_mut(&mut self) -> &mut Vec<BoxedTypeObject /* CustomizeVisual */>;
    fn unlocks(&self) -> &Vec<Option<LockedTypeObject /* UnlockAssetBase */>>;
    fn unlocks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockAssetBase */>>;
    fn override_max_health(&self) -> &f32;
    fn override_max_health_mut(&mut self) -> &mut f32;
    fn override_critical_health_threshold(&self) -> &f32;
    fn override_critical_health_threshold_mut(&mut self) -> &mut f32;
}

impl CustomizeCharacterDataTrait for CustomizeCharacterData {
    fn restore_to_original_visual_state(&self) -> &bool {
        &self.restore_to_original_visual_state
    }
    fn restore_to_original_visual_state_mut(&mut self) -> &mut bool {
        &mut self.restore_to_original_visual_state
    }
    fn clear_visual_state(&self) -> &bool {
        &self.clear_visual_state
    }
    fn clear_visual_state_mut(&mut self) -> &mut bool {
        &mut self.clear_visual_state
    }
    fn visual_groups(&self) -> &Vec<BoxedTypeObject /* CustomizeVisual */> {
        &self.visual_groups
    }
    fn visual_groups_mut(&mut self) -> &mut Vec<BoxedTypeObject /* CustomizeVisual */> {
        &mut self.visual_groups
    }
    fn unlocks(&self) -> &Vec<Option<LockedTypeObject /* UnlockAssetBase */>> {
        &self.unlocks
    }
    fn unlocks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockAssetBase */>> {
        &mut self.unlocks
    }
    fn override_max_health(&self) -> &f32 {
        &self.override_max_health
    }
    fn override_max_health_mut(&mut self) -> &mut f32 {
        &mut self.override_max_health
    }
    fn override_critical_health_threshold(&self) -> &f32 {
        &self.override_critical_health_threshold
    }
    fn override_critical_health_threshold_mut(&mut self) -> &mut f32 {
        &mut self.override_critical_health_threshold
    }
}

impl super::core::AssetTrait for CustomizeCharacterData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CustomizeCharacterData {
}

pub static CUSTOMIZECHARACTERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeCharacterData",
    name_hash: 3784213897,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(CustomizeCharacterData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeCharacterData as Default>::default())),
            create_boxed: || Box::new(<CustomizeCharacterData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RestoreToOriginalVisualState",
                name_hash: 1970657676,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CustomizeCharacterData, restore_to_original_visual_state),
            },
            FieldInfoData {
                name: "ClearVisualState",
                name_hash: 443106111,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CustomizeCharacterData, clear_visual_state),
            },
            FieldInfoData {
                name: "VisualGroups",
                name_hash: 1154342877,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomizeVisual-Array",
                rust_offset: offset_of!(CustomizeCharacterData, visual_groups),
            },
            FieldInfoData {
                name: "Unlocks",
                name_hash: 3464375270,
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(CustomizeCharacterData, unlocks),
            },
            FieldInfoData {
                name: "OverrideMaxHealth",
                name_hash: 3943553849,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CustomizeCharacterData, override_max_health),
            },
            FieldInfoData {
                name: "OverrideCriticalHealthThreshold",
                name_hash: 2799968817,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CustomizeCharacterData, override_critical_health_threshold),
            },
        ],
    }),
    array_type: Some(CUSTOMIZECHARACTERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizeCharacterData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZECHARACTERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZECHARACTERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeCharacterData-Array",
    name_hash: 900037437,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizeCharacterData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomizeVisual {
    pub visual: Vec<Option<LockedTypeObject /* UnlockAsset */>>,
}

pub trait CustomizeVisualTrait: TypeObject {
    fn visual(&self) -> &Vec<Option<LockedTypeObject /* UnlockAsset */>>;
    fn visual_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockAsset */>>;
}

impl CustomizeVisualTrait for CustomizeVisual {
    fn visual(&self) -> &Vec<Option<LockedTypeObject /* UnlockAsset */>> {
        &self.visual
    }
    fn visual_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockAsset */>> {
        &mut self.visual
    }
}

pub static CUSTOMIZEVISUAL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeVisual",
    name_hash: 3736595796,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeVisual as Default>::default())),
            create_boxed: || Box::new(<CustomizeVisual as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Visual",
                name_hash: 3150962481,
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAsset-Array",
                rust_offset: offset_of!(CustomizeVisual, visual),
            },
        ],
    }),
    array_type: Some(CUSTOMIZEVISUAL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizeVisual {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZEVISUAL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUSTOMIZEVISUAL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeVisual-Array",
    name_hash: 318372320,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizeVisual"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct NetworkPlayerSelectedUnlockAssetsMessage {
}

pub trait NetworkPlayerSelectedUnlockAssetsMessageTrait: TypeObject {
}

impl NetworkPlayerSelectedUnlockAssetsMessageTrait for NetworkPlayerSelectedUnlockAssetsMessage {
}

pub static NETWORKPLAYERSELECTEDUNLOCKASSETSMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkPlayerSelectedUnlockAssetsMessage",
    name_hash: 4149418297,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkPlayerSelectedUnlockAssetsMessage as Default>::default())),
            create_boxed: || Box::new(<NetworkPlayerSelectedUnlockAssetsMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for NetworkPlayerSelectedUnlockAssetsMessage {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKPLAYERSELECTEDUNLOCKASSETSMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct CamoUnlockSelection {
    pub category: i32,
    pub asset: Option<LockedTypeObject /* UnlockAssetBase */>,
}

pub trait CamoUnlockSelectionTrait: TypeObject {
    fn category(&self) -> &i32;
    fn category_mut(&mut self) -> &mut i32;
    fn asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */>;
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */>;
}

impl CamoUnlockSelectionTrait for CamoUnlockSelection {
    fn category(&self) -> &i32 {
        &self.category
    }
    fn category_mut(&mut self) -> &mut i32 {
        &mut self.category
    }
    fn asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */> {
        &mut self.asset
    }
}

pub static CAMOUNLOCKSELECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CamoUnlockSelection",
    name_hash: 597040917,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CamoUnlockSelection as Default>::default())),
            create_boxed: || Box::new(<CamoUnlockSelection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Category",
                name_hash: 3455858997,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CamoUnlockSelection, category),
            },
            FieldInfoData {
                name: "Asset",
                name_hash: 205976053,
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(CamoUnlockSelection, asset),
            },
        ],
    }),
    array_type: Some(CAMOUNLOCKSELECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CamoUnlockSelection {
    fn type_info(&self) -> &'static TypeInfo {
        CAMOUNLOCKSELECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMOUNLOCKSELECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CamoUnlockSelection-Array",
    name_hash: 1521307297,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CamoUnlockSelection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleCustomizationAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub visual_table: Option<LockedTypeObject /* CustomizationTable */>,
    pub customization: Option<LockedTypeObject /* CustomizationTable */>,
}

pub trait VehicleCustomizationAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn visual_table(&self) -> &Option<LockedTypeObject /* CustomizationTable */>;
    fn visual_table_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizationTable */>;
    fn customization(&self) -> &Option<LockedTypeObject /* CustomizationTable */>;
    fn customization_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizationTable */>;
}

impl VehicleCustomizationAssetTrait for VehicleCustomizationAsset {
    fn visual_table(&self) -> &Option<LockedTypeObject /* CustomizationTable */> {
        &self.visual_table
    }
    fn visual_table_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizationTable */> {
        &mut self.visual_table
    }
    fn customization(&self) -> &Option<LockedTypeObject /* CustomizationTable */> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizationTable */> {
        &mut self.customization
    }
}

impl super::core::DataContainerPolicyAssetTrait for VehicleCustomizationAsset {
}

impl super::core::AssetTrait for VehicleCustomizationAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VehicleCustomizationAsset {
}

pub static VEHICLECUSTOMIZATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCustomizationAsset",
    name_hash: 2772091056,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        super_class_offset: offset_of!(VehicleCustomizationAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleCustomizationAsset as Default>::default())),
            create_boxed: || Box::new(<VehicleCustomizationAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "VisualTable",
                name_hash: 277951407,
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(VehicleCustomizationAsset, visual_table),
            },
            FieldInfoData {
                name: "Customization",
                name_hash: 1998291608,
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(VehicleCustomizationAsset, customization),
            },
        ],
    }),
    array_type: Some(VEHICLECUSTOMIZATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleCustomizationAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECUSTOMIZATIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLECUSTOMIZATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCustomizationAsset-Array",
    name_hash: 2587487748,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleCustomizationAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterCustomizationAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub label_sid: String,
    pub visual_table: Option<LockedTypeObject /* CustomizationTable */>,
    pub specialization_table: Option<LockedTypeObject /* CustomizationTable */>,
}

pub trait CharacterCustomizationAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn label_sid(&self) -> &String;
    fn label_sid_mut(&mut self) -> &mut String;
    fn visual_table(&self) -> &Option<LockedTypeObject /* CustomizationTable */>;
    fn visual_table_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizationTable */>;
    fn specialization_table(&self) -> &Option<LockedTypeObject /* CustomizationTable */>;
    fn specialization_table_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizationTable */>;
}

impl CharacterCustomizationAssetTrait for CharacterCustomizationAsset {
    fn label_sid(&self) -> &String {
        &self.label_sid
    }
    fn label_sid_mut(&mut self) -> &mut String {
        &mut self.label_sid
    }
    fn visual_table(&self) -> &Option<LockedTypeObject /* CustomizationTable */> {
        &self.visual_table
    }
    fn visual_table_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizationTable */> {
        &mut self.visual_table
    }
    fn specialization_table(&self) -> &Option<LockedTypeObject /* CustomizationTable */> {
        &self.specialization_table
    }
    fn specialization_table_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizationTable */> {
        &mut self.specialization_table
    }
}

impl super::core::DataContainerPolicyAssetTrait for CharacterCustomizationAsset {
}

impl super::core::AssetTrait for CharacterCustomizationAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterCustomizationAsset {
}

pub static CHARACTERCUSTOMIZATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCustomizationAsset",
    name_hash: 3714318193,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        super_class_offset: offset_of!(CharacterCustomizationAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterCustomizationAsset as Default>::default())),
            create_boxed: || Box::new(<CharacterCustomizationAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LabelSid",
                name_hash: 4044105085,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CharacterCustomizationAsset, label_sid),
            },
            FieldInfoData {
                name: "VisualTable",
                name_hash: 277951407,
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(CharacterCustomizationAsset, visual_table),
            },
            FieldInfoData {
                name: "SpecializationTable",
                name_hash: 1559267348,
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(CharacterCustomizationAsset, specialization_table),
            },
        ],
    }),
    array_type: Some(CHARACTERCUSTOMIZATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterCustomizationAsset {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERCUSTOMIZATIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERCUSTOMIZATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCustomizationAsset-Array",
    name_hash: 3249455685,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterCustomizationAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomizationUnlockParts {
    pub _glacier_base: super::core::DataContainer,
    pub u_i_category_sid: String,
    pub default_selection_index: u32,
    pub selectable_unlocks: Vec<Option<LockedTypeObject /* UnlockAssetBase */>>,
}

pub trait CustomizationUnlockPartsTrait: super::core::DataContainerTrait {
    fn u_i_category_sid(&self) -> &String;
    fn u_i_category_sid_mut(&mut self) -> &mut String;
    fn default_selection_index(&self) -> &u32;
    fn default_selection_index_mut(&mut self) -> &mut u32;
    fn selectable_unlocks(&self) -> &Vec<Option<LockedTypeObject /* UnlockAssetBase */>>;
    fn selectable_unlocks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockAssetBase */>>;
}

impl CustomizationUnlockPartsTrait for CustomizationUnlockParts {
    fn u_i_category_sid(&self) -> &String {
        &self.u_i_category_sid
    }
    fn u_i_category_sid_mut(&mut self) -> &mut String {
        &mut self.u_i_category_sid
    }
    fn default_selection_index(&self) -> &u32 {
        &self.default_selection_index
    }
    fn default_selection_index_mut(&mut self) -> &mut u32 {
        &mut self.default_selection_index
    }
    fn selectable_unlocks(&self) -> &Vec<Option<LockedTypeObject /* UnlockAssetBase */>> {
        &self.selectable_unlocks
    }
    fn selectable_unlocks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockAssetBase */>> {
        &mut self.selectable_unlocks
    }
}

impl super::core::DataContainerTrait for CustomizationUnlockParts {
}

pub static CUSTOMIZATIONUNLOCKPARTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationUnlockParts",
    name_hash: 1742002636,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CustomizationUnlockParts, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizationUnlockParts as Default>::default())),
            create_boxed: || Box::new(<CustomizationUnlockParts as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "UICategorySid",
                name_hash: 795269975,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CustomizationUnlockParts, u_i_category_sid),
            },
            FieldInfoData {
                name: "DefaultSelectionIndex",
                name_hash: 3046460336,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CustomizationUnlockParts, default_selection_index),
            },
            FieldInfoData {
                name: "SelectableUnlocks",
                name_hash: 1920005412,
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(CustomizationUnlockParts, selectable_unlocks),
            },
        ],
    }),
    array_type: Some(CUSTOMIZATIONUNLOCKPARTS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizationUnlockParts {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZATIONUNLOCKPARTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZATIONUNLOCKPARTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationUnlockParts-Array",
    name_hash: 2703415928,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizationUnlockParts"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomizationTable {
    pub _glacier_base: super::core::DataContainer,
    pub unlock_parts: Vec<Option<LockedTypeObject /* CustomizationUnlockParts */>>,
}

pub trait CustomizationTableTrait: super::core::DataContainerTrait {
    fn unlock_parts(&self) -> &Vec<Option<LockedTypeObject /* CustomizationUnlockParts */>>;
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomizationUnlockParts */>>;
}

impl CustomizationTableTrait for CustomizationTable {
    fn unlock_parts(&self) -> &Vec<Option<LockedTypeObject /* CustomizationUnlockParts */>> {
        &self.unlock_parts
    }
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CustomizationUnlockParts */>> {
        &mut self.unlock_parts
    }
}

impl super::core::DataContainerTrait for CustomizationTable {
}

pub static CUSTOMIZATIONTABLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationTable",
    name_hash: 3301467942,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CustomizationTable, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizationTable as Default>::default())),
            create_boxed: || Box::new(<CustomizationTable as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockParts",
                name_hash: 4116003953,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomizationUnlockParts-Array",
                rust_offset: offset_of!(CustomizationTable, unlock_parts),
            },
        ],
    }),
    array_type: Some(CUSTOMIZATIONTABLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizationTable {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZATIONTABLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZATIONTABLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationTable-Array",
    name_hash: 468702098,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizationTable"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleVisualCustomizationAsset {
    pub _glacier_base: super::core::Asset,
    pub texture_unlock_part_collections: Vec<Option<LockedTypeObject /* ShaderTextureUnlockPartCollection */>>,
    pub text_unlock_parts: Vec<Option<LockedTypeObject /* TextUnlockPartData */>>,
}

pub trait VehicleVisualCustomizationAssetTrait: super::core::AssetTrait {
    fn texture_unlock_part_collections(&self) -> &Vec<Option<LockedTypeObject /* ShaderTextureUnlockPartCollection */>>;
    fn texture_unlock_part_collections_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ShaderTextureUnlockPartCollection */>>;
    fn text_unlock_parts(&self) -> &Vec<Option<LockedTypeObject /* TextUnlockPartData */>>;
    fn text_unlock_parts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TextUnlockPartData */>>;
}

impl VehicleVisualCustomizationAssetTrait for VehicleVisualCustomizationAsset {
    fn texture_unlock_part_collections(&self) -> &Vec<Option<LockedTypeObject /* ShaderTextureUnlockPartCollection */>> {
        &self.texture_unlock_part_collections
    }
    fn texture_unlock_part_collections_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ShaderTextureUnlockPartCollection */>> {
        &mut self.texture_unlock_part_collections
    }
    fn text_unlock_parts(&self) -> &Vec<Option<LockedTypeObject /* TextUnlockPartData */>> {
        &self.text_unlock_parts
    }
    fn text_unlock_parts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TextUnlockPartData */>> {
        &mut self.text_unlock_parts
    }
}

impl super::core::AssetTrait for VehicleVisualCustomizationAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VehicleVisualCustomizationAsset {
}

pub static VEHICLEVISUALCUSTOMIZATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVisualCustomizationAsset",
    name_hash: 192364932,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(VehicleVisualCustomizationAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleVisualCustomizationAsset as Default>::default())),
            create_boxed: || Box::new(<VehicleVisualCustomizationAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TextureUnlockPartCollections",
                name_hash: 3762069016,
                flags: MemberInfoFlags::new(144),
                field_type: "ShaderTextureUnlockPartCollection-Array",
                rust_offset: offset_of!(VehicleVisualCustomizationAsset, texture_unlock_part_collections),
            },
            FieldInfoData {
                name: "TextUnlockParts",
                name_hash: 1176201452,
                flags: MemberInfoFlags::new(144),
                field_type: "TextUnlockPartData-Array",
                rust_offset: offset_of!(VehicleVisualCustomizationAsset, text_unlock_parts),
            },
        ],
    }),
    array_type: Some(VEHICLEVISUALCUSTOMIZATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleVisualCustomizationAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEVISUALCUSTOMIZATIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEVISUALCUSTOMIZATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVisualCustomizationAsset-Array",
    name_hash: 354465200,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleVisualCustomizationAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TextUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub shader_node_name: String,
    pub mesh_blueprint: Option<LockedTypeObject /* super::entity::ObjectBlueprint */>,
}

pub trait TextUnlockPartDataTrait: super::core::DataContainerTrait {
    fn shader_node_name(&self) -> &String;
    fn shader_node_name_mut(&mut self) -> &mut String;
    fn mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
}

impl TextUnlockPartDataTrait for TextUnlockPartData {
    fn shader_node_name(&self) -> &String {
        &self.shader_node_name
    }
    fn shader_node_name_mut(&mut self) -> &mut String {
        &mut self.shader_node_name
    }
    fn mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &self.mesh_blueprint
    }
    fn mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &mut self.mesh_blueprint
    }
}

impl super::core::DataContainerTrait for TextUnlockPartData {
}

pub static TEXTUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextUnlockPartData",
    name_hash: 2377846223,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(TextUnlockPartData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextUnlockPartData as Default>::default())),
            create_boxed: || Box::new(<TextUnlockPartData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ShaderNodeName",
                name_hash: 4213969131,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TextUnlockPartData, shader_node_name),
            },
            FieldInfoData {
                name: "MeshBlueprint",
                name_hash: 1662348825,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(TextUnlockPartData, mesh_blueprint),
            },
        ],
    }),
    array_type: Some(TEXTUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextUnlockPartData-Array",
    name_hash: 869210875,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ShaderTextureUnlockPartCollection {
    pub _glacier_base: ShaderCustomizationUnlockPartCollection,
    pub default_texture_reference: Option<LockedTypeObject /* TextureReference */>,
    pub unlock_parts: Vec<Option<LockedTypeObject /* TextureUnlockPartData */>>,
}

pub trait ShaderTextureUnlockPartCollectionTrait: ShaderCustomizationUnlockPartCollectionTrait {
    fn default_texture_reference(&self) -> &Option<LockedTypeObject /* TextureReference */>;
    fn default_texture_reference_mut(&mut self) -> &mut Option<LockedTypeObject /* TextureReference */>;
    fn unlock_parts(&self) -> &Vec<Option<LockedTypeObject /* TextureUnlockPartData */>>;
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TextureUnlockPartData */>>;
}

impl ShaderTextureUnlockPartCollectionTrait for ShaderTextureUnlockPartCollection {
    fn default_texture_reference(&self) -> &Option<LockedTypeObject /* TextureReference */> {
        &self.default_texture_reference
    }
    fn default_texture_reference_mut(&mut self) -> &mut Option<LockedTypeObject /* TextureReference */> {
        &mut self.default_texture_reference
    }
    fn unlock_parts(&self) -> &Vec<Option<LockedTypeObject /* TextureUnlockPartData */>> {
        &self.unlock_parts
    }
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TextureUnlockPartData */>> {
        &mut self.unlock_parts
    }
}

impl ShaderCustomizationUnlockPartCollectionTrait for ShaderTextureUnlockPartCollection {
    fn mesh_blueprints(&self) -> &Vec<Option<LockedTypeObject /* super::entity::ObjectBlueprint */>> {
        self._glacier_base.mesh_blueprints()
    }
    fn mesh_blueprints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::ObjectBlueprint */>> {
        self._glacier_base.mesh_blueprints_mut()
    }
    fn shader_node_name(&self) -> &String {
        self._glacier_base.shader_node_name()
    }
    fn shader_node_name_mut(&mut self) -> &mut String {
        self._glacier_base.shader_node_name_mut()
    }
    fn mesh_materials(&self) -> &Vec<BoxedTypeObject /* CustomizedMeshMaterialsData */> {
        self._glacier_base.mesh_materials()
    }
    fn mesh_materials_mut(&mut self) -> &mut Vec<BoxedTypeObject /* CustomizedMeshMaterialsData */> {
        self._glacier_base.mesh_materials_mut()
    }
}

impl super::core::DataContainerTrait for ShaderTextureUnlockPartCollection {
}

pub static SHADERTEXTUREUNLOCKPARTCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderTextureUnlockPartCollection",
    name_hash: 2397597858,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO),
        super_class_offset: offset_of!(ShaderTextureUnlockPartCollection, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShaderTextureUnlockPartCollection as Default>::default())),
            create_boxed: || Box::new(<ShaderTextureUnlockPartCollection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultTextureReference",
                name_hash: 796555962,
                flags: MemberInfoFlags::new(0),
                field_type: "TextureReference",
                rust_offset: offset_of!(ShaderTextureUnlockPartCollection, default_texture_reference),
            },
            FieldInfoData {
                name: "UnlockParts",
                name_hash: 4116003953,
                flags: MemberInfoFlags::new(144),
                field_type: "TextureUnlockPartData-Array",
                rust_offset: offset_of!(ShaderTextureUnlockPartCollection, unlock_parts),
            },
        ],
    }),
    array_type: Some(SHADERTEXTUREUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ShaderTextureUnlockPartCollection {
    fn type_info(&self) -> &'static TypeInfo {
        SHADERTEXTUREUNLOCKPARTCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADERTEXTUREUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderTextureUnlockPartCollection-Array",
    name_hash: 638668566,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ShaderTextureUnlockPartCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ShaderColorUnlockPartCollection {
    pub _glacier_base: ShaderCustomizationUnlockPartCollection,
    pub default_color_reference: Option<LockedTypeObject /* ColorReference */>,
    pub unlock_parts: Vec<Option<LockedTypeObject /* ColorUnlockPartData */>>,
}

pub trait ShaderColorUnlockPartCollectionTrait: ShaderCustomizationUnlockPartCollectionTrait {
    fn default_color_reference(&self) -> &Option<LockedTypeObject /* ColorReference */>;
    fn default_color_reference_mut(&mut self) -> &mut Option<LockedTypeObject /* ColorReference */>;
    fn unlock_parts(&self) -> &Vec<Option<LockedTypeObject /* ColorUnlockPartData */>>;
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ColorUnlockPartData */>>;
}

impl ShaderColorUnlockPartCollectionTrait for ShaderColorUnlockPartCollection {
    fn default_color_reference(&self) -> &Option<LockedTypeObject /* ColorReference */> {
        &self.default_color_reference
    }
    fn default_color_reference_mut(&mut self) -> &mut Option<LockedTypeObject /* ColorReference */> {
        &mut self.default_color_reference
    }
    fn unlock_parts(&self) -> &Vec<Option<LockedTypeObject /* ColorUnlockPartData */>> {
        &self.unlock_parts
    }
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ColorUnlockPartData */>> {
        &mut self.unlock_parts
    }
}

impl ShaderCustomizationUnlockPartCollectionTrait for ShaderColorUnlockPartCollection {
    fn mesh_blueprints(&self) -> &Vec<Option<LockedTypeObject /* super::entity::ObjectBlueprint */>> {
        self._glacier_base.mesh_blueprints()
    }
    fn mesh_blueprints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::ObjectBlueprint */>> {
        self._glacier_base.mesh_blueprints_mut()
    }
    fn shader_node_name(&self) -> &String {
        self._glacier_base.shader_node_name()
    }
    fn shader_node_name_mut(&mut self) -> &mut String {
        self._glacier_base.shader_node_name_mut()
    }
    fn mesh_materials(&self) -> &Vec<BoxedTypeObject /* CustomizedMeshMaterialsData */> {
        self._glacier_base.mesh_materials()
    }
    fn mesh_materials_mut(&mut self) -> &mut Vec<BoxedTypeObject /* CustomizedMeshMaterialsData */> {
        self._glacier_base.mesh_materials_mut()
    }
}

impl super::core::DataContainerTrait for ShaderColorUnlockPartCollection {
}

pub static SHADERCOLORUNLOCKPARTCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderColorUnlockPartCollection",
    name_hash: 2481019200,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO),
        super_class_offset: offset_of!(ShaderColorUnlockPartCollection, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShaderColorUnlockPartCollection as Default>::default())),
            create_boxed: || Box::new(<ShaderColorUnlockPartCollection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultColorReference",
                name_hash: 1493675992,
                flags: MemberInfoFlags::new(0),
                field_type: "ColorReference",
                rust_offset: offset_of!(ShaderColorUnlockPartCollection, default_color_reference),
            },
            FieldInfoData {
                name: "UnlockParts",
                name_hash: 4116003953,
                flags: MemberInfoFlags::new(144),
                field_type: "ColorUnlockPartData-Array",
                rust_offset: offset_of!(ShaderColorUnlockPartCollection, unlock_parts),
            },
        ],
    }),
    array_type: Some(SHADERCOLORUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ShaderColorUnlockPartCollection {
    fn type_info(&self) -> &'static TypeInfo {
        SHADERCOLORUNLOCKPARTCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADERCOLORUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderColorUnlockPartCollection-Array",
    name_hash: 3820089332,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ShaderColorUnlockPartCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ShaderCustomizationUnlockPartCollection {
    pub _glacier_base: super::core::DataContainer,
    pub mesh_blueprints: Vec<Option<LockedTypeObject /* super::entity::ObjectBlueprint */>>,
    pub shader_node_name: String,
    pub mesh_materials: Vec<BoxedTypeObject /* CustomizedMeshMaterialsData */>,
}

pub trait ShaderCustomizationUnlockPartCollectionTrait: super::core::DataContainerTrait {
    fn mesh_blueprints(&self) -> &Vec<Option<LockedTypeObject /* super::entity::ObjectBlueprint */>>;
    fn mesh_blueprints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::ObjectBlueprint */>>;
    fn shader_node_name(&self) -> &String;
    fn shader_node_name_mut(&mut self) -> &mut String;
    fn mesh_materials(&self) -> &Vec<BoxedTypeObject /* CustomizedMeshMaterialsData */>;
    fn mesh_materials_mut(&mut self) -> &mut Vec<BoxedTypeObject /* CustomizedMeshMaterialsData */>;
}

impl ShaderCustomizationUnlockPartCollectionTrait for ShaderCustomizationUnlockPartCollection {
    fn mesh_blueprints(&self) -> &Vec<Option<LockedTypeObject /* super::entity::ObjectBlueprint */>> {
        &self.mesh_blueprints
    }
    fn mesh_blueprints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::ObjectBlueprint */>> {
        &mut self.mesh_blueprints
    }
    fn shader_node_name(&self) -> &String {
        &self.shader_node_name
    }
    fn shader_node_name_mut(&mut self) -> &mut String {
        &mut self.shader_node_name
    }
    fn mesh_materials(&self) -> &Vec<BoxedTypeObject /* CustomizedMeshMaterialsData */> {
        &self.mesh_materials
    }
    fn mesh_materials_mut(&mut self) -> &mut Vec<BoxedTypeObject /* CustomizedMeshMaterialsData */> {
        &mut self.mesh_materials
    }
}

impl super::core::DataContainerTrait for ShaderCustomizationUnlockPartCollection {
}

pub static SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderCustomizationUnlockPartCollection",
    name_hash: 2357535072,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(ShaderCustomizationUnlockPartCollection, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShaderCustomizationUnlockPartCollection as Default>::default())),
            create_boxed: || Box::new(<ShaderCustomizationUnlockPartCollection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MeshBlueprints",
                name_hash: 3317903690,
                flags: MemberInfoFlags::new(144),
                field_type: "ObjectBlueprint-Array",
                rust_offset: offset_of!(ShaderCustomizationUnlockPartCollection, mesh_blueprints),
            },
            FieldInfoData {
                name: "ShaderNodeName",
                name_hash: 4213969131,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ShaderCustomizationUnlockPartCollection, shader_node_name),
            },
            FieldInfoData {
                name: "MeshMaterials",
                name_hash: 3833968526,
                flags: MemberInfoFlags::new(144),
                field_type: "CustomizedMeshMaterialsData-Array",
                rust_offset: offset_of!(ShaderCustomizationUnlockPartCollection, mesh_materials),
            },
        ],
    }),
    array_type: Some(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ShaderCustomizationUnlockPartCollection {
    fn type_info(&self) -> &'static TypeInfo {
        SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderCustomizationUnlockPartCollection-Array",
    name_hash: 186849108,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ShaderCustomizationUnlockPartCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CustomizedMeshMaterialsData {
    pub mesh_blueprint: Option<LockedTypeObject /* super::entity::ObjectBlueprint */>,
    pub material_names: Vec<String>,
}

pub trait CustomizedMeshMaterialsDataTrait: TypeObject {
    fn mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn material_names(&self) -> &Vec<String>;
    fn material_names_mut(&mut self) -> &mut Vec<String>;
}

impl CustomizedMeshMaterialsDataTrait for CustomizedMeshMaterialsData {
    fn mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &self.mesh_blueprint
    }
    fn mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &mut self.mesh_blueprint
    }
    fn material_names(&self) -> &Vec<String> {
        &self.material_names
    }
    fn material_names_mut(&mut self) -> &mut Vec<String> {
        &mut self.material_names
    }
}

pub static CUSTOMIZEDMESHMATERIALSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizedMeshMaterialsData",
    name_hash: 23567519,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizedMeshMaterialsData as Default>::default())),
            create_boxed: || Box::new(<CustomizedMeshMaterialsData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MeshBlueprint",
                name_hash: 1662348825,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(CustomizedMeshMaterialsData, mesh_blueprint),
            },
            FieldInfoData {
                name: "MaterialNames",
                name_hash: 990812474,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(CustomizedMeshMaterialsData, material_names),
            },
        ],
    }),
    array_type: Some(CUSTOMIZEDMESHMATERIALSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizedMeshMaterialsData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZEDMESHMATERIALSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUSTOMIZEDMESHMATERIALSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizedMeshMaterialsData-Array",
    name_hash: 448708907,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizedMeshMaterialsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockableTextureSliceCollection {
    pub _glacier_base: super::core::DataContainer,
    pub default_value: i32,
    pub possible_values: Vec<Option<LockedTypeObject /* TextureSliceUnlockPartData */>>,
}

pub trait UnlockableTextureSliceCollectionTrait: super::core::DataContainerTrait {
    fn default_value(&self) -> &i32;
    fn default_value_mut(&mut self) -> &mut i32;
    fn possible_values(&self) -> &Vec<Option<LockedTypeObject /* TextureSliceUnlockPartData */>>;
    fn possible_values_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TextureSliceUnlockPartData */>>;
}

impl UnlockableTextureSliceCollectionTrait for UnlockableTextureSliceCollection {
    fn default_value(&self) -> &i32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut i32 {
        &mut self.default_value
    }
    fn possible_values(&self) -> &Vec<Option<LockedTypeObject /* TextureSliceUnlockPartData */>> {
        &self.possible_values
    }
    fn possible_values_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TextureSliceUnlockPartData */>> {
        &mut self.possible_values
    }
}

impl super::core::DataContainerTrait for UnlockableTextureSliceCollection {
}

pub static UNLOCKABLETEXTURESLICECOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableTextureSliceCollection",
    name_hash: 2831206950,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(UnlockableTextureSliceCollection, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockableTextureSliceCollection as Default>::default())),
            create_boxed: || Box::new(<UnlockableTextureSliceCollection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(UnlockableTextureSliceCollection, default_value),
            },
            FieldInfoData {
                name: "PossibleValues",
                name_hash: 349877344,
                flags: MemberInfoFlags::new(144),
                field_type: "TextureSliceUnlockPartData-Array",
                rust_offset: offset_of!(UnlockableTextureSliceCollection, possible_values),
            },
        ],
    }),
    array_type: Some(UNLOCKABLETEXTURESLICECOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockableTextureSliceCollection {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKABLETEXTURESLICECOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKABLETEXTURESLICECOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableTextureSliceCollection-Array",
    name_hash: 3748034194,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockableTextureSliceCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockableTextureCollection {
    pub _glacier_base: super::core::DataContainer,
    pub default_value: Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>,
}

pub trait UnlockableTextureCollectionTrait: super::core::DataContainerTrait {
    fn default_value(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
    fn default_value_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
}

impl UnlockableTextureCollectionTrait for UnlockableTextureCollection {
    fn default_value(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &mut self.default_value
    }
}

impl super::core::DataContainerTrait for UnlockableTextureCollection {
}

pub static UNLOCKABLETEXTURECOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableTextureCollection",
    name_hash: 3152185494,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(UnlockableTextureCollection, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockableTextureCollection as Default>::default())),
            create_boxed: || Box::new(<UnlockableTextureCollection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(UnlockableTextureCollection, default_value),
            },
        ],
    }),
    array_type: Some(UNLOCKABLETEXTURECOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockableTextureCollection {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKABLETEXTURECOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKABLETEXTURECOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableTextureCollection-Array",
    name_hash: 4192484770,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockableTextureCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockableColorCollection {
    pub _glacier_base: super::core::DataContainer,
    pub default_value: Option<LockedTypeObject /* ColorReference */>,
    pub possible_values: Vec<Option<LockedTypeObject /* ColorUnlockPartData */>>,
}

pub trait UnlockableColorCollectionTrait: super::core::DataContainerTrait {
    fn default_value(&self) -> &Option<LockedTypeObject /* ColorReference */>;
    fn default_value_mut(&mut self) -> &mut Option<LockedTypeObject /* ColorReference */>;
    fn possible_values(&self) -> &Vec<Option<LockedTypeObject /* ColorUnlockPartData */>>;
    fn possible_values_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ColorUnlockPartData */>>;
}

impl UnlockableColorCollectionTrait for UnlockableColorCollection {
    fn default_value(&self) -> &Option<LockedTypeObject /* ColorReference */> {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut Option<LockedTypeObject /* ColorReference */> {
        &mut self.default_value
    }
    fn possible_values(&self) -> &Vec<Option<LockedTypeObject /* ColorUnlockPartData */>> {
        &self.possible_values
    }
    fn possible_values_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* ColorUnlockPartData */>> {
        &mut self.possible_values
    }
}

impl super::core::DataContainerTrait for UnlockableColorCollection {
}

pub static UNLOCKABLECOLORCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableColorCollection",
    name_hash: 1249268212,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(UnlockableColorCollection, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockableColorCollection as Default>::default())),
            create_boxed: || Box::new(<UnlockableColorCollection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "ColorReference",
                rust_offset: offset_of!(UnlockableColorCollection, default_value),
            },
            FieldInfoData {
                name: "PossibleValues",
                name_hash: 349877344,
                flags: MemberInfoFlags::new(144),
                field_type: "ColorUnlockPartData-Array",
                rust_offset: offset_of!(UnlockableColorCollection, possible_values),
            },
        ],
    }),
    array_type: Some(UNLOCKABLECOLORCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockableColorCollection {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKABLECOLORCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKABLECOLORCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableColorCollection-Array",
    name_hash: 321461696,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockableColorCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockableShaderParameterValueCollection {
    pub _glacier_base: super::core::DataContainer,
    pub shader_parameter_name: String,
}

pub trait UnlockableShaderParameterValueCollectionTrait: super::core::DataContainerTrait {
    fn shader_parameter_name(&self) -> &String;
    fn shader_parameter_name_mut(&mut self) -> &mut String;
}

impl UnlockableShaderParameterValueCollectionTrait for UnlockableShaderParameterValueCollection {
    fn shader_parameter_name(&self) -> &String {
        &self.shader_parameter_name
    }
    fn shader_parameter_name_mut(&mut self) -> &mut String {
        &mut self.shader_parameter_name
    }
}

impl super::core::DataContainerTrait for UnlockableShaderParameterValueCollection {
}

pub static UNLOCKABLESHADERPARAMETERVALUECOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableShaderParameterValueCollection",
    name_hash: 580564898,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(UnlockableShaderParameterValueCollection, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockableShaderParameterValueCollection as Default>::default())),
            create_boxed: || Box::new(<UnlockableShaderParameterValueCollection as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ShaderParameterName",
                name_hash: 610960642,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(UnlockableShaderParameterValueCollection, shader_parameter_name),
            },
        ],
    }),
    array_type: Some(UNLOCKABLESHADERPARAMETERVALUECOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockableShaderParameterValueCollection {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKABLESHADERPARAMETERVALUECOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKABLESHADERPARAMETERVALUECOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableShaderParameterValueCollection-Array",
    name_hash: 2652689942,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockableShaderParameterValueCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TextureSliceUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub slice_index: i32,
}

pub trait TextureSliceUnlockPartDataTrait: super::core::DataContainerTrait {
    fn slice_index(&self) -> &i32;
    fn slice_index_mut(&mut self) -> &mut i32;
}

impl TextureSliceUnlockPartDataTrait for TextureSliceUnlockPartData {
    fn slice_index(&self) -> &i32 {
        &self.slice_index
    }
    fn slice_index_mut(&mut self) -> &mut i32 {
        &mut self.slice_index
    }
}

impl super::core::DataContainerTrait for TextureSliceUnlockPartData {
}

pub static TEXTURESLICEUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureSliceUnlockPartData",
    name_hash: 3404650717,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(TextureSliceUnlockPartData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextureSliceUnlockPartData as Default>::default())),
            create_boxed: || Box::new(<TextureSliceUnlockPartData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SliceIndex",
                name_hash: 3448212171,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TextureSliceUnlockPartData, slice_index),
            },
        ],
    }),
    array_type: Some(TEXTURESLICEUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextureSliceUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTURESLICEUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTURESLICEUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureSliceUnlockPartData-Array",
    name_hash: 4015371497,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextureSliceUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TextureAssetUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub texture: Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>,
}

pub trait TextureAssetUnlockPartDataTrait: super::core::DataContainerTrait {
    fn texture(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
    fn texture_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
}

impl TextureAssetUnlockPartDataTrait for TextureAssetUnlockPartData {
    fn texture(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &mut self.texture
    }
}

impl super::core::DataContainerTrait for TextureAssetUnlockPartData {
}

pub static TEXTUREASSETUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureAssetUnlockPartData",
    name_hash: 2700264829,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(TextureAssetUnlockPartData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextureAssetUnlockPartData as Default>::default())),
            create_boxed: || Box::new(<TextureAssetUnlockPartData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Texture",
                name_hash: 3185041626,
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(TextureAssetUnlockPartData, texture),
            },
        ],
    }),
    array_type: Some(TEXTUREASSETUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextureAssetUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTUREASSETUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTUREASSETUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureAssetUnlockPartData-Array",
    name_hash: 1719210569,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextureAssetUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TextureUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub texture_reference: Option<LockedTypeObject /* TextureReference */>,
}

pub trait TextureUnlockPartDataTrait: super::core::DataContainerTrait {
    fn texture_reference(&self) -> &Option<LockedTypeObject /* TextureReference */>;
    fn texture_reference_mut(&mut self) -> &mut Option<LockedTypeObject /* TextureReference */>;
}

impl TextureUnlockPartDataTrait for TextureUnlockPartData {
    fn texture_reference(&self) -> &Option<LockedTypeObject /* TextureReference */> {
        &self.texture_reference
    }
    fn texture_reference_mut(&mut self) -> &mut Option<LockedTypeObject /* TextureReference */> {
        &mut self.texture_reference
    }
}

impl super::core::DataContainerTrait for TextureUnlockPartData {
}

pub static TEXTUREUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureUnlockPartData",
    name_hash: 300161517,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(TextureUnlockPartData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextureUnlockPartData as Default>::default())),
            create_boxed: || Box::new(<TextureUnlockPartData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TextureReference",
                name_hash: 2751309329,
                flags: MemberInfoFlags::new(0),
                field_type: "TextureReference",
                rust_offset: offset_of!(TextureUnlockPartData, texture_reference),
            },
        ],
    }),
    array_type: Some(TEXTUREUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextureUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTUREUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTUREUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureUnlockPartData-Array",
    name_hash: 3517251289,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextureUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TextureReference {
    pub _glacier_base: super::core::Asset,
    pub texture: Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>,
}

pub trait TextureReferenceTrait: super::core::AssetTrait {
    fn texture(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
    fn texture_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
}

impl TextureReferenceTrait for TextureReference {
    fn texture(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &mut self.texture
    }
}

impl super::core::AssetTrait for TextureReference {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for TextureReference {
}

pub static TEXTUREREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureReference",
    name_hash: 2751309329,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(TextureReference, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextureReference as Default>::default())),
            create_boxed: || Box::new(<TextureReference as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Texture",
                name_hash: 3185041626,
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(TextureReference, texture),
            },
        ],
    }),
    array_type: Some(TEXTUREREFERENCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextureReference {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTUREREFERENCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTUREREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureReference-Array",
    name_hash: 555640741,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextureReference"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ColorUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub color_reference: Option<LockedTypeObject /* ColorReference */>,
}

pub trait ColorUnlockPartDataTrait: super::core::DataContainerTrait {
    fn color_reference(&self) -> &Option<LockedTypeObject /* ColorReference */>;
    fn color_reference_mut(&mut self) -> &mut Option<LockedTypeObject /* ColorReference */>;
}

impl ColorUnlockPartDataTrait for ColorUnlockPartData {
    fn color_reference(&self) -> &Option<LockedTypeObject /* ColorReference */> {
        &self.color_reference
    }
    fn color_reference_mut(&mut self) -> &mut Option<LockedTypeObject /* ColorReference */> {
        &mut self.color_reference
    }
}

impl super::core::DataContainerTrait for ColorUnlockPartData {
}

pub static COLORUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorUnlockPartData",
    name_hash: 17047375,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(ColorUnlockPartData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ColorUnlockPartData as Default>::default())),
            create_boxed: || Box::new(<ColorUnlockPartData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ColorReference",
                name_hash: 16575987,
                flags: MemberInfoFlags::new(0),
                field_type: "ColorReference",
                rust_offset: offset_of!(ColorUnlockPartData, color_reference),
            },
        ],
    }),
    array_type: Some(COLORUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ColorUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        COLORUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLORUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorUnlockPartData-Array",
    name_hash: 1426017403,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ColorUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ColorReference {
    pub _glacier_base: super::core::Asset,
    pub color: super::core::Vec4,
}

pub trait ColorReferenceTrait: super::core::AssetTrait {
    fn color(&self) -> &super::core::Vec4;
    fn color_mut(&mut self) -> &mut super::core::Vec4;
}

impl ColorReferenceTrait for ColorReference {
    fn color(&self) -> &super::core::Vec4 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.color
    }
}

impl super::core::AssetTrait for ColorReference {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ColorReference {
}

pub static COLORREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorReference",
    name_hash: 16575987,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(ColorReference, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ColorReference as Default>::default())),
            create_boxed: || Box::new(<ColorReference as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Color",
                name_hash: 212387320,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(ColorReference, color),
            },
        ],
    }),
    array_type: Some(COLORREFERENCE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ColorReference {
    fn type_info(&self) -> &'static TypeInfo {
        COLORREFERENCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLORREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorReference-Array",
    name_hash: 4069312967,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ColorReference"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AreaImmunityComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub clear_area_immunity: bool,
}

pub trait AreaImmunityComponentDataTrait: super::entity::GameComponentDataTrait {
    fn clear_area_immunity(&self) -> &bool;
    fn clear_area_immunity_mut(&mut self) -> &mut bool;
}

impl AreaImmunityComponentDataTrait for AreaImmunityComponentData {
    fn clear_area_immunity(&self) -> &bool {
        &self.clear_area_immunity
    }
    fn clear_area_immunity_mut(&mut self) -> &mut bool {
        &mut self.clear_area_immunity
    }
}

impl super::entity::GameComponentDataTrait for AreaImmunityComponentData {
}

impl super::entity::ComponentDataTrait for AreaImmunityComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AreaImmunityComponentData {
}

impl super::core::DataBusPeerTrait for AreaImmunityComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AreaImmunityComponentData {
}

impl super::core::DataContainerTrait for AreaImmunityComponentData {
}

pub static AREAIMMUNITYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaImmunityComponentData",
    name_hash: 3269650971,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(AreaImmunityComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AreaImmunityComponentData as Default>::default())),
            create_boxed: || Box::new(<AreaImmunityComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ClearAreaImmunity",
                name_hash: 1517086045,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaImmunityComponentData, clear_area_immunity),
            },
        ],
    }),
    array_type: Some(AREAIMMUNITYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AreaImmunityComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AREAIMMUNITYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AREAIMMUNITYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaImmunityComponentData-Array",
    name_hash: 1822326959,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaImmunityComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WaterDepthComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub auto_start: bool,
    pub reset_on_stop: bool,
    pub player_only: bool,
    pub update_rate: u32,
    pub enabled: bool,
}

pub trait WaterDepthComponentDataTrait: super::entity::GameComponentDataTrait {
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn reset_on_stop(&self) -> &bool;
    fn reset_on_stop_mut(&mut self) -> &mut bool;
    fn player_only(&self) -> &bool;
    fn player_only_mut(&mut self) -> &mut bool;
    fn update_rate(&self) -> &u32;
    fn update_rate_mut(&mut self) -> &mut u32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl WaterDepthComponentDataTrait for WaterDepthComponentData {
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn reset_on_stop(&self) -> &bool {
        &self.reset_on_stop
    }
    fn reset_on_stop_mut(&mut self) -> &mut bool {
        &mut self.reset_on_stop
    }
    fn player_only(&self) -> &bool {
        &self.player_only
    }
    fn player_only_mut(&mut self) -> &mut bool {
        &mut self.player_only
    }
    fn update_rate(&self) -> &u32 {
        &self.update_rate
    }
    fn update_rate_mut(&mut self) -> &mut u32 {
        &mut self.update_rate
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::GameComponentDataTrait for WaterDepthComponentData {
}

impl super::entity::ComponentDataTrait for WaterDepthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WaterDepthComponentData {
}

impl super::core::DataBusPeerTrait for WaterDepthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WaterDepthComponentData {
}

impl super::core::DataContainerTrait for WaterDepthComponentData {
}

pub static WATERDEPTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterDepthComponentData",
    name_hash: 3219279522,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(WaterDepthComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaterDepthComponentData as Default>::default())),
            create_boxed: || Box::new(<WaterDepthComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AutoStart",
                name_hash: 792615882,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthComponentData, auto_start),
            },
            FieldInfoData {
                name: "ResetOnStop",
                name_hash: 2700470473,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthComponentData, reset_on_stop),
            },
            FieldInfoData {
                name: "PlayerOnly",
                name_hash: 775446434,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthComponentData, player_only),
            },
            FieldInfoData {
                name: "UpdateRate",
                name_hash: 2270996982,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(WaterDepthComponentData, update_rate),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthComponentData, enabled),
            },
        ],
    }),
    array_type: Some(WATERDEPTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WaterDepthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WATERDEPTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WATERDEPTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterDepthComponentData-Array",
    name_hash: 1853467926,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WaterDepthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LadderComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait LadderComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl LadderComponentDataTrait for LadderComponentData {
}

impl super::entity::GameComponentDataTrait for LadderComponentData {
}

impl super::entity::ComponentDataTrait for LadderComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LadderComponentData {
}

impl super::core::DataBusPeerTrait for LadderComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LadderComponentData {
}

impl super::core::DataContainerTrait for LadderComponentData {
}

pub static LADDERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LadderComponentData",
    name_hash: 1043426720,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(LadderComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LadderComponentData as Default>::default())),
            create_boxed: || Box::new(<LadderComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(LADDERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LadderComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LADDERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LADDERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LadderComponentData-Array",
    name_hash: 3744174868,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LadderComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntityToComponentsResetMessage {
}

pub trait EntityToComponentsResetMessageTrait: TypeObject {
}

impl EntityToComponentsResetMessageTrait for EntityToComponentsResetMessage {
}

pub static ENTITYTOCOMPONENTSRESETMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityToComponentsResetMessage",
    name_hash: 1388390087,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityToComponentsResetMessage as Default>::default())),
            create_boxed: || Box::new(<EntityToComponentsResetMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for EntityToComponentsResetMessage {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYTOCOMPONENTSRESETMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct AlternateCameraViewData {
    pub _glacier_base: super::core::DataContainer,
    pub field_of_view: f32,
    pub allow_field_of_view_scaling: bool,
    pub fov_transition_time: f32,
    pub world_space_lock_efficiency: f32,
    pub mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub mask_mesh_blueprint: Option<LockedTypeObject /* super::entity::ObjectBlueprint */>,
    pub lock_mesh_to_render_view: bool,
    pub mesh_offset: super::core::Vec3,
    pub hud: Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>>,
    pub fade_to_black: bool,
    pub fade_in_duration: f32,
    pub fade_out_duration: f32,
    pub black_duration: f32,
    pub input_suppression: InputSuppressionData,
    pub toggle_view_change: bool,
    pub use_profile_option_for_toggle_view_change: bool,
    pub f_l_i_r_enabled: bool,
    pub screen_exposure_area_scale: f32,
}

pub trait AlternateCameraViewDataTrait: super::core::DataContainerTrait {
    fn field_of_view(&self) -> &f32;
    fn field_of_view_mut(&mut self) -> &mut f32;
    fn allow_field_of_view_scaling(&self) -> &bool;
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool;
    fn fov_transition_time(&self) -> &f32;
    fn fov_transition_time_mut(&mut self) -> &mut f32;
    fn world_space_lock_efficiency(&self) -> &f32;
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32;
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mask_mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn mask_mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn lock_mesh_to_render_view(&self) -> &bool;
    fn lock_mesh_to_render_view_mut(&mut self) -> &mut bool;
    fn mesh_offset(&self) -> &super::core::Vec3;
    fn mesh_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn hud(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>>;
    fn hud_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>>;
    fn fade_to_black(&self) -> &bool;
    fn fade_to_black_mut(&mut self) -> &mut bool;
    fn fade_in_duration(&self) -> &f32;
    fn fade_in_duration_mut(&mut self) -> &mut f32;
    fn fade_out_duration(&self) -> &f32;
    fn fade_out_duration_mut(&mut self) -> &mut f32;
    fn black_duration(&self) -> &f32;
    fn black_duration_mut(&mut self) -> &mut f32;
    fn input_suppression(&self) -> &InputSuppressionData;
    fn input_suppression_mut(&mut self) -> &mut InputSuppressionData;
    fn toggle_view_change(&self) -> &bool;
    fn toggle_view_change_mut(&mut self) -> &mut bool;
    fn use_profile_option_for_toggle_view_change(&self) -> &bool;
    fn use_profile_option_for_toggle_view_change_mut(&mut self) -> &mut bool;
    fn f_l_i_r_enabled(&self) -> &bool;
    fn f_l_i_r_enabled_mut(&mut self) -> &mut bool;
    fn screen_exposure_area_scale(&self) -> &f32;
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32;
}

impl AlternateCameraViewDataTrait for AlternateCameraViewData {
    fn field_of_view(&self) -> &f32 {
        &self.field_of_view
    }
    fn field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view
    }
    fn allow_field_of_view_scaling(&self) -> &bool {
        &self.allow_field_of_view_scaling
    }
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool {
        &mut self.allow_field_of_view_scaling
    }
    fn fov_transition_time(&self) -> &f32 {
        &self.fov_transition_time
    }
    fn fov_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.fov_transition_time
    }
    fn world_space_lock_efficiency(&self) -> &f32 {
        &self.world_space_lock_efficiency
    }
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh
    }
    fn mask_mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &self.mask_mesh_blueprint
    }
    fn mask_mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &mut self.mask_mesh_blueprint
    }
    fn lock_mesh_to_render_view(&self) -> &bool {
        &self.lock_mesh_to_render_view
    }
    fn lock_mesh_to_render_view_mut(&mut self) -> &mut bool {
        &mut self.lock_mesh_to_render_view
    }
    fn mesh_offset(&self) -> &super::core::Vec3 {
        &self.mesh_offset
    }
    fn mesh_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.mesh_offset
    }
    fn hud(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        &self.hud
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        &mut self.hud
    }
    fn fade_to_black(&self) -> &bool {
        &self.fade_to_black
    }
    fn fade_to_black_mut(&mut self) -> &mut bool {
        &mut self.fade_to_black
    }
    fn fade_in_duration(&self) -> &f32 {
        &self.fade_in_duration
    }
    fn fade_in_duration_mut(&mut self) -> &mut f32 {
        &mut self.fade_in_duration
    }
    fn fade_out_duration(&self) -> &f32 {
        &self.fade_out_duration
    }
    fn fade_out_duration_mut(&mut self) -> &mut f32 {
        &mut self.fade_out_duration
    }
    fn black_duration(&self) -> &f32 {
        &self.black_duration
    }
    fn black_duration_mut(&mut self) -> &mut f32 {
        &mut self.black_duration
    }
    fn input_suppression(&self) -> &InputSuppressionData {
        &self.input_suppression
    }
    fn input_suppression_mut(&mut self) -> &mut InputSuppressionData {
        &mut self.input_suppression
    }
    fn toggle_view_change(&self) -> &bool {
        &self.toggle_view_change
    }
    fn toggle_view_change_mut(&mut self) -> &mut bool {
        &mut self.toggle_view_change
    }
    fn use_profile_option_for_toggle_view_change(&self) -> &bool {
        &self.use_profile_option_for_toggle_view_change
    }
    fn use_profile_option_for_toggle_view_change_mut(&mut self) -> &mut bool {
        &mut self.use_profile_option_for_toggle_view_change
    }
    fn f_l_i_r_enabled(&self) -> &bool {
        &self.f_l_i_r_enabled
    }
    fn f_l_i_r_enabled_mut(&mut self) -> &mut bool {
        &mut self.f_l_i_r_enabled
    }
    fn screen_exposure_area_scale(&self) -> &f32 {
        &self.screen_exposure_area_scale
    }
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32 {
        &mut self.screen_exposure_area_scale
    }
}

impl super::core::DataContainerTrait for AlternateCameraViewData {
}

pub static ALTERNATECAMERAVIEWDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlternateCameraViewData",
    name_hash: 3141996945,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AlternateCameraViewData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AlternateCameraViewData as Default>::default())),
            create_boxed: || Box::new(<AlternateCameraViewData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FieldOfView",
                name_hash: 2227716035,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, field_of_view),
            },
            FieldInfoData {
                name: "AllowFieldOfViewScaling",
                name_hash: 899159559,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, allow_field_of_view_scaling),
            },
            FieldInfoData {
                name: "FovTransitionTime",
                name_hash: 1751899392,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, fov_transition_time),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiency",
                name_hash: 4063999679,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, world_space_lock_efficiency),
            },
            FieldInfoData {
                name: "Mesh",
                name_hash: 2088783990,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(AlternateCameraViewData, mesh),
            },
            FieldInfoData {
                name: "MaskMeshBlueprint",
                name_hash: 775268525,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(AlternateCameraViewData, mask_mesh_blueprint),
            },
            FieldInfoData {
                name: "LockMeshToRenderView",
                name_hash: 3810317313,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, lock_mesh_to_render_view),
            },
            FieldInfoData {
                name: "MeshOffset",
                name_hash: 775818267,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AlternateCameraViewData, mesh_offset),
            },
            FieldInfoData {
                name: "Hud",
                name_hash: 193458844,
                flags: MemberInfoFlags::new(144),
                field_type: "HudData-Array",
                rust_offset: offset_of!(AlternateCameraViewData, hud),
            },
            FieldInfoData {
                name: "FadeToBlack",
                name_hash: 325525503,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, fade_to_black),
            },
            FieldInfoData {
                name: "FadeInDuration",
                name_hash: 2433887354,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, fade_in_duration),
            },
            FieldInfoData {
                name: "FadeOutDuration",
                name_hash: 556400947,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, fade_out_duration),
            },
            FieldInfoData {
                name: "BlackDuration",
                name_hash: 1274814300,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, black_duration),
            },
            FieldInfoData {
                name: "InputSuppression",
                name_hash: 2197295466,
                flags: MemberInfoFlags::new(0),
                field_type: "InputSuppressionData",
                rust_offset: offset_of!(AlternateCameraViewData, input_suppression),
            },
            FieldInfoData {
                name: "ToggleViewChange",
                name_hash: 4173306524,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, toggle_view_change),
            },
            FieldInfoData {
                name: "UseProfileOptionForToggleViewChange",
                name_hash: 731278668,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, use_profile_option_for_toggle_view_change),
            },
            FieldInfoData {
                name: "FLIREnabled",
                name_hash: 1594804433,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, f_l_i_r_enabled),
            },
            FieldInfoData {
                name: "ScreenExposureAreaScale",
                name_hash: 2151479797,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, screen_exposure_area_scale),
            },
        ],
    }),
    array_type: Some(ALTERNATECAMERAVIEWDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AlternateCameraViewData {
    fn type_info(&self) -> &'static TypeInfo {
        ALTERNATECAMERAVIEWDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ALTERNATECAMERAVIEWDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlternateCameraViewData-Array",
    name_hash: 3752489765,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AlternateCameraViewData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CollisionEffectSpawnComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub effect_parameters: Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>>,
    pub speed_limit: f32,
}

pub trait CollisionEffectSpawnComponentDataTrait: super::entity::GameComponentDataTrait {
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>>;
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>>;
    fn speed_limit(&self) -> &f32;
    fn speed_limit_mut(&mut self) -> &mut f32;
}

impl CollisionEffectSpawnComponentDataTrait for CollisionEffectSpawnComponentData {
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        &self.effect_parameters
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        &mut self.effect_parameters
    }
    fn speed_limit(&self) -> &f32 {
        &self.speed_limit
    }
    fn speed_limit_mut(&mut self) -> &mut f32 {
        &mut self.speed_limit
    }
}

impl super::entity::GameComponentDataTrait for CollisionEffectSpawnComponentData {
}

impl super::entity::ComponentDataTrait for CollisionEffectSpawnComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CollisionEffectSpawnComponentData {
}

impl super::core::DataBusPeerTrait for CollisionEffectSpawnComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CollisionEffectSpawnComponentData {
}

impl super::core::DataContainerTrait for CollisionEffectSpawnComponentData {
}

pub static COLLISIONEFFECTSPAWNCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionEffectSpawnComponentData",
    name_hash: 2258221992,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CollisionEffectSpawnComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CollisionEffectSpawnComponentData as Default>::default())),
            create_boxed: || Box::new(<CollisionEffectSpawnComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EffectParameters",
                name_hash: 929782248,
                flags: MemberInfoFlags::new(144),
                field_type: "EffectParameter-Array",
                rust_offset: offset_of!(CollisionEffectSpawnComponentData, effect_parameters),
            },
            FieldInfoData {
                name: "SpeedLimit",
                name_hash: 4082744151,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionEffectSpawnComponentData, speed_limit),
            },
        ],
    }),
    array_type: Some(COLLISIONEFFECTSPAWNCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CollisionEffectSpawnComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        COLLISIONEFFECTSPAWNCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLLISIONEFFECTSPAWNCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionEffectSpawnComponentData-Array",
    name_hash: 1452653852,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CollisionEffectSpawnComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EffectComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub effect: Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>,
    pub auto_start: bool,
    pub snap_to_water_surface: bool,
    pub emitter_parameter1: f32,
    pub emitter_parameter2: f32,
    pub emitter_parameter3: f32,
    pub override_height: f32,
    pub max_instances: i32,
    pub effect_parameters: Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>>,
    pub is_first_person: bool,
}

pub trait EffectComponentDataTrait: super::entity::GameComponentDataTrait {
    fn effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn snap_to_water_surface(&self) -> &bool;
    fn snap_to_water_surface_mut(&mut self) -> &mut bool;
    fn emitter_parameter1(&self) -> &f32;
    fn emitter_parameter1_mut(&mut self) -> &mut f32;
    fn emitter_parameter2(&self) -> &f32;
    fn emitter_parameter2_mut(&mut self) -> &mut f32;
    fn emitter_parameter3(&self) -> &f32;
    fn emitter_parameter3_mut(&mut self) -> &mut f32;
    fn override_height(&self) -> &f32;
    fn override_height_mut(&mut self) -> &mut f32;
    fn max_instances(&self) -> &i32;
    fn max_instances_mut(&mut self) -> &mut i32;
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>>;
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>>;
    fn is_first_person(&self) -> &bool;
    fn is_first_person_mut(&mut self) -> &mut bool;
}

impl EffectComponentDataTrait for EffectComponentData {
    fn effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &self.effect
    }
    fn effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &mut self.effect
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn snap_to_water_surface(&self) -> &bool {
        &self.snap_to_water_surface
    }
    fn snap_to_water_surface_mut(&mut self) -> &mut bool {
        &mut self.snap_to_water_surface
    }
    fn emitter_parameter1(&self) -> &f32 {
        &self.emitter_parameter1
    }
    fn emitter_parameter1_mut(&mut self) -> &mut f32 {
        &mut self.emitter_parameter1
    }
    fn emitter_parameter2(&self) -> &f32 {
        &self.emitter_parameter2
    }
    fn emitter_parameter2_mut(&mut self) -> &mut f32 {
        &mut self.emitter_parameter2
    }
    fn emitter_parameter3(&self) -> &f32 {
        &self.emitter_parameter3
    }
    fn emitter_parameter3_mut(&mut self) -> &mut f32 {
        &mut self.emitter_parameter3
    }
    fn override_height(&self) -> &f32 {
        &self.override_height
    }
    fn override_height_mut(&mut self) -> &mut f32 {
        &mut self.override_height
    }
    fn max_instances(&self) -> &i32 {
        &self.max_instances
    }
    fn max_instances_mut(&mut self) -> &mut i32 {
        &mut self.max_instances
    }
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        &self.effect_parameters
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        &mut self.effect_parameters
    }
    fn is_first_person(&self) -> &bool {
        &self.is_first_person
    }
    fn is_first_person_mut(&mut self) -> &mut bool {
        &mut self.is_first_person
    }
}

impl super::entity::GameComponentDataTrait for EffectComponentData {
}

impl super::entity::ComponentDataTrait for EffectComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EffectComponentData {
}

impl super::core::DataBusPeerTrait for EffectComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EffectComponentData {
}

impl super::core::DataContainerTrait for EffectComponentData {
}

pub static EFFECTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EffectComponentData",
    name_hash: 3882874989,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(EffectComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EffectComponentData as Default>::default())),
            create_boxed: || Box::new(<EffectComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Effect",
                name_hash: 2332983090,
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(EffectComponentData, effect),
            },
            FieldInfoData {
                name: "AutoStart",
                name_hash: 792615882,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EffectComponentData, auto_start),
            },
            FieldInfoData {
                name: "SnapToWaterSurface",
                name_hash: 2958537010,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EffectComponentData, snap_to_water_surface),
            },
            FieldInfoData {
                name: "EmitterParameter1",
                name_hash: 3454545451,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EffectComponentData, emitter_parameter1),
            },
            FieldInfoData {
                name: "EmitterParameter2",
                name_hash: 3454545448,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EffectComponentData, emitter_parameter2),
            },
            FieldInfoData {
                name: "EmitterParameter3",
                name_hash: 3454545449,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EffectComponentData, emitter_parameter3),
            },
            FieldInfoData {
                name: "OverrideHeight",
                name_hash: 3774759278,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EffectComponentData, override_height),
            },
            FieldInfoData {
                name: "MaxInstances",
                name_hash: 3494173515,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EffectComponentData, max_instances),
            },
            FieldInfoData {
                name: "EffectParameters",
                name_hash: 929782248,
                flags: MemberInfoFlags::new(144),
                field_type: "EffectParameter-Array",
                rust_offset: offset_of!(EffectComponentData, effect_parameters),
            },
            FieldInfoData {
                name: "IsFirstPerson",
                name_hash: 824639024,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EffectComponentData, is_first_person),
            },
        ],
    }),
    array_type: Some(EFFECTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EffectComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        EFFECTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EFFECTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EffectComponentData-Array",
    name_hash: 3778919769,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EffectComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CustomizationConstants {
    #[default]
    MaxVisualSockets = 16,
    MaxAttachedSockets = 4,
}

pub static CUSTOMIZATIONCONSTANTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationConstants",
    name_hash: 585853557,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CUSTOMIZATIONCONSTANTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CustomizationConstants {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZATIONCONSTANTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUSTOMIZATIONCONSTANTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationConstants-Array",
    name_hash: 2300189505,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizationConstants"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RegularCameraViewData {
    pub f_l_i_r_enabled: bool,
    pub input_suppression: InputSuppressionData,
    pub field_of_view: f32,
    pub allow_field_of_view_scaling: bool,
    pub mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub mask_mesh_blueprint: Option<LockedTypeObject /* super::entity::ObjectBlueprint */>,
    pub lock_mesh_to_render_view: bool,
    pub mesh_offset: super::core::Vec3,
    pub screen_exposure_area_scale: f32,
}

pub trait RegularCameraViewDataTrait: TypeObject {
    fn f_l_i_r_enabled(&self) -> &bool;
    fn f_l_i_r_enabled_mut(&mut self) -> &mut bool;
    fn input_suppression(&self) -> &InputSuppressionData;
    fn input_suppression_mut(&mut self) -> &mut InputSuppressionData;
    fn field_of_view(&self) -> &f32;
    fn field_of_view_mut(&mut self) -> &mut f32;
    fn allow_field_of_view_scaling(&self) -> &bool;
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool;
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mask_mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn mask_mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn lock_mesh_to_render_view(&self) -> &bool;
    fn lock_mesh_to_render_view_mut(&mut self) -> &mut bool;
    fn mesh_offset(&self) -> &super::core::Vec3;
    fn mesh_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn screen_exposure_area_scale(&self) -> &f32;
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32;
}

impl RegularCameraViewDataTrait for RegularCameraViewData {
    fn f_l_i_r_enabled(&self) -> &bool {
        &self.f_l_i_r_enabled
    }
    fn f_l_i_r_enabled_mut(&mut self) -> &mut bool {
        &mut self.f_l_i_r_enabled
    }
    fn input_suppression(&self) -> &InputSuppressionData {
        &self.input_suppression
    }
    fn input_suppression_mut(&mut self) -> &mut InputSuppressionData {
        &mut self.input_suppression
    }
    fn field_of_view(&self) -> &f32 {
        &self.field_of_view
    }
    fn field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view
    }
    fn allow_field_of_view_scaling(&self) -> &bool {
        &self.allow_field_of_view_scaling
    }
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool {
        &mut self.allow_field_of_view_scaling
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh
    }
    fn mask_mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &self.mask_mesh_blueprint
    }
    fn mask_mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &mut self.mask_mesh_blueprint
    }
    fn lock_mesh_to_render_view(&self) -> &bool {
        &self.lock_mesh_to_render_view
    }
    fn lock_mesh_to_render_view_mut(&mut self) -> &mut bool {
        &mut self.lock_mesh_to_render_view
    }
    fn mesh_offset(&self) -> &super::core::Vec3 {
        &self.mesh_offset
    }
    fn mesh_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.mesh_offset
    }
    fn screen_exposure_area_scale(&self) -> &f32 {
        &self.screen_exposure_area_scale
    }
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32 {
        &mut self.screen_exposure_area_scale
    }
}

pub static REGULARCAMERAVIEWDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RegularCameraViewData",
    name_hash: 2602187035,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RegularCameraViewData as Default>::default())),
            create_boxed: || Box::new(<RegularCameraViewData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FLIREnabled",
                name_hash: 1594804433,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RegularCameraViewData, f_l_i_r_enabled),
            },
            FieldInfoData {
                name: "InputSuppression",
                name_hash: 2197295466,
                flags: MemberInfoFlags::new(0),
                field_type: "InputSuppressionData",
                rust_offset: offset_of!(RegularCameraViewData, input_suppression),
            },
            FieldInfoData {
                name: "FieldOfView",
                name_hash: 2227716035,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RegularCameraViewData, field_of_view),
            },
            FieldInfoData {
                name: "AllowFieldOfViewScaling",
                name_hash: 899159559,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RegularCameraViewData, allow_field_of_view_scaling),
            },
            FieldInfoData {
                name: "Mesh",
                name_hash: 2088783990,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(RegularCameraViewData, mesh),
            },
            FieldInfoData {
                name: "MaskMeshBlueprint",
                name_hash: 775268525,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(RegularCameraViewData, mask_mesh_blueprint),
            },
            FieldInfoData {
                name: "LockMeshToRenderView",
                name_hash: 3810317313,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RegularCameraViewData, lock_mesh_to_render_view),
            },
            FieldInfoData {
                name: "MeshOffset",
                name_hash: 775818267,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RegularCameraViewData, mesh_offset),
            },
            FieldInfoData {
                name: "ScreenExposureAreaScale",
                name_hash: 2151479797,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RegularCameraViewData, screen_exposure_area_scale),
            },
        ],
    }),
    array_type: Some(REGULARCAMERAVIEWDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RegularCameraViewData {
    fn type_info(&self) -> &'static TypeInfo {
        REGULARCAMERAVIEWDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static REGULARCAMERAVIEWDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RegularCameraViewData-Array",
    name_hash: 2329218991,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RegularCameraViewData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct InputSuppressionData {
    pub suppress_vehicle_input: Vec<BoxedTypeObject /* ActionSuppressor */>,
}

pub trait InputSuppressionDataTrait: TypeObject {
    fn suppress_vehicle_input(&self) -> &Vec<BoxedTypeObject /* ActionSuppressor */>;
    fn suppress_vehicle_input_mut(&mut self) -> &mut Vec<BoxedTypeObject /* ActionSuppressor */>;
}

impl InputSuppressionDataTrait for InputSuppressionData {
    fn suppress_vehicle_input(&self) -> &Vec<BoxedTypeObject /* ActionSuppressor */> {
        &self.suppress_vehicle_input
    }
    fn suppress_vehicle_input_mut(&mut self) -> &mut Vec<BoxedTypeObject /* ActionSuppressor */> {
        &mut self.suppress_vehicle_input
    }
}

pub static INPUTSUPPRESSIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputSuppressionData",
    name_hash: 2050789978,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputSuppressionData as Default>::default())),
            create_boxed: || Box::new(<InputSuppressionData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SuppressVehicleInput",
                name_hash: 141479834,
                flags: MemberInfoFlags::new(144),
                field_type: "ActionSuppressor-Array",
                rust_offset: offset_of!(InputSuppressionData, suppress_vehicle_input),
            },
        ],
    }),
    array_type: Some(INPUTSUPPRESSIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputSuppressionData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTSUPPRESSIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INPUTSUPPRESSIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputSuppressionData-Array",
    name_hash: 1176405486,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InputSuppressionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WeaponClassification {
    #[default]
    WCNone = 0,
    WCPrimary = 1,
    WCSecondary = 2,
}

pub static WEAPONCLASSIFICATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponClassification",
    name_hash: 275937681,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(WEAPONCLASSIFICATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WeaponClassification {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONCLASSIFICATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONCLASSIFICATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponClassification-Array",
    name_hash: 3519273765,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WeaponClassification"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BuoyantPartsData {
    pub part_name: BuoyantParts,
    pub buoyancy: f32,
}

pub trait BuoyantPartsDataTrait: TypeObject {
    fn part_name(&self) -> &BuoyantParts;
    fn part_name_mut(&mut self) -> &mut BuoyantParts;
    fn buoyancy(&self) -> &f32;
    fn buoyancy_mut(&mut self) -> &mut f32;
}

impl BuoyantPartsDataTrait for BuoyantPartsData {
    fn part_name(&self) -> &BuoyantParts {
        &self.part_name
    }
    fn part_name_mut(&mut self) -> &mut BuoyantParts {
        &mut self.part_name
    }
    fn buoyancy(&self) -> &f32 {
        &self.buoyancy
    }
    fn buoyancy_mut(&mut self) -> &mut f32 {
        &mut self.buoyancy
    }
}

pub static BUOYANTPARTSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuoyantPartsData",
    name_hash: 530296651,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BuoyantPartsData as Default>::default())),
            create_boxed: || Box::new(<BuoyantPartsData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PartName",
                name_hash: 3741572853,
                flags: MemberInfoFlags::new(0),
                field_type: "BuoyantParts",
                rust_offset: offset_of!(BuoyantPartsData, part_name),
            },
            FieldInfoData {
                name: "Buoyancy",
                name_hash: 1313602449,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuoyantPartsData, buoyancy),
            },
        ],
    }),
    array_type: Some(BUOYANTPARTSDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BuoyantPartsData {
    fn type_info(&self) -> &'static TypeInfo {
        BUOYANTPARTSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUOYANTPARTSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuoyantPartsData-Array",
    name_hash: 1774399103,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BuoyantPartsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BuoyantParts {
    #[default]
    BuoyantPart_Hips = 0,
    BuoyantPart_Spine = 1,
    BuoyantPart_Spine1 = 2,
    BuoyantPart_Spine2 = 3,
    BuoyantPart_Head = 4,
    BuoyantPart_LeftArm = 5,
    BuoyantPart_LeftArmRoll = 6,
    BuoyantPart_LeftForeArm = 7,
    BuoyantPart_RightArm = 8,
    BuoyantPart_RightArmRoll = 9,
    BuoyantPart_RightForeArm = 10,
    BuoyantPart_RightUpLeg = 11,
    BuoyantPart_RightLeg = 12,
    BuoyantPart_LeftUpLeg = 13,
    BuoyantPart_LeftLeg = 14,
}

pub static BUOYANTPARTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuoyantParts",
    name_hash: 2046898747,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BUOYANTPARTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BuoyantParts {
    fn type_info(&self) -> &'static TypeInfo {
        BUOYANTPARTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUOYANTPARTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuoyantParts-Array",
    name_hash: 251566479,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BuoyantParts"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SkeletonCollisionData {
    pub _glacier_base: super::core::DataContainer,
    pub skeleton_asset: Option<LockedTypeObject /* super::entity::SkeletonAsset */>,
    pub bone_collision_data: Vec<BoxedTypeObject /* BoneCollisionData */>,
}

pub trait SkeletonCollisionDataTrait: super::core::DataContainerTrait {
    fn skeleton_asset(&self) -> &Option<LockedTypeObject /* super::entity::SkeletonAsset */>;
    fn skeleton_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::SkeletonAsset */>;
    fn bone_collision_data(&self) -> &Vec<BoxedTypeObject /* BoneCollisionData */>;
    fn bone_collision_data_mut(&mut self) -> &mut Vec<BoxedTypeObject /* BoneCollisionData */>;
}

impl SkeletonCollisionDataTrait for SkeletonCollisionData {
    fn skeleton_asset(&self) -> &Option<LockedTypeObject /* super::entity::SkeletonAsset */> {
        &self.skeleton_asset
    }
    fn skeleton_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::SkeletonAsset */> {
        &mut self.skeleton_asset
    }
    fn bone_collision_data(&self) -> &Vec<BoxedTypeObject /* BoneCollisionData */> {
        &self.bone_collision_data
    }
    fn bone_collision_data_mut(&mut self) -> &mut Vec<BoxedTypeObject /* BoneCollisionData */> {
        &mut self.bone_collision_data
    }
}

impl super::core::DataContainerTrait for SkeletonCollisionData {
}

pub static SKELETONCOLLISIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonCollisionData",
    name_hash: 2418871594,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(SkeletonCollisionData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkeletonCollisionData as Default>::default())),
            create_boxed: || Box::new(<SkeletonCollisionData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SkeletonAsset",
                name_hash: 2375870068,
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(SkeletonCollisionData, skeleton_asset),
            },
            FieldInfoData {
                name: "BoneCollisionData",
                name_hash: 3073290765,
                flags: MemberInfoFlags::new(144),
                field_type: "BoneCollisionData-Array",
                rust_offset: offset_of!(SkeletonCollisionData, bone_collision_data),
            },
        ],
    }),
    array_type: Some(SKELETONCOLLISIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SkeletonCollisionData {
    fn type_info(&self) -> &'static TypeInfo {
        SKELETONCOLLISIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKELETONCOLLISIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonCollisionData-Array",
    name_hash: 1190700958,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SkeletonCollisionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoneCollisionData {
    pub debug_draw_color: super::core::Vec4,
    pub capsule_offset: super::core::Vec3,
    pub bone_name: String,
    pub animation_hit_reaction_type: HitReactionType,
    pub material_pair: super::entity::MaterialDecl,
    pub bone_axis: i32,
    pub capsule_length: f32,
    pub capsule_radius: f32,
    pub valid_in_hi_lod: bool,
    pub valid_in_low_lod: bool,
    pub deactivate_if_behind_wall: bool,
    pub use_physics_rotation: bool,
    pub max_pitch: PitchModifier,
    pub min_pitch: PitchModifier,
    pub aim_assist_target: Option<LockedTypeObject /* AimAssistCollisionBoneData */>,
}

pub trait BoneCollisionDataTrait: TypeObject {
    fn debug_draw_color(&self) -> &super::core::Vec4;
    fn debug_draw_color_mut(&mut self) -> &mut super::core::Vec4;
    fn capsule_offset(&self) -> &super::core::Vec3;
    fn capsule_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
    fn animation_hit_reaction_type(&self) -> &HitReactionType;
    fn animation_hit_reaction_type_mut(&mut self) -> &mut HitReactionType;
    fn material_pair(&self) -> &super::entity::MaterialDecl;
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn bone_axis(&self) -> &i32;
    fn bone_axis_mut(&mut self) -> &mut i32;
    fn capsule_length(&self) -> &f32;
    fn capsule_length_mut(&mut self) -> &mut f32;
    fn capsule_radius(&self) -> &f32;
    fn capsule_radius_mut(&mut self) -> &mut f32;
    fn valid_in_hi_lod(&self) -> &bool;
    fn valid_in_hi_lod_mut(&mut self) -> &mut bool;
    fn valid_in_low_lod(&self) -> &bool;
    fn valid_in_low_lod_mut(&mut self) -> &mut bool;
    fn deactivate_if_behind_wall(&self) -> &bool;
    fn deactivate_if_behind_wall_mut(&mut self) -> &mut bool;
    fn use_physics_rotation(&self) -> &bool;
    fn use_physics_rotation_mut(&mut self) -> &mut bool;
    fn max_pitch(&self) -> &PitchModifier;
    fn max_pitch_mut(&mut self) -> &mut PitchModifier;
    fn min_pitch(&self) -> &PitchModifier;
    fn min_pitch_mut(&mut self) -> &mut PitchModifier;
    fn aim_assist_target(&self) -> &Option<LockedTypeObject /* AimAssistCollisionBoneData */>;
    fn aim_assist_target_mut(&mut self) -> &mut Option<LockedTypeObject /* AimAssistCollisionBoneData */>;
}

impl BoneCollisionDataTrait for BoneCollisionData {
    fn debug_draw_color(&self) -> &super::core::Vec4 {
        &self.debug_draw_color
    }
    fn debug_draw_color_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.debug_draw_color
    }
    fn capsule_offset(&self) -> &super::core::Vec3 {
        &self.capsule_offset
    }
    fn capsule_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.capsule_offset
    }
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
    fn animation_hit_reaction_type(&self) -> &HitReactionType {
        &self.animation_hit_reaction_type
    }
    fn animation_hit_reaction_type_mut(&mut self) -> &mut HitReactionType {
        &mut self.animation_hit_reaction_type
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        &self.material_pair
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material_pair
    }
    fn bone_axis(&self) -> &i32 {
        &self.bone_axis
    }
    fn bone_axis_mut(&mut self) -> &mut i32 {
        &mut self.bone_axis
    }
    fn capsule_length(&self) -> &f32 {
        &self.capsule_length
    }
    fn capsule_length_mut(&mut self) -> &mut f32 {
        &mut self.capsule_length
    }
    fn capsule_radius(&self) -> &f32 {
        &self.capsule_radius
    }
    fn capsule_radius_mut(&mut self) -> &mut f32 {
        &mut self.capsule_radius
    }
    fn valid_in_hi_lod(&self) -> &bool {
        &self.valid_in_hi_lod
    }
    fn valid_in_hi_lod_mut(&mut self) -> &mut bool {
        &mut self.valid_in_hi_lod
    }
    fn valid_in_low_lod(&self) -> &bool {
        &self.valid_in_low_lod
    }
    fn valid_in_low_lod_mut(&mut self) -> &mut bool {
        &mut self.valid_in_low_lod
    }
    fn deactivate_if_behind_wall(&self) -> &bool {
        &self.deactivate_if_behind_wall
    }
    fn deactivate_if_behind_wall_mut(&mut self) -> &mut bool {
        &mut self.deactivate_if_behind_wall
    }
    fn use_physics_rotation(&self) -> &bool {
        &self.use_physics_rotation
    }
    fn use_physics_rotation_mut(&mut self) -> &mut bool {
        &mut self.use_physics_rotation
    }
    fn max_pitch(&self) -> &PitchModifier {
        &self.max_pitch
    }
    fn max_pitch_mut(&mut self) -> &mut PitchModifier {
        &mut self.max_pitch
    }
    fn min_pitch(&self) -> &PitchModifier {
        &self.min_pitch
    }
    fn min_pitch_mut(&mut self) -> &mut PitchModifier {
        &mut self.min_pitch
    }
    fn aim_assist_target(&self) -> &Option<LockedTypeObject /* AimAssistCollisionBoneData */> {
        &self.aim_assist_target
    }
    fn aim_assist_target_mut(&mut self) -> &mut Option<LockedTypeObject /* AimAssistCollisionBoneData */> {
        &mut self.aim_assist_target
    }
}

pub static BONECOLLISIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneCollisionData",
    name_hash: 3073290765,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoneCollisionData as Default>::default())),
            create_boxed: || Box::new(<BoneCollisionData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DebugDrawColor",
                name_hash: 34201065,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(BoneCollisionData, debug_draw_color),
            },
            FieldInfoData {
                name: "CapsuleOffset",
                name_hash: 1863560277,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(BoneCollisionData, capsule_offset),
            },
            FieldInfoData {
                name: "BoneName",
                name_hash: 1590647844,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BoneCollisionData, bone_name),
            },
            FieldInfoData {
                name: "AnimationHitReactionType",
                name_hash: 3424827895,
                flags: MemberInfoFlags::new(0),
                field_type: "HitReactionType",
                rust_offset: offset_of!(BoneCollisionData, animation_hit_reaction_type),
            },
            FieldInfoData {
                name: "MaterialPair",
                name_hash: 161392100,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(BoneCollisionData, material_pair),
            },
            FieldInfoData {
                name: "BoneAxis",
                name_hash: 1590208000,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BoneCollisionData, bone_axis),
            },
            FieldInfoData {
                name: "CapsuleLength",
                name_hash: 1676345540,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BoneCollisionData, capsule_length),
            },
            FieldInfoData {
                name: "CapsuleRadius",
                name_hash: 1441176608,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BoneCollisionData, capsule_radius),
            },
            FieldInfoData {
                name: "ValidInHiLod",
                name_hash: 1872072018,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoneCollisionData, valid_in_hi_lod),
            },
            FieldInfoData {
                name: "ValidInLowLod",
                name_hash: 1492667495,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoneCollisionData, valid_in_low_lod),
            },
            FieldInfoData {
                name: "DeactivateIfBehindWall",
                name_hash: 4263951528,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoneCollisionData, deactivate_if_behind_wall),
            },
            FieldInfoData {
                name: "UsePhysicsRotation",
                name_hash: 979803673,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoneCollisionData, use_physics_rotation),
            },
            FieldInfoData {
                name: "MaxPitch",
                name_hash: 397101687,
                flags: MemberInfoFlags::new(0),
                field_type: "PitchModifier",
                rust_offset: offset_of!(BoneCollisionData, max_pitch),
            },
            FieldInfoData {
                name: "MinPitch",
                name_hash: 3374061353,
                flags: MemberInfoFlags::new(0),
                field_type: "PitchModifier",
                rust_offset: offset_of!(BoneCollisionData, min_pitch),
            },
            FieldInfoData {
                name: "AimAssistTarget",
                name_hash: 624281566,
                flags: MemberInfoFlags::new(0),
                field_type: "AimAssistCollisionBoneData",
                rust_offset: offset_of!(BoneCollisionData, aim_assist_target),
            },
        ],
    }),
    array_type: Some(BONECOLLISIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BoneCollisionData {
    fn type_info(&self) -> &'static TypeInfo {
        BONECOLLISIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BONECOLLISIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneCollisionData-Array",
    name_hash: 1679078841,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoneCollisionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AimAssistCollisionBoneData {
    pub _glacier_base: super::core::DataContainer,
    pub length_scale: f32,
    pub snap_aim: AimAssistCollisionBoneSnapAimData,
}

pub trait AimAssistCollisionBoneDataTrait: super::core::DataContainerTrait {
    fn length_scale(&self) -> &f32;
    fn length_scale_mut(&mut self) -> &mut f32;
    fn snap_aim(&self) -> &AimAssistCollisionBoneSnapAimData;
    fn snap_aim_mut(&mut self) -> &mut AimAssistCollisionBoneSnapAimData;
}

impl AimAssistCollisionBoneDataTrait for AimAssistCollisionBoneData {
    fn length_scale(&self) -> &f32 {
        &self.length_scale
    }
    fn length_scale_mut(&mut self) -> &mut f32 {
        &mut self.length_scale
    }
    fn snap_aim(&self) -> &AimAssistCollisionBoneSnapAimData {
        &self.snap_aim
    }
    fn snap_aim_mut(&mut self) -> &mut AimAssistCollisionBoneSnapAimData {
        &mut self.snap_aim
    }
}

impl super::core::DataContainerTrait for AimAssistCollisionBoneData {
}

pub static AIMASSISTCOLLISIONBONEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBoneData",
    name_hash: 3706575111,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AimAssistCollisionBoneData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimAssistCollisionBoneData as Default>::default())),
            create_boxed: || Box::new(<AimAssistCollisionBoneData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LengthScale",
                name_hash: 2817746337,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistCollisionBoneData, length_scale),
            },
            FieldInfoData {
                name: "SnapAim",
                name_hash: 2884626796,
                flags: MemberInfoFlags::new(0),
                field_type: "AimAssistCollisionBoneSnapAimData",
                rust_offset: offset_of!(AimAssistCollisionBoneData, snap_aim),
            },
        ],
    }),
    array_type: Some(AIMASSISTCOLLISIONBONEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AimAssistCollisionBoneData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMASSISTCOLLISIONBONEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMASSISTCOLLISIONBONEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBoneData-Array",
    name_hash: 336476595,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AimAssistCollisionBoneData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AimAssistCollisionBoneSnapAimData {
    pub bounding_length_scale: f32,
    pub bounding_radius_scale: f32,
    pub point_length_scale: f32,
    pub point_priorities: AimAssistCollisionBonePrioritiesData,
    pub point_priorities_bone_under_reticle: AimAssistCollisionBonePrioritiesData,
}

pub trait AimAssistCollisionBoneSnapAimDataTrait: TypeObject {
    fn bounding_length_scale(&self) -> &f32;
    fn bounding_length_scale_mut(&mut self) -> &mut f32;
    fn bounding_radius_scale(&self) -> &f32;
    fn bounding_radius_scale_mut(&mut self) -> &mut f32;
    fn point_length_scale(&self) -> &f32;
    fn point_length_scale_mut(&mut self) -> &mut f32;
    fn point_priorities(&self) -> &AimAssistCollisionBonePrioritiesData;
    fn point_priorities_mut(&mut self) -> &mut AimAssistCollisionBonePrioritiesData;
    fn point_priorities_bone_under_reticle(&self) -> &AimAssistCollisionBonePrioritiesData;
    fn point_priorities_bone_under_reticle_mut(&mut self) -> &mut AimAssistCollisionBonePrioritiesData;
}

impl AimAssistCollisionBoneSnapAimDataTrait for AimAssistCollisionBoneSnapAimData {
    fn bounding_length_scale(&self) -> &f32 {
        &self.bounding_length_scale
    }
    fn bounding_length_scale_mut(&mut self) -> &mut f32 {
        &mut self.bounding_length_scale
    }
    fn bounding_radius_scale(&self) -> &f32 {
        &self.bounding_radius_scale
    }
    fn bounding_radius_scale_mut(&mut self) -> &mut f32 {
        &mut self.bounding_radius_scale
    }
    fn point_length_scale(&self) -> &f32 {
        &self.point_length_scale
    }
    fn point_length_scale_mut(&mut self) -> &mut f32 {
        &mut self.point_length_scale
    }
    fn point_priorities(&self) -> &AimAssistCollisionBonePrioritiesData {
        &self.point_priorities
    }
    fn point_priorities_mut(&mut self) -> &mut AimAssistCollisionBonePrioritiesData {
        &mut self.point_priorities
    }
    fn point_priorities_bone_under_reticle(&self) -> &AimAssistCollisionBonePrioritiesData {
        &self.point_priorities_bone_under_reticle
    }
    fn point_priorities_bone_under_reticle_mut(&mut self) -> &mut AimAssistCollisionBonePrioritiesData {
        &mut self.point_priorities_bone_under_reticle
    }
}

pub static AIMASSISTCOLLISIONBONESNAPAIMDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBoneSnapAimData",
    name_hash: 949693166,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimAssistCollisionBoneSnapAimData as Default>::default())),
            create_boxed: || Box::new(<AimAssistCollisionBoneSnapAimData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Bounding_LengthScale",
                name_hash: 2685891884,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, bounding_length_scale),
            },
            FieldInfoData {
                name: "Bounding_RadiusScale",
                name_hash: 1816372616,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, bounding_radius_scale),
            },
            FieldInfoData {
                name: "Point_LengthScale",
                name_hash: 1559428210,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, point_length_scale),
            },
            FieldInfoData {
                name: "Point_Priorities",
                name_hash: 1026895170,
                flags: MemberInfoFlags::new(0),
                field_type: "AimAssistCollisionBonePrioritiesData",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, point_priorities),
            },
            FieldInfoData {
                name: "Point_Priorities_BoneUnderReticle",
                name_hash: 2050369171,
                flags: MemberInfoFlags::new(0),
                field_type: "AimAssistCollisionBonePrioritiesData",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, point_priorities_bone_under_reticle),
            },
        ],
    }),
    array_type: Some(AIMASSISTCOLLISIONBONESNAPAIMDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AimAssistCollisionBoneSnapAimData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMASSISTCOLLISIONBONESNAPAIMDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIMASSISTCOLLISIONBONESNAPAIMDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBoneSnapAimData-Array",
    name_hash: 912622554,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AimAssistCollisionBoneSnapAimData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AimAssistCollisionBonePrioritiesData {
    pub start_priority: i32,
    pub mid_priority: i32,
    pub end_priority: i32,
}

pub trait AimAssistCollisionBonePrioritiesDataTrait: TypeObject {
    fn start_priority(&self) -> &i32;
    fn start_priority_mut(&mut self) -> &mut i32;
    fn mid_priority(&self) -> &i32;
    fn mid_priority_mut(&mut self) -> &mut i32;
    fn end_priority(&self) -> &i32;
    fn end_priority_mut(&mut self) -> &mut i32;
}

impl AimAssistCollisionBonePrioritiesDataTrait for AimAssistCollisionBonePrioritiesData {
    fn start_priority(&self) -> &i32 {
        &self.start_priority
    }
    fn start_priority_mut(&mut self) -> &mut i32 {
        &mut self.start_priority
    }
    fn mid_priority(&self) -> &i32 {
        &self.mid_priority
    }
    fn mid_priority_mut(&mut self) -> &mut i32 {
        &mut self.mid_priority
    }
    fn end_priority(&self) -> &i32 {
        &self.end_priority
    }
    fn end_priority_mut(&mut self) -> &mut i32 {
        &mut self.end_priority
    }
}

pub static AIMASSISTCOLLISIONBONEPRIORITIESDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBonePrioritiesData",
    name_hash: 1234025587,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimAssistCollisionBonePrioritiesData as Default>::default())),
            create_boxed: || Box::new(<AimAssistCollisionBonePrioritiesData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StartPriority",
                name_hash: 2378845495,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimAssistCollisionBonePrioritiesData, start_priority),
            },
            FieldInfoData {
                name: "MidPriority",
                name_hash: 1678558999,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimAssistCollisionBonePrioritiesData, mid_priority),
            },
            FieldInfoData {
                name: "EndPriority",
                name_hash: 1048989880,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimAssistCollisionBonePrioritiesData, end_priority),
            },
        ],
    }),
    array_type: Some(AIMASSISTCOLLISIONBONEPRIORITIESDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AimAssistCollisionBonePrioritiesData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMASSISTCOLLISIONBONEPRIORITIESDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIMASSISTCOLLISIONBONEPRIORITIESDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBonePrioritiesData-Array",
    name_hash: 1092515911,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AimAssistCollisionBonePrioritiesData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum HitReactionType {
    #[default]
    HRT_Body = 0,
    HRT_Head = 1,
    HRT_RightArm = 2,
    HRT_LeftArm = 3,
    HRT_RightLeg = 4,
    HRT_LeftLeg = 5,
    HRT_Count = 6,
}

pub static HITREACTIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionType",
    name_hash: 3575406657,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(HITREACTIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for HitReactionType {
    fn type_info(&self) -> &'static TypeInfo {
        HITREACTIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static HITREACTIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionType-Array",
    name_hash: 1729694325,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HitReactionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PitchModifier {
    pub pitch_val: f32,
    pub offset: super::core::Vec3,
    pub pitch_angle: f32,
}

pub trait PitchModifierTrait: TypeObject {
    fn pitch_val(&self) -> &f32;
    fn pitch_val_mut(&mut self) -> &mut f32;
    fn offset(&self) -> &super::core::Vec3;
    fn offset_mut(&mut self) -> &mut super::core::Vec3;
    fn pitch_angle(&self) -> &f32;
    fn pitch_angle_mut(&mut self) -> &mut f32;
}

impl PitchModifierTrait for PitchModifier {
    fn pitch_val(&self) -> &f32 {
        &self.pitch_val
    }
    fn pitch_val_mut(&mut self) -> &mut f32 {
        &mut self.pitch_val
    }
    fn offset(&self) -> &super::core::Vec3 {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.offset
    }
    fn pitch_angle(&self) -> &f32 {
        &self.pitch_angle
    }
    fn pitch_angle_mut(&mut self) -> &mut f32 {
        &mut self.pitch_angle
    }
}

pub static PITCHMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PitchModifier",
    name_hash: 4160465620,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PitchModifier as Default>::default())),
            create_boxed: || Box::new(<PitchModifier as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PitchVal",
                name_hash: 1095283832,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PitchModifier, pitch_val),
            },
            FieldInfoData {
                name: "Offset",
                name_hash: 2871410728,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PitchModifier, offset),
            },
            FieldInfoData {
                name: "PitchAngle",
                name_hash: 3042696834,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PitchModifier, pitch_angle),
            },
        ],
    }),
    array_type: Some(PITCHMODIFIER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PitchModifier {
    fn type_info(&self) -> &'static TypeInfo {
        PITCHMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PITCHMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PitchModifier-Array",
    name_hash: 242603872,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PitchModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ActionSuppressor {
    pub action_to_suppress: i32,
    pub suppressing_value: f32,
}

pub trait ActionSuppressorTrait: TypeObject {
    fn action_to_suppress(&self) -> &i32;
    fn action_to_suppress_mut(&mut self) -> &mut i32;
    fn suppressing_value(&self) -> &f32;
    fn suppressing_value_mut(&mut self) -> &mut f32;
}

impl ActionSuppressorTrait for ActionSuppressor {
    fn action_to_suppress(&self) -> &i32 {
        &self.action_to_suppress
    }
    fn action_to_suppress_mut(&mut self) -> &mut i32 {
        &mut self.action_to_suppress
    }
    fn suppressing_value(&self) -> &f32 {
        &self.suppressing_value
    }
    fn suppressing_value_mut(&mut self) -> &mut f32 {
        &mut self.suppressing_value
    }
}

pub static ACTIONSUPPRESSOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActionSuppressor",
    name_hash: 4193851191,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ActionSuppressor as Default>::default())),
            create_boxed: || Box::new(<ActionSuppressor as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ActionToSuppress",
                name_hash: 3644641713,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ActionSuppressor, action_to_suppress),
            },
            FieldInfoData {
                name: "SuppressingValue",
                name_hash: 390019807,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ActionSuppressor, suppressing_value),
            },
        ],
    }),
    array_type: Some(ACTIONSUPPRESSOR_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ActionSuppressor {
    fn type_info(&self) -> &'static TypeInfo {
        ACTIONSUPPRESSOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ACTIONSUPPRESSOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActionSuppressor-Array",
    name_hash: 592351363,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ActionSuppressor"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GroupComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait GroupComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl GroupComponentDataTrait for GroupComponentData {
}

impl super::entity::GameComponentDataTrait for GroupComponentData {
}

impl super::entity::ComponentDataTrait for GroupComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for GroupComponentData {
}

impl super::core::DataBusPeerTrait for GroupComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GroupComponentData {
}

impl super::core::DataContainerTrait for GroupComponentData {
}

pub static GROUPCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroupComponentData",
    name_hash: 2979010245,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(GroupComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GroupComponentData as Default>::default())),
            create_boxed: || Box::new(<GroupComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GROUPCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GroupComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        GROUPCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GROUPCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroupComponentData-Array",
    name_hash: 324751089,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GroupComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ColorPalette {
    pub _glacier_base: super::core::Asset,
    pub source_path: String,
    pub entries: Vec<BoxedTypeObject /* super::core::Vec3 */>,
}

pub trait ColorPaletteTrait: super::core::AssetTrait {
    fn source_path(&self) -> &String;
    fn source_path_mut(&mut self) -> &mut String;
    fn entries(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn entries_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
}

impl ColorPaletteTrait for ColorPalette {
    fn source_path(&self) -> &String {
        &self.source_path
    }
    fn source_path_mut(&mut self) -> &mut String {
        &mut self.source_path
    }
    fn entries(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.entries
    }
}

impl super::core::AssetTrait for ColorPalette {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ColorPalette {
}

pub static COLORPALETTE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorPalette",
    name_hash: 240037,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(ColorPalette, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ColorPalette as Default>::default())),
            create_boxed: || Box::new(<ColorPalette as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SourcePath",
                name_hash: 1521923381,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ColorPalette, source_path),
            },
            FieldInfoData {
                name: "Entries",
                name_hash: 8238103,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(ColorPalette, entries),
            },
        ],
    }),
    array_type: Some(COLORPALETTE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ColorPalette {
    fn type_info(&self) -> &'static TypeInfo {
        COLORPALETTE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLORPALETTE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorPalette-Array",
    name_hash: 3536962065,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ColorPalette"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct OBBCollisionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub enabled: bool,
    pub half_extents: super::core::Vec3,
    pub physics_bodies: Vec<Option<LockedTypeObject /* super::entity::EntityData */>>,
    pub collision_layer: super::physics::RigidBodyCollisionLayer,
    pub material: super::entity::MaterialDecl,
}

pub trait OBBCollisionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn half_extents(&self) -> &super::core::Vec3;
    fn half_extents_mut(&mut self) -> &mut super::core::Vec3;
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::entity::EntityData */>>;
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::EntityData */>>;
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer;
    fn collision_layer_mut(&mut self) -> &mut super::physics::RigidBodyCollisionLayer;
    fn material(&self) -> &super::entity::MaterialDecl;
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl;
}

impl OBBCollisionEntityDataTrait for OBBCollisionEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn half_extents(&self) -> &super::core::Vec3 {
        &self.half_extents
    }
    fn half_extents_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.half_extents
    }
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::entity::EntityData */>> {
        &self.physics_bodies
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::EntityData */>> {
        &mut self.physics_bodies
    }
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer {
        &self.collision_layer
    }
    fn collision_layer_mut(&mut self) -> &mut super::physics::RigidBodyCollisionLayer {
        &mut self.collision_layer
    }
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material
    }
}

impl super::entity::SpatialEntityDataTrait for OBBCollisionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for OBBCollisionEntityData {
}

impl super::entity::GameObjectDataTrait for OBBCollisionEntityData {
}

impl super::core::DataBusPeerTrait for OBBCollisionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for OBBCollisionEntityData {
}

impl super::core::DataContainerTrait for OBBCollisionEntityData {
}

pub static OBBCOLLISIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OBBCollisionEntityData",
    name_hash: 585941311,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(OBBCollisionEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OBBCollisionEntityData as Default>::default())),
            create_boxed: || Box::new(<OBBCollisionEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OBBCollisionEntityData, enabled),
            },
            FieldInfoData {
                name: "HalfExtents",
                name_hash: 905253763,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OBBCollisionEntityData, half_extents),
            },
            FieldInfoData {
                name: "PhysicsBodies",
                name_hash: 891560632,
                flags: MemberInfoFlags::new(144),
                field_type: "EntityData-Array",
                rust_offset: offset_of!(OBBCollisionEntityData, physics_bodies),
            },
            FieldInfoData {
                name: "CollisionLayer",
                name_hash: 719540408,
                flags: MemberInfoFlags::new(0),
                field_type: "RigidBodyCollisionLayer",
                rust_offset: offset_of!(OBBCollisionEntityData, collision_layer),
            },
            FieldInfoData {
                name: "Material",
                name_hash: 845639918,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(OBBCollisionEntityData, material),
            },
        ],
    }),
    array_type: Some(OBBCOLLISIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for OBBCollisionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBBCOLLISIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBBCOLLISIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OBBCollisionEntityData-Array",
    name_hash: 1700337291,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("OBBCollisionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SphereCollisionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub enabled: bool,
    pub position: super::core::Vec3,
    pub radius: f32,
    pub physics_bodies: Vec<Option<LockedTypeObject /* super::entity::EntityData */>>,
    pub collision_layer: super::physics::RigidBodyCollisionLayer,
    pub material: super::entity::MaterialDecl,
}

pub trait SphereCollisionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::entity::EntityData */>>;
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::EntityData */>>;
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer;
    fn collision_layer_mut(&mut self) -> &mut super::physics::RigidBodyCollisionLayer;
    fn material(&self) -> &super::entity::MaterialDecl;
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl;
}

impl SphereCollisionEntityDataTrait for SphereCollisionEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::entity::EntityData */>> {
        &self.physics_bodies
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::EntityData */>> {
        &mut self.physics_bodies
    }
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer {
        &self.collision_layer
    }
    fn collision_layer_mut(&mut self) -> &mut super::physics::RigidBodyCollisionLayer {
        &mut self.collision_layer
    }
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material
    }
}

impl super::entity::SpatialEntityDataTrait for SphereCollisionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for SphereCollisionEntityData {
}

impl super::entity::GameObjectDataTrait for SphereCollisionEntityData {
}

impl super::core::DataBusPeerTrait for SphereCollisionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SphereCollisionEntityData {
}

impl super::core::DataContainerTrait for SphereCollisionEntityData {
}

pub static SPHERECOLLISIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereCollisionEntityData",
    name_hash: 1195915337,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SphereCollisionEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SphereCollisionEntityData as Default>::default())),
            create_boxed: || Box::new(<SphereCollisionEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SphereCollisionEntityData, enabled),
            },
            FieldInfoData {
                name: "Position",
                name_hash: 3402582524,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SphereCollisionEntityData, position),
            },
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SphereCollisionEntityData, radius),
            },
            FieldInfoData {
                name: "PhysicsBodies",
                name_hash: 891560632,
                flags: MemberInfoFlags::new(144),
                field_type: "EntityData-Array",
                rust_offset: offset_of!(SphereCollisionEntityData, physics_bodies),
            },
            FieldInfoData {
                name: "CollisionLayer",
                name_hash: 719540408,
                flags: MemberInfoFlags::new(0),
                field_type: "RigidBodyCollisionLayer",
                rust_offset: offset_of!(SphereCollisionEntityData, collision_layer),
            },
            FieldInfoData {
                name: "Material",
                name_hash: 845639918,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(SphereCollisionEntityData, material),
            },
        ],
    }),
    array_type: Some(SPHERECOLLISIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SphereCollisionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPHERECOLLISIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPHERECOLLISIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereCollisionEntityData-Array",
    name_hash: 4081467005,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SphereCollisionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClientGameSettings {
    pub _glacier_base: super::core::SystemSettings,
    pub on_damage_spotting_enabled: bool,
    pub ignore_client_fire_rate_multiplier: bool,
    pub async_client_bullet_entity: bool,
    pub client_bullets_per_query: u32,
    pub debug_track_all_players_in_spawn_screen: bool,
    pub use_old_killer_camera: bool,
}

pub trait ClientGameSettingsTrait: super::core::SystemSettingsTrait {
    fn on_damage_spotting_enabled(&self) -> &bool;
    fn on_damage_spotting_enabled_mut(&mut self) -> &mut bool;
    fn ignore_client_fire_rate_multiplier(&self) -> &bool;
    fn ignore_client_fire_rate_multiplier_mut(&mut self) -> &mut bool;
    fn async_client_bullet_entity(&self) -> &bool;
    fn async_client_bullet_entity_mut(&mut self) -> &mut bool;
    fn client_bullets_per_query(&self) -> &u32;
    fn client_bullets_per_query_mut(&mut self) -> &mut u32;
    fn debug_track_all_players_in_spawn_screen(&self) -> &bool;
    fn debug_track_all_players_in_spawn_screen_mut(&mut self) -> &mut bool;
    fn use_old_killer_camera(&self) -> &bool;
    fn use_old_killer_camera_mut(&mut self) -> &mut bool;
}

impl ClientGameSettingsTrait for ClientGameSettings {
    fn on_damage_spotting_enabled(&self) -> &bool {
        &self.on_damage_spotting_enabled
    }
    fn on_damage_spotting_enabled_mut(&mut self) -> &mut bool {
        &mut self.on_damage_spotting_enabled
    }
    fn ignore_client_fire_rate_multiplier(&self) -> &bool {
        &self.ignore_client_fire_rate_multiplier
    }
    fn ignore_client_fire_rate_multiplier_mut(&mut self) -> &mut bool {
        &mut self.ignore_client_fire_rate_multiplier
    }
    fn async_client_bullet_entity(&self) -> &bool {
        &self.async_client_bullet_entity
    }
    fn async_client_bullet_entity_mut(&mut self) -> &mut bool {
        &mut self.async_client_bullet_entity
    }
    fn client_bullets_per_query(&self) -> &u32 {
        &self.client_bullets_per_query
    }
    fn client_bullets_per_query_mut(&mut self) -> &mut u32 {
        &mut self.client_bullets_per_query
    }
    fn debug_track_all_players_in_spawn_screen(&self) -> &bool {
        &self.debug_track_all_players_in_spawn_screen
    }
    fn debug_track_all_players_in_spawn_screen_mut(&mut self) -> &mut bool {
        &mut self.debug_track_all_players_in_spawn_screen
    }
    fn use_old_killer_camera(&self) -> &bool {
        &self.use_old_killer_camera
    }
    fn use_old_killer_camera_mut(&mut self) -> &mut bool {
        &mut self.use_old_killer_camera
    }
}

impl super::core::SystemSettingsTrait for ClientGameSettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        self._glacier_base.platform_mut()
    }
}

impl super::core::DataContainerTrait for ClientGameSettings {
}

pub static CLIENTGAMESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientGameSettings",
    name_hash: 2573885527,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        super_class_offset: offset_of!(ClientGameSettings, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientGameSettings as Default>::default())),
            create_boxed: || Box::new(<ClientGameSettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "OnDamageSpottingEnabled",
                name_hash: 2052923782,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, on_damage_spotting_enabled),
            },
            FieldInfoData {
                name: "IgnoreClientFireRateMultiplier",
                name_hash: 3144762037,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, ignore_client_fire_rate_multiplier),
            },
            FieldInfoData {
                name: "AsyncClientBulletEntity",
                name_hash: 2407735079,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, async_client_bullet_entity),
            },
            FieldInfoData {
                name: "ClientBulletsPerQuery",
                name_hash: 1842175076,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ClientGameSettings, client_bullets_per_query),
            },
            FieldInfoData {
                name: "DebugTrackAllPlayersInSpawnScreen",
                name_hash: 2432142890,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, debug_track_all_players_in_spawn_screen),
            },
            FieldInfoData {
                name: "UseOldKillerCamera",
                name_hash: 1526032525,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, use_old_killer_camera),
            },
        ],
    }),
    array_type: Some(CLIENTGAMESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientGameSettings {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTGAMESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTGAMESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientGameSettings-Array",
    name_hash: 946190691,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClientGameSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterToComponentsOnKilledMessage {
}

pub trait CharacterToComponentsOnKilledMessageTrait: TypeObject {
}

impl CharacterToComponentsOnKilledMessageTrait for CharacterToComponentsOnKilledMessage {
}

pub static CHARACTERTOCOMPONENTSONKILLEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterToComponentsOnKilledMessage",
    name_hash: 4047768274,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterToComponentsOnKilledMessage as Default>::default())),
            create_boxed: || Box::new(<CharacterToComponentsOnKilledMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for CharacterToComponentsOnKilledMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERTOCOMPONENTSONKILLEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterEntityData {
    pub _glacier_base: super::gameplay_sim::ControllableEntityData,
    pub max_health: f32,
    pub default_view_mode: PersonViewMode,
    pub player_spawn_type: PlayerSpawnType,
    pub character_lighting_enable: bool,
    pub voice_over_info: Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */>,
    pub sound: Option<LockedTypeObject /* CharacterSoundData */>,
}

pub trait CharacterEntityDataTrait: super::gameplay_sim::ControllableEntityDataTrait {
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn default_view_mode(&self) -> &PersonViewMode;
    fn default_view_mode_mut(&mut self) -> &mut PersonViewMode;
    fn player_spawn_type(&self) -> &PlayerSpawnType;
    fn player_spawn_type_mut(&mut self) -> &mut PlayerSpawnType;
    fn character_lighting_enable(&self) -> &bool;
    fn character_lighting_enable_mut(&mut self) -> &mut bool;
    fn voice_over_info(&self) -> &Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */>;
    fn voice_over_info_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */>;
    fn sound(&self) -> &Option<LockedTypeObject /* CharacterSoundData */>;
    fn sound_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterSoundData */>;
}

impl CharacterEntityDataTrait for CharacterEntityData {
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn default_view_mode(&self) -> &PersonViewMode {
        &self.default_view_mode
    }
    fn default_view_mode_mut(&mut self) -> &mut PersonViewMode {
        &mut self.default_view_mode
    }
    fn player_spawn_type(&self) -> &PlayerSpawnType {
        &self.player_spawn_type
    }
    fn player_spawn_type_mut(&mut self) -> &mut PlayerSpawnType {
        &mut self.player_spawn_type
    }
    fn character_lighting_enable(&self) -> &bool {
        &self.character_lighting_enable
    }
    fn character_lighting_enable_mut(&mut self) -> &mut bool {
        &mut self.character_lighting_enable
    }
    fn voice_over_info(&self) -> &Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */> {
        &self.voice_over_info
    }
    fn voice_over_info_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */> {
        &mut self.voice_over_info
    }
    fn sound(&self) -> &Option<LockedTypeObject /* CharacterSoundData */> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterSoundData */> {
        &mut self.sound
    }
}

impl super::gameplay_sim::ControllableEntityDataTrait for CharacterEntityData {
    fn use_prediction(&self) -> &bool {
        self._glacier_base.use_prediction()
    }
    fn use_prediction_mut(&mut self) -> &mut bool {
        self._glacier_base.use_prediction_mut()
    }
    fn default_team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.default_team()
    }
    fn default_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.default_team_mut()
    }
    fn reset_team_on_last_player_exits(&self) -> &bool {
        self._glacier_base.reset_team_on_last_player_exits()
    }
    fn reset_team_on_last_player_exits_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_team_on_last_player_exits_mut()
    }
    fn immortal(&self) -> &bool {
        self._glacier_base.immortal()
    }
    fn immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.immortal_mut()
    }
    fn fake_immortal(&self) -> &bool {
        self._glacier_base.fake_immortal()
    }
    fn fake_immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.fake_immortal_mut()
    }
    fn low_health_threshold(&self) -> &f32 {
        self._glacier_base.low_health_threshold()
    }
    fn low_health_threshold_mut(&mut self) -> &mut f32 {
        self._glacier_base.low_health_threshold_mut()
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        self._glacier_base.material_pair()
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        self._glacier_base.material_pair_mut()
    }
    fn force_foreground_rendering(&self) -> &bool {
        self._glacier_base.force_foreground_rendering()
    }
    fn force_foreground_rendering_mut(&mut self) -> &mut bool {
        self._glacier_base.force_foreground_rendering_mut()
    }
    fn suppressed_inputs(&self) -> &Vec<i32> {
        self._glacier_base.suppressed_inputs()
    }
    fn suppressed_inputs_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.suppressed_inputs_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for CharacterEntityData {
}

impl super::entity::GameComponentEntityDataTrait for CharacterEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for CharacterEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for CharacterEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CharacterEntityData {
}

impl super::entity::GameObjectDataTrait for CharacterEntityData {
}

impl super::core::DataBusPeerTrait for CharacterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterEntityData {
}

impl super::core::DataContainerTrait for CharacterEntityData {
}

pub static CHARACTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityData",
    name_hash: 1060528343,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterEntityData as Default>::default())),
            create_boxed: || Box::new(<CharacterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MaxHealth",
                name_hash: 1153188365,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterEntityData, max_health),
            },
            FieldInfoData {
                name: "DefaultViewMode",
                name_hash: 3414667104,
                flags: MemberInfoFlags::new(0),
                field_type: "PersonViewMode",
                rust_offset: offset_of!(CharacterEntityData, default_view_mode),
            },
            FieldInfoData {
                name: "PlayerSpawnType",
                name_hash: 350489269,
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerSpawnType",
                rust_offset: offset_of!(CharacterEntityData, player_spawn_type),
            },
            FieldInfoData {
                name: "CharacterLightingEnable",
                name_hash: 4279193667,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterEntityData, character_lighting_enable),
            },
            FieldInfoData {
                name: "VoiceOverInfo",
                name_hash: 1260547539,
                flags: MemberInfoFlags::new(0),
                field_type: "EntityVoiceOverInfo",
                rust_offset: offset_of!(CharacterEntityData, voice_over_info),
            },
            FieldInfoData {
                name: "Sound",
                name_hash: 231353798,
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterSoundData",
                rust_offset: offset_of!(CharacterEntityData, sound),
            },
        ],
    }),
    array_type: Some(CHARACTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityData-Array",
    name_hash: 2219842019,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterSoundData {
    pub _glacier_base: super::core::DataContainer,
    pub movement: Option<LockedTypeObject /* super::audio::SoundAsset */>,
}

pub trait CharacterSoundDataTrait: super::core::DataContainerTrait {
    fn movement(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn movement_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
}

impl CharacterSoundDataTrait for CharacterSoundData {
    fn movement(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.movement
    }
    fn movement_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.movement
    }
}

impl super::core::DataContainerTrait for CharacterSoundData {
}

pub static CHARACTERSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSoundData",
    name_hash: 3911953583,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CharacterSoundData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterSoundData as Default>::default())),
            create_boxed: || Box::new(<CharacterSoundData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Movement",
                name_hash: 1609263334,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(CharacterSoundData, movement),
            },
        ],
    }),
    array_type: Some(CHARACTERSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSoundData-Array",
    name_hash: 3311917595,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersonViewMode {
    #[default]
    PersonViewMode_FirstPerson = 0,
    PersonViewMode_ThirdPerson = 1,
    PersonViewModeCount = 2,
}

pub static PERSONVIEWMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersonViewMode",
    name_hash: 2519008798,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSONVIEWMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersonViewMode {
    fn type_info(&self) -> &'static TypeInfo {
        PERSONVIEWMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSONVIEWMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersonViewMode-Array",
    name_hash: 3975034666,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersonViewMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterEntityDeathType {
    #[default]
    CharacterEntityDeathType_Shot = 0,
    CharacterEntityDeathType_ShotInVehicleEntry = 1,
    CharacterEntityDeathType_InsideExplodingVehicle = 2,
}

pub static CHARACTERENTITYDEATHTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityDeathType",
    name_hash: 2612637059,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERENTITYDEATHTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterEntityDeathType {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERENTITYDEATHTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHARACTERENTITYDEATHTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityDeathType-Array",
    name_hash: 357023799,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterEntityDeathType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterEntityHitDirection {
    #[default]
    CharacterEntityHitDirection_Front = 0,
    CharacterEntityHitDirection_Right = 1,
    CharacterEntityHitDirection_Left = 2,
    CharacterEntityHitDirection_Back = 3,
    CharacterEntityHitDirection_None = 4,
}

pub static CHARACTERENTITYHITDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityHitDirection",
    name_hash: 2833688343,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERENTITYHITDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterEntityHitDirection {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERENTITYHITDIRECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHARACTERENTITYHITDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityHitDirection-Array",
    name_hash: 645681059,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterEntityHitDirection"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterMeshComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub enable_updates: bool,
}

pub trait CharacterMeshComponentDataTrait: super::entity::GameComponentDataTrait {
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn enable_updates(&self) -> &bool;
    fn enable_updates_mut(&mut self) -> &mut bool;
}

impl CharacterMeshComponentDataTrait for CharacterMeshComponentData {
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh
    }
    fn enable_updates(&self) -> &bool {
        &self.enable_updates
    }
    fn enable_updates_mut(&mut self) -> &mut bool {
        &mut self.enable_updates
    }
}

impl super::entity::GameComponentDataTrait for CharacterMeshComponentData {
}

impl super::entity::ComponentDataTrait for CharacterMeshComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterMeshComponentData {
}

impl super::core::DataBusPeerTrait for CharacterMeshComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterMeshComponentData {
}

impl super::core::DataContainerTrait for CharacterMeshComponentData {
}

pub static CHARACTERMESHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterMeshComponentData",
    name_hash: 3780471216,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterMeshComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterMeshComponentData as Default>::default())),
            create_boxed: || Box::new(<CharacterMeshComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                name_hash: 2088783990,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(CharacterMeshComponentData, mesh),
            },
            FieldInfoData {
                name: "EnableUpdates",
                name_hash: 771920806,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterMeshComponentData, enable_updates),
            },
        ],
    }),
    array_type: Some(CHARACTERMESHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterMeshComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERMESHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERMESHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterMeshComponentData-Array",
    name_hash: 871323396,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterMeshComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterCustomizationComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub customization: Option<LockedTypeObject /* CharacterCustomizationAsset */>,
    pub visual_unlock: Option<LockedTypeObject /* VisualUnlockAsset */>,
    pub character_lighting_enable: bool,
}

pub trait CharacterCustomizationComponentDataTrait: super::entity::GameComponentDataTrait {
    fn customization(&self) -> &Option<LockedTypeObject /* CharacterCustomizationAsset */>;
    fn customization_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterCustomizationAsset */>;
    fn visual_unlock(&self) -> &Option<LockedTypeObject /* VisualUnlockAsset */>;
    fn visual_unlock_mut(&mut self) -> &mut Option<LockedTypeObject /* VisualUnlockAsset */>;
    fn character_lighting_enable(&self) -> &bool;
    fn character_lighting_enable_mut(&mut self) -> &mut bool;
}

impl CharacterCustomizationComponentDataTrait for CharacterCustomizationComponentData {
    fn customization(&self) -> &Option<LockedTypeObject /* CharacterCustomizationAsset */> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterCustomizationAsset */> {
        &mut self.customization
    }
    fn visual_unlock(&self) -> &Option<LockedTypeObject /* VisualUnlockAsset */> {
        &self.visual_unlock
    }
    fn visual_unlock_mut(&mut self) -> &mut Option<LockedTypeObject /* VisualUnlockAsset */> {
        &mut self.visual_unlock
    }
    fn character_lighting_enable(&self) -> &bool {
        &self.character_lighting_enable
    }
    fn character_lighting_enable_mut(&mut self) -> &mut bool {
        &mut self.character_lighting_enable
    }
}

impl super::entity::GameComponentDataTrait for CharacterCustomizationComponentData {
}

impl super::entity::ComponentDataTrait for CharacterCustomizationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterCustomizationComponentData {
}

impl super::core::DataBusPeerTrait for CharacterCustomizationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterCustomizationComponentData {
}

impl super::core::DataContainerTrait for CharacterCustomizationComponentData {
}

pub static CHARACTERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCustomizationComponentData",
    name_hash: 2331141950,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterCustomizationComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterCustomizationComponentData as Default>::default())),
            create_boxed: || Box::new(<CharacterCustomizationComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Customization",
                name_hash: 1998291608,
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterCustomizationAsset",
                rust_offset: offset_of!(CharacterCustomizationComponentData, customization),
            },
            FieldInfoData {
                name: "VisualUnlock",
                name_hash: 629823297,
                flags: MemberInfoFlags::new(0),
                field_type: "VisualUnlockAsset",
                rust_offset: offset_of!(CharacterCustomizationComponentData, visual_unlock),
            },
            FieldInfoData {
                name: "CharacterLightingEnable",
                name_hash: 4279193667,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterCustomizationComponentData, character_lighting_enable),
            },
        ],
    }),
    array_type: Some(CHARACTERCUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterCustomizationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERCUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCustomizationComponentData-Array",
    name_hash: 1806432138,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterCustomizationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterToComponentsOnActiveViewChangedMessage {
}

pub trait CharacterToComponentsOnActiveViewChangedMessageTrait: TypeObject {
}

impl CharacterToComponentsOnActiveViewChangedMessageTrait for CharacterToComponentsOnActiveViewChangedMessage {
}

pub static CHARACTERTOCOMPONENTSONACTIVEVIEWCHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterToComponentsOnActiveViewChangedMessage",
    name_hash: 4029945458,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterToComponentsOnActiveViewChangedMessage as Default>::default())),
            create_boxed: || Box::new(<CharacterToComponentsOnActiveViewChangedMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for CharacterToComponentsOnActiveViewChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERTOCOMPONENTSONACTIVEVIEWCHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterMasterPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::ControllablePhysicsComponentData,
}

pub trait CharacterMasterPhysicsComponentDataTrait: super::gameplay_sim::ControllablePhysicsComponentDataTrait {
}

impl CharacterMasterPhysicsComponentDataTrait for CharacterMasterPhysicsComponentData {
}

impl super::gameplay_sim::ControllablePhysicsComponentDataTrait for CharacterMasterPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for CharacterMasterPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for CharacterMasterPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for CharacterMasterPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterMasterPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for CharacterMasterPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterMasterPhysicsComponentData {
}

impl super::core::DataContainerTrait for CharacterMasterPhysicsComponentData {
}

pub static CHARACTERMASTERPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterMasterPhysicsComponentData",
    name_hash: 445474324,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEPHYSICSCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterMasterPhysicsComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterMasterPhysicsComponentData as Default>::default())),
            create_boxed: || Box::new(<CharacterMasterPhysicsComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERMASTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterMasterPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERMASTERPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERMASTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterMasterPhysicsComponentData-Array",
    name_hash: 435356192,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterMasterPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraRelativeInputComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub enabled: bool,
    pub is_steering: bool,
}

pub trait CameraRelativeInputComponentDataTrait: super::entity::GameComponentDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn is_steering(&self) -> &bool;
    fn is_steering_mut(&mut self) -> &mut bool;
}

impl CameraRelativeInputComponentDataTrait for CameraRelativeInputComponentData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn is_steering(&self) -> &bool {
        &self.is_steering
    }
    fn is_steering_mut(&mut self) -> &mut bool {
        &mut self.is_steering
    }
}

impl super::entity::GameComponentDataTrait for CameraRelativeInputComponentData {
}

impl super::entity::ComponentDataTrait for CameraRelativeInputComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraRelativeInputComponentData {
}

impl super::core::DataBusPeerTrait for CameraRelativeInputComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraRelativeInputComponentData {
}

impl super::core::DataContainerTrait for CameraRelativeInputComponentData {
}

pub static CAMERARELATIVEINPUTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeInputComponentData",
    name_hash: 2829416417,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraRelativeInputComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraRelativeInputComponentData as Default>::default())),
            create_boxed: || Box::new(<CameraRelativeInputComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeInputComponentData, enabled),
            },
            FieldInfoData {
                name: "IsSteering",
                name_hash: 2873823530,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeInputComponentData, is_steering),
            },
        ],
    }),
    array_type: Some(CAMERARELATIVEINPUTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraRelativeInputComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARELATIVEINPUTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERARELATIVEINPUTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeInputComponentData-Array",
    name_hash: 867554005,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraRelativeInputComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterHealthComponentData {
    pub _glacier_base: super::gameplay_sim::ControllableHealthComponentData,
    pub max_health: f32,
    pub time_for_corpse: f32,
}

pub trait CharacterHealthComponentDataTrait: super::gameplay_sim::ControllableHealthComponentDataTrait {
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn time_for_corpse(&self) -> &f32;
    fn time_for_corpse_mut(&mut self) -> &mut f32;
}

impl CharacterHealthComponentDataTrait for CharacterHealthComponentData {
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn time_for_corpse(&self) -> &f32 {
        &self.time_for_corpse
    }
    fn time_for_corpse_mut(&mut self) -> &mut f32 {
        &mut self.time_for_corpse
    }
}

impl super::gameplay_sim::ControllableHealthComponentDataTrait for CharacterHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for CharacterHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for CharacterHealthComponentData {
}

impl super::entity::ComponentDataTrait for CharacterHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterHealthComponentData {
}

impl super::core::DataBusPeerTrait for CharacterHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterHealthComponentData {
}

impl super::core::DataContainerTrait for CharacterHealthComponentData {
}

pub static CHARACTERHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterHealthComponentData",
    name_hash: 2887277439,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEHEALTHCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterHealthComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterHealthComponentData as Default>::default())),
            create_boxed: || Box::new(<CharacterHealthComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MaxHealth",
                name_hash: 1153188365,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterHealthComponentData, max_health),
            },
            FieldInfoData {
                name: "TimeForCorpse",
                name_hash: 418744275,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterHealthComponentData, time_for_corpse),
            },
        ],
    }),
    array_type: Some(CHARACTERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterHealthComponentData-Array",
    name_hash: 2997051723,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AntInputComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait AntInputComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl AntInputComponentDataTrait for AntInputComponentData {
}

impl super::entity::GameComponentDataTrait for AntInputComponentData {
}

impl super::entity::ComponentDataTrait for AntInputComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AntInputComponentData {
}

impl super::core::DataBusPeerTrait for AntInputComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AntInputComponentData {
}

impl super::core::DataContainerTrait for AntInputComponentData {
}

pub static ANTINPUTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntInputComponentData",
    name_hash: 1961294423,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(AntInputComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntInputComponentData as Default>::default())),
            create_boxed: || Box::new(<AntInputComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANTINPUTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AntInputComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTINPUTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTINPUTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntInputComponentData-Array",
    name_hash: 1231934307,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntInputComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AntDrivenComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub reset_controller_tree_on_teleport: bool,
    pub zero_trajectory_velocity_on_teleport: bool,
}

pub trait AntDrivenComponentDataTrait: super::entity::GameComponentDataTrait {
    fn reset_controller_tree_on_teleport(&self) -> &bool;
    fn reset_controller_tree_on_teleport_mut(&mut self) -> &mut bool;
    fn zero_trajectory_velocity_on_teleport(&self) -> &bool;
    fn zero_trajectory_velocity_on_teleport_mut(&mut self) -> &mut bool;
}

impl AntDrivenComponentDataTrait for AntDrivenComponentData {
    fn reset_controller_tree_on_teleport(&self) -> &bool {
        &self.reset_controller_tree_on_teleport
    }
    fn reset_controller_tree_on_teleport_mut(&mut self) -> &mut bool {
        &mut self.reset_controller_tree_on_teleport
    }
    fn zero_trajectory_velocity_on_teleport(&self) -> &bool {
        &self.zero_trajectory_velocity_on_teleport
    }
    fn zero_trajectory_velocity_on_teleport_mut(&mut self) -> &mut bool {
        &mut self.zero_trajectory_velocity_on_teleport
    }
}

impl super::entity::GameComponentDataTrait for AntDrivenComponentData {
}

impl super::entity::ComponentDataTrait for AntDrivenComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AntDrivenComponentData {
}

impl super::core::DataBusPeerTrait for AntDrivenComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AntDrivenComponentData {
}

impl super::core::DataContainerTrait for AntDrivenComponentData {
}

pub static ANTDRIVENCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntDrivenComponentData",
    name_hash: 3835491267,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(AntDrivenComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntDrivenComponentData as Default>::default())),
            create_boxed: || Box::new(<AntDrivenComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ResetControllerTreeOnTeleport",
                name_hash: 1768467626,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntDrivenComponentData, reset_controller_tree_on_teleport),
            },
            FieldInfoData {
                name: "ZeroTrajectoryVelocityOnTeleport",
                name_hash: 2733828459,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntDrivenComponentData, zero_trajectory_velocity_on_teleport),
            },
        ],
    }),
    array_type: Some(ANTDRIVENCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AntDrivenComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTDRIVENCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTDRIVENCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntDrivenComponentData-Array",
    name_hash: 3729159927,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntDrivenComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterPhysicsComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub character_physics: Option<LockedTypeObject /* super::physics::CharacterPhysicsData */>,
    pub enable_collision_on_spawn: bool,
}

pub trait CharacterPhysicsComponentDataTrait: super::entity::GameComponentDataTrait {
    fn character_physics(&self) -> &Option<LockedTypeObject /* super::physics::CharacterPhysicsData */>;
    fn character_physics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::CharacterPhysicsData */>;
    fn enable_collision_on_spawn(&self) -> &bool;
    fn enable_collision_on_spawn_mut(&mut self) -> &mut bool;
}

impl CharacterPhysicsComponentDataTrait for CharacterPhysicsComponentData {
    fn character_physics(&self) -> &Option<LockedTypeObject /* super::physics::CharacterPhysicsData */> {
        &self.character_physics
    }
    fn character_physics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::CharacterPhysicsData */> {
        &mut self.character_physics
    }
    fn enable_collision_on_spawn(&self) -> &bool {
        &self.enable_collision_on_spawn
    }
    fn enable_collision_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.enable_collision_on_spawn
    }
}

impl super::entity::GameComponentDataTrait for CharacterPhysicsComponentData {
}

impl super::entity::ComponentDataTrait for CharacterPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for CharacterPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterPhysicsComponentData {
}

impl super::core::DataContainerTrait for CharacterPhysicsComponentData {
}

pub static CHARACTERPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPhysicsComponentData",
    name_hash: 1411710856,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterPhysicsComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterPhysicsComponentData as Default>::default())),
            create_boxed: || Box::new(<CharacterPhysicsComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "CharacterPhysics",
                name_hash: 4032988407,
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterPhysicsData",
                rust_offset: offset_of!(CharacterPhysicsComponentData, character_physics),
            },
            FieldInfoData {
                name: "EnableCollisionOnSpawn",
                name_hash: 1861797248,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterPhysicsComponentData, enable_collision_on_spawn),
            },
        ],
    }),
    array_type: Some(CHARACTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPhysicsComponentData-Array",
    name_hash: 1172611516,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterCameraComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub cameras: Vec<Option<LockedTypeObject /* super::gameplay_sim::CameraData */>>,
}

pub trait CharacterCameraComponentDataTrait: super::entity::GameComponentDataTrait {
    fn cameras(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::CameraData */>>;
    fn cameras_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::CameraData */>>;
}

impl CharacterCameraComponentDataTrait for CharacterCameraComponentData {
    fn cameras(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::CameraData */>> {
        &self.cameras
    }
    fn cameras_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::CameraData */>> {
        &mut self.cameras
    }
}

impl super::entity::GameComponentDataTrait for CharacterCameraComponentData {
}

impl super::entity::ComponentDataTrait for CharacterCameraComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterCameraComponentData {
}

impl super::core::DataBusPeerTrait for CharacterCameraComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterCameraComponentData {
}

impl super::core::DataContainerTrait for CharacterCameraComponentData {
}

pub static CHARACTERCAMERACOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCameraComponentData",
    name_hash: 1258747706,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterCameraComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterCameraComponentData as Default>::default())),
            create_boxed: || Box::new(<CharacterCameraComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Cameras",
                name_hash: 3740512847,
                flags: MemberInfoFlags::new(144),
                field_type: "CameraData-Array",
                rust_offset: offset_of!(CharacterCameraComponentData, cameras),
            },
        ],
    }),
    array_type: Some(CHARACTERCAMERACOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterCameraComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERCAMERACOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERCAMERACOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCameraComponentData-Array",
    name_hash: 2343360910,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterCameraComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayerCameraEntityData {
    pub _glacier_base: CameraEntityBaseData,
    pub soldier_target_mode: TargetMode,
    pub soldier_camera_index: u32,
    pub vehicle_target_mode: TargetMode,
    pub vehicle_camera_index: u32,
    pub release_control_if_target_lost: bool,
    pub should_target_controllable: bool,
    pub should_target_vehicle_driver_entry: bool,
    pub should_target_extra_player_in_double_player_event: bool,
    pub camera_smoothing_factor: f32,
}

pub trait PlayerCameraEntityDataTrait: CameraEntityBaseDataTrait {
    fn soldier_target_mode(&self) -> &TargetMode;
    fn soldier_target_mode_mut(&mut self) -> &mut TargetMode;
    fn soldier_camera_index(&self) -> &u32;
    fn soldier_camera_index_mut(&mut self) -> &mut u32;
    fn vehicle_target_mode(&self) -> &TargetMode;
    fn vehicle_target_mode_mut(&mut self) -> &mut TargetMode;
    fn vehicle_camera_index(&self) -> &u32;
    fn vehicle_camera_index_mut(&mut self) -> &mut u32;
    fn release_control_if_target_lost(&self) -> &bool;
    fn release_control_if_target_lost_mut(&mut self) -> &mut bool;
    fn should_target_controllable(&self) -> &bool;
    fn should_target_controllable_mut(&mut self) -> &mut bool;
    fn should_target_vehicle_driver_entry(&self) -> &bool;
    fn should_target_vehicle_driver_entry_mut(&mut self) -> &mut bool;
    fn should_target_extra_player_in_double_player_event(&self) -> &bool;
    fn should_target_extra_player_in_double_player_event_mut(&mut self) -> &mut bool;
    fn camera_smoothing_factor(&self) -> &f32;
    fn camera_smoothing_factor_mut(&mut self) -> &mut f32;
}

impl PlayerCameraEntityDataTrait for PlayerCameraEntityData {
    fn soldier_target_mode(&self) -> &TargetMode {
        &self.soldier_target_mode
    }
    fn soldier_target_mode_mut(&mut self) -> &mut TargetMode {
        &mut self.soldier_target_mode
    }
    fn soldier_camera_index(&self) -> &u32 {
        &self.soldier_camera_index
    }
    fn soldier_camera_index_mut(&mut self) -> &mut u32 {
        &mut self.soldier_camera_index
    }
    fn vehicle_target_mode(&self) -> &TargetMode {
        &self.vehicle_target_mode
    }
    fn vehicle_target_mode_mut(&mut self) -> &mut TargetMode {
        &mut self.vehicle_target_mode
    }
    fn vehicle_camera_index(&self) -> &u32 {
        &self.vehicle_camera_index
    }
    fn vehicle_camera_index_mut(&mut self) -> &mut u32 {
        &mut self.vehicle_camera_index
    }
    fn release_control_if_target_lost(&self) -> &bool {
        &self.release_control_if_target_lost
    }
    fn release_control_if_target_lost_mut(&mut self) -> &mut bool {
        &mut self.release_control_if_target_lost
    }
    fn should_target_controllable(&self) -> &bool {
        &self.should_target_controllable
    }
    fn should_target_controllable_mut(&mut self) -> &mut bool {
        &mut self.should_target_controllable
    }
    fn should_target_vehicle_driver_entry(&self) -> &bool {
        &self.should_target_vehicle_driver_entry
    }
    fn should_target_vehicle_driver_entry_mut(&mut self) -> &mut bool {
        &mut self.should_target_vehicle_driver_entry
    }
    fn should_target_extra_player_in_double_player_event(&self) -> &bool {
        &self.should_target_extra_player_in_double_player_event
    }
    fn should_target_extra_player_in_double_player_event_mut(&mut self) -> &mut bool {
        &mut self.should_target_extra_player_in_double_player_event
    }
    fn camera_smoothing_factor(&self) -> &f32 {
        &self.camera_smoothing_factor
    }
    fn camera_smoothing_factor_mut(&mut self) -> &mut f32 {
        &mut self.camera_smoothing_factor
    }
}

impl CameraEntityBaseDataTrait for PlayerCameraEntityData {
    fn name_id(&self) -> &String {
        self._glacier_base.name_id()
    }
    fn name_id_mut(&mut self) -> &mut String {
        self._glacier_base.name_id_mut()
    }
    fn priority(&self) -> &i32 {
        self._glacier_base.priority()
    }
    fn priority_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn object_layers_mask(&self) -> &i32 {
        self._glacier_base.object_layers_mask()
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        self._glacier_base.object_layers_mask_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn focal_length(&self) -> &f32 {
        self._glacier_base.focal_length()
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.focal_length_mut()
    }
    fn focus_distance(&self) -> &f32 {
        self._glacier_base.focus_distance()
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.focus_distance_mut()
    }
    fn exposure_compensation(&self) -> &f32 {
        self._glacier_base.exposure_compensation()
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        self._glacier_base.exposure_compensation_mut()
    }
    fn aperture(&self) -> &f32 {
        self._glacier_base.aperture()
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        self._glacier_base.aperture_mut()
    }
    fn shutter_speed(&self) -> &f32 {
        self._glacier_base.shutter_speed()
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.shutter_speed_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn e_v(&self) -> &f32 {
        self._glacier_base.e_v()
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        self._glacier_base.e_v_mut()
    }
    fn i_s_o(&self) -> &f32 {
        self._glacier_base.i_s_o()
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        self._glacier_base.i_s_o_mut()
    }
    fn spot_meter_scale(&self) -> &f32 {
        self._glacier_base.spot_meter_scale()
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_scale_mut()
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_x()
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_x_mut()
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_y()
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_y_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn render_target(&self) -> &Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        self._glacier_base.render_target()
    }
    fn render_target_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        self._glacier_base.render_target_mut()
    }
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for PlayerCameraEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PlayerCameraEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerCameraEntityData {
}

impl super::core::DataBusPeerTrait for PlayerCameraEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerCameraEntityData {
}

impl super::core::DataContainerTrait for PlayerCameraEntityData {
}

pub static PLAYERCAMERAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerCameraEntityData",
    name_hash: 4240733796,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERAENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlayerCameraEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerCameraEntityData as Default>::default())),
            create_boxed: || Box::new(<PlayerCameraEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SoldierTargetMode",
                name_hash: 2742914237,
                flags: MemberInfoFlags::new(0),
                field_type: "TargetMode",
                rust_offset: offset_of!(PlayerCameraEntityData, soldier_target_mode),
            },
            FieldInfoData {
                name: "SoldierCameraIndex",
                name_hash: 61768104,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerCameraEntityData, soldier_camera_index),
            },
            FieldInfoData {
                name: "VehicleTargetMode",
                name_hash: 3963983535,
                flags: MemberInfoFlags::new(0),
                field_type: "TargetMode",
                rust_offset: offset_of!(PlayerCameraEntityData, vehicle_target_mode),
            },
            FieldInfoData {
                name: "VehicleCameraIndex",
                name_hash: 1896906746,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerCameraEntityData, vehicle_camera_index),
            },
            FieldInfoData {
                name: "ReleaseControlIfTargetLost",
                name_hash: 3292924305,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerCameraEntityData, release_control_if_target_lost),
            },
            FieldInfoData {
                name: "ShouldTargetControllable",
                name_hash: 341097948,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerCameraEntityData, should_target_controllable),
            },
            FieldInfoData {
                name: "ShouldTargetVehicleDriverEntry",
                name_hash: 1821967951,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerCameraEntityData, should_target_vehicle_driver_entry),
            },
            FieldInfoData {
                name: "ShouldTargetExtraPlayerInDoublePlayerEvent",
                name_hash: 1876542201,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerCameraEntityData, should_target_extra_player_in_double_player_event),
            },
            FieldInfoData {
                name: "CameraSmoothingFactor",
                name_hash: 1631719763,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerCameraEntityData, camera_smoothing_factor),
            },
        ],
    }),
    array_type: Some(PLAYERCAMERAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerCameraEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERCAMERAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERCAMERAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerCameraEntityData-Array",
    name_hash: 2785925712,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerCameraEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TargetMode {
    #[default]
    TargetMode_FirstPerson = 0,
    TargetMode_ThirdPerson = 1,
    TargetMode_Index = 2,
}

pub static TARGETMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetMode",
    name_hash: 328913367,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(TARGETMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TargetMode {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TARGETMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetMode-Array",
    name_hash: 2290436835,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TargetMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TargetCameraEntityData {
    pub _glacier_base: CameraEntityBaseData,
    pub camera: Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */>,
    pub offset_transform: super::core::LinearTransform,
    pub f_o_v: f32,
}

pub trait TargetCameraEntityDataTrait: CameraEntityBaseDataTrait {
    fn camera(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */>;
    fn camera_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */>;
    fn offset_transform(&self) -> &super::core::LinearTransform;
    fn offset_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn f_o_v(&self) -> &f32;
    fn f_o_v_mut(&mut self) -> &mut f32;
}

impl TargetCameraEntityDataTrait for TargetCameraEntityData {
    fn camera(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */> {
        &self.camera
    }
    fn camera_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */> {
        &mut self.camera
    }
    fn offset_transform(&self) -> &super::core::LinearTransform {
        &self.offset_transform
    }
    fn offset_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.offset_transform
    }
    fn f_o_v(&self) -> &f32 {
        &self.f_o_v
    }
    fn f_o_v_mut(&mut self) -> &mut f32 {
        &mut self.f_o_v
    }
}

impl CameraEntityBaseDataTrait for TargetCameraEntityData {
    fn name_id(&self) -> &String {
        self._glacier_base.name_id()
    }
    fn name_id_mut(&mut self) -> &mut String {
        self._glacier_base.name_id_mut()
    }
    fn priority(&self) -> &i32 {
        self._glacier_base.priority()
    }
    fn priority_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn object_layers_mask(&self) -> &i32 {
        self._glacier_base.object_layers_mask()
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        self._glacier_base.object_layers_mask_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn focal_length(&self) -> &f32 {
        self._glacier_base.focal_length()
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.focal_length_mut()
    }
    fn focus_distance(&self) -> &f32 {
        self._glacier_base.focus_distance()
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.focus_distance_mut()
    }
    fn exposure_compensation(&self) -> &f32 {
        self._glacier_base.exposure_compensation()
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        self._glacier_base.exposure_compensation_mut()
    }
    fn aperture(&self) -> &f32 {
        self._glacier_base.aperture()
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        self._glacier_base.aperture_mut()
    }
    fn shutter_speed(&self) -> &f32 {
        self._glacier_base.shutter_speed()
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.shutter_speed_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn e_v(&self) -> &f32 {
        self._glacier_base.e_v()
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        self._glacier_base.e_v_mut()
    }
    fn i_s_o(&self) -> &f32 {
        self._glacier_base.i_s_o()
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        self._glacier_base.i_s_o_mut()
    }
    fn spot_meter_scale(&self) -> &f32 {
        self._glacier_base.spot_meter_scale()
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_scale_mut()
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_x()
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_x_mut()
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_y()
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_y_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn render_target(&self) -> &Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        self._glacier_base.render_target()
    }
    fn render_target_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        self._glacier_base.render_target_mut()
    }
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for TargetCameraEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TargetCameraEntityData {
}

impl super::entity::GameObjectDataTrait for TargetCameraEntityData {
}

impl super::core::DataBusPeerTrait for TargetCameraEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TargetCameraEntityData {
}

impl super::core::DataContainerTrait for TargetCameraEntityData {
}

pub static TARGETCAMERAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCameraEntityData",
    name_hash: 3345735622,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERAENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(TargetCameraEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TargetCameraEntityData as Default>::default())),
            create_boxed: || Box::new(<TargetCameraEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Camera",
                name_hash: 2716359356,
                flags: MemberInfoFlags::new(0),
                field_type: "TargetCameraData",
                rust_offset: offset_of!(TargetCameraEntityData, camera),
            },
            FieldInfoData {
                name: "OffsetTransform",
                name_hash: 90785508,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TargetCameraEntityData, offset_transform),
            },
            FieldInfoData {
                name: "FOV",
                name_hash: 193442778,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetCameraEntityData, f_o_v),
            },
        ],
    }),
    array_type: Some(TARGETCAMERAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TargetCameraEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETCAMERAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TARGETCAMERAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCameraEntityData-Array",
    name_hash: 1260354930,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TargetCameraEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LookAtCameraEntityData {
    pub _glacier_base: CameraEntityData,
}

pub trait LookAtCameraEntityDataTrait: CameraEntityDataTrait {
}

impl LookAtCameraEntityDataTrait for LookAtCameraEntityData {
}

impl CameraEntityDataTrait for LookAtCameraEntityData {
    fn fov(&self) -> &f32 {
        self._glacier_base.fov()
    }
    fn fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.fov_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn far_plane(&self) -> &f32 {
        self._glacier_base.far_plane()
    }
    fn far_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.far_plane_mut()
    }
}

impl CameraEntityBaseDataTrait for LookAtCameraEntityData {
    fn name_id(&self) -> &String {
        self._glacier_base.name_id()
    }
    fn name_id_mut(&mut self) -> &mut String {
        self._glacier_base.name_id_mut()
    }
    fn priority(&self) -> &i32 {
        self._glacier_base.priority()
    }
    fn priority_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn object_layers_mask(&self) -> &i32 {
        self._glacier_base.object_layers_mask()
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        self._glacier_base.object_layers_mask_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn focal_length(&self) -> &f32 {
        self._glacier_base.focal_length()
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.focal_length_mut()
    }
    fn focus_distance(&self) -> &f32 {
        self._glacier_base.focus_distance()
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.focus_distance_mut()
    }
    fn exposure_compensation(&self) -> &f32 {
        self._glacier_base.exposure_compensation()
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        self._glacier_base.exposure_compensation_mut()
    }
    fn aperture(&self) -> &f32 {
        self._glacier_base.aperture()
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        self._glacier_base.aperture_mut()
    }
    fn shutter_speed(&self) -> &f32 {
        self._glacier_base.shutter_speed()
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.shutter_speed_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn e_v(&self) -> &f32 {
        self._glacier_base.e_v()
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        self._glacier_base.e_v_mut()
    }
    fn i_s_o(&self) -> &f32 {
        self._glacier_base.i_s_o()
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        self._glacier_base.i_s_o_mut()
    }
    fn spot_meter_scale(&self) -> &f32 {
        self._glacier_base.spot_meter_scale()
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_scale_mut()
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_x()
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_x_mut()
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_y()
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_y_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn render_target(&self) -> &Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        self._glacier_base.render_target()
    }
    fn render_target_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        self._glacier_base.render_target_mut()
    }
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for LookAtCameraEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LookAtCameraEntityData {
}

impl super::entity::GameObjectDataTrait for LookAtCameraEntityData {
}

impl super::core::DataBusPeerTrait for LookAtCameraEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LookAtCameraEntityData {
}

impl super::core::DataContainerTrait for LookAtCameraEntityData {
}

pub static LOOKATCAMERAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtCameraEntityData",
    name_hash: 2121026565,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERAENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LookAtCameraEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LookAtCameraEntityData as Default>::default())),
            create_boxed: || Box::new(<LookAtCameraEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOOKATCAMERAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LookAtCameraEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOOKATCAMERAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOOKATCAMERAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtCameraEntityData-Array",
    name_hash: 723415985,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LookAtCameraEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraEntityData {
    pub _glacier_base: CameraEntityBaseData,
    pub fov: f32,
    pub near_plane: f32,
    pub far_plane: f32,
}

pub trait CameraEntityDataTrait: CameraEntityBaseDataTrait {
    fn fov(&self) -> &f32;
    fn fov_mut(&mut self) -> &mut f32;
    fn near_plane(&self) -> &f32;
    fn near_plane_mut(&mut self) -> &mut f32;
    fn far_plane(&self) -> &f32;
    fn far_plane_mut(&mut self) -> &mut f32;
}

impl CameraEntityDataTrait for CameraEntityData {
    fn fov(&self) -> &f32 {
        &self.fov
    }
    fn fov_mut(&mut self) -> &mut f32 {
        &mut self.fov
    }
    fn near_plane(&self) -> &f32 {
        &self.near_plane
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        &mut self.near_plane
    }
    fn far_plane(&self) -> &f32 {
        &self.far_plane
    }
    fn far_plane_mut(&mut self) -> &mut f32 {
        &mut self.far_plane
    }
}

impl CameraEntityBaseDataTrait for CameraEntityData {
    fn name_id(&self) -> &String {
        self._glacier_base.name_id()
    }
    fn name_id_mut(&mut self) -> &mut String {
        self._glacier_base.name_id_mut()
    }
    fn priority(&self) -> &i32 {
        self._glacier_base.priority()
    }
    fn priority_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn object_layers_mask(&self) -> &i32 {
        self._glacier_base.object_layers_mask()
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        self._glacier_base.object_layers_mask_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn focal_length(&self) -> &f32 {
        self._glacier_base.focal_length()
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.focal_length_mut()
    }
    fn focus_distance(&self) -> &f32 {
        self._glacier_base.focus_distance()
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.focus_distance_mut()
    }
    fn exposure_compensation(&self) -> &f32 {
        self._glacier_base.exposure_compensation()
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        self._glacier_base.exposure_compensation_mut()
    }
    fn aperture(&self) -> &f32 {
        self._glacier_base.aperture()
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        self._glacier_base.aperture_mut()
    }
    fn shutter_speed(&self) -> &f32 {
        self._glacier_base.shutter_speed()
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.shutter_speed_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn e_v(&self) -> &f32 {
        self._glacier_base.e_v()
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        self._glacier_base.e_v_mut()
    }
    fn i_s_o(&self) -> &f32 {
        self._glacier_base.i_s_o()
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        self._glacier_base.i_s_o_mut()
    }
    fn spot_meter_scale(&self) -> &f32 {
        self._glacier_base.spot_meter_scale()
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_scale_mut()
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_x()
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_x_mut()
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_y()
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_y_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn render_target(&self) -> &Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        self._glacier_base.render_target()
    }
    fn render_target_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        self._glacier_base.render_target_mut()
    }
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for CameraEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CameraEntityData {
}

impl super::entity::GameObjectDataTrait for CameraEntityData {
}

impl super::core::DataBusPeerTrait for CameraEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraEntityData {
}

impl super::core::DataContainerTrait for CameraEntityData {
}

pub static CAMERAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEntityData",
    name_hash: 3783889431,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERAENTITYBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraEntityData as Default>::default())),
            create_boxed: || Box::new(<CameraEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Fov",
                name_hash: 193443802,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityData, fov),
            },
            FieldInfoData {
                name: "NearPlane",
                name_hash: 3156145579,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityData, near_plane),
            },
            FieldInfoData {
                name: "FarPlane",
                name_hash: 192290566,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityData, far_plane),
            },
        ],
    }),
    array_type: Some(CAMERAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEntityData-Array",
    name_hash: 2254666403,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraEntityBaseData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub name_id: String,
    pub priority: i32,
    pub view_id: super::render_base::LocalPlayerViewId,
    pub object_layers_mask: i32,
    pub enabled: bool,
    pub physical_camera_body: Option<LockedTypeObject /* CameraBodyPreset */>,
    pub physical_camera_lens: Option<LockedTypeObject /* CameraLensPreset */>,
    pub focal_length: f32,
    pub focus_distance: f32,
    pub exposure_compensation: f32,
    pub aperture: f32,
    pub shutter_speed: f32,
    pub exposure_mode: ExposureMode,
    pub e_v: f32,
    pub i_s_o: f32,
    pub spot_meter_scale: f32,
    pub spot_meter_offset_x: f32,
    pub spot_meter_offset_y: f32,
    pub auto_exposure_method: super::render_base::AutoExposureMethod,
    pub render_target: Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */>,
    pub transition_data_pack: Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */>,
}

pub trait CameraEntityBaseDataTrait: super::entity::SpatialEntityDataTrait {
    fn name_id(&self) -> &String;
    fn name_id_mut(&mut self) -> &mut String;
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId;
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId;
    fn object_layers_mask(&self) -> &i32;
    fn object_layers_mask_mut(&mut self) -> &mut i32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */>;
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */>;
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */>;
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */>;
    fn focal_length(&self) -> &f32;
    fn focal_length_mut(&mut self) -> &mut f32;
    fn focus_distance(&self) -> &f32;
    fn focus_distance_mut(&mut self) -> &mut f32;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn aperture(&self) -> &f32;
    fn aperture_mut(&mut self) -> &mut f32;
    fn shutter_speed(&self) -> &f32;
    fn shutter_speed_mut(&mut self) -> &mut f32;
    fn exposure_mode(&self) -> &ExposureMode;
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode;
    fn e_v(&self) -> &f32;
    fn e_v_mut(&mut self) -> &mut f32;
    fn i_s_o(&self) -> &f32;
    fn i_s_o_mut(&mut self) -> &mut f32;
    fn spot_meter_scale(&self) -> &f32;
    fn spot_meter_scale_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_x(&self) -> &f32;
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_y(&self) -> &f32;
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32;
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod;
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod;
    fn render_target(&self) -> &Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */>;
    fn render_target_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */>;
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */>;
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */>;
}

impl CameraEntityBaseDataTrait for CameraEntityBaseData {
    fn name_id(&self) -> &String {
        &self.name_id
    }
    fn name_id_mut(&mut self) -> &mut String {
        &mut self.name_id
    }
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        &self.view_id
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        &mut self.view_id
    }
    fn object_layers_mask(&self) -> &i32 {
        &self.object_layers_mask
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        &mut self.object_layers_mask
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn physical_camera_body(&self) -> &Option<LockedTypeObject /* CameraBodyPreset */> {
        &self.physical_camera_body
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraBodyPreset */> {
        &mut self.physical_camera_body
    }
    fn physical_camera_lens(&self) -> &Option<LockedTypeObject /* CameraLensPreset */> {
        &self.physical_camera_lens
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraLensPreset */> {
        &mut self.physical_camera_lens
    }
    fn focal_length(&self) -> &f32 {
        &self.focal_length
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        &mut self.focal_length
    }
    fn focus_distance(&self) -> &f32 {
        &self.focus_distance
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        &mut self.focus_distance
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn aperture(&self) -> &f32 {
        &self.aperture
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        &mut self.aperture
    }
    fn shutter_speed(&self) -> &f32 {
        &self.shutter_speed
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        &mut self.shutter_speed
    }
    fn exposure_mode(&self) -> &ExposureMode {
        &self.exposure_mode
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        &mut self.exposure_mode
    }
    fn e_v(&self) -> &f32 {
        &self.e_v
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        &mut self.e_v
    }
    fn i_s_o(&self) -> &f32 {
        &self.i_s_o
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        &mut self.i_s_o
    }
    fn spot_meter_scale(&self) -> &f32 {
        &self.spot_meter_scale
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_scale
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        &self.spot_meter_offset_x
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_x
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        &self.spot_meter_offset_y
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_y
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        &self.auto_exposure_method
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        &mut self.auto_exposure_method
    }
    fn render_target(&self) -> &Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        &self.render_target
    }
    fn render_target_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::RenderTextureBaseAsset */> {
        &mut self.render_target
    }
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        &self.transition_data_pack
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        &mut self.transition_data_pack
    }
}

impl super::entity::SpatialEntityDataTrait for CameraEntityBaseData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CameraEntityBaseData {
}

impl super::entity::GameObjectDataTrait for CameraEntityBaseData {
}

impl super::core::DataBusPeerTrait for CameraEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraEntityBaseData {
}

impl super::core::DataContainerTrait for CameraEntityBaseData {
}

pub static CAMERAENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEntityBaseData",
    name_hash: 842747074,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraEntityBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraEntityBaseData as Default>::default())),
            create_boxed: || Box::new(<CameraEntityBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "NameId",
                name_hash: 2828728719,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CameraEntityBaseData, name_id),
            },
            FieldInfoData {
                name: "Priority",
                name_hash: 3062102871,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraEntityBaseData, priority),
            },
            FieldInfoData {
                name: "ViewId",
                name_hash: 3151570821,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerViewId",
                rust_offset: offset_of!(CameraEntityBaseData, view_id),
            },
            FieldInfoData {
                name: "ObjectLayersMask",
                name_hash: 22577300,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraEntityBaseData, object_layers_mask),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraEntityBaseData, enabled),
            },
            FieldInfoData {
                name: "PhysicalCameraBody",
                name_hash: 3562743577,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraBodyPreset",
                rust_offset: offset_of!(CameraEntityBaseData, physical_camera_body),
            },
            FieldInfoData {
                name: "PhysicalCameraLens",
                name_hash: 3562665885,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraLensPreset",
                rust_offset: offset_of!(CameraEntityBaseData, physical_camera_lens),
            },
            FieldInfoData {
                name: "FocalLength",
                name_hash: 1499741854,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, focal_length),
            },
            FieldInfoData {
                name: "FocusDistance",
                name_hash: 1402926186,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, focus_distance),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                name_hash: 3835253666,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, exposure_compensation),
            },
            FieldInfoData {
                name: "Aperture",
                name_hash: 1885994293,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, aperture),
            },
            FieldInfoData {
                name: "ShutterSpeed",
                name_hash: 488177211,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, shutter_speed),
            },
            FieldInfoData {
                name: "ExposureMode",
                name_hash: 3564732021,
                flags: MemberInfoFlags::new(0),
                field_type: "ExposureMode",
                rust_offset: offset_of!(CameraEntityBaseData, exposure_mode),
            },
            FieldInfoData {
                name: "EV",
                name_hash: 5861814,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, e_v),
            },
            FieldInfoData {
                name: "ISO",
                name_hash: 193452880,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, i_s_o),
            },
            FieldInfoData {
                name: "SpotMeterScale",
                name_hash: 1691011758,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, spot_meter_scale),
            },
            FieldInfoData {
                name: "SpotMeterOffsetX",
                name_hash: 3433992131,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, spot_meter_offset_x),
            },
            FieldInfoData {
                name: "SpotMeterOffsetY",
                name_hash: 3433992130,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, spot_meter_offset_y),
            },
            FieldInfoData {
                name: "AutoExposureMethod",
                name_hash: 2459920774,
                flags: MemberInfoFlags::new(0),
                field_type: "AutoExposureMethod",
                rust_offset: offset_of!(CameraEntityBaseData, auto_exposure_method),
            },
            FieldInfoData {
                name: "RenderTarget",
                name_hash: 1581516062,
                flags: MemberInfoFlags::new(0),
                field_type: "RenderTextureBaseAsset",
                rust_offset: offset_of!(CameraEntityBaseData, render_target),
            },
            FieldInfoData {
                name: "TransitionDataPack",
                name_hash: 600691939,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraTransitionEffectDataPack",
                rust_offset: offset_of!(CameraEntityBaseData, transition_data_pack),
            },
        ],
    }),
    array_type: Some(CAMERAENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CameraEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEntityBaseData-Array",
    name_hash: 3217882230,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ExposureMode {
    #[default]
    ExposureMode_Manual = 0,
    ExposureMode_ManualEV = 1,
    ExposureMode_AutoExposure = 2,
    ExposureMode_UseVisualEnvironment = 3,
}

pub static EXPOSUREMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExposureMode",
    name_hash: 3564732021,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(EXPOSUREMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ExposureMode {
    fn type_info(&self) -> &'static TypeInfo {
        EXPOSUREMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EXPOSUREMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExposureMode-Array",
    name_hash: 971452225,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ExposureMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraLensPreset {
    pub _glacier_base: super::core::Asset,
    pub default_focal_length: f32,
    pub enable_lens_breathing: bool,
    pub visual_environment: Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */>,
}

pub trait CameraLensPresetTrait: super::core::AssetTrait {
    fn default_focal_length(&self) -> &f32;
    fn default_focal_length_mut(&mut self) -> &mut f32;
    fn enable_lens_breathing(&self) -> &bool;
    fn enable_lens_breathing_mut(&mut self) -> &mut bool;
    fn visual_environment(&self) -> &Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */>;
    fn visual_environment_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */>;
}

impl CameraLensPresetTrait for CameraLensPreset {
    fn default_focal_length(&self) -> &f32 {
        &self.default_focal_length
    }
    fn default_focal_length_mut(&mut self) -> &mut f32 {
        &mut self.default_focal_length
    }
    fn enable_lens_breathing(&self) -> &bool {
        &self.enable_lens_breathing
    }
    fn enable_lens_breathing_mut(&mut self) -> &mut bool {
        &mut self.enable_lens_breathing
    }
    fn visual_environment(&self) -> &Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */> {
        &self.visual_environment
    }
    fn visual_environment_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */> {
        &mut self.visual_environment
    }
}

impl super::core::AssetTrait for CameraLensPreset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CameraLensPreset {
}

pub static CAMERALENSPRESET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLensPreset",
    name_hash: 2785227821,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(CameraLensPreset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraLensPreset as Default>::default())),
            create_boxed: || Box::new(<CameraLensPreset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultFocalLength",
                name_hash: 432875349,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraLensPreset, default_focal_length),
            },
            FieldInfoData {
                name: "EnableLensBreathing",
                name_hash: 3262787448,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraLensPreset, enable_lens_breathing),
            },
            FieldInfoData {
                name: "VisualEnvironment",
                name_hash: 1724714788,
                flags: MemberInfoFlags::new(0),
                field_type: "VisualEnvironmentBlueprint",
                rust_offset: offset_of!(CameraLensPreset, visual_environment),
            },
        ],
    }),
    array_type: Some(CAMERALENSPRESET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraLensPreset {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERALENSPRESET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERALENSPRESET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLensPreset-Array",
    name_hash: 1617856665,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraLensPreset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraBodyPreset {
    pub _glacier_base: super::core::Asset,
    pub sensor_width: f32,
    pub sensor_height: f32,
    pub visual_environment: Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */>,
}

pub trait CameraBodyPresetTrait: super::core::AssetTrait {
    fn sensor_width(&self) -> &f32;
    fn sensor_width_mut(&mut self) -> &mut f32;
    fn sensor_height(&self) -> &f32;
    fn sensor_height_mut(&mut self) -> &mut f32;
    fn visual_environment(&self) -> &Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */>;
    fn visual_environment_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */>;
}

impl CameraBodyPresetTrait for CameraBodyPreset {
    fn sensor_width(&self) -> &f32 {
        &self.sensor_width
    }
    fn sensor_width_mut(&mut self) -> &mut f32 {
        &mut self.sensor_width
    }
    fn sensor_height(&self) -> &f32 {
        &self.sensor_height
    }
    fn sensor_height_mut(&mut self) -> &mut f32 {
        &mut self.sensor_height
    }
    fn visual_environment(&self) -> &Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */> {
        &self.visual_environment
    }
    fn visual_environment_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::VisualEnvironmentBlueprint */> {
        &mut self.visual_environment
    }
}

impl super::core::AssetTrait for CameraBodyPreset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CameraBodyPreset {
}

pub static CAMERABODYPRESET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraBodyPreset",
    name_hash: 4100167081,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(CameraBodyPreset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraBodyPreset as Default>::default())),
            create_boxed: || Box::new(<CameraBodyPreset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SensorWidth",
                name_hash: 2576703797,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraBodyPreset, sensor_width),
            },
            FieldInfoData {
                name: "SensorHeight",
                name_hash: 105242156,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraBodyPreset, sensor_height),
            },
            FieldInfoData {
                name: "VisualEnvironment",
                name_hash: 1724714788,
                flags: MemberInfoFlags::new(0),
                field_type: "VisualEnvironmentBlueprint",
                rust_offset: offset_of!(CameraBodyPreset, visual_environment),
            },
        ],
    }),
    array_type: Some(CAMERABODYPRESET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraBodyPreset {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERABODYPRESET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERABODYPRESET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraBodyPreset-Array",
    name_hash: 598891549,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraBodyPreset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleCameraData {
    pub _glacier_base: super::gameplay_sim::TargetCameraData,
    pub move_to_position: super::core::Vec3,
    pub move_to_position_slope_factor: super::core::Vec3,
    pub target_offset: super::core::Vec3,
    pub target_offset_slope_factor: super::core::Vec3,
    pub rotation_factor: super::core::Vec3,
    pub position_factor: f32,
    pub reset_distance: f32,
    pub fixed_position: bool,
    pub fixed_angle_z: bool,
    pub use_terrain_adjustment: bool,
}

pub trait VehicleCameraDataTrait: super::gameplay_sim::TargetCameraDataTrait {
    fn move_to_position(&self) -> &super::core::Vec3;
    fn move_to_position_mut(&mut self) -> &mut super::core::Vec3;
    fn move_to_position_slope_factor(&self) -> &super::core::Vec3;
    fn move_to_position_slope_factor_mut(&mut self) -> &mut super::core::Vec3;
    fn target_offset(&self) -> &super::core::Vec3;
    fn target_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn target_offset_slope_factor(&self) -> &super::core::Vec3;
    fn target_offset_slope_factor_mut(&mut self) -> &mut super::core::Vec3;
    fn rotation_factor(&self) -> &super::core::Vec3;
    fn rotation_factor_mut(&mut self) -> &mut super::core::Vec3;
    fn position_factor(&self) -> &f32;
    fn position_factor_mut(&mut self) -> &mut f32;
    fn reset_distance(&self) -> &f32;
    fn reset_distance_mut(&mut self) -> &mut f32;
    fn fixed_position(&self) -> &bool;
    fn fixed_position_mut(&mut self) -> &mut bool;
    fn fixed_angle_z(&self) -> &bool;
    fn fixed_angle_z_mut(&mut self) -> &mut bool;
    fn use_terrain_adjustment(&self) -> &bool;
    fn use_terrain_adjustment_mut(&mut self) -> &mut bool;
}

impl VehicleCameraDataTrait for VehicleCameraData {
    fn move_to_position(&self) -> &super::core::Vec3 {
        &self.move_to_position
    }
    fn move_to_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.move_to_position
    }
    fn move_to_position_slope_factor(&self) -> &super::core::Vec3 {
        &self.move_to_position_slope_factor
    }
    fn move_to_position_slope_factor_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.move_to_position_slope_factor
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        &self.target_offset
    }
    fn target_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_offset
    }
    fn target_offset_slope_factor(&self) -> &super::core::Vec3 {
        &self.target_offset_slope_factor
    }
    fn target_offset_slope_factor_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_offset_slope_factor
    }
    fn rotation_factor(&self) -> &super::core::Vec3 {
        &self.rotation_factor
    }
    fn rotation_factor_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.rotation_factor
    }
    fn position_factor(&self) -> &f32 {
        &self.position_factor
    }
    fn position_factor_mut(&mut self) -> &mut f32 {
        &mut self.position_factor
    }
    fn reset_distance(&self) -> &f32 {
        &self.reset_distance
    }
    fn reset_distance_mut(&mut self) -> &mut f32 {
        &mut self.reset_distance
    }
    fn fixed_position(&self) -> &bool {
        &self.fixed_position
    }
    fn fixed_position_mut(&mut self) -> &mut bool {
        &mut self.fixed_position
    }
    fn fixed_angle_z(&self) -> &bool {
        &self.fixed_angle_z
    }
    fn fixed_angle_z_mut(&mut self) -> &mut bool {
        &mut self.fixed_angle_z
    }
    fn use_terrain_adjustment(&self) -> &bool {
        &self.use_terrain_adjustment
    }
    fn use_terrain_adjustment_mut(&mut self) -> &mut bool {
        &mut self.use_terrain_adjustment
    }
}

impl super::gameplay_sim::TargetCameraDataTrait for VehicleCameraData {
    fn hud(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        self._glacier_base.hud()
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        self._glacier_base.hud_mut()
    }
    fn use_transform_space_hierarchy(&self) -> &bool {
        self._glacier_base.use_transform_space_hierarchy()
    }
    fn use_transform_space_hierarchy_mut(&mut self) -> &mut bool {
        self._glacier_base.use_transform_space_hierarchy_mut()
    }
}

impl super::gameplay_sim::CameraDataTrait for VehicleCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleCameraData {
}

impl super::core::DataBusPeerTrait for VehicleCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleCameraData {
}

impl super::core::DataContainerTrait for VehicleCameraData {
}

pub static VEHICLECAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCameraData",
    name_hash: 3310862324,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TARGETCAMERADATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleCameraData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleCameraData as Default>::default())),
            create_boxed: || Box::new(<VehicleCameraData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MoveToPosition",
                name_hash: 2255519254,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, move_to_position),
            },
            FieldInfoData {
                name: "MoveToPositionSlopeFactor",
                name_hash: 3566386494,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, move_to_position_slope_factor),
            },
            FieldInfoData {
                name: "TargetOffset",
                name_hash: 1634518457,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, target_offset),
            },
            FieldInfoData {
                name: "TargetOffsetSlopeFactor",
                name_hash: 2939212273,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, target_offset_slope_factor),
            },
            FieldInfoData {
                name: "RotationFactor",
                name_hash: 1739032700,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, rotation_factor),
            },
            FieldInfoData {
                name: "PositionFactor",
                name_hash: 3939849105,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCameraData, position_factor),
            },
            FieldInfoData {
                name: "ResetDistance",
                name_hash: 601574707,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCameraData, reset_distance),
            },
            FieldInfoData {
                name: "FixedPosition",
                name_hash: 2172041354,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCameraData, fixed_position),
            },
            FieldInfoData {
                name: "FixedAngleZ",
                name_hash: 3991869768,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCameraData, fixed_angle_z),
            },
            FieldInfoData {
                name: "UseTerrainAdjustment",
                name_hash: 3333670366,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCameraData, use_terrain_adjustment),
            },
        ],
    }),
    array_type: Some(VEHICLECAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLECAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCameraData-Array",
    name_hash: 4175760320,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraLeapData {
    pub transform: super::core::LinearTransform,
    pub time: f32,
    pub fov_modifier: f32,
}

pub trait CameraLeapDataTrait: TypeObject {
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn fov_modifier(&self) -> &f32;
    fn fov_modifier_mut(&mut self) -> &mut f32;
}

impl CameraLeapDataTrait for CameraLeapData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn fov_modifier(&self) -> &f32 {
        &self.fov_modifier
    }
    fn fov_modifier_mut(&mut self) -> &mut f32 {
        &mut self.fov_modifier
    }
}

pub static CAMERALEAPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLeapData",
    name_hash: 981182484,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraLeapData as Default>::default())),
            create_boxed: || Box::new(<CameraLeapData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                name_hash: 2270319721,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CameraLeapData, transform),
            },
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraLeapData, time),
            },
            FieldInfoData {
                name: "FovModifier",
                name_hash: 3245684845,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraLeapData, fov_modifier),
            },
        ],
    }),
    array_type: Some(CAMERALEAPDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraLeapData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERALEAPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERALEAPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLeapData-Array",
    name_hash: 2013971488,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraLeapData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticCameraData {
    pub _glacier_base: super::gameplay_sim::TargetCameraData,
    pub left_curve: Vec<BoxedTypeObject /* super::core::Vec3 */>,
    pub right_curve: Vec<BoxedTypeObject /* super::core::Vec3 */>,
    pub up_curve: Vec<BoxedTypeObject /* super::core::Vec3 */>,
    pub down_curve: Vec<BoxedTypeObject /* super::core::Vec3 */>,
    pub merge_left_and_right_curves: bool,
    pub merge_up_and_down_curves: bool,
    pub mirror_horizontal_curves: bool,
    pub mirror_vertical_curves: bool,
    pub loose_part_physics: Vec<Option<LockedTypeObject /* super::physics::CameraLoosePartPhysicsData */>>,
    pub left_yaw_angle: f32,
    pub right_yaw_angle: f32,
    pub up_pitch_angle: f32,
    pub down_pitch_angle: f32,
    pub average_filter_frames: i32,
    pub yaw_input_action: i32,
    pub pitch_input_action: i32,
    pub accumulate_input: bool,
    pub reset_accumulated_input_on_view_change: bool,
    pub world_space_lock_efficiency_yaw: f32,
    pub world_space_lock_efficiency_pitch: f32,
    pub yaw_sensitivity_non_zoomed: f32,
    pub yaw_sensitivity_zoomed: f32,
    pub pitch_sensitivity_non_zoomed: f32,
    pub pitch_sensitivity_zoomed: f32,
}

pub trait StaticCameraDataTrait: super::gameplay_sim::TargetCameraDataTrait {
    fn left_curve(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn left_curve_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn right_curve(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn right_curve_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn up_curve(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn up_curve_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn down_curve(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn down_curve_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn merge_left_and_right_curves(&self) -> &bool;
    fn merge_left_and_right_curves_mut(&mut self) -> &mut bool;
    fn merge_up_and_down_curves(&self) -> &bool;
    fn merge_up_and_down_curves_mut(&mut self) -> &mut bool;
    fn mirror_horizontal_curves(&self) -> &bool;
    fn mirror_horizontal_curves_mut(&mut self) -> &mut bool;
    fn mirror_vertical_curves(&self) -> &bool;
    fn mirror_vertical_curves_mut(&mut self) -> &mut bool;
    fn loose_part_physics(&self) -> &Vec<Option<LockedTypeObject /* super::physics::CameraLoosePartPhysicsData */>>;
    fn loose_part_physics_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::CameraLoosePartPhysicsData */>>;
    fn left_yaw_angle(&self) -> &f32;
    fn left_yaw_angle_mut(&mut self) -> &mut f32;
    fn right_yaw_angle(&self) -> &f32;
    fn right_yaw_angle_mut(&mut self) -> &mut f32;
    fn up_pitch_angle(&self) -> &f32;
    fn up_pitch_angle_mut(&mut self) -> &mut f32;
    fn down_pitch_angle(&self) -> &f32;
    fn down_pitch_angle_mut(&mut self) -> &mut f32;
    fn average_filter_frames(&self) -> &i32;
    fn average_filter_frames_mut(&mut self) -> &mut i32;
    fn yaw_input_action(&self) -> &i32;
    fn yaw_input_action_mut(&mut self) -> &mut i32;
    fn pitch_input_action(&self) -> &i32;
    fn pitch_input_action_mut(&mut self) -> &mut i32;
    fn accumulate_input(&self) -> &bool;
    fn accumulate_input_mut(&mut self) -> &mut bool;
    fn reset_accumulated_input_on_view_change(&self) -> &bool;
    fn reset_accumulated_input_on_view_change_mut(&mut self) -> &mut bool;
    fn world_space_lock_efficiency_yaw(&self) -> &f32;
    fn world_space_lock_efficiency_yaw_mut(&mut self) -> &mut f32;
    fn world_space_lock_efficiency_pitch(&self) -> &f32;
    fn world_space_lock_efficiency_pitch_mut(&mut self) -> &mut f32;
    fn yaw_sensitivity_non_zoomed(&self) -> &f32;
    fn yaw_sensitivity_non_zoomed_mut(&mut self) -> &mut f32;
    fn yaw_sensitivity_zoomed(&self) -> &f32;
    fn yaw_sensitivity_zoomed_mut(&mut self) -> &mut f32;
    fn pitch_sensitivity_non_zoomed(&self) -> &f32;
    fn pitch_sensitivity_non_zoomed_mut(&mut self) -> &mut f32;
    fn pitch_sensitivity_zoomed(&self) -> &f32;
    fn pitch_sensitivity_zoomed_mut(&mut self) -> &mut f32;
}

impl StaticCameraDataTrait for StaticCameraData {
    fn left_curve(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.left_curve
    }
    fn left_curve_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.left_curve
    }
    fn right_curve(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.right_curve
    }
    fn right_curve_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.right_curve
    }
    fn up_curve(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.up_curve
    }
    fn up_curve_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.up_curve
    }
    fn down_curve(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.down_curve
    }
    fn down_curve_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.down_curve
    }
    fn merge_left_and_right_curves(&self) -> &bool {
        &self.merge_left_and_right_curves
    }
    fn merge_left_and_right_curves_mut(&mut self) -> &mut bool {
        &mut self.merge_left_and_right_curves
    }
    fn merge_up_and_down_curves(&self) -> &bool {
        &self.merge_up_and_down_curves
    }
    fn merge_up_and_down_curves_mut(&mut self) -> &mut bool {
        &mut self.merge_up_and_down_curves
    }
    fn mirror_horizontal_curves(&self) -> &bool {
        &self.mirror_horizontal_curves
    }
    fn mirror_horizontal_curves_mut(&mut self) -> &mut bool {
        &mut self.mirror_horizontal_curves
    }
    fn mirror_vertical_curves(&self) -> &bool {
        &self.mirror_vertical_curves
    }
    fn mirror_vertical_curves_mut(&mut self) -> &mut bool {
        &mut self.mirror_vertical_curves
    }
    fn loose_part_physics(&self) -> &Vec<Option<LockedTypeObject /* super::physics::CameraLoosePartPhysicsData */>> {
        &self.loose_part_physics
    }
    fn loose_part_physics_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::CameraLoosePartPhysicsData */>> {
        &mut self.loose_part_physics
    }
    fn left_yaw_angle(&self) -> &f32 {
        &self.left_yaw_angle
    }
    fn left_yaw_angle_mut(&mut self) -> &mut f32 {
        &mut self.left_yaw_angle
    }
    fn right_yaw_angle(&self) -> &f32 {
        &self.right_yaw_angle
    }
    fn right_yaw_angle_mut(&mut self) -> &mut f32 {
        &mut self.right_yaw_angle
    }
    fn up_pitch_angle(&self) -> &f32 {
        &self.up_pitch_angle
    }
    fn up_pitch_angle_mut(&mut self) -> &mut f32 {
        &mut self.up_pitch_angle
    }
    fn down_pitch_angle(&self) -> &f32 {
        &self.down_pitch_angle
    }
    fn down_pitch_angle_mut(&mut self) -> &mut f32 {
        &mut self.down_pitch_angle
    }
    fn average_filter_frames(&self) -> &i32 {
        &self.average_filter_frames
    }
    fn average_filter_frames_mut(&mut self) -> &mut i32 {
        &mut self.average_filter_frames
    }
    fn yaw_input_action(&self) -> &i32 {
        &self.yaw_input_action
    }
    fn yaw_input_action_mut(&mut self) -> &mut i32 {
        &mut self.yaw_input_action
    }
    fn pitch_input_action(&self) -> &i32 {
        &self.pitch_input_action
    }
    fn pitch_input_action_mut(&mut self) -> &mut i32 {
        &mut self.pitch_input_action
    }
    fn accumulate_input(&self) -> &bool {
        &self.accumulate_input
    }
    fn accumulate_input_mut(&mut self) -> &mut bool {
        &mut self.accumulate_input
    }
    fn reset_accumulated_input_on_view_change(&self) -> &bool {
        &self.reset_accumulated_input_on_view_change
    }
    fn reset_accumulated_input_on_view_change_mut(&mut self) -> &mut bool {
        &mut self.reset_accumulated_input_on_view_change
    }
    fn world_space_lock_efficiency_yaw(&self) -> &f32 {
        &self.world_space_lock_efficiency_yaw
    }
    fn world_space_lock_efficiency_yaw_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency_yaw
    }
    fn world_space_lock_efficiency_pitch(&self) -> &f32 {
        &self.world_space_lock_efficiency_pitch
    }
    fn world_space_lock_efficiency_pitch_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency_pitch
    }
    fn yaw_sensitivity_non_zoomed(&self) -> &f32 {
        &self.yaw_sensitivity_non_zoomed
    }
    fn yaw_sensitivity_non_zoomed_mut(&mut self) -> &mut f32 {
        &mut self.yaw_sensitivity_non_zoomed
    }
    fn yaw_sensitivity_zoomed(&self) -> &f32 {
        &self.yaw_sensitivity_zoomed
    }
    fn yaw_sensitivity_zoomed_mut(&mut self) -> &mut f32 {
        &mut self.yaw_sensitivity_zoomed
    }
    fn pitch_sensitivity_non_zoomed(&self) -> &f32 {
        &self.pitch_sensitivity_non_zoomed
    }
    fn pitch_sensitivity_non_zoomed_mut(&mut self) -> &mut f32 {
        &mut self.pitch_sensitivity_non_zoomed
    }
    fn pitch_sensitivity_zoomed(&self) -> &f32 {
        &self.pitch_sensitivity_zoomed
    }
    fn pitch_sensitivity_zoomed_mut(&mut self) -> &mut f32 {
        &mut self.pitch_sensitivity_zoomed
    }
}

impl super::gameplay_sim::TargetCameraDataTrait for StaticCameraData {
    fn hud(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        self._glacier_base.hud()
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        self._glacier_base.hud_mut()
    }
    fn use_transform_space_hierarchy(&self) -> &bool {
        self._glacier_base.use_transform_space_hierarchy()
    }
    fn use_transform_space_hierarchy_mut(&mut self) -> &mut bool {
        self._glacier_base.use_transform_space_hierarchy_mut()
    }
}

impl super::gameplay_sim::CameraDataTrait for StaticCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticCameraData {
}

impl super::core::DataBusPeerTrait for StaticCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticCameraData {
}

impl super::core::DataContainerTrait for StaticCameraData {
}

pub static STATICCAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticCameraData",
    name_hash: 2722924628,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TARGETCAMERADATA_TYPE_INFO),
        super_class_offset: offset_of!(StaticCameraData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticCameraData as Default>::default())),
            create_boxed: || Box::new(<StaticCameraData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LeftCurve",
                name_hash: 2820820617,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(StaticCameraData, left_curve),
            },
            FieldInfoData {
                name: "RightCurve",
                name_hash: 724171666,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(StaticCameraData, right_curve),
            },
            FieldInfoData {
                name: "UpCurve",
                name_hash: 2426881463,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(StaticCameraData, up_curve),
            },
            FieldInfoData {
                name: "DownCurve",
                name_hash: 3691425472,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(StaticCameraData, down_curve),
            },
            FieldInfoData {
                name: "MergeLeftAndRightCurves",
                name_hash: 3823308649,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, merge_left_and_right_curves),
            },
            FieldInfoData {
                name: "MergeUpAndDownCurves",
                name_hash: 328806277,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, merge_up_and_down_curves),
            },
            FieldInfoData {
                name: "MirrorHorizontalCurves",
                name_hash: 3434506758,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, mirror_horizontal_curves),
            },
            FieldInfoData {
                name: "MirrorVerticalCurves",
                name_hash: 529936810,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, mirror_vertical_curves),
            },
            FieldInfoData {
                name: "LoosePartPhysics",
                name_hash: 4017113603,
                flags: MemberInfoFlags::new(144),
                field_type: "CameraLoosePartPhysicsData-Array",
                rust_offset: offset_of!(StaticCameraData, loose_part_physics),
            },
            FieldInfoData {
                name: "LeftYawAngle",
                name_hash: 2425251312,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, left_yaw_angle),
            },
            FieldInfoData {
                name: "RightYawAngle",
                name_hash: 2366463371,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, right_yaw_angle),
            },
            FieldInfoData {
                name: "UpPitchAngle",
                name_hash: 1050781767,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, up_pitch_angle),
            },
            FieldInfoData {
                name: "DownPitchAngle",
                name_hash: 2129496336,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, down_pitch_angle),
            },
            FieldInfoData {
                name: "AverageFilterFrames",
                name_hash: 2544157096,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StaticCameraData, average_filter_frames),
            },
            FieldInfoData {
                name: "YawInputAction",
                name_hash: 1432982466,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StaticCameraData, yaw_input_action),
            },
            FieldInfoData {
                name: "PitchInputAction",
                name_hash: 4136660683,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StaticCameraData, pitch_input_action),
            },
            FieldInfoData {
                name: "AccumulateInput",
                name_hash: 922985347,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, accumulate_input),
            },
            FieldInfoData {
                name: "ResetAccumulatedInputOnViewChange",
                name_hash: 986552120,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, reset_accumulated_input_on_view_change),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiencyYaw",
                name_hash: 1888576688,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, world_space_lock_efficiency_yaw),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiencyPitch",
                name_hash: 3673803289,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, world_space_lock_efficiency_pitch),
            },
            FieldInfoData {
                name: "YawSensitivityNonZoomed",
                name_hash: 4254658238,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, yaw_sensitivity_non_zoomed),
            },
            FieldInfoData {
                name: "YawSensitivityZoomed",
                name_hash: 682537073,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, yaw_sensitivity_zoomed),
            },
            FieldInfoData {
                name: "PitchSensitivityNonZoomed",
                name_hash: 508245719,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, pitch_sensitivity_non_zoomed),
            },
            FieldInfoData {
                name: "PitchSensitivityZoomed",
                name_hash: 1497662520,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, pitch_sensitivity_zoomed),
            },
        ],
    }),
    array_type: Some(STATICCAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICCAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICCAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticCameraData-Array",
    name_hash: 3092698336,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ChaseCameraData {
    pub _glacier_base: super::gameplay_sim::TargetCameraData,
    pub target_offset: super::core::Vec3,
    pub target_rotation_offset: f32,
    pub keep_target_pitch: bool,
    pub to_wanted_position_scale: super::core::Vec3,
    pub max_view_rotation_angle_deg: f32,
    pub wanted_angle_deg: f32,
    pub wanted_distance: f32,
    pub max_distance: f32,
    pub snap_distance: f32,
    pub reset_distance: f32,
    pub force_field_radius: f32,
    pub collision_radius: f32,
    pub force_field_force_scale: f32,
    pub away_from_target_force_scale: f32,
    pub velocity_drag: f32,
    pub max_velocity: f32,
    pub pill_minimum_collision_radius: f32,
    pub pill_maximum_collision_radius: f32,
    pub pill_minimum_collision_length: f32,
    pub pill_expand_size_speed_acceleration: f32,
    pub look_distance_scale: f32,
    pub look_distance_in_front_of_target: f32,
    pub should_roll_with_target: bool,
    pub inherit_target_velocity: bool,
    pub update_rate: u32,
    pub bypass_chase_calculations: bool,
    pub has_collision_against_target: bool,
    pub ignore_collision_in_chase_calculations: bool,
    pub has_collision: bool,
}

pub trait ChaseCameraDataTrait: super::gameplay_sim::TargetCameraDataTrait {
    fn target_offset(&self) -> &super::core::Vec3;
    fn target_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn target_rotation_offset(&self) -> &f32;
    fn target_rotation_offset_mut(&mut self) -> &mut f32;
    fn keep_target_pitch(&self) -> &bool;
    fn keep_target_pitch_mut(&mut self) -> &mut bool;
    fn to_wanted_position_scale(&self) -> &super::core::Vec3;
    fn to_wanted_position_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn max_view_rotation_angle_deg(&self) -> &f32;
    fn max_view_rotation_angle_deg_mut(&mut self) -> &mut f32;
    fn wanted_angle_deg(&self) -> &f32;
    fn wanted_angle_deg_mut(&mut self) -> &mut f32;
    fn wanted_distance(&self) -> &f32;
    fn wanted_distance_mut(&mut self) -> &mut f32;
    fn max_distance(&self) -> &f32;
    fn max_distance_mut(&mut self) -> &mut f32;
    fn snap_distance(&self) -> &f32;
    fn snap_distance_mut(&mut self) -> &mut f32;
    fn reset_distance(&self) -> &f32;
    fn reset_distance_mut(&mut self) -> &mut f32;
    fn force_field_radius(&self) -> &f32;
    fn force_field_radius_mut(&mut self) -> &mut f32;
    fn collision_radius(&self) -> &f32;
    fn collision_radius_mut(&mut self) -> &mut f32;
    fn force_field_force_scale(&self) -> &f32;
    fn force_field_force_scale_mut(&mut self) -> &mut f32;
    fn away_from_target_force_scale(&self) -> &f32;
    fn away_from_target_force_scale_mut(&mut self) -> &mut f32;
    fn velocity_drag(&self) -> &f32;
    fn velocity_drag_mut(&mut self) -> &mut f32;
    fn max_velocity(&self) -> &f32;
    fn max_velocity_mut(&mut self) -> &mut f32;
    fn pill_minimum_collision_radius(&self) -> &f32;
    fn pill_minimum_collision_radius_mut(&mut self) -> &mut f32;
    fn pill_maximum_collision_radius(&self) -> &f32;
    fn pill_maximum_collision_radius_mut(&mut self) -> &mut f32;
    fn pill_minimum_collision_length(&self) -> &f32;
    fn pill_minimum_collision_length_mut(&mut self) -> &mut f32;
    fn pill_expand_size_speed_acceleration(&self) -> &f32;
    fn pill_expand_size_speed_acceleration_mut(&mut self) -> &mut f32;
    fn look_distance_scale(&self) -> &f32;
    fn look_distance_scale_mut(&mut self) -> &mut f32;
    fn look_distance_in_front_of_target(&self) -> &f32;
    fn look_distance_in_front_of_target_mut(&mut self) -> &mut f32;
    fn should_roll_with_target(&self) -> &bool;
    fn should_roll_with_target_mut(&mut self) -> &mut bool;
    fn inherit_target_velocity(&self) -> &bool;
    fn inherit_target_velocity_mut(&mut self) -> &mut bool;
    fn update_rate(&self) -> &u32;
    fn update_rate_mut(&mut self) -> &mut u32;
    fn bypass_chase_calculations(&self) -> &bool;
    fn bypass_chase_calculations_mut(&mut self) -> &mut bool;
    fn has_collision_against_target(&self) -> &bool;
    fn has_collision_against_target_mut(&mut self) -> &mut bool;
    fn ignore_collision_in_chase_calculations(&self) -> &bool;
    fn ignore_collision_in_chase_calculations_mut(&mut self) -> &mut bool;
    fn has_collision(&self) -> &bool;
    fn has_collision_mut(&mut self) -> &mut bool;
}

impl ChaseCameraDataTrait for ChaseCameraData {
    fn target_offset(&self) -> &super::core::Vec3 {
        &self.target_offset
    }
    fn target_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_offset
    }
    fn target_rotation_offset(&self) -> &f32 {
        &self.target_rotation_offset
    }
    fn target_rotation_offset_mut(&mut self) -> &mut f32 {
        &mut self.target_rotation_offset
    }
    fn keep_target_pitch(&self) -> &bool {
        &self.keep_target_pitch
    }
    fn keep_target_pitch_mut(&mut self) -> &mut bool {
        &mut self.keep_target_pitch
    }
    fn to_wanted_position_scale(&self) -> &super::core::Vec3 {
        &self.to_wanted_position_scale
    }
    fn to_wanted_position_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.to_wanted_position_scale
    }
    fn max_view_rotation_angle_deg(&self) -> &f32 {
        &self.max_view_rotation_angle_deg
    }
    fn max_view_rotation_angle_deg_mut(&mut self) -> &mut f32 {
        &mut self.max_view_rotation_angle_deg
    }
    fn wanted_angle_deg(&self) -> &f32 {
        &self.wanted_angle_deg
    }
    fn wanted_angle_deg_mut(&mut self) -> &mut f32 {
        &mut self.wanted_angle_deg
    }
    fn wanted_distance(&self) -> &f32 {
        &self.wanted_distance
    }
    fn wanted_distance_mut(&mut self) -> &mut f32 {
        &mut self.wanted_distance
    }
    fn max_distance(&self) -> &f32 {
        &self.max_distance
    }
    fn max_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_distance
    }
    fn snap_distance(&self) -> &f32 {
        &self.snap_distance
    }
    fn snap_distance_mut(&mut self) -> &mut f32 {
        &mut self.snap_distance
    }
    fn reset_distance(&self) -> &f32 {
        &self.reset_distance
    }
    fn reset_distance_mut(&mut self) -> &mut f32 {
        &mut self.reset_distance
    }
    fn force_field_radius(&self) -> &f32 {
        &self.force_field_radius
    }
    fn force_field_radius_mut(&mut self) -> &mut f32 {
        &mut self.force_field_radius
    }
    fn collision_radius(&self) -> &f32 {
        &self.collision_radius
    }
    fn collision_radius_mut(&mut self) -> &mut f32 {
        &mut self.collision_radius
    }
    fn force_field_force_scale(&self) -> &f32 {
        &self.force_field_force_scale
    }
    fn force_field_force_scale_mut(&mut self) -> &mut f32 {
        &mut self.force_field_force_scale
    }
    fn away_from_target_force_scale(&self) -> &f32 {
        &self.away_from_target_force_scale
    }
    fn away_from_target_force_scale_mut(&mut self) -> &mut f32 {
        &mut self.away_from_target_force_scale
    }
    fn velocity_drag(&self) -> &f32 {
        &self.velocity_drag
    }
    fn velocity_drag_mut(&mut self) -> &mut f32 {
        &mut self.velocity_drag
    }
    fn max_velocity(&self) -> &f32 {
        &self.max_velocity
    }
    fn max_velocity_mut(&mut self) -> &mut f32 {
        &mut self.max_velocity
    }
    fn pill_minimum_collision_radius(&self) -> &f32 {
        &self.pill_minimum_collision_radius
    }
    fn pill_minimum_collision_radius_mut(&mut self) -> &mut f32 {
        &mut self.pill_minimum_collision_radius
    }
    fn pill_maximum_collision_radius(&self) -> &f32 {
        &self.pill_maximum_collision_radius
    }
    fn pill_maximum_collision_radius_mut(&mut self) -> &mut f32 {
        &mut self.pill_maximum_collision_radius
    }
    fn pill_minimum_collision_length(&self) -> &f32 {
        &self.pill_minimum_collision_length
    }
    fn pill_minimum_collision_length_mut(&mut self) -> &mut f32 {
        &mut self.pill_minimum_collision_length
    }
    fn pill_expand_size_speed_acceleration(&self) -> &f32 {
        &self.pill_expand_size_speed_acceleration
    }
    fn pill_expand_size_speed_acceleration_mut(&mut self) -> &mut f32 {
        &mut self.pill_expand_size_speed_acceleration
    }
    fn look_distance_scale(&self) -> &f32 {
        &self.look_distance_scale
    }
    fn look_distance_scale_mut(&mut self) -> &mut f32 {
        &mut self.look_distance_scale
    }
    fn look_distance_in_front_of_target(&self) -> &f32 {
        &self.look_distance_in_front_of_target
    }
    fn look_distance_in_front_of_target_mut(&mut self) -> &mut f32 {
        &mut self.look_distance_in_front_of_target
    }
    fn should_roll_with_target(&self) -> &bool {
        &self.should_roll_with_target
    }
    fn should_roll_with_target_mut(&mut self) -> &mut bool {
        &mut self.should_roll_with_target
    }
    fn inherit_target_velocity(&self) -> &bool {
        &self.inherit_target_velocity
    }
    fn inherit_target_velocity_mut(&mut self) -> &mut bool {
        &mut self.inherit_target_velocity
    }
    fn update_rate(&self) -> &u32 {
        &self.update_rate
    }
    fn update_rate_mut(&mut self) -> &mut u32 {
        &mut self.update_rate
    }
    fn bypass_chase_calculations(&self) -> &bool {
        &self.bypass_chase_calculations
    }
    fn bypass_chase_calculations_mut(&mut self) -> &mut bool {
        &mut self.bypass_chase_calculations
    }
    fn has_collision_against_target(&self) -> &bool {
        &self.has_collision_against_target
    }
    fn has_collision_against_target_mut(&mut self) -> &mut bool {
        &mut self.has_collision_against_target
    }
    fn ignore_collision_in_chase_calculations(&self) -> &bool {
        &self.ignore_collision_in_chase_calculations
    }
    fn ignore_collision_in_chase_calculations_mut(&mut self) -> &mut bool {
        &mut self.ignore_collision_in_chase_calculations
    }
    fn has_collision(&self) -> &bool {
        &self.has_collision
    }
    fn has_collision_mut(&mut self) -> &mut bool {
        &mut self.has_collision
    }
}

impl super::gameplay_sim::TargetCameraDataTrait for ChaseCameraData {
    fn hud(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        self._glacier_base.hud()
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        self._glacier_base.hud_mut()
    }
    fn use_transform_space_hierarchy(&self) -> &bool {
        self._glacier_base.use_transform_space_hierarchy()
    }
    fn use_transform_space_hierarchy_mut(&mut self) -> &mut bool {
        self._glacier_base.use_transform_space_hierarchy_mut()
    }
}

impl super::gameplay_sim::CameraDataTrait for ChaseCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for ChaseCameraData {
}

impl super::core::DataBusPeerTrait for ChaseCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ChaseCameraData {
}

impl super::core::DataContainerTrait for ChaseCameraData {
}

pub static CHASECAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChaseCameraData",
    name_hash: 2757126096,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TARGETCAMERADATA_TYPE_INFO),
        super_class_offset: offset_of!(ChaseCameraData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChaseCameraData as Default>::default())),
            create_boxed: || Box::new(<ChaseCameraData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TargetOffset",
                name_hash: 1634518457,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ChaseCameraData, target_offset),
            },
            FieldInfoData {
                name: "TargetRotationOffset",
                name_hash: 1618502637,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, target_rotation_offset),
            },
            FieldInfoData {
                name: "KeepTargetPitch",
                name_hash: 3248397385,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, keep_target_pitch),
            },
            FieldInfoData {
                name: "ToWantedPositionScale",
                name_hash: 2553064018,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ChaseCameraData, to_wanted_position_scale),
            },
            FieldInfoData {
                name: "MaxViewRotationAngleDeg",
                name_hash: 389369231,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, max_view_rotation_angle_deg),
            },
            FieldInfoData {
                name: "WantedAngleDeg",
                name_hash: 3363627311,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, wanted_angle_deg),
            },
            FieldInfoData {
                name: "WantedDistance",
                name_hash: 543265451,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, wanted_distance),
            },
            FieldInfoData {
                name: "MaxDistance",
                name_hash: 3520454034,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, max_distance),
            },
            FieldInfoData {
                name: "SnapDistance",
                name_hash: 2841439402,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, snap_distance),
            },
            FieldInfoData {
                name: "ResetDistance",
                name_hash: 601574707,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, reset_distance),
            },
            FieldInfoData {
                name: "ForceFieldRadius",
                name_hash: 1763697730,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, force_field_radius),
            },
            FieldInfoData {
                name: "CollisionRadius",
                name_hash: 1874505603,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, collision_radius),
            },
            FieldInfoData {
                name: "ForceFieldForceScale",
                name_hash: 3317981151,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, force_field_force_scale),
            },
            FieldInfoData {
                name: "AwayFromTargetForceScale",
                name_hash: 2623914665,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, away_from_target_force_scale),
            },
            FieldInfoData {
                name: "VelocityDrag",
                name_hash: 58335362,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, velocity_drag),
            },
            FieldInfoData {
                name: "MaxVelocity",
                name_hash: 81127366,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, max_velocity),
            },
            FieldInfoData {
                name: "PillMinimumCollisionRadius",
                name_hash: 804419372,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, pill_minimum_collision_radius),
            },
            FieldInfoData {
                name: "PillMaximumCollisionRadius",
                name_hash: 3536568050,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, pill_maximum_collision_radius),
            },
            FieldInfoData {
                name: "PillMinimumCollisionLength",
                name_hash: 1361574600,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, pill_minimum_collision_length),
            },
            FieldInfoData {
                name: "PillExpandSizeSpeedAcceleration",
                name_hash: 2985104634,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, pill_expand_size_speed_acceleration),
            },
            FieldInfoData {
                name: "LookDistanceScale",
                name_hash: 4112376025,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, look_distance_scale),
            },
            FieldInfoData {
                name: "LookDistanceInFrontOfTarget",
                name_hash: 4045244511,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, look_distance_in_front_of_target),
            },
            FieldInfoData {
                name: "ShouldRollWithTarget",
                name_hash: 2421688066,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, should_roll_with_target),
            },
            FieldInfoData {
                name: "InheritTargetVelocity",
                name_hash: 219688038,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, inherit_target_velocity),
            },
            FieldInfoData {
                name: "UpdateRate",
                name_hash: 2270996982,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ChaseCameraData, update_rate),
            },
            FieldInfoData {
                name: "BypassChaseCalculations",
                name_hash: 2070186217,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, bypass_chase_calculations),
            },
            FieldInfoData {
                name: "HasCollisionAgainstTarget",
                name_hash: 2034543639,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, has_collision_against_target),
            },
            FieldInfoData {
                name: "IgnoreCollisionInChaseCalculations",
                name_hash: 2935161858,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, ignore_collision_in_chase_calculations),
            },
            FieldInfoData {
                name: "HasCollision",
                name_hash: 2369733505,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, has_collision),
            },
        ],
    }),
    array_type: Some(CHASECAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChaseCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        CHASECAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHASECAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChaseCameraData-Array",
    name_hash: 3018499684,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChaseCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FPSCameraData {
    pub _glacier_base: super::gameplay_sim::TargetCameraData,
    pub turn_effect_settings: TurnEffectData,
    pub blur_effect_settings: BlurEffectData,
    pub f_o_v: f32,
}

pub trait FPSCameraDataTrait: super::gameplay_sim::TargetCameraDataTrait {
    fn turn_effect_settings(&self) -> &TurnEffectData;
    fn turn_effect_settings_mut(&mut self) -> &mut TurnEffectData;
    fn blur_effect_settings(&self) -> &BlurEffectData;
    fn blur_effect_settings_mut(&mut self) -> &mut BlurEffectData;
    fn f_o_v(&self) -> &f32;
    fn f_o_v_mut(&mut self) -> &mut f32;
}

impl FPSCameraDataTrait for FPSCameraData {
    fn turn_effect_settings(&self) -> &TurnEffectData {
        &self.turn_effect_settings
    }
    fn turn_effect_settings_mut(&mut self) -> &mut TurnEffectData {
        &mut self.turn_effect_settings
    }
    fn blur_effect_settings(&self) -> &BlurEffectData {
        &self.blur_effect_settings
    }
    fn blur_effect_settings_mut(&mut self) -> &mut BlurEffectData {
        &mut self.blur_effect_settings
    }
    fn f_o_v(&self) -> &f32 {
        &self.f_o_v
    }
    fn f_o_v_mut(&mut self) -> &mut f32 {
        &mut self.f_o_v
    }
}

impl super::gameplay_sim::TargetCameraDataTrait for FPSCameraData {
    fn hud(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        self._glacier_base.hud()
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::HudData */>> {
        self._glacier_base.hud_mut()
    }
    fn use_transform_space_hierarchy(&self) -> &bool {
        self._glacier_base.use_transform_space_hierarchy()
    }
    fn use_transform_space_hierarchy_mut(&mut self) -> &mut bool {
        self._glacier_base.use_transform_space_hierarchy_mut()
    }
}

impl super::gameplay_sim::CameraDataTrait for FPSCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::CameraTransitionEffectDataPack */> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for FPSCameraData {
}

impl super::core::DataBusPeerTrait for FPSCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FPSCameraData {
}

impl super::core::DataContainerTrait for FPSCameraData {
}

pub static FPSCAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FPSCameraData",
    name_hash: 640525609,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TARGETCAMERADATA_TYPE_INFO),
        super_class_offset: offset_of!(FPSCameraData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FPSCameraData as Default>::default())),
            create_boxed: || Box::new(<FPSCameraData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TurnEffectSettings",
                name_hash: 76337482,
                flags: MemberInfoFlags::new(0),
                field_type: "TurnEffectData",
                rust_offset: offset_of!(FPSCameraData, turn_effect_settings),
            },
            FieldInfoData {
                name: "BlurEffectSettings",
                name_hash: 2488763390,
                flags: MemberInfoFlags::new(0),
                field_type: "BlurEffectData",
                rust_offset: offset_of!(FPSCameraData, blur_effect_settings),
            },
            FieldInfoData {
                name: "FOV",
                name_hash: 193442778,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FPSCameraData, f_o_v),
            },
        ],
    }),
    array_type: Some(FPSCAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FPSCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        FPSCAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FPSCAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FPSCameraData-Array",
    name_hash: 732564381,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FPSCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct HudImpactData {
    pub enable: bool,
    pub min_health: f32,
    pub max_health: f32,
    pub min_time_visible: f32,
    pub max_time_visible: f32,
}

pub trait HudImpactDataTrait: TypeObject {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn min_health(&self) -> &f32;
    fn min_health_mut(&mut self) -> &mut f32;
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn min_time_visible(&self) -> &f32;
    fn min_time_visible_mut(&mut self) -> &mut f32;
    fn max_time_visible(&self) -> &f32;
    fn max_time_visible_mut(&mut self) -> &mut f32;
}

impl HudImpactDataTrait for HudImpactData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn min_health(&self) -> &f32 {
        &self.min_health
    }
    fn min_health_mut(&mut self) -> &mut f32 {
        &mut self.min_health
    }
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn min_time_visible(&self) -> &f32 {
        &self.min_time_visible
    }
    fn min_time_visible_mut(&mut self) -> &mut f32 {
        &mut self.min_time_visible
    }
    fn max_time_visible(&self) -> &f32 {
        &self.max_time_visible
    }
    fn max_time_visible_mut(&mut self) -> &mut f32 {
        &mut self.max_time_visible
    }
}

pub static HUDIMPACTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HudImpactData",
    name_hash: 1984360526,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HudImpactData as Default>::default())),
            create_boxed: || Box::new(<HudImpactData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                name_hash: 2342790116,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HudImpactData, enable),
            },
            FieldInfoData {
                name: "MinHealth",
                name_hash: 3036033555,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HudImpactData, min_health),
            },
            FieldInfoData {
                name: "MaxHealth",
                name_hash: 1153188365,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HudImpactData, max_health),
            },
            FieldInfoData {
                name: "MinTimeVisible",
                name_hash: 3316010964,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HudImpactData, min_time_visible),
            },
            FieldInfoData {
                name: "MaxTimeVisible",
                name_hash: 3813767306,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HudImpactData, max_time_visible),
            },
        ],
    }),
    array_type: Some(HUDIMPACTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for HudImpactData {
    fn type_info(&self) -> &'static TypeInfo {
        HUDIMPACTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static HUDIMPACTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HudImpactData-Array",
    name_hash: 3584313850,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HudImpactData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BlurEffectData {
    pub dispersion_strength: f32,
    pub dispersion_threshhold: f32,
    pub explosion_strength: f32,
    pub bullet_strength: f32,
    pub explosion_falloff_speed: f32,
    pub bullet_falloff_speed: f32,
}

pub trait BlurEffectDataTrait: TypeObject {
    fn dispersion_strength(&self) -> &f32;
    fn dispersion_strength_mut(&mut self) -> &mut f32;
    fn dispersion_threshhold(&self) -> &f32;
    fn dispersion_threshhold_mut(&mut self) -> &mut f32;
    fn explosion_strength(&self) -> &f32;
    fn explosion_strength_mut(&mut self) -> &mut f32;
    fn bullet_strength(&self) -> &f32;
    fn bullet_strength_mut(&mut self) -> &mut f32;
    fn explosion_falloff_speed(&self) -> &f32;
    fn explosion_falloff_speed_mut(&mut self) -> &mut f32;
    fn bullet_falloff_speed(&self) -> &f32;
    fn bullet_falloff_speed_mut(&mut self) -> &mut f32;
}

impl BlurEffectDataTrait for BlurEffectData {
    fn dispersion_strength(&self) -> &f32 {
        &self.dispersion_strength
    }
    fn dispersion_strength_mut(&mut self) -> &mut f32 {
        &mut self.dispersion_strength
    }
    fn dispersion_threshhold(&self) -> &f32 {
        &self.dispersion_threshhold
    }
    fn dispersion_threshhold_mut(&mut self) -> &mut f32 {
        &mut self.dispersion_threshhold
    }
    fn explosion_strength(&self) -> &f32 {
        &self.explosion_strength
    }
    fn explosion_strength_mut(&mut self) -> &mut f32 {
        &mut self.explosion_strength
    }
    fn bullet_strength(&self) -> &f32 {
        &self.bullet_strength
    }
    fn bullet_strength_mut(&mut self) -> &mut f32 {
        &mut self.bullet_strength
    }
    fn explosion_falloff_speed(&self) -> &f32 {
        &self.explosion_falloff_speed
    }
    fn explosion_falloff_speed_mut(&mut self) -> &mut f32 {
        &mut self.explosion_falloff_speed
    }
    fn bullet_falloff_speed(&self) -> &f32 {
        &self.bullet_falloff_speed
    }
    fn bullet_falloff_speed_mut(&mut self) -> &mut f32 {
        &mut self.bullet_falloff_speed
    }
}

pub static BLUREFFECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlurEffectData",
    name_hash: 370909771,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BlurEffectData as Default>::default())),
            create_boxed: || Box::new(<BlurEffectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DispersionStrength",
                name_hash: 267790946,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, dispersion_strength),
            },
            FieldInfoData {
                name: "DispersionThreshhold",
                name_hash: 2849266168,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, dispersion_threshhold),
            },
            FieldInfoData {
                name: "ExplosionStrength",
                name_hash: 146990261,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, explosion_strength),
            },
            FieldInfoData {
                name: "BulletStrength",
                name_hash: 1725135046,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, bullet_strength),
            },
            FieldInfoData {
                name: "ExplosionFalloffSpeed",
                name_hash: 676135103,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, explosion_falloff_speed),
            },
            FieldInfoData {
                name: "BulletFalloffSpeed",
                name_hash: 252733900,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, bullet_falloff_speed),
            },
        ],
    }),
    array_type: Some(BLUREFFECTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BlurEffectData {
    fn type_info(&self) -> &'static TypeInfo {
        BLUREFFECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BLUREFFECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlurEffectData-Array",
    name_hash: 2335007103,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BlurEffectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TurnEffectData {
    pub max_roll_angle: f32,
    pub max_pitch_angle: f32,
    pub yaw_velocity_threshhold: f32,
    pub velocity_threshhold: f32,
    pub safe_time: f32,
    pub begin_time: f32,
    pub hold_time: f32,
    pub end_time: f32,
}

pub trait TurnEffectDataTrait: TypeObject {
    fn max_roll_angle(&self) -> &f32;
    fn max_roll_angle_mut(&mut self) -> &mut f32;
    fn max_pitch_angle(&self) -> &f32;
    fn max_pitch_angle_mut(&mut self) -> &mut f32;
    fn yaw_velocity_threshhold(&self) -> &f32;
    fn yaw_velocity_threshhold_mut(&mut self) -> &mut f32;
    fn velocity_threshhold(&self) -> &f32;
    fn velocity_threshhold_mut(&mut self) -> &mut f32;
    fn safe_time(&self) -> &f32;
    fn safe_time_mut(&mut self) -> &mut f32;
    fn begin_time(&self) -> &f32;
    fn begin_time_mut(&mut self) -> &mut f32;
    fn hold_time(&self) -> &f32;
    fn hold_time_mut(&mut self) -> &mut f32;
    fn end_time(&self) -> &f32;
    fn end_time_mut(&mut self) -> &mut f32;
}

impl TurnEffectDataTrait for TurnEffectData {
    fn max_roll_angle(&self) -> &f32 {
        &self.max_roll_angle
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_roll_angle
    }
    fn max_pitch_angle(&self) -> &f32 {
        &self.max_pitch_angle
    }
    fn max_pitch_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_pitch_angle
    }
    fn yaw_velocity_threshhold(&self) -> &f32 {
        &self.yaw_velocity_threshhold
    }
    fn yaw_velocity_threshhold_mut(&mut self) -> &mut f32 {
        &mut self.yaw_velocity_threshhold
    }
    fn velocity_threshhold(&self) -> &f32 {
        &self.velocity_threshhold
    }
    fn velocity_threshhold_mut(&mut self) -> &mut f32 {
        &mut self.velocity_threshhold
    }
    fn safe_time(&self) -> &f32 {
        &self.safe_time
    }
    fn safe_time_mut(&mut self) -> &mut f32 {
        &mut self.safe_time
    }
    fn begin_time(&self) -> &f32 {
        &self.begin_time
    }
    fn begin_time_mut(&mut self) -> &mut f32 {
        &mut self.begin_time
    }
    fn hold_time(&self) -> &f32 {
        &self.hold_time
    }
    fn hold_time_mut(&mut self) -> &mut f32 {
        &mut self.hold_time
    }
    fn end_time(&self) -> &f32 {
        &self.end_time
    }
    fn end_time_mut(&mut self) -> &mut f32 {
        &mut self.end_time
    }
}

pub static TURNEFFECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TurnEffectData",
    name_hash: 874193855,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TurnEffectData as Default>::default())),
            create_boxed: || Box::new(<TurnEffectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MaxRollAngle",
                name_hash: 863732973,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, max_roll_angle),
            },
            FieldInfoData {
                name: "MaxPitchAngle",
                name_hash: 1228368214,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, max_pitch_angle),
            },
            FieldInfoData {
                name: "YawVelocityThreshhold",
                name_hash: 3352651138,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, yaw_velocity_threshhold),
            },
            FieldInfoData {
                name: "VelocityThreshhold",
                name_hash: 2190993229,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, velocity_threshhold),
            },
            FieldInfoData {
                name: "SafeTime",
                name_hash: 1593077185,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, safe_time),
            },
            FieldInfoData {
                name: "BeginTime",
                name_hash: 900554935,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, begin_time),
            },
            FieldInfoData {
                name: "HoldTime",
                name_hash: 3936329343,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, hold_time),
            },
            FieldInfoData {
                name: "EndTime",
                name_hash: 4286530879,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, end_time),
            },
        ],
    }),
    array_type: Some(TURNEFFECTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TurnEffectData {
    fn type_info(&self) -> &'static TypeInfo {
        TURNEFFECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TURNEFFECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TurnEffectData-Array",
    name_hash: 1768380683,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TurnEffectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraSineCurveData {
    pub frequency: f32,
    pub amplitude: f32,
    pub phase_shift: f32,
}

pub trait CameraSineCurveDataTrait: TypeObject {
    fn frequency(&self) -> &f32;
    fn frequency_mut(&mut self) -> &mut f32;
    fn amplitude(&self) -> &f32;
    fn amplitude_mut(&mut self) -> &mut f32;
    fn phase_shift(&self) -> &f32;
    fn phase_shift_mut(&mut self) -> &mut f32;
}

impl CameraSineCurveDataTrait for CameraSineCurveData {
    fn frequency(&self) -> &f32 {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut f32 {
        &mut self.frequency
    }
    fn amplitude(&self) -> &f32 {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut f32 {
        &mut self.amplitude
    }
    fn phase_shift(&self) -> &f32 {
        &self.phase_shift
    }
    fn phase_shift_mut(&mut self) -> &mut f32 {
        &mut self.phase_shift
    }
}

pub static CAMERASINECURVEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraSineCurveData",
    name_hash: 1030487882,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraSineCurveData as Default>::default())),
            create_boxed: || Box::new(<CameraSineCurveData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Frequency",
                name_hash: 4112821953,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSineCurveData, frequency),
            },
            FieldInfoData {
                name: "Amplitude",
                name_hash: 698564572,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSineCurveData, amplitude),
            },
            FieldInfoData {
                name: "PhaseShift",
                name_hash: 3261548234,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSineCurveData, phase_shift),
            },
        ],
    }),
    array_type: Some(CAMERASINECURVEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CameraSineCurveData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERASINECURVEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERASINECURVEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraSineCurveData-Array",
    name_hash: 752413438,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraSineCurveData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BuildConfigFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait BuildConfigFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl BuildConfigFilterEntityDataTrait for BuildConfigFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for BuildConfigFilterEntityData {
}

impl super::entity::GameObjectDataTrait for BuildConfigFilterEntityData {
}

impl super::core::DataBusPeerTrait for BuildConfigFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BuildConfigFilterEntityData {
}

impl super::core::DataContainerTrait for BuildConfigFilterEntityData {
}

pub static BUILDCONFIGFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuildConfigFilterEntityData",
    name_hash: 1174429458,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BuildConfigFilterEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BuildConfigFilterEntityData as Default>::default())),
            create_boxed: || Box::new(<BuildConfigFilterEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BuildConfigFilterEntityData, realm),
            },
        ],
    }),
    array_type: Some(BUILDCONFIGFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BuildConfigFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BUILDCONFIGFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BUILDCONFIGFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuildConfigFilterEntityData-Array",
    name_hash: 1885947430,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BuildConfigFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterAsset {
    pub _glacier_base: CharacterBlueprint,
}

pub trait CharacterAssetTrait: CharacterBlueprintTrait {
}

impl CharacterAssetTrait for CharacterAsset {
}

impl CharacterBlueprintTrait for CharacterAsset {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl super::entity::ObjectBlueprintTrait for CharacterAsset {
    fn object(&self) -> &Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for CharacterAsset {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for CharacterAsset {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for CharacterAsset {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for CharacterAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterAsset {
}

pub static CHARACTERASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterAsset",
    name_hash: 2805666860,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(CharacterAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterAsset as Default>::default())),
            create_boxed: || Box::new(<CharacterAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterAsset {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterAsset-Array",
    name_hash: 1329013656,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleAsset {
    pub _glacier_base: VehicleBlueprint,
}

pub trait VehicleAssetTrait: VehicleBlueprintTrait {
}

impl VehicleAssetTrait for VehicleAsset {
}

impl VehicleBlueprintTrait for VehicleAsset {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl super::entity::ObjectBlueprintTrait for VehicleAsset {
    fn object(&self) -> &Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for VehicleAsset {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for VehicleAsset {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for VehicleAsset {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for VehicleAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VehicleAsset {
}

pub static VEHICLEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleAsset",
    name_hash: 514079437,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VEHICLEBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(VehicleAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleAsset as Default>::default())),
            create_boxed: || Box::new(<VehicleAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEHICLEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleAsset-Array",
    name_hash: 1920585465,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
    pub time_delta_type: super::entity::TimeDeltaType,
}

pub trait CharacterBlueprintTrait: super::entity::ObjectBlueprintTrait {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType;
}

impl CharacterBlueprintTrait for CharacterBlueprint {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl super::entity::ObjectBlueprintTrait for CharacterBlueprint {
    fn object(&self) -> &Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for CharacterBlueprint {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for CharacterBlueprint {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for CharacterBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for CharacterBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterBlueprint {
}

pub static CHARACTERBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterBlueprint",
    name_hash: 1806128211,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(CharacterBlueprint, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterBlueprint as Default>::default())),
            create_boxed: || Box::new(<CharacterBlueprint as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TimeDeltaType",
                name_hash: 1100516816,
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(CharacterBlueprint, time_delta_type),
            },
        ],
    }),
    array_type: Some(CHARACTERBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterBlueprint-Array",
    name_hash: 675938151,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
    pub time_delta_type: super::entity::TimeDeltaType,
}

pub trait VehicleBlueprintTrait: super::entity::ObjectBlueprintTrait {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType;
}

impl VehicleBlueprintTrait for VehicleBlueprint {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl super::entity::ObjectBlueprintTrait for VehicleBlueprint {
    fn object(&self) -> &Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for VehicleBlueprint {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for VehicleBlueprint {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for VehicleBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for VehicleBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VehicleBlueprint {
}

pub static VEHICLEBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleBlueprint",
    name_hash: 6378290,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(VehicleBlueprint, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleBlueprint as Default>::default())),
            create_boxed: || Box::new(<VehicleBlueprint as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TimeDeltaType",
                name_hash: 1100516816,
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(VehicleBlueprint, time_delta_type),
            },
        ],
    }),
    array_type: Some(VEHICLEBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleBlueprint-Array",
    name_hash: 131914118,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BlueprintBundleAnimationStatusEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub stream_realm: super::entity::StreamRealm,
    pub bundle_name: String,
}

pub trait BlueprintBundleAnimationStatusEntityDataTrait: super::entity::EntityDataTrait {
    fn stream_realm(&self) -> &super::entity::StreamRealm;
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm;
    fn bundle_name(&self) -> &String;
    fn bundle_name_mut(&mut self) -> &mut String;
}

impl BlueprintBundleAnimationStatusEntityDataTrait for BlueprintBundleAnimationStatusEntityData {
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        &self.stream_realm
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        &mut self.stream_realm
    }
    fn bundle_name(&self) -> &String {
        &self.bundle_name
    }
    fn bundle_name_mut(&mut self) -> &mut String {
        &mut self.bundle_name
    }
}

impl super::entity::EntityDataTrait for BlueprintBundleAnimationStatusEntityData {
}

impl super::entity::GameObjectDataTrait for BlueprintBundleAnimationStatusEntityData {
}

impl super::core::DataBusPeerTrait for BlueprintBundleAnimationStatusEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BlueprintBundleAnimationStatusEntityData {
}

impl super::core::DataContainerTrait for BlueprintBundleAnimationStatusEntityData {
}

pub static BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlueprintBundleAnimationStatusEntityData",
    name_hash: 1622604247,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BlueprintBundleAnimationStatusEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BlueprintBundleAnimationStatusEntityData as Default>::default())),
            create_boxed: || Box::new(<BlueprintBundleAnimationStatusEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StreamRealm",
                name_hash: 1844114478,
                flags: MemberInfoFlags::new(0),
                field_type: "StreamRealm",
                rust_offset: offset_of!(BlueprintBundleAnimationStatusEntityData, stream_realm),
            },
            FieldInfoData {
                name: "BundleName",
                name_hash: 461157046,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BlueprintBundleAnimationStatusEntityData, bundle_name),
            },
        ],
    }),
    array_type: Some(BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BlueprintBundleAnimationStatusEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlueprintBundleAnimationStatusEntityData-Array",
    name_hash: 1411347171,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BlueprintBundleAnimationStatusEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BangerHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait BangerHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl BangerHealthComponentDataTrait for BangerHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for BangerHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for BangerHealthComponentData {
}

impl super::entity::ComponentDataTrait for BangerHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BangerHealthComponentData {
}

impl super::core::DataBusPeerTrait for BangerHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BangerHealthComponentData {
}

impl super::core::DataContainerTrait for BangerHealthComponentData {
}

pub static BANGERHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerHealthComponentData",
    name_hash: 1098754843,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(BangerHealthComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BangerHealthComponentData as Default>::default())),
            create_boxed: || Box::new(<BangerHealthComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BANGERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BangerHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BANGERHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BANGERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerHealthComponentData-Array",
    name_hash: 2659582383,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BangerHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BangerPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
    pub impulse_input: super::core::Vec3,
}

pub trait BangerPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
    fn impulse_input(&self) -> &super::core::Vec3;
    fn impulse_input_mut(&mut self) -> &mut super::core::Vec3;
}

impl BangerPhysicsComponentDataTrait for BangerPhysicsComponentData {
    fn impulse_input(&self) -> &super::core::Vec3 {
        &self.impulse_input
    }
    fn impulse_input_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.impulse_input
    }
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for BangerPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for BangerPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for BangerPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BangerPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for BangerPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BangerPhysicsComponentData {
}

impl super::core::DataContainerTrait for BangerPhysicsComponentData {
}

pub static BANGERPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerPhysicsComponentData",
    name_hash: 3579731436,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(BangerPhysicsComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BangerPhysicsComponentData as Default>::default())),
            create_boxed: || Box::new(<BangerPhysicsComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ImpulseInput",
                name_hash: 2611741544,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(BangerPhysicsComponentData, impulse_input),
            },
        ],
    }),
    array_type: Some(BANGERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BangerPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BANGERPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BANGERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerPhysicsComponentData-Array",
    name_hash: 1507245528,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BangerPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BangerEntityData {
    pub _glacier_base: DynamicGamePhysicsEntityData,
    pub mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub explosion: Option<LockedTypeObject /* ExplosionEntityData */>,
    pub time_to_live: f32,
    pub use_variable_network_frequency: bool,
    pub destructible_part_count: u32,
}

pub trait BangerEntityDataTrait: DynamicGamePhysicsEntityDataTrait {
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn explosion(&self) -> &Option<LockedTypeObject /* ExplosionEntityData */>;
    fn explosion_mut(&mut self) -> &mut Option<LockedTypeObject /* ExplosionEntityData */>;
    fn time_to_live(&self) -> &f32;
    fn time_to_live_mut(&mut self) -> &mut f32;
    fn use_variable_network_frequency(&self) -> &bool;
    fn use_variable_network_frequency_mut(&mut self) -> &mut bool;
    fn destructible_part_count(&self) -> &u32;
    fn destructible_part_count_mut(&mut self) -> &mut u32;
}

impl BangerEntityDataTrait for BangerEntityData {
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh
    }
    fn explosion(&self) -> &Option<LockedTypeObject /* ExplosionEntityData */> {
        &self.explosion
    }
    fn explosion_mut(&mut self) -> &mut Option<LockedTypeObject /* ExplosionEntityData */> {
        &mut self.explosion
    }
    fn time_to_live(&self) -> &f32 {
        &self.time_to_live
    }
    fn time_to_live_mut(&mut self) -> &mut f32 {
        &mut self.time_to_live
    }
    fn use_variable_network_frequency(&self) -> &bool {
        &self.use_variable_network_frequency
    }
    fn use_variable_network_frequency_mut(&mut self) -> &mut bool {
        &mut self.use_variable_network_frequency
    }
    fn destructible_part_count(&self) -> &u32 {
        &self.destructible_part_count
    }
    fn destructible_part_count_mut(&mut self) -> &mut u32 {
        &mut self.destructible_part_count
    }
}

impl DynamicGamePhysicsEntityDataTrait for BangerEntityData {
}

impl super::physics::GamePhysicsEntityDataTrait for BangerEntityData {
}

impl super::entity::GameComponentEntityDataTrait for BangerEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for BangerEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for BangerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for BangerEntityData {
}

impl super::entity::GameObjectDataTrait for BangerEntityData {
}

impl super::core::DataBusPeerTrait for BangerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BangerEntityData {
}

impl super::core::DataContainerTrait for BangerEntityData {
}

pub static BANGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerEntityData",
    name_hash: 1869660531,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BangerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BangerEntityData as Default>::default())),
            create_boxed: || Box::new(<BangerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                name_hash: 2088783990,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(BangerEntityData, mesh),
            },
            FieldInfoData {
                name: "Explosion",
                name_hash: 2222171184,
                flags: MemberInfoFlags::new(0),
                field_type: "ExplosionEntityData",
                rust_offset: offset_of!(BangerEntityData, explosion),
            },
            FieldInfoData {
                name: "TimeToLive",
                name_hash: 1571456733,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BangerEntityData, time_to_live),
            },
            FieldInfoData {
                name: "UseVariableNetworkFrequency",
                name_hash: 1010950522,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BangerEntityData, use_variable_network_frequency),
            },
            FieldInfoData {
                name: "DestructiblePartCount",
                name_hash: 539039685,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BangerEntityData, destructible_part_count),
            },
        ],
    }),
    array_type: Some(BANGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BangerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BANGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BANGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerEntityData-Array",
    name_hash: 3899735367,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BangerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WorldRendererSwitchEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait WorldRendererSwitchEntityDataTrait: super::entity::EntityDataTrait {
}

impl WorldRendererSwitchEntityDataTrait for WorldRendererSwitchEntityData {
}

impl super::entity::EntityDataTrait for WorldRendererSwitchEntityData {
}

impl super::entity::GameObjectDataTrait for WorldRendererSwitchEntityData {
}

impl super::core::DataBusPeerTrait for WorldRendererSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WorldRendererSwitchEntityData {
}

impl super::core::DataContainerTrait for WorldRendererSwitchEntityData {
}

pub static WORLDRENDERERSWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldRendererSwitchEntityData",
    name_hash: 2204684291,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(WorldRendererSwitchEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldRendererSwitchEntityData as Default>::default())),
            create_boxed: || Box::new(<WorldRendererSwitchEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDRENDERERSWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldRendererSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDRENDERERSWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDRENDERERSWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldRendererSwitchEntityData-Array",
    name_hash: 2103886519,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WorldRendererSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CannedScenarioEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub canned_anim_binding: CannedAnimationBinding,
    pub animation_entity_space_priority: i32,
    pub always_clear_entity_space_when_in_scenario: bool,
}

pub trait CannedScenarioEntityDataTrait: super::entity::EntityDataTrait {
    fn canned_anim_binding(&self) -> &CannedAnimationBinding;
    fn canned_anim_binding_mut(&mut self) -> &mut CannedAnimationBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn always_clear_entity_space_when_in_scenario(&self) -> &bool;
    fn always_clear_entity_space_when_in_scenario_mut(&mut self) -> &mut bool;
}

impl CannedScenarioEntityDataTrait for CannedScenarioEntityData {
    fn canned_anim_binding(&self) -> &CannedAnimationBinding {
        &self.canned_anim_binding
    }
    fn canned_anim_binding_mut(&mut self) -> &mut CannedAnimationBinding {
        &mut self.canned_anim_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn always_clear_entity_space_when_in_scenario(&self) -> &bool {
        &self.always_clear_entity_space_when_in_scenario
    }
    fn always_clear_entity_space_when_in_scenario_mut(&mut self) -> &mut bool {
        &mut self.always_clear_entity_space_when_in_scenario
    }
}

impl super::entity::EntityDataTrait for CannedScenarioEntityData {
}

impl super::entity::GameObjectDataTrait for CannedScenarioEntityData {
}

impl super::core::DataBusPeerTrait for CannedScenarioEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CannedScenarioEntityData {
}

impl super::core::DataContainerTrait for CannedScenarioEntityData {
}

pub static CANNEDSCENARIOENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CannedScenarioEntityData",
    name_hash: 1182204899,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CannedScenarioEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CannedScenarioEntityData as Default>::default())),
            create_boxed: || Box::new(<CannedScenarioEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "CannedAnimBinding",
                name_hash: 3536770252,
                flags: MemberInfoFlags::new(0),
                field_type: "CannedAnimationBinding",
                rust_offset: offset_of!(CannedScenarioEntityData, canned_anim_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                name_hash: 4041607518,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CannedScenarioEntityData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "AlwaysClearEntitySpaceWhenInScenario",
                name_hash: 4447823,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CannedScenarioEntityData, always_clear_entity_space_when_in_scenario),
            },
        ],
    }),
    array_type: Some(CANNEDSCENARIOENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CannedScenarioEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CANNEDSCENARIOENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CANNEDSCENARIOENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CannedScenarioEntityData-Array",
    name_hash: 2636945367,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CannedScenarioEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WarpAnimationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub warp_binding: WarpAnimationBinding,
    pub animation_entity_space_priority: i32,
    pub bone_to_align: super::entity::GameplayBones,
    pub require_animation_weight: bool,
    pub force_animation_transform: bool,
    pub connect_transform: super::core::LinearTransform,
    pub external_connect_transform: bool,
}

pub trait WarpAnimationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn warp_binding(&self) -> &WarpAnimationBinding;
    fn warp_binding_mut(&mut self) -> &mut WarpAnimationBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn bone_to_align(&self) -> &super::entity::GameplayBones;
    fn bone_to_align_mut(&mut self) -> &mut super::entity::GameplayBones;
    fn require_animation_weight(&self) -> &bool;
    fn require_animation_weight_mut(&mut self) -> &mut bool;
    fn force_animation_transform(&self) -> &bool;
    fn force_animation_transform_mut(&mut self) -> &mut bool;
    fn connect_transform(&self) -> &super::core::LinearTransform;
    fn connect_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn external_connect_transform(&self) -> &bool;
    fn external_connect_transform_mut(&mut self) -> &mut bool;
}

impl WarpAnimationEntityDataTrait for WarpAnimationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn warp_binding(&self) -> &WarpAnimationBinding {
        &self.warp_binding
    }
    fn warp_binding_mut(&mut self) -> &mut WarpAnimationBinding {
        &mut self.warp_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn bone_to_align(&self) -> &super::entity::GameplayBones {
        &self.bone_to_align
    }
    fn bone_to_align_mut(&mut self) -> &mut super::entity::GameplayBones {
        &mut self.bone_to_align
    }
    fn require_animation_weight(&self) -> &bool {
        &self.require_animation_weight
    }
    fn require_animation_weight_mut(&mut self) -> &mut bool {
        &mut self.require_animation_weight
    }
    fn force_animation_transform(&self) -> &bool {
        &self.force_animation_transform
    }
    fn force_animation_transform_mut(&mut self) -> &mut bool {
        &mut self.force_animation_transform
    }
    fn connect_transform(&self) -> &super::core::LinearTransform {
        &self.connect_transform
    }
    fn connect_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.connect_transform
    }
    fn external_connect_transform(&self) -> &bool {
        &self.external_connect_transform
    }
    fn external_connect_transform_mut(&mut self) -> &mut bool {
        &mut self.external_connect_transform
    }
}

impl super::entity::EntityDataTrait for WarpAnimationEntityData {
}

impl super::entity::GameObjectDataTrait for WarpAnimationEntityData {
}

impl super::core::DataBusPeerTrait for WarpAnimationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WarpAnimationEntityData {
}

impl super::core::DataContainerTrait for WarpAnimationEntityData {
}

pub static WARPANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationEntityData",
    name_hash: 2240608140,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(WarpAnimationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarpAnimationEntityData as Default>::default())),
            create_boxed: || Box::new(<WarpAnimationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WarpAnimationEntityData, realm),
            },
            FieldInfoData {
                name: "WarpBinding",
                name_hash: 2937232592,
                flags: MemberInfoFlags::new(0),
                field_type: "WarpAnimationBinding",
                rust_offset: offset_of!(WarpAnimationEntityData, warp_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                name_hash: 4041607518,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WarpAnimationEntityData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "BoneToAlign",
                name_hash: 911082357,
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(WarpAnimationEntityData, bone_to_align),
            },
            FieldInfoData {
                name: "RequireAnimationWeight",
                name_hash: 1434930590,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationEntityData, require_animation_weight),
            },
            FieldInfoData {
                name: "ForceAnimationTransform",
                name_hash: 3539295138,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationEntityData, force_animation_transform),
            },
            FieldInfoData {
                name: "ConnectTransform",
                name_hash: 1194494871,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WarpAnimationEntityData, connect_transform),
            },
            FieldInfoData {
                name: "ExternalConnectTransform",
                name_hash: 3883178538,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationEntityData, external_connect_transform),
            },
        ],
    }),
    array_type: Some(WARPANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WarpAnimationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WARPANIMATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WARPANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationEntityData-Array",
    name_hash: 883312568,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarpAnimationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WarpAnimationComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub warp_binding: WarpAnimationBinding,
    pub canned_anim_binding: CannedAnimationBinding,
    pub animation_entity_space_priority: i32,
    pub bone_to_align: super::entity::GameplayBones,
    pub require_animation_weight: bool,
    pub force_animation_transform: bool,
    pub connect_transform: super::core::LinearTransform,
    pub external_connect_transform: bool,
}

pub trait WarpAnimationComponentDataTrait: super::entity::GameComponentDataTrait {
    fn warp_binding(&self) -> &WarpAnimationBinding;
    fn warp_binding_mut(&mut self) -> &mut WarpAnimationBinding;
    fn canned_anim_binding(&self) -> &CannedAnimationBinding;
    fn canned_anim_binding_mut(&mut self) -> &mut CannedAnimationBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn bone_to_align(&self) -> &super::entity::GameplayBones;
    fn bone_to_align_mut(&mut self) -> &mut super::entity::GameplayBones;
    fn require_animation_weight(&self) -> &bool;
    fn require_animation_weight_mut(&mut self) -> &mut bool;
    fn force_animation_transform(&self) -> &bool;
    fn force_animation_transform_mut(&mut self) -> &mut bool;
    fn connect_transform(&self) -> &super::core::LinearTransform;
    fn connect_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn external_connect_transform(&self) -> &bool;
    fn external_connect_transform_mut(&mut self) -> &mut bool;
}

impl WarpAnimationComponentDataTrait for WarpAnimationComponentData {
    fn warp_binding(&self) -> &WarpAnimationBinding {
        &self.warp_binding
    }
    fn warp_binding_mut(&mut self) -> &mut WarpAnimationBinding {
        &mut self.warp_binding
    }
    fn canned_anim_binding(&self) -> &CannedAnimationBinding {
        &self.canned_anim_binding
    }
    fn canned_anim_binding_mut(&mut self) -> &mut CannedAnimationBinding {
        &mut self.canned_anim_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn bone_to_align(&self) -> &super::entity::GameplayBones {
        &self.bone_to_align
    }
    fn bone_to_align_mut(&mut self) -> &mut super::entity::GameplayBones {
        &mut self.bone_to_align
    }
    fn require_animation_weight(&self) -> &bool {
        &self.require_animation_weight
    }
    fn require_animation_weight_mut(&mut self) -> &mut bool {
        &mut self.require_animation_weight
    }
    fn force_animation_transform(&self) -> &bool {
        &self.force_animation_transform
    }
    fn force_animation_transform_mut(&mut self) -> &mut bool {
        &mut self.force_animation_transform
    }
    fn connect_transform(&self) -> &super::core::LinearTransform {
        &self.connect_transform
    }
    fn connect_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.connect_transform
    }
    fn external_connect_transform(&self) -> &bool {
        &self.external_connect_transform
    }
    fn external_connect_transform_mut(&mut self) -> &mut bool {
        &mut self.external_connect_transform
    }
}

impl super::entity::GameComponentDataTrait for WarpAnimationComponentData {
}

impl super::entity::ComponentDataTrait for WarpAnimationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WarpAnimationComponentData {
}

impl super::core::DataBusPeerTrait for WarpAnimationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WarpAnimationComponentData {
}

impl super::core::DataContainerTrait for WarpAnimationComponentData {
}

pub static WARPANIMATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationComponentData",
    name_hash: 2908054936,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(WarpAnimationComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarpAnimationComponentData as Default>::default())),
            create_boxed: || Box::new(<WarpAnimationComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "WarpBinding",
                name_hash: 2937232592,
                flags: MemberInfoFlags::new(0),
                field_type: "WarpAnimationBinding",
                rust_offset: offset_of!(WarpAnimationComponentData, warp_binding),
            },
            FieldInfoData {
                name: "CannedAnimBinding",
                name_hash: 3536770252,
                flags: MemberInfoFlags::new(0),
                field_type: "CannedAnimationBinding",
                rust_offset: offset_of!(WarpAnimationComponentData, canned_anim_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                name_hash: 4041607518,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WarpAnimationComponentData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "BoneToAlign",
                name_hash: 911082357,
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(WarpAnimationComponentData, bone_to_align),
            },
            FieldInfoData {
                name: "RequireAnimationWeight",
                name_hash: 1434930590,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationComponentData, require_animation_weight),
            },
            FieldInfoData {
                name: "ForceAnimationTransform",
                name_hash: 3539295138,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationComponentData, force_animation_transform),
            },
            FieldInfoData {
                name: "ConnectTransform",
                name_hash: 1194494871,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WarpAnimationComponentData, connect_transform),
            },
            FieldInfoData {
                name: "ExternalConnectTransform",
                name_hash: 3883178538,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationComponentData, external_connect_transform),
            },
        ],
    }),
    array_type: Some(WARPANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WarpAnimationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WARPANIMATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WARPANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationComponentData-Array",
    name_hash: 1188843436,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarpAnimationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CannedAnimationBinding {
    pub level_index: super::ant::AntRef,
    pub scenario_index: super::ant::AntRef,
    pub actor_index: super::ant::AntRef,
    pub part_index: super::ant::AntRef,
    pub trigger_canned_animation: super::ant::AntRef,
    pub exit_canned_animation: super::ant::AntRef,
    pub external_time: super::ant::AntRef,
    pub blend_value: super::ant::AntRef,
    pub advance_scenario: super::ant::AntRef,
    pub entered_loop: super::ant::AntRef,
    pub almost_finished: super::ant::AntRef,
}

pub trait CannedAnimationBindingTrait: TypeObject {
    fn level_index(&self) -> &super::ant::AntRef;
    fn level_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn scenario_index(&self) -> &super::ant::AntRef;
    fn scenario_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn actor_index(&self) -> &super::ant::AntRef;
    fn actor_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn part_index(&self) -> &super::ant::AntRef;
    fn part_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn trigger_canned_animation(&self) -> &super::ant::AntRef;
    fn trigger_canned_animation_mut(&mut self) -> &mut super::ant::AntRef;
    fn exit_canned_animation(&self) -> &super::ant::AntRef;
    fn exit_canned_animation_mut(&mut self) -> &mut super::ant::AntRef;
    fn external_time(&self) -> &super::ant::AntRef;
    fn external_time_mut(&mut self) -> &mut super::ant::AntRef;
    fn blend_value(&self) -> &super::ant::AntRef;
    fn blend_value_mut(&mut self) -> &mut super::ant::AntRef;
    fn advance_scenario(&self) -> &super::ant::AntRef;
    fn advance_scenario_mut(&mut self) -> &mut super::ant::AntRef;
    fn entered_loop(&self) -> &super::ant::AntRef;
    fn entered_loop_mut(&mut self) -> &mut super::ant::AntRef;
    fn almost_finished(&self) -> &super::ant::AntRef;
    fn almost_finished_mut(&mut self) -> &mut super::ant::AntRef;
}

impl CannedAnimationBindingTrait for CannedAnimationBinding {
    fn level_index(&self) -> &super::ant::AntRef {
        &self.level_index
    }
    fn level_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.level_index
    }
    fn scenario_index(&self) -> &super::ant::AntRef {
        &self.scenario_index
    }
    fn scenario_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.scenario_index
    }
    fn actor_index(&self) -> &super::ant::AntRef {
        &self.actor_index
    }
    fn actor_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.actor_index
    }
    fn part_index(&self) -> &super::ant::AntRef {
        &self.part_index
    }
    fn part_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.part_index
    }
    fn trigger_canned_animation(&self) -> &super::ant::AntRef {
        &self.trigger_canned_animation
    }
    fn trigger_canned_animation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.trigger_canned_animation
    }
    fn exit_canned_animation(&self) -> &super::ant::AntRef {
        &self.exit_canned_animation
    }
    fn exit_canned_animation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.exit_canned_animation
    }
    fn external_time(&self) -> &super::ant::AntRef {
        &self.external_time
    }
    fn external_time_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.external_time
    }
    fn blend_value(&self) -> &super::ant::AntRef {
        &self.blend_value
    }
    fn blend_value_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.blend_value
    }
    fn advance_scenario(&self) -> &super::ant::AntRef {
        &self.advance_scenario
    }
    fn advance_scenario_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.advance_scenario
    }
    fn entered_loop(&self) -> &super::ant::AntRef {
        &self.entered_loop
    }
    fn entered_loop_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.entered_loop
    }
    fn almost_finished(&self) -> &super::ant::AntRef {
        &self.almost_finished
    }
    fn almost_finished_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.almost_finished
    }
}

pub static CANNEDANIMATIONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CannedAnimationBinding",
    name_hash: 447354257,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CannedAnimationBinding as Default>::default())),
            create_boxed: || Box::new(<CannedAnimationBinding as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LevelIndex",
                name_hash: 1224148013,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, level_index),
            },
            FieldInfoData {
                name: "ScenarioIndex",
                name_hash: 3733751989,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, scenario_index),
            },
            FieldInfoData {
                name: "ActorIndex",
                name_hash: 4155216592,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, actor_index),
            },
            FieldInfoData {
                name: "PartIndex",
                name_hash: 3213901068,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, part_index),
            },
            FieldInfoData {
                name: "TriggerCannedAnimation",
                name_hash: 3299428744,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, trigger_canned_animation),
            },
            FieldInfoData {
                name: "ExitCannedAnimation",
                name_hash: 2312291536,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, exit_canned_animation),
            },
            FieldInfoData {
                name: "ExternalTime",
                name_hash: 2162678253,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, external_time),
            },
            FieldInfoData {
                name: "BlendValue",
                name_hash: 236872047,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, blend_value),
            },
            FieldInfoData {
                name: "AdvanceScenario",
                name_hash: 442020689,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, advance_scenario),
            },
            FieldInfoData {
                name: "EnteredLoop",
                name_hash: 1022507888,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, entered_loop),
            },
            FieldInfoData {
                name: "AlmostFinished",
                name_hash: 1011188927,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, almost_finished),
            },
        ],
    }),
    array_type: Some(CANNEDANIMATIONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CannedAnimationBinding {
    fn type_info(&self) -> &'static TypeInfo {
        CANNEDANIMATIONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CANNEDANIMATIONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CannedAnimationBinding-Array",
    name_hash: 3862984485,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CannedAnimationBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WarpAnimationBinding {
    pub connect_joint_group: super::ant::AntRef,
    pub connect_joint_weight: super::ant::AntRef,
    pub enable_align: super::ant::AntRef,
    pub disable_culling: super::ant::AntRef,
    pub translation_y_warp_tolerance: super::ant::AntRef,
}

pub trait WarpAnimationBindingTrait: TypeObject {
    fn connect_joint_group(&self) -> &super::ant::AntRef;
    fn connect_joint_group_mut(&mut self) -> &mut super::ant::AntRef;
    fn connect_joint_weight(&self) -> &super::ant::AntRef;
    fn connect_joint_weight_mut(&mut self) -> &mut super::ant::AntRef;
    fn enable_align(&self) -> &super::ant::AntRef;
    fn enable_align_mut(&mut self) -> &mut super::ant::AntRef;
    fn disable_culling(&self) -> &super::ant::AntRef;
    fn disable_culling_mut(&mut self) -> &mut super::ant::AntRef;
    fn translation_y_warp_tolerance(&self) -> &super::ant::AntRef;
    fn translation_y_warp_tolerance_mut(&mut self) -> &mut super::ant::AntRef;
}

impl WarpAnimationBindingTrait for WarpAnimationBinding {
    fn connect_joint_group(&self) -> &super::ant::AntRef {
        &self.connect_joint_group
    }
    fn connect_joint_group_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.connect_joint_group
    }
    fn connect_joint_weight(&self) -> &super::ant::AntRef {
        &self.connect_joint_weight
    }
    fn connect_joint_weight_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.connect_joint_weight
    }
    fn enable_align(&self) -> &super::ant::AntRef {
        &self.enable_align
    }
    fn enable_align_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enable_align
    }
    fn disable_culling(&self) -> &super::ant::AntRef {
        &self.disable_culling
    }
    fn disable_culling_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.disable_culling
    }
    fn translation_y_warp_tolerance(&self) -> &super::ant::AntRef {
        &self.translation_y_warp_tolerance
    }
    fn translation_y_warp_tolerance_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.translation_y_warp_tolerance
    }
}

pub static WARPANIMATIONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationBinding",
    name_hash: 3173956326,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarpAnimationBinding as Default>::default())),
            create_boxed: || Box::new(<WarpAnimationBinding as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ConnectJointGroup",
                name_hash: 3144089970,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, connect_joint_group),
            },
            FieldInfoData {
                name: "ConnectJointWeight",
                name_hash: 1293270221,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, connect_joint_weight),
            },
            FieldInfoData {
                name: "EnableAlign",
                name_hash: 637937353,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, enable_align),
            },
            FieldInfoData {
                name: "DisableCulling",
                name_hash: 900615207,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, disable_culling),
            },
            FieldInfoData {
                name: "TranslationYWarpTolerance",
                name_hash: 544117098,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, translation_y_warp_tolerance),
            },
        ],
    }),
    array_type: Some(WARPANIMATIONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WarpAnimationBinding {
    fn type_info(&self) -> &'static TypeInfo {
        WARPANIMATIONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WARPANIMATIONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationBinding-Array",
    name_hash: 484816850,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarpAnimationBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WarningSystemComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub aim_warn_sound_effect: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub missile_warn_sound_effect: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub low_health_warn_sound_effect: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub locking_warn_sound_effect: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub locked_warn_sound_effect: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub player_type: WarningPlayerType,
}

pub trait WarningSystemComponentDataTrait: super::entity::GameComponentDataTrait {
    fn aim_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn aim_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn missile_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn missile_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn low_health_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn low_health_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn locking_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn locking_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn locked_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn locked_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn player_type(&self) -> &WarningPlayerType;
    fn player_type_mut(&mut self) -> &mut WarningPlayerType;
}

impl WarningSystemComponentDataTrait for WarningSystemComponentData {
    fn aim_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.aim_warn_sound_effect
    }
    fn aim_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.aim_warn_sound_effect
    }
    fn missile_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.missile_warn_sound_effect
    }
    fn missile_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.missile_warn_sound_effect
    }
    fn low_health_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.low_health_warn_sound_effect
    }
    fn low_health_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.low_health_warn_sound_effect
    }
    fn locking_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.locking_warn_sound_effect
    }
    fn locking_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.locking_warn_sound_effect
    }
    fn locked_warn_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.locked_warn_sound_effect
    }
    fn locked_warn_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.locked_warn_sound_effect
    }
    fn player_type(&self) -> &WarningPlayerType {
        &self.player_type
    }
    fn player_type_mut(&mut self) -> &mut WarningPlayerType {
        &mut self.player_type
    }
}

impl super::entity::GameComponentDataTrait for WarningSystemComponentData {
}

impl super::entity::ComponentDataTrait for WarningSystemComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WarningSystemComponentData {
}

impl super::core::DataBusPeerTrait for WarningSystemComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WarningSystemComponentData {
}

impl super::core::DataContainerTrait for WarningSystemComponentData {
}

pub static WARNINGSYSTEMCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarningSystemComponentData",
    name_hash: 4082101077,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(WarningSystemComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarningSystemComponentData as Default>::default())),
            create_boxed: || Box::new(<WarningSystemComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AimWarnSoundEffect",
                name_hash: 2573535070,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, aim_warn_sound_effect),
            },
            FieldInfoData {
                name: "MissileWarnSoundEffect",
                name_hash: 3117773919,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, missile_warn_sound_effect),
            },
            FieldInfoData {
                name: "LowHealthWarnSoundEffect",
                name_hash: 2886566771,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, low_health_warn_sound_effect),
            },
            FieldInfoData {
                name: "LockingWarnSoundEffect",
                name_hash: 893923632,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, locking_warn_sound_effect),
            },
            FieldInfoData {
                name: "LockedWarnSoundEffect",
                name_hash: 1254781329,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, locked_warn_sound_effect),
            },
            FieldInfoData {
                name: "PlayerType",
                name_hash: 774572558,
                flags: MemberInfoFlags::new(0),
                field_type: "WarningPlayerType",
                rust_offset: offset_of!(WarningSystemComponentData, player_type),
            },
        ],
    }),
    array_type: Some(WARNINGSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WarningSystemComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WARNINGSYSTEMCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WARNINGSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarningSystemComponentData-Array",
    name_hash: 4015737697,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarningSystemComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WarningPlayerType {
    #[default]
    WPTInflictor = 0,
    WPTVictim = 1,
}

pub static WARNINGPLAYERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarningPlayerType",
    name_hash: 4154003140,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(WARNINGPLAYERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WarningPlayerType {
    fn type_info(&self) -> &'static TypeInfo {
        WARNINGPLAYERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WARNINGPLAYERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarningPlayerType-Array",
    name_hash: 2147185520,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarningPlayerType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LensFlareComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub lens_flare: Option<LockedTypeObject /* super::world_sim::LensFlareEntityData */>,
}

pub trait LensFlareComponentDataTrait: super::entity::GameComponentDataTrait {
    fn lens_flare(&self) -> &Option<LockedTypeObject /* super::world_sim::LensFlareEntityData */>;
    fn lens_flare_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::LensFlareEntityData */>;
}

impl LensFlareComponentDataTrait for LensFlareComponentData {
    fn lens_flare(&self) -> &Option<LockedTypeObject /* super::world_sim::LensFlareEntityData */> {
        &self.lens_flare
    }
    fn lens_flare_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::LensFlareEntityData */> {
        &mut self.lens_flare
    }
}

impl super::entity::GameComponentDataTrait for LensFlareComponentData {
}

impl super::entity::ComponentDataTrait for LensFlareComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LensFlareComponentData {
}

impl super::core::DataBusPeerTrait for LensFlareComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LensFlareComponentData {
}

impl super::core::DataContainerTrait for LensFlareComponentData {
}

pub static LENSFLARECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareComponentData",
    name_hash: 2825818482,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(LensFlareComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensFlareComponentData as Default>::default())),
            create_boxed: || Box::new(<LensFlareComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LensFlare",
                name_hash: 890070093,
                flags: MemberInfoFlags::new(0),
                field_type: "LensFlareEntityData",
                rust_offset: offset_of!(LensFlareComponentData, lens_flare),
            },
        ],
    }),
    array_type: Some(LENSFLARECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LensFlareComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LENSFLARECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSFLARECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareComponentData-Array",
    name_hash: 2510260294,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LensFlareComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SphereReflectionVolumeComponentData {
    pub _glacier_base: ReflectionVolumeComponentData,
    pub reflection_volume: Option<LockedTypeObject /* super::world_sim::PbrSphereReflectionVolumeEntityData */>,
}

pub trait SphereReflectionVolumeComponentDataTrait: ReflectionVolumeComponentDataTrait {
    fn reflection_volume(&self) -> &Option<LockedTypeObject /* super::world_sim::PbrSphereReflectionVolumeEntityData */>;
    fn reflection_volume_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::PbrSphereReflectionVolumeEntityData */>;
}

impl SphereReflectionVolumeComponentDataTrait for SphereReflectionVolumeComponentData {
    fn reflection_volume(&self) -> &Option<LockedTypeObject /* super::world_sim::PbrSphereReflectionVolumeEntityData */> {
        &self.reflection_volume
    }
    fn reflection_volume_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::PbrSphereReflectionVolumeEntityData */> {
        &mut self.reflection_volume
    }
}

impl ReflectionVolumeComponentDataTrait for SphereReflectionVolumeComponentData {
}

impl super::entity::GameComponentDataTrait for SphereReflectionVolumeComponentData {
}

impl super::entity::ComponentDataTrait for SphereReflectionVolumeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SphereReflectionVolumeComponentData {
}

impl super::core::DataBusPeerTrait for SphereReflectionVolumeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SphereReflectionVolumeComponentData {
}

impl super::core::DataContainerTrait for SphereReflectionVolumeComponentData {
}

pub static SPHEREREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereReflectionVolumeComponentData",
    name_hash: 2953047692,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(SphereReflectionVolumeComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SphereReflectionVolumeComponentData as Default>::default())),
            create_boxed: || Box::new(<SphereReflectionVolumeComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ReflectionVolume",
                name_hash: 2009449130,
                flags: MemberInfoFlags::new(0),
                field_type: "PbrSphereReflectionVolumeEntityData",
                rust_offset: offset_of!(SphereReflectionVolumeComponentData, reflection_volume),
            },
        ],
    }),
    array_type: Some(SPHEREREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SphereReflectionVolumeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SPHEREREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPHEREREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereReflectionVolumeComponentData-Array",
    name_hash: 1346010808,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SphereReflectionVolumeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoxReflectionVolumeComponentData {
    pub _glacier_base: ReflectionVolumeComponentData,
    pub reflection_volume: Option<LockedTypeObject /* super::world_sim::PbrBoxReflectionVolumeEntityData */>,
}

pub trait BoxReflectionVolumeComponentDataTrait: ReflectionVolumeComponentDataTrait {
    fn reflection_volume(&self) -> &Option<LockedTypeObject /* super::world_sim::PbrBoxReflectionVolumeEntityData */>;
    fn reflection_volume_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::PbrBoxReflectionVolumeEntityData */>;
}

impl BoxReflectionVolumeComponentDataTrait for BoxReflectionVolumeComponentData {
    fn reflection_volume(&self) -> &Option<LockedTypeObject /* super::world_sim::PbrBoxReflectionVolumeEntityData */> {
        &self.reflection_volume
    }
    fn reflection_volume_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::PbrBoxReflectionVolumeEntityData */> {
        &mut self.reflection_volume
    }
}

impl ReflectionVolumeComponentDataTrait for BoxReflectionVolumeComponentData {
}

impl super::entity::GameComponentDataTrait for BoxReflectionVolumeComponentData {
}

impl super::entity::ComponentDataTrait for BoxReflectionVolumeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BoxReflectionVolumeComponentData {
}

impl super::core::DataBusPeerTrait for BoxReflectionVolumeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoxReflectionVolumeComponentData {
}

impl super::core::DataContainerTrait for BoxReflectionVolumeComponentData {
}

pub static BOXREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoxReflectionVolumeComponentData",
    name_hash: 4187470144,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(BoxReflectionVolumeComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoxReflectionVolumeComponentData as Default>::default())),
            create_boxed: || Box::new(<BoxReflectionVolumeComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ReflectionVolume",
                name_hash: 2009449130,
                flags: MemberInfoFlags::new(0),
                field_type: "PbrBoxReflectionVolumeEntityData",
                rust_offset: offset_of!(BoxReflectionVolumeComponentData, reflection_volume),
            },
        ],
    }),
    array_type: Some(BOXREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BoxReflectionVolumeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BOXREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOXREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoxReflectionVolumeComponentData-Array",
    name_hash: 279990260,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoxReflectionVolumeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ReflectionVolumeComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait ReflectionVolumeComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl ReflectionVolumeComponentDataTrait for ReflectionVolumeComponentData {
}

impl super::entity::GameComponentDataTrait for ReflectionVolumeComponentData {
}

impl super::entity::ComponentDataTrait for ReflectionVolumeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ReflectionVolumeComponentData {
}

impl super::core::DataBusPeerTrait for ReflectionVolumeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReflectionVolumeComponentData {
}

impl super::core::DataContainerTrait for ReflectionVolumeComponentData {
}

pub static REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReflectionVolumeComponentData",
    name_hash: 928999669,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(ReflectionVolumeComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReflectionVolumeComponentData as Default>::default())),
            create_boxed: || Box::new(<ReflectionVolumeComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(REFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ReflectionVolumeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReflectionVolumeComponentData-Array",
    name_hash: 2905799105,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReflectionVolumeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LightComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub light: Option<LockedTypeObject /* super::world_sim::LocalLightEntityData */>,
}

pub trait LightComponentDataTrait: super::entity::GameComponentDataTrait {
    fn light(&self) -> &Option<LockedTypeObject /* super::world_sim::LocalLightEntityData */>;
    fn light_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::LocalLightEntityData */>;
}

impl LightComponentDataTrait for LightComponentData {
    fn light(&self) -> &Option<LockedTypeObject /* super::world_sim::LocalLightEntityData */> {
        &self.light
    }
    fn light_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_sim::LocalLightEntityData */> {
        &mut self.light
    }
}

impl super::entity::GameComponentDataTrait for LightComponentData {
}

impl super::entity::ComponentDataTrait for LightComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LightComponentData {
}

impl super::core::DataBusPeerTrait for LightComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LightComponentData {
}

impl super::core::DataContainerTrait for LightComponentData {
}

pub static LIGHTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightComponentData",
    name_hash: 911959652,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(LightComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LightComponentData as Default>::default())),
            create_boxed: || Box::new(<LightComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Light",
                name_hash: 217821467,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalLightEntityData",
                rust_offset: offset_of!(LightComponentData, light),
            },
        ],
    }),
    array_type: Some(LIGHTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LightComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LIGHTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LIGHTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightComponentData-Array",
    name_hash: 3508062800,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LightComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleInputSettings {
    pub _glacier_base: super::input_shared::BaseInputSettings,
    pub vehicle_boost_is_toggle: bool,
    pub vehicle_boost_is_toggle_min_input: f32,
}

pub trait VehicleInputSettingsTrait: super::input_shared::BaseInputSettingsTrait {
    fn vehicle_boost_is_toggle(&self) -> &bool;
    fn vehicle_boost_is_toggle_mut(&mut self) -> &mut bool;
    fn vehicle_boost_is_toggle_min_input(&self) -> &f32;
    fn vehicle_boost_is_toggle_min_input_mut(&mut self) -> &mut f32;
}

impl VehicleInputSettingsTrait for VehicleInputSettings {
    fn vehicle_boost_is_toggle(&self) -> &bool {
        &self.vehicle_boost_is_toggle
    }
    fn vehicle_boost_is_toggle_mut(&mut self) -> &mut bool {
        &mut self.vehicle_boost_is_toggle
    }
    fn vehicle_boost_is_toggle_min_input(&self) -> &f32 {
        &self.vehicle_boost_is_toggle_min_input
    }
    fn vehicle_boost_is_toggle_min_input_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_boost_is_toggle_min_input
    }
}

impl super::input_shared::BaseInputSettingsTrait for VehicleInputSettings {
}

impl super::core::DataContainerTrait for VehicleInputSettings {
}

pub static VEHICLEINPUTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleInputSettings",
    name_hash: 3893651502,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::input_shared::BASEINPUTSETTINGS_TYPE_INFO),
        super_class_offset: offset_of!(VehicleInputSettings, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleInputSettings as Default>::default())),
            create_boxed: || Box::new(<VehicleInputSettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "VehicleBoostIsToggle",
                name_hash: 1735323024,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleInputSettings, vehicle_boost_is_toggle),
            },
            FieldInfoData {
                name: "VehicleBoostIsToggleMinInput",
                name_hash: 522084300,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleInputSettings, vehicle_boost_is_toggle_min_input),
            },
        ],
    }),
    array_type: Some(VEHICLEINPUTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleInputSettings {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEINPUTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEINPUTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleInputSettings-Array",
    name_hash: 3304583322,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleInputSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct HealthZoneInfo {
    pub health_is_valid: bool,
    pub health: u32,
    pub is_protected_shield_active: bool,
}

pub trait HealthZoneInfoTrait: TypeObject {
    fn health_is_valid(&self) -> &bool;
    fn health_is_valid_mut(&mut self) -> &mut bool;
    fn health(&self) -> &u32;
    fn health_mut(&mut self) -> &mut u32;
    fn is_protected_shield_active(&self) -> &bool;
    fn is_protected_shield_active_mut(&mut self) -> &mut bool;
}

impl HealthZoneInfoTrait for HealthZoneInfo {
    fn health_is_valid(&self) -> &bool {
        &self.health_is_valid
    }
    fn health_is_valid_mut(&mut self) -> &mut bool {
        &mut self.health_is_valid
    }
    fn health(&self) -> &u32 {
        &self.health
    }
    fn health_mut(&mut self) -> &mut u32 {
        &mut self.health
    }
    fn is_protected_shield_active(&self) -> &bool {
        &self.is_protected_shield_active
    }
    fn is_protected_shield_active_mut(&mut self) -> &mut bool {
        &mut self.is_protected_shield_active
    }
}

pub static HEALTHZONEINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HealthZoneInfo",
    name_hash: 1955529897,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HealthZoneInfo as Default>::default())),
            create_boxed: || Box::new(<HealthZoneInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "HealthIsValid",
                name_hash: 174204149,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HealthZoneInfo, health_is_valid),
            },
            FieldInfoData {
                name: "Health",
                name_hash: 3054337113,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(HealthZoneInfo, health),
            },
            FieldInfoData {
                name: "IsProtectedShieldActive",
                name_hash: 2950444358,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HealthZoneInfo, is_protected_shield_active),
            },
        ],
    }),
    array_type: Some(HEALTHZONEINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for HealthZoneInfo {
    fn type_info(&self) -> &'static TypeInfo {
        HEALTHZONEINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static HEALTHZONEINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HealthZoneInfo-Array",
    name_hash: 1484065565,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HealthZoneInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleEntryListenerComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub vehicle_entry_listener: VehicleEntryListenerBinding,
    pub vehicle_camera_control: VehicleCameraControlBinding,
    pub read_binding: VehicleEntryListenerReadBinding,
    pub animation_entity_space_priority: i32,
    pub animation_wheel_transform_delay: f32,
}

pub trait VehicleEntryListenerComponentDataTrait: super::entity::GameComponentDataTrait {
    fn vehicle_entry_listener(&self) -> &VehicleEntryListenerBinding;
    fn vehicle_entry_listener_mut(&mut self) -> &mut VehicleEntryListenerBinding;
    fn vehicle_camera_control(&self) -> &VehicleCameraControlBinding;
    fn vehicle_camera_control_mut(&mut self) -> &mut VehicleCameraControlBinding;
    fn read_binding(&self) -> &VehicleEntryListenerReadBinding;
    fn read_binding_mut(&mut self) -> &mut VehicleEntryListenerReadBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn animation_wheel_transform_delay(&self) -> &f32;
    fn animation_wheel_transform_delay_mut(&mut self) -> &mut f32;
}

impl VehicleEntryListenerComponentDataTrait for VehicleEntryListenerComponentData {
    fn vehicle_entry_listener(&self) -> &VehicleEntryListenerBinding {
        &self.vehicle_entry_listener
    }
    fn vehicle_entry_listener_mut(&mut self) -> &mut VehicleEntryListenerBinding {
        &mut self.vehicle_entry_listener
    }
    fn vehicle_camera_control(&self) -> &VehicleCameraControlBinding {
        &self.vehicle_camera_control
    }
    fn vehicle_camera_control_mut(&mut self) -> &mut VehicleCameraControlBinding {
        &mut self.vehicle_camera_control
    }
    fn read_binding(&self) -> &VehicleEntryListenerReadBinding {
        &self.read_binding
    }
    fn read_binding_mut(&mut self) -> &mut VehicleEntryListenerReadBinding {
        &mut self.read_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn animation_wheel_transform_delay(&self) -> &f32 {
        &self.animation_wheel_transform_delay
    }
    fn animation_wheel_transform_delay_mut(&mut self) -> &mut f32 {
        &mut self.animation_wheel_transform_delay
    }
}

impl super::entity::GameComponentDataTrait for VehicleEntryListenerComponentData {
}

impl super::entity::ComponentDataTrait for VehicleEntryListenerComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleEntryListenerComponentData {
}

impl super::core::DataBusPeerTrait for VehicleEntryListenerComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleEntryListenerComponentData {
}

impl super::core::DataContainerTrait for VehicleEntryListenerComponentData {
}

pub static VEHICLEENTRYLISTENERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerComponentData",
    name_hash: 1404980136,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleEntryListenerComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntryListenerComponentData as Default>::default())),
            create_boxed: || Box::new(<VehicleEntryListenerComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "VehicleEntryListener",
                name_hash: 1646308695,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleEntryListenerBinding",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, vehicle_entry_listener),
            },
            FieldInfoData {
                name: "VehicleCameraControl",
                name_hash: 478775939,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleCameraControlBinding",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, vehicle_camera_control),
            },
            FieldInfoData {
                name: "ReadBinding",
                name_hash: 3668929686,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleEntryListenerReadBinding",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, read_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                name_hash: 4041607518,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "AnimationWheelTransformDelay",
                name_hash: 2638640185,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, animation_wheel_transform_delay),
            },
        ],
    }),
    array_type: Some(VEHICLEENTRYLISTENERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleEntryListenerComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTRYLISTENERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEENTRYLISTENERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerComponentData-Array",
    name_hash: 820399388,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntryListenerComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleCameraControlBinding {
    pub enable_animated_vehicle_camera: super::ant::AntRef,
}

pub trait VehicleCameraControlBindingTrait: TypeObject {
    fn enable_animated_vehicle_camera(&self) -> &super::ant::AntRef;
    fn enable_animated_vehicle_camera_mut(&mut self) -> &mut super::ant::AntRef;
}

impl VehicleCameraControlBindingTrait for VehicleCameraControlBinding {
    fn enable_animated_vehicle_camera(&self) -> &super::ant::AntRef {
        &self.enable_animated_vehicle_camera
    }
    fn enable_animated_vehicle_camera_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enable_animated_vehicle_camera
    }
}

pub static VEHICLECAMERACONTROLBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCameraControlBinding",
    name_hash: 3663174402,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleCameraControlBinding as Default>::default())),
            create_boxed: || Box::new(<VehicleCameraControlBinding as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EnableAnimatedVehicleCamera",
                name_hash: 4037882842,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleCameraControlBinding, enable_animated_vehicle_camera),
            },
        ],
    }),
    array_type: Some(VEHICLECAMERACONTROLBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleCameraControlBinding {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECAMERACONTROLBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLECAMERACONTROLBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCameraControlBinding-Array",
    name_hash: 2158672438,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleCameraControlBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleEntryListenerReadBinding {
    pub in_vehicle_node: super::ant::AntRef,
    pub vehicle_align_index: super::ant::AntRef,
    pub vehicle_entry_index_updated: super::ant::AntRef,
    pub vehicle_allowed_to_switch_seat: super::ant::AntRef,
}

pub trait VehicleEntryListenerReadBindingTrait: TypeObject {
    fn in_vehicle_node(&self) -> &super::ant::AntRef;
    fn in_vehicle_node_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_align_index(&self) -> &super::ant::AntRef;
    fn vehicle_align_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_index_updated(&self) -> &super::ant::AntRef;
    fn vehicle_entry_index_updated_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_allowed_to_switch_seat(&self) -> &super::ant::AntRef;
    fn vehicle_allowed_to_switch_seat_mut(&mut self) -> &mut super::ant::AntRef;
}

impl VehicleEntryListenerReadBindingTrait for VehicleEntryListenerReadBinding {
    fn in_vehicle_node(&self) -> &super::ant::AntRef {
        &self.in_vehicle_node
    }
    fn in_vehicle_node_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_vehicle_node
    }
    fn vehicle_align_index(&self) -> &super::ant::AntRef {
        &self.vehicle_align_index
    }
    fn vehicle_align_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_align_index
    }
    fn vehicle_entry_index_updated(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_index_updated
    }
    fn vehicle_entry_index_updated_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_index_updated
    }
    fn vehicle_allowed_to_switch_seat(&self) -> &super::ant::AntRef {
        &self.vehicle_allowed_to_switch_seat
    }
    fn vehicle_allowed_to_switch_seat_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_allowed_to_switch_seat
    }
}

pub static VEHICLEENTRYLISTENERREADBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerReadBinding",
    name_hash: 2571965060,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntryListenerReadBinding as Default>::default())),
            create_boxed: || Box::new(<VehicleEntryListenerReadBinding as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InVehicleNode",
                name_hash: 2274096250,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerReadBinding, in_vehicle_node),
            },
            FieldInfoData {
                name: "VehicleAlignIndex",
                name_hash: 2495828174,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerReadBinding, vehicle_align_index),
            },
            FieldInfoData {
                name: "VehicleEntryIndexUpdated",
                name_hash: 3953478242,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerReadBinding, vehicle_entry_index_updated),
            },
            FieldInfoData {
                name: "VehicleAllowedToSwitchSeat",
                name_hash: 1097874639,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerReadBinding, vehicle_allowed_to_switch_seat),
            },
        ],
    }),
    array_type: Some(VEHICLEENTRYLISTENERREADBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleEntryListenerReadBinding {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTRYLISTENERREADBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEENTRYLISTENERREADBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerReadBinding-Array",
    name_hash: 978273968,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntryListenerReadBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleEntryListenerBinding {
    pub in_vehicle: super::ant::AntRef,
    pub in_open_entry: super::ant::AntRef,
    pub vehicle_enter_direction: super::ant::AntRef,
    pub vehicle_speed: super::ant::AntRef,
    pub vehicle_entry_fire: super::ant::AntRef,
    pub vehicle_entry_yaw: super::ant::AntRef,
    pub vehicle_entry_relative_yaw: super::ant::AntRef,
    pub vehicle_entry_pitch: super::ant::AntRef,
    pub vehicle_entry_roll: super::ant::AntRef,
    pub vehicle_entry_rotation: super::ant::AntRef,
    pub vehicle_entry_force_x: super::ant::AntRef,
    pub vehicle_entry_force_y: super::ant::AntRef,
    pub vehicle_entry_force_z: super::ant::AntRef,
    pub vehicle_previous_entry_index: super::ant::AntRef,
    pub vehicle_entry_index: super::ant::AntRef,
    pub vehicle_open_entry_index: super::ant::AntRef,
    pub in_vehicle_retrigger: super::ant::AntRef,
    pub vehicle_entry_chooser_index: super::ant::AntRef,
}

pub trait VehicleEntryListenerBindingTrait: TypeObject {
    fn in_vehicle(&self) -> &super::ant::AntRef;
    fn in_vehicle_mut(&mut self) -> &mut super::ant::AntRef;
    fn in_open_entry(&self) -> &super::ant::AntRef;
    fn in_open_entry_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_enter_direction(&self) -> &super::ant::AntRef;
    fn vehicle_enter_direction_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_speed(&self) -> &super::ant::AntRef;
    fn vehicle_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_fire(&self) -> &super::ant::AntRef;
    fn vehicle_entry_fire_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_yaw(&self) -> &super::ant::AntRef;
    fn vehicle_entry_yaw_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_relative_yaw(&self) -> &super::ant::AntRef;
    fn vehicle_entry_relative_yaw_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_pitch(&self) -> &super::ant::AntRef;
    fn vehicle_entry_pitch_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_roll(&self) -> &super::ant::AntRef;
    fn vehicle_entry_roll_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_rotation(&self) -> &super::ant::AntRef;
    fn vehicle_entry_rotation_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_force_x(&self) -> &super::ant::AntRef;
    fn vehicle_entry_force_x_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_force_y(&self) -> &super::ant::AntRef;
    fn vehicle_entry_force_y_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_force_z(&self) -> &super::ant::AntRef;
    fn vehicle_entry_force_z_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_previous_entry_index(&self) -> &super::ant::AntRef;
    fn vehicle_previous_entry_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_index(&self) -> &super::ant::AntRef;
    fn vehicle_entry_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_open_entry_index(&self) -> &super::ant::AntRef;
    fn vehicle_open_entry_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn in_vehicle_retrigger(&self) -> &super::ant::AntRef;
    fn in_vehicle_retrigger_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_chooser_index(&self) -> &super::ant::AntRef;
    fn vehicle_entry_chooser_index_mut(&mut self) -> &mut super::ant::AntRef;
}

impl VehicleEntryListenerBindingTrait for VehicleEntryListenerBinding {
    fn in_vehicle(&self) -> &super::ant::AntRef {
        &self.in_vehicle
    }
    fn in_vehicle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_vehicle
    }
    fn in_open_entry(&self) -> &super::ant::AntRef {
        &self.in_open_entry
    }
    fn in_open_entry_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_open_entry
    }
    fn vehicle_enter_direction(&self) -> &super::ant::AntRef {
        &self.vehicle_enter_direction
    }
    fn vehicle_enter_direction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_enter_direction
    }
    fn vehicle_speed(&self) -> &super::ant::AntRef {
        &self.vehicle_speed
    }
    fn vehicle_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_speed
    }
    fn vehicle_entry_fire(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_fire
    }
    fn vehicle_entry_fire_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_fire
    }
    fn vehicle_entry_yaw(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_yaw
    }
    fn vehicle_entry_yaw_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_yaw
    }
    fn vehicle_entry_relative_yaw(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_relative_yaw
    }
    fn vehicle_entry_relative_yaw_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_relative_yaw
    }
    fn vehicle_entry_pitch(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_pitch
    }
    fn vehicle_entry_pitch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_pitch
    }
    fn vehicle_entry_roll(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_roll
    }
    fn vehicle_entry_roll_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_roll
    }
    fn vehicle_entry_rotation(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_rotation
    }
    fn vehicle_entry_rotation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_rotation
    }
    fn vehicle_entry_force_x(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_force_x
    }
    fn vehicle_entry_force_x_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_force_x
    }
    fn vehicle_entry_force_y(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_force_y
    }
    fn vehicle_entry_force_y_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_force_y
    }
    fn vehicle_entry_force_z(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_force_z
    }
    fn vehicle_entry_force_z_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_force_z
    }
    fn vehicle_previous_entry_index(&self) -> &super::ant::AntRef {
        &self.vehicle_previous_entry_index
    }
    fn vehicle_previous_entry_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_previous_entry_index
    }
    fn vehicle_entry_index(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_index
    }
    fn vehicle_entry_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_index
    }
    fn vehicle_open_entry_index(&self) -> &super::ant::AntRef {
        &self.vehicle_open_entry_index
    }
    fn vehicle_open_entry_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_open_entry_index
    }
    fn in_vehicle_retrigger(&self) -> &super::ant::AntRef {
        &self.in_vehicle_retrigger
    }
    fn in_vehicle_retrigger_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_vehicle_retrigger
    }
    fn vehicle_entry_chooser_index(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_chooser_index
    }
    fn vehicle_entry_chooser_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_chooser_index
    }
}

pub static VEHICLEENTRYLISTENERBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerBinding",
    name_hash: 313160918,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntryListenerBinding as Default>::default())),
            create_boxed: || Box::new(<VehicleEntryListenerBinding as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InVehicle",
                name_hash: 2027857690,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, in_vehicle),
            },
            FieldInfoData {
                name: "InOpenEntry",
                name_hash: 3944895714,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, in_open_entry),
            },
            FieldInfoData {
                name: "VehicleEnterDirection",
                name_hash: 120921776,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_enter_direction),
            },
            FieldInfoData {
                name: "VehicleSpeed",
                name_hash: 503036026,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_speed),
            },
            FieldInfoData {
                name: "VehicleEntryFire",
                name_hash: 1657787569,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_fire),
            },
            FieldInfoData {
                name: "VehicleEntryYaw",
                name_hash: 50235142,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_yaw),
            },
            FieldInfoData {
                name: "VehicleEntryRelativeYaw",
                name_hash: 1208732402,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_relative_yaw),
            },
            FieldInfoData {
                name: "VehicleEntryPitch",
                name_hash: 3174613487,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_pitch),
            },
            FieldInfoData {
                name: "VehicleEntryRoll",
                name_hash: 1658216564,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_roll),
            },
            FieldInfoData {
                name: "VehicleEntryRotation",
                name_hash: 2010737181,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_rotation),
            },
            FieldInfoData {
                name: "VehicleEntryForceX",
                name_hash: 1432827884,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_force_x),
            },
            FieldInfoData {
                name: "VehicleEntryForceY",
                name_hash: 1432827885,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_force_y),
            },
            FieldInfoData {
                name: "VehicleEntryForceZ",
                name_hash: 1432827886,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_force_z),
            },
            FieldInfoData {
                name: "VehiclePreviousEntryIndex",
                name_hash: 2956272838,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_previous_entry_index),
            },
            FieldInfoData {
                name: "VehicleEntryIndex",
                name_hash: 3148172503,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_index),
            },
            FieldInfoData {
                name: "VehicleOpenEntryIndex",
                name_hash: 1471285795,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_open_entry_index),
            },
            FieldInfoData {
                name: "InVehicleRetrigger",
                name_hash: 3157938229,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, in_vehicle_retrigger),
            },
            FieldInfoData {
                name: "VehicleEntryChooserIndex",
                name_hash: 2285531672,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_chooser_index),
            },
        ],
    }),
    array_type: Some(VEHICLEENTRYLISTENERBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleEntryListenerBinding {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTRYLISTENERBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEENTRYLISTENERBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerBinding-Array",
    name_hash: 30186082,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntryListenerBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClientCameraToComponentsInitMessage {
}

pub trait ClientCameraToComponentsInitMessageTrait: TypeObject {
}

impl ClientCameraToComponentsInitMessageTrait for ClientCameraToComponentsInitMessage {
}

pub static CLIENTCAMERATOCOMPONENTSINITMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientCameraToComponentsInitMessage",
    name_hash: 1119945427,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientCameraToComponentsInitMessage as Default>::default())),
            create_boxed: || Box::new(<ClientCameraToComponentsInitMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientCameraToComponentsInitMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTCAMERATOCOMPONENTSINITMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleToComponentsStartDisabledDamagedMessage {
}

pub trait VehicleToComponentsStartDisabledDamagedMessageTrait: TypeObject {
}

impl VehicleToComponentsStartDisabledDamagedMessageTrait for VehicleToComponentsStartDisabledDamagedMessage {
}

pub static VEHICLETOCOMPONENTSSTARTDISABLEDDAMAGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleToComponentsStartDisabledDamagedMessage",
    name_hash: 4094060270,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleToComponentsStartDisabledDamagedMessage as Default>::default())),
            create_boxed: || Box::new(<VehicleToComponentsStartDisabledDamagedMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for VehicleToComponentsStartDisabledDamagedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLETOCOMPONENTSSTARTDISABLEDDAMAGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct ClientVehicleToComponentsHealthChangedMessage {
}

pub trait ClientVehicleToComponentsHealthChangedMessageTrait: TypeObject {
}

impl ClientVehicleToComponentsHealthChangedMessageTrait for ClientVehicleToComponentsHealthChangedMessage {
}

pub static CLIENTVEHICLETOCOMPONENTSHEALTHCHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientVehicleToComponentsHealthChangedMessage",
    name_hash: 1113786230,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientVehicleToComponentsHealthChangedMessage as Default>::default())),
            create_boxed: || Box::new(<ClientVehicleToComponentsHealthChangedMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientVehicleToComponentsHealthChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTVEHICLETOCOMPONENTSHEALTHCHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleEntityData {
    pub _glacier_base: super::gameplay_sim::ControllableEntityData,
    pub controllable_type: String,
    pub allow_vehicle_outside_combat_areas: bool,
    pub disabled_damage_threshold: f32,
    pub pre_destruction_damage_threshold: f32,
    pub front_health_zone: VehicleHealthZoneData,
    pub rear_health_zone: VehicleHealthZoneData,
    pub left_health_zone: VehicleHealthZoneData,
    pub right_health_zone: VehicleHealthZoneData,
    pub top_health_zone: VehicleHealthZoneData,
    pub use_top_zone: bool,
    pub top_hit_height: f32,
    pub top_hit_angle: f32,
    pub health_zones_share_damage: bool,
    pub regeneration_delay: f32,
    pub regeneration_rate: f32,
    pub use_protected_shields: bool,
    pub armor_multiplier: f32,
    pub regeneration_delay_multiplier: f32,
    pub regeneration_rate_multiplier: f32,
    pub emergency_repair_health: f32,
    pub decay_delay: f32,
    pub decay_rate: f32,
    pub show_player_health: bool,
    pub use_self_for_self_destruct: bool,
    pub critically_damaged_effect: Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>,
    pub critically_damaged_effect_position: super::core::Vec3,
    pub critical_damage_time: f32,
    pub pre_explosion_effect: Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>,
    pub pre_explosion_effect_position: super::core::Vec3,
    pub pre_explosion_time: f32,
    pub bypass_pre_destruction: bool,
    pub random_pre_destruction: bool,
    pub explosion: Option<LockedTypeObject /* ExplosionEntityData */>,
    pub abandoned_explosion_damage_multiplier: f32,
    pub mesh_type: super::render_base::MeshType,
    pub mesh_part_count: u32,
    pub foreground_render_cockpit_mesh: bool,
    pub motion_blur_mask: bool,
    pub suppress_damage_by_passengers: bool,
    pub hud_data: VehicleHudData,
    pub name_sid: String,
    pub max_players_in_vehicle: i32,
    pub min_speed_for_mine_activation: f32,
    pub trigger_vehicle_detonation: bool,
    pub upside_down_damage: f32,
    pub upside_down_damage_delay: f32,
    pub upside_down_angle: f32,
    pub water_damage: f32,
    pub below_water_damage_delay: f32,
    pub water_damage_offset: f32,
    pub is_affected_by_e_m_p: bool,
    pub velocity_damage_threshold: f32,
    pub velocity_damage_magnifier: f32,
    pub can_take_dynamic_fire_damage: bool,
    pub always_deal_collision_damage: bool,
    pub has_exclusive_entries: bool,
    pub prohibit_entry_switching: bool,
    pub throw_out_soldier_inside_on_water_damage: bool,
    pub kill_soldier_collision_speed_threshold: f32,
    pub kill_soldier_collision_speed_threshold_block_time: f32,
    pub ignore_soldier_collision_normal: bool,
    pub chose_exit_point_by_direction: bool,
    pub exit_speed_threshold: f32,
    pub exit_direction_speed_threshold: f32,
    pub enter_allowed: bool,
    pub exit_allowed: bool,
    pub enable_groundmap_lighting: bool,
    pub use_as_team_spawner: bool,
    pub f_l_i_r_value: f32,
    pub f_l_i_r_key_color: super::core::Vec3,
    pub m_p_mode: MPModeData,
    pub exit_camera_switch_delay: f32,
    pub angle_of_impact: AngleOfImpactData,
    pub is_lockable: bool,
    pub locking_time_multiplier: f32,
    pub vehicle_lockable_info: VehicleLockableInfoData,
    pub never_report_vehicle_as_empty: bool,
    pub a_i_target: bool,
    pub high_altitude_lock_height: f32,
    pub use_low_altitude_heat_signature: bool,
    pub sound: Option<LockedTypeObject /* VehicleSoundData */>,
    pub voice_over_info: Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */>,
    pub nametag_height_scale: f32,
    pub spotting_fov_scale: f32,
    pub use_spotting_target_component_for_raycast: bool,
    pub interaction_offset: super::core::Vec3,
    pub equipment_fake_vehicle: bool,
    pub explosion_packs_attachable: bool,
    pub character_blueprint_override: Option<LockedTypeObject /* CharacterBlueprint */>,
    pub damage_giver_override_owner_vehicle: bool,
    pub enable_sub_realm: bool,
    pub causes_a_i_to_flee: bool,
    pub a_i_flee_radius: f32,
    pub a_i_sound_category: AIVehicleSoundCategory,
    pub victim_offset_override: super::core::Vec3,
}

pub trait VehicleEntityDataTrait: super::gameplay_sim::ControllableEntityDataTrait {
    fn controllable_type(&self) -> &String;
    fn controllable_type_mut(&mut self) -> &mut String;
    fn allow_vehicle_outside_combat_areas(&self) -> &bool;
    fn allow_vehicle_outside_combat_areas_mut(&mut self) -> &mut bool;
    fn disabled_damage_threshold(&self) -> &f32;
    fn disabled_damage_threshold_mut(&mut self) -> &mut f32;
    fn pre_destruction_damage_threshold(&self) -> &f32;
    fn pre_destruction_damage_threshold_mut(&mut self) -> &mut f32;
    fn front_health_zone(&self) -> &VehicleHealthZoneData;
    fn front_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn rear_health_zone(&self) -> &VehicleHealthZoneData;
    fn rear_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn left_health_zone(&self) -> &VehicleHealthZoneData;
    fn left_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn right_health_zone(&self) -> &VehicleHealthZoneData;
    fn right_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn top_health_zone(&self) -> &VehicleHealthZoneData;
    fn top_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn use_top_zone(&self) -> &bool;
    fn use_top_zone_mut(&mut self) -> &mut bool;
    fn top_hit_height(&self) -> &f32;
    fn top_hit_height_mut(&mut self) -> &mut f32;
    fn top_hit_angle(&self) -> &f32;
    fn top_hit_angle_mut(&mut self) -> &mut f32;
    fn health_zones_share_damage(&self) -> &bool;
    fn health_zones_share_damage_mut(&mut self) -> &mut bool;
    fn regeneration_delay(&self) -> &f32;
    fn regeneration_delay_mut(&mut self) -> &mut f32;
    fn regeneration_rate(&self) -> &f32;
    fn regeneration_rate_mut(&mut self) -> &mut f32;
    fn use_protected_shields(&self) -> &bool;
    fn use_protected_shields_mut(&mut self) -> &mut bool;
    fn armor_multiplier(&self) -> &f32;
    fn armor_multiplier_mut(&mut self) -> &mut f32;
    fn regeneration_delay_multiplier(&self) -> &f32;
    fn regeneration_delay_multiplier_mut(&mut self) -> &mut f32;
    fn regeneration_rate_multiplier(&self) -> &f32;
    fn regeneration_rate_multiplier_mut(&mut self) -> &mut f32;
    fn emergency_repair_health(&self) -> &f32;
    fn emergency_repair_health_mut(&mut self) -> &mut f32;
    fn decay_delay(&self) -> &f32;
    fn decay_delay_mut(&mut self) -> &mut f32;
    fn decay_rate(&self) -> &f32;
    fn decay_rate_mut(&mut self) -> &mut f32;
    fn show_player_health(&self) -> &bool;
    fn show_player_health_mut(&mut self) -> &mut bool;
    fn use_self_for_self_destruct(&self) -> &bool;
    fn use_self_for_self_destruct_mut(&mut self) -> &mut bool;
    fn critically_damaged_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn critically_damaged_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn critically_damaged_effect_position(&self) -> &super::core::Vec3;
    fn critically_damaged_effect_position_mut(&mut self) -> &mut super::core::Vec3;
    fn critical_damage_time(&self) -> &f32;
    fn critical_damage_time_mut(&mut self) -> &mut f32;
    fn pre_explosion_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn pre_explosion_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn pre_explosion_effect_position(&self) -> &super::core::Vec3;
    fn pre_explosion_effect_position_mut(&mut self) -> &mut super::core::Vec3;
    fn pre_explosion_time(&self) -> &f32;
    fn pre_explosion_time_mut(&mut self) -> &mut f32;
    fn bypass_pre_destruction(&self) -> &bool;
    fn bypass_pre_destruction_mut(&mut self) -> &mut bool;
    fn random_pre_destruction(&self) -> &bool;
    fn random_pre_destruction_mut(&mut self) -> &mut bool;
    fn explosion(&self) -> &Option<LockedTypeObject /* ExplosionEntityData */>;
    fn explosion_mut(&mut self) -> &mut Option<LockedTypeObject /* ExplosionEntityData */>;
    fn abandoned_explosion_damage_multiplier(&self) -> &f32;
    fn abandoned_explosion_damage_multiplier_mut(&mut self) -> &mut f32;
    fn mesh_type(&self) -> &super::render_base::MeshType;
    fn mesh_type_mut(&mut self) -> &mut super::render_base::MeshType;
    fn mesh_part_count(&self) -> &u32;
    fn mesh_part_count_mut(&mut self) -> &mut u32;
    fn foreground_render_cockpit_mesh(&self) -> &bool;
    fn foreground_render_cockpit_mesh_mut(&mut self) -> &mut bool;
    fn motion_blur_mask(&self) -> &bool;
    fn motion_blur_mask_mut(&mut self) -> &mut bool;
    fn suppress_damage_by_passengers(&self) -> &bool;
    fn suppress_damage_by_passengers_mut(&mut self) -> &mut bool;
    fn hud_data(&self) -> &VehicleHudData;
    fn hud_data_mut(&mut self) -> &mut VehicleHudData;
    fn name_sid(&self) -> &String;
    fn name_sid_mut(&mut self) -> &mut String;
    fn max_players_in_vehicle(&self) -> &i32;
    fn max_players_in_vehicle_mut(&mut self) -> &mut i32;
    fn min_speed_for_mine_activation(&self) -> &f32;
    fn min_speed_for_mine_activation_mut(&mut self) -> &mut f32;
    fn trigger_vehicle_detonation(&self) -> &bool;
    fn trigger_vehicle_detonation_mut(&mut self) -> &mut bool;
    fn upside_down_damage(&self) -> &f32;
    fn upside_down_damage_mut(&mut self) -> &mut f32;
    fn upside_down_damage_delay(&self) -> &f32;
    fn upside_down_damage_delay_mut(&mut self) -> &mut f32;
    fn upside_down_angle(&self) -> &f32;
    fn upside_down_angle_mut(&mut self) -> &mut f32;
    fn water_damage(&self) -> &f32;
    fn water_damage_mut(&mut self) -> &mut f32;
    fn below_water_damage_delay(&self) -> &f32;
    fn below_water_damage_delay_mut(&mut self) -> &mut f32;
    fn water_damage_offset(&self) -> &f32;
    fn water_damage_offset_mut(&mut self) -> &mut f32;
    fn is_affected_by_e_m_p(&self) -> &bool;
    fn is_affected_by_e_m_p_mut(&mut self) -> &mut bool;
    fn velocity_damage_threshold(&self) -> &f32;
    fn velocity_damage_threshold_mut(&mut self) -> &mut f32;
    fn velocity_damage_magnifier(&self) -> &f32;
    fn velocity_damage_magnifier_mut(&mut self) -> &mut f32;
    fn can_take_dynamic_fire_damage(&self) -> &bool;
    fn can_take_dynamic_fire_damage_mut(&mut self) -> &mut bool;
    fn always_deal_collision_damage(&self) -> &bool;
    fn always_deal_collision_damage_mut(&mut self) -> &mut bool;
    fn has_exclusive_entries(&self) -> &bool;
    fn has_exclusive_entries_mut(&mut self) -> &mut bool;
    fn prohibit_entry_switching(&self) -> &bool;
    fn prohibit_entry_switching_mut(&mut self) -> &mut bool;
    fn throw_out_soldier_inside_on_water_damage(&self) -> &bool;
    fn throw_out_soldier_inside_on_water_damage_mut(&mut self) -> &mut bool;
    fn kill_soldier_collision_speed_threshold(&self) -> &f32;
    fn kill_soldier_collision_speed_threshold_mut(&mut self) -> &mut f32;
    fn kill_soldier_collision_speed_threshold_block_time(&self) -> &f32;
    fn kill_soldier_collision_speed_threshold_block_time_mut(&mut self) -> &mut f32;
    fn ignore_soldier_collision_normal(&self) -> &bool;
    fn ignore_soldier_collision_normal_mut(&mut self) -> &mut bool;
    fn chose_exit_point_by_direction(&self) -> &bool;
    fn chose_exit_point_by_direction_mut(&mut self) -> &mut bool;
    fn exit_speed_threshold(&self) -> &f32;
    fn exit_speed_threshold_mut(&mut self) -> &mut f32;
    fn exit_direction_speed_threshold(&self) -> &f32;
    fn exit_direction_speed_threshold_mut(&mut self) -> &mut f32;
    fn enter_allowed(&self) -> &bool;
    fn enter_allowed_mut(&mut self) -> &mut bool;
    fn exit_allowed(&self) -> &bool;
    fn exit_allowed_mut(&mut self) -> &mut bool;
    fn enable_groundmap_lighting(&self) -> &bool;
    fn enable_groundmap_lighting_mut(&mut self) -> &mut bool;
    fn use_as_team_spawner(&self) -> &bool;
    fn use_as_team_spawner_mut(&mut self) -> &mut bool;
    fn f_l_i_r_value(&self) -> &f32;
    fn f_l_i_r_value_mut(&mut self) -> &mut f32;
    fn f_l_i_r_key_color(&self) -> &super::core::Vec3;
    fn f_l_i_r_key_color_mut(&mut self) -> &mut super::core::Vec3;
    fn m_p_mode(&self) -> &MPModeData;
    fn m_p_mode_mut(&mut self) -> &mut MPModeData;
    fn exit_camera_switch_delay(&self) -> &f32;
    fn exit_camera_switch_delay_mut(&mut self) -> &mut f32;
    fn angle_of_impact(&self) -> &AngleOfImpactData;
    fn angle_of_impact_mut(&mut self) -> &mut AngleOfImpactData;
    fn is_lockable(&self) -> &bool;
    fn is_lockable_mut(&mut self) -> &mut bool;
    fn locking_time_multiplier(&self) -> &f32;
    fn locking_time_multiplier_mut(&mut self) -> &mut f32;
    fn vehicle_lockable_info(&self) -> &VehicleLockableInfoData;
    fn vehicle_lockable_info_mut(&mut self) -> &mut VehicleLockableInfoData;
    fn never_report_vehicle_as_empty(&self) -> &bool;
    fn never_report_vehicle_as_empty_mut(&mut self) -> &mut bool;
    fn a_i_target(&self) -> &bool;
    fn a_i_target_mut(&mut self) -> &mut bool;
    fn high_altitude_lock_height(&self) -> &f32;
    fn high_altitude_lock_height_mut(&mut self) -> &mut f32;
    fn use_low_altitude_heat_signature(&self) -> &bool;
    fn use_low_altitude_heat_signature_mut(&mut self) -> &mut bool;
    fn sound(&self) -> &Option<LockedTypeObject /* VehicleSoundData */>;
    fn sound_mut(&mut self) -> &mut Option<LockedTypeObject /* VehicleSoundData */>;
    fn voice_over_info(&self) -> &Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */>;
    fn voice_over_info_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */>;
    fn nametag_height_scale(&self) -> &f32;
    fn nametag_height_scale_mut(&mut self) -> &mut f32;
    fn spotting_fov_scale(&self) -> &f32;
    fn spotting_fov_scale_mut(&mut self) -> &mut f32;
    fn use_spotting_target_component_for_raycast(&self) -> &bool;
    fn use_spotting_target_component_for_raycast_mut(&mut self) -> &mut bool;
    fn interaction_offset(&self) -> &super::core::Vec3;
    fn interaction_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn equipment_fake_vehicle(&self) -> &bool;
    fn equipment_fake_vehicle_mut(&mut self) -> &mut bool;
    fn explosion_packs_attachable(&self) -> &bool;
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool;
    fn character_blueprint_override(&self) -> &Option<LockedTypeObject /* CharacterBlueprint */>;
    fn character_blueprint_override_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterBlueprint */>;
    fn damage_giver_override_owner_vehicle(&self) -> &bool;
    fn damage_giver_override_owner_vehicle_mut(&mut self) -> &mut bool;
    fn enable_sub_realm(&self) -> &bool;
    fn enable_sub_realm_mut(&mut self) -> &mut bool;
    fn causes_a_i_to_flee(&self) -> &bool;
    fn causes_a_i_to_flee_mut(&mut self) -> &mut bool;
    fn a_i_flee_radius(&self) -> &f32;
    fn a_i_flee_radius_mut(&mut self) -> &mut f32;
    fn a_i_sound_category(&self) -> &AIVehicleSoundCategory;
    fn a_i_sound_category_mut(&mut self) -> &mut AIVehicleSoundCategory;
    fn victim_offset_override(&self) -> &super::core::Vec3;
    fn victim_offset_override_mut(&mut self) -> &mut super::core::Vec3;
}

impl VehicleEntityDataTrait for VehicleEntityData {
    fn controllable_type(&self) -> &String {
        &self.controllable_type
    }
    fn controllable_type_mut(&mut self) -> &mut String {
        &mut self.controllable_type
    }
    fn allow_vehicle_outside_combat_areas(&self) -> &bool {
        &self.allow_vehicle_outside_combat_areas
    }
    fn allow_vehicle_outside_combat_areas_mut(&mut self) -> &mut bool {
        &mut self.allow_vehicle_outside_combat_areas
    }
    fn disabled_damage_threshold(&self) -> &f32 {
        &self.disabled_damage_threshold
    }
    fn disabled_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.disabled_damage_threshold
    }
    fn pre_destruction_damage_threshold(&self) -> &f32 {
        &self.pre_destruction_damage_threshold
    }
    fn pre_destruction_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.pre_destruction_damage_threshold
    }
    fn front_health_zone(&self) -> &VehicleHealthZoneData {
        &self.front_health_zone
    }
    fn front_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.front_health_zone
    }
    fn rear_health_zone(&self) -> &VehicleHealthZoneData {
        &self.rear_health_zone
    }
    fn rear_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.rear_health_zone
    }
    fn left_health_zone(&self) -> &VehicleHealthZoneData {
        &self.left_health_zone
    }
    fn left_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.left_health_zone
    }
    fn right_health_zone(&self) -> &VehicleHealthZoneData {
        &self.right_health_zone
    }
    fn right_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.right_health_zone
    }
    fn top_health_zone(&self) -> &VehicleHealthZoneData {
        &self.top_health_zone
    }
    fn top_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.top_health_zone
    }
    fn use_top_zone(&self) -> &bool {
        &self.use_top_zone
    }
    fn use_top_zone_mut(&mut self) -> &mut bool {
        &mut self.use_top_zone
    }
    fn top_hit_height(&self) -> &f32 {
        &self.top_hit_height
    }
    fn top_hit_height_mut(&mut self) -> &mut f32 {
        &mut self.top_hit_height
    }
    fn top_hit_angle(&self) -> &f32 {
        &self.top_hit_angle
    }
    fn top_hit_angle_mut(&mut self) -> &mut f32 {
        &mut self.top_hit_angle
    }
    fn health_zones_share_damage(&self) -> &bool {
        &self.health_zones_share_damage
    }
    fn health_zones_share_damage_mut(&mut self) -> &mut bool {
        &mut self.health_zones_share_damage
    }
    fn regeneration_delay(&self) -> &f32 {
        &self.regeneration_delay
    }
    fn regeneration_delay_mut(&mut self) -> &mut f32 {
        &mut self.regeneration_delay
    }
    fn regeneration_rate(&self) -> &f32 {
        &self.regeneration_rate
    }
    fn regeneration_rate_mut(&mut self) -> &mut f32 {
        &mut self.regeneration_rate
    }
    fn use_protected_shields(&self) -> &bool {
        &self.use_protected_shields
    }
    fn use_protected_shields_mut(&mut self) -> &mut bool {
        &mut self.use_protected_shields
    }
    fn armor_multiplier(&self) -> &f32 {
        &self.armor_multiplier
    }
    fn armor_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.armor_multiplier
    }
    fn regeneration_delay_multiplier(&self) -> &f32 {
        &self.regeneration_delay_multiplier
    }
    fn regeneration_delay_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.regeneration_delay_multiplier
    }
    fn regeneration_rate_multiplier(&self) -> &f32 {
        &self.regeneration_rate_multiplier
    }
    fn regeneration_rate_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.regeneration_rate_multiplier
    }
    fn emergency_repair_health(&self) -> &f32 {
        &self.emergency_repair_health
    }
    fn emergency_repair_health_mut(&mut self) -> &mut f32 {
        &mut self.emergency_repair_health
    }
    fn decay_delay(&self) -> &f32 {
        &self.decay_delay
    }
    fn decay_delay_mut(&mut self) -> &mut f32 {
        &mut self.decay_delay
    }
    fn decay_rate(&self) -> &f32 {
        &self.decay_rate
    }
    fn decay_rate_mut(&mut self) -> &mut f32 {
        &mut self.decay_rate
    }
    fn show_player_health(&self) -> &bool {
        &self.show_player_health
    }
    fn show_player_health_mut(&mut self) -> &mut bool {
        &mut self.show_player_health
    }
    fn use_self_for_self_destruct(&self) -> &bool {
        &self.use_self_for_self_destruct
    }
    fn use_self_for_self_destruct_mut(&mut self) -> &mut bool {
        &mut self.use_self_for_self_destruct
    }
    fn critically_damaged_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &self.critically_damaged_effect
    }
    fn critically_damaged_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &mut self.critically_damaged_effect
    }
    fn critically_damaged_effect_position(&self) -> &super::core::Vec3 {
        &self.critically_damaged_effect_position
    }
    fn critically_damaged_effect_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.critically_damaged_effect_position
    }
    fn critical_damage_time(&self) -> &f32 {
        &self.critical_damage_time
    }
    fn critical_damage_time_mut(&mut self) -> &mut f32 {
        &mut self.critical_damage_time
    }
    fn pre_explosion_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &self.pre_explosion_effect
    }
    fn pre_explosion_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &mut self.pre_explosion_effect
    }
    fn pre_explosion_effect_position(&self) -> &super::core::Vec3 {
        &self.pre_explosion_effect_position
    }
    fn pre_explosion_effect_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.pre_explosion_effect_position
    }
    fn pre_explosion_time(&self) -> &f32 {
        &self.pre_explosion_time
    }
    fn pre_explosion_time_mut(&mut self) -> &mut f32 {
        &mut self.pre_explosion_time
    }
    fn bypass_pre_destruction(&self) -> &bool {
        &self.bypass_pre_destruction
    }
    fn bypass_pre_destruction_mut(&mut self) -> &mut bool {
        &mut self.bypass_pre_destruction
    }
    fn random_pre_destruction(&self) -> &bool {
        &self.random_pre_destruction
    }
    fn random_pre_destruction_mut(&mut self) -> &mut bool {
        &mut self.random_pre_destruction
    }
    fn explosion(&self) -> &Option<LockedTypeObject /* ExplosionEntityData */> {
        &self.explosion
    }
    fn explosion_mut(&mut self) -> &mut Option<LockedTypeObject /* ExplosionEntityData */> {
        &mut self.explosion
    }
    fn abandoned_explosion_damage_multiplier(&self) -> &f32 {
        &self.abandoned_explosion_damage_multiplier
    }
    fn abandoned_explosion_damage_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.abandoned_explosion_damage_multiplier
    }
    fn mesh_type(&self) -> &super::render_base::MeshType {
        &self.mesh_type
    }
    fn mesh_type_mut(&mut self) -> &mut super::render_base::MeshType {
        &mut self.mesh_type
    }
    fn mesh_part_count(&self) -> &u32 {
        &self.mesh_part_count
    }
    fn mesh_part_count_mut(&mut self) -> &mut u32 {
        &mut self.mesh_part_count
    }
    fn foreground_render_cockpit_mesh(&self) -> &bool {
        &self.foreground_render_cockpit_mesh
    }
    fn foreground_render_cockpit_mesh_mut(&mut self) -> &mut bool {
        &mut self.foreground_render_cockpit_mesh
    }
    fn motion_blur_mask(&self) -> &bool {
        &self.motion_blur_mask
    }
    fn motion_blur_mask_mut(&mut self) -> &mut bool {
        &mut self.motion_blur_mask
    }
    fn suppress_damage_by_passengers(&self) -> &bool {
        &self.suppress_damage_by_passengers
    }
    fn suppress_damage_by_passengers_mut(&mut self) -> &mut bool {
        &mut self.suppress_damage_by_passengers
    }
    fn hud_data(&self) -> &VehicleHudData {
        &self.hud_data
    }
    fn hud_data_mut(&mut self) -> &mut VehicleHudData {
        &mut self.hud_data
    }
    fn name_sid(&self) -> &String {
        &self.name_sid
    }
    fn name_sid_mut(&mut self) -> &mut String {
        &mut self.name_sid
    }
    fn max_players_in_vehicle(&self) -> &i32 {
        &self.max_players_in_vehicle
    }
    fn max_players_in_vehicle_mut(&mut self) -> &mut i32 {
        &mut self.max_players_in_vehicle
    }
    fn min_speed_for_mine_activation(&self) -> &f32 {
        &self.min_speed_for_mine_activation
    }
    fn min_speed_for_mine_activation_mut(&mut self) -> &mut f32 {
        &mut self.min_speed_for_mine_activation
    }
    fn trigger_vehicle_detonation(&self) -> &bool {
        &self.trigger_vehicle_detonation
    }
    fn trigger_vehicle_detonation_mut(&mut self) -> &mut bool {
        &mut self.trigger_vehicle_detonation
    }
    fn upside_down_damage(&self) -> &f32 {
        &self.upside_down_damage
    }
    fn upside_down_damage_mut(&mut self) -> &mut f32 {
        &mut self.upside_down_damage
    }
    fn upside_down_damage_delay(&self) -> &f32 {
        &self.upside_down_damage_delay
    }
    fn upside_down_damage_delay_mut(&mut self) -> &mut f32 {
        &mut self.upside_down_damage_delay
    }
    fn upside_down_angle(&self) -> &f32 {
        &self.upside_down_angle
    }
    fn upside_down_angle_mut(&mut self) -> &mut f32 {
        &mut self.upside_down_angle
    }
    fn water_damage(&self) -> &f32 {
        &self.water_damage
    }
    fn water_damage_mut(&mut self) -> &mut f32 {
        &mut self.water_damage
    }
    fn below_water_damage_delay(&self) -> &f32 {
        &self.below_water_damage_delay
    }
    fn below_water_damage_delay_mut(&mut self) -> &mut f32 {
        &mut self.below_water_damage_delay
    }
    fn water_damage_offset(&self) -> &f32 {
        &self.water_damage_offset
    }
    fn water_damage_offset_mut(&mut self) -> &mut f32 {
        &mut self.water_damage_offset
    }
    fn is_affected_by_e_m_p(&self) -> &bool {
        &self.is_affected_by_e_m_p
    }
    fn is_affected_by_e_m_p_mut(&mut self) -> &mut bool {
        &mut self.is_affected_by_e_m_p
    }
    fn velocity_damage_threshold(&self) -> &f32 {
        &self.velocity_damage_threshold
    }
    fn velocity_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.velocity_damage_threshold
    }
    fn velocity_damage_magnifier(&self) -> &f32 {
        &self.velocity_damage_magnifier
    }
    fn velocity_damage_magnifier_mut(&mut self) -> &mut f32 {
        &mut self.velocity_damage_magnifier
    }
    fn can_take_dynamic_fire_damage(&self) -> &bool {
        &self.can_take_dynamic_fire_damage
    }
    fn can_take_dynamic_fire_damage_mut(&mut self) -> &mut bool {
        &mut self.can_take_dynamic_fire_damage
    }
    fn always_deal_collision_damage(&self) -> &bool {
        &self.always_deal_collision_damage
    }
    fn always_deal_collision_damage_mut(&mut self) -> &mut bool {
        &mut self.always_deal_collision_damage
    }
    fn has_exclusive_entries(&self) -> &bool {
        &self.has_exclusive_entries
    }
    fn has_exclusive_entries_mut(&mut self) -> &mut bool {
        &mut self.has_exclusive_entries
    }
    fn prohibit_entry_switching(&self) -> &bool {
        &self.prohibit_entry_switching
    }
    fn prohibit_entry_switching_mut(&mut self) -> &mut bool {
        &mut self.prohibit_entry_switching
    }
    fn throw_out_soldier_inside_on_water_damage(&self) -> &bool {
        &self.throw_out_soldier_inside_on_water_damage
    }
    fn throw_out_soldier_inside_on_water_damage_mut(&mut self) -> &mut bool {
        &mut self.throw_out_soldier_inside_on_water_damage
    }
    fn kill_soldier_collision_speed_threshold(&self) -> &f32 {
        &self.kill_soldier_collision_speed_threshold
    }
    fn kill_soldier_collision_speed_threshold_mut(&mut self) -> &mut f32 {
        &mut self.kill_soldier_collision_speed_threshold
    }
    fn kill_soldier_collision_speed_threshold_block_time(&self) -> &f32 {
        &self.kill_soldier_collision_speed_threshold_block_time
    }
    fn kill_soldier_collision_speed_threshold_block_time_mut(&mut self) -> &mut f32 {
        &mut self.kill_soldier_collision_speed_threshold_block_time
    }
    fn ignore_soldier_collision_normal(&self) -> &bool {
        &self.ignore_soldier_collision_normal
    }
    fn ignore_soldier_collision_normal_mut(&mut self) -> &mut bool {
        &mut self.ignore_soldier_collision_normal
    }
    fn chose_exit_point_by_direction(&self) -> &bool {
        &self.chose_exit_point_by_direction
    }
    fn chose_exit_point_by_direction_mut(&mut self) -> &mut bool {
        &mut self.chose_exit_point_by_direction
    }
    fn exit_speed_threshold(&self) -> &f32 {
        &self.exit_speed_threshold
    }
    fn exit_speed_threshold_mut(&mut self) -> &mut f32 {
        &mut self.exit_speed_threshold
    }
    fn exit_direction_speed_threshold(&self) -> &f32 {
        &self.exit_direction_speed_threshold
    }
    fn exit_direction_speed_threshold_mut(&mut self) -> &mut f32 {
        &mut self.exit_direction_speed_threshold
    }
    fn enter_allowed(&self) -> &bool {
        &self.enter_allowed
    }
    fn enter_allowed_mut(&mut self) -> &mut bool {
        &mut self.enter_allowed
    }
    fn exit_allowed(&self) -> &bool {
        &self.exit_allowed
    }
    fn exit_allowed_mut(&mut self) -> &mut bool {
        &mut self.exit_allowed
    }
    fn enable_groundmap_lighting(&self) -> &bool {
        &self.enable_groundmap_lighting
    }
    fn enable_groundmap_lighting_mut(&mut self) -> &mut bool {
        &mut self.enable_groundmap_lighting
    }
    fn use_as_team_spawner(&self) -> &bool {
        &self.use_as_team_spawner
    }
    fn use_as_team_spawner_mut(&mut self) -> &mut bool {
        &mut self.use_as_team_spawner
    }
    fn f_l_i_r_value(&self) -> &f32 {
        &self.f_l_i_r_value
    }
    fn f_l_i_r_value_mut(&mut self) -> &mut f32 {
        &mut self.f_l_i_r_value
    }
    fn f_l_i_r_key_color(&self) -> &super::core::Vec3 {
        &self.f_l_i_r_key_color
    }
    fn f_l_i_r_key_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.f_l_i_r_key_color
    }
    fn m_p_mode(&self) -> &MPModeData {
        &self.m_p_mode
    }
    fn m_p_mode_mut(&mut self) -> &mut MPModeData {
        &mut self.m_p_mode
    }
    fn exit_camera_switch_delay(&self) -> &f32 {
        &self.exit_camera_switch_delay
    }
    fn exit_camera_switch_delay_mut(&mut self) -> &mut f32 {
        &mut self.exit_camera_switch_delay
    }
    fn angle_of_impact(&self) -> &AngleOfImpactData {
        &self.angle_of_impact
    }
    fn angle_of_impact_mut(&mut self) -> &mut AngleOfImpactData {
        &mut self.angle_of_impact
    }
    fn is_lockable(&self) -> &bool {
        &self.is_lockable
    }
    fn is_lockable_mut(&mut self) -> &mut bool {
        &mut self.is_lockable
    }
    fn locking_time_multiplier(&self) -> &f32 {
        &self.locking_time_multiplier
    }
    fn locking_time_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.locking_time_multiplier
    }
    fn vehicle_lockable_info(&self) -> &VehicleLockableInfoData {
        &self.vehicle_lockable_info
    }
    fn vehicle_lockable_info_mut(&mut self) -> &mut VehicleLockableInfoData {
        &mut self.vehicle_lockable_info
    }
    fn never_report_vehicle_as_empty(&self) -> &bool {
        &self.never_report_vehicle_as_empty
    }
    fn never_report_vehicle_as_empty_mut(&mut self) -> &mut bool {
        &mut self.never_report_vehicle_as_empty
    }
    fn a_i_target(&self) -> &bool {
        &self.a_i_target
    }
    fn a_i_target_mut(&mut self) -> &mut bool {
        &mut self.a_i_target
    }
    fn high_altitude_lock_height(&self) -> &f32 {
        &self.high_altitude_lock_height
    }
    fn high_altitude_lock_height_mut(&mut self) -> &mut f32 {
        &mut self.high_altitude_lock_height
    }
    fn use_low_altitude_heat_signature(&self) -> &bool {
        &self.use_low_altitude_heat_signature
    }
    fn use_low_altitude_heat_signature_mut(&mut self) -> &mut bool {
        &mut self.use_low_altitude_heat_signature
    }
    fn sound(&self) -> &Option<LockedTypeObject /* VehicleSoundData */> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<LockedTypeObject /* VehicleSoundData */> {
        &mut self.sound
    }
    fn voice_over_info(&self) -> &Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */> {
        &self.voice_over_info
    }
    fn voice_over_info_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::EntityVoiceOverInfo */> {
        &mut self.voice_over_info
    }
    fn nametag_height_scale(&self) -> &f32 {
        &self.nametag_height_scale
    }
    fn nametag_height_scale_mut(&mut self) -> &mut f32 {
        &mut self.nametag_height_scale
    }
    fn spotting_fov_scale(&self) -> &f32 {
        &self.spotting_fov_scale
    }
    fn spotting_fov_scale_mut(&mut self) -> &mut f32 {
        &mut self.spotting_fov_scale
    }
    fn use_spotting_target_component_for_raycast(&self) -> &bool {
        &self.use_spotting_target_component_for_raycast
    }
    fn use_spotting_target_component_for_raycast_mut(&mut self) -> &mut bool {
        &mut self.use_spotting_target_component_for_raycast
    }
    fn interaction_offset(&self) -> &super::core::Vec3 {
        &self.interaction_offset
    }
    fn interaction_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.interaction_offset
    }
    fn equipment_fake_vehicle(&self) -> &bool {
        &self.equipment_fake_vehicle
    }
    fn equipment_fake_vehicle_mut(&mut self) -> &mut bool {
        &mut self.equipment_fake_vehicle
    }
    fn explosion_packs_attachable(&self) -> &bool {
        &self.explosion_packs_attachable
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        &mut self.explosion_packs_attachable
    }
    fn character_blueprint_override(&self) -> &Option<LockedTypeObject /* CharacterBlueprint */> {
        &self.character_blueprint_override
    }
    fn character_blueprint_override_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterBlueprint */> {
        &mut self.character_blueprint_override
    }
    fn damage_giver_override_owner_vehicle(&self) -> &bool {
        &self.damage_giver_override_owner_vehicle
    }
    fn damage_giver_override_owner_vehicle_mut(&mut self) -> &mut bool {
        &mut self.damage_giver_override_owner_vehicle
    }
    fn enable_sub_realm(&self) -> &bool {
        &self.enable_sub_realm
    }
    fn enable_sub_realm_mut(&mut self) -> &mut bool {
        &mut self.enable_sub_realm
    }
    fn causes_a_i_to_flee(&self) -> &bool {
        &self.causes_a_i_to_flee
    }
    fn causes_a_i_to_flee_mut(&mut self) -> &mut bool {
        &mut self.causes_a_i_to_flee
    }
    fn a_i_flee_radius(&self) -> &f32 {
        &self.a_i_flee_radius
    }
    fn a_i_flee_radius_mut(&mut self) -> &mut f32 {
        &mut self.a_i_flee_radius
    }
    fn a_i_sound_category(&self) -> &AIVehicleSoundCategory {
        &self.a_i_sound_category
    }
    fn a_i_sound_category_mut(&mut self) -> &mut AIVehicleSoundCategory {
        &mut self.a_i_sound_category
    }
    fn victim_offset_override(&self) -> &super::core::Vec3 {
        &self.victim_offset_override
    }
    fn victim_offset_override_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.victim_offset_override
    }
}

impl super::gameplay_sim::ControllableEntityDataTrait for VehicleEntityData {
    fn use_prediction(&self) -> &bool {
        self._glacier_base.use_prediction()
    }
    fn use_prediction_mut(&mut self) -> &mut bool {
        self._glacier_base.use_prediction_mut()
    }
    fn default_team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.default_team()
    }
    fn default_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.default_team_mut()
    }
    fn reset_team_on_last_player_exits(&self) -> &bool {
        self._glacier_base.reset_team_on_last_player_exits()
    }
    fn reset_team_on_last_player_exits_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_team_on_last_player_exits_mut()
    }
    fn immortal(&self) -> &bool {
        self._glacier_base.immortal()
    }
    fn immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.immortal_mut()
    }
    fn fake_immortal(&self) -> &bool {
        self._glacier_base.fake_immortal()
    }
    fn fake_immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.fake_immortal_mut()
    }
    fn low_health_threshold(&self) -> &f32 {
        self._glacier_base.low_health_threshold()
    }
    fn low_health_threshold_mut(&mut self) -> &mut f32 {
        self._glacier_base.low_health_threshold_mut()
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        self._glacier_base.material_pair()
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        self._glacier_base.material_pair_mut()
    }
    fn force_foreground_rendering(&self) -> &bool {
        self._glacier_base.force_foreground_rendering()
    }
    fn force_foreground_rendering_mut(&mut self) -> &mut bool {
        self._glacier_base.force_foreground_rendering_mut()
    }
    fn suppressed_inputs(&self) -> &Vec<i32> {
        self._glacier_base.suppressed_inputs()
    }
    fn suppressed_inputs_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.suppressed_inputs_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for VehicleEntityData {
}

impl super::entity::GameComponentEntityDataTrait for VehicleEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for VehicleEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for VehicleEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for VehicleEntityData {
}

impl super::entity::GameObjectDataTrait for VehicleEntityData {
}

impl super::core::DataBusPeerTrait for VehicleEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleEntityData {
}

impl super::core::DataContainerTrait for VehicleEntityData {
}

pub static VEHICLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntityData",
    name_hash: 266823830,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntityData as Default>::default())),
            create_boxed: || Box::new(<VehicleEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ControllableType",
                name_hash: 1363023004,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VehicleEntityData, controllable_type),
            },
            FieldInfoData {
                name: "AllowVehicleOutsideCombatAreas",
                name_hash: 4259780355,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, allow_vehicle_outside_combat_areas),
            },
            FieldInfoData {
                name: "DisabledDamageThreshold",
                name_hash: 3318533033,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, disabled_damage_threshold),
            },
            FieldInfoData {
                name: "PreDestructionDamageThreshold",
                name_hash: 2383353120,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, pre_destruction_damage_threshold),
            },
            FieldInfoData {
                name: "FrontHealthZone",
                name_hash: 2276895046,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, front_health_zone),
            },
            FieldInfoData {
                name: "RearHealthZone",
                name_hash: 3627622819,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, rear_health_zone),
            },
            FieldInfoData {
                name: "LeftHealthZone",
                name_hash: 3030125852,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, left_health_zone),
            },
            FieldInfoData {
                name: "RightHealthZone",
                name_hash: 2832264487,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, right_health_zone),
            },
            FieldInfoData {
                name: "TopHealthZone",
                name_hash: 1902150956,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, top_health_zone),
            },
            FieldInfoData {
                name: "UseTopZone",
                name_hash: 546015187,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_top_zone),
            },
            FieldInfoData {
                name: "TopHitHeight",
                name_hash: 3456381732,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, top_hit_height),
            },
            FieldInfoData {
                name: "TopHitAngle",
                name_hash: 2587655194,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, top_hit_angle),
            },
            FieldInfoData {
                name: "HealthZonesShareDamage",
                name_hash: 4208633362,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, health_zones_share_damage),
            },
            FieldInfoData {
                name: "RegenerationDelay",
                name_hash: 778753505,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, regeneration_delay),
            },
            FieldInfoData {
                name: "RegenerationRate",
                name_hash: 3407288278,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, regeneration_rate),
            },
            FieldInfoData {
                name: "UseProtectedShields",
                name_hash: 3998576672,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_protected_shields),
            },
            FieldInfoData {
                name: "ArmorMultiplier",
                name_hash: 3612687949,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, armor_multiplier),
            },
            FieldInfoData {
                name: "RegenerationDelayMultiplier",
                name_hash: 2331689578,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, regeneration_delay_multiplier),
            },
            FieldInfoData {
                name: "RegenerationRateMultiplier",
                name_hash: 2044311709,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, regeneration_rate_multiplier),
            },
            FieldInfoData {
                name: "EmergencyRepairHealth",
                name_hash: 2646266061,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, emergency_repair_health),
            },
            FieldInfoData {
                name: "DecayDelay",
                name_hash: 696940618,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, decay_delay),
            },
            FieldInfoData {
                name: "DecayRate",
                name_hash: 3274236317,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, decay_rate),
            },
            FieldInfoData {
                name: "ShowPlayerHealth",
                name_hash: 1579764169,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, show_player_health),
            },
            FieldInfoData {
                name: "UseSelfForSelfDestruct",
                name_hash: 2794469259,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_self_for_self_destruct),
            },
            FieldInfoData {
                name: "CriticallyDamagedEffect",
                name_hash: 3947288579,
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(VehicleEntityData, critically_damaged_effect),
            },
            FieldInfoData {
                name: "CriticallyDamagedEffectPosition",
                name_hash: 1856265210,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, critically_damaged_effect_position),
            },
            FieldInfoData {
                name: "CriticalDamageTime",
                name_hash: 859585936,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, critical_damage_time),
            },
            FieldInfoData {
                name: "PreExplosionEffect",
                name_hash: 2795974848,
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(VehicleEntityData, pre_explosion_effect),
            },
            FieldInfoData {
                name: "PreExplosionEffectPosition",
                name_hash: 2935241977,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, pre_explosion_effect_position),
            },
            FieldInfoData {
                name: "PreExplosionTime",
                name_hash: 3054583394,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, pre_explosion_time),
            },
            FieldInfoData {
                name: "BypassPreDestruction",
                name_hash: 4244356438,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, bypass_pre_destruction),
            },
            FieldInfoData {
                name: "RandomPreDestruction",
                name_hash: 2871501575,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, random_pre_destruction),
            },
            FieldInfoData {
                name: "Explosion",
                name_hash: 2222171184,
                flags: MemberInfoFlags::new(0),
                field_type: "ExplosionEntityData",
                rust_offset: offset_of!(VehicleEntityData, explosion),
            },
            FieldInfoData {
                name: "AbandonedExplosionDamageMultiplier",
                name_hash: 3556863736,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, abandoned_explosion_damage_multiplier),
            },
            FieldInfoData {
                name: "MeshType",
                name_hash: 1821946062,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshType",
                rust_offset: offset_of!(VehicleEntityData, mesh_type),
            },
            FieldInfoData {
                name: "MeshPartCount",
                name_hash: 3449407426,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleEntityData, mesh_part_count),
            },
            FieldInfoData {
                name: "ForegroundRenderCockpitMesh",
                name_hash: 1107408366,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, foreground_render_cockpit_mesh),
            },
            FieldInfoData {
                name: "MotionBlurMask",
                name_hash: 3803525894,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, motion_blur_mask),
            },
            FieldInfoData {
                name: "SuppressDamageByPassengers",
                name_hash: 1567030525,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, suppress_damage_by_passengers),
            },
            FieldInfoData {
                name: "HudData",
                name_hash: 2639805868,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHudData",
                rust_offset: offset_of!(VehicleEntityData, hud_data),
            },
            FieldInfoData {
                name: "NameSid",
                name_hash: 3153745340,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VehicleEntityData, name_sid),
            },
            FieldInfoData {
                name: "MaxPlayersInVehicle",
                name_hash: 3678083790,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleEntityData, max_players_in_vehicle),
            },
            FieldInfoData {
                name: "MinSpeedForMineActivation",
                name_hash: 339948744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, min_speed_for_mine_activation),
            },
            FieldInfoData {
                name: "TriggerVehicleDetonation",
                name_hash: 2973676940,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, trigger_vehicle_detonation),
            },
            FieldInfoData {
                name: "UpsideDownDamage",
                name_hash: 4107473026,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, upside_down_damage),
            },
            FieldInfoData {
                name: "UpsideDownDamageDelay",
                name_hash: 1848412439,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, upside_down_damage_delay),
            },
            FieldInfoData {
                name: "UpsideDownAngle",
                name_hash: 511050632,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, upside_down_angle),
            },
            FieldInfoData {
                name: "WaterDamage",
                name_hash: 470266331,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, water_damage),
            },
            FieldInfoData {
                name: "BelowWaterDamageDelay",
                name_hash: 2319914781,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, below_water_damage_delay),
            },
            FieldInfoData {
                name: "WaterDamageOffset",
                name_hash: 559085046,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, water_damage_offset),
            },
            FieldInfoData {
                name: "IsAffectedByEMP",
                name_hash: 2093965006,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, is_affected_by_e_m_p),
            },
            FieldInfoData {
                name: "VelocityDamageThreshold",
                name_hash: 3583792430,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, velocity_damage_threshold),
            },
            FieldInfoData {
                name: "VelocityDamageMagnifier",
                name_hash: 489897037,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, velocity_damage_magnifier),
            },
            FieldInfoData {
                name: "CanTakeDynamicFireDamage",
                name_hash: 4011405428,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, can_take_dynamic_fire_damage),
            },
            FieldInfoData {
                name: "AlwaysDealCollisionDamage",
                name_hash: 1629537165,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, always_deal_collision_damage),
            },
            FieldInfoData {
                name: "HasExclusiveEntries",
                name_hash: 2252490243,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, has_exclusive_entries),
            },
            FieldInfoData {
                name: "ProhibitEntrySwitching",
                name_hash: 231041776,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, prohibit_entry_switching),
            },
            FieldInfoData {
                name: "ThrowOutSoldierInsideOnWaterDamage",
                name_hash: 1661389364,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, throw_out_soldier_inside_on_water_damage),
            },
            FieldInfoData {
                name: "KillSoldierCollisionSpeedThreshold",
                name_hash: 3028123395,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, kill_soldier_collision_speed_threshold),
            },
            FieldInfoData {
                name: "KillSoldierCollisionSpeedThresholdBlockTime",
                name_hash: 281749535,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, kill_soldier_collision_speed_threshold_block_time),
            },
            FieldInfoData {
                name: "IgnoreSoldierCollisionNormal",
                name_hash: 1916568890,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, ignore_soldier_collision_normal),
            },
            FieldInfoData {
                name: "ChoseExitPointByDirection",
                name_hash: 775582885,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, chose_exit_point_by_direction),
            },
            FieldInfoData {
                name: "ExitSpeedThreshold",
                name_hash: 1049184085,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, exit_speed_threshold),
            },
            FieldInfoData {
                name: "ExitDirectionSpeedThreshold",
                name_hash: 1613225104,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, exit_direction_speed_threshold),
            },
            FieldInfoData {
                name: "EnterAllowed",
                name_hash: 4155915125,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, enter_allowed),
            },
            FieldInfoData {
                name: "ExitAllowed",
                name_hash: 1004482141,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, exit_allowed),
            },
            FieldInfoData {
                name: "EnableGroundmapLighting",
                name_hash: 1278245411,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, enable_groundmap_lighting),
            },
            FieldInfoData {
                name: "UseAsTeamSpawner",
                name_hash: 1433904997,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_as_team_spawner),
            },
            FieldInfoData {
                name: "FLIRValue",
                name_hash: 3325471103,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, f_l_i_r_value),
            },
            FieldInfoData {
                name: "FLIRKeyColor",
                name_hash: 844334526,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, f_l_i_r_key_color),
            },
            FieldInfoData {
                name: "MPMode",
                name_hash: 2699506811,
                flags: MemberInfoFlags::new(0),
                field_type: "MPModeData",
                rust_offset: offset_of!(VehicleEntityData, m_p_mode),
            },
            FieldInfoData {
                name: "ExitCameraSwitchDelay",
                name_hash: 774785883,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, exit_camera_switch_delay),
            },
            FieldInfoData {
                name: "AngleOfImpact",
                name_hash: 2658042767,
                flags: MemberInfoFlags::new(0),
                field_type: "AngleOfImpactData",
                rust_offset: offset_of!(VehicleEntityData, angle_of_impact),
            },
            FieldInfoData {
                name: "IsLockable",
                name_hash: 3657214078,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, is_lockable),
            },
            FieldInfoData {
                name: "LockingTimeMultiplier",
                name_hash: 1983394672,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, locking_time_multiplier),
            },
            FieldInfoData {
                name: "VehicleLockableInfo",
                name_hash: 3058902738,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleLockableInfoData",
                rust_offset: offset_of!(VehicleEntityData, vehicle_lockable_info),
            },
            FieldInfoData {
                name: "NeverReportVehicleAsEmpty",
                name_hash: 1610705598,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, never_report_vehicle_as_empty),
            },
            FieldInfoData {
                name: "AITarget",
                name_hash: 2666370364,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, a_i_target),
            },
            FieldInfoData {
                name: "HighAltitudeLockHeight",
                name_hash: 562612431,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, high_altitude_lock_height),
            },
            FieldInfoData {
                name: "UseLowAltitudeHeatSignature",
                name_hash: 3071375774,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_low_altitude_heat_signature),
            },
            FieldInfoData {
                name: "Sound",
                name_hash: 231353798,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleSoundData",
                rust_offset: offset_of!(VehicleEntityData, sound),
            },
            FieldInfoData {
                name: "VoiceOverInfo",
                name_hash: 1260547539,
                flags: MemberInfoFlags::new(0),
                field_type: "EntityVoiceOverInfo",
                rust_offset: offset_of!(VehicleEntityData, voice_over_info),
            },
            FieldInfoData {
                name: "NametagHeightScale",
                name_hash: 3182332183,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, nametag_height_scale),
            },
            FieldInfoData {
                name: "SpottingFovScale",
                name_hash: 2562381902,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, spotting_fov_scale),
            },
            FieldInfoData {
                name: "UseSpottingTargetComponentForRaycast",
                name_hash: 1083702272,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_spotting_target_component_for_raycast),
            },
            FieldInfoData {
                name: "InteractionOffset",
                name_hash: 696984818,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, interaction_offset),
            },
            FieldInfoData {
                name: "EquipmentFakeVehicle",
                name_hash: 3184500446,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, equipment_fake_vehicle),
            },
            FieldInfoData {
                name: "ExplosionPacksAttachable",
                name_hash: 2851996027,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, explosion_packs_attachable),
            },
            FieldInfoData {
                name: "CharacterBlueprintOverride",
                name_hash: 2623674279,
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterBlueprint",
                rust_offset: offset_of!(VehicleEntityData, character_blueprint_override),
            },
            FieldInfoData {
                name: "DamageGiverOverrideOwnerVehicle",
                name_hash: 1231762412,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, damage_giver_override_owner_vehicle),
            },
            FieldInfoData {
                name: "EnableSubRealm",
                name_hash: 4199960439,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, enable_sub_realm),
            },
            FieldInfoData {
                name: "CausesAIToFlee",
                name_hash: 467814542,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, causes_a_i_to_flee),
            },
            FieldInfoData {
                name: "AIFleeRadius",
                name_hash: 2368796095,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, a_i_flee_radius),
            },
            FieldInfoData {
                name: "AISoundCategory",
                name_hash: 2164925982,
                flags: MemberInfoFlags::new(0),
                field_type: "AIVehicleSoundCategory",
                rust_offset: offset_of!(VehicleEntityData, a_i_sound_category),
            },
            FieldInfoData {
                name: "VictimOffsetOverride",
                name_hash: 3863524720,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, victim_offset_override),
            },
        ],
    }),
    array_type: Some(VEHICLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntityData-Array",
    name_hash: 907091362,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIVehicleSoundCategory {
    #[default]
    AIVehicleSoundCategory_Normal = 0,
    AIVehicleSoundCategory_Quiet = 1,
}

pub static AIVEHICLESOUNDCATEGORY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleSoundCategory",
    name_hash: 3576377126,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIVEHICLESOUNDCATEGORY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIVehicleSoundCategory {
    fn type_info(&self) -> &'static TypeInfo {
        AIVEHICLESOUNDCATEGORY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIVEHICLESOUNDCATEGORY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleSoundCategory-Array",
    name_hash: 3980958610,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AIVehicleSoundCategory"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimatedDriverEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub input_transform: super::core::LinearTransform,
    pub delay_animation_wheel_transform: bool,
    pub vehicle_speed: super::ant::AntRef,
    pub vehicle_movement_state: super::ant::AntRef,
    pub vehicle_boost: super::ant::AntRef,
    pub vehicle_brake: super::ant::AntRef,
    pub movement_state_stand_threshold: f32,
    pub yaw: NormalizeSettings,
    pub pitch: NormalizeSettings,
    pub roll: NormalizeSettings,
}

pub trait AnimatedDriverEntityDataTrait: super::entity::EntityDataTrait {
    fn input_transform(&self) -> &super::core::LinearTransform;
    fn input_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn delay_animation_wheel_transform(&self) -> &bool;
    fn delay_animation_wheel_transform_mut(&mut self) -> &mut bool;
    fn vehicle_speed(&self) -> &super::ant::AntRef;
    fn vehicle_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_movement_state(&self) -> &super::ant::AntRef;
    fn vehicle_movement_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_boost(&self) -> &super::ant::AntRef;
    fn vehicle_boost_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_brake(&self) -> &super::ant::AntRef;
    fn vehicle_brake_mut(&mut self) -> &mut super::ant::AntRef;
    fn movement_state_stand_threshold(&self) -> &f32;
    fn movement_state_stand_threshold_mut(&mut self) -> &mut f32;
    fn yaw(&self) -> &NormalizeSettings;
    fn yaw_mut(&mut self) -> &mut NormalizeSettings;
    fn pitch(&self) -> &NormalizeSettings;
    fn pitch_mut(&mut self) -> &mut NormalizeSettings;
    fn roll(&self) -> &NormalizeSettings;
    fn roll_mut(&mut self) -> &mut NormalizeSettings;
}

impl AnimatedDriverEntityDataTrait for AnimatedDriverEntityData {
    fn input_transform(&self) -> &super::core::LinearTransform {
        &self.input_transform
    }
    fn input_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.input_transform
    }
    fn delay_animation_wheel_transform(&self) -> &bool {
        &self.delay_animation_wheel_transform
    }
    fn delay_animation_wheel_transform_mut(&mut self) -> &mut bool {
        &mut self.delay_animation_wheel_transform
    }
    fn vehicle_speed(&self) -> &super::ant::AntRef {
        &self.vehicle_speed
    }
    fn vehicle_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_speed
    }
    fn vehicle_movement_state(&self) -> &super::ant::AntRef {
        &self.vehicle_movement_state
    }
    fn vehicle_movement_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_movement_state
    }
    fn vehicle_boost(&self) -> &super::ant::AntRef {
        &self.vehicle_boost
    }
    fn vehicle_boost_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_boost
    }
    fn vehicle_brake(&self) -> &super::ant::AntRef {
        &self.vehicle_brake
    }
    fn vehicle_brake_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_brake
    }
    fn movement_state_stand_threshold(&self) -> &f32 {
        &self.movement_state_stand_threshold
    }
    fn movement_state_stand_threshold_mut(&mut self) -> &mut f32 {
        &mut self.movement_state_stand_threshold
    }
    fn yaw(&self) -> &NormalizeSettings {
        &self.yaw
    }
    fn yaw_mut(&mut self) -> &mut NormalizeSettings {
        &mut self.yaw
    }
    fn pitch(&self) -> &NormalizeSettings {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut NormalizeSettings {
        &mut self.pitch
    }
    fn roll(&self) -> &NormalizeSettings {
        &self.roll
    }
    fn roll_mut(&mut self) -> &mut NormalizeSettings {
        &mut self.roll
    }
}

impl super::entity::EntityDataTrait for AnimatedDriverEntityData {
}

impl super::entity::GameObjectDataTrait for AnimatedDriverEntityData {
}

impl super::core::DataBusPeerTrait for AnimatedDriverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimatedDriverEntityData {
}

impl super::core::DataContainerTrait for AnimatedDriverEntityData {
}

pub static ANIMATEDDRIVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedDriverEntityData",
    name_hash: 1295385519,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AnimatedDriverEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimatedDriverEntityData as Default>::default())),
            create_boxed: || Box::new(<AnimatedDriverEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InputTransform",
                name_hash: 674191935,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AnimatedDriverEntityData, input_transform),
            },
            FieldInfoData {
                name: "DelayAnimationWheelTransform",
                name_hash: 1883575417,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimatedDriverEntityData, delay_animation_wheel_transform),
            },
            FieldInfoData {
                name: "VehicleSpeed",
                name_hash: 503036026,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedDriverEntityData, vehicle_speed),
            },
            FieldInfoData {
                name: "VehicleMovementState",
                name_hash: 2105315721,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedDriverEntityData, vehicle_movement_state),
            },
            FieldInfoData {
                name: "VehicleBoost",
                name_hash: 519733784,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedDriverEntityData, vehicle_boost),
            },
            FieldInfoData {
                name: "VehicleBrake",
                name_hash: 519539362,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedDriverEntityData, vehicle_brake),
            },
            FieldInfoData {
                name: "MovementStateStandThreshold",
                name_hash: 1916267914,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AnimatedDriverEntityData, movement_state_stand_threshold),
            },
            FieldInfoData {
                name: "Yaw",
                name_hash: 193468618,
                flags: MemberInfoFlags::new(0),
                field_type: "NormalizeSettings",
                rust_offset: offset_of!(AnimatedDriverEntityData, yaw),
            },
            FieldInfoData {
                name: "Pitch",
                name_hash: 232604323,
                flags: MemberInfoFlags::new(0),
                field_type: "NormalizeSettings",
                rust_offset: offset_of!(AnimatedDriverEntityData, pitch),
            },
            FieldInfoData {
                name: "Roll",
                name_hash: 2089387576,
                flags: MemberInfoFlags::new(0),
                field_type: "NormalizeSettings",
                rust_offset: offset_of!(AnimatedDriverEntityData, roll),
            },
        ],
    }),
    array_type: Some(ANIMATEDDRIVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AnimatedDriverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATEDDRIVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATEDDRIVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedDriverEntityData-Array",
    name_hash: 2476175643,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimatedDriverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct NormalizeSettings {
    pub normalize: bool,
    pub minimum: f32,
    pub maximum: f32,
    pub lower: f32,
    pub upper: f32,
    pub velocity: f32,
}

pub trait NormalizeSettingsTrait: TypeObject {
    fn normalize(&self) -> &bool;
    fn normalize_mut(&mut self) -> &mut bool;
    fn minimum(&self) -> &f32;
    fn minimum_mut(&mut self) -> &mut f32;
    fn maximum(&self) -> &f32;
    fn maximum_mut(&mut self) -> &mut f32;
    fn lower(&self) -> &f32;
    fn lower_mut(&mut self) -> &mut f32;
    fn upper(&self) -> &f32;
    fn upper_mut(&mut self) -> &mut f32;
    fn velocity(&self) -> &f32;
    fn velocity_mut(&mut self) -> &mut f32;
}

impl NormalizeSettingsTrait for NormalizeSettings {
    fn normalize(&self) -> &bool {
        &self.normalize
    }
    fn normalize_mut(&mut self) -> &mut bool {
        &mut self.normalize
    }
    fn minimum(&self) -> &f32 {
        &self.minimum
    }
    fn minimum_mut(&mut self) -> &mut f32 {
        &mut self.minimum
    }
    fn maximum(&self) -> &f32 {
        &self.maximum
    }
    fn maximum_mut(&mut self) -> &mut f32 {
        &mut self.maximum
    }
    fn lower(&self) -> &f32 {
        &self.lower
    }
    fn lower_mut(&mut self) -> &mut f32 {
        &mut self.lower
    }
    fn upper(&self) -> &f32 {
        &self.upper
    }
    fn upper_mut(&mut self) -> &mut f32 {
        &mut self.upper
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut f32 {
        &mut self.velocity
    }
}

pub static NORMALIZESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NormalizeSettings",
    name_hash: 2515943973,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NormalizeSettings as Default>::default())),
            create_boxed: || Box::new(<NormalizeSettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Normalize",
                name_hash: 3221786848,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NormalizeSettings, normalize),
            },
            FieldInfoData {
                name: "Minimum",
                name_hash: 1011407507,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, minimum),
            },
            FieldInfoData {
                name: "Maximum",
                name_hash: 1313344397,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, maximum),
            },
            FieldInfoData {
                name: "Lower",
                name_hash: 218180838,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, lower),
            },
            FieldInfoData {
                name: "Upper",
                name_hash: 219190343,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, upper),
            },
            FieldInfoData {
                name: "Velocity",
                name_hash: 3860766482,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, velocity),
            },
        ],
    }),
    array_type: Some(NORMALIZESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for NormalizeSettings {
    fn type_info(&self) -> &'static TypeInfo {
        NORMALIZESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NORMALIZESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NormalizeSettings-Array",
    name_hash: 2809445009,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("NormalizeSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleSoundData {
    pub _glacier_base: super::core::DataContainer,
    pub bullet_impact: Option<LockedTypeObject /* super::audio::SoundAsset */>,
}

pub trait VehicleSoundDataTrait: super::core::DataContainerTrait {
    fn bullet_impact(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn bullet_impact_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
}

impl VehicleSoundDataTrait for VehicleSoundData {
    fn bullet_impact(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.bullet_impact
    }
    fn bullet_impact_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.bullet_impact
    }
}

impl super::core::DataContainerTrait for VehicleSoundData {
}

pub static VEHICLESOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSoundData",
    name_hash: 2585489806,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(VehicleSoundData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleSoundData as Default>::default())),
            create_boxed: || Box::new(<VehicleSoundData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BulletImpact",
                name_hash: 1157477793,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(VehicleSoundData, bullet_impact),
            },
        ],
    }),
    array_type: Some(VEHICLESOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLESOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLESOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSoundData-Array",
    name_hash: 3595860666,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleLockableInfoData {
    pub heat_signature: f32,
    pub radar_signature: f32,
    pub low_altitude_height: f32,
    pub low_altitude_heat_signature: f32,
}

pub trait VehicleLockableInfoDataTrait: TypeObject {
    fn heat_signature(&self) -> &f32;
    fn heat_signature_mut(&mut self) -> &mut f32;
    fn radar_signature(&self) -> &f32;
    fn radar_signature_mut(&mut self) -> &mut f32;
    fn low_altitude_height(&self) -> &f32;
    fn low_altitude_height_mut(&mut self) -> &mut f32;
    fn low_altitude_heat_signature(&self) -> &f32;
    fn low_altitude_heat_signature_mut(&mut self) -> &mut f32;
}

impl VehicleLockableInfoDataTrait for VehicleLockableInfoData {
    fn heat_signature(&self) -> &f32 {
        &self.heat_signature
    }
    fn heat_signature_mut(&mut self) -> &mut f32 {
        &mut self.heat_signature
    }
    fn radar_signature(&self) -> &f32 {
        &self.radar_signature
    }
    fn radar_signature_mut(&mut self) -> &mut f32 {
        &mut self.radar_signature
    }
    fn low_altitude_height(&self) -> &f32 {
        &self.low_altitude_height
    }
    fn low_altitude_height_mut(&mut self) -> &mut f32 {
        &mut self.low_altitude_height
    }
    fn low_altitude_heat_signature(&self) -> &f32 {
        &self.low_altitude_heat_signature
    }
    fn low_altitude_heat_signature_mut(&mut self) -> &mut f32 {
        &mut self.low_altitude_heat_signature
    }
}

pub static VEHICLELOCKABLEINFODATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleLockableInfoData",
    name_hash: 1718951906,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleLockableInfoData as Default>::default())),
            create_boxed: || Box::new(<VehicleLockableInfoData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "HeatSignature",
                name_hash: 2221510681,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleLockableInfoData, heat_signature),
            },
            FieldInfoData {
                name: "RadarSignature",
                name_hash: 1808737829,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleLockableInfoData, radar_signature),
            },
            FieldInfoData {
                name: "LowAltitudeHeight",
                name_hash: 768153502,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleLockableInfoData, low_altitude_height),
            },
            FieldInfoData {
                name: "LowAltitudeHeatSignature",
                name_hash: 3927766749,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleLockableInfoData, low_altitude_heat_signature),
            },
        ],
    }),
    array_type: Some(VEHICLELOCKABLEINFODATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleLockableInfoData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLELOCKABLEINFODATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLELOCKABLEINFODATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleLockableInfoData-Array",
    name_hash: 3143904982,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleLockableInfoData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AngleOfImpactData {
    pub zone12_delimiter: f32,
    pub zone23_delimiter: f32,
    pub zone1_multiplier: f32,
    pub zone2_multiplier: f32,
    pub zone3_multiplier: f32,
    pub enabled: bool,
}

pub trait AngleOfImpactDataTrait: TypeObject {
    fn zone12_delimiter(&self) -> &f32;
    fn zone12_delimiter_mut(&mut self) -> &mut f32;
    fn zone23_delimiter(&self) -> &f32;
    fn zone23_delimiter_mut(&mut self) -> &mut f32;
    fn zone1_multiplier(&self) -> &f32;
    fn zone1_multiplier_mut(&mut self) -> &mut f32;
    fn zone2_multiplier(&self) -> &f32;
    fn zone2_multiplier_mut(&mut self) -> &mut f32;
    fn zone3_multiplier(&self) -> &f32;
    fn zone3_multiplier_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl AngleOfImpactDataTrait for AngleOfImpactData {
    fn zone12_delimiter(&self) -> &f32 {
        &self.zone12_delimiter
    }
    fn zone12_delimiter_mut(&mut self) -> &mut f32 {
        &mut self.zone12_delimiter
    }
    fn zone23_delimiter(&self) -> &f32 {
        &self.zone23_delimiter
    }
    fn zone23_delimiter_mut(&mut self) -> &mut f32 {
        &mut self.zone23_delimiter
    }
    fn zone1_multiplier(&self) -> &f32 {
        &self.zone1_multiplier
    }
    fn zone1_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.zone1_multiplier
    }
    fn zone2_multiplier(&self) -> &f32 {
        &self.zone2_multiplier
    }
    fn zone2_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.zone2_multiplier
    }
    fn zone3_multiplier(&self) -> &f32 {
        &self.zone3_multiplier
    }
    fn zone3_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.zone3_multiplier
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

pub static ANGLEOFIMPACTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleOfImpactData",
    name_hash: 1911555199,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AngleOfImpactData as Default>::default())),
            create_boxed: || Box::new(<AngleOfImpactData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Zone12Delimiter",
                name_hash: 1249719259,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone12_delimiter),
            },
            FieldInfoData {
                name: "Zone23Delimiter",
                name_hash: 2906626489,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone23_delimiter),
            },
            FieldInfoData {
                name: "Zone1Multiplier",
                name_hash: 1160298209,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone1_multiplier),
            },
            FieldInfoData {
                name: "Zone2Multiplier",
                name_hash: 1257656802,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone2_multiplier),
            },
            FieldInfoData {
                name: "Zone3Multiplier",
                name_hash: 2162935267,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone3_multiplier),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AngleOfImpactData, enabled),
            },
        ],
    }),
    array_type: Some(ANGLEOFIMPACTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AngleOfImpactData {
    fn type_info(&self) -> &'static TypeInfo {
        ANGLEOFIMPACTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANGLEOFIMPACTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleOfImpactData-Array",
    name_hash: 1876281931,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AngleOfImpactData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MPModeData {
    pub vehicle_points: i32,
}

pub trait MPModeDataTrait: TypeObject {
    fn vehicle_points(&self) -> &i32;
    fn vehicle_points_mut(&mut self) -> &mut i32;
}

impl MPModeDataTrait for MPModeData {
    fn vehicle_points(&self) -> &i32 {
        &self.vehicle_points
    }
    fn vehicle_points_mut(&mut self) -> &mut i32 {
        &mut self.vehicle_points
    }
}

pub static MPMODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MPModeData",
    name_hash: 1911582603,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MPModeData as Default>::default())),
            create_boxed: || Box::new(<MPModeData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "VehiclePoints",
                name_hash: 3414626658,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MPModeData, vehicle_points),
            },
        ],
    }),
    array_type: Some(MPMODEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MPModeData {
    fn type_info(&self) -> &'static TypeInfo {
        MPMODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MPMODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MPModeData-Array",
    name_hash: 545742399,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MPModeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleHealthZoneData {
    pub max_health: f32,
    pub max_shield_health: f32,
    pub use_damage_angle_calculation: bool,
    pub min_damage_angle: f32,
    pub damage_angle_multiplier: f32,
    pub damage_angle_multiplier_curve: Option<LockedTypeObject /* super::physics::Curve2D */>,
    pub vertical_factor: f32,
}

pub trait VehicleHealthZoneDataTrait: TypeObject {
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn max_shield_health(&self) -> &f32;
    fn max_shield_health_mut(&mut self) -> &mut f32;
    fn use_damage_angle_calculation(&self) -> &bool;
    fn use_damage_angle_calculation_mut(&mut self) -> &mut bool;
    fn min_damage_angle(&self) -> &f32;
    fn min_damage_angle_mut(&mut self) -> &mut f32;
    fn damage_angle_multiplier(&self) -> &f32;
    fn damage_angle_multiplier_mut(&mut self) -> &mut f32;
    fn damage_angle_multiplier_curve(&self) -> &Option<LockedTypeObject /* super::physics::Curve2D */>;
    fn damage_angle_multiplier_curve_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::Curve2D */>;
    fn vertical_factor(&self) -> &f32;
    fn vertical_factor_mut(&mut self) -> &mut f32;
}

impl VehicleHealthZoneDataTrait for VehicleHealthZoneData {
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn max_shield_health(&self) -> &f32 {
        &self.max_shield_health
    }
    fn max_shield_health_mut(&mut self) -> &mut f32 {
        &mut self.max_shield_health
    }
    fn use_damage_angle_calculation(&self) -> &bool {
        &self.use_damage_angle_calculation
    }
    fn use_damage_angle_calculation_mut(&mut self) -> &mut bool {
        &mut self.use_damage_angle_calculation
    }
    fn min_damage_angle(&self) -> &f32 {
        &self.min_damage_angle
    }
    fn min_damage_angle_mut(&mut self) -> &mut f32 {
        &mut self.min_damage_angle
    }
    fn damage_angle_multiplier(&self) -> &f32 {
        &self.damage_angle_multiplier
    }
    fn damage_angle_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.damage_angle_multiplier
    }
    fn damage_angle_multiplier_curve(&self) -> &Option<LockedTypeObject /* super::physics::Curve2D */> {
        &self.damage_angle_multiplier_curve
    }
    fn damage_angle_multiplier_curve_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::Curve2D */> {
        &mut self.damage_angle_multiplier_curve
    }
    fn vertical_factor(&self) -> &f32 {
        &self.vertical_factor
    }
    fn vertical_factor_mut(&mut self) -> &mut f32 {
        &mut self.vertical_factor
    }
}

pub static VEHICLEHEALTHZONEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHealthZoneData",
    name_hash: 1156648303,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleHealthZoneData as Default>::default())),
            create_boxed: || Box::new(<VehicleHealthZoneData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MaxHealth",
                name_hash: 1153188365,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, max_health),
            },
            FieldInfoData {
                name: "MaxShieldHealth",
                name_hash: 170435442,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, max_shield_health),
            },
            FieldInfoData {
                name: "UseDamageAngleCalculation",
                name_hash: 983192421,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleHealthZoneData, use_damage_angle_calculation),
            },
            FieldInfoData {
                name: "MinDamageAngle",
                name_hash: 922661029,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, min_damage_angle),
            },
            FieldInfoData {
                name: "DamageAngleMultiplier",
                name_hash: 1111808420,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, damage_angle_multiplier),
            },
            FieldInfoData {
                name: "DamageAngleMultiplierCurve",
                name_hash: 4285632595,
                flags: MemberInfoFlags::new(0),
                field_type: "Curve2D",
                rust_offset: offset_of!(VehicleHealthZoneData, damage_angle_multiplier_curve),
            },
            FieldInfoData {
                name: "VerticalFactor",
                name_hash: 1774860954,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, vertical_factor),
            },
        ],
    }),
    array_type: Some(VEHICLEHEALTHZONEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleHealthZoneData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEHEALTHZONEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEHEALTHZONEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHealthZoneData-Array",
    name_hash: 3156659035,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleHealthZoneData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleHudData {
    pub customization: Option<LockedTypeObject /* VehicleCustomizationAsset */>,
    pub customization_offset: super::core::Vec3,
    pub minimap_icon: UIHudIcon,
    pub icon_name: String,
    pub rotate_in_map: bool,
    pub show_health: bool,
    pub texture: Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>,
    pub vehicle_item_hash: u32,
}

pub trait VehicleHudDataTrait: TypeObject {
    fn customization(&self) -> &Option<LockedTypeObject /* VehicleCustomizationAsset */>;
    fn customization_mut(&mut self) -> &mut Option<LockedTypeObject /* VehicleCustomizationAsset */>;
    fn customization_offset(&self) -> &super::core::Vec3;
    fn customization_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn minimap_icon(&self) -> &UIHudIcon;
    fn minimap_icon_mut(&mut self) -> &mut UIHudIcon;
    fn icon_name(&self) -> &String;
    fn icon_name_mut(&mut self) -> &mut String;
    fn rotate_in_map(&self) -> &bool;
    fn rotate_in_map_mut(&mut self) -> &mut bool;
    fn show_health(&self) -> &bool;
    fn show_health_mut(&mut self) -> &mut bool;
    fn texture(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
    fn texture_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */>;
    fn vehicle_item_hash(&self) -> &u32;
    fn vehicle_item_hash_mut(&mut self) -> &mut u32;
}

impl VehicleHudDataTrait for VehicleHudData {
    fn customization(&self) -> &Option<LockedTypeObject /* VehicleCustomizationAsset */> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<LockedTypeObject /* VehicleCustomizationAsset */> {
        &mut self.customization
    }
    fn customization_offset(&self) -> &super::core::Vec3 {
        &self.customization_offset
    }
    fn customization_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.customization_offset
    }
    fn minimap_icon(&self) -> &UIHudIcon {
        &self.minimap_icon
    }
    fn minimap_icon_mut(&mut self) -> &mut UIHudIcon {
        &mut self.minimap_icon
    }
    fn icon_name(&self) -> &String {
        &self.icon_name
    }
    fn icon_name_mut(&mut self) -> &mut String {
        &mut self.icon_name
    }
    fn rotate_in_map(&self) -> &bool {
        &self.rotate_in_map
    }
    fn rotate_in_map_mut(&mut self) -> &mut bool {
        &mut self.rotate_in_map
    }
    fn show_health(&self) -> &bool {
        &self.show_health
    }
    fn show_health_mut(&mut self) -> &mut bool {
        &mut self.show_health
    }
    fn texture(&self) -> &Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::TextureBaseAsset */> {
        &mut self.texture
    }
    fn vehicle_item_hash(&self) -> &u32 {
        &self.vehicle_item_hash
    }
    fn vehicle_item_hash_mut(&mut self) -> &mut u32 {
        &mut self.vehicle_item_hash
    }
}

pub static VEHICLEHUDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHudData",
    name_hash: 2504088660,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleHudData as Default>::default())),
            create_boxed: || Box::new(<VehicleHudData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Customization",
                name_hash: 1998291608,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleCustomizationAsset",
                rust_offset: offset_of!(VehicleHudData, customization),
            },
            FieldInfoData {
                name: "CustomizationOffset",
                name_hash: 2069977717,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleHudData, customization_offset),
            },
            FieldInfoData {
                name: "MinimapIcon",
                name_hash: 1721945905,
                flags: MemberInfoFlags::new(0),
                field_type: "UIHudIcon",
                rust_offset: offset_of!(VehicleHudData, minimap_icon),
            },
            FieldInfoData {
                name: "IconName",
                name_hash: 268503081,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VehicleHudData, icon_name),
            },
            FieldInfoData {
                name: "RotateInMap",
                name_hash: 1621111143,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleHudData, rotate_in_map),
            },
            FieldInfoData {
                name: "ShowHealth",
                name_hash: 2197316858,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleHudData, show_health),
            },
            FieldInfoData {
                name: "Texture",
                name_hash: 3185041626,
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(VehicleHudData, texture),
            },
            FieldInfoData {
                name: "VehicleItemHash",
                name_hash: 1208512666,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleHudData, vehicle_item_hash),
            },
        ],
    }),
    array_type: Some(VEHICLEHUDDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleHudData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEHUDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEHUDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHudData-Array",
    name_hash: 1285204192,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleHudData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ChildMovingBodyData {
    pub _glacier_base: super::physics::LinearMovingBodyData,
    pub input_delay: f32,
    pub speed: f32,
    pub input_action: i32,
    pub is_one_shot_input: bool,
    pub trigger_impulse: f32,
}

pub trait ChildMovingBodyDataTrait: super::physics::LinearMovingBodyDataTrait {
    fn input_delay(&self) -> &f32;
    fn input_delay_mut(&mut self) -> &mut f32;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
    fn input_action(&self) -> &i32;
    fn input_action_mut(&mut self) -> &mut i32;
    fn is_one_shot_input(&self) -> &bool;
    fn is_one_shot_input_mut(&mut self) -> &mut bool;
    fn trigger_impulse(&self) -> &f32;
    fn trigger_impulse_mut(&mut self) -> &mut f32;
}

impl ChildMovingBodyDataTrait for ChildMovingBodyData {
    fn input_delay(&self) -> &f32 {
        &self.input_delay
    }
    fn input_delay_mut(&mut self) -> &mut f32 {
        &mut self.input_delay
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn input_action_mut(&mut self) -> &mut i32 {
        &mut self.input_action
    }
    fn is_one_shot_input(&self) -> &bool {
        &self.is_one_shot_input
    }
    fn is_one_shot_input_mut(&mut self) -> &mut bool {
        &mut self.is_one_shot_input
    }
    fn trigger_impulse(&self) -> &f32 {
        &self.trigger_impulse
    }
    fn trigger_impulse_mut(&mut self) -> &mut f32 {
        &mut self.trigger_impulse
    }
}

impl super::physics::LinearMovingBodyDataTrait for ChildMovingBodyData {
    fn axis(&self) -> &super::core::Vec3 {
        self._glacier_base.axis()
    }
    fn axis_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.axis_mut()
    }
    fn start(&self) -> &super::physics::EndPointData {
        self._glacier_base.start()
    }
    fn start_mut(&mut self) -> &mut super::physics::EndPointData {
        self._glacier_base.start_mut()
    }
    fn end(&self) -> &super::physics::EndPointData {
        self._glacier_base.end()
    }
    fn end_mut(&mut self) -> &mut super::physics::EndPointData {
        self._glacier_base.end_mut()
    }
}

impl super::physics::MovingBodyDataTrait for ChildMovingBodyData {
    fn mass(&self) -> &f32 {
        self._glacier_base.mass()
    }
    fn mass_mut(&mut self) -> &mut f32 {
        self._glacier_base.mass_mut()
    }
    fn inertia(&self) -> &f32 {
        self._glacier_base.inertia()
    }
    fn inertia_mut(&mut self) -> &mut f32 {
        self._glacier_base.inertia_mut()
    }
}

impl super::core::DataContainerTrait for ChildMovingBodyData {
}

pub static CHILDMOVINGBODYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildMovingBodyData",
    name_hash: 404082683,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::LINEARMOVINGBODYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ChildMovingBodyData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildMovingBodyData as Default>::default())),
            create_boxed: || Box::new(<ChildMovingBodyData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InputDelay",
                name_hash: 1617181990,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildMovingBodyData, input_delay),
            },
            FieldInfoData {
                name: "Speed",
                name_hash: 230887042,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildMovingBodyData, speed),
            },
            FieldInfoData {
                name: "InputAction",
                name_hash: 1407707693,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ChildMovingBodyData, input_action),
            },
            FieldInfoData {
                name: "IsOneShotInput",
                name_hash: 1020834765,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildMovingBodyData, is_one_shot_input),
            },
            FieldInfoData {
                name: "TriggerImpulse",
                name_hash: 2705515430,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildMovingBodyData, trigger_impulse),
            },
        ],
    }),
    array_type: Some(CHILDMOVINGBODYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChildMovingBodyData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDMOVINGBODYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHILDMOVINGBODYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildMovingBodyData-Array",
    name_hash: 667322319,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildMovingBodyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ChildRotationBodyData {
    pub _glacier_base: super::physics::RotationBodyData,
    pub force_modifier: f32,
    pub reset_force_modifier: f32,
    pub reset_force_input_threshold: f32,
    pub use_linear_input: bool,
    pub rotation_input: i32,
    pub world_space_lock_efficiency: f32,
}

pub trait ChildRotationBodyDataTrait: super::physics::RotationBodyDataTrait {
    fn force_modifier(&self) -> &f32;
    fn force_modifier_mut(&mut self) -> &mut f32;
    fn reset_force_modifier(&self) -> &f32;
    fn reset_force_modifier_mut(&mut self) -> &mut f32;
    fn reset_force_input_threshold(&self) -> &f32;
    fn reset_force_input_threshold_mut(&mut self) -> &mut f32;
    fn use_linear_input(&self) -> &bool;
    fn use_linear_input_mut(&mut self) -> &mut bool;
    fn rotation_input(&self) -> &i32;
    fn rotation_input_mut(&mut self) -> &mut i32;
    fn world_space_lock_efficiency(&self) -> &f32;
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32;
}

impl ChildRotationBodyDataTrait for ChildRotationBodyData {
    fn force_modifier(&self) -> &f32 {
        &self.force_modifier
    }
    fn force_modifier_mut(&mut self) -> &mut f32 {
        &mut self.force_modifier
    }
    fn reset_force_modifier(&self) -> &f32 {
        &self.reset_force_modifier
    }
    fn reset_force_modifier_mut(&mut self) -> &mut f32 {
        &mut self.reset_force_modifier
    }
    fn reset_force_input_threshold(&self) -> &f32 {
        &self.reset_force_input_threshold
    }
    fn reset_force_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.reset_force_input_threshold
    }
    fn use_linear_input(&self) -> &bool {
        &self.use_linear_input
    }
    fn use_linear_input_mut(&mut self) -> &mut bool {
        &mut self.use_linear_input
    }
    fn rotation_input(&self) -> &i32 {
        &self.rotation_input
    }
    fn rotation_input_mut(&mut self) -> &mut i32 {
        &mut self.rotation_input
    }
    fn world_space_lock_efficiency(&self) -> &f32 {
        &self.world_space_lock_efficiency
    }
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency
    }
}

impl super::physics::RotationBodyDataTrait for ChildRotationBodyData {
    fn angular_momentum_multiplier(&self) -> &f32 {
        self._glacier_base.angular_momentum_multiplier()
    }
    fn angular_momentum_multiplier_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_multiplier_mut()
    }
    fn angular_momentum_threshold(&self) -> &f32 {
        self._glacier_base.angular_momentum_threshold()
    }
    fn angular_momentum_threshold_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_threshold_mut()
    }
    fn angular_momentum_damping(&self) -> &f32 {
        self._glacier_base.angular_momentum_damping()
    }
    fn angular_momentum_damping_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_damping_mut()
    }
    fn angular_momentum_damping_acc(&self) -> &f32 {
        self._glacier_base.angular_momentum_damping_acc()
    }
    fn angular_momentum_damping_acc_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_damping_acc_mut()
    }
    fn angular_momentum_damping_deacc(&self) -> &f32 {
        self._glacier_base.angular_momentum_damping_deacc()
    }
    fn angular_momentum_damping_deacc_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_damping_deacc_mut()
    }
    fn use_post_satisfy_constraints(&self) -> &bool {
        self._glacier_base.use_post_satisfy_constraints()
    }
    fn use_post_satisfy_constraints_mut(&mut self) -> &mut bool {
        self._glacier_base.use_post_satisfy_constraints_mut()
    }
    fn angular_constraint_min(&self) -> &f32 {
        self._glacier_base.angular_constraint_min()
    }
    fn angular_constraint_min_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_constraint_min_mut()
    }
    fn angular_constraint_max(&self) -> &f32 {
        self._glacier_base.angular_constraint_max()
    }
    fn angular_constraint_max_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_constraint_max_mut()
    }
    fn rotation_axis(&self) -> &i32 {
        self._glacier_base.rotation_axis()
    }
    fn rotation_axis_mut(&mut self) -> &mut i32 {
        self._glacier_base.rotation_axis_mut()
    }
    fn extended_constraints(&self) -> &Option<LockedTypeObject /* super::physics::ExtendedConstraintsData */> {
        self._glacier_base.extended_constraints()
    }
    fn extended_constraints_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::ExtendedConstraintsData */> {
        self._glacier_base.extended_constraints_mut()
    }
    fn use_angular_momentum_threshold(&self) -> &bool {
        self._glacier_base.use_angular_momentum_threshold()
    }
    fn use_angular_momentum_threshold_mut(&mut self) -> &mut bool {
        self._glacier_base.use_angular_momentum_threshold_mut()
    }
    fn use_angular_momentum_damping(&self) -> &bool {
        self._glacier_base.use_angular_momentum_damping()
    }
    fn use_angular_momentum_damping_mut(&mut self) -> &mut bool {
        self._glacier_base.use_angular_momentum_damping_mut()
    }
    fn use_angular_constraint(&self) -> &bool {
        self._glacier_base.use_angular_constraint()
    }
    fn use_angular_constraint_mut(&mut self) -> &mut bool {
        self._glacier_base.use_angular_constraint_mut()
    }
}

impl super::physics::MovingBodyDataTrait for ChildRotationBodyData {
    fn mass(&self) -> &f32 {
        self._glacier_base.mass()
    }
    fn mass_mut(&mut self) -> &mut f32 {
        self._glacier_base.mass_mut()
    }
    fn inertia(&self) -> &f32 {
        self._glacier_base.inertia()
    }
    fn inertia_mut(&mut self) -> &mut f32 {
        self._glacier_base.inertia_mut()
    }
}

impl super::core::DataContainerTrait for ChildRotationBodyData {
}

pub static CHILDROTATIONBODYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildRotationBodyData",
    name_hash: 2474725947,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::ROTATIONBODYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ChildRotationBodyData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildRotationBodyData as Default>::default())),
            create_boxed: || Box::new(<ChildRotationBodyData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ForceModifier",
                name_hash: 1738357711,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildRotationBodyData, force_modifier),
            },
            FieldInfoData {
                name: "ResetForceModifier",
                name_hash: 4210794010,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildRotationBodyData, reset_force_modifier),
            },
            FieldInfoData {
                name: "ResetForceInputThreshold",
                name_hash: 1759745836,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildRotationBodyData, reset_force_input_threshold),
            },
            FieldInfoData {
                name: "UseLinearInput",
                name_hash: 330083213,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildRotationBodyData, use_linear_input),
            },
            FieldInfoData {
                name: "RotationInput",
                name_hash: 832509767,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ChildRotationBodyData, rotation_input),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiency",
                name_hash: 4063999679,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildRotationBodyData, world_space_lock_efficiency),
            },
        ],
    }),
    array_type: Some(CHILDROTATIONBODYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChildRotationBodyData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDROTATIONBODYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHILDROTATIONBODYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildRotationBodyData-Array",
    name_hash: 2417408399,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildRotationBodyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleHealthComponentData {
    pub _glacier_base: super::gameplay_sim::ControllableHealthComponentData,
    pub force_min_damage_angle_radius: f32,
}

pub trait VehicleHealthComponentDataTrait: super::gameplay_sim::ControllableHealthComponentDataTrait {
    fn force_min_damage_angle_radius(&self) -> &f32;
    fn force_min_damage_angle_radius_mut(&mut self) -> &mut f32;
}

impl VehicleHealthComponentDataTrait for VehicleHealthComponentData {
    fn force_min_damage_angle_radius(&self) -> &f32 {
        &self.force_min_damage_angle_radius
    }
    fn force_min_damage_angle_radius_mut(&mut self) -> &mut f32 {
        &mut self.force_min_damage_angle_radius
    }
}

impl super::gameplay_sim::ControllableHealthComponentDataTrait for VehicleHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for VehicleHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for VehicleHealthComponentData {
}

impl super::entity::ComponentDataTrait for VehicleHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleHealthComponentData {
}

impl super::core::DataBusPeerTrait for VehicleHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleHealthComponentData {
}

impl super::core::DataContainerTrait for VehicleHealthComponentData {
}

pub static VEHICLEHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHealthComponentData",
    name_hash: 1332967774,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEHEALTHCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleHealthComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleHealthComponentData as Default>::default())),
            create_boxed: || Box::new(<VehicleHealthComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ForceMinDamageAngleRadius",
                name_hash: 2603800768,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthComponentData, force_min_damage_angle_radius),
            },
        ],
    }),
    array_type: Some(VEHICLEHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHealthComponentData-Array",
    name_hash: 2582010602,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehiclePhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::ControllablePhysicsComponentData,
    pub vehicle_physics_action: Option<LockedTypeObject /* super::physics::VehiclePhysicsActionData */>,
    pub proximity_tracker_data: Option<LockedTypeObject /* super::physics::ProximityTrackerData */>,
}

pub trait VehiclePhysicsComponentDataTrait: super::gameplay_sim::ControllablePhysicsComponentDataTrait {
    fn vehicle_physics_action(&self) -> &Option<LockedTypeObject /* super::physics::VehiclePhysicsActionData */>;
    fn vehicle_physics_action_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::VehiclePhysicsActionData */>;
    fn proximity_tracker_data(&self) -> &Option<LockedTypeObject /* super::physics::ProximityTrackerData */>;
    fn proximity_tracker_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::ProximityTrackerData */>;
}

impl VehiclePhysicsComponentDataTrait for VehiclePhysicsComponentData {
    fn vehicle_physics_action(&self) -> &Option<LockedTypeObject /* super::physics::VehiclePhysicsActionData */> {
        &self.vehicle_physics_action
    }
    fn vehicle_physics_action_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::VehiclePhysicsActionData */> {
        &mut self.vehicle_physics_action
    }
    fn proximity_tracker_data(&self) -> &Option<LockedTypeObject /* super::physics::ProximityTrackerData */> {
        &self.proximity_tracker_data
    }
    fn proximity_tracker_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::ProximityTrackerData */> {
        &mut self.proximity_tracker_data
    }
}

impl super::gameplay_sim::ControllablePhysicsComponentDataTrait for VehiclePhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for VehiclePhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for VehiclePhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for VehiclePhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehiclePhysicsComponentData {
}

impl super::core::DataBusPeerTrait for VehiclePhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehiclePhysicsComponentData {
}

impl super::core::DataContainerTrait for VehiclePhysicsComponentData {
}

pub static VEHICLEPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehiclePhysicsComponentData",
    name_hash: 4063397769,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEPHYSICSCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehiclePhysicsComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehiclePhysicsComponentData as Default>::default())),
            create_boxed: || Box::new(<VehiclePhysicsComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "VehiclePhysicsAction",
                name_hash: 2205050216,
                flags: MemberInfoFlags::new(0),
                field_type: "VehiclePhysicsActionData",
                rust_offset: offset_of!(VehiclePhysicsComponentData, vehicle_physics_action),
            },
            FieldInfoData {
                name: "ProximityTrackerData",
                name_hash: 4292598136,
                flags: MemberInfoFlags::new(0),
                field_type: "ProximityTrackerData",
                rust_offset: offset_of!(VehiclePhysicsComponentData, proximity_tracker_data),
            },
        ],
    }),
    array_type: Some(VEHICLEPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehiclePhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehiclePhysicsComponentData-Array",
    name_hash: 633535805,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehiclePhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IKComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub i_k_effector: super::gameplay_sim::IKEffectorEnum,
    pub i_k_data: super::gameplay_sim::HIKData,
}

pub trait IKComponentDataTrait: super::entity::GameComponentDataTrait {
    fn i_k_effector(&self) -> &super::gameplay_sim::IKEffectorEnum;
    fn i_k_effector_mut(&mut self) -> &mut super::gameplay_sim::IKEffectorEnum;
    fn i_k_data(&self) -> &super::gameplay_sim::HIKData;
    fn i_k_data_mut(&mut self) -> &mut super::gameplay_sim::HIKData;
}

impl IKComponentDataTrait for IKComponentData {
    fn i_k_effector(&self) -> &super::gameplay_sim::IKEffectorEnum {
        &self.i_k_effector
    }
    fn i_k_effector_mut(&mut self) -> &mut super::gameplay_sim::IKEffectorEnum {
        &mut self.i_k_effector
    }
    fn i_k_data(&self) -> &super::gameplay_sim::HIKData {
        &self.i_k_data
    }
    fn i_k_data_mut(&mut self) -> &mut super::gameplay_sim::HIKData {
        &mut self.i_k_data
    }
}

impl super::entity::GameComponentDataTrait for IKComponentData {
}

impl super::entity::ComponentDataTrait for IKComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for IKComponentData {
}

impl super::core::DataBusPeerTrait for IKComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IKComponentData {
}

impl super::core::DataContainerTrait for IKComponentData {
}

pub static IKCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IKComponentData",
    name_hash: 507131224,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(IKComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IKComponentData as Default>::default())),
            create_boxed: || Box::new(<IKComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "IKEffector",
                name_hash: 4088955053,
                flags: MemberInfoFlags::new(0),
                field_type: "IKEffectorEnum",
                rust_offset: offset_of!(IKComponentData, i_k_effector),
            },
            FieldInfoData {
                name: "IKData",
                name_hash: 2831034455,
                flags: MemberInfoFlags::new(0),
                field_type: "HIKData",
                rust_offset: offset_of!(IKComponentData, i_k_data),
            },
        ],
    }),
    array_type: Some(IKCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for IKComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        IKCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IKCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IKComponentData-Array",
    name_hash: 3998347244,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IKComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleComponentData {
    pub _glacier_base: ChassisComponentData,
}

pub trait VehicleComponentDataTrait: ChassisComponentDataTrait {
}

impl VehicleComponentDataTrait for VehicleComponentData {
}

impl ChassisComponentDataTrait for VehicleComponentData {
    fn vehicle_config(&self) -> &Option<LockedTypeObject /* super::physics::VehicleConfigData */> {
        self._glacier_base.vehicle_config()
    }
    fn vehicle_config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::VehicleConfigData */> {
        self._glacier_base.vehicle_config_mut()
    }
    fn gearbox_config(&self) -> &Option<LockedTypeObject /* super::physics::GearboxConfigData */> {
        self._glacier_base.gearbox_config()
    }
    fn gearbox_config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::GearboxConfigData */> {
        self._glacier_base.gearbox_config_mut()
    }
    fn camera_relative_control_config(&self) -> &Option<LockedTypeObject /* CameraRelativeControlData */> {
        self._glacier_base.camera_relative_control_config()
    }
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraRelativeControlData */> {
        self._glacier_base.camera_relative_control_config_mut()
    }
    fn always_full_throttle(&self) -> &bool {
        self._glacier_base.always_full_throttle()
    }
    fn always_full_throttle_mut(&mut self) -> &mut bool {
        self._glacier_base.always_full_throttle_mut()
    }
    fn water_effects(&self) -> &Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>> {
        self._glacier_base.water_effects()
    }
    fn water_effects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>> {
        self._glacier_base.water_effects_mut()
    }
    fn water_streak_effects(&self) -> &Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>> {
        self._glacier_base.water_streak_effects()
    }
    fn water_streak_effects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>> {
        self._glacier_base.water_streak_effects_mut()
    }
    fn trigger_ground_effect_impulse(&self) -> &f32 {
        self._glacier_base.trigger_ground_effect_impulse()
    }
    fn trigger_ground_effect_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.trigger_ground_effect_impulse_mut()
    }
    fn trigger_ground_effect_height(&self) -> &f32 {
        self._glacier_base.trigger_ground_effect_height()
    }
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32 {
        self._glacier_base.trigger_ground_effect_height_mut()
    }
    fn ground_effect_on_terrain_only(&self) -> &bool {
        self._glacier_base.ground_effect_on_terrain_only()
    }
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool {
        self._glacier_base.ground_effect_on_terrain_only_mut()
    }
    fn ground_effect_fade_param(&self) -> &f32 {
        self._glacier_base.ground_effect_fade_param()
    }
    fn ground_effect_fade_param_mut(&mut self) -> &mut f32 {
        self._glacier_base.ground_effect_fade_param_mut()
    }
    fn landing_gear_logic(&self) -> &Option<LockedTypeObject /* LandingGearLogicData */> {
        self._glacier_base.landing_gear_logic()
    }
    fn landing_gear_logic_mut(&mut self) -> &mut Option<LockedTypeObject /* LandingGearLogicData */> {
        self._glacier_base.landing_gear_logic_mut()
    }
    fn allow_negative_throttle(&self) -> &bool {
        self._glacier_base.allow_negative_throttle()
    }
    fn allow_negative_throttle_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_negative_throttle_mut()
    }
    fn override_server_bounding_box(&self) -> &bool {
        self._glacier_base.override_server_bounding_box()
    }
    fn override_server_bounding_box_mut(&mut self) -> &mut bool {
        self._glacier_base.override_server_bounding_box_mut()
    }
    fn override_client_bounding_box(&self) -> &bool {
        self._glacier_base.override_client_bounding_box()
    }
    fn override_client_bounding_box_mut(&mut self) -> &mut bool {
        self._glacier_base.override_client_bounding_box_mut()
    }
    fn override_bounding_box_min(&self) -> &super::core::Vec3 {
        self._glacier_base.override_bounding_box_min()
    }
    fn override_bounding_box_min_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.override_bounding_box_min_mut()
    }
    fn override_bounding_box_max(&self) -> &super::core::Vec3 {
        self._glacier_base.override_bounding_box_max()
    }
    fn override_bounding_box_max_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.override_bounding_box_max_mut()
    }
}

impl super::gameplay_sim::PartComponentDataTrait for VehicleComponentData {
    fn health_states(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::HealthStateData */>> {
        self._glacier_base.health_states()
    }
    fn health_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::HealthStateData */>> {
        self._glacier_base.health_states_mut()
    }
    fn part_links(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links_mut()
    }
    fn is_supported(&self) -> &bool {
        self._glacier_base.is_supported()
    }
    fn is_supported_mut(&mut self) -> &mut bool {
        self._glacier_base.is_supported_mut()
    }
    fn is_fragile(&self) -> &bool {
        self._glacier_base.is_fragile()
    }
    fn is_fragile_mut(&mut self) -> &mut bool {
        self._glacier_base.is_fragile_mut()
    }
    fn is_networkable(&self) -> &bool {
        self._glacier_base.is_networkable()
    }
    fn is_networkable_mut(&mut self) -> &mut bool {
        self._glacier_base.is_networkable_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
}

impl super::entity::GameComponentDataTrait for VehicleComponentData {
}

impl super::entity::ComponentDataTrait for VehicleComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleComponentData {
}

impl super::core::DataBusPeerTrait for VehicleComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleComponentData {
}

impl super::core::DataContainerTrait for VehicleComponentData {
}

pub static VEHICLECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleComponentData",
    name_hash: 831529794,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHASSISCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleComponentData as Default>::default())),
            create_boxed: || Box::new(<VehicleComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEHICLECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleComponentData-Array",
    name_hash: 2584261366,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ChassisComponentData {
    pub _glacier_base: super::gameplay_sim::PartComponentData,
    pub vehicle_config: Option<LockedTypeObject /* super::physics::VehicleConfigData */>,
    pub gearbox_config: Option<LockedTypeObject /* super::physics::GearboxConfigData */>,
    pub camera_relative_control_config: Option<LockedTypeObject /* CameraRelativeControlData */>,
    pub always_full_throttle: bool,
    pub water_effects: Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>>,
    pub water_streak_effects: Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>>,
    pub trigger_ground_effect_impulse: f32,
    pub trigger_ground_effect_height: f32,
    pub ground_effect_on_terrain_only: bool,
    pub ground_effect_fade_param: f32,
    pub landing_gear_logic: Option<LockedTypeObject /* LandingGearLogicData */>,
    pub allow_negative_throttle: bool,
    pub override_server_bounding_box: bool,
    pub override_client_bounding_box: bool,
    pub override_bounding_box_min: super::core::Vec3,
    pub override_bounding_box_max: super::core::Vec3,
}

pub trait ChassisComponentDataTrait: super::gameplay_sim::PartComponentDataTrait {
    fn vehicle_config(&self) -> &Option<LockedTypeObject /* super::physics::VehicleConfigData */>;
    fn vehicle_config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::VehicleConfigData */>;
    fn gearbox_config(&self) -> &Option<LockedTypeObject /* super::physics::GearboxConfigData */>;
    fn gearbox_config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::GearboxConfigData */>;
    fn camera_relative_control_config(&self) -> &Option<LockedTypeObject /* CameraRelativeControlData */>;
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraRelativeControlData */>;
    fn always_full_throttle(&self) -> &bool;
    fn always_full_throttle_mut(&mut self) -> &mut bool;
    fn water_effects(&self) -> &Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>>;
    fn water_effects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>>;
    fn water_streak_effects(&self) -> &Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>>;
    fn water_streak_effects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>>;
    fn trigger_ground_effect_impulse(&self) -> &f32;
    fn trigger_ground_effect_impulse_mut(&mut self) -> &mut f32;
    fn trigger_ground_effect_height(&self) -> &f32;
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32;
    fn ground_effect_on_terrain_only(&self) -> &bool;
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool;
    fn ground_effect_fade_param(&self) -> &f32;
    fn ground_effect_fade_param_mut(&mut self) -> &mut f32;
    fn landing_gear_logic(&self) -> &Option<LockedTypeObject /* LandingGearLogicData */>;
    fn landing_gear_logic_mut(&mut self) -> &mut Option<LockedTypeObject /* LandingGearLogicData */>;
    fn allow_negative_throttle(&self) -> &bool;
    fn allow_negative_throttle_mut(&mut self) -> &mut bool;
    fn override_server_bounding_box(&self) -> &bool;
    fn override_server_bounding_box_mut(&mut self) -> &mut bool;
    fn override_client_bounding_box(&self) -> &bool;
    fn override_client_bounding_box_mut(&mut self) -> &mut bool;
    fn override_bounding_box_min(&self) -> &super::core::Vec3;
    fn override_bounding_box_min_mut(&mut self) -> &mut super::core::Vec3;
    fn override_bounding_box_max(&self) -> &super::core::Vec3;
    fn override_bounding_box_max_mut(&mut self) -> &mut super::core::Vec3;
}

impl ChassisComponentDataTrait for ChassisComponentData {
    fn vehicle_config(&self) -> &Option<LockedTypeObject /* super::physics::VehicleConfigData */> {
        &self.vehicle_config
    }
    fn vehicle_config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::VehicleConfigData */> {
        &mut self.vehicle_config
    }
    fn gearbox_config(&self) -> &Option<LockedTypeObject /* super::physics::GearboxConfigData */> {
        &self.gearbox_config
    }
    fn gearbox_config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::GearboxConfigData */> {
        &mut self.gearbox_config
    }
    fn camera_relative_control_config(&self) -> &Option<LockedTypeObject /* CameraRelativeControlData */> {
        &self.camera_relative_control_config
    }
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraRelativeControlData */> {
        &mut self.camera_relative_control_config
    }
    fn always_full_throttle(&self) -> &bool {
        &self.always_full_throttle
    }
    fn always_full_throttle_mut(&mut self) -> &mut bool {
        &mut self.always_full_throttle
    }
    fn water_effects(&self) -> &Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>> {
        &self.water_effects
    }
    fn water_effects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>> {
        &mut self.water_effects
    }
    fn water_streak_effects(&self) -> &Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>> {
        &self.water_streak_effects
    }
    fn water_streak_effects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VehicleWaterEffectData */>> {
        &mut self.water_streak_effects
    }
    fn trigger_ground_effect_impulse(&self) -> &f32 {
        &self.trigger_ground_effect_impulse
    }
    fn trigger_ground_effect_impulse_mut(&mut self) -> &mut f32 {
        &mut self.trigger_ground_effect_impulse
    }
    fn trigger_ground_effect_height(&self) -> &f32 {
        &self.trigger_ground_effect_height
    }
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32 {
        &mut self.trigger_ground_effect_height
    }
    fn ground_effect_on_terrain_only(&self) -> &bool {
        &self.ground_effect_on_terrain_only
    }
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool {
        &mut self.ground_effect_on_terrain_only
    }
    fn ground_effect_fade_param(&self) -> &f32 {
        &self.ground_effect_fade_param
    }
    fn ground_effect_fade_param_mut(&mut self) -> &mut f32 {
        &mut self.ground_effect_fade_param
    }
    fn landing_gear_logic(&self) -> &Option<LockedTypeObject /* LandingGearLogicData */> {
        &self.landing_gear_logic
    }
    fn landing_gear_logic_mut(&mut self) -> &mut Option<LockedTypeObject /* LandingGearLogicData */> {
        &mut self.landing_gear_logic
    }
    fn allow_negative_throttle(&self) -> &bool {
        &self.allow_negative_throttle
    }
    fn allow_negative_throttle_mut(&mut self) -> &mut bool {
        &mut self.allow_negative_throttle
    }
    fn override_server_bounding_box(&self) -> &bool {
        &self.override_server_bounding_box
    }
    fn override_server_bounding_box_mut(&mut self) -> &mut bool {
        &mut self.override_server_bounding_box
    }
    fn override_client_bounding_box(&self) -> &bool {
        &self.override_client_bounding_box
    }
    fn override_client_bounding_box_mut(&mut self) -> &mut bool {
        &mut self.override_client_bounding_box
    }
    fn override_bounding_box_min(&self) -> &super::core::Vec3 {
        &self.override_bounding_box_min
    }
    fn override_bounding_box_min_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.override_bounding_box_min
    }
    fn override_bounding_box_max(&self) -> &super::core::Vec3 {
        &self.override_bounding_box_max
    }
    fn override_bounding_box_max_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.override_bounding_box_max
    }
}

impl super::gameplay_sim::PartComponentDataTrait for ChassisComponentData {
    fn health_states(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::HealthStateData */>> {
        self._glacier_base.health_states()
    }
    fn health_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::HealthStateData */>> {
        self._glacier_base.health_states_mut()
    }
    fn part_links(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links_mut()
    }
    fn is_supported(&self) -> &bool {
        self._glacier_base.is_supported()
    }
    fn is_supported_mut(&mut self) -> &mut bool {
        self._glacier_base.is_supported_mut()
    }
    fn is_fragile(&self) -> &bool {
        self._glacier_base.is_fragile()
    }
    fn is_fragile_mut(&mut self) -> &mut bool {
        self._glacier_base.is_fragile_mut()
    }
    fn is_networkable(&self) -> &bool {
        self._glacier_base.is_networkable()
    }
    fn is_networkable_mut(&mut self) -> &mut bool {
        self._glacier_base.is_networkable_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
}

impl super::entity::GameComponentDataTrait for ChassisComponentData {
}

impl super::entity::ComponentDataTrait for ChassisComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ChassisComponentData {
}

impl super::core::DataBusPeerTrait for ChassisComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ChassisComponentData {
}

impl super::core::DataContainerTrait for ChassisComponentData {
}

pub static CHASSISCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChassisComponentData",
    name_hash: 2316767946,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::PARTCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(ChassisComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChassisComponentData as Default>::default())),
            create_boxed: || Box::new(<ChassisComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "VehicleConfig",
                name_hash: 14921303,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleConfigData",
                rust_offset: offset_of!(ChassisComponentData, vehicle_config),
            },
            FieldInfoData {
                name: "GearboxConfig",
                name_hash: 1478960267,
                flags: MemberInfoFlags::new(0),
                field_type: "GearboxConfigData",
                rust_offset: offset_of!(ChassisComponentData, gearbox_config),
            },
            FieldInfoData {
                name: "CameraRelativeControlConfig",
                name_hash: 3669484517,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraRelativeControlData",
                rust_offset: offset_of!(ChassisComponentData, camera_relative_control_config),
            },
            FieldInfoData {
                name: "AlwaysFullThrottle",
                name_hash: 2632109007,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, always_full_throttle),
            },
            FieldInfoData {
                name: "WaterEffects",
                name_hash: 1529363092,
                flags: MemberInfoFlags::new(144),
                field_type: "VehicleWaterEffectData-Array",
                rust_offset: offset_of!(ChassisComponentData, water_effects),
            },
            FieldInfoData {
                name: "WaterStreakEffects",
                name_hash: 1233991406,
                flags: MemberInfoFlags::new(144),
                field_type: "VehicleWaterEffectData-Array",
                rust_offset: offset_of!(ChassisComponentData, water_streak_effects),
            },
            FieldInfoData {
                name: "TriggerGroundEffectImpulse",
                name_hash: 3804940212,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChassisComponentData, trigger_ground_effect_impulse),
            },
            FieldInfoData {
                name: "TriggerGroundEffectHeight",
                name_hash: 1753938672,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChassisComponentData, trigger_ground_effect_height),
            },
            FieldInfoData {
                name: "GroundEffectOnTerrainOnly",
                name_hash: 1990027221,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, ground_effect_on_terrain_only),
            },
            FieldInfoData {
                name: "GroundEffectFadeParam",
                name_hash: 1198309982,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChassisComponentData, ground_effect_fade_param),
            },
            FieldInfoData {
                name: "LandingGearLogic",
                name_hash: 3799182877,
                flags: MemberInfoFlags::new(0),
                field_type: "LandingGearLogicData",
                rust_offset: offset_of!(ChassisComponentData, landing_gear_logic),
            },
            FieldInfoData {
                name: "AllowNegativeThrottle",
                name_hash: 1548999735,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, allow_negative_throttle),
            },
            FieldInfoData {
                name: "OverrideServerBoundingBox",
                name_hash: 2614986419,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, override_server_bounding_box),
            },
            FieldInfoData {
                name: "OverrideClientBoundingBox",
                name_hash: 375303279,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, override_client_bounding_box),
            },
            FieldInfoData {
                name: "OverrideBoundingBoxMin",
                name_hash: 4035937948,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ChassisComponentData, override_bounding_box_min),
            },
            FieldInfoData {
                name: "OverrideBoundingBoxMax",
                name_hash: 4035938178,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ChassisComponentData, override_bounding_box_max),
            },
        ],
    }),
    array_type: Some(CHASSISCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChassisComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHASSISCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHASSISCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChassisComponentData-Array",
    name_hash: 493133438,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChassisComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraRelativeControlData {
    pub _glacier_base: super::core::DataContainer,
    pub camera_relative_control: CameraRelativeControlEnum,
    pub combine_with_non_relative_controls: bool,
    pub use_camera_component_transform: bool,
    pub vehicle_relative_forward: bool,
    pub camera_relative_control_forward: i32,
    pub camera_relative_control_back: i32,
    pub vehicle_relative_strafe: bool,
    pub camera_relative_control_strafe: i32,
    pub forced_moving_body_world_space_lock: i32,
    pub speed_relative_data: Vec<BoxedTypeObject /* CameraRelativeControlPerSpeedData */>,
    pub throttle_output: i32,
    pub brake_output: i32,
    pub yaw_output: i32,
    pub inverted_yaw_in_reverse: bool,
    pub pitch_output: i32,
    pub force_align_yaw_with_camera: bool,
    pub force_align_yaw_input_hint: i32,
    pub force_align_yaw_input_threshold: f32,
    pub force_align_yaw_no_input_threshold: f32,
    pub force_align_yaw_threshold_pow: f32,
    pub force_align_yaw_angle_offset: f32,
    pub force_align_pitch_with_camera: bool,
    pub force_align_pitch_input_hint: i32,
    pub force_align_pitch_input_threshold: f32,
    pub force_align_pitch_no_input_threshold: f32,
    pub force_align_pitch_threshold_pow: f32,
    pub force_align_pitch_angle_offset: f32,
}

pub trait CameraRelativeControlDataTrait: super::core::DataContainerTrait {
    fn camera_relative_control(&self) -> &CameraRelativeControlEnum;
    fn camera_relative_control_mut(&mut self) -> &mut CameraRelativeControlEnum;
    fn combine_with_non_relative_controls(&self) -> &bool;
    fn combine_with_non_relative_controls_mut(&mut self) -> &mut bool;
    fn use_camera_component_transform(&self) -> &bool;
    fn use_camera_component_transform_mut(&mut self) -> &mut bool;
    fn vehicle_relative_forward(&self) -> &bool;
    fn vehicle_relative_forward_mut(&mut self) -> &mut bool;
    fn camera_relative_control_forward(&self) -> &i32;
    fn camera_relative_control_forward_mut(&mut self) -> &mut i32;
    fn camera_relative_control_back(&self) -> &i32;
    fn camera_relative_control_back_mut(&mut self) -> &mut i32;
    fn vehicle_relative_strafe(&self) -> &bool;
    fn vehicle_relative_strafe_mut(&mut self) -> &mut bool;
    fn camera_relative_control_strafe(&self) -> &i32;
    fn camera_relative_control_strafe_mut(&mut self) -> &mut i32;
    fn forced_moving_body_world_space_lock(&self) -> &i32;
    fn forced_moving_body_world_space_lock_mut(&mut self) -> &mut i32;
    fn speed_relative_data(&self) -> &Vec<BoxedTypeObject /* CameraRelativeControlPerSpeedData */>;
    fn speed_relative_data_mut(&mut self) -> &mut Vec<BoxedTypeObject /* CameraRelativeControlPerSpeedData */>;
    fn throttle_output(&self) -> &i32;
    fn throttle_output_mut(&mut self) -> &mut i32;
    fn brake_output(&self) -> &i32;
    fn brake_output_mut(&mut self) -> &mut i32;
    fn yaw_output(&self) -> &i32;
    fn yaw_output_mut(&mut self) -> &mut i32;
    fn inverted_yaw_in_reverse(&self) -> &bool;
    fn inverted_yaw_in_reverse_mut(&mut self) -> &mut bool;
    fn pitch_output(&self) -> &i32;
    fn pitch_output_mut(&mut self) -> &mut i32;
    fn force_align_yaw_with_camera(&self) -> &bool;
    fn force_align_yaw_with_camera_mut(&mut self) -> &mut bool;
    fn force_align_yaw_input_hint(&self) -> &i32;
    fn force_align_yaw_input_hint_mut(&mut self) -> &mut i32;
    fn force_align_yaw_input_threshold(&self) -> &f32;
    fn force_align_yaw_input_threshold_mut(&mut self) -> &mut f32;
    fn force_align_yaw_no_input_threshold(&self) -> &f32;
    fn force_align_yaw_no_input_threshold_mut(&mut self) -> &mut f32;
    fn force_align_yaw_threshold_pow(&self) -> &f32;
    fn force_align_yaw_threshold_pow_mut(&mut self) -> &mut f32;
    fn force_align_yaw_angle_offset(&self) -> &f32;
    fn force_align_yaw_angle_offset_mut(&mut self) -> &mut f32;
    fn force_align_pitch_with_camera(&self) -> &bool;
    fn force_align_pitch_with_camera_mut(&mut self) -> &mut bool;
    fn force_align_pitch_input_hint(&self) -> &i32;
    fn force_align_pitch_input_hint_mut(&mut self) -> &mut i32;
    fn force_align_pitch_input_threshold(&self) -> &f32;
    fn force_align_pitch_input_threshold_mut(&mut self) -> &mut f32;
    fn force_align_pitch_no_input_threshold(&self) -> &f32;
    fn force_align_pitch_no_input_threshold_mut(&mut self) -> &mut f32;
    fn force_align_pitch_threshold_pow(&self) -> &f32;
    fn force_align_pitch_threshold_pow_mut(&mut self) -> &mut f32;
    fn force_align_pitch_angle_offset(&self) -> &f32;
    fn force_align_pitch_angle_offset_mut(&mut self) -> &mut f32;
}

impl CameraRelativeControlDataTrait for CameraRelativeControlData {
    fn camera_relative_control(&self) -> &CameraRelativeControlEnum {
        &self.camera_relative_control
    }
    fn camera_relative_control_mut(&mut self) -> &mut CameraRelativeControlEnum {
        &mut self.camera_relative_control
    }
    fn combine_with_non_relative_controls(&self) -> &bool {
        &self.combine_with_non_relative_controls
    }
    fn combine_with_non_relative_controls_mut(&mut self) -> &mut bool {
        &mut self.combine_with_non_relative_controls
    }
    fn use_camera_component_transform(&self) -> &bool {
        &self.use_camera_component_transform
    }
    fn use_camera_component_transform_mut(&mut self) -> &mut bool {
        &mut self.use_camera_component_transform
    }
    fn vehicle_relative_forward(&self) -> &bool {
        &self.vehicle_relative_forward
    }
    fn vehicle_relative_forward_mut(&mut self) -> &mut bool {
        &mut self.vehicle_relative_forward
    }
    fn camera_relative_control_forward(&self) -> &i32 {
        &self.camera_relative_control_forward
    }
    fn camera_relative_control_forward_mut(&mut self) -> &mut i32 {
        &mut self.camera_relative_control_forward
    }
    fn camera_relative_control_back(&self) -> &i32 {
        &self.camera_relative_control_back
    }
    fn camera_relative_control_back_mut(&mut self) -> &mut i32 {
        &mut self.camera_relative_control_back
    }
    fn vehicle_relative_strafe(&self) -> &bool {
        &self.vehicle_relative_strafe
    }
    fn vehicle_relative_strafe_mut(&mut self) -> &mut bool {
        &mut self.vehicle_relative_strafe
    }
    fn camera_relative_control_strafe(&self) -> &i32 {
        &self.camera_relative_control_strafe
    }
    fn camera_relative_control_strafe_mut(&mut self) -> &mut i32 {
        &mut self.camera_relative_control_strafe
    }
    fn forced_moving_body_world_space_lock(&self) -> &i32 {
        &self.forced_moving_body_world_space_lock
    }
    fn forced_moving_body_world_space_lock_mut(&mut self) -> &mut i32 {
        &mut self.forced_moving_body_world_space_lock
    }
    fn speed_relative_data(&self) -> &Vec<BoxedTypeObject /* CameraRelativeControlPerSpeedData */> {
        &self.speed_relative_data
    }
    fn speed_relative_data_mut(&mut self) -> &mut Vec<BoxedTypeObject /* CameraRelativeControlPerSpeedData */> {
        &mut self.speed_relative_data
    }
    fn throttle_output(&self) -> &i32 {
        &self.throttle_output
    }
    fn throttle_output_mut(&mut self) -> &mut i32 {
        &mut self.throttle_output
    }
    fn brake_output(&self) -> &i32 {
        &self.brake_output
    }
    fn brake_output_mut(&mut self) -> &mut i32 {
        &mut self.brake_output
    }
    fn yaw_output(&self) -> &i32 {
        &self.yaw_output
    }
    fn yaw_output_mut(&mut self) -> &mut i32 {
        &mut self.yaw_output
    }
    fn inverted_yaw_in_reverse(&self) -> &bool {
        &self.inverted_yaw_in_reverse
    }
    fn inverted_yaw_in_reverse_mut(&mut self) -> &mut bool {
        &mut self.inverted_yaw_in_reverse
    }
    fn pitch_output(&self) -> &i32 {
        &self.pitch_output
    }
    fn pitch_output_mut(&mut self) -> &mut i32 {
        &mut self.pitch_output
    }
    fn force_align_yaw_with_camera(&self) -> &bool {
        &self.force_align_yaw_with_camera
    }
    fn force_align_yaw_with_camera_mut(&mut self) -> &mut bool {
        &mut self.force_align_yaw_with_camera
    }
    fn force_align_yaw_input_hint(&self) -> &i32 {
        &self.force_align_yaw_input_hint
    }
    fn force_align_yaw_input_hint_mut(&mut self) -> &mut i32 {
        &mut self.force_align_yaw_input_hint
    }
    fn force_align_yaw_input_threshold(&self) -> &f32 {
        &self.force_align_yaw_input_threshold
    }
    fn force_align_yaw_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.force_align_yaw_input_threshold
    }
    fn force_align_yaw_no_input_threshold(&self) -> &f32 {
        &self.force_align_yaw_no_input_threshold
    }
    fn force_align_yaw_no_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.force_align_yaw_no_input_threshold
    }
    fn force_align_yaw_threshold_pow(&self) -> &f32 {
        &self.force_align_yaw_threshold_pow
    }
    fn force_align_yaw_threshold_pow_mut(&mut self) -> &mut f32 {
        &mut self.force_align_yaw_threshold_pow
    }
    fn force_align_yaw_angle_offset(&self) -> &f32 {
        &self.force_align_yaw_angle_offset
    }
    fn force_align_yaw_angle_offset_mut(&mut self) -> &mut f32 {
        &mut self.force_align_yaw_angle_offset
    }
    fn force_align_pitch_with_camera(&self) -> &bool {
        &self.force_align_pitch_with_camera
    }
    fn force_align_pitch_with_camera_mut(&mut self) -> &mut bool {
        &mut self.force_align_pitch_with_camera
    }
    fn force_align_pitch_input_hint(&self) -> &i32 {
        &self.force_align_pitch_input_hint
    }
    fn force_align_pitch_input_hint_mut(&mut self) -> &mut i32 {
        &mut self.force_align_pitch_input_hint
    }
    fn force_align_pitch_input_threshold(&self) -> &f32 {
        &self.force_align_pitch_input_threshold
    }
    fn force_align_pitch_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.force_align_pitch_input_threshold
    }
    fn force_align_pitch_no_input_threshold(&self) -> &f32 {
        &self.force_align_pitch_no_input_threshold
    }
    fn force_align_pitch_no_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.force_align_pitch_no_input_threshold
    }
    fn force_align_pitch_threshold_pow(&self) -> &f32 {
        &self.force_align_pitch_threshold_pow
    }
    fn force_align_pitch_threshold_pow_mut(&mut self) -> &mut f32 {
        &mut self.force_align_pitch_threshold_pow
    }
    fn force_align_pitch_angle_offset(&self) -> &f32 {
        &self.force_align_pitch_angle_offset
    }
    fn force_align_pitch_angle_offset_mut(&mut self) -> &mut f32 {
        &mut self.force_align_pitch_angle_offset
    }
}

impl super::core::DataContainerTrait for CameraRelativeControlData {
}

pub static CAMERARELATIVECONTROLDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlData",
    name_hash: 4053854399,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CameraRelativeControlData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraRelativeControlData as Default>::default())),
            create_boxed: || Box::new(<CameraRelativeControlData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "CameraRelativeControl",
                name_hash: 4072327375,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraRelativeControlEnum",
                rust_offset: offset_of!(CameraRelativeControlData, camera_relative_control),
            },
            FieldInfoData {
                name: "CombineWithNonRelativeControls",
                name_hash: 713381449,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, combine_with_non_relative_controls),
            },
            FieldInfoData {
                name: "UseCameraComponentTransform",
                name_hash: 3622581372,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, use_camera_component_transform),
            },
            FieldInfoData {
                name: "VehicleRelativeForward",
                name_hash: 2462317874,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, vehicle_relative_forward),
            },
            FieldInfoData {
                name: "CameraRelativeControl_Forward",
                name_hash: 706198763,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, camera_relative_control_forward),
            },
            FieldInfoData {
                name: "CameraRelativeControl_Back",
                name_hash: 638073595,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, camera_relative_control_back),
            },
            FieldInfoData {
                name: "VehicleRelativeStrafe",
                name_hash: 326221022,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, vehicle_relative_strafe),
            },
            FieldInfoData {
                name: "CameraRelativeControl_Strafe",
                name_hash: 3037218279,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, camera_relative_control_strafe),
            },
            FieldInfoData {
                name: "ForcedMovingBodyWorldSpaceLock",
                name_hash: 847785845,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, forced_moving_body_world_space_lock),
            },
            FieldInfoData {
                name: "SpeedRelativeData",
                name_hash: 1023531526,
                flags: MemberInfoFlags::new(144),
                field_type: "CameraRelativeControlPerSpeedData-Array",
                rust_offset: offset_of!(CameraRelativeControlData, speed_relative_data),
            },
            FieldInfoData {
                name: "ThrottleOutput",
                name_hash: 1453443538,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, throttle_output),
            },
            FieldInfoData {
                name: "BrakeOutput",
                name_hash: 1335091045,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, brake_output),
            },
            FieldInfoData {
                name: "YawOutput",
                name_hash: 1215891573,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, yaw_output),
            },
            FieldInfoData {
                name: "InvertedYawInReverse",
                name_hash: 935683710,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, inverted_yaw_in_reverse),
            },
            FieldInfoData {
                name: "PitchOutput",
                name_hash: 1869859292,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, pitch_output),
            },
            FieldInfoData {
                name: "ForceAlignYawWithCamera",
                name_hash: 3714092577,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_with_camera),
            },
            FieldInfoData {
                name: "ForceAlignYawInputHint",
                name_hash: 2905947415,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_input_hint),
            },
            FieldInfoData {
                name: "ForceAlignYawInputThreshold",
                name_hash: 33938459,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_input_threshold),
            },
            FieldInfoData {
                name: "ForceAlignYawNoInputThreshold",
                name_hash: 3263387194,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_no_input_threshold),
            },
            FieldInfoData {
                name: "ForceAlignYawThresholdPow",
                name_hash: 2671772325,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_threshold_pow),
            },
            FieldInfoData {
                name: "ForceAlignYawAngleOffset",
                name_hash: 1529287670,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_angle_offset),
            },
            FieldInfoData {
                name: "ForceAlignPitchWithCamera",
                name_hash: 1704823240,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_with_camera),
            },
            FieldInfoData {
                name: "ForceAlignPitchInputHint",
                name_hash: 1244455966,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_input_hint),
            },
            FieldInfoData {
                name: "ForceAlignPitchInputThreshold",
                name_hash: 3139001394,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_input_threshold),
            },
            FieldInfoData {
                name: "ForceAlignPitchNoInputThreshold",
                name_hash: 3096595667,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_no_input_threshold),
            },
            FieldInfoData {
                name: "ForceAlignPitchThresholdPow",
                name_hash: 1417105036,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_threshold_pow),
            },
            FieldInfoData {
                name: "ForceAlignPitchAngleOffset",
                name_hash: 1415830719,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_angle_offset),
            },
        ],
    }),
    array_type: Some(CAMERARELATIVECONTROLDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraRelativeControlData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARELATIVECONTROLDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERARELATIVECONTROLDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlData-Array",
    name_hash: 124575243,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraRelativeControlData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraRelativeControlPerSpeedData {
    pub speed_threshold: f32,
    pub use_in_forward_and_neutral_gears: bool,
    pub use_in_reverse_gear: bool,
    pub use_in_boost: bool,
    pub use_not_in_boost: bool,
    pub world_space_lock_efficiency: f32,
    pub world_space_lock_efficiency_away: f32,
    pub throttle_for_steering_help: f32,
    pub throttle_for_steering_help_strength: f32,
    pub throttle_hold: f32,
    pub min_input_magnitude: f32,
    pub throttle_exponent: f32,
    pub turning_exponent: f32,
    pub full_turning_threshold: f32,
    pub full_turning_blending: f32,
    pub extra_forward_zone_angle: f32,
    pub invert_extra_forward_zone_if_backwards: bool,
    pub invert_extra_forward_zone_on_side_facing_camera: bool,
    pub angular_yaw_constraint: f32,
}

pub trait CameraRelativeControlPerSpeedDataTrait: TypeObject {
    fn speed_threshold(&self) -> &f32;
    fn speed_threshold_mut(&mut self) -> &mut f32;
    fn use_in_forward_and_neutral_gears(&self) -> &bool;
    fn use_in_forward_and_neutral_gears_mut(&mut self) -> &mut bool;
    fn use_in_reverse_gear(&self) -> &bool;
    fn use_in_reverse_gear_mut(&mut self) -> &mut bool;
    fn use_in_boost(&self) -> &bool;
    fn use_in_boost_mut(&mut self) -> &mut bool;
    fn use_not_in_boost(&self) -> &bool;
    fn use_not_in_boost_mut(&mut self) -> &mut bool;
    fn world_space_lock_efficiency(&self) -> &f32;
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32;
    fn world_space_lock_efficiency_away(&self) -> &f32;
    fn world_space_lock_efficiency_away_mut(&mut self) -> &mut f32;
    fn throttle_for_steering_help(&self) -> &f32;
    fn throttle_for_steering_help_mut(&mut self) -> &mut f32;
    fn throttle_for_steering_help_strength(&self) -> &f32;
    fn throttle_for_steering_help_strength_mut(&mut self) -> &mut f32;
    fn throttle_hold(&self) -> &f32;
    fn throttle_hold_mut(&mut self) -> &mut f32;
    fn min_input_magnitude(&self) -> &f32;
    fn min_input_magnitude_mut(&mut self) -> &mut f32;
    fn throttle_exponent(&self) -> &f32;
    fn throttle_exponent_mut(&mut self) -> &mut f32;
    fn turning_exponent(&self) -> &f32;
    fn turning_exponent_mut(&mut self) -> &mut f32;
    fn full_turning_threshold(&self) -> &f32;
    fn full_turning_threshold_mut(&mut self) -> &mut f32;
    fn full_turning_blending(&self) -> &f32;
    fn full_turning_blending_mut(&mut self) -> &mut f32;
    fn extra_forward_zone_angle(&self) -> &f32;
    fn extra_forward_zone_angle_mut(&mut self) -> &mut f32;
    fn invert_extra_forward_zone_if_backwards(&self) -> &bool;
    fn invert_extra_forward_zone_if_backwards_mut(&mut self) -> &mut bool;
    fn invert_extra_forward_zone_on_side_facing_camera(&self) -> &bool;
    fn invert_extra_forward_zone_on_side_facing_camera_mut(&mut self) -> &mut bool;
    fn angular_yaw_constraint(&self) -> &f32;
    fn angular_yaw_constraint_mut(&mut self) -> &mut f32;
}

impl CameraRelativeControlPerSpeedDataTrait for CameraRelativeControlPerSpeedData {
    fn speed_threshold(&self) -> &f32 {
        &self.speed_threshold
    }
    fn speed_threshold_mut(&mut self) -> &mut f32 {
        &mut self.speed_threshold
    }
    fn use_in_forward_and_neutral_gears(&self) -> &bool {
        &self.use_in_forward_and_neutral_gears
    }
    fn use_in_forward_and_neutral_gears_mut(&mut self) -> &mut bool {
        &mut self.use_in_forward_and_neutral_gears
    }
    fn use_in_reverse_gear(&self) -> &bool {
        &self.use_in_reverse_gear
    }
    fn use_in_reverse_gear_mut(&mut self) -> &mut bool {
        &mut self.use_in_reverse_gear
    }
    fn use_in_boost(&self) -> &bool {
        &self.use_in_boost
    }
    fn use_in_boost_mut(&mut self) -> &mut bool {
        &mut self.use_in_boost
    }
    fn use_not_in_boost(&self) -> &bool {
        &self.use_not_in_boost
    }
    fn use_not_in_boost_mut(&mut self) -> &mut bool {
        &mut self.use_not_in_boost
    }
    fn world_space_lock_efficiency(&self) -> &f32 {
        &self.world_space_lock_efficiency
    }
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency
    }
    fn world_space_lock_efficiency_away(&self) -> &f32 {
        &self.world_space_lock_efficiency_away
    }
    fn world_space_lock_efficiency_away_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency_away
    }
    fn throttle_for_steering_help(&self) -> &f32 {
        &self.throttle_for_steering_help
    }
    fn throttle_for_steering_help_mut(&mut self) -> &mut f32 {
        &mut self.throttle_for_steering_help
    }
    fn throttle_for_steering_help_strength(&self) -> &f32 {
        &self.throttle_for_steering_help_strength
    }
    fn throttle_for_steering_help_strength_mut(&mut self) -> &mut f32 {
        &mut self.throttle_for_steering_help_strength
    }
    fn throttle_hold(&self) -> &f32 {
        &self.throttle_hold
    }
    fn throttle_hold_mut(&mut self) -> &mut f32 {
        &mut self.throttle_hold
    }
    fn min_input_magnitude(&self) -> &f32 {
        &self.min_input_magnitude
    }
    fn min_input_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.min_input_magnitude
    }
    fn throttle_exponent(&self) -> &f32 {
        &self.throttle_exponent
    }
    fn throttle_exponent_mut(&mut self) -> &mut f32 {
        &mut self.throttle_exponent
    }
    fn turning_exponent(&self) -> &f32 {
        &self.turning_exponent
    }
    fn turning_exponent_mut(&mut self) -> &mut f32 {
        &mut self.turning_exponent
    }
    fn full_turning_threshold(&self) -> &f32 {
        &self.full_turning_threshold
    }
    fn full_turning_threshold_mut(&mut self) -> &mut f32 {
        &mut self.full_turning_threshold
    }
    fn full_turning_blending(&self) -> &f32 {
        &self.full_turning_blending
    }
    fn full_turning_blending_mut(&mut self) -> &mut f32 {
        &mut self.full_turning_blending
    }
    fn extra_forward_zone_angle(&self) -> &f32 {
        &self.extra_forward_zone_angle
    }
    fn extra_forward_zone_angle_mut(&mut self) -> &mut f32 {
        &mut self.extra_forward_zone_angle
    }
    fn invert_extra_forward_zone_if_backwards(&self) -> &bool {
        &self.invert_extra_forward_zone_if_backwards
    }
    fn invert_extra_forward_zone_if_backwards_mut(&mut self) -> &mut bool {
        &mut self.invert_extra_forward_zone_if_backwards
    }
    fn invert_extra_forward_zone_on_side_facing_camera(&self) -> &bool {
        &self.invert_extra_forward_zone_on_side_facing_camera
    }
    fn invert_extra_forward_zone_on_side_facing_camera_mut(&mut self) -> &mut bool {
        &mut self.invert_extra_forward_zone_on_side_facing_camera
    }
    fn angular_yaw_constraint(&self) -> &f32 {
        &self.angular_yaw_constraint
    }
    fn angular_yaw_constraint_mut(&mut self) -> &mut f32 {
        &mut self.angular_yaw_constraint
    }
}

pub static CAMERARELATIVECONTROLPERSPEEDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlPerSpeedData",
    name_hash: 1706336351,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraRelativeControlPerSpeedData as Default>::default())),
            create_boxed: || Box::new(<CameraRelativeControlPerSpeedData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SpeedThreshold",
                name_hash: 1215144053,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, speed_threshold),
            },
            FieldInfoData {
                name: "UseInForwardAndNeutralGears",
                name_hash: 2920500006,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, use_in_forward_and_neutral_gears),
            },
            FieldInfoData {
                name: "UseInReverseGear",
                name_hash: 3374380976,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, use_in_reverse_gear),
            },
            FieldInfoData {
                name: "UseInBoost",
                name_hash: 1914931748,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, use_in_boost),
            },
            FieldInfoData {
                name: "UseNotInBoost",
                name_hash: 1422091377,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, use_not_in_boost),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiency",
                name_hash: 4063999679,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, world_space_lock_efficiency),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiencyAway",
                name_hash: 2194330897,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, world_space_lock_efficiency_away),
            },
            FieldInfoData {
                name: "ThrottleForSteeringHelp",
                name_hash: 951572978,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, throttle_for_steering_help),
            },
            FieldInfoData {
                name: "ThrottleForSteeringHelpStrength",
                name_hash: 2535009271,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, throttle_for_steering_help_strength),
            },
            FieldInfoData {
                name: "ThrottleHold",
                name_hash: 1295112642,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, throttle_hold),
            },
            FieldInfoData {
                name: "MinInputMagnitude",
                name_hash: 4222045205,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, min_input_magnitude),
            },
            FieldInfoData {
                name: "ThrottleExponent",
                name_hash: 4132975102,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, throttle_exponent),
            },
            FieldInfoData {
                name: "TurningExponent",
                name_hash: 993183755,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, turning_exponent),
            },
            FieldInfoData {
                name: "FullTurningThreshold",
                name_hash: 1606373596,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, full_turning_threshold),
            },
            FieldInfoData {
                name: "FullTurningBlending",
                name_hash: 3852837002,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, full_turning_blending),
            },
            FieldInfoData {
                name: "ExtraForwardZoneAngle",
                name_hash: 1481245691,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, extra_forward_zone_angle),
            },
            FieldInfoData {
                name: "InvertExtraForwardZoneIfBackwards",
                name_hash: 3223330623,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, invert_extra_forward_zone_if_backwards),
            },
            FieldInfoData {
                name: "InvertExtraForwardZoneOnSideFacingCamera",
                name_hash: 454017167,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, invert_extra_forward_zone_on_side_facing_camera),
            },
            FieldInfoData {
                name: "AngularYawConstraint",
                name_hash: 159435981,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, angular_yaw_constraint),
            },
        ],
    }),
    array_type: Some(CAMERARELATIVECONTROLPERSPEEDDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CameraRelativeControlPerSpeedData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARELATIVECONTROLPERSPEEDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERARELATIVECONTROLPERSPEEDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlPerSpeedData-Array",
    name_hash: 1709135211,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraRelativeControlPerSpeedData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CameraRelativeControlEnum {
    #[default]
    UseProfileOptions = 0,
    ForceCameraRelative = 1,
}

pub static CAMERARELATIVECONTROLENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlEnum",
    name_hash: 4053884604,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CAMERARELATIVECONTROLENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CameraRelativeControlEnum {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARELATIVECONTROLENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERARELATIVECONTROLENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlEnum-Array",
    name_hash: 4032697864,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraRelativeControlEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LandingGearLogicData {
    pub _glacier_base: super::core::DataContainer,
    pub retract_condition: LandingGearConditionData,
    pub deploy_condition: LandingGearConditionData,
}

pub trait LandingGearLogicDataTrait: super::core::DataContainerTrait {
    fn retract_condition(&self) -> &LandingGearConditionData;
    fn retract_condition_mut(&mut self) -> &mut LandingGearConditionData;
    fn deploy_condition(&self) -> &LandingGearConditionData;
    fn deploy_condition_mut(&mut self) -> &mut LandingGearConditionData;
}

impl LandingGearLogicDataTrait for LandingGearLogicData {
    fn retract_condition(&self) -> &LandingGearConditionData {
        &self.retract_condition
    }
    fn retract_condition_mut(&mut self) -> &mut LandingGearConditionData {
        &mut self.retract_condition
    }
    fn deploy_condition(&self) -> &LandingGearConditionData {
        &self.deploy_condition
    }
    fn deploy_condition_mut(&mut self) -> &mut LandingGearConditionData {
        &mut self.deploy_condition
    }
}

impl super::core::DataContainerTrait for LandingGearLogicData {
}

pub static LANDINGGEARLOGICDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LandingGearLogicData",
    name_hash: 2691244525,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(LandingGearLogicData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LandingGearLogicData as Default>::default())),
            create_boxed: || Box::new(<LandingGearLogicData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RetractCondition",
                name_hash: 750548785,
                flags: MemberInfoFlags::new(0),
                field_type: "LandingGearConditionData",
                rust_offset: offset_of!(LandingGearLogicData, retract_condition),
            },
            FieldInfoData {
                name: "DeployCondition",
                name_hash: 3008584093,
                flags: MemberInfoFlags::new(0),
                field_type: "LandingGearConditionData",
                rust_offset: offset_of!(LandingGearLogicData, deploy_condition),
            },
        ],
    }),
    array_type: Some(LANDINGGEARLOGICDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LandingGearLogicData {
    fn type_info(&self) -> &'static TypeInfo {
        LANDINGGEARLOGICDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LANDINGGEARLOGICDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LandingGearLogicData-Array",
    name_hash: 1104152281,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LandingGearLogicData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LandingGearConditionData {
    pub height: f32,
    pub velocity: f32,
    pub angle: f32,
}

pub trait LandingGearConditionDataTrait: TypeObject {
    fn height(&self) -> &f32;
    fn height_mut(&mut self) -> &mut f32;
    fn velocity(&self) -> &f32;
    fn velocity_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
}

impl LandingGearConditionDataTrait for LandingGearConditionData {
    fn height(&self) -> &f32 {
        &self.height
    }
    fn height_mut(&mut self) -> &mut f32 {
        &mut self.height
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut f32 {
        &mut self.velocity
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
}

pub static LANDINGGEARCONDITIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LandingGearConditionData",
    name_hash: 553692592,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LandingGearConditionData as Default>::default())),
            create_boxed: || Box::new(<LandingGearConditionData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Height",
                name_hash: 3054065626,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LandingGearConditionData, height),
            },
            FieldInfoData {
                name: "Velocity",
                name_hash: 3860766482,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LandingGearConditionData, velocity),
            },
            FieldInfoData {
                name: "Angle",
                name_hash: 205597860,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LandingGearConditionData, angle),
            },
        ],
    }),
    array_type: Some(LANDINGGEARCONDITIONDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LandingGearConditionData {
    fn type_info(&self) -> &'static TypeInfo {
        LANDINGGEARCONDITIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LANDINGGEARCONDITIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LandingGearConditionData-Array",
    name_hash: 3221068548,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LandingGearConditionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleWaterEffectData {
    pub _glacier_base: super::core::DataContainer,
    pub position: super::core::Vec3,
    pub effect: Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>,
}

pub trait VehicleWaterEffectDataTrait: super::core::DataContainerTrait {
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
}

impl VehicleWaterEffectDataTrait for VehicleWaterEffectData {
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &self.effect
    }
    fn effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &mut self.effect
    }
}

impl super::core::DataContainerTrait for VehicleWaterEffectData {
}

pub static VEHICLEWATEREFFECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleWaterEffectData",
    name_hash: 997510735,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(VehicleWaterEffectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleWaterEffectData as Default>::default())),
            create_boxed: || Box::new(<VehicleWaterEffectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Position",
                name_hash: 3402582524,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleWaterEffectData, position),
            },
            FieldInfoData {
                name: "Effect",
                name_hash: 2332983090,
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(VehicleWaterEffectData, effect),
            },
        ],
    }),
    array_type: Some(VEHICLEWATEREFFECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleWaterEffectData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEWATEREFFECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEWATEREFFECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleWaterEffectData-Array",
    name_hash: 3002547067,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleWaterEffectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleExitPointComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub ordinal: i32,
    pub terrain_height: f32,
    pub velocity: f32,
    pub inherit_camera_direction: bool,
    pub impulse: super::core::Vec3,
    pub check_for_vehicle_overrun: bool,
}

pub trait VehicleExitPointComponentDataTrait: super::entity::GameComponentDataTrait {
    fn ordinal(&self) -> &i32;
    fn ordinal_mut(&mut self) -> &mut i32;
    fn terrain_height(&self) -> &f32;
    fn terrain_height_mut(&mut self) -> &mut f32;
    fn velocity(&self) -> &f32;
    fn velocity_mut(&mut self) -> &mut f32;
    fn inherit_camera_direction(&self) -> &bool;
    fn inherit_camera_direction_mut(&mut self) -> &mut bool;
    fn impulse(&self) -> &super::core::Vec3;
    fn impulse_mut(&mut self) -> &mut super::core::Vec3;
    fn check_for_vehicle_overrun(&self) -> &bool;
    fn check_for_vehicle_overrun_mut(&mut self) -> &mut bool;
}

impl VehicleExitPointComponentDataTrait for VehicleExitPointComponentData {
    fn ordinal(&self) -> &i32 {
        &self.ordinal
    }
    fn ordinal_mut(&mut self) -> &mut i32 {
        &mut self.ordinal
    }
    fn terrain_height(&self) -> &f32 {
        &self.terrain_height
    }
    fn terrain_height_mut(&mut self) -> &mut f32 {
        &mut self.terrain_height
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut f32 {
        &mut self.velocity
    }
    fn inherit_camera_direction(&self) -> &bool {
        &self.inherit_camera_direction
    }
    fn inherit_camera_direction_mut(&mut self) -> &mut bool {
        &mut self.inherit_camera_direction
    }
    fn impulse(&self) -> &super::core::Vec3 {
        &self.impulse
    }
    fn impulse_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.impulse
    }
    fn check_for_vehicle_overrun(&self) -> &bool {
        &self.check_for_vehicle_overrun
    }
    fn check_for_vehicle_overrun_mut(&mut self) -> &mut bool {
        &mut self.check_for_vehicle_overrun
    }
}

impl super::entity::GameComponentDataTrait for VehicleExitPointComponentData {
}

impl super::entity::ComponentDataTrait for VehicleExitPointComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleExitPointComponentData {
}

impl super::core::DataBusPeerTrait for VehicleExitPointComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleExitPointComponentData {
}

impl super::core::DataContainerTrait for VehicleExitPointComponentData {
}

pub static VEHICLEEXITPOINTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleExitPointComponentData",
    name_hash: 1849492398,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleExitPointComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleExitPointComponentData as Default>::default())),
            create_boxed: || Box::new(<VehicleExitPointComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Ordinal",
                name_hash: 747685430,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleExitPointComponentData, ordinal),
            },
            FieldInfoData {
                name: "TerrainHeight",
                name_hash: 3163704045,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleExitPointComponentData, terrain_height),
            },
            FieldInfoData {
                name: "Velocity",
                name_hash: 3860766482,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleExitPointComponentData, velocity),
            },
            FieldInfoData {
                name: "InheritCameraDirection",
                name_hash: 1304457244,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleExitPointComponentData, inherit_camera_direction),
            },
            FieldInfoData {
                name: "Impulse",
                name_hash: 1723395486,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleExitPointComponentData, impulse),
            },
            FieldInfoData {
                name: "CheckForVehicleOverrun",
                name_hash: 587298343,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleExitPointComponentData, check_for_vehicle_overrun),
            },
        ],
    }),
    array_type: Some(VEHICLEEXITPOINTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleExitPointComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEEXITPOINTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEEXITPOINTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleExitPointComponentData-Array",
    name_hash: 1225206810,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleExitPointComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub camera: Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */>,
    pub field_of_view: f32,
    pub force_field_of_view: f32,
    pub enable_camera_mesh: bool,
    pub alternate_view: Option<LockedTypeObject /* AlternateCameraViewData */>,
    pub regular_view: RegularCameraViewData,
    pub override_freelook_pitch: f32,
    pub override_freelook_yaw: f32,
    pub override_freelook_enable: bool,
    pub alternate_view_enabled: bool,
    pub camera_relative_control_config: Option<LockedTypeObject /* CameraRelativeControlData */>,
    pub freeze_height: f32,
    pub is_first_person: bool,
    pub receive_impulses_as_third_person: bool,
    pub use_camera_transition: bool,
    pub camera_transition_pos: super::core::Vec3,
    pub camera_transition_time: f32,
    pub mesh_parent_component_number: u32,
    pub stance_data: StanceCameraData,
    pub camera_sound_data: Option<LockedTypeObject /* CameraComponentSoundData */>,
    pub override_transform: super::core::LinearTransform,
}

pub trait CameraComponentDataTrait: super::entity::GameComponentDataTrait {
    fn camera(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */>;
    fn camera_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */>;
    fn field_of_view(&self) -> &f32;
    fn field_of_view_mut(&mut self) -> &mut f32;
    fn force_field_of_view(&self) -> &f32;
    fn force_field_of_view_mut(&mut self) -> &mut f32;
    fn enable_camera_mesh(&self) -> &bool;
    fn enable_camera_mesh_mut(&mut self) -> &mut bool;
    fn alternate_view(&self) -> &Option<LockedTypeObject /* AlternateCameraViewData */>;
    fn alternate_view_mut(&mut self) -> &mut Option<LockedTypeObject /* AlternateCameraViewData */>;
    fn regular_view(&self) -> &RegularCameraViewData;
    fn regular_view_mut(&mut self) -> &mut RegularCameraViewData;
    fn override_freelook_pitch(&self) -> &f32;
    fn override_freelook_pitch_mut(&mut self) -> &mut f32;
    fn override_freelook_yaw(&self) -> &f32;
    fn override_freelook_yaw_mut(&mut self) -> &mut f32;
    fn override_freelook_enable(&self) -> &bool;
    fn override_freelook_enable_mut(&mut self) -> &mut bool;
    fn alternate_view_enabled(&self) -> &bool;
    fn alternate_view_enabled_mut(&mut self) -> &mut bool;
    fn camera_relative_control_config(&self) -> &Option<LockedTypeObject /* CameraRelativeControlData */>;
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraRelativeControlData */>;
    fn freeze_height(&self) -> &f32;
    fn freeze_height_mut(&mut self) -> &mut f32;
    fn is_first_person(&self) -> &bool;
    fn is_first_person_mut(&mut self) -> &mut bool;
    fn receive_impulses_as_third_person(&self) -> &bool;
    fn receive_impulses_as_third_person_mut(&mut self) -> &mut bool;
    fn use_camera_transition(&self) -> &bool;
    fn use_camera_transition_mut(&mut self) -> &mut bool;
    fn camera_transition_pos(&self) -> &super::core::Vec3;
    fn camera_transition_pos_mut(&mut self) -> &mut super::core::Vec3;
    fn camera_transition_time(&self) -> &f32;
    fn camera_transition_time_mut(&mut self) -> &mut f32;
    fn mesh_parent_component_number(&self) -> &u32;
    fn mesh_parent_component_number_mut(&mut self) -> &mut u32;
    fn stance_data(&self) -> &StanceCameraData;
    fn stance_data_mut(&mut self) -> &mut StanceCameraData;
    fn camera_sound_data(&self) -> &Option<LockedTypeObject /* CameraComponentSoundData */>;
    fn camera_sound_data_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraComponentSoundData */>;
    fn override_transform(&self) -> &super::core::LinearTransform;
    fn override_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl CameraComponentDataTrait for CameraComponentData {
    fn camera(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */> {
        &self.camera
    }
    fn camera_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::TargetCameraData */> {
        &mut self.camera
    }
    fn field_of_view(&self) -> &f32 {
        &self.field_of_view
    }
    fn field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view
    }
    fn force_field_of_view(&self) -> &f32 {
        &self.force_field_of_view
    }
    fn force_field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.force_field_of_view
    }
    fn enable_camera_mesh(&self) -> &bool {
        &self.enable_camera_mesh
    }
    fn enable_camera_mesh_mut(&mut self) -> &mut bool {
        &mut self.enable_camera_mesh
    }
    fn alternate_view(&self) -> &Option<LockedTypeObject /* AlternateCameraViewData */> {
        &self.alternate_view
    }
    fn alternate_view_mut(&mut self) -> &mut Option<LockedTypeObject /* AlternateCameraViewData */> {
        &mut self.alternate_view
    }
    fn regular_view(&self) -> &RegularCameraViewData {
        &self.regular_view
    }
    fn regular_view_mut(&mut self) -> &mut RegularCameraViewData {
        &mut self.regular_view
    }
    fn override_freelook_pitch(&self) -> &f32 {
        &self.override_freelook_pitch
    }
    fn override_freelook_pitch_mut(&mut self) -> &mut f32 {
        &mut self.override_freelook_pitch
    }
    fn override_freelook_yaw(&self) -> &f32 {
        &self.override_freelook_yaw
    }
    fn override_freelook_yaw_mut(&mut self) -> &mut f32 {
        &mut self.override_freelook_yaw
    }
    fn override_freelook_enable(&self) -> &bool {
        &self.override_freelook_enable
    }
    fn override_freelook_enable_mut(&mut self) -> &mut bool {
        &mut self.override_freelook_enable
    }
    fn alternate_view_enabled(&self) -> &bool {
        &self.alternate_view_enabled
    }
    fn alternate_view_enabled_mut(&mut self) -> &mut bool {
        &mut self.alternate_view_enabled
    }
    fn camera_relative_control_config(&self) -> &Option<LockedTypeObject /* CameraRelativeControlData */> {
        &self.camera_relative_control_config
    }
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraRelativeControlData */> {
        &mut self.camera_relative_control_config
    }
    fn freeze_height(&self) -> &f32 {
        &self.freeze_height
    }
    fn freeze_height_mut(&mut self) -> &mut f32 {
        &mut self.freeze_height
    }
    fn is_first_person(&self) -> &bool {
        &self.is_first_person
    }
    fn is_first_person_mut(&mut self) -> &mut bool {
        &mut self.is_first_person
    }
    fn receive_impulses_as_third_person(&self) -> &bool {
        &self.receive_impulses_as_third_person
    }
    fn receive_impulses_as_third_person_mut(&mut self) -> &mut bool {
        &mut self.receive_impulses_as_third_person
    }
    fn use_camera_transition(&self) -> &bool {
        &self.use_camera_transition
    }
    fn use_camera_transition_mut(&mut self) -> &mut bool {
        &mut self.use_camera_transition
    }
    fn camera_transition_pos(&self) -> &super::core::Vec3 {
        &self.camera_transition_pos
    }
    fn camera_transition_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.camera_transition_pos
    }
    fn camera_transition_time(&self) -> &f32 {
        &self.camera_transition_time
    }
    fn camera_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.camera_transition_time
    }
    fn mesh_parent_component_number(&self) -> &u32 {
        &self.mesh_parent_component_number
    }
    fn mesh_parent_component_number_mut(&mut self) -> &mut u32 {
        &mut self.mesh_parent_component_number
    }
    fn stance_data(&self) -> &StanceCameraData {
        &self.stance_data
    }
    fn stance_data_mut(&mut self) -> &mut StanceCameraData {
        &mut self.stance_data
    }
    fn camera_sound_data(&self) -> &Option<LockedTypeObject /* CameraComponentSoundData */> {
        &self.camera_sound_data
    }
    fn camera_sound_data_mut(&mut self) -> &mut Option<LockedTypeObject /* CameraComponentSoundData */> {
        &mut self.camera_sound_data
    }
    fn override_transform(&self) -> &super::core::LinearTransform {
        &self.override_transform
    }
    fn override_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.override_transform
    }
}

impl super::entity::GameComponentDataTrait for CameraComponentData {
}

impl super::entity::ComponentDataTrait for CameraComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraComponentData {
}

impl super::core::DataBusPeerTrait for CameraComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraComponentData {
}

impl super::core::DataContainerTrait for CameraComponentData {
}

pub static CAMERACOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraComponentData",
    name_hash: 3995088163,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraComponentData as Default>::default())),
            create_boxed: || Box::new(<CameraComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Camera",
                name_hash: 2716359356,
                flags: MemberInfoFlags::new(0),
                field_type: "TargetCameraData",
                rust_offset: offset_of!(CameraComponentData, camera),
            },
            FieldInfoData {
                name: "FieldOfView",
                name_hash: 2227716035,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, field_of_view),
            },
            FieldInfoData {
                name: "ForceFieldOfView",
                name_hash: 2191221214,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, force_field_of_view),
            },
            FieldInfoData {
                name: "EnableCameraMesh",
                name_hash: 3311112814,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, enable_camera_mesh),
            },
            FieldInfoData {
                name: "AlternateView",
                name_hash: 906681240,
                flags: MemberInfoFlags::new(0),
                field_type: "AlternateCameraViewData",
                rust_offset: offset_of!(CameraComponentData, alternate_view),
            },
            FieldInfoData {
                name: "RegularView",
                name_hash: 653142290,
                flags: MemberInfoFlags::new(0),
                field_type: "RegularCameraViewData",
                rust_offset: offset_of!(CameraComponentData, regular_view),
            },
            FieldInfoData {
                name: "OverrideFreelookPitch",
                name_hash: 2098375364,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, override_freelook_pitch),
            },
            FieldInfoData {
                name: "OverrideFreelookYaw",
                name_hash: 2230268845,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, override_freelook_yaw),
            },
            FieldInfoData {
                name: "OverrideFreelookEnable",
                name_hash: 10317219,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, override_freelook_enable),
            },
            FieldInfoData {
                name: "AlternateViewEnabled",
                name_hash: 541013693,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, alternate_view_enabled),
            },
            FieldInfoData {
                name: "CameraRelativeControlConfig",
                name_hash: 3669484517,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraRelativeControlData",
                rust_offset: offset_of!(CameraComponentData, camera_relative_control_config),
            },
            FieldInfoData {
                name: "FreezeHeight",
                name_hash: 3432929233,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, freeze_height),
            },
            FieldInfoData {
                name: "IsFirstPerson",
                name_hash: 824639024,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, is_first_person),
            },
            FieldInfoData {
                name: "ReceiveImpulsesAsThirdPerson",
                name_hash: 3555599490,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, receive_impulses_as_third_person),
            },
            FieldInfoData {
                name: "UseCameraTransition",
                name_hash: 2345252784,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, use_camera_transition),
            },
            FieldInfoData {
                name: "CameraTransitionPos",
                name_hash: 3159565823,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CameraComponentData, camera_transition_pos),
            },
            FieldInfoData {
                name: "CameraTransitionTime",
                name_hash: 1186593510,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, camera_transition_time),
            },
            FieldInfoData {
                name: "MeshParentComponentNumber",
                name_hash: 1500139014,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CameraComponentData, mesh_parent_component_number),
            },
            FieldInfoData {
                name: "StanceData",
                name_hash: 2329728379,
                flags: MemberInfoFlags::new(0),
                field_type: "StanceCameraData",
                rust_offset: offset_of!(CameraComponentData, stance_data),
            },
            FieldInfoData {
                name: "CameraSoundData",
                name_hash: 3785254511,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraComponentSoundData",
                rust_offset: offset_of!(CameraComponentData, camera_sound_data),
            },
            FieldInfoData {
                name: "OverrideTransform",
                name_hash: 4226660189,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CameraComponentData, override_transform),
            },
        ],
    }),
    array_type: Some(CAMERACOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERACOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraComponentData-Array",
    name_hash: 3137452183,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StanceCameraData {
    pub valid_stances: Vec<i32>,
    pub default_camera_for_stances: Vec<i32>,
}

pub trait StanceCameraDataTrait: TypeObject {
    fn valid_stances(&self) -> &Vec<i32>;
    fn valid_stances_mut(&mut self) -> &mut Vec<i32>;
    fn default_camera_for_stances(&self) -> &Vec<i32>;
    fn default_camera_for_stances_mut(&mut self) -> &mut Vec<i32>;
}

impl StanceCameraDataTrait for StanceCameraData {
    fn valid_stances(&self) -> &Vec<i32> {
        &self.valid_stances
    }
    fn valid_stances_mut(&mut self) -> &mut Vec<i32> {
        &mut self.valid_stances
    }
    fn default_camera_for_stances(&self) -> &Vec<i32> {
        &self.default_camera_for_stances
    }
    fn default_camera_for_stances_mut(&mut self) -> &mut Vec<i32> {
        &mut self.default_camera_for_stances
    }
}

pub static STANCECAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceCameraData",
    name_hash: 544755202,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StanceCameraData as Default>::default())),
            create_boxed: || Box::new(<StanceCameraData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ValidStances",
                name_hash: 4192498222,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StanceCameraData, valid_stances),
            },
            FieldInfoData {
                name: "DefaultCameraForStances",
                name_hash: 1972868017,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StanceCameraData, default_camera_for_stances),
            },
        ],
    }),
    array_type: Some(STANCECAMERADATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StanceCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        STANCECAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STANCECAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceCameraData-Array",
    name_hash: 3611667766,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StanceCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TurretRotationInfo {
    pub rotation_axis: super::gameplay_sim::RotationAxis,
    pub channel: RotationChannel,
    pub normalize_rotation: bool,
    pub max_rotation: f32,
    pub min_rotation: f32,
    pub phase_offset: f32,
    pub invert_rotation: bool,
}

pub trait TurretRotationInfoTrait: TypeObject {
    fn rotation_axis(&self) -> &super::gameplay_sim::RotationAxis;
    fn rotation_axis_mut(&mut self) -> &mut super::gameplay_sim::RotationAxis;
    fn channel(&self) -> &RotationChannel;
    fn channel_mut(&mut self) -> &mut RotationChannel;
    fn normalize_rotation(&self) -> &bool;
    fn normalize_rotation_mut(&mut self) -> &mut bool;
    fn max_rotation(&self) -> &f32;
    fn max_rotation_mut(&mut self) -> &mut f32;
    fn min_rotation(&self) -> &f32;
    fn min_rotation_mut(&mut self) -> &mut f32;
    fn phase_offset(&self) -> &f32;
    fn phase_offset_mut(&mut self) -> &mut f32;
    fn invert_rotation(&self) -> &bool;
    fn invert_rotation_mut(&mut self) -> &mut bool;
}

impl TurretRotationInfoTrait for TurretRotationInfo {
    fn rotation_axis(&self) -> &super::gameplay_sim::RotationAxis {
        &self.rotation_axis
    }
    fn rotation_axis_mut(&mut self) -> &mut super::gameplay_sim::RotationAxis {
        &mut self.rotation_axis
    }
    fn channel(&self) -> &RotationChannel {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut RotationChannel {
        &mut self.channel
    }
    fn normalize_rotation(&self) -> &bool {
        &self.normalize_rotation
    }
    fn normalize_rotation_mut(&mut self) -> &mut bool {
        &mut self.normalize_rotation
    }
    fn max_rotation(&self) -> &f32 {
        &self.max_rotation
    }
    fn max_rotation_mut(&mut self) -> &mut f32 {
        &mut self.max_rotation
    }
    fn min_rotation(&self) -> &f32 {
        &self.min_rotation
    }
    fn min_rotation_mut(&mut self) -> &mut f32 {
        &mut self.min_rotation
    }
    fn phase_offset(&self) -> &f32 {
        &self.phase_offset
    }
    fn phase_offset_mut(&mut self) -> &mut f32 {
        &mut self.phase_offset
    }
    fn invert_rotation(&self) -> &bool {
        &self.invert_rotation
    }
    fn invert_rotation_mut(&mut self) -> &mut bool {
        &mut self.invert_rotation
    }
}

pub static TURRETROTATIONINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TurretRotationInfo",
    name_hash: 1904282639,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TurretRotationInfo as Default>::default())),
            create_boxed: || Box::new(<TurretRotationInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RotationAxis",
                name_hash: 3148542130,
                flags: MemberInfoFlags::new(0),
                field_type: "RotationAxis",
                rust_offset: offset_of!(TurretRotationInfo, rotation_axis),
            },
            FieldInfoData {
                name: "Channel",
                name_hash: 4082709062,
                flags: MemberInfoFlags::new(0),
                field_type: "RotationChannel",
                rust_offset: offset_of!(TurretRotationInfo, channel),
            },
            FieldInfoData {
                name: "NormalizeRotation",
                name_hash: 1190235636,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TurretRotationInfo, normalize_rotation),
            },
            FieldInfoData {
                name: "MaxRotation",
                name_hash: 1608547717,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurretRotationInfo, max_rotation),
            },
            FieldInfoData {
                name: "MinRotation",
                name_hash: 3781648795,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurretRotationInfo, min_rotation),
            },
            FieldInfoData {
                name: "PhaseOffset",
                name_hash: 3780505959,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurretRotationInfo, phase_offset),
            },
            FieldInfoData {
                name: "InvertRotation",
                name_hash: 1002888771,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TurretRotationInfo, invert_rotation),
            },
        ],
    }),
    array_type: Some(TURRETROTATIONINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TurretRotationInfo {
    fn type_info(&self) -> &'static TypeInfo {
        TURRETROTATIONINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TURRETROTATIONINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TurretRotationInfo-Array",
    name_hash: 2809858235,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TurretRotationInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RotationChannel {
    #[default]
    RotationChannel_Pitch = 0,
    RotationChannel_Yaw = 1,
    RotationChannel_Roll = 2,
}

pub static ROTATIONCHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationChannel",
    name_hash: 753222674,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ROTATIONCHANNEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RotationChannel {
    fn type_info(&self) -> &'static TypeInfo {
        ROTATIONCHANNEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ROTATIONCHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationChannel-Array",
    name_hash: 3399871270,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RotationChannel"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ChildBarrelComponentData {
    pub _glacier_base: ChildComponentData,
}

pub trait ChildBarrelComponentDataTrait: ChildComponentDataTrait {
}

impl ChildBarrelComponentDataTrait for ChildBarrelComponentData {
}

impl ChildComponentDataTrait for ChildBarrelComponentData {
    fn sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        self._glacier_base.sound_effect()
    }
    fn sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        self._glacier_base.sound_effect_mut()
    }
    fn moving_body(&self) -> &Option<LockedTypeObject /* super::physics::MovingBodyData */> {
        self._glacier_base.moving_body()
    }
    fn moving_body_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::MovingBodyData */> {
        self._glacier_base.moving_body_mut()
    }
    fn health_zone(&self) -> &VehicleHealthZoneData {
        self._glacier_base.health_zone()
    }
    fn health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        self._glacier_base.health_zone_mut()
    }
    fn sound_effect_start_rpm(&self) -> &f32 {
        self._glacier_base.sound_effect_start_rpm()
    }
    fn sound_effect_start_rpm_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_effect_start_rpm_mut()
    }
    fn sound_effect_stop_rpm(&self) -> &f32 {
        self._glacier_base.sound_effect_stop_rpm()
    }
    fn sound_effect_stop_rpm_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_effect_stop_rpm_mut()
    }
    fn alignment_settings(&self) -> &Option<LockedTypeObject /* AlignmentData */> {
        self._glacier_base.alignment_settings()
    }
    fn alignment_settings_mut(&mut self) -> &mut Option<LockedTypeObject /* AlignmentData */> {
        self._glacier_base.alignment_settings_mut()
    }
    fn world_space_position_lock(&self) -> &bool {
        self._glacier_base.world_space_position_lock()
    }
    fn world_space_position_lock_mut(&mut self) -> &mut bool {
        self._glacier_base.world_space_position_lock_mut()
    }
    fn enable_align_to_camera(&self) -> &bool {
        self._glacier_base.enable_align_to_camera()
    }
    fn enable_align_to_camera_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_align_to_camera_mut()
    }
    fn align_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.align_transform()
    }
    fn align_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.align_transform_mut()
    }
}

impl super::entity::BoneComponentDataTrait for ChildBarrelComponentData {
}

impl super::entity::GameComponentDataTrait for ChildBarrelComponentData {
}

impl super::entity::ComponentDataTrait for ChildBarrelComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ChildBarrelComponentData {
}

impl super::core::DataBusPeerTrait for ChildBarrelComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ChildBarrelComponentData {
}

impl super::core::DataContainerTrait for ChildBarrelComponentData {
}

pub static CHILDBARRELCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildBarrelComponentData",
    name_hash: 2758056538,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHILDCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(ChildBarrelComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildBarrelComponentData as Default>::default())),
            create_boxed: || Box::new(<ChildBarrelComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHILDBARRELCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChildBarrelComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDBARRELCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHILDBARRELCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildBarrelComponentData-Array",
    name_hash: 1076661742,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildBarrelComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AlignmentData {
    pub _glacier_base: super::core::DataContainer,
    pub align_action: i32,
    pub stop_tolerance: f32,
    pub speed: f32,
}

pub trait AlignmentDataTrait: super::core::DataContainerTrait {
    fn align_action(&self) -> &i32;
    fn align_action_mut(&mut self) -> &mut i32;
    fn stop_tolerance(&self) -> &f32;
    fn stop_tolerance_mut(&mut self) -> &mut f32;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
}

impl AlignmentDataTrait for AlignmentData {
    fn align_action(&self) -> &i32 {
        &self.align_action
    }
    fn align_action_mut(&mut self) -> &mut i32 {
        &mut self.align_action
    }
    fn stop_tolerance(&self) -> &f32 {
        &self.stop_tolerance
    }
    fn stop_tolerance_mut(&mut self) -> &mut f32 {
        &mut self.stop_tolerance
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
}

impl super::core::DataContainerTrait for AlignmentData {
}

pub static ALIGNMENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlignmentData",
    name_hash: 3519085898,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AlignmentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AlignmentData as Default>::default())),
            create_boxed: || Box::new(<AlignmentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AlignAction",
                name_hash: 2810627638,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AlignmentData, align_action),
            },
            FieldInfoData {
                name: "StopTolerance",
                name_hash: 3127075412,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlignmentData, stop_tolerance),
            },
            FieldInfoData {
                name: "Speed",
                name_hash: 230887042,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlignmentData, speed),
            },
        ],
    }),
    array_type: Some(ALIGNMENTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AlignmentData {
    fn type_info(&self) -> &'static TypeInfo {
        ALIGNMENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ALIGNMENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlignmentData-Array",
    name_hash: 4168378622,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AlignmentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RotorComponentData {
    pub _glacier_base: super::gameplay_sim::TwoPartComponentData,
    pub low_rpm_model: RotorModelData,
    pub high_rpm_model: RotorModelData,
    pub rotation_axis: super::gameplay_sim::RotationAxis,
    pub rotation_multiplier: f32,
    pub change_model_rpm: f32,
    pub blow_effect: Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>,
    pub only_trigger_blow_effect_in_water: bool,
    pub trigger_ground_effect_height: f32,
    pub ground_effect_on_terrain_only: bool,
    pub critically_damaged_rotation_force: f32,
    pub critical_damage: bool,
}

pub trait RotorComponentDataTrait: super::gameplay_sim::TwoPartComponentDataTrait {
    fn low_rpm_model(&self) -> &RotorModelData;
    fn low_rpm_model_mut(&mut self) -> &mut RotorModelData;
    fn high_rpm_model(&self) -> &RotorModelData;
    fn high_rpm_model_mut(&mut self) -> &mut RotorModelData;
    fn rotation_axis(&self) -> &super::gameplay_sim::RotationAxis;
    fn rotation_axis_mut(&mut self) -> &mut super::gameplay_sim::RotationAxis;
    fn rotation_multiplier(&self) -> &f32;
    fn rotation_multiplier_mut(&mut self) -> &mut f32;
    fn change_model_rpm(&self) -> &f32;
    fn change_model_rpm_mut(&mut self) -> &mut f32;
    fn blow_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn blow_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn only_trigger_blow_effect_in_water(&self) -> &bool;
    fn only_trigger_blow_effect_in_water_mut(&mut self) -> &mut bool;
    fn trigger_ground_effect_height(&self) -> &f32;
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32;
    fn ground_effect_on_terrain_only(&self) -> &bool;
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool;
    fn critically_damaged_rotation_force(&self) -> &f32;
    fn critically_damaged_rotation_force_mut(&mut self) -> &mut f32;
    fn critical_damage(&self) -> &bool;
    fn critical_damage_mut(&mut self) -> &mut bool;
}

impl RotorComponentDataTrait for RotorComponentData {
    fn low_rpm_model(&self) -> &RotorModelData {
        &self.low_rpm_model
    }
    fn low_rpm_model_mut(&mut self) -> &mut RotorModelData {
        &mut self.low_rpm_model
    }
    fn high_rpm_model(&self) -> &RotorModelData {
        &self.high_rpm_model
    }
    fn high_rpm_model_mut(&mut self) -> &mut RotorModelData {
        &mut self.high_rpm_model
    }
    fn rotation_axis(&self) -> &super::gameplay_sim::RotationAxis {
        &self.rotation_axis
    }
    fn rotation_axis_mut(&mut self) -> &mut super::gameplay_sim::RotationAxis {
        &mut self.rotation_axis
    }
    fn rotation_multiplier(&self) -> &f32 {
        &self.rotation_multiplier
    }
    fn rotation_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.rotation_multiplier
    }
    fn change_model_rpm(&self) -> &f32 {
        &self.change_model_rpm
    }
    fn change_model_rpm_mut(&mut self) -> &mut f32 {
        &mut self.change_model_rpm
    }
    fn blow_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &self.blow_effect
    }
    fn blow_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &mut self.blow_effect
    }
    fn only_trigger_blow_effect_in_water(&self) -> &bool {
        &self.only_trigger_blow_effect_in_water
    }
    fn only_trigger_blow_effect_in_water_mut(&mut self) -> &mut bool {
        &mut self.only_trigger_blow_effect_in_water
    }
    fn trigger_ground_effect_height(&self) -> &f32 {
        &self.trigger_ground_effect_height
    }
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32 {
        &mut self.trigger_ground_effect_height
    }
    fn ground_effect_on_terrain_only(&self) -> &bool {
        &self.ground_effect_on_terrain_only
    }
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool {
        &mut self.ground_effect_on_terrain_only
    }
    fn critically_damaged_rotation_force(&self) -> &f32 {
        &self.critically_damaged_rotation_force
    }
    fn critically_damaged_rotation_force_mut(&mut self) -> &mut f32 {
        &mut self.critically_damaged_rotation_force
    }
    fn critical_damage(&self) -> &bool {
        &self.critical_damage
    }
    fn critical_damage_mut(&mut self) -> &mut bool {
        &mut self.critical_damage
    }
}

impl super::gameplay_sim::TwoPartComponentDataTrait for RotorComponentData {
}

impl super::entity::GameComponentDataTrait for RotorComponentData {
}

impl super::entity::ComponentDataTrait for RotorComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for RotorComponentData {
}

impl super::core::DataBusPeerTrait for RotorComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RotorComponentData {
}

impl super::core::DataContainerTrait for RotorComponentData {
}

pub static ROTORCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotorComponentData",
    name_hash: 3904124366,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TWOPARTCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(RotorComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RotorComponentData as Default>::default())),
            create_boxed: || Box::new(<RotorComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LowRpmModel",
                name_hash: 3693202929,
                flags: MemberInfoFlags::new(0),
                field_type: "RotorModelData",
                rust_offset: offset_of!(RotorComponentData, low_rpm_model),
            },
            FieldInfoData {
                name: "HighRpmModel",
                name_hash: 4157411755,
                flags: MemberInfoFlags::new(0),
                field_type: "RotorModelData",
                rust_offset: offset_of!(RotorComponentData, high_rpm_model),
            },
            FieldInfoData {
                name: "RotationAxis",
                name_hash: 3148542130,
                flags: MemberInfoFlags::new(0),
                field_type: "RotationAxis",
                rust_offset: offset_of!(RotorComponentData, rotation_axis),
            },
            FieldInfoData {
                name: "RotationMultiplier",
                name_hash: 1226236954,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorComponentData, rotation_multiplier),
            },
            FieldInfoData {
                name: "ChangeModelRpm",
                name_hash: 935487395,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorComponentData, change_model_rpm),
            },
            FieldInfoData {
                name: "BlowEffect",
                name_hash: 3040391844,
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(RotorComponentData, blow_effect),
            },
            FieldInfoData {
                name: "OnlyTriggerBlowEffectInWater",
                name_hash: 2216323514,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RotorComponentData, only_trigger_blow_effect_in_water),
            },
            FieldInfoData {
                name: "TriggerGroundEffectHeight",
                name_hash: 1753938672,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorComponentData, trigger_ground_effect_height),
            },
            FieldInfoData {
                name: "GroundEffectOnTerrainOnly",
                name_hash: 1990027221,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RotorComponentData, ground_effect_on_terrain_only),
            },
            FieldInfoData {
                name: "CriticallyDamagedRotationForce",
                name_hash: 482271037,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorComponentData, critically_damaged_rotation_force),
            },
            FieldInfoData {
                name: "CriticalDamage",
                name_hash: 3377319365,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RotorComponentData, critical_damage),
            },
        ],
    }),
    array_type: Some(ROTORCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RotorComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ROTORCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ROTORCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotorComponentData-Array",
    name_hash: 2505027450,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RotorComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RotorModelData {
    pub rotation_rpm: f32,
    pub part_index: u32,
}

pub trait RotorModelDataTrait: TypeObject {
    fn rotation_rpm(&self) -> &f32;
    fn rotation_rpm_mut(&mut self) -> &mut f32;
    fn part_index(&self) -> &u32;
    fn part_index_mut(&mut self) -> &mut u32;
}

impl RotorModelDataTrait for RotorModelData {
    fn rotation_rpm(&self) -> &f32 {
        &self.rotation_rpm
    }
    fn rotation_rpm_mut(&mut self) -> &mut f32 {
        &mut self.rotation_rpm
    }
    fn part_index(&self) -> &u32 {
        &self.part_index
    }
    fn part_index_mut(&mut self) -> &mut u32 {
        &mut self.part_index
    }
}

pub static ROTORMODELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotorModelData",
    name_hash: 2641361710,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RotorModelData as Default>::default())),
            create_boxed: || Box::new(<RotorModelData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RotationRpm",
                name_hash: 1136603326,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorModelData, rotation_rpm),
            },
            FieldInfoData {
                name: "PartIndex",
                name_hash: 3213901068,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RotorModelData, part_index),
            },
        ],
    }),
    array_type: Some(ROTORMODELDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RotorModelData {
    fn type_info(&self) -> &'static TypeInfo {
        ROTORMODELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ROTORMODELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotorModelData-Array",
    name_hash: 2205533082,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RotorModelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TrackComponentData {
    pub _glacier_base: MeshComponentData,
    pub skeleton: Option<LockedTypeObject /* super::entity::SkeletonAsset */>,
    pub scroll_factor: f32,
}

pub trait TrackComponentDataTrait: MeshComponentDataTrait {
    fn skeleton(&self) -> &Option<LockedTypeObject /* super::entity::SkeletonAsset */>;
    fn skeleton_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::SkeletonAsset */>;
    fn scroll_factor(&self) -> &f32;
    fn scroll_factor_mut(&mut self) -> &mut f32;
}

impl TrackComponentDataTrait for TrackComponentData {
    fn skeleton(&self) -> &Option<LockedTypeObject /* super::entity::SkeletonAsset */> {
        &self.skeleton
    }
    fn skeleton_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::SkeletonAsset */> {
        &mut self.skeleton
    }
    fn scroll_factor(&self) -> &f32 {
        &self.scroll_factor
    }
    fn scroll_factor_mut(&mut self) -> &mut f32 {
        &mut self.scroll_factor
    }
}

impl MeshComponentDataTrait for TrackComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh_mut()
    }
}

impl super::entity::GameComponentDataTrait for TrackComponentData {
}

impl super::entity::ComponentDataTrait for TrackComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for TrackComponentData {
}

impl super::core::DataBusPeerTrait for TrackComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TrackComponentData {
}

impl super::core::DataContainerTrait for TrackComponentData {
}

pub static TRACKCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackComponentData",
    name_hash: 3028109269,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MESHCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(TrackComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrackComponentData as Default>::default())),
            create_boxed: || Box::new(<TrackComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Skeleton",
                name_hash: 291024164,
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(TrackComponentData, skeleton),
            },
            FieldInfoData {
                name: "ScrollFactor",
                name_hash: 3975253477,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrackComponentData, scroll_factor),
            },
        ],
    }),
    array_type: Some(TRACKCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TrackComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRACKCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackComponentData-Array",
    name_hash: 2302412769,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrackComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FakePhysicsMeshComponentData {
    pub _glacier_base: MeshComponentData,
    pub bone_fake_physics: Vec<Option<LockedTypeObject /* BoneFakePhysicsData */>>,
    pub skeleton: Option<LockedTypeObject /* super::entity::SkeletonAsset */>,
    pub extract_mesh_transforms: bool,
    pub mesh_transforms: Vec<BoxedTypeObject /* super::core::LinearTransform */>,
}

pub trait FakePhysicsMeshComponentDataTrait: MeshComponentDataTrait {
    fn bone_fake_physics(&self) -> &Vec<Option<LockedTypeObject /* BoneFakePhysicsData */>>;
    fn bone_fake_physics_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* BoneFakePhysicsData */>>;
    fn skeleton(&self) -> &Option<LockedTypeObject /* super::entity::SkeletonAsset */>;
    fn skeleton_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::SkeletonAsset */>;
    fn extract_mesh_transforms(&self) -> &bool;
    fn extract_mesh_transforms_mut(&mut self) -> &mut bool;
    fn mesh_transforms(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn mesh_transforms_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */>;
}

impl FakePhysicsMeshComponentDataTrait for FakePhysicsMeshComponentData {
    fn bone_fake_physics(&self) -> &Vec<Option<LockedTypeObject /* BoneFakePhysicsData */>> {
        &self.bone_fake_physics
    }
    fn bone_fake_physics_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* BoneFakePhysicsData */>> {
        &mut self.bone_fake_physics
    }
    fn skeleton(&self) -> &Option<LockedTypeObject /* super::entity::SkeletonAsset */> {
        &self.skeleton
    }
    fn skeleton_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::SkeletonAsset */> {
        &mut self.skeleton
    }
    fn extract_mesh_transforms(&self) -> &bool {
        &self.extract_mesh_transforms
    }
    fn extract_mesh_transforms_mut(&mut self) -> &mut bool {
        &mut self.extract_mesh_transforms
    }
    fn mesh_transforms(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &self.mesh_transforms
    }
    fn mesh_transforms_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &mut self.mesh_transforms
    }
}

impl MeshComponentDataTrait for FakePhysicsMeshComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh_mut()
    }
}

impl super::entity::GameComponentDataTrait for FakePhysicsMeshComponentData {
}

impl super::entity::ComponentDataTrait for FakePhysicsMeshComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for FakePhysicsMeshComponentData {
}

impl super::core::DataBusPeerTrait for FakePhysicsMeshComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FakePhysicsMeshComponentData {
}

impl super::core::DataContainerTrait for FakePhysicsMeshComponentData {
}

pub static FAKEPHYSICSMESHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FakePhysicsMeshComponentData",
    name_hash: 4243717419,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MESHCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(FakePhysicsMeshComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FakePhysicsMeshComponentData as Default>::default())),
            create_boxed: || Box::new(<FakePhysicsMeshComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BoneFakePhysics",
                name_hash: 2227758113,
                flags: MemberInfoFlags::new(144),
                field_type: "BoneFakePhysicsData-Array",
                rust_offset: offset_of!(FakePhysicsMeshComponentData, bone_fake_physics),
            },
            FieldInfoData {
                name: "Skeleton",
                name_hash: 291024164,
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(FakePhysicsMeshComponentData, skeleton),
            },
            FieldInfoData {
                name: "ExtractMeshTransforms",
                name_hash: 1215248452,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FakePhysicsMeshComponentData, extract_mesh_transforms),
            },
            FieldInfoData {
                name: "MeshTransforms",
                name_hash: 3575082313,
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(FakePhysicsMeshComponentData, mesh_transforms),
            },
        ],
    }),
    array_type: Some(FAKEPHYSICSMESHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FakePhysicsMeshComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        FAKEPHYSICSMESHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FAKEPHYSICSMESHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FakePhysicsMeshComponentData-Array",
    name_hash: 2760432799,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FakePhysicsMeshComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MeshComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
}

pub trait MeshComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
}

impl MeshComponentDataTrait for MeshComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh
    }
}

impl super::entity::GameComponentDataTrait for MeshComponentData {
}

impl super::entity::ComponentDataTrait for MeshComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for MeshComponentData {
}

impl super::core::DataBusPeerTrait for MeshComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MeshComponentData {
}

impl super::core::DataContainerTrait for MeshComponentData {
}

pub static MESHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshComponentData",
    name_hash: 2073269161,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(MeshComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshComponentData as Default>::default())),
            create_boxed: || Box::new(<MeshComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MeshComponentData, realm),
            },
            FieldInfoData {
                name: "Mesh",
                name_hash: 2088783990,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(MeshComponentData, mesh),
            },
        ],
    }),
    array_type: Some(MESHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MeshComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MESHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshComponentData-Array",
    name_hash: 1516821021,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleCustomizationComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub always_load_cockpitmesh: bool,
    pub visual_unlock: Option<LockedTypeObject /* VisualUnlockAsset */>,
    pub customization: Option<LockedTypeObject /* VehicleCustomizationAsset */>,
}

pub trait VehicleCustomizationComponentDataTrait: super::entity::GameComponentDataTrait {
    fn always_load_cockpitmesh(&self) -> &bool;
    fn always_load_cockpitmesh_mut(&mut self) -> &mut bool;
    fn visual_unlock(&self) -> &Option<LockedTypeObject /* VisualUnlockAsset */>;
    fn visual_unlock_mut(&mut self) -> &mut Option<LockedTypeObject /* VisualUnlockAsset */>;
    fn customization(&self) -> &Option<LockedTypeObject /* VehicleCustomizationAsset */>;
    fn customization_mut(&mut self) -> &mut Option<LockedTypeObject /* VehicleCustomizationAsset */>;
}

impl VehicleCustomizationComponentDataTrait for VehicleCustomizationComponentData {
    fn always_load_cockpitmesh(&self) -> &bool {
        &self.always_load_cockpitmesh
    }
    fn always_load_cockpitmesh_mut(&mut self) -> &mut bool {
        &mut self.always_load_cockpitmesh
    }
    fn visual_unlock(&self) -> &Option<LockedTypeObject /* VisualUnlockAsset */> {
        &self.visual_unlock
    }
    fn visual_unlock_mut(&mut self) -> &mut Option<LockedTypeObject /* VisualUnlockAsset */> {
        &mut self.visual_unlock
    }
    fn customization(&self) -> &Option<LockedTypeObject /* VehicleCustomizationAsset */> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<LockedTypeObject /* VehicleCustomizationAsset */> {
        &mut self.customization
    }
}

impl super::entity::GameComponentDataTrait for VehicleCustomizationComponentData {
}

impl super::entity::ComponentDataTrait for VehicleCustomizationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleCustomizationComponentData {
}

impl super::core::DataBusPeerTrait for VehicleCustomizationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleCustomizationComponentData {
}

impl super::core::DataContainerTrait for VehicleCustomizationComponentData {
}

pub static VEHICLECUSTOMIZATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCustomizationComponentData",
    name_hash: 3071300095,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleCustomizationComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleCustomizationComponentData as Default>::default())),
            create_boxed: || Box::new(<VehicleCustomizationComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AlwaysLoadCockpitmesh",
                name_hash: 1863488360,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCustomizationComponentData, always_load_cockpitmesh),
            },
            FieldInfoData {
                name: "VisualUnlock",
                name_hash: 629823297,
                flags: MemberInfoFlags::new(0),
                field_type: "VisualUnlockAsset",
                rust_offset: offset_of!(VehicleCustomizationComponentData, visual_unlock),
            },
            FieldInfoData {
                name: "Customization",
                name_hash: 1998291608,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleCustomizationAsset",
                rust_offset: offset_of!(VehicleCustomizationComponentData, customization),
            },
        ],
    }),
    array_type: Some(VEHICLECUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleCustomizationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECUSTOMIZATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLECUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCustomizationComponentData-Array",
    name_hash: 3462019019,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleCustomizationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleMeshComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub cockpit_mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
}

pub trait VehicleMeshComponentDataTrait: super::entity::GameComponentDataTrait {
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn cockpit_mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn cockpit_mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
}

impl VehicleMeshComponentDataTrait for VehicleMeshComponentData {
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh
    }
    fn cockpit_mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.cockpit_mesh
    }
    fn cockpit_mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.cockpit_mesh
    }
}

impl super::entity::GameComponentDataTrait for VehicleMeshComponentData {
}

impl super::entity::ComponentDataTrait for VehicleMeshComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleMeshComponentData {
}

impl super::core::DataBusPeerTrait for VehicleMeshComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleMeshComponentData {
}

impl super::core::DataContainerTrait for VehicleMeshComponentData {
}

pub static VEHICLEMESHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleMeshComponentData",
    name_hash: 40282257,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleMeshComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleMeshComponentData as Default>::default())),
            create_boxed: || Box::new(<VehicleMeshComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                name_hash: 2088783990,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(VehicleMeshComponentData, mesh),
            },
            FieldInfoData {
                name: "CockpitMesh",
                name_hash: 1006188287,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(VehicleMeshComponentData, cockpit_mesh),
            },
        ],
    }),
    array_type: Some(VEHICLEMESHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleMeshComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEMESHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEMESHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleMeshComponentData-Array",
    name_hash: 1541360165,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleMeshComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RotationAxisEnum {
    #[default]
    RALeft = 0,
    RAUp = 1,
    RADof = 2,
}

pub static ROTATIONAXISENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationAxisEnum",
    name_hash: 2216249985,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ROTATIONAXISENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RotationAxisEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ROTATIONAXISENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ROTATIONAXISENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationAxisEnum-Array",
    name_hash: 1710269493,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RotationAxisEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TrackWheelComponentData {
    pub _glacier_base: WheelComponentData,
    pub bone_name: String,
}

pub trait TrackWheelComponentDataTrait: WheelComponentDataTrait {
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
}

impl TrackWheelComponentDataTrait for TrackWheelComponentData {
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
}

impl WheelComponentDataTrait for TrackWheelComponentData {
    fn config(&self) -> &Option<LockedTypeObject /* super::physics::WheelConfigData */> {
        self._glacier_base.config()
    }
    fn config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::WheelConfigData */> {
        self._glacier_base.config_mut()
    }
    fn physics_type(&self) -> &super::gameplay_sim::WheelPhysicsType {
        self._glacier_base.physics_type()
    }
    fn physics_type_mut(&mut self) -> &mut super::gameplay_sim::WheelPhysicsType {
        self._glacier_base.physics_type_mut()
    }
    fn effect_clamp_velocity(&self) -> &f32 {
        self._glacier_base.effect_clamp_velocity()
    }
    fn effect_clamp_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.effect_clamp_velocity_mut()
    }
}

impl super::entity::BoneComponentDataTrait for TrackWheelComponentData {
}

impl super::entity::GameComponentDataTrait for TrackWheelComponentData {
}

impl super::entity::ComponentDataTrait for TrackWheelComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for TrackWheelComponentData {
}

impl super::core::DataBusPeerTrait for TrackWheelComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TrackWheelComponentData {
}

impl super::core::DataContainerTrait for TrackWheelComponentData {
}

pub static TRACKWHEELCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackWheelComponentData",
    name_hash: 3285838854,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WHEELCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(TrackWheelComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrackWheelComponentData as Default>::default())),
            create_boxed: || Box::new(<TrackWheelComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BoneName",
                name_hash: 1590647844,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TrackWheelComponentData, bone_name),
            },
        ],
    }),
    array_type: Some(TRACKWHEELCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TrackWheelComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKWHEELCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRACKWHEELCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackWheelComponentData-Array",
    name_hash: 1378187570,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrackWheelComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct WheelComponentData {
    pub _glacier_base: super::entity::BoneComponentData,
    pub config: Option<LockedTypeObject /* super::physics::WheelConfigData */>,
    pub physics_type: super::gameplay_sim::WheelPhysicsType,
    pub effect_clamp_velocity: f32,
}

pub trait WheelComponentDataTrait: super::entity::BoneComponentDataTrait {
    fn config(&self) -> &Option<LockedTypeObject /* super::physics::WheelConfigData */>;
    fn config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::WheelConfigData */>;
    fn physics_type(&self) -> &super::gameplay_sim::WheelPhysicsType;
    fn physics_type_mut(&mut self) -> &mut super::gameplay_sim::WheelPhysicsType;
    fn effect_clamp_velocity(&self) -> &f32;
    fn effect_clamp_velocity_mut(&mut self) -> &mut f32;
}

impl WheelComponentDataTrait for WheelComponentData {
    fn config(&self) -> &Option<LockedTypeObject /* super::physics::WheelConfigData */> {
        &self.config
    }
    fn config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::WheelConfigData */> {
        &mut self.config
    }
    fn physics_type(&self) -> &super::gameplay_sim::WheelPhysicsType {
        &self.physics_type
    }
    fn physics_type_mut(&mut self) -> &mut super::gameplay_sim::WheelPhysicsType {
        &mut self.physics_type
    }
    fn effect_clamp_velocity(&self) -> &f32 {
        &self.effect_clamp_velocity
    }
    fn effect_clamp_velocity_mut(&mut self) -> &mut f32 {
        &mut self.effect_clamp_velocity
    }
}

impl super::entity::BoneComponentDataTrait for WheelComponentData {
}

impl super::entity::GameComponentDataTrait for WheelComponentData {
}

impl super::entity::ComponentDataTrait for WheelComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WheelComponentData {
}

impl super::core::DataBusPeerTrait for WheelComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WheelComponentData {
}

impl super::core::DataContainerTrait for WheelComponentData {
}

pub static WHEELCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WheelComponentData",
    name_hash: 3345815177,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::BONECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(WheelComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WheelComponentData as Default>::default())),
            create_boxed: || Box::new(<WheelComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Config",
                name_hash: 2713732399,
                flags: MemberInfoFlags::new(0),
                field_type: "WheelConfigData",
                rust_offset: offset_of!(WheelComponentData, config),
            },
            FieldInfoData {
                name: "PhysicsType",
                name_hash: 1744391446,
                flags: MemberInfoFlags::new(0),
                field_type: "WheelPhysicsType",
                rust_offset: offset_of!(WheelComponentData, physics_type),
            },
            FieldInfoData {
                name: "EffectClampVelocity",
                name_hash: 2869239062,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WheelComponentData, effect_clamp_velocity),
            },
        ],
    }),
    array_type: Some(WHEELCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WheelComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WHEELCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WHEELCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WheelComponentData-Array",
    name_hash: 1181535293,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WheelComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StanceFilterComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub valid_stances: Vec<i32>,
    pub stance_change_time: f32,
    pub undo_parent_stance_filter: bool,
    pub filter_specific_actions: bool,
    pub actions_to_filter: Vec<BoxedTypeObject /* ActionSuppressor */>,
}

pub trait StanceFilterComponentDataTrait: super::entity::GameComponentDataTrait {
    fn valid_stances(&self) -> &Vec<i32>;
    fn valid_stances_mut(&mut self) -> &mut Vec<i32>;
    fn stance_change_time(&self) -> &f32;
    fn stance_change_time_mut(&mut self) -> &mut f32;
    fn undo_parent_stance_filter(&self) -> &bool;
    fn undo_parent_stance_filter_mut(&mut self) -> &mut bool;
    fn filter_specific_actions(&self) -> &bool;
    fn filter_specific_actions_mut(&mut self) -> &mut bool;
    fn actions_to_filter(&self) -> &Vec<BoxedTypeObject /* ActionSuppressor */>;
    fn actions_to_filter_mut(&mut self) -> &mut Vec<BoxedTypeObject /* ActionSuppressor */>;
}

impl StanceFilterComponentDataTrait for StanceFilterComponentData {
    fn valid_stances(&self) -> &Vec<i32> {
        &self.valid_stances
    }
    fn valid_stances_mut(&mut self) -> &mut Vec<i32> {
        &mut self.valid_stances
    }
    fn stance_change_time(&self) -> &f32 {
        &self.stance_change_time
    }
    fn stance_change_time_mut(&mut self) -> &mut f32 {
        &mut self.stance_change_time
    }
    fn undo_parent_stance_filter(&self) -> &bool {
        &self.undo_parent_stance_filter
    }
    fn undo_parent_stance_filter_mut(&mut self) -> &mut bool {
        &mut self.undo_parent_stance_filter
    }
    fn filter_specific_actions(&self) -> &bool {
        &self.filter_specific_actions
    }
    fn filter_specific_actions_mut(&mut self) -> &mut bool {
        &mut self.filter_specific_actions
    }
    fn actions_to_filter(&self) -> &Vec<BoxedTypeObject /* ActionSuppressor */> {
        &self.actions_to_filter
    }
    fn actions_to_filter_mut(&mut self) -> &mut Vec<BoxedTypeObject /* ActionSuppressor */> {
        &mut self.actions_to_filter
    }
}

impl super::entity::GameComponentDataTrait for StanceFilterComponentData {
}

impl super::entity::ComponentDataTrait for StanceFilterComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StanceFilterComponentData {
}

impl super::core::DataBusPeerTrait for StanceFilterComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StanceFilterComponentData {
}

impl super::core::DataContainerTrait for StanceFilterComponentData {
}

pub static STANCEFILTERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceFilterComponentData",
    name_hash: 1358040692,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(StanceFilterComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StanceFilterComponentData as Default>::default())),
            create_boxed: || Box::new(<StanceFilterComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ValidStances",
                name_hash: 4192498222,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StanceFilterComponentData, valid_stances),
            },
            FieldInfoData {
                name: "StanceChangeTime",
                name_hash: 58412120,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StanceFilterComponentData, stance_change_time),
            },
            FieldInfoData {
                name: "UndoParentStanceFilter",
                name_hash: 1383671783,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StanceFilterComponentData, undo_parent_stance_filter),
            },
            FieldInfoData {
                name: "FilterSpecificActions",
                name_hash: 1330805128,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StanceFilterComponentData, filter_specific_actions),
            },
            FieldInfoData {
                name: "ActionsToFilter",
                name_hash: 2075922899,
                flags: MemberInfoFlags::new(144),
                field_type: "ActionSuppressor-Array",
                rust_offset: offset_of!(StanceFilterComponentData, actions_to_filter),
            },
        ],
    }),
    array_type: Some(STANCEFILTERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StanceFilterComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STANCEFILTERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STANCEFILTERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceFilterComponentData-Array",
    name_hash: 195050048,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StanceFilterComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EngineComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub config: Option<LockedTypeObject /* super::physics::EngineConfigData */>,
    pub sound_effect: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub surface_sound_effect: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub use_first_person_sounds: bool,
}

pub trait EngineComponentDataTrait: super::entity::GameComponentDataTrait {
    fn config(&self) -> &Option<LockedTypeObject /* super::physics::EngineConfigData */>;
    fn config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::EngineConfigData */>;
    fn sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn surface_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn surface_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn use_first_person_sounds(&self) -> &bool;
    fn use_first_person_sounds_mut(&mut self) -> &mut bool;
}

impl EngineComponentDataTrait for EngineComponentData {
    fn config(&self) -> &Option<LockedTypeObject /* super::physics::EngineConfigData */> {
        &self.config
    }
    fn config_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::EngineConfigData */> {
        &mut self.config
    }
    fn sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.sound_effect
    }
    fn sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.sound_effect
    }
    fn surface_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.surface_sound_effect
    }
    fn surface_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.surface_sound_effect
    }
    fn use_first_person_sounds(&self) -> &bool {
        &self.use_first_person_sounds
    }
    fn use_first_person_sounds_mut(&mut self) -> &mut bool {
        &mut self.use_first_person_sounds
    }
}

impl super::entity::GameComponentDataTrait for EngineComponentData {
}

impl super::entity::ComponentDataTrait for EngineComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EngineComponentData {
}

impl super::core::DataBusPeerTrait for EngineComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EngineComponentData {
}

impl super::core::DataContainerTrait for EngineComponentData {
}

pub static ENGINECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EngineComponentData",
    name_hash: 2125872276,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(EngineComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EngineComponentData as Default>::default())),
            create_boxed: || Box::new(<EngineComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Config",
                name_hash: 2713732399,
                flags: MemberInfoFlags::new(0),
                field_type: "EngineConfigData",
                rust_offset: offset_of!(EngineComponentData, config),
            },
            FieldInfoData {
                name: "SoundEffect",
                name_hash: 3556609201,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(EngineComponentData, sound_effect),
            },
            FieldInfoData {
                name: "SurfaceSoundEffect",
                name_hash: 3348100644,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(EngineComponentData, surface_sound_effect),
            },
            FieldInfoData {
                name: "UseFirstPersonSounds",
                name_hash: 2865323833,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EngineComponentData, use_first_person_sounds),
            },
        ],
    }),
    array_type: Some(ENGINECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EngineComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ENGINECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENGINECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EngineComponentData-Array",
    name_hash: 2818750624,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EngineComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ChildComponentData {
    pub _glacier_base: super::entity::BoneComponentData,
    pub sound_effect: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub moving_body: Option<LockedTypeObject /* super::physics::MovingBodyData */>,
    pub health_zone: VehicleHealthZoneData,
    pub sound_effect_start_rpm: f32,
    pub sound_effect_stop_rpm: f32,
    pub alignment_settings: Option<LockedTypeObject /* AlignmentData */>,
    pub world_space_position_lock: bool,
    pub enable_align_to_camera: bool,
    pub align_transform: super::core::LinearTransform,
}

pub trait ChildComponentDataTrait: super::entity::BoneComponentDataTrait {
    fn sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn moving_body(&self) -> &Option<LockedTypeObject /* super::physics::MovingBodyData */>;
    fn moving_body_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::MovingBodyData */>;
    fn health_zone(&self) -> &VehicleHealthZoneData;
    fn health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn sound_effect_start_rpm(&self) -> &f32;
    fn sound_effect_start_rpm_mut(&mut self) -> &mut f32;
    fn sound_effect_stop_rpm(&self) -> &f32;
    fn sound_effect_stop_rpm_mut(&mut self) -> &mut f32;
    fn alignment_settings(&self) -> &Option<LockedTypeObject /* AlignmentData */>;
    fn alignment_settings_mut(&mut self) -> &mut Option<LockedTypeObject /* AlignmentData */>;
    fn world_space_position_lock(&self) -> &bool;
    fn world_space_position_lock_mut(&mut self) -> &mut bool;
    fn enable_align_to_camera(&self) -> &bool;
    fn enable_align_to_camera_mut(&mut self) -> &mut bool;
    fn align_transform(&self) -> &super::core::LinearTransform;
    fn align_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl ChildComponentDataTrait for ChildComponentData {
    fn sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.sound_effect
    }
    fn sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.sound_effect
    }
    fn moving_body(&self) -> &Option<LockedTypeObject /* super::physics::MovingBodyData */> {
        &self.moving_body
    }
    fn moving_body_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::MovingBodyData */> {
        &mut self.moving_body
    }
    fn health_zone(&self) -> &VehicleHealthZoneData {
        &self.health_zone
    }
    fn health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.health_zone
    }
    fn sound_effect_start_rpm(&self) -> &f32 {
        &self.sound_effect_start_rpm
    }
    fn sound_effect_start_rpm_mut(&mut self) -> &mut f32 {
        &mut self.sound_effect_start_rpm
    }
    fn sound_effect_stop_rpm(&self) -> &f32 {
        &self.sound_effect_stop_rpm
    }
    fn sound_effect_stop_rpm_mut(&mut self) -> &mut f32 {
        &mut self.sound_effect_stop_rpm
    }
    fn alignment_settings(&self) -> &Option<LockedTypeObject /* AlignmentData */> {
        &self.alignment_settings
    }
    fn alignment_settings_mut(&mut self) -> &mut Option<LockedTypeObject /* AlignmentData */> {
        &mut self.alignment_settings
    }
    fn world_space_position_lock(&self) -> &bool {
        &self.world_space_position_lock
    }
    fn world_space_position_lock_mut(&mut self) -> &mut bool {
        &mut self.world_space_position_lock
    }
    fn enable_align_to_camera(&self) -> &bool {
        &self.enable_align_to_camera
    }
    fn enable_align_to_camera_mut(&mut self) -> &mut bool {
        &mut self.enable_align_to_camera
    }
    fn align_transform(&self) -> &super::core::LinearTransform {
        &self.align_transform
    }
    fn align_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.align_transform
    }
}

impl super::entity::BoneComponentDataTrait for ChildComponentData {
}

impl super::entity::GameComponentDataTrait for ChildComponentData {
}

impl super::entity::ComponentDataTrait for ChildComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ChildComponentData {
}

impl super::core::DataBusPeerTrait for ChildComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ChildComponentData {
}

impl super::core::DataContainerTrait for ChildComponentData {
}

pub static CHILDCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildComponentData",
    name_hash: 1955505936,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::BONECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(ChildComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildComponentData as Default>::default())),
            create_boxed: || Box::new(<ChildComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SoundEffect",
                name_hash: 3556609201,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(ChildComponentData, sound_effect),
            },
            FieldInfoData {
                name: "MovingBody",
                name_hash: 654150049,
                flags: MemberInfoFlags::new(0),
                field_type: "MovingBodyData",
                rust_offset: offset_of!(ChildComponentData, moving_body),
            },
            FieldInfoData {
                name: "HealthZone",
                name_hash: 3196619047,
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(ChildComponentData, health_zone),
            },
            FieldInfoData {
                name: "SoundEffectStartRpm",
                name_hash: 2939554110,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildComponentData, sound_effect_start_rpm),
            },
            FieldInfoData {
                name: "SoundEffectStopRpm",
                name_hash: 1267382822,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildComponentData, sound_effect_stop_rpm),
            },
            FieldInfoData {
                name: "AlignmentSettings",
                name_hash: 870827711,
                flags: MemberInfoFlags::new(0),
                field_type: "AlignmentData",
                rust_offset: offset_of!(ChildComponentData, alignment_settings),
            },
            FieldInfoData {
                name: "WorldSpacePositionLock",
                name_hash: 3785410993,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildComponentData, world_space_position_lock),
            },
            FieldInfoData {
                name: "EnableAlignToCamera",
                name_hash: 2538251595,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildComponentData, enable_align_to_camera),
            },
            FieldInfoData {
                name: "AlignTransform",
                name_hash: 4277081604,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ChildComponentData, align_transform),
            },
        ],
    }),
    array_type: Some(CHILDCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChildComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHILDCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildComponentData-Array",
    name_hash: 2564904228,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleEntryComponentData {
    pub _glacier_base: PlayerEntryComponentData,
    pub number_of_stances: i32,
    pub stances_enabled: bool,
    pub entry_component_sound: Option<LockedTypeObject /* EntryComponentSoundData */>,
    pub character_collision_offset: super::core::Vec3,
    pub character_collision_offset_realm: super::core::Realm,
}

pub trait VehicleEntryComponentDataTrait: PlayerEntryComponentDataTrait {
    fn number_of_stances(&self) -> &i32;
    fn number_of_stances_mut(&mut self) -> &mut i32;
    fn stances_enabled(&self) -> &bool;
    fn stances_enabled_mut(&mut self) -> &mut bool;
    fn entry_component_sound(&self) -> &Option<LockedTypeObject /* EntryComponentSoundData */>;
    fn entry_component_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* EntryComponentSoundData */>;
    fn character_collision_offset(&self) -> &super::core::Vec3;
    fn character_collision_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn character_collision_offset_realm(&self) -> &super::core::Realm;
    fn character_collision_offset_realm_mut(&mut self) -> &mut super::core::Realm;
}

impl VehicleEntryComponentDataTrait for VehicleEntryComponentData {
    fn number_of_stances(&self) -> &i32 {
        &self.number_of_stances
    }
    fn number_of_stances_mut(&mut self) -> &mut i32 {
        &mut self.number_of_stances
    }
    fn stances_enabled(&self) -> &bool {
        &self.stances_enabled
    }
    fn stances_enabled_mut(&mut self) -> &mut bool {
        &mut self.stances_enabled
    }
    fn entry_component_sound(&self) -> &Option<LockedTypeObject /* EntryComponentSoundData */> {
        &self.entry_component_sound
    }
    fn entry_component_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* EntryComponentSoundData */> {
        &mut self.entry_component_sound
    }
    fn character_collision_offset(&self) -> &super::core::Vec3 {
        &self.character_collision_offset
    }
    fn character_collision_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.character_collision_offset
    }
    fn character_collision_offset_realm(&self) -> &super::core::Realm {
        &self.character_collision_offset_realm
    }
    fn character_collision_offset_realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.character_collision_offset_realm
    }
}

impl PlayerEntryComponentDataTrait for VehicleEntryComponentData {
    fn ant_entry_i_d(&self) -> &String {
        self._glacier_base.ant_entry_i_d()
    }
    fn ant_entry_i_d_mut(&mut self) -> &mut String {
        self._glacier_base.ant_entry_i_d_mut()
    }
    fn ant_entry_id(&self) -> &AntEntryIdEnum {
        self._glacier_base.ant_entry_id()
    }
    fn ant_entry_id_mut(&mut self) -> &mut AntEntryIdEnum {
        self._glacier_base.ant_entry_id_mut()
    }
    fn ant_entry_enumeration(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */> {
        self._glacier_base.ant_entry_enumeration()
    }
    fn ant_entry_enumeration_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */> {
        self._glacier_base.ant_entry_enumeration_mut()
    }
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3 {
        self._glacier_base.animation_acceleration_multiplier()
    }
    fn animation_acceleration_multiplier_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.animation_acceleration_multiplier_mut()
    }
}

impl GameEntryComponentDataTrait for VehicleEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        self._glacier_base.lock_soldier_aiming_to_entry()
    }
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.lock_soldier_aiming_to_entry_mut()
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.soldier_offset()
    }
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.soldier_offset_mut()
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for VehicleEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn entry_class_mut(&mut self) -> &mut super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class_mut()
    }
    fn a_i_data(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::GameAIEntryData */> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::GameAIEntryData */> {
        self._glacier_base.a_i_data_mut()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn forbidden_for_human_mut(&mut self) -> &mut bool {
        self._glacier_base.forbidden_for_human_mut()
    }
    fn input_graph(&self) -> &Option<LockedTypeObject /* super::input_shared::InputGraph */> {
        self._glacier_base.input_graph()
    }
    fn input_graph_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputGraph */> {
        self._glacier_base.input_graph_mut()
    }
    fn input_concept_definition(&self) -> &Option<LockedTypeObject /* super::input_shared::InputActionMapsData */> {
        self._glacier_base.input_concept_definition()
    }
    fn input_concept_definition_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputActionMapsData */> {
        self._glacier_base.input_concept_definition_mut()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn action_map_settings_flip_y_scheme_override_mut(&mut self) -> &mut i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override_mut()
    }
    fn input_mapping(&self) -> &Option<LockedTypeObject /* super::input_shared::InputConceptToEntryInputActionMappings */> {
        self._glacier_base.input_mapping()
    }
    fn input_mapping_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputConceptToEntryInputActionMappings */> {
        self._glacier_base.input_mapping_mut()
    }
    fn input_curves(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::InputCurveData */>> {
        self._glacier_base.input_curves()
    }
    fn input_curves_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::InputCurveData */>> {
        self._glacier_base.input_curves_mut()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn hud_data_mut(&mut self) -> &mut super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data_mut()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn entry_order_number_mut(&mut self) -> &mut i32 {
        self._glacier_base.entry_order_number_mut()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn enter_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.enter_impulse_mut()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn entry_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.entry_radius_mut()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn is_allowed_to_exit_in_air_mut(&mut self) -> &mut bool {
        self._glacier_base.is_allowed_to_exit_in_air_mut()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn clear_path_to_exit_point_start_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset_mut()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn is_shielded_mut(&mut self) -> &mut bool {
        self._glacier_base.is_shielded_mut()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_in_entry_mut()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn show1p_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_mut()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn soldier_transition_invisble_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.soldier_transition_invisble_time_mut()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn entry_spotting_settings_mut(&mut self) -> &mut super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings_mut()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_weapon_in_entry_mut()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show1p_soldier_in_entry_for_player_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only_mut()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show3p_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show3p_soldier_weapon_in_entry_mut()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn show_soldier_gear_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_gear_in_entry_mut()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn pose_constraints_mut(&mut self) -> &mut super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints_mut()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn use_local_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_local_transform_mut()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn trigger_event_on_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.trigger_event_on_key_mut()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn allow_ragdoll_from_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_ragdoll_from_entry_mut()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
    fn camera_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.camera_index_mut()
    }
}

impl super::entity::GameComponentDataTrait for VehicleEntryComponentData {
}

impl super::entity::ComponentDataTrait for VehicleEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleEntryComponentData {
}

impl super::core::DataBusPeerTrait for VehicleEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleEntryComponentData {
}

impl super::core::DataContainerTrait for VehicleEntryComponentData {
}

pub static VEHICLEENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryComponentData",
    name_hash: 3900037622,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERENTRYCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleEntryComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntryComponentData as Default>::default())),
            create_boxed: || Box::new(<VehicleEntryComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "NumberOfStances",
                name_hash: 3289223154,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleEntryComponentData, number_of_stances),
            },
            FieldInfoData {
                name: "StancesEnabled",
                name_hash: 955154621,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntryComponentData, stances_enabled),
            },
            FieldInfoData {
                name: "EntryComponentSound",
                name_hash: 248283805,
                flags: MemberInfoFlags::new(0),
                field_type: "EntryComponentSoundData",
                rust_offset: offset_of!(VehicleEntryComponentData, entry_component_sound),
            },
            FieldInfoData {
                name: "CharacterCollisionOffset",
                name_hash: 2661285551,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntryComponentData, character_collision_offset),
            },
            FieldInfoData {
                name: "CharacterCollisionOffsetRealm",
                name_hash: 3050521080,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VehicleEntryComponentData, character_collision_offset_realm),
            },
        ],
    }),
    array_type: Some(VEHICLEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryComponentData-Array",
    name_hash: 2119884482,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntryComponentSoundData {
    pub _glacier_base: super::core::DataContainer,
    pub stance_sounds: Vec<BoxedTypeObject /* StanceSwitchSoundData */>,
    pub stance_switch_sound: Option<LockedTypeObject /* super::audio::SoundAsset */>,
}

pub trait EntryComponentSoundDataTrait: super::core::DataContainerTrait {
    fn stance_sounds(&self) -> &Vec<BoxedTypeObject /* StanceSwitchSoundData */>;
    fn stance_sounds_mut(&mut self) -> &mut Vec<BoxedTypeObject /* StanceSwitchSoundData */>;
    fn stance_switch_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn stance_switch_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
}

impl EntryComponentSoundDataTrait for EntryComponentSoundData {
    fn stance_sounds(&self) -> &Vec<BoxedTypeObject /* StanceSwitchSoundData */> {
        &self.stance_sounds
    }
    fn stance_sounds_mut(&mut self) -> &mut Vec<BoxedTypeObject /* StanceSwitchSoundData */> {
        &mut self.stance_sounds
    }
    fn stance_switch_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.stance_switch_sound
    }
    fn stance_switch_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.stance_switch_sound
    }
}

impl super::core::DataContainerTrait for EntryComponentSoundData {
}

pub static ENTRYCOMPONENTSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryComponentSoundData",
    name_hash: 3497588333,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(EntryComponentSoundData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntryComponentSoundData as Default>::default())),
            create_boxed: || Box::new(<EntryComponentSoundData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StanceSounds",
                name_hash: 3318640379,
                flags: MemberInfoFlags::new(144),
                field_type: "StanceSwitchSoundData-Array",
                rust_offset: offset_of!(EntryComponentSoundData, stance_sounds),
            },
            FieldInfoData {
                name: "StanceSwitchSound",
                name_hash: 865104730,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(EntryComponentSoundData, stance_switch_sound),
            },
        ],
    }),
    array_type: Some(ENTRYCOMPONENTSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntryComponentSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTRYCOMPONENTSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTRYCOMPONENTSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryComponentSoundData-Array",
    name_hash: 3096263513,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntryComponentSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StanceSwitchSoundData {
    pub stance_switch_sound: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub valid_stances: Vec<i32>,
}

pub trait StanceSwitchSoundDataTrait: TypeObject {
    fn stance_switch_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn stance_switch_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn valid_stances(&self) -> &Vec<i32>;
    fn valid_stances_mut(&mut self) -> &mut Vec<i32>;
}

impl StanceSwitchSoundDataTrait for StanceSwitchSoundData {
    fn stance_switch_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.stance_switch_sound
    }
    fn stance_switch_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.stance_switch_sound
    }
    fn valid_stances(&self) -> &Vec<i32> {
        &self.valid_stances
    }
    fn valid_stances_mut(&mut self) -> &mut Vec<i32> {
        &mut self.valid_stances
    }
}

pub static STANCESWITCHSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceSwitchSoundData",
    name_hash: 2736091242,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StanceSwitchSoundData as Default>::default())),
            create_boxed: || Box::new(<StanceSwitchSoundData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StanceSwitchSound",
                name_hash: 865104730,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(StanceSwitchSoundData, stance_switch_sound),
            },
            FieldInfoData {
                name: "ValidStances",
                name_hash: 4192498222,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StanceSwitchSoundData, valid_stances),
            },
        ],
    }),
    array_type: Some(STANCESWITCHSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StanceSwitchSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        STANCESWITCHSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STANCESWITCHSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceSwitchSoundData-Array",
    name_hash: 3802020702,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StanceSwitchSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraComponentSoundData {
    pub _glacier_base: super::core::DataContainer,
    pub switch_to_alternate_view_sound: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub switch_to_normal_view_sound: Option<LockedTypeObject /* super::audio::SoundAsset */>,
}

pub trait CameraComponentSoundDataTrait: super::core::DataContainerTrait {
    fn switch_to_alternate_view_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn switch_to_alternate_view_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn switch_to_normal_view_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn switch_to_normal_view_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
}

impl CameraComponentSoundDataTrait for CameraComponentSoundData {
    fn switch_to_alternate_view_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.switch_to_alternate_view_sound
    }
    fn switch_to_alternate_view_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.switch_to_alternate_view_sound
    }
    fn switch_to_normal_view_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.switch_to_normal_view_sound
    }
    fn switch_to_normal_view_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.switch_to_normal_view_sound
    }
}

impl super::core::DataContainerTrait for CameraComponentSoundData {
}

pub static CAMERACOMPONENTSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraComponentSoundData",
    name_hash: 897351392,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CameraComponentSoundData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraComponentSoundData as Default>::default())),
            create_boxed: || Box::new(<CameraComponentSoundData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "SwitchToAlternateViewSound",
                name_hash: 1181169106,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(CameraComponentSoundData, switch_to_alternate_view_sound),
            },
            FieldInfoData {
                name: "SwitchToNormalViewSound",
                name_hash: 3067038865,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(CameraComponentSoundData, switch_to_normal_view_sound),
            },
        ],
    }),
    array_type: Some(CAMERACOMPONENTSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraComponentSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACOMPONENTSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERACOMPONENTSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraComponentSoundData-Array",
    name_hash: 3062535380,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraComponentSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BasicUnlockInfo {
    pub unlock_guid: glacier_util::guid::Guid,
    pub identifier: u32,
    pub unlock_score: u32,
    pub licenses: Vec<String>,
    pub additional_licenses: Vec<String>,
    pub string_id: String,
}

pub trait BasicUnlockInfoTrait: TypeObject {
    fn unlock_guid(&self) -> &glacier_util::guid::Guid;
    fn unlock_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn identifier(&self) -> &u32;
    fn identifier_mut(&mut self) -> &mut u32;
    fn unlock_score(&self) -> &u32;
    fn unlock_score_mut(&mut self) -> &mut u32;
    fn licenses(&self) -> &Vec<String>;
    fn licenses_mut(&mut self) -> &mut Vec<String>;
    fn additional_licenses(&self) -> &Vec<String>;
    fn additional_licenses_mut(&mut self) -> &mut Vec<String>;
    fn string_id(&self) -> &String;
    fn string_id_mut(&mut self) -> &mut String;
}

impl BasicUnlockInfoTrait for BasicUnlockInfo {
    fn unlock_guid(&self) -> &glacier_util::guid::Guid {
        &self.unlock_guid
    }
    fn unlock_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.unlock_guid
    }
    fn identifier(&self) -> &u32 {
        &self.identifier
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        &mut self.identifier
    }
    fn unlock_score(&self) -> &u32 {
        &self.unlock_score
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        &mut self.unlock_score
    }
    fn licenses(&self) -> &Vec<String> {
        &self.licenses
    }
    fn licenses_mut(&mut self) -> &mut Vec<String> {
        &mut self.licenses
    }
    fn additional_licenses(&self) -> &Vec<String> {
        &self.additional_licenses
    }
    fn additional_licenses_mut(&mut self) -> &mut Vec<String> {
        &mut self.additional_licenses
    }
    fn string_id(&self) -> &String {
        &self.string_id
    }
    fn string_id_mut(&mut self) -> &mut String {
        &mut self.string_id
    }
}

pub static BASICUNLOCKINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicUnlockInfo",
    name_hash: 1191652097,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BasicUnlockInfo as Default>::default())),
            create_boxed: || Box::new(<BasicUnlockInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockGuid",
                name_hash: 1036441738,
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(BasicUnlockInfo, unlock_guid),
            },
            FieldInfoData {
                name: "Identifier",
                name_hash: 3512790342,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BasicUnlockInfo, identifier),
            },
            FieldInfoData {
                name: "UnlockScore",
                name_hash: 4124076605,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BasicUnlockInfo, unlock_score),
            },
            FieldInfoData {
                name: "Licenses",
                name_hash: 2259172461,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(BasicUnlockInfo, licenses),
            },
            FieldInfoData {
                name: "AdditionalLicenses",
                name_hash: 2557362420,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(BasicUnlockInfo, additional_licenses),
            },
            FieldInfoData {
                name: "StringId",
                name_hash: 3536090717,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BasicUnlockInfo, string_id),
            },
        ],
    }),
    array_type: Some(BASICUNLOCKINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicUnlockInfo {
    fn type_info(&self) -> &'static TypeInfo {
        BASICUNLOCKINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BASICUNLOCKINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicUnlockInfo-Array",
    name_hash: 1491395765,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BasicUnlockInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ValueUnlockAsset {
    pub _glacier_base: UnlockAssetBase,
    pub unlock_values: Vec<Option<LockedTypeObject /* UnlockValuePair */>>,
}

pub trait ValueUnlockAssetTrait: UnlockAssetBaseTrait {
    fn unlock_values(&self) -> &Vec<Option<LockedTypeObject /* UnlockValuePair */>>;
    fn unlock_values_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockValuePair */>>;
}

impl ValueUnlockAssetTrait for ValueUnlockAsset {
    fn unlock_values(&self) -> &Vec<Option<LockedTypeObject /* UnlockValuePair */>> {
        &self.unlock_values
    }
    fn unlock_values_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockValuePair */>> {
        &mut self.unlock_values
    }
}

impl UnlockAssetBaseTrait for ValueUnlockAsset {
    fn unlock_user_data(&self) -> &Option<LockedTypeObject /* UnlockUserDataBase */> {
        self._glacier_base.unlock_user_data()
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockUserDataBase */> {
        self._glacier_base.unlock_user_data_mut()
    }
    fn debug_unlock_id(&self) -> &String {
        self._glacier_base.debug_unlock_id()
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        self._glacier_base.debug_unlock_id_mut()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        self._glacier_base.identifier_mut()
    }
    fn unlock_score(&self) -> &u32 {
        self._glacier_base.unlock_score()
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        self._glacier_base.unlock_score_mut()
    }
    fn auto_available(&self) -> &bool {
        self._glacier_base.auto_available()
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_available_mut()
    }
    fn next_level_unlock_asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */> {
        self._glacier_base.next_level_unlock_asset()
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */> {
        self._glacier_base.next_level_unlock_asset_mut()
    }
    fn hidden_in_progression(&self) -> &bool {
        self._glacier_base.hidden_in_progression()
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        self._glacier_base.hidden_in_progression_mut()
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        self._glacier_base.available_for_player()
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        self._glacier_base.available_for_player_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for ValueUnlockAsset {
}

impl super::core::AssetTrait for ValueUnlockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ValueUnlockAsset {
}

pub static VALUEUNLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueUnlockAsset",
    name_hash: 3372834894,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKASSETBASE_TYPE_INFO),
        super_class_offset: offset_of!(ValueUnlockAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValueUnlockAsset as Default>::default())),
            create_boxed: || Box::new(<ValueUnlockAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockValues",
                name_hash: 2757489261,
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockValuePair-Array",
                rust_offset: offset_of!(ValueUnlockAsset, unlock_values),
            },
        ],
    }),
    array_type: Some(VALUEUNLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueUnlockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VALUEUNLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALUEUNLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueUnlockAsset-Array",
    name_hash: 746240506,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ValueUnlockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolUnlockValuePair {
    pub _glacier_base: UnlockValuePair,
    pub default_value: bool,
    pub unlocked_value: bool,
}

pub trait BoolUnlockValuePairTrait: UnlockValuePairTrait {
    fn default_value(&self) -> &bool;
    fn default_value_mut(&mut self) -> &mut bool;
    fn unlocked_value(&self) -> &bool;
    fn unlocked_value_mut(&mut self) -> &mut bool;
}

impl BoolUnlockValuePairTrait for BoolUnlockValuePair {
    fn default_value(&self) -> &bool {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut bool {
        &mut self.default_value
    }
    fn unlocked_value(&self) -> &bool {
        &self.unlocked_value
    }
    fn unlocked_value_mut(&mut self) -> &mut bool {
        &mut self.unlocked_value
    }
}

impl UnlockValuePairTrait for BoolUnlockValuePair {
    fn id(&self) -> &String {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut String {
        self._glacier_base.id_mut()
    }
}

impl super::core::DataContainerTrait for BoolUnlockValuePair {
}

pub static BOOLUNLOCKVALUEPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolUnlockValuePair",
    name_hash: 1527874714,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKVALUEPAIR_TYPE_INFO),
        super_class_offset: offset_of!(BoolUnlockValuePair, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolUnlockValuePair as Default>::default())),
            create_boxed: || Box::new(<BoolUnlockValuePair as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolUnlockValuePair, default_value),
            },
            FieldInfoData {
                name: "UnlockedValue",
                name_hash: 2493912799,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolUnlockValuePair, unlocked_value),
            },
        ],
    }),
    array_type: Some(BOOLUNLOCKVALUEPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolUnlockValuePair {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLUNLOCKVALUEPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLUNLOCKVALUEPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolUnlockValuePair-Array",
    name_hash: 950003630,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoolUnlockValuePair"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntUnlockValuePair {
    pub _glacier_base: UnlockValuePair,
    pub default_value: i32,
    pub unlocked_value: i32,
}

pub trait IntUnlockValuePairTrait: UnlockValuePairTrait {
    fn default_value(&self) -> &i32;
    fn default_value_mut(&mut self) -> &mut i32;
    fn unlocked_value(&self) -> &i32;
    fn unlocked_value_mut(&mut self) -> &mut i32;
}

impl IntUnlockValuePairTrait for IntUnlockValuePair {
    fn default_value(&self) -> &i32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut i32 {
        &mut self.default_value
    }
    fn unlocked_value(&self) -> &i32 {
        &self.unlocked_value
    }
    fn unlocked_value_mut(&mut self) -> &mut i32 {
        &mut self.unlocked_value
    }
}

impl UnlockValuePairTrait for IntUnlockValuePair {
    fn id(&self) -> &String {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut String {
        self._glacier_base.id_mut()
    }
}

impl super::core::DataContainerTrait for IntUnlockValuePair {
}

pub static INTUNLOCKVALUEPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntUnlockValuePair",
    name_hash: 474034631,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKVALUEPAIR_TYPE_INFO),
        super_class_offset: offset_of!(IntUnlockValuePair, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntUnlockValuePair as Default>::default())),
            create_boxed: || Box::new(<IntUnlockValuePair as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntUnlockValuePair, default_value),
            },
            FieldInfoData {
                name: "UnlockedValue",
                name_hash: 2493912799,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntUnlockValuePair, unlocked_value),
            },
        ],
    }),
    array_type: Some(INTUNLOCKVALUEPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntUnlockValuePair {
    fn type_info(&self) -> &'static TypeInfo {
        INTUNLOCKVALUEPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTUNLOCKVALUEPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntUnlockValuePair-Array",
    name_hash: 4242596595,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntUnlockValuePair"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatUnlockValuePair {
    pub _glacier_base: UnlockValuePair,
    pub default_value: f32,
    pub unlocked_value: f32,
}

pub trait FloatUnlockValuePairTrait: UnlockValuePairTrait {
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
    fn unlocked_value(&self) -> &f32;
    fn unlocked_value_mut(&mut self) -> &mut f32;
}

impl FloatUnlockValuePairTrait for FloatUnlockValuePair {
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
    fn unlocked_value(&self) -> &f32 {
        &self.unlocked_value
    }
    fn unlocked_value_mut(&mut self) -> &mut f32 {
        &mut self.unlocked_value
    }
}

impl UnlockValuePairTrait for FloatUnlockValuePair {
    fn id(&self) -> &String {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut String {
        self._glacier_base.id_mut()
    }
}

impl super::core::DataContainerTrait for FloatUnlockValuePair {
}

pub static FLOATUNLOCKVALUEPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatUnlockValuePair",
    name_hash: 3409649988,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKVALUEPAIR_TYPE_INFO),
        super_class_offset: offset_of!(FloatUnlockValuePair, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatUnlockValuePair as Default>::default())),
            create_boxed: || Box::new(<FloatUnlockValuePair as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                name_hash: 2066049125,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatUnlockValuePair, default_value),
            },
            FieldInfoData {
                name: "UnlockedValue",
                name_hash: 2493912799,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatUnlockValuePair, unlocked_value),
            },
        ],
    }),
    array_type: Some(FLOATUNLOCKVALUEPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatUnlockValuePair {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATUNLOCKVALUEPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATUNLOCKVALUEPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatUnlockValuePair-Array",
    name_hash: 444687856,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FloatUnlockValuePair"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockValuePair {
    pub _glacier_base: super::core::DataContainer,
    pub id: String,
}

pub trait UnlockValuePairTrait: super::core::DataContainerTrait {
    fn id(&self) -> &String;
    fn id_mut(&mut self) -> &mut String;
}

impl UnlockValuePairTrait for UnlockValuePair {
    fn id(&self) -> &String {
        &self.id
    }
    fn id_mut(&mut self) -> &mut String {
        &mut self.id
    }
}

impl super::core::DataContainerTrait for UnlockValuePair {
}

pub static UNLOCKVALUEPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockValuePair",
    name_hash: 2405109396,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(UnlockValuePair, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockValuePair as Default>::default())),
            create_boxed: || Box::new(<UnlockValuePair as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                name_hash: 5862152,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(UnlockValuePair, id),
            },
        ],
    }),
    array_type: Some(UNLOCKVALUEPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockValuePair {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKVALUEPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKVALUEPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockValuePair-Array",
    name_hash: 3917286048,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockValuePair"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockAssetPair {
    pub second: Option<LockedTypeObject /* UnlockAssetBase */>,
    pub result: Option<LockedTypeObject /* UnlockAssetBase */>,
}

pub trait UnlockAssetPairTrait: TypeObject {
    fn second(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */>;
    fn second_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */>;
    fn result(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */>;
    fn result_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */>;
}

impl UnlockAssetPairTrait for UnlockAssetPair {
    fn second(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */> {
        &self.second
    }
    fn second_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */> {
        &mut self.second
    }
    fn result(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */> {
        &self.result
    }
    fn result_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */> {
        &mut self.result
    }
}

pub static UNLOCKASSETPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAssetPair",
    name_hash: 601918607,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockAssetPair as Default>::default())),
            create_boxed: || Box::new(<UnlockAssetPair as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Second",
                name_hash: 3337441269,
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(UnlockAssetPair, second),
            },
            FieldInfoData {
                name: "Result",
                name_hash: 3293273164,
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(UnlockAssetPair, result),
            },
        ],
    }),
    array_type: Some(UNLOCKASSETPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockAssetPair {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKASSETPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UNLOCKASSETPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAssetPair-Array",
    name_hash: 10021179,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockAssetPair"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VisualUnlockAsset {
    pub _glacier_base: UnlockAsset,
    pub out_object_blueprint: Option<LockedTypeObject /* super::entity::ObjectBlueprint */>,
    pub third_person_bundles: Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */>,
    pub first_person_bundles: Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */>,
    pub render_in1p: bool,
    pub disable_render1p_in_foreground: bool,
    pub entry_index: i32,
    pub on_demand_loaded: bool,
    pub face_poser_library: super::ant::AntRef,
    pub morph_dof_set: super::ant::AntRef,
    pub morph_texture_blend_dof_set: super::ant::AntRef,
    pub visual_ant_game_states: Vec<Option<LockedTypeObject /* WriteAntGameStateData */>>,
    pub rig_scale: Option<LockedTypeObject /* WriteFloatGameState */>,
    pub visual_unlock_assets: Vec<Option<LockedTypeObject /* VisualUnlockAsset */>>,
}

pub trait VisualUnlockAssetTrait: UnlockAssetTrait {
    fn out_object_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn out_object_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn third_person_bundles(&self) -> &Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */>;
    fn third_person_bundles_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */>;
    fn first_person_bundles(&self) -> &Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */>;
    fn first_person_bundles_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */>;
    fn render_in1p(&self) -> &bool;
    fn render_in1p_mut(&mut self) -> &mut bool;
    fn disable_render1p_in_foreground(&self) -> &bool;
    fn disable_render1p_in_foreground_mut(&mut self) -> &mut bool;
    fn entry_index(&self) -> &i32;
    fn entry_index_mut(&mut self) -> &mut i32;
    fn on_demand_loaded(&self) -> &bool;
    fn on_demand_loaded_mut(&mut self) -> &mut bool;
    fn face_poser_library(&self) -> &super::ant::AntRef;
    fn face_poser_library_mut(&mut self) -> &mut super::ant::AntRef;
    fn morph_dof_set(&self) -> &super::ant::AntRef;
    fn morph_dof_set_mut(&mut self) -> &mut super::ant::AntRef;
    fn morph_texture_blend_dof_set(&self) -> &super::ant::AntRef;
    fn morph_texture_blend_dof_set_mut(&mut self) -> &mut super::ant::AntRef;
    fn visual_ant_game_states(&self) -> &Vec<Option<LockedTypeObject /* WriteAntGameStateData */>>;
    fn visual_ant_game_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* WriteAntGameStateData */>>;
    fn rig_scale(&self) -> &Option<LockedTypeObject /* WriteFloatGameState */>;
    fn rig_scale_mut(&mut self) -> &mut Option<LockedTypeObject /* WriteFloatGameState */>;
    fn visual_unlock_assets(&self) -> &Vec<Option<LockedTypeObject /* VisualUnlockAsset */>>;
    fn visual_unlock_assets_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VisualUnlockAsset */>>;
}

impl VisualUnlockAssetTrait for VisualUnlockAsset {
    fn out_object_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &self.out_object_blueprint
    }
    fn out_object_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &mut self.out_object_blueprint
    }
    fn third_person_bundles(&self) -> &Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */> {
        &self.third_person_bundles
    }
    fn third_person_bundles_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */> {
        &mut self.third_person_bundles
    }
    fn first_person_bundles(&self) -> &Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */> {
        &self.first_person_bundles
    }
    fn first_person_bundles_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::gameplay_sim::BlueprintBundleReference */> {
        &mut self.first_person_bundles
    }
    fn render_in1p(&self) -> &bool {
        &self.render_in1p
    }
    fn render_in1p_mut(&mut self) -> &mut bool {
        &mut self.render_in1p
    }
    fn disable_render1p_in_foreground(&self) -> &bool {
        &self.disable_render1p_in_foreground
    }
    fn disable_render1p_in_foreground_mut(&mut self) -> &mut bool {
        &mut self.disable_render1p_in_foreground
    }
    fn entry_index(&self) -> &i32 {
        &self.entry_index
    }
    fn entry_index_mut(&mut self) -> &mut i32 {
        &mut self.entry_index
    }
    fn on_demand_loaded(&self) -> &bool {
        &self.on_demand_loaded
    }
    fn on_demand_loaded_mut(&mut self) -> &mut bool {
        &mut self.on_demand_loaded
    }
    fn face_poser_library(&self) -> &super::ant::AntRef {
        &self.face_poser_library
    }
    fn face_poser_library_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.face_poser_library
    }
    fn morph_dof_set(&self) -> &super::ant::AntRef {
        &self.morph_dof_set
    }
    fn morph_dof_set_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.morph_dof_set
    }
    fn morph_texture_blend_dof_set(&self) -> &super::ant::AntRef {
        &self.morph_texture_blend_dof_set
    }
    fn morph_texture_blend_dof_set_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.morph_texture_blend_dof_set
    }
    fn visual_ant_game_states(&self) -> &Vec<Option<LockedTypeObject /* WriteAntGameStateData */>> {
        &self.visual_ant_game_states
    }
    fn visual_ant_game_states_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* WriteAntGameStateData */>> {
        &mut self.visual_ant_game_states
    }
    fn rig_scale(&self) -> &Option<LockedTypeObject /* WriteFloatGameState */> {
        &self.rig_scale
    }
    fn rig_scale_mut(&mut self) -> &mut Option<LockedTypeObject /* WriteFloatGameState */> {
        &mut self.rig_scale
    }
    fn visual_unlock_assets(&self) -> &Vec<Option<LockedTypeObject /* VisualUnlockAsset */>> {
        &self.visual_unlock_assets
    }
    fn visual_unlock_assets_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* VisualUnlockAsset */>> {
        &mut self.visual_unlock_assets
    }
}

impl UnlockAssetTrait for VisualUnlockAsset {
}

impl UnlockAssetBaseTrait for VisualUnlockAsset {
    fn unlock_user_data(&self) -> &Option<LockedTypeObject /* UnlockUserDataBase */> {
        self._glacier_base.unlock_user_data()
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockUserDataBase */> {
        self._glacier_base.unlock_user_data_mut()
    }
    fn debug_unlock_id(&self) -> &String {
        self._glacier_base.debug_unlock_id()
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        self._glacier_base.debug_unlock_id_mut()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        self._glacier_base.identifier_mut()
    }
    fn unlock_score(&self) -> &u32 {
        self._glacier_base.unlock_score()
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        self._glacier_base.unlock_score_mut()
    }
    fn auto_available(&self) -> &bool {
        self._glacier_base.auto_available()
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_available_mut()
    }
    fn next_level_unlock_asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */> {
        self._glacier_base.next_level_unlock_asset()
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */> {
        self._glacier_base.next_level_unlock_asset_mut()
    }
    fn hidden_in_progression(&self) -> &bool {
        self._glacier_base.hidden_in_progression()
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        self._glacier_base.hidden_in_progression_mut()
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        self._glacier_base.available_for_player()
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        self._glacier_base.available_for_player_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for VisualUnlockAsset {
}

impl super::core::AssetTrait for VisualUnlockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VisualUnlockAsset {
}

pub static VISUALUNLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockAsset",
    name_hash: 2948332081,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKASSET_TYPE_INFO),
        super_class_offset: offset_of!(VisualUnlockAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualUnlockAsset as Default>::default())),
            create_boxed: || Box::new(<VisualUnlockAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "OutObjectBlueprint",
                name_hash: 395392593,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(VisualUnlockAsset, out_object_blueprint),
            },
            FieldInfoData {
                name: "ThirdPersonBundles",
                name_hash: 717831444,
                flags: MemberInfoFlags::new(144),
                field_type: "BlueprintBundleReference-Array",
                rust_offset: offset_of!(VisualUnlockAsset, third_person_bundles),
            },
            FieldInfoData {
                name: "FirstPersonBundles",
                name_hash: 3441598189,
                flags: MemberInfoFlags::new(144),
                field_type: "BlueprintBundleReference-Array",
                rust_offset: offset_of!(VisualUnlockAsset, first_person_bundles),
            },
            FieldInfoData {
                name: "RenderIn1p",
                name_hash: 604201065,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisualUnlockAsset, render_in1p),
            },
            FieldInfoData {
                name: "DisableRender1pInForeground",
                name_hash: 505064870,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisualUnlockAsset, disable_render1p_in_foreground),
            },
            FieldInfoData {
                name: "EntryIndex",
                name_hash: 294360175,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VisualUnlockAsset, entry_index),
            },
            FieldInfoData {
                name: "OnDemandLoaded",
                name_hash: 3494845092,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisualUnlockAsset, on_demand_loaded),
            },
            FieldInfoData {
                name: "FacePoserLibrary",
                name_hash: 2878950592,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VisualUnlockAsset, face_poser_library),
            },
            FieldInfoData {
                name: "MorphDofSet",
                name_hash: 3682490018,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VisualUnlockAsset, morph_dof_set),
            },
            FieldInfoData {
                name: "MorphTextureBlendDofSet",
                name_hash: 3543169084,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VisualUnlockAsset, morph_texture_blend_dof_set),
            },
            FieldInfoData {
                name: "VisualAntGameStates",
                name_hash: 1577620832,
                flags: MemberInfoFlags::new(144),
                field_type: "WriteAntGameStateData-Array",
                rust_offset: offset_of!(VisualUnlockAsset, visual_ant_game_states),
            },
            FieldInfoData {
                name: "RigScale",
                name_hash: 3158745857,
                flags: MemberInfoFlags::new(0),
                field_type: "WriteFloatGameState",
                rust_offset: offset_of!(VisualUnlockAsset, rig_scale),
            },
            FieldInfoData {
                name: "VisualUnlockAssets",
                name_hash: 2805678114,
                flags: MemberInfoFlags::new(144),
                field_type: "VisualUnlockAsset-Array",
                rust_offset: offset_of!(VisualUnlockAsset, visual_unlock_assets),
            },
        ],
    }),
    array_type: Some(VISUALUNLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VisualUnlockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALUNLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALUNLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockAsset-Array",
    name_hash: 3405220997,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VisualUnlockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VisualUnlockBlueprintBundle {
    pub _glacier_base: super::gameplay_sim::BlueprintBundle,
}

pub trait VisualUnlockBlueprintBundleTrait: super::gameplay_sim::BlueprintBundleTrait {
}

impl VisualUnlockBlueprintBundleTrait for VisualUnlockBlueprintBundle {
}

impl super::gameplay_sim::BlueprintBundleTrait for VisualUnlockBlueprintBundle {
    fn blueprint(&self) -> &Option<LockedTypeObject /* super::entity::Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
}

impl super::entity::SharedBundleBaseAssetTrait for VisualUnlockBlueprintBundle {
}

impl super::core::AssetTrait for VisualUnlockBlueprintBundle {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VisualUnlockBlueprintBundle {
}

pub static VISUALUNLOCKBLUEPRINTBUNDLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBlueprintBundle",
    name_hash: 1830021818,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::BLUEPRINTBUNDLE_TYPE_INFO),
        super_class_offset: offset_of!(VisualUnlockBlueprintBundle, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualUnlockBlueprintBundle as Default>::default())),
            create_boxed: || Box::new(<VisualUnlockBlueprintBundle as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VISUALUNLOCKBLUEPRINTBUNDLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VisualUnlockBlueprintBundle {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALUNLOCKBLUEPRINTBUNDLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALUNLOCKBLUEPRINTBUNDLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBlueprintBundle-Array",
    name_hash: 193096974,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VisualUnlockBlueprintBundle"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VisualUnlockBundleAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub bundle_mode: VisualUnlockBundleMode,
}

pub trait VisualUnlockBundleAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn bundle_mode(&self) -> &VisualUnlockBundleMode;
    fn bundle_mode_mut(&mut self) -> &mut VisualUnlockBundleMode;
}

impl VisualUnlockBundleAssetTrait for VisualUnlockBundleAsset {
    fn bundle_mode(&self) -> &VisualUnlockBundleMode {
        &self.bundle_mode
    }
    fn bundle_mode_mut(&mut self) -> &mut VisualUnlockBundleMode {
        &mut self.bundle_mode
    }
}

impl super::core::DataContainerPolicyAssetTrait for VisualUnlockBundleAsset {
}

impl super::core::AssetTrait for VisualUnlockBundleAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VisualUnlockBundleAsset {
}

pub static VISUALUNLOCKBUNDLEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBundleAsset",
    name_hash: 1670784389,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        super_class_offset: offset_of!(VisualUnlockBundleAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualUnlockBundleAsset as Default>::default())),
            create_boxed: || Box::new(<VisualUnlockBundleAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BundleMode",
                name_hash: 460971314,
                flags: MemberInfoFlags::new(0),
                field_type: "VisualUnlockBundleMode",
                rust_offset: offset_of!(VisualUnlockBundleAsset, bundle_mode),
            },
        ],
    }),
    array_type: Some(VISUALUNLOCKBUNDLEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VisualUnlockBundleAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALUNLOCKBUNDLEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALUNLOCKBUNDLEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBundleAsset-Array",
    name_hash: 631598385,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VisualUnlockBundleAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VisualUnlockBundleMode {
    #[default]
    BundleMode_Both1pAnd3p = 0,
    BundleMode_Only1p = 1,
}

pub static VISUALUNLOCKBUNDLEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBundleMode",
    name_hash: 4085452406,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(VISUALUNLOCKBUNDLEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VisualUnlockBundleMode {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALUNLOCKBUNDLEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VISUALUNLOCKBUNDLEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBundleMode-Array",
    name_hash: 815625026,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VisualUnlockBundleMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MultiUnlockAsset {
    pub _glacier_base: UnlockAssetBase,
    pub unlocks: Vec<Option<LockedTypeObject /* UnlockAssetBase */>>,
}

pub trait MultiUnlockAssetTrait: UnlockAssetBaseTrait {
    fn unlocks(&self) -> &Vec<Option<LockedTypeObject /* UnlockAssetBase */>>;
    fn unlocks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockAssetBase */>>;
}

impl MultiUnlockAssetTrait for MultiUnlockAsset {
    fn unlocks(&self) -> &Vec<Option<LockedTypeObject /* UnlockAssetBase */>> {
        &self.unlocks
    }
    fn unlocks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* UnlockAssetBase */>> {
        &mut self.unlocks
    }
}

impl UnlockAssetBaseTrait for MultiUnlockAsset {
    fn unlock_user_data(&self) -> &Option<LockedTypeObject /* UnlockUserDataBase */> {
        self._glacier_base.unlock_user_data()
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockUserDataBase */> {
        self._glacier_base.unlock_user_data_mut()
    }
    fn debug_unlock_id(&self) -> &String {
        self._glacier_base.debug_unlock_id()
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        self._glacier_base.debug_unlock_id_mut()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        self._glacier_base.identifier_mut()
    }
    fn unlock_score(&self) -> &u32 {
        self._glacier_base.unlock_score()
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        self._glacier_base.unlock_score_mut()
    }
    fn auto_available(&self) -> &bool {
        self._glacier_base.auto_available()
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_available_mut()
    }
    fn next_level_unlock_asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */> {
        self._glacier_base.next_level_unlock_asset()
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */> {
        self._glacier_base.next_level_unlock_asset_mut()
    }
    fn hidden_in_progression(&self) -> &bool {
        self._glacier_base.hidden_in_progression()
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        self._glacier_base.hidden_in_progression_mut()
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        self._glacier_base.available_for_player()
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        self._glacier_base.available_for_player_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for MultiUnlockAsset {
}

impl super::core::AssetTrait for MultiUnlockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MultiUnlockAsset {
}

pub static MULTIUNLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiUnlockAsset",
    name_hash: 1042976812,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKASSETBASE_TYPE_INFO),
        super_class_offset: offset_of!(MultiUnlockAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultiUnlockAsset as Default>::default())),
            create_boxed: || Box::new(<MultiUnlockAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Unlocks",
                name_hash: 3464375270,
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(MultiUnlockAsset, unlocks),
            },
        ],
    }),
    array_type: Some(MULTIUNLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultiUnlockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MULTIUNLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTIUNLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiUnlockAsset-Array",
    name_hash: 1389600664,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MultiUnlockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockAsset {
    pub _glacier_base: UnlockAssetBase,
}

pub trait UnlockAssetTrait: UnlockAssetBaseTrait {
}

impl UnlockAssetTrait for UnlockAsset {
}

impl UnlockAssetBaseTrait for UnlockAsset {
    fn unlock_user_data(&self) -> &Option<LockedTypeObject /* UnlockUserDataBase */> {
        self._glacier_base.unlock_user_data()
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockUserDataBase */> {
        self._glacier_base.unlock_user_data_mut()
    }
    fn debug_unlock_id(&self) -> &String {
        self._glacier_base.debug_unlock_id()
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        self._glacier_base.debug_unlock_id_mut()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        self._glacier_base.identifier_mut()
    }
    fn unlock_score(&self) -> &u32 {
        self._glacier_base.unlock_score()
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        self._glacier_base.unlock_score_mut()
    }
    fn auto_available(&self) -> &bool {
        self._glacier_base.auto_available()
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_available_mut()
    }
    fn next_level_unlock_asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */> {
        self._glacier_base.next_level_unlock_asset()
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */> {
        self._glacier_base.next_level_unlock_asset_mut()
    }
    fn hidden_in_progression(&self) -> &bool {
        self._glacier_base.hidden_in_progression()
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        self._glacier_base.hidden_in_progression_mut()
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        self._glacier_base.available_for_player()
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        self._glacier_base.available_for_player_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for UnlockAsset {
}

impl super::core::AssetTrait for UnlockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UnlockAsset {
}

pub static UNLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAsset",
    name_hash: 4135652293,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKASSETBASE_TYPE_INFO),
        super_class_offset: offset_of!(UnlockAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockAsset as Default>::default())),
            create_boxed: || Box::new(<UnlockAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(UNLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAsset-Array",
    name_hash: 3362784241,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MeshAndVariationPair {
    pub _glacier_base: super::entity::ObjectBlueprint,
    pub mesh_asset: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub variation: Option<LockedTypeObject /* super::entity::ObjectVariation */>,
}

pub trait MeshAndVariationPairTrait: super::entity::ObjectBlueprintTrait {
    fn mesh_asset(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn variation(&self) -> &Option<LockedTypeObject /* super::entity::ObjectVariation */>;
    fn variation_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectVariation */>;
}

impl MeshAndVariationPairTrait for MeshAndVariationPair {
    fn mesh_asset(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh_asset
    }
    fn mesh_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh_asset
    }
    fn variation(&self) -> &Option<LockedTypeObject /* super::entity::ObjectVariation */> {
        &self.variation
    }
    fn variation_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectVariation */> {
        &mut self.variation
    }
}

impl super::entity::ObjectBlueprintTrait for MeshAndVariationPair {
    fn object(&self) -> &Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for MeshAndVariationPair {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for MeshAndVariationPair {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for MeshAndVariationPair {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for MeshAndVariationPair {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MeshAndVariationPair {
}

pub static MESHANDVARIATIONPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshAndVariationPair",
    name_hash: 1028455270,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(MeshAndVariationPair, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshAndVariationPair as Default>::default())),
            create_boxed: || Box::new(<MeshAndVariationPair as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MeshAsset",
                name_hash: 15738982,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(MeshAndVariationPair, mesh_asset),
            },
            FieldInfoData {
                name: "Variation",
                name_hash: 2945980116,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectVariation",
                rust_offset: offset_of!(MeshAndVariationPair, variation),
            },
        ],
    }),
    array_type: Some(MESHANDVARIATIONPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeshAndVariationPair {
    fn type_info(&self) -> &'static TypeInfo {
        MESHANDVARIATIONPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHANDVARIATIONPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshAndVariationPair-Array",
    name_hash: 3352451154,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshAndVariationPair"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockAssetBase {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub unlock_user_data: Option<LockedTypeObject /* UnlockUserDataBase */>,
    pub debug_unlock_id: String,
    pub identifier: u32,
    pub unlock_score: u32,
    pub auto_available: bool,
    pub next_level_unlock_asset: Option<LockedTypeObject /* UnlockAssetBase */>,
    pub hidden_in_progression: bool,
    pub available_for_player: UnlockAvailability,
}

pub trait UnlockAssetBaseTrait: super::core::DataContainerPolicyAssetTrait {
    fn unlock_user_data(&self) -> &Option<LockedTypeObject /* UnlockUserDataBase */>;
    fn unlock_user_data_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockUserDataBase */>;
    fn debug_unlock_id(&self) -> &String;
    fn debug_unlock_id_mut(&mut self) -> &mut String;
    fn identifier(&self) -> &u32;
    fn identifier_mut(&mut self) -> &mut u32;
    fn unlock_score(&self) -> &u32;
    fn unlock_score_mut(&mut self) -> &mut u32;
    fn auto_available(&self) -> &bool;
    fn auto_available_mut(&mut self) -> &mut bool;
    fn next_level_unlock_asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */>;
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */>;
    fn hidden_in_progression(&self) -> &bool;
    fn hidden_in_progression_mut(&mut self) -> &mut bool;
    fn available_for_player(&self) -> &UnlockAvailability;
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability;
}

impl UnlockAssetBaseTrait for UnlockAssetBase {
    fn unlock_user_data(&self) -> &Option<LockedTypeObject /* UnlockUserDataBase */> {
        &self.unlock_user_data
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockUserDataBase */> {
        &mut self.unlock_user_data
    }
    fn debug_unlock_id(&self) -> &String {
        &self.debug_unlock_id
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        &mut self.debug_unlock_id
    }
    fn identifier(&self) -> &u32 {
        &self.identifier
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        &mut self.identifier
    }
    fn unlock_score(&self) -> &u32 {
        &self.unlock_score
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        &mut self.unlock_score
    }
    fn auto_available(&self) -> &bool {
        &self.auto_available
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        &mut self.auto_available
    }
    fn next_level_unlock_asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */> {
        &self.next_level_unlock_asset
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */> {
        &mut self.next_level_unlock_asset
    }
    fn hidden_in_progression(&self) -> &bool {
        &self.hidden_in_progression
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        &mut self.hidden_in_progression
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        &self.available_for_player
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        &mut self.available_for_player
    }
}

impl super::core::DataContainerPolicyAssetTrait for UnlockAssetBase {
}

impl super::core::AssetTrait for UnlockAssetBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UnlockAssetBase {
}

pub static UNLOCKASSETBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAssetBase",
    name_hash: 601555088,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        super_class_offset: offset_of!(UnlockAssetBase, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockAssetBase as Default>::default())),
            create_boxed: || Box::new(<UnlockAssetBase as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockUserData",
                name_hash: 334679412,
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockUserDataBase",
                rust_offset: offset_of!(UnlockAssetBase, unlock_user_data),
            },
            FieldInfoData {
                name: "DebugUnlockId",
                name_hash: 2468774985,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(UnlockAssetBase, debug_unlock_id),
            },
            FieldInfoData {
                name: "Identifier",
                name_hash: 3512790342,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UnlockAssetBase, identifier),
            },
            FieldInfoData {
                name: "UnlockScore",
                name_hash: 4124076605,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UnlockAssetBase, unlock_score),
            },
            FieldInfoData {
                name: "AutoAvailable",
                name_hash: 1619872979,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockAssetBase, auto_available),
            },
            FieldInfoData {
                name: "NextLevelUnlockAsset",
                name_hash: 3071818964,
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(UnlockAssetBase, next_level_unlock_asset),
            },
            FieldInfoData {
                name: "HiddenInProgression",
                name_hash: 1800564573,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockAssetBase, hidden_in_progression),
            },
            FieldInfoData {
                name: "AvailableForPlayer",
                name_hash: 3398545844,
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAvailability",
                rust_offset: offset_of!(UnlockAssetBase, available_for_player),
            },
        ],
    }),
    array_type: Some(UNLOCKASSETBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockAssetBase {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKASSETBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKASSETBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAssetBase-Array",
    name_hash: 225103524,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockAssetBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UnlockAvailability {
    #[default]
    UnlockAvailability_All = 0,
    UnlockAvailability_HumanPlayerOnly = 1,
    UnlockAvailability_AIOnly = 2,
}

pub static UNLOCKAVAILABILITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAvailability",
    name_hash: 3063827140,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UNLOCKAVAILABILITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UnlockAvailability {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKAVAILABILITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UNLOCKAVAILABILITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAvailability-Array",
    name_hash: 1425911664,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockAvailability"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockUserDataBase {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
}

pub trait UnlockUserDataBaseTrait: super::core::DataContainerPolicyAssetTrait {
}

impl UnlockUserDataBaseTrait for UnlockUserDataBase {
}

impl super::core::DataContainerPolicyAssetTrait for UnlockUserDataBase {
}

impl super::core::AssetTrait for UnlockUserDataBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UnlockUserDataBase {
}

pub static UNLOCKUSERDATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockUserDataBase",
    name_hash: 1117832545,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        super_class_offset: offset_of!(UnlockUserDataBase, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockUserDataBase as Default>::default())),
            create_boxed: || Box::new(<UnlockUserDataBase as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(UNLOCKUSERDATABASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockUserDataBase {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKUSERDATABASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKUSERDATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockUserDataBase-Array",
    name_hash: 3746906197,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockUserDataBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnlockComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub unlock_asset: Option<LockedTypeObject /* UnlockAssetBase */>,
    pub unlock_asset_guid: glacier_util::guid::Guid,
    pub unlock_identifier: u32,
    pub invert_unlock_test: bool,
    pub unlockable_from_all_entries: bool,
    pub evaluate_once: bool,
    pub unlock_on_spawn: UnlockSpawnType,
    pub deactivate_check_on_entering_entry: bool,
}

pub trait UnlockComponentDataTrait: super::entity::GameComponentDataTrait {
    fn unlock_asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */>;
    fn unlock_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */>;
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid;
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn unlock_identifier(&self) -> &u32;
    fn unlock_identifier_mut(&mut self) -> &mut u32;
    fn invert_unlock_test(&self) -> &bool;
    fn invert_unlock_test_mut(&mut self) -> &mut bool;
    fn unlockable_from_all_entries(&self) -> &bool;
    fn unlockable_from_all_entries_mut(&mut self) -> &mut bool;
    fn evaluate_once(&self) -> &bool;
    fn evaluate_once_mut(&mut self) -> &mut bool;
    fn unlock_on_spawn(&self) -> &UnlockSpawnType;
    fn unlock_on_spawn_mut(&mut self) -> &mut UnlockSpawnType;
    fn deactivate_check_on_entering_entry(&self) -> &bool;
    fn deactivate_check_on_entering_entry_mut(&mut self) -> &mut bool;
}

impl UnlockComponentDataTrait for UnlockComponentData {
    fn unlock_asset(&self) -> &Option<LockedTypeObject /* UnlockAssetBase */> {
        &self.unlock_asset
    }
    fn unlock_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* UnlockAssetBase */> {
        &mut self.unlock_asset
    }
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid {
        &self.unlock_asset_guid
    }
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.unlock_asset_guid
    }
    fn unlock_identifier(&self) -> &u32 {
        &self.unlock_identifier
    }
    fn unlock_identifier_mut(&mut self) -> &mut u32 {
        &mut self.unlock_identifier
    }
    fn invert_unlock_test(&self) -> &bool {
        &self.invert_unlock_test
    }
    fn invert_unlock_test_mut(&mut self) -> &mut bool {
        &mut self.invert_unlock_test
    }
    fn unlockable_from_all_entries(&self) -> &bool {
        &self.unlockable_from_all_entries
    }
    fn unlockable_from_all_entries_mut(&mut self) -> &mut bool {
        &mut self.unlockable_from_all_entries
    }
    fn evaluate_once(&self) -> &bool {
        &self.evaluate_once
    }
    fn evaluate_once_mut(&mut self) -> &mut bool {
        &mut self.evaluate_once
    }
    fn unlock_on_spawn(&self) -> &UnlockSpawnType {
        &self.unlock_on_spawn
    }
    fn unlock_on_spawn_mut(&mut self) -> &mut UnlockSpawnType {
        &mut self.unlock_on_spawn
    }
    fn deactivate_check_on_entering_entry(&self) -> &bool {
        &self.deactivate_check_on_entering_entry
    }
    fn deactivate_check_on_entering_entry_mut(&mut self) -> &mut bool {
        &mut self.deactivate_check_on_entering_entry
    }
}

impl super::entity::GameComponentDataTrait for UnlockComponentData {
}

impl super::entity::ComponentDataTrait for UnlockComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for UnlockComponentData {
}

impl super::core::DataBusPeerTrait for UnlockComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for UnlockComponentData {
}

impl super::core::DataContainerTrait for UnlockComponentData {
}

pub static UNLOCKCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockComponentData",
    name_hash: 2083600970,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(UnlockComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockComponentData as Default>::default())),
            create_boxed: || Box::new(<UnlockComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockAsset",
                name_hash: 4135652293,
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(UnlockComponentData, unlock_asset),
            },
            FieldInfoData {
                name: "UnlockAssetGuid",
                name_hash: 601185850,
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(UnlockComponentData, unlock_asset_guid),
            },
            FieldInfoData {
                name: "UnlockIdentifier",
                name_hash: 500030326,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UnlockComponentData, unlock_identifier),
            },
            FieldInfoData {
                name: "InvertUnlockTest",
                name_hash: 1973219505,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockComponentData, invert_unlock_test),
            },
            FieldInfoData {
                name: "UnlockableFromAllEntries",
                name_hash: 2298992538,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockComponentData, unlockable_from_all_entries),
            },
            FieldInfoData {
                name: "EvaluateOnce",
                name_hash: 874828217,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockComponentData, evaluate_once),
            },
            FieldInfoData {
                name: "UnlockOnSpawn",
                name_hash: 2533744719,
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockSpawnType",
                rust_offset: offset_of!(UnlockComponentData, unlock_on_spawn),
            },
            FieldInfoData {
                name: "DeactivateCheckOnEnteringEntry",
                name_hash: 866525958,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockComponentData, deactivate_check_on_entering_entry),
            },
        ],
    }),
    array_type: Some(UNLOCKCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for UnlockComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockComponentData-Array",
    name_hash: 1465804286,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UnlockSpawnType {
    #[default]
    SpawnLock_Ignore = 0,
    SpawnLock_Locked = 1,
    SpawnLock_Unlocked = 2,
}

pub static UNLOCKSPAWNTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockSpawnType",
    name_hash: 3361846550,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UNLOCKSPAWNTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UnlockSpawnType {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKSPAWNTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UNLOCKSPAWNTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockSpawnType-Array",
    name_hash: 2838678050,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockSpawnType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UIMessageType {
    #[default]
    UIMessageType_Text = 0,
    UIMessageType_EnemyTank = 1,
    UIMessageType_EnemyCar = 2,
    UIMessageType_EnemyBoat = 3,
    UIMessageType_EnemyHelicopter = 4,
    UIMessageType_EnemyInfantry = 5,
    UIMessageType_EnemyActivity = 6,
    UIMessageType_EnemyC4 = 7,
    UIMessageType_EnemyATMine = 8,
    UIMessageType_ChatGo = 9,
    UIMessageType_ChatFollowMe = 10,
    UIMessageType_ChatNeedBackup = 11,
    UIMessageType_ChatNeedPickup = 12,
    UIMessageType_ChatNeedAmmo = 13,
    UIMessageType_ChatNeedMedic = 14,
    UIMessageType_ChatYes = 15,
    UIMessageType_ChatNo = 16,
    UIMessageType_ChatThanks = 17,
    UIMessageType_ChatSorry = 18,
    UIMessageType_ChatNeedRepair = 19,
    UIMessageType_ChatGetIn = 20,
    UIMessageType_ChatGetOut = 21,
    UIMessageType_ChatDropMeOff = 22,
    UIMessageType_OrderDefendBase = 23,
    UIMessageType_OrderAttackBase = 24,
    UIMessageType_OrderMoveToPos = 25,
    UIMessageType_JoinedSquad = 26,
    UIMessageType_LeftSquad = 27,
    UIMessageType_RequestSquad = 28,
    UIMessageType_InviteSquad = 29,
    UIMessageType_KickSquad = 30,
    UIMessageType_LeaderPromoted = 31,
    UIMessageType_Connected = 32,
    UIMessageType_Disconnected = 33,
    UIMessageType_Killed = 34,
    UIMessageType_Died = 35,
}

pub static UIMESSAGETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIMessageType",
    name_hash: 2911085194,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UIMESSAGETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UIMessageType {
    fn type_info(&self) -> &'static TypeInfo {
        UIMESSAGETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UIMESSAGETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIMessageType-Array",
    name_hash: 2619194814,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIMessageType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LightDimmerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub distance_to_fade: f32,
    pub distance_to_cull: f32,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait LightDimmerEntityDataTrait: super::entity::EntityDataTrait {
    fn distance_to_fade(&self) -> &f32;
    fn distance_to_fade_mut(&mut self) -> &mut f32;
    fn distance_to_cull(&self) -> &f32;
    fn distance_to_cull_mut(&mut self) -> &mut f32;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl LightDimmerEntityDataTrait for LightDimmerEntityData {
    fn distance_to_fade(&self) -> &f32 {
        &self.distance_to_fade
    }
    fn distance_to_fade_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_fade
    }
    fn distance_to_cull(&self) -> &f32 {
        &self.distance_to_cull
    }
    fn distance_to_cull_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_cull
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for LightDimmerEntityData {
}

impl super::entity::GameObjectDataTrait for LightDimmerEntityData {
}

impl super::core::DataBusPeerTrait for LightDimmerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LightDimmerEntityData {
}

impl super::core::DataContainerTrait for LightDimmerEntityData {
}

pub static LIGHTDIMMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightDimmerEntityData",
    name_hash: 3562510026,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LightDimmerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LightDimmerEntityData as Default>::default())),
            create_boxed: || Box::new(<LightDimmerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DistanceToFade",
                name_hash: 4164205659,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LightDimmerEntityData, distance_to_fade),
            },
            FieldInfoData {
                name: "DistanceToCull",
                name_hash: 4164359147,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LightDimmerEntityData, distance_to_cull),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LightDimmerEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(LIGHTDIMMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LightDimmerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LIGHTDIMMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LIGHTDIMMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightDimmerEntityData-Array",
    name_hash: 519578238,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LightDimmerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct KinectServiceData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait KinectServiceDataTrait: super::entity::EntityDataTrait {
}

impl KinectServiceDataTrait for KinectServiceData {
}

impl super::entity::EntityDataTrait for KinectServiceData {
}

impl super::entity::GameObjectDataTrait for KinectServiceData {
}

impl super::core::DataBusPeerTrait for KinectServiceData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for KinectServiceData {
}

impl super::core::DataContainerTrait for KinectServiceData {
}

pub static KINECTSERVICEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KinectServiceData",
    name_hash: 3392975030,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(KinectServiceData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<KinectServiceData as Default>::default())),
            create_boxed: || Box::new(<KinectServiceData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(KINECTSERVICEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for KinectServiceData {
    fn type_info(&self) -> &'static TypeInfo {
        KINECTSERVICEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static KINECTSERVICEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KinectServiceData-Array",
    name_hash: 275252482,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("KinectServiceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UIWorldIconBehavior {
    pub _glacier_base: super::core::Asset,
}

pub trait UIWorldIconBehaviorTrait: super::core::AssetTrait {
}

impl UIWorldIconBehaviorTrait for UIWorldIconBehavior {
}

impl super::core::AssetTrait for UIWorldIconBehavior {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UIWorldIconBehavior {
}

pub static UIWORLDICONBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIWorldIconBehavior",
    name_hash: 504421724,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(UIWorldIconBehavior, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIWorldIconBehavior as Default>::default())),
            create_boxed: || Box::new(<UIWorldIconBehavior as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(UIWORLDICONBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UIWorldIconBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        UIWORLDICONBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UIWORLDICONBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIWorldIconBehavior-Array",
    name_hash: 1338394088,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIWorldIconBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UICombatAreaAsset {
    pub _glacier_base: super::core::Asset,
    pub prefix: String,
}

pub trait UICombatAreaAssetTrait: super::core::AssetTrait {
    fn prefix(&self) -> &String;
    fn prefix_mut(&mut self) -> &mut String;
}

impl UICombatAreaAssetTrait for UICombatAreaAsset {
    fn prefix(&self) -> &String {
        &self.prefix
    }
    fn prefix_mut(&mut self) -> &mut String {
        &mut self.prefix
    }
}

impl super::core::AssetTrait for UICombatAreaAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UICombatAreaAsset {
}

pub static UICOMBATAREAASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UICombatAreaAsset",
    name_hash: 632426248,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(UICombatAreaAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UICombatAreaAsset as Default>::default())),
            create_boxed: || Box::new(<UICombatAreaAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Prefix",
                name_hash: 3358704757,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(UICombatAreaAsset, prefix),
            },
        ],
    }),
    array_type: Some(UICOMBATAREAASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UICombatAreaAsset {
    fn type_info(&self) -> &'static TypeInfo {
        UICOMBATAREAASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UICOMBATAREAASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UICombatAreaAsset-Array",
    name_hash: 1944015164,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UICombatAreaAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SpottingType {
    #[default]
    STGunner = 0,
    STSquadLeader = 1,
    STDefault = 2,
    STPersonal = 3,
    STSnapshot = 4,
    STSquadUav = 5,
    STTypesCount = 6,
}

pub static SPOTTINGTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpottingType",
    name_hash: 243350993,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(SPOTTINGTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SpottingType {
    fn type_info(&self) -> &'static TypeInfo {
        SPOTTINGTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SPOTTINGTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpottingType-Array",
    name_hash: 1856032741,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SpottingType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UIPartData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait UIPartDataTrait: super::core::DataContainerTrait {
}

impl UIPartDataTrait for UIPartData {
}

impl super::core::DataContainerTrait for UIPartData {
}

pub static UIPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartData",
    name_hash: 3008668606,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(UIPartData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIPartData as Default>::default())),
            create_boxed: || Box::new(<UIPartData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(UIPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UIPartData {
    fn type_info(&self) -> &'static TypeInfo {
        UIPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UIPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartData-Array",
    name_hash: 4176057354,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LockingTypeAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait LockingTypeAssetTrait: super::core::AssetTrait {
}

impl LockingTypeAssetTrait for LockingTypeAsset {
}

impl super::core::AssetTrait for LockingTypeAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for LockingTypeAsset {
}

pub static LOCKINGTYPEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LockingTypeAsset",
    name_hash: 1499316550,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(LockingTypeAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LockingTypeAsset as Default>::default())),
            create_boxed: || Box::new(<LockingTypeAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCKINGTYPEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LockingTypeAsset {
    fn type_info(&self) -> &'static TypeInfo {
        LOCKINGTYPEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCKINGTYPEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LockingTypeAsset-Array",
    name_hash: 978616050,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LockingTypeAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CrosshairTypeAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait CrosshairTypeAssetTrait: super::core::AssetTrait {
}

impl CrosshairTypeAssetTrait for CrosshairTypeAsset {
}

impl super::core::AssetTrait for CrosshairTypeAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CrosshairTypeAsset {
}

pub static CROSSHAIRTYPEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CrosshairTypeAsset",
    name_hash: 468879713,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(CrosshairTypeAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CrosshairTypeAsset as Default>::default())),
            create_boxed: || Box::new(<CrosshairTypeAsset as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(CROSSHAIRTYPEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CrosshairTypeAsset {
    fn type_info(&self) -> &'static TypeInfo {
        CROSSHAIRTYPEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CROSSHAIRTYPEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CrosshairTypeAsset-Array",
    name_hash: 1206518869,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CrosshairTypeAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UIPartPropertyList {
    pub _glacier_base: super::core::DataContainer,
    pub hud_property_list: Vec<BoxedTypeObject /* UIPartProperties */>,
}

pub trait UIPartPropertyListTrait: super::core::DataContainerTrait {
    fn hud_property_list(&self) -> &Vec<BoxedTypeObject /* UIPartProperties */>;
    fn hud_property_list_mut(&mut self) -> &mut Vec<BoxedTypeObject /* UIPartProperties */>;
}

impl UIPartPropertyListTrait for UIPartPropertyList {
    fn hud_property_list(&self) -> &Vec<BoxedTypeObject /* UIPartProperties */> {
        &self.hud_property_list
    }
    fn hud_property_list_mut(&mut self) -> &mut Vec<BoxedTypeObject /* UIPartProperties */> {
        &mut self.hud_property_list
    }
}

impl super::core::DataContainerTrait for UIPartPropertyList {
}

pub static UIPARTPROPERTYLIST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartPropertyList",
    name_hash: 3422923307,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(UIPartPropertyList, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIPartPropertyList as Default>::default())),
            create_boxed: || Box::new(<UIPartPropertyList as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "HudPropertyList",
                name_hash: 3433890873,
                flags: MemberInfoFlags::new(144),
                field_type: "UIPartProperties-Array",
                rust_offset: offset_of!(UIPartPropertyList, hud_property_list),
            },
        ],
    }),
    array_type: Some(UIPARTPROPERTYLIST_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UIPartPropertyList {
    fn type_info(&self) -> &'static TypeInfo {
        UIPARTPROPERTYLIST_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UIPARTPROPERTYLIST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartPropertyList-Array",
    name_hash: 1357531551,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIPartPropertyList"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UIPartProperties {
    pub identifier: UIPartIdentifier,
    pub range: f32,
    pub frequency: f32,
    pub compensate_freelook: bool,
}

pub trait UIPartPropertiesTrait: TypeObject {
    fn identifier(&self) -> &UIPartIdentifier;
    fn identifier_mut(&mut self) -> &mut UIPartIdentifier;
    fn range(&self) -> &f32;
    fn range_mut(&mut self) -> &mut f32;
    fn frequency(&self) -> &f32;
    fn frequency_mut(&mut self) -> &mut f32;
    fn compensate_freelook(&self) -> &bool;
    fn compensate_freelook_mut(&mut self) -> &mut bool;
}

impl UIPartPropertiesTrait for UIPartProperties {
    fn identifier(&self) -> &UIPartIdentifier {
        &self.identifier
    }
    fn identifier_mut(&mut self) -> &mut UIPartIdentifier {
        &mut self.identifier
    }
    fn range(&self) -> &f32 {
        &self.range
    }
    fn range_mut(&mut self) -> &mut f32 {
        &mut self.range
    }
    fn frequency(&self) -> &f32 {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut f32 {
        &mut self.frequency
    }
    fn compensate_freelook(&self) -> &bool {
        &self.compensate_freelook
    }
    fn compensate_freelook_mut(&mut self) -> &mut bool {
        &mut self.compensate_freelook
    }
}

pub static UIPARTPROPERTIES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartProperties",
    name_hash: 3801190799,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIPartProperties as Default>::default())),
            create_boxed: || Box::new(<UIPartProperties as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Identifier",
                name_hash: 3512790342,
                flags: MemberInfoFlags::new(0),
                field_type: "UIPartIdentifier",
                rust_offset: offset_of!(UIPartProperties, identifier),
            },
            FieldInfoData {
                name: "Range",
                name_hash: 230112826,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(UIPartProperties, range),
            },
            FieldInfoData {
                name: "Frequency",
                name_hash: 4112821953,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(UIPartProperties, frequency),
            },
            FieldInfoData {
                name: "CompensateFreelook",
                name_hash: 3705803663,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UIPartProperties, compensate_freelook),
            },
        ],
    }),
    array_type: Some(UIPARTPROPERTIES_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for UIPartProperties {
    fn type_info(&self) -> &'static TypeInfo {
        UIPARTPROPERTIES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UIPARTPROPERTIES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartProperties-Array",
    name_hash: 590982715,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIPartProperties"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UIHudIcon {
    #[default]
    UIHudIcon_Unused = 0,
    UIHudIcon_LocalPlayer = 1,
    UIHudIcon_LocalDirection = 2,
    UIHudIcon_FriendlyPlayer = 3,
    UIHudIcon_EnemyPlayer = 4,
    UIHudIcon_NeutralPlayer = 5,
    UIHudIcon_SquadMember = 6,
    UIHudIcon_SquadLeader = 7,
    UIHudIcon_SquadLeaderTargeted = 8,
    UIHudIcon_Vehicle = 9,
    UIHudIcon_PrimaryObjective = 10,
    UIHudIcon_PrimaryObjectiveBlink = 11,
    UIHudIcon_SecondaryObjective = 12,
    UIHudIcon_AreaMapMarker = 13,
    UIHudIcon_ObjectiveDestroy = 14,
    UIHudIcon_ObjectiveScout = 15,
    UIHudIcon_ObjectiveDefend = 16,
    UIHudIcon_ObjectiveMoveTo = 17,
    UIHudIcon_ObjectiveAttack = 18,
    UIHudIcon_ObjectiveFollow = 19,
    UIHudIcon_ObjectiveGeneral = 20,
    UIHudICon_UAV = 21,
    UIHudIcon_AmmoCrate = 22,
    UIHudIcon_MedicBag = 23,
    UIHudIcon_C4 = 24,
    UIHudIcon_ATMine = 25,
    UIHudIcon_StationaryWeapon = 26,
    UIHudIcon_North = 27,
    UIHudIcon_South = 28,
    UIHudIcon_West = 29,
    UIHudIcon_East = 30,
    UIHudIcon_NeutralFlag = 31,
    UIHudIcon_FriendlyFlag = 32,
    UIHudIcon_EnemyFlag = 33,
    UIHudIcon_FriendlyBase = 34,
    UIHudIcon_EnemyBase = 35,
    UIHudIcon_Team1Flag = 36,
    UIHudIcon_Team2Flag = 37,
    UIHudIcon_NeutralFlagLit = 38,
    UIHudIcon_FriendlyFlagLit = 39,
    UIHudIcon_EnemyFlagLit = 40,
    UIHudIcon_SelectableSpawnPoint = 41,
    UIHudIcon_SelectedSpawnPoint = 42,
    UIHudIcon_NonSelectableSpawnPoint = 43,
    UIHudIcon_FriendlyFlagUnderAttack = 44,
    UIHudIcon_EnemyFlagUnderAttack = 45,
    UIHudIcon_OrderAttack = 46,
    UIHudIcon_OrderDefend = 47,
    UIHudIcon_OrderAttackObserved = 48,
    UIHudIcon_OrderDefendObserved = 49,
    UIHudIcon_Boat = 50,
    UIHudIcon_Car = 51,
    UIHudIcon_Jeep = 52,
    UIHudIcon_HeliAttack = 53,
    UIHudIcon_HeliScout = 54,
    UIHudIcon_Tank = 55,
    UIHudIcon_TankIFV = 56,
    UIHudIcon_TankArty = 57,
    UIHudIcon_TankAA = 58,
    UIHudIcon_TankAT = 59,
    UIHudIcon_Jet = 60,
    UIHudIcon_JetBomber = 61,
    UIHudIcon_Stationary = 62,
    UIHudIcon_Strategic = 63,
    UIHudIcon_MotionRadarSweep = 64,
    UIHudIcon_NeedBackup = 65,
    UIHudIcon_NeedAmmo = 66,
    UIHudIcon_NeedMedic = 67,
    UIHudIcon_NeedPickup = 68,
    UIHudIcon_NeedRepair = 69,
    UIHudIcon_KitAssault = 70,
    UIHudIcon_KitDemolition = 71,
    UIHudIcon_KitRecon = 72,
    UIHudIcon_KitSpecialist = 73,
    UIHudIcon_KitSupport = 74,
    UIHudIcon_KitMedic = 75,
    UIHudIcon_KitEngineer = 76,
    UIHudIcon_KitPickupAssault = 77,
    UIHudIcon_KitPickupDemolition = 78,
    UIHudIcon_KitPickupRecon = 79,
    UIHudIcon_KitPickupSpecialist = 80,
    UIHudIcon_KitPickupSupport = 81,
    UIHudIcon_KitPickupMedic = 82,
    UIHudIcon_KitPickupEngineer = 83,
    UIHudIcon_Pickup = 84,
    UIHudIcon_TaggedVehicle = 85,
    UIHudIcon_LaserPaintedVehicle = 86,
    UIHudIcon_HeliTargetEnemy = 87,
    UIHudIcon_HeliTargetFriendly = 88,
    UIHudIcon_ArtilleryTarget = 89,
    UIHudIcon_NeutralFlagAttacker = 90,
    UIHudIcon_FriendlyFlagAttacker = 91,
    UIHudIcon_EnemyFlagAttacker = 92,
    UIHudIcon_LaserTarget = 93,
    UIHudIcon_ObjectiveAttacker = 94,
    UIHudIcon_ObjectiveDefender = 95,
    UIHudIcon_HealthbarBackground = 96,
    UIHudIcon_Healthbar = 97,
    UIHudIcon_RadarSweepComponent = 98,
    UIHudIcon_Blank = 99,
    UIHudIcon_LocalPlayerBigIcon = 100,
    UIHudIcon_LocalPlayerOutOfMap = 101,
    UIHudIcon_PrimaryObjectiveLarge = 102,
    UIHudIcon_TargetUnlocked = 103,
    UIHudIcon_TargetLocked = 104,
    UIHudIcon_TargetLocking = 105,
    UIHudIcon_ArtilleryStrikeNametag = 106,
    UIHudIcon_ArtilleryStrikeMinimap = 107,
    UIHudIcon_CapturePointContested = 108,
    UIHudIcon_CapturePointDefended = 109,
    UIHudIcon_RoundBar = 110,
    UIHudIcon_RoundBarBg = 111,
    UIHudIcon_RoundBarBgPlate = 112,
    UIHudIcon_SnapOvalArrow = 113,
    UIHudIcon_SquadleaderBg = 114,
    UIHudIcon_VehicleBg = 115,
    UIHudIcon_NonTakeableControlPoint = 116,
    UIHudIcon_SpottedPosition = 117,
    UIHudIcon_Grenade = 118,
    UIHudIcon_Revive = 119,
    UIHudIcon_Repair = 120,
    UIHudIcon_Interact = 121,
    UIHudIcon_Voip = 122,
    UIHudIcon_Claymore = 123,
    UIHudIcon_EodBot = 124,
    UIHudIcon_Explosive = 125,
    UIHudIcon_LaserDesignator = 126,
    UIHudIcon_Mav = 127,
    UIHudIcon_Mortar = 128,
    UIHudIcon_RadioBeacon = 129,
    UIHudIcon_Ugs = 130,
    UIHudIcon_PercetageBarMiddle = 131,
    UIHudIcon_PercetageBarEdge = 132,
    UIHudIcon_PercentageBarBackground = 133,
    UIHudIcon_TankLC = 134,
    UIHudIcon_HeliTrans = 135,
    UIHudIcon_StaticAT = 136,
    UIHudIcon_StaticAA = 137,
    UIHudIcon_SprintBoost = 138,
    UIHudIcon_AmmoBoost = 139,
    UIHudIcon_ExplosiveBoost = 140,
    UIHudIcon_ExplosiveResistBoost = 141,
    UIHudIcon_SuppressionBoost = 142,
    UIHudIcon_SuppressionResistBoost = 143,
    UIHudIcon_GrenadeBoost = 144,
    UIHudIcon_HealSpeedBoost = 145,
    UIHudIcon_NeedAmmoHighlight = 146,
    UIHudIcon_NeedMedicHighlight = 147,
    UIHudIcon_NeedRepairHighlight = 148,
    UIHudIcon_NeedPickupHighlight = 149,
    UIHudIcon_PlayerDead = 150,
    UIHudIcon_Player = 151,
    UIHudIcon_Flag = 152,
    UIHudIcon_Base = 153,
    UIHudIcon_ObjectiveNeutralBomb = 154,
    UIHudIcon_ObjectiveFriendlyBomb = 155,
    UIHudIcon_ObjectiveEnemyBomb = 156,
    UIHudIcon_ObjectiveEnemyHVT = 157,
    UIHudIcon_ObjectiveFriendlyHVT = 158,
    UIHudIcon_Count = 159,
}

pub static UIHUDICON_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIHudIcon",
    name_hash: 3556510859,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UIHUDICON_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UIHudIcon {
    fn type_info(&self) -> &'static TypeInfo {
        UIHUDICON_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UIHUDICON_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIHudIcon-Array",
    name_hash: 370457407,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIHudIcon"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UIPartIdentifier {
    #[default]
    HCI_None = 0,
    HCI_RangeMeter = 1,
    HCI_PredictedSight = 2,
    HCI_VelocityVector = 3,
    HCI_RadioAltitude = 4,
}

pub static UIPARTIDENTIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartIdentifier",
    name_hash: 1656444749,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UIPARTIDENTIFIER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UIPartIdentifier {
    fn type_info(&self) -> &'static TypeInfo {
        UIPARTIDENTIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UIPARTIDENTIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartIdentifier-Array",
    name_hash: 127159161,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIPartIdentifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CollisionMethodEnum {
    #[default]
    CMESimple = 0,
    CMEDetailed = 1,
}

pub static COLLISIONMETHODENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionMethodEnum",
    name_hash: 637874967,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(COLLISIONMETHODENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CollisionMethodEnum {
    fn type_info(&self) -> &'static TypeInfo {
        COLLISIONMETHODENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COLLISIONMETHODENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionMethodEnum-Array",
    name_hash: 1532222371,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CollisionMethodEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticModelGroupHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait StaticModelGroupHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl StaticModelGroupHealthComponentDataTrait for StaticModelGroupHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for StaticModelGroupHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for StaticModelGroupHealthComponentData {
}

impl super::entity::ComponentDataTrait for StaticModelGroupHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelGroupHealthComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelGroupHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelGroupHealthComponentData {
}

impl super::core::DataContainerTrait for StaticModelGroupHealthComponentData {
}

pub static STATICMODELGROUPHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupHealthComponentData",
    name_hash: 2618209902,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(StaticModelGroupHealthComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelGroupHealthComponentData as Default>::default())),
            create_boxed: || Box::new(<StaticModelGroupHealthComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICMODELGROUPHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelGroupHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELGROUPHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELGROUPHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupHealthComponentData-Array",
    name_hash: 2150870874,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelGroupHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticModelGroupPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
}

pub trait StaticModelGroupPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
}

impl StaticModelGroupPhysicsComponentDataTrait for StaticModelGroupPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for StaticModelGroupPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for StaticModelGroupPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for StaticModelGroupPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelGroupPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelGroupPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelGroupPhysicsComponentData {
}

impl super::core::DataContainerTrait for StaticModelGroupPhysicsComponentData {
}

pub static STATICMODELGROUPPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupPhysicsComponentData",
    name_hash: 1232745465,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(StaticModelGroupPhysicsComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelGroupPhysicsComponentData as Default>::default())),
            create_boxed: || Box::new(<StaticModelGroupPhysicsComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICMODELGROUPPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelGroupPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELGROUPPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELGROUPPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupPhysicsComponentData-Array",
    name_hash: 4198085325,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelGroupPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticModelGroupEntityData {
    pub _glacier_base: super::physics::GamePhysicsEntityData,
    pub member_datas: Vec<BoxedTypeObject /* StaticModelGroupMemberData */>,
    pub network_id_count: u32,
    pub hack_to_solve_real_time_tweaking_issue: glacier_util::guid::Guid,
}

pub trait StaticModelGroupEntityDataTrait: super::physics::GamePhysicsEntityDataTrait {
    fn member_datas(&self) -> &Vec<BoxedTypeObject /* StaticModelGroupMemberData */>;
    fn member_datas_mut(&mut self) -> &mut Vec<BoxedTypeObject /* StaticModelGroupMemberData */>;
    fn network_id_count(&self) -> &u32;
    fn network_id_count_mut(&mut self) -> &mut u32;
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid;
    fn hack_to_solve_real_time_tweaking_issue_mut(&mut self) -> &mut glacier_util::guid::Guid;
}

impl StaticModelGroupEntityDataTrait for StaticModelGroupEntityData {
    fn member_datas(&self) -> &Vec<BoxedTypeObject /* StaticModelGroupMemberData */> {
        &self.member_datas
    }
    fn member_datas_mut(&mut self) -> &mut Vec<BoxedTypeObject /* StaticModelGroupMemberData */> {
        &mut self.member_datas
    }
    fn network_id_count(&self) -> &u32 {
        &self.network_id_count
    }
    fn network_id_count_mut(&mut self) -> &mut u32 {
        &mut self.network_id_count
    }
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid {
        &self.hack_to_solve_real_time_tweaking_issue
    }
    fn hack_to_solve_real_time_tweaking_issue_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.hack_to_solve_real_time_tweaking_issue
    }
}

impl super::physics::GamePhysicsEntityDataTrait for StaticModelGroupEntityData {
}

impl super::entity::GameComponentEntityDataTrait for StaticModelGroupEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for StaticModelGroupEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for StaticModelGroupEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for StaticModelGroupEntityData {
}

impl super::entity::GameObjectDataTrait for StaticModelGroupEntityData {
}

impl super::core::DataBusPeerTrait for StaticModelGroupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelGroupEntityData {
}

impl super::core::DataContainerTrait for StaticModelGroupEntityData {
}

pub static STATICMODELGROUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupEntityData",
    name_hash: 218481190,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::GAMEPHYSICSENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(StaticModelGroupEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelGroupEntityData as Default>::default())),
            create_boxed: || Box::new(<StaticModelGroupEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MemberDatas",
                name_hash: 1084657014,
                flags: MemberInfoFlags::new(144),
                field_type: "StaticModelGroupMemberData-Array",
                rust_offset: offset_of!(StaticModelGroupEntityData, member_datas),
            },
            FieldInfoData {
                name: "NetworkIdCount",
                name_hash: 1234693717,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupEntityData, network_id_count),
            },
            FieldInfoData {
                name: "HackToSolveRealTimeTweakingIssue",
                name_hash: 1452521702,
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(StaticModelGroupEntityData, hack_to_solve_real_time_tweaking_issue),
            },
        ],
    }),
    array_type: Some(STATICMODELGROUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelGroupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELGROUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELGROUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupEntityData-Array",
    name_hash: 3515182738,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelGroupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticModelGroupMemberData {
    pub instance_transforms: Vec<BoxedTypeObject /* super::core::LinearTransform */>,
    pub instance_object_variation: Vec<u32>,
    pub instance_rendering_overrides: Vec<BoxedTypeObject /* super::core::RenderingOverrides */>,
    pub instance_radiosity_type_override: Vec<super::core::RadiosityTypeOverride>,
    pub instance_terrain_shader_nodes_enable: Vec<bool>,
    pub member_type: Option<LockedTypeObject /* super::physics::GamePhysicsEntityData */>,
    pub mesh_asset: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub instance_count: u32,
    pub health_state_entity_manager_id: u32,
    pub physics_part_range: IndexRange,
    pub physics_part_count_per_instance: u32,
    pub network_id_range: IndexRange,
    pub network_id_count_per_instance: u32,
    pub part_component_count: u32,
}

pub trait StaticModelGroupMemberDataTrait: TypeObject {
    fn instance_transforms(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn instance_transforms_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */>;
    fn instance_object_variation(&self) -> &Vec<u32>;
    fn instance_object_variation_mut(&mut self) -> &mut Vec<u32>;
    fn instance_rendering_overrides(&self) -> &Vec<BoxedTypeObject /* super::core::RenderingOverrides */>;
    fn instance_rendering_overrides_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::RenderingOverrides */>;
    fn instance_radiosity_type_override(&self) -> &Vec<super::core::RadiosityTypeOverride>;
    fn instance_radiosity_type_override_mut(&mut self) -> &mut Vec<super::core::RadiosityTypeOverride>;
    fn instance_terrain_shader_nodes_enable(&self) -> &Vec<bool>;
    fn instance_terrain_shader_nodes_enable_mut(&mut self) -> &mut Vec<bool>;
    fn member_type(&self) -> &Option<LockedTypeObject /* super::physics::GamePhysicsEntityData */>;
    fn member_type_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::GamePhysicsEntityData */>;
    fn mesh_asset(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn instance_count(&self) -> &u32;
    fn instance_count_mut(&mut self) -> &mut u32;
    fn health_state_entity_manager_id(&self) -> &u32;
    fn health_state_entity_manager_id_mut(&mut self) -> &mut u32;
    fn physics_part_range(&self) -> &IndexRange;
    fn physics_part_range_mut(&mut self) -> &mut IndexRange;
    fn physics_part_count_per_instance(&self) -> &u32;
    fn physics_part_count_per_instance_mut(&mut self) -> &mut u32;
    fn network_id_range(&self) -> &IndexRange;
    fn network_id_range_mut(&mut self) -> &mut IndexRange;
    fn network_id_count_per_instance(&self) -> &u32;
    fn network_id_count_per_instance_mut(&mut self) -> &mut u32;
    fn part_component_count(&self) -> &u32;
    fn part_component_count_mut(&mut self) -> &mut u32;
}

impl StaticModelGroupMemberDataTrait for StaticModelGroupMemberData {
    fn instance_transforms(&self) -> &Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &self.instance_transforms
    }
    fn instance_transforms_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinearTransform */> {
        &mut self.instance_transforms
    }
    fn instance_object_variation(&self) -> &Vec<u32> {
        &self.instance_object_variation
    }
    fn instance_object_variation_mut(&mut self) -> &mut Vec<u32> {
        &mut self.instance_object_variation
    }
    fn instance_rendering_overrides(&self) -> &Vec<BoxedTypeObject /* super::core::RenderingOverrides */> {
        &self.instance_rendering_overrides
    }
    fn instance_rendering_overrides_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::RenderingOverrides */> {
        &mut self.instance_rendering_overrides
    }
    fn instance_radiosity_type_override(&self) -> &Vec<super::core::RadiosityTypeOverride> {
        &self.instance_radiosity_type_override
    }
    fn instance_radiosity_type_override_mut(&mut self) -> &mut Vec<super::core::RadiosityTypeOverride> {
        &mut self.instance_radiosity_type_override
    }
    fn instance_terrain_shader_nodes_enable(&self) -> &Vec<bool> {
        &self.instance_terrain_shader_nodes_enable
    }
    fn instance_terrain_shader_nodes_enable_mut(&mut self) -> &mut Vec<bool> {
        &mut self.instance_terrain_shader_nodes_enable
    }
    fn member_type(&self) -> &Option<LockedTypeObject /* super::physics::GamePhysicsEntityData */> {
        &self.member_type
    }
    fn member_type_mut(&mut self) -> &mut Option<LockedTypeObject /* super::physics::GamePhysicsEntityData */> {
        &mut self.member_type
    }
    fn mesh_asset(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh_asset
    }
    fn mesh_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh_asset
    }
    fn instance_count(&self) -> &u32 {
        &self.instance_count
    }
    fn instance_count_mut(&mut self) -> &mut u32 {
        &mut self.instance_count
    }
    fn health_state_entity_manager_id(&self) -> &u32 {
        &self.health_state_entity_manager_id
    }
    fn health_state_entity_manager_id_mut(&mut self) -> &mut u32 {
        &mut self.health_state_entity_manager_id
    }
    fn physics_part_range(&self) -> &IndexRange {
        &self.physics_part_range
    }
    fn physics_part_range_mut(&mut self) -> &mut IndexRange {
        &mut self.physics_part_range
    }
    fn physics_part_count_per_instance(&self) -> &u32 {
        &self.physics_part_count_per_instance
    }
    fn physics_part_count_per_instance_mut(&mut self) -> &mut u32 {
        &mut self.physics_part_count_per_instance
    }
    fn network_id_range(&self) -> &IndexRange {
        &self.network_id_range
    }
    fn network_id_range_mut(&mut self) -> &mut IndexRange {
        &mut self.network_id_range
    }
    fn network_id_count_per_instance(&self) -> &u32 {
        &self.network_id_count_per_instance
    }
    fn network_id_count_per_instance_mut(&mut self) -> &mut u32 {
        &mut self.network_id_count_per_instance
    }
    fn part_component_count(&self) -> &u32 {
        &self.part_component_count
    }
    fn part_component_count_mut(&mut self) -> &mut u32 {
        &mut self.part_component_count
    }
}

pub static STATICMODELGROUPMEMBERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupMemberData",
    name_hash: 711139821,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelGroupMemberData as Default>::default())),
            create_boxed: || Box::new(<StaticModelGroupMemberData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InstanceTransforms",
                name_hash: 3878849363,
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_transforms),
            },
            FieldInfoData {
                name: "InstanceObjectVariation",
                name_hash: 2895987976,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_object_variation),
            },
            FieldInfoData {
                name: "InstanceRenderingOverrides",
                name_hash: 1577935745,
                flags: MemberInfoFlags::new(144),
                field_type: "RenderingOverrides-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_rendering_overrides),
            },
            FieldInfoData {
                name: "InstanceRadiosityTypeOverride",
                name_hash: 1954263302,
                flags: MemberInfoFlags::new(144),
                field_type: "RadiosityTypeOverride-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_radiosity_type_override),
            },
            FieldInfoData {
                name: "InstanceTerrainShaderNodesEnable",
                name_hash: 3651168000,
                flags: MemberInfoFlags::new(144),
                field_type: "Boolean-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_terrain_shader_nodes_enable),
            },
            FieldInfoData {
                name: "MemberType",
                name_hash: 2244878317,
                flags: MemberInfoFlags::new(0),
                field_type: "GamePhysicsEntityData",
                rust_offset: offset_of!(StaticModelGroupMemberData, member_type),
            },
            FieldInfoData {
                name: "MeshAsset",
                name_hash: 15738982,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(StaticModelGroupMemberData, mesh_asset),
            },
            FieldInfoData {
                name: "InstanceCount",
                name_hash: 536540879,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_count),
            },
            FieldInfoData {
                name: "HealthStateEntityManagerId",
                name_hash: 4181756587,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, health_state_entity_manager_id),
            },
            FieldInfoData {
                name: "PhysicsPartRange",
                name_hash: 357063654,
                flags: MemberInfoFlags::new(0),
                field_type: "IndexRange",
                rust_offset: offset_of!(StaticModelGroupMemberData, physics_part_range),
            },
            FieldInfoData {
                name: "PhysicsPartCountPerInstance",
                name_hash: 2036496020,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, physics_part_count_per_instance),
            },
            FieldInfoData {
                name: "NetworkIdRange",
                name_hash: 1216708329,
                flags: MemberInfoFlags::new(0),
                field_type: "IndexRange",
                rust_offset: offset_of!(StaticModelGroupMemberData, network_id_range),
            },
            FieldInfoData {
                name: "NetworkIdCountPerInstance",
                name_hash: 3896998395,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, network_id_count_per_instance),
            },
            FieldInfoData {
                name: "PartComponentCount",
                name_hash: 4205683934,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, part_component_count),
            },
        ],
    }),
    array_type: Some(STATICMODELGROUPMEMBERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StaticModelGroupMemberData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELGROUPMEMBERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STATICMODELGROUPMEMBERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupMemberData-Array",
    name_hash: 3746170585,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelGroupMemberData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameSplineEntityData {
    pub _glacier_base: super::entity::GameComponentEntityData,
    pub realm: super::core::Realm,
    pub game_spline_data_guid: glacier_util::guid::Guid,
    pub length: f32,
    pub discrete_local_points: Vec<BoxedTypeObject /* super::core::Vec3 */>,
    pub discrete_normals: Vec<BoxedTypeObject /* super::core::Vec3 */>,
    pub discrete_normalized_lengths: Vec<f32>,
}

pub trait GameSplineEntityDataTrait: super::entity::GameComponentEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn game_spline_data_guid(&self) -> &glacier_util::guid::Guid;
    fn game_spline_data_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
    fn discrete_local_points(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn discrete_local_points_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn discrete_normals(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn discrete_normals_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn discrete_normalized_lengths(&self) -> &Vec<f32>;
    fn discrete_normalized_lengths_mut(&mut self) -> &mut Vec<f32>;
}

impl GameSplineEntityDataTrait for GameSplineEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn game_spline_data_guid(&self) -> &glacier_util::guid::Guid {
        &self.game_spline_data_guid
    }
    fn game_spline_data_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.game_spline_data_guid
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
    fn discrete_local_points(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.discrete_local_points
    }
    fn discrete_local_points_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.discrete_local_points
    }
    fn discrete_normals(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.discrete_normals
    }
    fn discrete_normals_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.discrete_normals
    }
    fn discrete_normalized_lengths(&self) -> &Vec<f32> {
        &self.discrete_normalized_lengths
    }
    fn discrete_normalized_lengths_mut(&mut self) -> &mut Vec<f32> {
        &mut self.discrete_normalized_lengths
    }
}

impl super::entity::GameComponentEntityDataTrait for GameSplineEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for GameSplineEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for GameSplineEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for GameSplineEntityData {
}

impl super::entity::GameObjectDataTrait for GameSplineEntityData {
}

impl super::core::DataBusPeerTrait for GameSplineEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameSplineEntityData {
}

impl super::core::DataContainerTrait for GameSplineEntityData {
}

pub static GAMESPLINEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSplineEntityData",
    name_hash: 3546123661,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(GameSplineEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameSplineEntityData as Default>::default())),
            create_boxed: || Box::new(<GameSplineEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(GameSplineEntityData, realm),
            },
            FieldInfoData {
                name: "GameSplineDataGuid",
                name_hash: 412297897,
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(GameSplineEntityData, game_spline_data_guid),
            },
            FieldInfoData {
                name: "Length",
                name_hash: 2906827577,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameSplineEntityData, length),
            },
            FieldInfoData {
                name: "DiscreteLocalPoints",
                name_hash: 2435507212,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(GameSplineEntityData, discrete_local_points),
            },
            FieldInfoData {
                name: "DiscreteNormals",
                name_hash: 1837844894,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(GameSplineEntityData, discrete_normals),
            },
            FieldInfoData {
                name: "DiscreteNormalizedLengths",
                name_hash: 4226632624,
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(GameSplineEntityData, discrete_normalized_lengths),
            },
        ],
    }),
    array_type: Some(GAMESPLINEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GameSplineEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMESPLINEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMESPLINEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSplineEntityData-Array",
    name_hash: 4191826233,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameSplineEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameSplineData {
    pub _glacier_base: super::entity::CustomSplineData,
}

pub trait GameSplineDataTrait: super::entity::CustomSplineDataTrait {
}

impl GameSplineDataTrait for GameSplineData {
}

impl super::entity::CustomSplineDataTrait for GameSplineData {
}

impl super::entity::VectorShapeDataTrait for GameSplineData {
    fn points(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points()
    }
    fn points_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        self._glacier_base.points_mut()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn tension_mut(&mut self) -> &mut f32 {
        self._glacier_base.tension_mut()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_closed_mut()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_roll_mut()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_yaw_pitch_mut()
    }
}

impl super::entity::BaseShapeDataTrait for GameSplineData {
}

impl super::entity::BaseShapeDataBaseTrait for GameSplineData {
}

impl super::entity::GameObjectDataTrait for GameSplineData {
}

impl super::core::DataBusPeerTrait for GameSplineData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameSplineData {
}

impl super::core::DataContainerTrait for GameSplineData {
}

pub static GAMESPLINEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSplineData",
    name_hash: 3114178582,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::CUSTOMSPLINEDATA_TYPE_INFO),
        super_class_offset: offset_of!(GameSplineData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameSplineData as Default>::default())),
            create_boxed: || Box::new(<GameSplineData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMESPLINEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameSplineData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMESPLINEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMESPLINEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSplineData-Array",
    name_hash: 2068704546,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameSplineData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LicenseeGameSettings {
    pub _glacier_base: super::core::SystemSettings,
    pub min_player_count_elimination: u32,
    pub use_speed_based_detailed_collision: bool,
    pub use_single_weapon_selector: bool,
    pub auto_aim_enabled: bool,
    pub p_s3_content_rating_age: u32,
    pub has_unlimited_ammo: bool,
    pub has_unlimited_mags: bool,
    pub rotate_logs: bool,
    pub log_history: u32,
    pub adjust_vehicle_center_of_mass: bool,
    pub time_before_spawn_is_allowed: f32,
    pub level_warm_up_time: f32,
    pub difficulty_settings: Option<LockedTypeObject /* DifficultyDatas */>,
    pub aim_assist_enabled: bool,
    pub aim_assist_use_polynomials: bool,
    pub is_god_mode: bool,
    pub is_jesus_mode: bool,
    pub is_jesus_mode_ai: bool,
    pub current_s_k_u: SKU,
    pub game_administration_enabled: bool,
    pub allow_destruction_outside_combat_area: bool,
    pub controllable_significance_settings: SignificanceSettings,
}

pub trait LicenseeGameSettingsTrait: super::core::SystemSettingsTrait {
    fn min_player_count_elimination(&self) -> &u32;
    fn min_player_count_elimination_mut(&mut self) -> &mut u32;
    fn use_speed_based_detailed_collision(&self) -> &bool;
    fn use_speed_based_detailed_collision_mut(&mut self) -> &mut bool;
    fn use_single_weapon_selector(&self) -> &bool;
    fn use_single_weapon_selector_mut(&mut self) -> &mut bool;
    fn auto_aim_enabled(&self) -> &bool;
    fn auto_aim_enabled_mut(&mut self) -> &mut bool;
    fn p_s3_content_rating_age(&self) -> &u32;
    fn p_s3_content_rating_age_mut(&mut self) -> &mut u32;
    fn has_unlimited_ammo(&self) -> &bool;
    fn has_unlimited_ammo_mut(&mut self) -> &mut bool;
    fn has_unlimited_mags(&self) -> &bool;
    fn has_unlimited_mags_mut(&mut self) -> &mut bool;
    fn rotate_logs(&self) -> &bool;
    fn rotate_logs_mut(&mut self) -> &mut bool;
    fn log_history(&self) -> &u32;
    fn log_history_mut(&mut self) -> &mut u32;
    fn adjust_vehicle_center_of_mass(&self) -> &bool;
    fn adjust_vehicle_center_of_mass_mut(&mut self) -> &mut bool;
    fn time_before_spawn_is_allowed(&self) -> &f32;
    fn time_before_spawn_is_allowed_mut(&mut self) -> &mut f32;
    fn level_warm_up_time(&self) -> &f32;
    fn level_warm_up_time_mut(&mut self) -> &mut f32;
    fn difficulty_settings(&self) -> &Option<LockedTypeObject /* DifficultyDatas */>;
    fn difficulty_settings_mut(&mut self) -> &mut Option<LockedTypeObject /* DifficultyDatas */>;
    fn aim_assist_enabled(&self) -> &bool;
    fn aim_assist_enabled_mut(&mut self) -> &mut bool;
    fn aim_assist_use_polynomials(&self) -> &bool;
    fn aim_assist_use_polynomials_mut(&mut self) -> &mut bool;
    fn is_god_mode(&self) -> &bool;
    fn is_god_mode_mut(&mut self) -> &mut bool;
    fn is_jesus_mode(&self) -> &bool;
    fn is_jesus_mode_mut(&mut self) -> &mut bool;
    fn is_jesus_mode_ai(&self) -> &bool;
    fn is_jesus_mode_ai_mut(&mut self) -> &mut bool;
    fn current_s_k_u(&self) -> &SKU;
    fn current_s_k_u_mut(&mut self) -> &mut SKU;
    fn game_administration_enabled(&self) -> &bool;
    fn game_administration_enabled_mut(&mut self) -> &mut bool;
    fn allow_destruction_outside_combat_area(&self) -> &bool;
    fn allow_destruction_outside_combat_area_mut(&mut self) -> &mut bool;
    fn controllable_significance_settings(&self) -> &SignificanceSettings;
    fn controllable_significance_settings_mut(&mut self) -> &mut SignificanceSettings;
}

impl LicenseeGameSettingsTrait for LicenseeGameSettings {
    fn min_player_count_elimination(&self) -> &u32 {
        &self.min_player_count_elimination
    }
    fn min_player_count_elimination_mut(&mut self) -> &mut u32 {
        &mut self.min_player_count_elimination
    }
    fn use_speed_based_detailed_collision(&self) -> &bool {
        &self.use_speed_based_detailed_collision
    }
    fn use_speed_based_detailed_collision_mut(&mut self) -> &mut bool {
        &mut self.use_speed_based_detailed_collision
    }
    fn use_single_weapon_selector(&self) -> &bool {
        &self.use_single_weapon_selector
    }
    fn use_single_weapon_selector_mut(&mut self) -> &mut bool {
        &mut self.use_single_weapon_selector
    }
    fn auto_aim_enabled(&self) -> &bool {
        &self.auto_aim_enabled
    }
    fn auto_aim_enabled_mut(&mut self) -> &mut bool {
        &mut self.auto_aim_enabled
    }
    fn p_s3_content_rating_age(&self) -> &u32 {
        &self.p_s3_content_rating_age
    }
    fn p_s3_content_rating_age_mut(&mut self) -> &mut u32 {
        &mut self.p_s3_content_rating_age
    }
    fn has_unlimited_ammo(&self) -> &bool {
        &self.has_unlimited_ammo
    }
    fn has_unlimited_ammo_mut(&mut self) -> &mut bool {
        &mut self.has_unlimited_ammo
    }
    fn has_unlimited_mags(&self) -> &bool {
        &self.has_unlimited_mags
    }
    fn has_unlimited_mags_mut(&mut self) -> &mut bool {
        &mut self.has_unlimited_mags
    }
    fn rotate_logs(&self) -> &bool {
        &self.rotate_logs
    }
    fn rotate_logs_mut(&mut self) -> &mut bool {
        &mut self.rotate_logs
    }
    fn log_history(&self) -> &u32 {
        &self.log_history
    }
    fn log_history_mut(&mut self) -> &mut u32 {
        &mut self.log_history
    }
    fn adjust_vehicle_center_of_mass(&self) -> &bool {
        &self.adjust_vehicle_center_of_mass
    }
    fn adjust_vehicle_center_of_mass_mut(&mut self) -> &mut bool {
        &mut self.adjust_vehicle_center_of_mass
    }
    fn time_before_spawn_is_allowed(&self) -> &f32 {
        &self.time_before_spawn_is_allowed
    }
    fn time_before_spawn_is_allowed_mut(&mut self) -> &mut f32 {
        &mut self.time_before_spawn_is_allowed
    }
    fn level_warm_up_time(&self) -> &f32 {
        &self.level_warm_up_time
    }
    fn level_warm_up_time_mut(&mut self) -> &mut f32 {
        &mut self.level_warm_up_time
    }
    fn difficulty_settings(&self) -> &Option<LockedTypeObject /* DifficultyDatas */> {
        &self.difficulty_settings
    }
    fn difficulty_settings_mut(&mut self) -> &mut Option<LockedTypeObject /* DifficultyDatas */> {
        &mut self.difficulty_settings
    }
    fn aim_assist_enabled(&self) -> &bool {
        &self.aim_assist_enabled
    }
    fn aim_assist_enabled_mut(&mut self) -> &mut bool {
        &mut self.aim_assist_enabled
    }
    fn aim_assist_use_polynomials(&self) -> &bool {
        &self.aim_assist_use_polynomials
    }
    fn aim_assist_use_polynomials_mut(&mut self) -> &mut bool {
        &mut self.aim_assist_use_polynomials
    }
    fn is_god_mode(&self) -> &bool {
        &self.is_god_mode
    }
    fn is_god_mode_mut(&mut self) -> &mut bool {
        &mut self.is_god_mode
    }
    fn is_jesus_mode(&self) -> &bool {
        &self.is_jesus_mode
    }
    fn is_jesus_mode_mut(&mut self) -> &mut bool {
        &mut self.is_jesus_mode
    }
    fn is_jesus_mode_ai(&self) -> &bool {
        &self.is_jesus_mode_ai
    }
    fn is_jesus_mode_ai_mut(&mut self) -> &mut bool {
        &mut self.is_jesus_mode_ai
    }
    fn current_s_k_u(&self) -> &SKU {
        &self.current_s_k_u
    }
    fn current_s_k_u_mut(&mut self) -> &mut SKU {
        &mut self.current_s_k_u
    }
    fn game_administration_enabled(&self) -> &bool {
        &self.game_administration_enabled
    }
    fn game_administration_enabled_mut(&mut self) -> &mut bool {
        &mut self.game_administration_enabled
    }
    fn allow_destruction_outside_combat_area(&self) -> &bool {
        &self.allow_destruction_outside_combat_area
    }
    fn allow_destruction_outside_combat_area_mut(&mut self) -> &mut bool {
        &mut self.allow_destruction_outside_combat_area
    }
    fn controllable_significance_settings(&self) -> &SignificanceSettings {
        &self.controllable_significance_settings
    }
    fn controllable_significance_settings_mut(&mut self) -> &mut SignificanceSettings {
        &mut self.controllable_significance_settings
    }
}

impl super::core::SystemSettingsTrait for LicenseeGameSettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        self._glacier_base.platform_mut()
    }
}

impl super::core::DataContainerTrait for LicenseeGameSettings {
}

pub static LICENSEEGAMESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LicenseeGameSettings",
    name_hash: 4196941456,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        super_class_offset: offset_of!(LicenseeGameSettings, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LicenseeGameSettings as Default>::default())),
            create_boxed: || Box::new(<LicenseeGameSettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MinPlayerCountElimination",
                name_hash: 760000168,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LicenseeGameSettings, min_player_count_elimination),
            },
            FieldInfoData {
                name: "UseSpeedBasedDetailedCollision",
                name_hash: 801331358,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, use_speed_based_detailed_collision),
            },
            FieldInfoData {
                name: "UseSingleWeaponSelector",
                name_hash: 1670669515,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, use_single_weapon_selector),
            },
            FieldInfoData {
                name: "AutoAimEnabled",
                name_hash: 2330232810,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, auto_aim_enabled),
            },
            FieldInfoData {
                name: "PS3ContentRatingAge",
                name_hash: 534892568,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LicenseeGameSettings, p_s3_content_rating_age),
            },
            FieldInfoData {
                name: "HasUnlimitedAmmo",
                name_hash: 3689258814,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, has_unlimited_ammo),
            },
            FieldInfoData {
                name: "HasUnlimitedMags",
                name_hash: 3689677416,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, has_unlimited_mags),
            },
            FieldInfoData {
                name: "RotateLogs",
                name_hash: 1480400363,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, rotate_logs),
            },
            FieldInfoData {
                name: "LogHistory",
                name_hash: 1374192771,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LicenseeGameSettings, log_history),
            },
            FieldInfoData {
                name: "AdjustVehicleCenterOfMass",
                name_hash: 589491054,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, adjust_vehicle_center_of_mass),
            },
            FieldInfoData {
                name: "TimeBeforeSpawnIsAllowed",
                name_hash: 3672151792,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LicenseeGameSettings, time_before_spawn_is_allowed),
            },
            FieldInfoData {
                name: "LevelWarmUpTime",
                name_hash: 3353881322,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LicenseeGameSettings, level_warm_up_time),
            },
            FieldInfoData {
                name: "DifficultySettings",
                name_hash: 1244447411,
                flags: MemberInfoFlags::new(0),
                field_type: "DifficultyDatas",
                rust_offset: offset_of!(LicenseeGameSettings, difficulty_settings),
            },
            FieldInfoData {
                name: "AimAssistEnabled",
                name_hash: 3924289354,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, aim_assist_enabled),
            },
            FieldInfoData {
                name: "AimAssistUsePolynomials",
                name_hash: 1082705757,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, aim_assist_use_polynomials),
            },
            FieldInfoData {
                name: "IsGodMode",
                name_hash: 568328144,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, is_god_mode),
            },
            FieldInfoData {
                name: "IsJesusMode",
                name_hash: 314138150,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, is_jesus_mode),
            },
            FieldInfoData {
                name: "IsJesusModeAi",
                name_hash: 2794026990,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, is_jesus_mode_ai),
            },
            FieldInfoData {
                name: "CurrentSKU",
                name_hash: 1385383009,
                flags: MemberInfoFlags::new(0),
                field_type: "SKU",
                rust_offset: offset_of!(LicenseeGameSettings, current_s_k_u),
            },
            FieldInfoData {
                name: "GameAdministrationEnabled",
                name_hash: 2064959744,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, game_administration_enabled),
            },
            FieldInfoData {
                name: "AllowDestructionOutsideCombatArea",
                name_hash: 1836790742,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, allow_destruction_outside_combat_area),
            },
            FieldInfoData {
                name: "ControllableSignificanceSettings",
                name_hash: 4221589918,
                flags: MemberInfoFlags::new(0),
                field_type: "SignificanceSettings",
                rust_offset: offset_of!(LicenseeGameSettings, controllable_significance_settings),
            },
        ],
    }),
    array_type: Some(LICENSEEGAMESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LicenseeGameSettings {
    fn type_info(&self) -> &'static TypeInfo {
        LICENSEEGAMESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LICENSEEGAMESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LicenseeGameSettings-Array",
    name_hash: 1143901348,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LicenseeGameSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SignificanceSettings {
    pub high: u32,
    pub medium: u32,
    pub is_enabled: bool,
    pub primary_radius: f32,
    pub primary_length: f32,
    pub secondary_radius: f32,
    pub secondary_length: f32,
}

pub trait SignificanceSettingsTrait: TypeObject {
    fn high(&self) -> &u32;
    fn high_mut(&mut self) -> &mut u32;
    fn medium(&self) -> &u32;
    fn medium_mut(&mut self) -> &mut u32;
    fn is_enabled(&self) -> &bool;
    fn is_enabled_mut(&mut self) -> &mut bool;
    fn primary_radius(&self) -> &f32;
    fn primary_radius_mut(&mut self) -> &mut f32;
    fn primary_length(&self) -> &f32;
    fn primary_length_mut(&mut self) -> &mut f32;
    fn secondary_radius(&self) -> &f32;
    fn secondary_radius_mut(&mut self) -> &mut f32;
    fn secondary_length(&self) -> &f32;
    fn secondary_length_mut(&mut self) -> &mut f32;
}

impl SignificanceSettingsTrait for SignificanceSettings {
    fn high(&self) -> &u32 {
        &self.high
    }
    fn high_mut(&mut self) -> &mut u32 {
        &mut self.high
    }
    fn medium(&self) -> &u32 {
        &self.medium
    }
    fn medium_mut(&mut self) -> &mut u32 {
        &mut self.medium
    }
    fn is_enabled(&self) -> &bool {
        &self.is_enabled
    }
    fn is_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_enabled
    }
    fn primary_radius(&self) -> &f32 {
        &self.primary_radius
    }
    fn primary_radius_mut(&mut self) -> &mut f32 {
        &mut self.primary_radius
    }
    fn primary_length(&self) -> &f32 {
        &self.primary_length
    }
    fn primary_length_mut(&mut self) -> &mut f32 {
        &mut self.primary_length
    }
    fn secondary_radius(&self) -> &f32 {
        &self.secondary_radius
    }
    fn secondary_radius_mut(&mut self) -> &mut f32 {
        &mut self.secondary_radius
    }
    fn secondary_length(&self) -> &f32 {
        &self.secondary_length
    }
    fn secondary_length_mut(&mut self) -> &mut f32 {
        &mut self.secondary_length
    }
}

pub static SIGNIFICANCESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SignificanceSettings",
    name_hash: 3591629247,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SignificanceSettings as Default>::default())),
            create_boxed: || Box::new(<SignificanceSettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "High",
                name_hash: 2089152523,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SignificanceSettings, high),
            },
            FieldInfoData {
                name: "Medium",
                name_hash: 2647104632,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SignificanceSettings, medium),
            },
            FieldInfoData {
                name: "IsEnabled",
                name_hash: 2323834330,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SignificanceSettings, is_enabled),
            },
            FieldInfoData {
                name: "PrimaryRadius",
                name_hash: 2454780945,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SignificanceSettings, primary_radius),
            },
            FieldInfoData {
                name: "PrimaryLength",
                name_hash: 1437628021,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SignificanceSettings, primary_length),
            },
            FieldInfoData {
                name: "SecondaryRadius",
                name_hash: 35825703,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SignificanceSettings, secondary_radius),
            },
            FieldInfoData {
                name: "SecondaryLength",
                name_hash: 427404931,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SignificanceSettings, secondary_length),
            },
        ],
    }),
    array_type: Some(SIGNIFICANCESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SignificanceSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SIGNIFICANCESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SIGNIFICANCESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SignificanceSettings-Array",
    name_hash: 811376395,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SignificanceSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SKU {
    #[default]
    WW = 0,
    EU = 1,
    US = 2,
    JPN = 3,
    ROA = 4,
    RU = 5,
    EN = 6,
}

pub static SKU_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SKU",
    name_hash: 193467592,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(SKU_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SKU {
    fn type_info(&self) -> &'static TypeInfo {
        SKU_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SKU_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SKU-Array",
    name_hash: 2312546172,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SKU"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct InteractionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub use_within_radius: f32,
    pub use_within_angle: f32,
    pub test_if_occluded: bool,
    pub max_uses: u32,
    pub allow_interaction_via_remote_entry: bool,
    pub display_within_radius: f32,
    pub use_display_within_radius: bool,
    pub pre_interaction_sound_effect: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub enabled: bool,
}

pub trait InteractionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn use_within_radius(&self) -> &f32;
    fn use_within_radius_mut(&mut self) -> &mut f32;
    fn use_within_angle(&self) -> &f32;
    fn use_within_angle_mut(&mut self) -> &mut f32;
    fn test_if_occluded(&self) -> &bool;
    fn test_if_occluded_mut(&mut self) -> &mut bool;
    fn max_uses(&self) -> &u32;
    fn max_uses_mut(&mut self) -> &mut u32;
    fn allow_interaction_via_remote_entry(&self) -> &bool;
    fn allow_interaction_via_remote_entry_mut(&mut self) -> &mut bool;
    fn display_within_radius(&self) -> &f32;
    fn display_within_radius_mut(&mut self) -> &mut f32;
    fn use_display_within_radius(&self) -> &bool;
    fn use_display_within_radius_mut(&mut self) -> &mut bool;
    fn pre_interaction_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn pre_interaction_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl InteractionEntityDataTrait for InteractionEntityData {
    fn use_within_radius(&self) -> &f32 {
        &self.use_within_radius
    }
    fn use_within_radius_mut(&mut self) -> &mut f32 {
        &mut self.use_within_radius
    }
    fn use_within_angle(&self) -> &f32 {
        &self.use_within_angle
    }
    fn use_within_angle_mut(&mut self) -> &mut f32 {
        &mut self.use_within_angle
    }
    fn test_if_occluded(&self) -> &bool {
        &self.test_if_occluded
    }
    fn test_if_occluded_mut(&mut self) -> &mut bool {
        &mut self.test_if_occluded
    }
    fn max_uses(&self) -> &u32 {
        &self.max_uses
    }
    fn max_uses_mut(&mut self) -> &mut u32 {
        &mut self.max_uses
    }
    fn allow_interaction_via_remote_entry(&self) -> &bool {
        &self.allow_interaction_via_remote_entry
    }
    fn allow_interaction_via_remote_entry_mut(&mut self) -> &mut bool {
        &mut self.allow_interaction_via_remote_entry
    }
    fn display_within_radius(&self) -> &f32 {
        &self.display_within_radius
    }
    fn display_within_radius_mut(&mut self) -> &mut f32 {
        &mut self.display_within_radius
    }
    fn use_display_within_radius(&self) -> &bool {
        &self.use_display_within_radius
    }
    fn use_display_within_radius_mut(&mut self) -> &mut bool {
        &mut self.use_display_within_radius
    }
    fn pre_interaction_sound_effect(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.pre_interaction_sound_effect
    }
    fn pre_interaction_sound_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.pre_interaction_sound_effect
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for InteractionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for InteractionEntityData {
}

impl super::entity::GameObjectDataTrait for InteractionEntityData {
}

impl super::core::DataBusPeerTrait for InteractionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for InteractionEntityData {
}

impl super::core::DataContainerTrait for InteractionEntityData {
}

pub static INTERACTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InteractionEntityData",
    name_hash: 739826548,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(InteractionEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InteractionEntityData as Default>::default())),
            create_boxed: || Box::new(<InteractionEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "UseWithinRadius",
                name_hash: 2619256891,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InteractionEntityData, use_within_radius),
            },
            FieldInfoData {
                name: "UseWithinAngle",
                name_hash: 2931974274,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InteractionEntityData, use_within_angle),
            },
            FieldInfoData {
                name: "TestIfOccluded",
                name_hash: 1300068079,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InteractionEntityData, test_if_occluded),
            },
            FieldInfoData {
                name: "MaxUses",
                name_hash: 1313728481,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(InteractionEntityData, max_uses),
            },
            FieldInfoData {
                name: "AllowInteractionViaRemoteEntry",
                name_hash: 1767691528,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InteractionEntityData, allow_interaction_via_remote_entry),
            },
            FieldInfoData {
                name: "DisplayWithinRadius",
                name_hash: 4049681154,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InteractionEntityData, display_within_radius),
            },
            FieldInfoData {
                name: "UseDisplayWithinRadius",
                name_hash: 1343244385,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InteractionEntityData, use_display_within_radius),
            },
            FieldInfoData {
                name: "PreInteractionSoundEffect",
                name_hash: 3692764940,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(InteractionEntityData, pre_interaction_sound_effect),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InteractionEntityData, enabled),
            },
        ],
    }),
    array_type: Some(INTERACTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for InteractionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTERACTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTERACTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InteractionEntityData-Array",
    name_hash: 2381104960,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InteractionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PredestructionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub radius: f32,
    pub enabled: bool,
}

pub trait PredestructionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl PredestructionEntityDataTrait for PredestructionEntityData {
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for PredestructionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PredestructionEntityData {
}

impl super::entity::GameObjectDataTrait for PredestructionEntityData {
}

impl super::core::DataBusPeerTrait for PredestructionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PredestructionEntityData {
}

impl super::core::DataContainerTrait for PredestructionEntityData {
}

pub static PREDESTRUCTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PredestructionEntityData",
    name_hash: 542147607,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PredestructionEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PredestructionEntityData as Default>::default())),
            create_boxed: || Box::new(<PredestructionEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PredestructionEntityData, radius),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PredestructionEntityData, enabled),
            },
        ],
    }),
    array_type: Some(PREDESTRUCTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PredestructionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PREDESTRUCTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PREDESTRUCTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PredestructionEntityData-Array",
    name_hash: 3474451619,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PredestructionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ExplosionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub detonation_effect: Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>,
    pub detonation_effect_for_friendlies: Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>,
    pub no_friendlies_effect_on_enabled_friendly_fire: bool,
    pub use_entity_transform_for_detonation_effect: bool,
    pub material_pair: super::entity::MaterialDecl,
    pub secondary_materials_active: bool,
    pub secondary_material_pair: super::entity::MaterialDecl,
    pub damage_indication_type: DamageIndicationType,
    pub emp_time: f32,
    pub max_occlusion_raycast_radius: f32,
    pub inner_blast_radius: f32,
    pub blast_damage: f32,
    pub blast_radius: f32,
    pub blast_impulse: f32,
    pub has_stun_effect: bool,
    pub shockwave_damage: f32,
    pub shockwave_radius: f32,
    pub shockwave_impulse: f32,
    pub allow_damage_to_owner: bool,
    pub shockwave_time: f32,
    pub apply_blast_damage_to_vehicles_and_characters_instantly: bool,
    pub force_serverside_ai_damage: bool,
    pub disable_occlusion: bool,
    pub disable_static_entity_occlusion: bool,
    pub disable_occlusion_outside_blast_radius: bool,
    pub camera_shockwave_radius: f32,
    pub spawn_delay: f32,
    pub trigger_impaired_hearing: bool,
    pub shockwave_wind_force: Option<LockedTypeObject /* ExplosionWindForceData */>,
    pub enabled: bool,
}

pub trait ExplosionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn detonation_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn detonation_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn detonation_effect_for_friendlies(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn detonation_effect_for_friendlies_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn no_friendlies_effect_on_enabled_friendly_fire(&self) -> &bool;
    fn no_friendlies_effect_on_enabled_friendly_fire_mut(&mut self) -> &mut bool;
    fn use_entity_transform_for_detonation_effect(&self) -> &bool;
    fn use_entity_transform_for_detonation_effect_mut(&mut self) -> &mut bool;
    fn material_pair(&self) -> &super::entity::MaterialDecl;
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn secondary_materials_active(&self) -> &bool;
    fn secondary_materials_active_mut(&mut self) -> &mut bool;
    fn secondary_material_pair(&self) -> &super::entity::MaterialDecl;
    fn secondary_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn damage_indication_type(&self) -> &DamageIndicationType;
    fn damage_indication_type_mut(&mut self) -> &mut DamageIndicationType;
    fn emp_time(&self) -> &f32;
    fn emp_time_mut(&mut self) -> &mut f32;
    fn max_occlusion_raycast_radius(&self) -> &f32;
    fn max_occlusion_raycast_radius_mut(&mut self) -> &mut f32;
    fn inner_blast_radius(&self) -> &f32;
    fn inner_blast_radius_mut(&mut self) -> &mut f32;
    fn blast_damage(&self) -> &f32;
    fn blast_damage_mut(&mut self) -> &mut f32;
    fn blast_radius(&self) -> &f32;
    fn blast_radius_mut(&mut self) -> &mut f32;
    fn blast_impulse(&self) -> &f32;
    fn blast_impulse_mut(&mut self) -> &mut f32;
    fn has_stun_effect(&self) -> &bool;
    fn has_stun_effect_mut(&mut self) -> &mut bool;
    fn shockwave_damage(&self) -> &f32;
    fn shockwave_damage_mut(&mut self) -> &mut f32;
    fn shockwave_radius(&self) -> &f32;
    fn shockwave_radius_mut(&mut self) -> &mut f32;
    fn shockwave_impulse(&self) -> &f32;
    fn shockwave_impulse_mut(&mut self) -> &mut f32;
    fn allow_damage_to_owner(&self) -> &bool;
    fn allow_damage_to_owner_mut(&mut self) -> &mut bool;
    fn shockwave_time(&self) -> &f32;
    fn shockwave_time_mut(&mut self) -> &mut f32;
    fn apply_blast_damage_to_vehicles_and_characters_instantly(&self) -> &bool;
    fn apply_blast_damage_to_vehicles_and_characters_instantly_mut(&mut self) -> &mut bool;
    fn force_serverside_ai_damage(&self) -> &bool;
    fn force_serverside_ai_damage_mut(&mut self) -> &mut bool;
    fn disable_occlusion(&self) -> &bool;
    fn disable_occlusion_mut(&mut self) -> &mut bool;
    fn disable_static_entity_occlusion(&self) -> &bool;
    fn disable_static_entity_occlusion_mut(&mut self) -> &mut bool;
    fn disable_occlusion_outside_blast_radius(&self) -> &bool;
    fn disable_occlusion_outside_blast_radius_mut(&mut self) -> &mut bool;
    fn camera_shockwave_radius(&self) -> &f32;
    fn camera_shockwave_radius_mut(&mut self) -> &mut f32;
    fn spawn_delay(&self) -> &f32;
    fn spawn_delay_mut(&mut self) -> &mut f32;
    fn trigger_impaired_hearing(&self) -> &bool;
    fn trigger_impaired_hearing_mut(&mut self) -> &mut bool;
    fn shockwave_wind_force(&self) -> &Option<LockedTypeObject /* ExplosionWindForceData */>;
    fn shockwave_wind_force_mut(&mut self) -> &mut Option<LockedTypeObject /* ExplosionWindForceData */>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl ExplosionEntityDataTrait for ExplosionEntityData {
    fn detonation_effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &self.detonation_effect
    }
    fn detonation_effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &mut self.detonation_effect
    }
    fn detonation_effect_for_friendlies(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &self.detonation_effect_for_friendlies
    }
    fn detonation_effect_for_friendlies_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &mut self.detonation_effect_for_friendlies
    }
    fn no_friendlies_effect_on_enabled_friendly_fire(&self) -> &bool {
        &self.no_friendlies_effect_on_enabled_friendly_fire
    }
    fn no_friendlies_effect_on_enabled_friendly_fire_mut(&mut self) -> &mut bool {
        &mut self.no_friendlies_effect_on_enabled_friendly_fire
    }
    fn use_entity_transform_for_detonation_effect(&self) -> &bool {
        &self.use_entity_transform_for_detonation_effect
    }
    fn use_entity_transform_for_detonation_effect_mut(&mut self) -> &mut bool {
        &mut self.use_entity_transform_for_detonation_effect
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        &self.material_pair
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material_pair
    }
    fn secondary_materials_active(&self) -> &bool {
        &self.secondary_materials_active
    }
    fn secondary_materials_active_mut(&mut self) -> &mut bool {
        &mut self.secondary_materials_active
    }
    fn secondary_material_pair(&self) -> &super::entity::MaterialDecl {
        &self.secondary_material_pair
    }
    fn secondary_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.secondary_material_pair
    }
    fn damage_indication_type(&self) -> &DamageIndicationType {
        &self.damage_indication_type
    }
    fn damage_indication_type_mut(&mut self) -> &mut DamageIndicationType {
        &mut self.damage_indication_type
    }
    fn emp_time(&self) -> &f32 {
        &self.emp_time
    }
    fn emp_time_mut(&mut self) -> &mut f32 {
        &mut self.emp_time
    }
    fn max_occlusion_raycast_radius(&self) -> &f32 {
        &self.max_occlusion_raycast_radius
    }
    fn max_occlusion_raycast_radius_mut(&mut self) -> &mut f32 {
        &mut self.max_occlusion_raycast_radius
    }
    fn inner_blast_radius(&self) -> &f32 {
        &self.inner_blast_radius
    }
    fn inner_blast_radius_mut(&mut self) -> &mut f32 {
        &mut self.inner_blast_radius
    }
    fn blast_damage(&self) -> &f32 {
        &self.blast_damage
    }
    fn blast_damage_mut(&mut self) -> &mut f32 {
        &mut self.blast_damage
    }
    fn blast_radius(&self) -> &f32 {
        &self.blast_radius
    }
    fn blast_radius_mut(&mut self) -> &mut f32 {
        &mut self.blast_radius
    }
    fn blast_impulse(&self) -> &f32 {
        &self.blast_impulse
    }
    fn blast_impulse_mut(&mut self) -> &mut f32 {
        &mut self.blast_impulse
    }
    fn has_stun_effect(&self) -> &bool {
        &self.has_stun_effect
    }
    fn has_stun_effect_mut(&mut self) -> &mut bool {
        &mut self.has_stun_effect
    }
    fn shockwave_damage(&self) -> &f32 {
        &self.shockwave_damage
    }
    fn shockwave_damage_mut(&mut self) -> &mut f32 {
        &mut self.shockwave_damage
    }
    fn shockwave_radius(&self) -> &f32 {
        &self.shockwave_radius
    }
    fn shockwave_radius_mut(&mut self) -> &mut f32 {
        &mut self.shockwave_radius
    }
    fn shockwave_impulse(&self) -> &f32 {
        &self.shockwave_impulse
    }
    fn shockwave_impulse_mut(&mut self) -> &mut f32 {
        &mut self.shockwave_impulse
    }
    fn allow_damage_to_owner(&self) -> &bool {
        &self.allow_damage_to_owner
    }
    fn allow_damage_to_owner_mut(&mut self) -> &mut bool {
        &mut self.allow_damage_to_owner
    }
    fn shockwave_time(&self) -> &f32 {
        &self.shockwave_time
    }
    fn shockwave_time_mut(&mut self) -> &mut f32 {
        &mut self.shockwave_time
    }
    fn apply_blast_damage_to_vehicles_and_characters_instantly(&self) -> &bool {
        &self.apply_blast_damage_to_vehicles_and_characters_instantly
    }
    fn apply_blast_damage_to_vehicles_and_characters_instantly_mut(&mut self) -> &mut bool {
        &mut self.apply_blast_damage_to_vehicles_and_characters_instantly
    }
    fn force_serverside_ai_damage(&self) -> &bool {
        &self.force_serverside_ai_damage
    }
    fn force_serverside_ai_damage_mut(&mut self) -> &mut bool {
        &mut self.force_serverside_ai_damage
    }
    fn disable_occlusion(&self) -> &bool {
        &self.disable_occlusion
    }
    fn disable_occlusion_mut(&mut self) -> &mut bool {
        &mut self.disable_occlusion
    }
    fn disable_static_entity_occlusion(&self) -> &bool {
        &self.disable_static_entity_occlusion
    }
    fn disable_static_entity_occlusion_mut(&mut self) -> &mut bool {
        &mut self.disable_static_entity_occlusion
    }
    fn disable_occlusion_outside_blast_radius(&self) -> &bool {
        &self.disable_occlusion_outside_blast_radius
    }
    fn disable_occlusion_outside_blast_radius_mut(&mut self) -> &mut bool {
        &mut self.disable_occlusion_outside_blast_radius
    }
    fn camera_shockwave_radius(&self) -> &f32 {
        &self.camera_shockwave_radius
    }
    fn camera_shockwave_radius_mut(&mut self) -> &mut f32 {
        &mut self.camera_shockwave_radius
    }
    fn spawn_delay(&self) -> &f32 {
        &self.spawn_delay
    }
    fn spawn_delay_mut(&mut self) -> &mut f32 {
        &mut self.spawn_delay
    }
    fn trigger_impaired_hearing(&self) -> &bool {
        &self.trigger_impaired_hearing
    }
    fn trigger_impaired_hearing_mut(&mut self) -> &mut bool {
        &mut self.trigger_impaired_hearing
    }
    fn shockwave_wind_force(&self) -> &Option<LockedTypeObject /* ExplosionWindForceData */> {
        &self.shockwave_wind_force
    }
    fn shockwave_wind_force_mut(&mut self) -> &mut Option<LockedTypeObject /* ExplosionWindForceData */> {
        &mut self.shockwave_wind_force
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for ExplosionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for ExplosionEntityData {
}

impl super::entity::GameObjectDataTrait for ExplosionEntityData {
}

impl super::core::DataBusPeerTrait for ExplosionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ExplosionEntityData {
}

impl super::core::DataContainerTrait for ExplosionEntityData {
}

pub static EXPLOSIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionEntityData",
    name_hash: 3500527003,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ExplosionEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionEntityData as Default>::default())),
            create_boxed: || Box::new(<ExplosionEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DetonationEffect",
                name_hash: 2442173307,
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(ExplosionEntityData, detonation_effect),
            },
            FieldInfoData {
                name: "DetonationEffectForFriendlies",
                name_hash: 2246110273,
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(ExplosionEntityData, detonation_effect_for_friendlies),
            },
            FieldInfoData {
                name: "NoFriendliesEffectOnEnabledFriendlyFire",
                name_hash: 108632649,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, no_friendlies_effect_on_enabled_friendly_fire),
            },
            FieldInfoData {
                name: "UseEntityTransformForDetonationEffect",
                name_hash: 28012372,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, use_entity_transform_for_detonation_effect),
            },
            FieldInfoData {
                name: "MaterialPair",
                name_hash: 161392100,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(ExplosionEntityData, material_pair),
            },
            FieldInfoData {
                name: "SecondaryMaterialsActive",
                name_hash: 3177856171,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, secondary_materials_active),
            },
            FieldInfoData {
                name: "SecondaryMaterialPair",
                name_hash: 1616965022,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(ExplosionEntityData, secondary_material_pair),
            },
            FieldInfoData {
                name: "DamageIndicationType",
                name_hash: 1466039938,
                flags: MemberInfoFlags::new(0),
                field_type: "DamageIndicationType",
                rust_offset: offset_of!(ExplosionEntityData, damage_indication_type),
            },
            FieldInfoData {
                name: "EmpTime",
                name_hash: 50680072,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, emp_time),
            },
            FieldInfoData {
                name: "MaxOcclusionRaycastRadius",
                name_hash: 3529203691,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, max_occlusion_raycast_radius),
            },
            FieldInfoData {
                name: "InnerBlastRadius",
                name_hash: 3210314251,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, inner_blast_radius),
            },
            FieldInfoData {
                name: "BlastDamage",
                name_hash: 2404506214,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, blast_damage),
            },
            FieldInfoData {
                name: "BlastRadius",
                name_hash: 3113578581,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, blast_radius),
            },
            FieldInfoData {
                name: "BlastImpulse",
                name_hash: 1357093398,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, blast_impulse),
            },
            FieldInfoData {
                name: "HasStunEffect",
                name_hash: 3580962068,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, has_stun_effect),
            },
            FieldInfoData {
                name: "ShockwaveDamage",
                name_hash: 1308225879,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_damage),
            },
            FieldInfoData {
                name: "ShockwaveRadius",
                name_hash: 764886628,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_radius),
            },
            FieldInfoData {
                name: "ShockwaveImpulse",
                name_hash: 2645636871,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_impulse),
            },
            FieldInfoData {
                name: "AllowDamageToOwner",
                name_hash: 273010765,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, allow_damage_to_owner),
            },
            FieldInfoData {
                name: "ShockwaveTime",
                name_hash: 2690395625,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_time),
            },
            FieldInfoData {
                name: "ApplyBlastDamageToVehiclesAndCharactersInstantly",
                name_hash: 1837850029,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, apply_blast_damage_to_vehicles_and_characters_instantly),
            },
            FieldInfoData {
                name: "ForceServersideAiDamage",
                name_hash: 3207978501,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, force_serverside_ai_damage),
            },
            FieldInfoData {
                name: "DisableOcclusion",
                name_hash: 4105695996,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, disable_occlusion),
            },
            FieldInfoData {
                name: "DisableStaticEntityOcclusion",
                name_hash: 1182367647,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, disable_static_entity_occlusion),
            },
            FieldInfoData {
                name: "DisableOcclusionOutsideBlastRadius",
                name_hash: 3764181369,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, disable_occlusion_outside_blast_radius),
            },
            FieldInfoData {
                name: "CameraShockwaveRadius",
                name_hash: 1681428477,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, camera_shockwave_radius),
            },
            FieldInfoData {
                name: "SpawnDelay",
                name_hash: 3473198411,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, spawn_delay),
            },
            FieldInfoData {
                name: "TriggerImpairedHearing",
                name_hash: 3966072268,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, trigger_impaired_hearing),
            },
            FieldInfoData {
                name: "ShockwaveWindForce",
                name_hash: 4011825653,
                flags: MemberInfoFlags::new(0),
                field_type: "ExplosionWindForceData",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_wind_force),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, enabled),
            },
        ],
    }),
    array_type: Some(EXPLOSIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ExplosionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionEntityData-Array",
    name_hash: 2766013487,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ExplosionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ExplosionWindForceData {
    pub _glacier_base: super::core::DataContainer,
    pub strength: f32,
    pub variation: f32,
    pub variation_rate: f32,
    pub micro_variation: f32,
    pub hardness: f32,
    pub force_as_instant_velocity: f32,
    pub should_affect_vegetation: bool,
    pub should_affect_mesh_scattering: bool,
    pub should_affect_effects: bool,
    pub should_affect_cloth: bool,
    pub should_affect_physics: bool,
}

pub trait ExplosionWindForceDataTrait: super::core::DataContainerTrait {
    fn strength(&self) -> &f32;
    fn strength_mut(&mut self) -> &mut f32;
    fn variation(&self) -> &f32;
    fn variation_mut(&mut self) -> &mut f32;
    fn variation_rate(&self) -> &f32;
    fn variation_rate_mut(&mut self) -> &mut f32;
    fn micro_variation(&self) -> &f32;
    fn micro_variation_mut(&mut self) -> &mut f32;
    fn hardness(&self) -> &f32;
    fn hardness_mut(&mut self) -> &mut f32;
    fn force_as_instant_velocity(&self) -> &f32;
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32;
    fn should_affect_vegetation(&self) -> &bool;
    fn should_affect_vegetation_mut(&mut self) -> &mut bool;
    fn should_affect_mesh_scattering(&self) -> &bool;
    fn should_affect_mesh_scattering_mut(&mut self) -> &mut bool;
    fn should_affect_effects(&self) -> &bool;
    fn should_affect_effects_mut(&mut self) -> &mut bool;
    fn should_affect_cloth(&self) -> &bool;
    fn should_affect_cloth_mut(&mut self) -> &mut bool;
    fn should_affect_physics(&self) -> &bool;
    fn should_affect_physics_mut(&mut self) -> &mut bool;
}

impl ExplosionWindForceDataTrait for ExplosionWindForceData {
    fn strength(&self) -> &f32 {
        &self.strength
    }
    fn strength_mut(&mut self) -> &mut f32 {
        &mut self.strength
    }
    fn variation(&self) -> &f32 {
        &self.variation
    }
    fn variation_mut(&mut self) -> &mut f32 {
        &mut self.variation
    }
    fn variation_rate(&self) -> &f32 {
        &self.variation_rate
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        &mut self.variation_rate
    }
    fn micro_variation(&self) -> &f32 {
        &self.micro_variation
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        &mut self.micro_variation
    }
    fn hardness(&self) -> &f32 {
        &self.hardness
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        &mut self.hardness
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        &self.force_as_instant_velocity
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        &mut self.force_as_instant_velocity
    }
    fn should_affect_vegetation(&self) -> &bool {
        &self.should_affect_vegetation
    }
    fn should_affect_vegetation_mut(&mut self) -> &mut bool {
        &mut self.should_affect_vegetation
    }
    fn should_affect_mesh_scattering(&self) -> &bool {
        &self.should_affect_mesh_scattering
    }
    fn should_affect_mesh_scattering_mut(&mut self) -> &mut bool {
        &mut self.should_affect_mesh_scattering
    }
    fn should_affect_effects(&self) -> &bool {
        &self.should_affect_effects
    }
    fn should_affect_effects_mut(&mut self) -> &mut bool {
        &mut self.should_affect_effects
    }
    fn should_affect_cloth(&self) -> &bool {
        &self.should_affect_cloth
    }
    fn should_affect_cloth_mut(&mut self) -> &mut bool {
        &mut self.should_affect_cloth
    }
    fn should_affect_physics(&self) -> &bool {
        &self.should_affect_physics
    }
    fn should_affect_physics_mut(&mut self) -> &mut bool {
        &mut self.should_affect_physics
    }
}

impl super::core::DataContainerTrait for ExplosionWindForceData {
}

pub static EXPLOSIONWINDFORCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionWindForceData",
    name_hash: 2218103113,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(ExplosionWindForceData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionWindForceData as Default>::default())),
            create_boxed: || Box::new(<ExplosionWindForceData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Strength",
                name_hash: 3531643328,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, strength),
            },
            FieldInfoData {
                name: "Variation",
                name_hash: 2945980116,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, variation),
            },
            FieldInfoData {
                name: "VariationRate",
                name_hash: 1485055286,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, variation_rate),
            },
            FieldInfoData {
                name: "MicroVariation",
                name_hash: 880089358,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, micro_variation),
            },
            FieldInfoData {
                name: "Hardness",
                name_hash: 3328149841,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, hardness),
            },
            FieldInfoData {
                name: "ForceAsInstantVelocity",
                name_hash: 381884134,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, force_as_instant_velocity),
            },
            FieldInfoData {
                name: "ShouldAffectVegetation",
                name_hash: 4261277287,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_vegetation),
            },
            FieldInfoData {
                name: "ShouldAffectMeshScattering",
                name_hash: 1198814282,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_mesh_scattering),
            },
            FieldInfoData {
                name: "ShouldAffectEffects",
                name_hash: 3510082395,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_effects),
            },
            FieldInfoData {
                name: "ShouldAffectCloth",
                name_hash: 542006179,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_cloth),
            },
            FieldInfoData {
                name: "ShouldAffectPhysics",
                name_hash: 593997428,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_physics),
            },
        ],
    }),
    array_type: Some(EXPLOSIONWINDFORCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplosionWindForceData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONWINDFORCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONWINDFORCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionWindForceData-Array",
    name_hash: 1829918589,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ExplosionWindForceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DamageIndicationType {
    #[default]
    DamageIndicationType_GiverPlayer = 0,
    DamageIndicationType_ExplosionCenter = 1,
}

pub static DAMAGEINDICATIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageIndicationType",
    name_hash: 1466039938,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DAMAGEINDICATIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DamageIndicationType {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEINDICATIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DAMAGEINDICATIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageIndicationType-Array",
    name_hash: 1607581110,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DamageIndicationType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DynamicGamePhysicsEntityData {
    pub _glacier_base: super::physics::GamePhysicsEntityData,
}

pub trait DynamicGamePhysicsEntityDataTrait: super::physics::GamePhysicsEntityDataTrait {
}

impl DynamicGamePhysicsEntityDataTrait for DynamicGamePhysicsEntityData {
}

impl super::physics::GamePhysicsEntityDataTrait for DynamicGamePhysicsEntityData {
}

impl super::entity::GameComponentEntityDataTrait for DynamicGamePhysicsEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for DynamicGamePhysicsEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DynamicGamePhysicsEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DynamicGamePhysicsEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicGamePhysicsEntityData {
}

impl super::core::DataBusPeerTrait for DynamicGamePhysicsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicGamePhysicsEntityData {
}

impl super::core::DataContainerTrait for DynamicGamePhysicsEntityData {
}

pub static DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicGamePhysicsEntityData",
    name_hash: 1391212382,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::GAMEPHYSICSENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DynamicGamePhysicsEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicGamePhysicsEntityData as Default>::default())),
            create_boxed: || Box::new(<DynamicGamePhysicsEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(DYNAMICGAMEPHYSICSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicGamePhysicsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICGAMEPHYSICSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicGamePhysicsEntityData-Array",
    name_hash: 276142314,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicGamePhysicsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VoiceOverAnimationComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait VoiceOverAnimationComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl VoiceOverAnimationComponentDataTrait for VoiceOverAnimationComponentData {
}

impl super::entity::GameComponentDataTrait for VoiceOverAnimationComponentData {
}

impl super::entity::ComponentDataTrait for VoiceOverAnimationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VoiceOverAnimationComponentData {
}

impl super::core::DataBusPeerTrait for VoiceOverAnimationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverAnimationComponentData {
}

impl super::core::DataContainerTrait for VoiceOverAnimationComponentData {
}

pub static VOICEOVERANIMATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverAnimationComponentData",
    name_hash: 2796985620,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VoiceOverAnimationComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverAnimationComponentData as Default>::default())),
            create_boxed: || Box::new(<VoiceOverAnimationComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverAnimationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERANIMATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverAnimationComponentData-Array",
    name_hash: 602503456,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverAnimationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VoiceOverManagerControlEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait VoiceOverManagerControlEntityDataTrait: super::entity::EntityDataTrait {
}

impl VoiceOverManagerControlEntityDataTrait for VoiceOverManagerControlEntityData {
}

impl super::entity::EntityDataTrait for VoiceOverManagerControlEntityData {
}

impl super::entity::GameObjectDataTrait for VoiceOverManagerControlEntityData {
}

impl super::core::DataBusPeerTrait for VoiceOverManagerControlEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverManagerControlEntityData {
}

impl super::core::DataContainerTrait for VoiceOverManagerControlEntityData {
}

pub static VOICEOVERMANAGERCONTROLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManagerControlEntityData",
    name_hash: 2292780834,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(VoiceOverManagerControlEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverManagerControlEntityData as Default>::default())),
            create_boxed: || Box::new(<VoiceOverManagerControlEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERMANAGERCONTROLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverManagerControlEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERMANAGERCONTROLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERMANAGERCONTROLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManagerControlEntityData-Array",
    name_hash: 1584319894,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverManagerControlEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DetachedSoundListenerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub fov: f32,
    pub radius: f32,
    pub transform: super::core::LinearTransform,
    pub velocity: super::core::Vec3,
    pub panning_position: super::core::Vec3,
}

pub trait DetachedSoundListenerEntityDataTrait: super::entity::EntityDataTrait {
    fn fov(&self) -> &f32;
    fn fov_mut(&mut self) -> &mut f32;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn velocity(&self) -> &super::core::Vec3;
    fn velocity_mut(&mut self) -> &mut super::core::Vec3;
    fn panning_position(&self) -> &super::core::Vec3;
    fn panning_position_mut(&mut self) -> &mut super::core::Vec3;
}

impl DetachedSoundListenerEntityDataTrait for DetachedSoundListenerEntityData {
    fn fov(&self) -> &f32 {
        &self.fov
    }
    fn fov_mut(&mut self) -> &mut f32 {
        &mut self.fov
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn velocity(&self) -> &super::core::Vec3 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.velocity
    }
    fn panning_position(&self) -> &super::core::Vec3 {
        &self.panning_position
    }
    fn panning_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.panning_position
    }
}

impl super::entity::EntityDataTrait for DetachedSoundListenerEntityData {
}

impl super::entity::GameObjectDataTrait for DetachedSoundListenerEntityData {
}

impl super::core::DataBusPeerTrait for DetachedSoundListenerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DetachedSoundListenerEntityData {
}

impl super::core::DataContainerTrait for DetachedSoundListenerEntityData {
}

pub static DETACHEDSOUNDLISTENERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetachedSoundListenerEntityData",
    name_hash: 3652870989,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DetachedSoundListenerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DetachedSoundListenerEntityData as Default>::default())),
            create_boxed: || Box::new(<DetachedSoundListenerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Fov",
                name_hash: 193443802,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, fov),
            },
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, radius),
            },
            FieldInfoData {
                name: "Transform",
                name_hash: 2270319721,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, transform),
            },
            FieldInfoData {
                name: "Velocity",
                name_hash: 3860766482,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, velocity),
            },
            FieldInfoData {
                name: "PanningPosition",
                name_hash: 2767888941,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, panning_position),
            },
        ],
    }),
    array_type: Some(DETACHEDSOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DetachedSoundListenerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DETACHEDSOUNDLISTENERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DETACHEDSOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetachedSoundListenerEntityData-Array",
    name_hash: 1017927545,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DetachedSoundListenerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SoundListenerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub local_player_id: super::core::LocalPlayerId,
    pub preserve_velocity: bool,
    pub fov: f32,
    pub radius: f32,
    pub transform: super::core::LinearTransform,
    pub velocity: super::core::Vec3,
    pub panning_position: super::core::Vec3,
}

pub trait SoundListenerEntityDataTrait: super::entity::EntityDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
    fn preserve_velocity(&self) -> &bool;
    fn preserve_velocity_mut(&mut self) -> &mut bool;
    fn fov(&self) -> &f32;
    fn fov_mut(&mut self) -> &mut f32;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn velocity(&self) -> &super::core::Vec3;
    fn velocity_mut(&mut self) -> &mut super::core::Vec3;
    fn panning_position(&self) -> &super::core::Vec3;
    fn panning_position_mut(&mut self) -> &mut super::core::Vec3;
}

impl SoundListenerEntityDataTrait for SoundListenerEntityData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
    fn preserve_velocity(&self) -> &bool {
        &self.preserve_velocity
    }
    fn preserve_velocity_mut(&mut self) -> &mut bool {
        &mut self.preserve_velocity
    }
    fn fov(&self) -> &f32 {
        &self.fov
    }
    fn fov_mut(&mut self) -> &mut f32 {
        &mut self.fov
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn velocity(&self) -> &super::core::Vec3 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.velocity
    }
    fn panning_position(&self) -> &super::core::Vec3 {
        &self.panning_position
    }
    fn panning_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.panning_position
    }
}

impl super::entity::EntityDataTrait for SoundListenerEntityData {
}

impl super::entity::GameObjectDataTrait for SoundListenerEntityData {
}

impl super::core::DataBusPeerTrait for SoundListenerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundListenerEntityData {
}

impl super::core::DataContainerTrait for SoundListenerEntityData {
}

pub static SOUNDLISTENERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundListenerEntityData",
    name_hash: 1029765683,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SoundListenerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundListenerEntityData as Default>::default())),
            create_boxed: || Box::new(<SoundListenerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(SoundListenerEntityData, local_player_id),
            },
            FieldInfoData {
                name: "PreserveVelocity",
                name_hash: 1729742114,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundListenerEntityData, preserve_velocity),
            },
            FieldInfoData {
                name: "Fov",
                name_hash: 193443802,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundListenerEntityData, fov),
            },
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundListenerEntityData, radius),
            },
            FieldInfoData {
                name: "Transform",
                name_hash: 2270319721,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SoundListenerEntityData, transform),
            },
            FieldInfoData {
                name: "Velocity",
                name_hash: 3860766482,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoundListenerEntityData, velocity),
            },
            FieldInfoData {
                name: "PanningPosition",
                name_hash: 2767888941,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoundListenerEntityData, panning_position),
            },
        ],
    }),
    array_type: Some(SOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoundListenerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDLISTENERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundListenerEntityData-Array",
    name_hash: 3667199367,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SoundListenerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SoundAreaEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub sound: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub big_world: Option<LockedTypeObject /* super::gameplay_sim::BigWorldSettingsAsset */>,
    pub perimeter_size: f32,
    pub relevance_multiplier: f32,
    pub min_relevance_budget: f32,
    pub relevance_falloff: super::audio::FadeCurveType,
    pub enable_on_creation: bool,
    pub priority: f32,
    pub use_legacy_behavior: bool,
    pub face_listener: bool,
    pub ignore_vertical_perimeter: bool,
}

pub trait SoundAreaEntityDataTrait: super::entity::EntityDataTrait {
    fn sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn big_world(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::BigWorldSettingsAsset */>;
    fn big_world_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::BigWorldSettingsAsset */>;
    fn perimeter_size(&self) -> &f32;
    fn perimeter_size_mut(&mut self) -> &mut f32;
    fn relevance_multiplier(&self) -> &f32;
    fn relevance_multiplier_mut(&mut self) -> &mut f32;
    fn min_relevance_budget(&self) -> &f32;
    fn min_relevance_budget_mut(&mut self) -> &mut f32;
    fn relevance_falloff(&self) -> &super::audio::FadeCurveType;
    fn relevance_falloff_mut(&mut self) -> &mut super::audio::FadeCurveType;
    fn enable_on_creation(&self) -> &bool;
    fn enable_on_creation_mut(&mut self) -> &mut bool;
    fn priority(&self) -> &f32;
    fn priority_mut(&mut self) -> &mut f32;
    fn use_legacy_behavior(&self) -> &bool;
    fn use_legacy_behavior_mut(&mut self) -> &mut bool;
    fn face_listener(&self) -> &bool;
    fn face_listener_mut(&mut self) -> &mut bool;
    fn ignore_vertical_perimeter(&self) -> &bool;
    fn ignore_vertical_perimeter_mut(&mut self) -> &mut bool;
}

impl SoundAreaEntityDataTrait for SoundAreaEntityData {
    fn sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.sound
    }
    fn big_world(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::BigWorldSettingsAsset */> {
        &self.big_world
    }
    fn big_world_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::BigWorldSettingsAsset */> {
        &mut self.big_world
    }
    fn perimeter_size(&self) -> &f32 {
        &self.perimeter_size
    }
    fn perimeter_size_mut(&mut self) -> &mut f32 {
        &mut self.perimeter_size
    }
    fn relevance_multiplier(&self) -> &f32 {
        &self.relevance_multiplier
    }
    fn relevance_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.relevance_multiplier
    }
    fn min_relevance_budget(&self) -> &f32 {
        &self.min_relevance_budget
    }
    fn min_relevance_budget_mut(&mut self) -> &mut f32 {
        &mut self.min_relevance_budget
    }
    fn relevance_falloff(&self) -> &super::audio::FadeCurveType {
        &self.relevance_falloff
    }
    fn relevance_falloff_mut(&mut self) -> &mut super::audio::FadeCurveType {
        &mut self.relevance_falloff
    }
    fn enable_on_creation(&self) -> &bool {
        &self.enable_on_creation
    }
    fn enable_on_creation_mut(&mut self) -> &mut bool {
        &mut self.enable_on_creation
    }
    fn priority(&self) -> &f32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut f32 {
        &mut self.priority
    }
    fn use_legacy_behavior(&self) -> &bool {
        &self.use_legacy_behavior
    }
    fn use_legacy_behavior_mut(&mut self) -> &mut bool {
        &mut self.use_legacy_behavior
    }
    fn face_listener(&self) -> &bool {
        &self.face_listener
    }
    fn face_listener_mut(&mut self) -> &mut bool {
        &mut self.face_listener
    }
    fn ignore_vertical_perimeter(&self) -> &bool {
        &self.ignore_vertical_perimeter
    }
    fn ignore_vertical_perimeter_mut(&mut self) -> &mut bool {
        &mut self.ignore_vertical_perimeter
    }
}

impl super::entity::EntityDataTrait for SoundAreaEntityData {
}

impl super::entity::GameObjectDataTrait for SoundAreaEntityData {
}

impl super::core::DataBusPeerTrait for SoundAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundAreaEntityData {
}

impl super::core::DataContainerTrait for SoundAreaEntityData {
}

pub static SOUNDAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundAreaEntityData",
    name_hash: 2457018394,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SoundAreaEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundAreaEntityData as Default>::default())),
            create_boxed: || Box::new(<SoundAreaEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Sound",
                name_hash: 231353798,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoundAreaEntityData, sound),
            },
            FieldInfoData {
                name: "BigWorld",
                name_hash: 4205700235,
                flags: MemberInfoFlags::new(0),
                field_type: "BigWorldSettingsAsset",
                rust_offset: offset_of!(SoundAreaEntityData, big_world),
            },
            FieldInfoData {
                name: "PerimeterSize",
                name_hash: 156564773,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundAreaEntityData, perimeter_size),
            },
            FieldInfoData {
                name: "RelevanceMultiplier",
                name_hash: 3495794351,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundAreaEntityData, relevance_multiplier),
            },
            FieldInfoData {
                name: "MinRelevanceBudget",
                name_hash: 4050735531,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundAreaEntityData, min_relevance_budget),
            },
            FieldInfoData {
                name: "RelevanceFalloff",
                name_hash: 1856356236,
                flags: MemberInfoFlags::new(0),
                field_type: "FadeCurveType",
                rust_offset: offset_of!(SoundAreaEntityData, relevance_falloff),
            },
            FieldInfoData {
                name: "EnableOnCreation",
                name_hash: 348824620,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundAreaEntityData, enable_on_creation),
            },
            FieldInfoData {
                name: "Priority",
                name_hash: 3062102871,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundAreaEntityData, priority),
            },
            FieldInfoData {
                name: "UseLegacyBehavior",
                name_hash: 4066039615,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundAreaEntityData, use_legacy_behavior),
            },
            FieldInfoData {
                name: "FaceListener",
                name_hash: 3563530970,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundAreaEntityData, face_listener),
            },
            FieldInfoData {
                name: "IgnoreVerticalPerimeter",
                name_hash: 2464526538,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundAreaEntityData, ignore_vertical_perimeter),
            },
        ],
    }),
    array_type: Some(SOUNDAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundAreaEntityData-Array",
    name_hash: 3030917934,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SoundAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VoiceOverConversationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub conversation: super::audio::VoiceOverConversationInfo,
    pub track_infos: Vec<BoxedTypeObject /* VoiceOverConversationEntityTrackInfo */>,
    pub trigger_delay: f32,
    pub finished_delay: f32,
    pub run_once: bool,
    pub needs_trigger_result: bool,
    pub pronunciation_index: i32,
    pub cancel_on_deinit: bool,
    pub referenced_wave_files: Vec<String>,
}

pub trait VoiceOverConversationEntityDataTrait: super::entity::EntityDataTrait {
    fn conversation(&self) -> &super::audio::VoiceOverConversationInfo;
    fn conversation_mut(&mut self) -> &mut super::audio::VoiceOverConversationInfo;
    fn track_infos(&self) -> &Vec<BoxedTypeObject /* VoiceOverConversationEntityTrackInfo */>;
    fn track_infos_mut(&mut self) -> &mut Vec<BoxedTypeObject /* VoiceOverConversationEntityTrackInfo */>;
    fn trigger_delay(&self) -> &f32;
    fn trigger_delay_mut(&mut self) -> &mut f32;
    fn finished_delay(&self) -> &f32;
    fn finished_delay_mut(&mut self) -> &mut f32;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn needs_trigger_result(&self) -> &bool;
    fn needs_trigger_result_mut(&mut self) -> &mut bool;
    fn pronunciation_index(&self) -> &i32;
    fn pronunciation_index_mut(&mut self) -> &mut i32;
    fn cancel_on_deinit(&self) -> &bool;
    fn cancel_on_deinit_mut(&mut self) -> &mut bool;
    fn referenced_wave_files(&self) -> &Vec<String>;
    fn referenced_wave_files_mut(&mut self) -> &mut Vec<String>;
}

impl VoiceOverConversationEntityDataTrait for VoiceOverConversationEntityData {
    fn conversation(&self) -> &super::audio::VoiceOverConversationInfo {
        &self.conversation
    }
    fn conversation_mut(&mut self) -> &mut super::audio::VoiceOverConversationInfo {
        &mut self.conversation
    }
    fn track_infos(&self) -> &Vec<BoxedTypeObject /* VoiceOverConversationEntityTrackInfo */> {
        &self.track_infos
    }
    fn track_infos_mut(&mut self) -> &mut Vec<BoxedTypeObject /* VoiceOverConversationEntityTrackInfo */> {
        &mut self.track_infos
    }
    fn trigger_delay(&self) -> &f32 {
        &self.trigger_delay
    }
    fn trigger_delay_mut(&mut self) -> &mut f32 {
        &mut self.trigger_delay
    }
    fn finished_delay(&self) -> &f32 {
        &self.finished_delay
    }
    fn finished_delay_mut(&mut self) -> &mut f32 {
        &mut self.finished_delay
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn needs_trigger_result(&self) -> &bool {
        &self.needs_trigger_result
    }
    fn needs_trigger_result_mut(&mut self) -> &mut bool {
        &mut self.needs_trigger_result
    }
    fn pronunciation_index(&self) -> &i32 {
        &self.pronunciation_index
    }
    fn pronunciation_index_mut(&mut self) -> &mut i32 {
        &mut self.pronunciation_index
    }
    fn cancel_on_deinit(&self) -> &bool {
        &self.cancel_on_deinit
    }
    fn cancel_on_deinit_mut(&mut self) -> &mut bool {
        &mut self.cancel_on_deinit
    }
    fn referenced_wave_files(&self) -> &Vec<String> {
        &self.referenced_wave_files
    }
    fn referenced_wave_files_mut(&mut self) -> &mut Vec<String> {
        &mut self.referenced_wave_files
    }
}

impl super::entity::EntityDataTrait for VoiceOverConversationEntityData {
}

impl super::entity::GameObjectDataTrait for VoiceOverConversationEntityData {
}

impl super::core::DataBusPeerTrait for VoiceOverConversationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverConversationEntityData {
}

impl super::core::DataContainerTrait for VoiceOverConversationEntityData {
}

pub static VOICEOVERCONVERSATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationEntityData",
    name_hash: 706964763,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(VoiceOverConversationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationEntityData as Default>::default())),
            create_boxed: || Box::new(<VoiceOverConversationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Conversation",
                name_hash: 292366248,
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationInfo",
                rust_offset: offset_of!(VoiceOverConversationEntityData, conversation),
            },
            FieldInfoData {
                name: "TrackInfos",
                name_hash: 2099249655,
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverConversationEntityTrackInfo-Array",
                rust_offset: offset_of!(VoiceOverConversationEntityData, track_infos),
            },
            FieldInfoData {
                name: "TriggerDelay",
                name_hash: 3587015816,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverConversationEntityData, trigger_delay),
            },
            FieldInfoData {
                name: "FinishedDelay",
                name_hash: 2930042562,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverConversationEntityData, finished_delay),
            },
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverConversationEntityData, run_once),
            },
            FieldInfoData {
                name: "NeedsTriggerResult",
                name_hash: 4258304973,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverConversationEntityData, needs_trigger_result),
            },
            FieldInfoData {
                name: "PronunciationIndex",
                name_hash: 3343344084,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VoiceOverConversationEntityData, pronunciation_index),
            },
            FieldInfoData {
                name: "CancelOnDeinit",
                name_hash: 3695563609,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverConversationEntityData, cancel_on_deinit),
            },
            FieldInfoData {
                name: "ReferencedWaveFiles",
                name_hash: 3820854970,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(VoiceOverConversationEntityData, referenced_wave_files),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONVERSATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationEntityData-Array",
    name_hash: 1358250927,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverConversationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VoiceOverConversationEntityTrackInfo {
    pub take_control_id: u32,
    pub source_id: u32,
}

pub trait VoiceOverConversationEntityTrackInfoTrait: TypeObject {
    fn take_control_id(&self) -> &u32;
    fn take_control_id_mut(&mut self) -> &mut u32;
    fn source_id(&self) -> &u32;
    fn source_id_mut(&mut self) -> &mut u32;
}

impl VoiceOverConversationEntityTrackInfoTrait for VoiceOverConversationEntityTrackInfo {
    fn take_control_id(&self) -> &u32 {
        &self.take_control_id
    }
    fn take_control_id_mut(&mut self) -> &mut u32 {
        &mut self.take_control_id
    }
    fn source_id(&self) -> &u32 {
        &self.source_id
    }
    fn source_id_mut(&mut self) -> &mut u32 {
        &mut self.source_id
    }
}

pub static VOICEOVERCONVERSATIONENTITYTRACKINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationEntityTrackInfo",
    name_hash: 107260778,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationEntityTrackInfo as Default>::default())),
            create_boxed: || Box::new(<VoiceOverConversationEntityTrackInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TakeControlId",
                name_hash: 248750612,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverConversationEntityTrackInfo, take_control_id),
            },
            FieldInfoData {
                name: "SourceId",
                name_hash: 3432638869,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverConversationEntityTrackInfo, source_id),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONENTITYTRACKINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VoiceOverConversationEntityTrackInfo {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONENTITYTRACKINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERCONVERSATIONENTITYTRACKINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationEntityTrackInfo-Array",
    name_hash: 4046304862,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverConversationEntityTrackInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VoiceOverEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub vo_event: Option<LockedTypeObject /* super::audio::VoiceOverEvent */>,
    pub event_player: Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */>,
    pub extra_event_player: Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */>,
    pub trigger_delay: f32,
    pub finished_delay: f32,
    pub run_once: bool,
    pub cancel_on_deinit: bool,
}

pub trait VoiceOverEventEntityDataTrait: super::entity::EntityDataTrait {
    fn vo_event(&self) -> &Option<LockedTypeObject /* super::audio::VoiceOverEvent */>;
    fn vo_event_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::VoiceOverEvent */>;
    fn event_player(&self) -> &Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */>;
    fn event_player_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */>;
    fn extra_event_player(&self) -> &Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */>;
    fn extra_event_player_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */>;
    fn trigger_delay(&self) -> &f32;
    fn trigger_delay_mut(&mut self) -> &mut f32;
    fn finished_delay(&self) -> &f32;
    fn finished_delay_mut(&mut self) -> &mut f32;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn cancel_on_deinit(&self) -> &bool;
    fn cancel_on_deinit_mut(&mut self) -> &mut bool;
}

impl VoiceOverEventEntityDataTrait for VoiceOverEventEntityData {
    fn vo_event(&self) -> &Option<LockedTypeObject /* super::audio::VoiceOverEvent */> {
        &self.vo_event
    }
    fn vo_event_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::VoiceOverEvent */> {
        &mut self.vo_event
    }
    fn event_player(&self) -> &Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */> {
        &self.event_player
    }
    fn event_player_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */> {
        &mut self.event_player
    }
    fn extra_event_player(&self) -> &Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */> {
        &self.extra_event_player
    }
    fn extra_event_player_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::VoiceOverNamedValue */> {
        &mut self.extra_event_player
    }
    fn trigger_delay(&self) -> &f32 {
        &self.trigger_delay
    }
    fn trigger_delay_mut(&mut self) -> &mut f32 {
        &mut self.trigger_delay
    }
    fn finished_delay(&self) -> &f32 {
        &self.finished_delay
    }
    fn finished_delay_mut(&mut self) -> &mut f32 {
        &mut self.finished_delay
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn cancel_on_deinit(&self) -> &bool {
        &self.cancel_on_deinit
    }
    fn cancel_on_deinit_mut(&mut self) -> &mut bool {
        &mut self.cancel_on_deinit
    }
}

impl super::entity::EntityDataTrait for VoiceOverEventEntityData {
}

impl super::entity::GameObjectDataTrait for VoiceOverEventEntityData {
}

impl super::core::DataBusPeerTrait for VoiceOverEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverEventEntityData {
}

impl super::core::DataContainerTrait for VoiceOverEventEntityData {
}

pub static VOICEOVEREVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventEntityData",
    name_hash: 4117183386,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(VoiceOverEventEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverEventEntityData as Default>::default())),
            create_boxed: || Box::new(<VoiceOverEventEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "VoEvent",
                name_hash: 1188417264,
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverEvent",
                rust_offset: offset_of!(VoiceOverEventEntityData, vo_event),
            },
            FieldInfoData {
                name: "EventPlayer",
                name_hash: 4041067226,
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverEventEntityData, event_player),
            },
            FieldInfoData {
                name: "ExtraEventPlayer",
                name_hash: 1270251872,
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverEventEntityData, extra_event_player),
            },
            FieldInfoData {
                name: "TriggerDelay",
                name_hash: 3587015816,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverEventEntityData, trigger_delay),
            },
            FieldInfoData {
                name: "FinishedDelay",
                name_hash: 2930042562,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverEventEntityData, finished_delay),
            },
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverEventEntityData, run_once),
            },
            FieldInfoData {
                name: "CancelOnDeinit",
                name_hash: 3695563609,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverEventEntityData, cancel_on_deinit),
            },
        ],
    }),
    array_type: Some(VOICEOVEREVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEREVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVEREVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventEntityData-Array",
    name_hash: 1612897966,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayAnimationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub animation: Option<LockedTypeObject /* PlayAnimationData */>,
    pub animation_blend_in_time: f32,
    pub animation_blend_out_time: f32,
    pub replicated: bool,
    pub trigger_if_culled: bool,
    pub external_time: f32,
    pub life_time: f32,
    pub entity_space0: super::core::LinearTransform,
    pub entity_space1: super::core::LinearTransform,
    pub entity_space2: super::core::LinearTransform,
    pub entity_space3: super::core::LinearTransform,
    pub entity_space4: super::core::LinearTransform,
    pub align_value: f32,
}

pub trait PlayAnimationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn animation(&self) -> &Option<LockedTypeObject /* PlayAnimationData */>;
    fn animation_mut(&mut self) -> &mut Option<LockedTypeObject /* PlayAnimationData */>;
    fn animation_blend_in_time(&self) -> &f32;
    fn animation_blend_in_time_mut(&mut self) -> &mut f32;
    fn animation_blend_out_time(&self) -> &f32;
    fn animation_blend_out_time_mut(&mut self) -> &mut f32;
    fn replicated(&self) -> &bool;
    fn replicated_mut(&mut self) -> &mut bool;
    fn trigger_if_culled(&self) -> &bool;
    fn trigger_if_culled_mut(&mut self) -> &mut bool;
    fn external_time(&self) -> &f32;
    fn external_time_mut(&mut self) -> &mut f32;
    fn life_time(&self) -> &f32;
    fn life_time_mut(&mut self) -> &mut f32;
    fn entity_space0(&self) -> &super::core::LinearTransform;
    fn entity_space0_mut(&mut self) -> &mut super::core::LinearTransform;
    fn entity_space1(&self) -> &super::core::LinearTransform;
    fn entity_space1_mut(&mut self) -> &mut super::core::LinearTransform;
    fn entity_space2(&self) -> &super::core::LinearTransform;
    fn entity_space2_mut(&mut self) -> &mut super::core::LinearTransform;
    fn entity_space3(&self) -> &super::core::LinearTransform;
    fn entity_space3_mut(&mut self) -> &mut super::core::LinearTransform;
    fn entity_space4(&self) -> &super::core::LinearTransform;
    fn entity_space4_mut(&mut self) -> &mut super::core::LinearTransform;
    fn align_value(&self) -> &f32;
    fn align_value_mut(&mut self) -> &mut f32;
}

impl PlayAnimationEntityDataTrait for PlayAnimationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn animation(&self) -> &Option<LockedTypeObject /* PlayAnimationData */> {
        &self.animation
    }
    fn animation_mut(&mut self) -> &mut Option<LockedTypeObject /* PlayAnimationData */> {
        &mut self.animation
    }
    fn animation_blend_in_time(&self) -> &f32 {
        &self.animation_blend_in_time
    }
    fn animation_blend_in_time_mut(&mut self) -> &mut f32 {
        &mut self.animation_blend_in_time
    }
    fn animation_blend_out_time(&self) -> &f32 {
        &self.animation_blend_out_time
    }
    fn animation_blend_out_time_mut(&mut self) -> &mut f32 {
        &mut self.animation_blend_out_time
    }
    fn replicated(&self) -> &bool {
        &self.replicated
    }
    fn replicated_mut(&mut self) -> &mut bool {
        &mut self.replicated
    }
    fn trigger_if_culled(&self) -> &bool {
        &self.trigger_if_culled
    }
    fn trigger_if_culled_mut(&mut self) -> &mut bool {
        &mut self.trigger_if_culled
    }
    fn external_time(&self) -> &f32 {
        &self.external_time
    }
    fn external_time_mut(&mut self) -> &mut f32 {
        &mut self.external_time
    }
    fn life_time(&self) -> &f32 {
        &self.life_time
    }
    fn life_time_mut(&mut self) -> &mut f32 {
        &mut self.life_time
    }
    fn entity_space0(&self) -> &super::core::LinearTransform {
        &self.entity_space0
    }
    fn entity_space0_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space0
    }
    fn entity_space1(&self) -> &super::core::LinearTransform {
        &self.entity_space1
    }
    fn entity_space1_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space1
    }
    fn entity_space2(&self) -> &super::core::LinearTransform {
        &self.entity_space2
    }
    fn entity_space2_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space2
    }
    fn entity_space3(&self) -> &super::core::LinearTransform {
        &self.entity_space3
    }
    fn entity_space3_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space3
    }
    fn entity_space4(&self) -> &super::core::LinearTransform {
        &self.entity_space4
    }
    fn entity_space4_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space4
    }
    fn align_value(&self) -> &f32 {
        &self.align_value
    }
    fn align_value_mut(&mut self) -> &mut f32 {
        &mut self.align_value
    }
}

impl super::entity::EntityDataTrait for PlayAnimationEntityData {
}

impl super::entity::GameObjectDataTrait for PlayAnimationEntityData {
}

impl super::core::DataBusPeerTrait for PlayAnimationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayAnimationEntityData {
}

impl super::core::DataContainerTrait for PlayAnimationEntityData {
}

pub static PLAYANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationEntityData",
    name_hash: 2492935708,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlayAnimationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayAnimationEntityData as Default>::default())),
            create_boxed: || Box::new(<PlayAnimationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayAnimationEntityData, realm),
            },
            FieldInfoData {
                name: "Animation",
                name_hash: 3481138675,
                flags: MemberInfoFlags::new(0),
                field_type: "PlayAnimationData",
                rust_offset: offset_of!(PlayAnimationEntityData, animation),
            },
            FieldInfoData {
                name: "AnimationBlendInTime",
                name_hash: 2567538048,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, animation_blend_in_time),
            },
            FieldInfoData {
                name: "AnimationBlendOutTime",
                name_hash: 346011881,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, animation_blend_out_time),
            },
            FieldInfoData {
                name: "Replicated",
                name_hash: 1403935504,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayAnimationEntityData, replicated),
            },
            FieldInfoData {
                name: "TriggerIfCulled",
                name_hash: 2229653445,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayAnimationEntityData, trigger_if_culled),
            },
            FieldInfoData {
                name: "ExternalTime",
                name_hash: 2162678253,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, external_time),
            },
            FieldInfoData {
                name: "LifeTime",
                name_hash: 2449447350,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, life_time),
            },
            FieldInfoData {
                name: "EntitySpace0",
                name_hash: 1631614922,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space0),
            },
            FieldInfoData {
                name: "EntitySpace1",
                name_hash: 1631614923,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space1),
            },
            FieldInfoData {
                name: "EntitySpace2",
                name_hash: 1631614920,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space2),
            },
            FieldInfoData {
                name: "EntitySpace3",
                name_hash: 1631614921,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space3),
            },
            FieldInfoData {
                name: "EntitySpace4",
                name_hash: 1631614926,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space4),
            },
            FieldInfoData {
                name: "AlignValue",
                name_hash: 628339715,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, align_value),
            },
        ],
    }),
    array_type: Some(PLAYANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayAnimationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYANIMATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationEntityData-Array",
    name_hash: 4172424744,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayAnimationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ServerPlayAnimationStartedMessage {
}

pub trait ServerPlayAnimationStartedMessageTrait: TypeObject {
}

impl ServerPlayAnimationStartedMessageTrait for ServerPlayAnimationStartedMessage {
}

pub static SERVERPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerPlayAnimationStartedMessage",
    name_hash: 2996648088,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerPlayAnimationStartedMessage as Default>::default())),
            create_boxed: || Box::new(<ServerPlayAnimationStartedMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ServerPlayAnimationStartedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct ClientPlayAnimationStartedMessage {
}

pub trait ClientPlayAnimationStartedMessageTrait: TypeObject {
}

impl ClientPlayAnimationStartedMessageTrait for ClientPlayAnimationStartedMessage {
}

pub static CLIENTPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayAnimationStartedMessage",
    name_hash: 4173648452,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientPlayAnimationStartedMessage as Default>::default())),
            create_boxed: || Box::new(<ClientPlayAnimationStartedMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientPlayAnimationStartedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayAnimationData {
    pub _glacier_base: super::core::DataContainer,
    pub controller: super::ant::AntRef,
    pub looping: bool,
}

pub trait PlayAnimationDataTrait: super::core::DataContainerTrait {
    fn controller(&self) -> &super::ant::AntRef;
    fn controller_mut(&mut self) -> &mut super::ant::AntRef;
    fn looping(&self) -> &bool;
    fn looping_mut(&mut self) -> &mut bool;
}

impl PlayAnimationDataTrait for PlayAnimationData {
    fn controller(&self) -> &super::ant::AntRef {
        &self.controller
    }
    fn controller_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.controller
    }
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn looping_mut(&mut self) -> &mut bool {
        &mut self.looping
    }
}

impl super::core::DataContainerTrait for PlayAnimationData {
}

pub static PLAYANIMATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationData",
    name_hash: 527678087,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(PlayAnimationData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayAnimationData as Default>::default())),
            create_boxed: || Box::new(<PlayAnimationData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Controller",
                name_hash: 1870777401,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PlayAnimationData, controller),
            },
            FieldInfoData {
                name: "Looping",
                name_hash: 1366646169,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayAnimationData, looping),
            },
        ],
    }),
    array_type: Some(PLAYANIMATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayAnimationData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYANIMATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYANIMATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationData-Array",
    name_hash: 3537320755,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayAnimationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FbProxyControllerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub canned_anim_binding: FbProxyControllerEntityBinding,
    pub animation_entity_space_priority: i32,
    pub always_clear_entity_space_when_in_scenario: bool,
    pub pointer_game_state: super::ant::AntRef,
}

pub trait FbProxyControllerEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn canned_anim_binding(&self) -> &FbProxyControllerEntityBinding;
    fn canned_anim_binding_mut(&mut self) -> &mut FbProxyControllerEntityBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn always_clear_entity_space_when_in_scenario(&self) -> &bool;
    fn always_clear_entity_space_when_in_scenario_mut(&mut self) -> &mut bool;
    fn pointer_game_state(&self) -> &super::ant::AntRef;
    fn pointer_game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl FbProxyControllerEntityDataTrait for FbProxyControllerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn canned_anim_binding(&self) -> &FbProxyControllerEntityBinding {
        &self.canned_anim_binding
    }
    fn canned_anim_binding_mut(&mut self) -> &mut FbProxyControllerEntityBinding {
        &mut self.canned_anim_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn always_clear_entity_space_when_in_scenario(&self) -> &bool {
        &self.always_clear_entity_space_when_in_scenario
    }
    fn always_clear_entity_space_when_in_scenario_mut(&mut self) -> &mut bool {
        &mut self.always_clear_entity_space_when_in_scenario
    }
    fn pointer_game_state(&self) -> &super::ant::AntRef {
        &self.pointer_game_state
    }
    fn pointer_game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.pointer_game_state
    }
}

impl super::entity::EntityDataTrait for FbProxyControllerEntityData {
}

impl super::entity::GameObjectDataTrait for FbProxyControllerEntityData {
}

impl super::core::DataBusPeerTrait for FbProxyControllerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FbProxyControllerEntityData {
}

impl super::core::DataContainerTrait for FbProxyControllerEntityData {
}

pub static FBPROXYCONTROLLERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FbProxyControllerEntityData",
    name_hash: 1055087770,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FbProxyControllerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FbProxyControllerEntityData as Default>::default())),
            create_boxed: || Box::new(<FbProxyControllerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FbProxyControllerEntityData, realm),
            },
            FieldInfoData {
                name: "CannedAnimBinding",
                name_hash: 3536770252,
                flags: MemberInfoFlags::new(0),
                field_type: "FbProxyControllerEntityBinding",
                rust_offset: offset_of!(FbProxyControllerEntityData, canned_anim_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                name_hash: 4041607518,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FbProxyControllerEntityData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "AlwaysClearEntitySpaceWhenInScenario",
                name_hash: 4447823,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FbProxyControllerEntityData, always_clear_entity_space_when_in_scenario),
            },
            FieldInfoData {
                name: "PointerGameState",
                name_hash: 2478195143,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityData, pointer_game_state),
            },
        ],
    }),
    array_type: Some(FBPROXYCONTROLLERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FbProxyControllerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FBPROXYCONTROLLERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FBPROXYCONTROLLERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FbProxyControllerEntityData-Array",
    name_hash: 410238894,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FbProxyControllerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FbProxyControllerEntityBinding {
    pub trigger: super::ant::AntRef,
    pub stop: super::ant::AntRef,
    pub blend_in_time: super::ant::AntRef,
    pub blend_out_time: super::ant::AntRef,
}

pub trait FbProxyControllerEntityBindingTrait: TypeObject {
    fn trigger(&self) -> &super::ant::AntRef;
    fn trigger_mut(&mut self) -> &mut super::ant::AntRef;
    fn stop(&self) -> &super::ant::AntRef;
    fn stop_mut(&mut self) -> &mut super::ant::AntRef;
    fn blend_in_time(&self) -> &super::ant::AntRef;
    fn blend_in_time_mut(&mut self) -> &mut super::ant::AntRef;
    fn blend_out_time(&self) -> &super::ant::AntRef;
    fn blend_out_time_mut(&mut self) -> &mut super::ant::AntRef;
}

impl FbProxyControllerEntityBindingTrait for FbProxyControllerEntityBinding {
    fn trigger(&self) -> &super::ant::AntRef {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.trigger
    }
    fn stop(&self) -> &super::ant::AntRef {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.stop
    }
    fn blend_in_time(&self) -> &super::ant::AntRef {
        &self.blend_in_time
    }
    fn blend_in_time_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.blend_in_time
    }
    fn blend_out_time(&self) -> &super::ant::AntRef {
        &self.blend_out_time
    }
    fn blend_out_time_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.blend_out_time
    }
}

pub static FBPROXYCONTROLLERENTITYBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FbProxyControllerEntityBinding",
    name_hash: 1962457035,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FbProxyControllerEntityBinding as Default>::default())),
            create_boxed: || Box::new(<FbProxyControllerEntityBinding as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Trigger",
                name_hash: 2606354109,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityBinding, trigger),
            },
            FieldInfoData {
                name: "Stop",
                name_hash: 2089401213,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityBinding, stop),
            },
            FieldInfoData {
                name: "BlendInTime",
                name_hash: 3385711094,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityBinding, blend_in_time),
            },
            FieldInfoData {
                name: "BlendOutTime",
                name_hash: 2108146399,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityBinding, blend_out_time),
            },
        ],
    }),
    array_type: Some(FBPROXYCONTROLLERENTITYBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FbProxyControllerEntityBinding {
    fn type_info(&self) -> &'static TypeInfo {
        FBPROXYCONTROLLERENTITYBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FBPROXYCONTROLLERENTITYBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FbProxyControllerEntityBinding-Array",
    name_hash: 3756300031,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FbProxyControllerEntityBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FaceposerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub face_poser_library: super::ant::AntRef,
    pub set_face_poser_library_on_spawn: bool,
}

pub trait FaceposerEntityDataTrait: super::entity::EntityDataTrait {
    fn face_poser_library(&self) -> &super::ant::AntRef;
    fn face_poser_library_mut(&mut self) -> &mut super::ant::AntRef;
    fn set_face_poser_library_on_spawn(&self) -> &bool;
    fn set_face_poser_library_on_spawn_mut(&mut self) -> &mut bool;
}

impl FaceposerEntityDataTrait for FaceposerEntityData {
    fn face_poser_library(&self) -> &super::ant::AntRef {
        &self.face_poser_library
    }
    fn face_poser_library_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.face_poser_library
    }
    fn set_face_poser_library_on_spawn(&self) -> &bool {
        &self.set_face_poser_library_on_spawn
    }
    fn set_face_poser_library_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.set_face_poser_library_on_spawn
    }
}

impl super::entity::EntityDataTrait for FaceposerEntityData {
}

impl super::entity::GameObjectDataTrait for FaceposerEntityData {
}

impl super::core::DataBusPeerTrait for FaceposerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FaceposerEntityData {
}

impl super::core::DataContainerTrait for FaceposerEntityData {
}

pub static FACEPOSERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaceposerEntityData",
    name_hash: 1043233236,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FaceposerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FaceposerEntityData as Default>::default())),
            create_boxed: || Box::new(<FaceposerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FacePoserLibrary",
                name_hash: 2878950592,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FaceposerEntityData, face_poser_library),
            },
            FieldInfoData {
                name: "SetFacePoserLibraryOnSpawn",
                name_hash: 235198936,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FaceposerEntityData, set_face_poser_library_on_spawn),
            },
        ],
    }),
    array_type: Some(FACEPOSERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FaceposerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FACEPOSERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FACEPOSERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaceposerEntityData-Array",
    name_hash: 155706976,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FaceposerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EventSyncReachedClientMessage {
}

pub trait EventSyncReachedClientMessageTrait: TypeObject {
}

impl EventSyncReachedClientMessageTrait for EventSyncReachedClientMessage {
}

pub static EVENTSYNCREACHEDCLIENTMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSyncReachedClientMessage",
    name_hash: 1167035168,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSyncReachedClientMessage as Default>::default())),
            create_boxed: || Box::new(<EventSyncReachedClientMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for EventSyncReachedClientMessage {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSYNCREACHEDCLIENTMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct EventSyncEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait EventSyncEntityDataTrait: super::entity::EntityDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl EventSyncEntityDataTrait for EventSyncEntityData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for EventSyncEntityData {
}

impl super::entity::GameObjectDataTrait for EventSyncEntityData {
}

impl super::core::DataBusPeerTrait for EventSyncEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventSyncEntityData {
}

impl super::core::DataContainerTrait for EventSyncEntityData {
}

pub static EVENTSYNCENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSyncEntityData",
    name_hash: 843326469,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EventSyncEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSyncEntityData as Default>::default())),
            create_boxed: || Box::new(<EventSyncEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(EventSyncEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(EVENTSYNCENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSyncEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSYNCENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSYNCENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSyncEntityData-Array",
    name_hash: 1199066033,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventSyncEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterEntryComponentData {
    pub _glacier_base: GameEntryComponentData,
    pub aiming_constraints: super::gameplay_sim::AimingConstraintsData,
}

pub trait CharacterEntryComponentDataTrait: GameEntryComponentDataTrait {
    fn aiming_constraints(&self) -> &super::gameplay_sim::AimingConstraintsData;
    fn aiming_constraints_mut(&mut self) -> &mut super::gameplay_sim::AimingConstraintsData;
}

impl CharacterEntryComponentDataTrait for CharacterEntryComponentData {
    fn aiming_constraints(&self) -> &super::gameplay_sim::AimingConstraintsData {
        &self.aiming_constraints
    }
    fn aiming_constraints_mut(&mut self) -> &mut super::gameplay_sim::AimingConstraintsData {
        &mut self.aiming_constraints
    }
}

impl GameEntryComponentDataTrait for CharacterEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        self._glacier_base.lock_soldier_aiming_to_entry()
    }
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.lock_soldier_aiming_to_entry_mut()
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.soldier_offset()
    }
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.soldier_offset_mut()
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for CharacterEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn entry_class_mut(&mut self) -> &mut super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class_mut()
    }
    fn a_i_data(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::GameAIEntryData */> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::GameAIEntryData */> {
        self._glacier_base.a_i_data_mut()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn forbidden_for_human_mut(&mut self) -> &mut bool {
        self._glacier_base.forbidden_for_human_mut()
    }
    fn input_graph(&self) -> &Option<LockedTypeObject /* super::input_shared::InputGraph */> {
        self._glacier_base.input_graph()
    }
    fn input_graph_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputGraph */> {
        self._glacier_base.input_graph_mut()
    }
    fn input_concept_definition(&self) -> &Option<LockedTypeObject /* super::input_shared::InputActionMapsData */> {
        self._glacier_base.input_concept_definition()
    }
    fn input_concept_definition_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputActionMapsData */> {
        self._glacier_base.input_concept_definition_mut()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn action_map_settings_flip_y_scheme_override_mut(&mut self) -> &mut i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override_mut()
    }
    fn input_mapping(&self) -> &Option<LockedTypeObject /* super::input_shared::InputConceptToEntryInputActionMappings */> {
        self._glacier_base.input_mapping()
    }
    fn input_mapping_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputConceptToEntryInputActionMappings */> {
        self._glacier_base.input_mapping_mut()
    }
    fn input_curves(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::InputCurveData */>> {
        self._glacier_base.input_curves()
    }
    fn input_curves_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::InputCurveData */>> {
        self._glacier_base.input_curves_mut()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn hud_data_mut(&mut self) -> &mut super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data_mut()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn entry_order_number_mut(&mut self) -> &mut i32 {
        self._glacier_base.entry_order_number_mut()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn enter_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.enter_impulse_mut()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn entry_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.entry_radius_mut()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn is_allowed_to_exit_in_air_mut(&mut self) -> &mut bool {
        self._glacier_base.is_allowed_to_exit_in_air_mut()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn clear_path_to_exit_point_start_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset_mut()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn is_shielded_mut(&mut self) -> &mut bool {
        self._glacier_base.is_shielded_mut()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_in_entry_mut()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn show1p_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_mut()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn soldier_transition_invisble_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.soldier_transition_invisble_time_mut()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn entry_spotting_settings_mut(&mut self) -> &mut super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings_mut()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_weapon_in_entry_mut()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show1p_soldier_in_entry_for_player_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only_mut()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show3p_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show3p_soldier_weapon_in_entry_mut()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn show_soldier_gear_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_gear_in_entry_mut()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn pose_constraints_mut(&mut self) -> &mut super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints_mut()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn use_local_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_local_transform_mut()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn trigger_event_on_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.trigger_event_on_key_mut()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn allow_ragdoll_from_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_ragdoll_from_entry_mut()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
    fn camera_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.camera_index_mut()
    }
}

impl super::entity::GameComponentDataTrait for CharacterEntryComponentData {
}

impl super::entity::ComponentDataTrait for CharacterEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterEntryComponentData {
}

impl super::core::DataBusPeerTrait for CharacterEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterEntryComponentData {
}

impl super::core::DataContainerTrait for CharacterEntryComponentData {
}

pub static CHARACTERENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntryComponentData",
    name_hash: 2302775351,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEENTRYCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterEntryComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterEntryComponentData as Default>::default())),
            create_boxed: || Box::new(<CharacterEntryComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AimingConstraints",
                name_hash: 1523178198,
                flags: MemberInfoFlags::new(0),
                field_type: "AimingConstraintsData",
                rust_offset: offset_of!(CharacterEntryComponentData, aiming_constraints),
            },
        ],
    }),
    array_type: Some(CHARACTERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntryComponentData-Array",
    name_hash: 1330497923,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayerEntryComponentData {
    pub _glacier_base: GameEntryComponentData,
    pub ant_entry_i_d: String,
    pub ant_entry_id: AntEntryIdEnum,
    pub ant_entry_enumeration: Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */>,
    pub animation_acceleration_multiplier: super::core::Vec3,
}

pub trait PlayerEntryComponentDataTrait: GameEntryComponentDataTrait {
    fn ant_entry_i_d(&self) -> &String;
    fn ant_entry_i_d_mut(&mut self) -> &mut String;
    fn ant_entry_id(&self) -> &AntEntryIdEnum;
    fn ant_entry_id_mut(&mut self) -> &mut AntEntryIdEnum;
    fn ant_entry_enumeration(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */>;
    fn ant_entry_enumeration_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */>;
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3;
    fn animation_acceleration_multiplier_mut(&mut self) -> &mut super::core::Vec3;
}

impl PlayerEntryComponentDataTrait for PlayerEntryComponentData {
    fn ant_entry_i_d(&self) -> &String {
        &self.ant_entry_i_d
    }
    fn ant_entry_i_d_mut(&mut self) -> &mut String {
        &mut self.ant_entry_i_d
    }
    fn ant_entry_id(&self) -> &AntEntryIdEnum {
        &self.ant_entry_id
    }
    fn ant_entry_id_mut(&mut self) -> &mut AntEntryIdEnum {
        &mut self.ant_entry_id
    }
    fn ant_entry_enumeration(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */> {
        &self.ant_entry_enumeration
    }
    fn ant_entry_enumeration_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */> {
        &mut self.ant_entry_enumeration
    }
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3 {
        &self.animation_acceleration_multiplier
    }
    fn animation_acceleration_multiplier_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.animation_acceleration_multiplier
    }
}

impl GameEntryComponentDataTrait for PlayerEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        self._glacier_base.lock_soldier_aiming_to_entry()
    }
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.lock_soldier_aiming_to_entry_mut()
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.soldier_offset()
    }
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.soldier_offset_mut()
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for PlayerEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn entry_class_mut(&mut self) -> &mut super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class_mut()
    }
    fn a_i_data(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::GameAIEntryData */> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::GameAIEntryData */> {
        self._glacier_base.a_i_data_mut()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn forbidden_for_human_mut(&mut self) -> &mut bool {
        self._glacier_base.forbidden_for_human_mut()
    }
    fn input_graph(&self) -> &Option<LockedTypeObject /* super::input_shared::InputGraph */> {
        self._glacier_base.input_graph()
    }
    fn input_graph_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputGraph */> {
        self._glacier_base.input_graph_mut()
    }
    fn input_concept_definition(&self) -> &Option<LockedTypeObject /* super::input_shared::InputActionMapsData */> {
        self._glacier_base.input_concept_definition()
    }
    fn input_concept_definition_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputActionMapsData */> {
        self._glacier_base.input_concept_definition_mut()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn action_map_settings_flip_y_scheme_override_mut(&mut self) -> &mut i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override_mut()
    }
    fn input_mapping(&self) -> &Option<LockedTypeObject /* super::input_shared::InputConceptToEntryInputActionMappings */> {
        self._glacier_base.input_mapping()
    }
    fn input_mapping_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputConceptToEntryInputActionMappings */> {
        self._glacier_base.input_mapping_mut()
    }
    fn input_curves(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::InputCurveData */>> {
        self._glacier_base.input_curves()
    }
    fn input_curves_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::InputCurveData */>> {
        self._glacier_base.input_curves_mut()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn hud_data_mut(&mut self) -> &mut super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data_mut()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn entry_order_number_mut(&mut self) -> &mut i32 {
        self._glacier_base.entry_order_number_mut()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn enter_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.enter_impulse_mut()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn entry_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.entry_radius_mut()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn is_allowed_to_exit_in_air_mut(&mut self) -> &mut bool {
        self._glacier_base.is_allowed_to_exit_in_air_mut()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn clear_path_to_exit_point_start_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset_mut()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn is_shielded_mut(&mut self) -> &mut bool {
        self._glacier_base.is_shielded_mut()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_in_entry_mut()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn show1p_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_mut()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn soldier_transition_invisble_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.soldier_transition_invisble_time_mut()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn entry_spotting_settings_mut(&mut self) -> &mut super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings_mut()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_weapon_in_entry_mut()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show1p_soldier_in_entry_for_player_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only_mut()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show3p_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show3p_soldier_weapon_in_entry_mut()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn show_soldier_gear_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_gear_in_entry_mut()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn pose_constraints_mut(&mut self) -> &mut super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints_mut()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn use_local_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_local_transform_mut()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn trigger_event_on_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.trigger_event_on_key_mut()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn allow_ragdoll_from_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_ragdoll_from_entry_mut()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
    fn camera_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.camera_index_mut()
    }
}

impl super::entity::GameComponentDataTrait for PlayerEntryComponentData {
}

impl super::entity::ComponentDataTrait for PlayerEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for PlayerEntryComponentData {
}

impl super::core::DataBusPeerTrait for PlayerEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerEntryComponentData {
}

impl super::core::DataContainerTrait for PlayerEntryComponentData {
}

pub static PLAYERENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerEntryComponentData",
    name_hash: 1606794493,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEENTRYCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlayerEntryComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerEntryComponentData as Default>::default())),
            create_boxed: || Box::new(<PlayerEntryComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AntEntryID",
                name_hash: 3749795271,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PlayerEntryComponentData, ant_entry_i_d),
            },
            FieldInfoData {
                name: "AntEntryId",
                name_hash: 3749795303,
                flags: MemberInfoFlags::new(0),
                field_type: "AntEntryIdEnum",
                rust_offset: offset_of!(PlayerEntryComponentData, ant_entry_id),
            },
            FieldInfoData {
                name: "AntEntryEnumeration",
                name_hash: 1819698227,
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(PlayerEntryComponentData, ant_entry_enumeration),
            },
            FieldInfoData {
                name: "AnimationAccelerationMultiplier",
                name_hash: 893003770,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PlayerEntryComponentData, animation_acceleration_multiplier),
            },
        ],
    }),
    array_type: Some(PLAYERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerEntryComponentData-Array",
    name_hash: 1753721289,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameEntryComponentData {
    pub _glacier_base: super::gameplay_sim::EntryComponentData,
    pub lock_soldier_aiming_to_entry: bool,
    pub soldier_offset: super::core::Vec3,
}

pub trait GameEntryComponentDataTrait: super::gameplay_sim::EntryComponentDataTrait {
    fn lock_soldier_aiming_to_entry(&self) -> &bool;
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool;
    fn soldier_offset(&self) -> &super::core::Vec3;
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3;
}

impl GameEntryComponentDataTrait for GameEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        &self.lock_soldier_aiming_to_entry
    }
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool {
        &mut self.lock_soldier_aiming_to_entry
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        &self.soldier_offset
    }
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.soldier_offset
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for GameEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn entry_class_mut(&mut self) -> &mut super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class_mut()
    }
    fn a_i_data(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::GameAIEntryData */> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::GameAIEntryData */> {
        self._glacier_base.a_i_data_mut()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn forbidden_for_human_mut(&mut self) -> &mut bool {
        self._glacier_base.forbidden_for_human_mut()
    }
    fn input_graph(&self) -> &Option<LockedTypeObject /* super::input_shared::InputGraph */> {
        self._glacier_base.input_graph()
    }
    fn input_graph_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputGraph */> {
        self._glacier_base.input_graph_mut()
    }
    fn input_concept_definition(&self) -> &Option<LockedTypeObject /* super::input_shared::InputActionMapsData */> {
        self._glacier_base.input_concept_definition()
    }
    fn input_concept_definition_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputActionMapsData */> {
        self._glacier_base.input_concept_definition_mut()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn action_map_settings_flip_y_scheme_override_mut(&mut self) -> &mut i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override_mut()
    }
    fn input_mapping(&self) -> &Option<LockedTypeObject /* super::input_shared::InputConceptToEntryInputActionMappings */> {
        self._glacier_base.input_mapping()
    }
    fn input_mapping_mut(&mut self) -> &mut Option<LockedTypeObject /* super::input_shared::InputConceptToEntryInputActionMappings */> {
        self._glacier_base.input_mapping_mut()
    }
    fn input_curves(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::InputCurveData */>> {
        self._glacier_base.input_curves()
    }
    fn input_curves_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::InputCurveData */>> {
        self._glacier_base.input_curves_mut()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn hud_data_mut(&mut self) -> &mut super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data_mut()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn entry_order_number_mut(&mut self) -> &mut i32 {
        self._glacier_base.entry_order_number_mut()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn enter_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.enter_impulse_mut()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn entry_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.entry_radius_mut()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn is_allowed_to_exit_in_air_mut(&mut self) -> &mut bool {
        self._glacier_base.is_allowed_to_exit_in_air_mut()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn clear_path_to_exit_point_start_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset_mut()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn is_shielded_mut(&mut self) -> &mut bool {
        self._glacier_base.is_shielded_mut()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_in_entry_mut()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn show1p_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_mut()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn soldier_transition_invisble_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.soldier_transition_invisble_time_mut()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn entry_spotting_settings_mut(&mut self) -> &mut super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings_mut()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_weapon_in_entry_mut()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show1p_soldier_in_entry_for_player_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only_mut()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show3p_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show3p_soldier_weapon_in_entry_mut()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn show_soldier_gear_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_gear_in_entry_mut()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn pose_constraints_mut(&mut self) -> &mut super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints_mut()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn use_local_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_local_transform_mut()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn trigger_event_on_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.trigger_event_on_key_mut()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn allow_ragdoll_from_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_ragdoll_from_entry_mut()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
    fn camera_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.camera_index_mut()
    }
}

impl super::entity::GameComponentDataTrait for GameEntryComponentData {
}

impl super::entity::ComponentDataTrait for GameEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for GameEntryComponentData {
}

impl super::core::DataBusPeerTrait for GameEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameEntryComponentData {
}

impl super::core::DataContainerTrait for GameEntryComponentData {
}

pub static GAMEENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameEntryComponentData",
    name_hash: 3272871264,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::ENTRYCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(GameEntryComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameEntryComponentData as Default>::default())),
            create_boxed: || Box::new(<GameEntryComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LockSoldierAimingToEntry",
                name_hash: 506867918,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameEntryComponentData, lock_soldier_aiming_to_entry),
            },
            FieldInfoData {
                name: "SoldierOffset",
                name_hash: 1109239746,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(GameEntryComponentData, soldier_offset),
            },
        ],
    }),
    array_type: Some(GAMEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for GameEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameEntryComponentData-Array",
    name_hash: 607322964,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AntEntryIdEnum {
    #[default]
    AntEntryIdEnum_Humvee_Driver = 0,
    AntEntryIdEnum_Humvee_Gunner = 1,
    AntEntryIdEnum_Humvee_PassengerRearLeft = 2,
    AntEntryIdEnum_Humvee_PassengerRearRight = 3,
    AntEntryIdEnum_F16_Pilot = 4,
    AntEntryIdEnum_SU37_Pilot = 5,
    AntEntryIdEnum_AH6_Pilot = 6,
    AntEntryIdEnum_AH64_Pilot = 7,
    AntEntryIdEnum_AH64_Gunner = 8,
    AntEntryIdEnum_Vodnik_Driver = 9,
    AntEntryIdEnum_Vodnik_Gunner = 10,
    AntEntryIdEnum_Humvee_PassengerFrontRight = 11,
    AntEntryIdEnum_Vodnik_PassengerFrontRight = 12,
    AntEntryIdEnum_Vodnik_PassengerRearRight = 13,
    AntEntryIdEnum_Vodnik_PassengerRearLeft = 14,
    AntEntryIdEnum_VadsGunner = 15,
    AntEntryIdEnum_F18F_Pilot = 16,
    AntEntryIdEnum_F18F_Navigator = 17,
    AntEntryIdEnum_M1A2_Gunner = 18,
    AntEntryIdEnum_M1A2_Driver = 19,
}

pub static ANTENTRYIDENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEntryIdEnum",
    name_hash: 3394355988,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTENTRYIDENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntEntryIdEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ANTENTRYIDENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTENTRYIDENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEntryIdEnum-Array",
    name_hash: 1959337760,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntEntryIdEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntitlementQuery {
    pub _glacier_base: super::core::Asset,
    pub entitlements_data: Vec<BoxedTypeObject /* EntitlementData */>,
    pub group_names: Vec<String>,
    pub platform: super::core::GamePlatform,
    pub entitlement_tag: String,
    pub product_id: String,
    pub project_id: String,
}

pub trait EntitlementQueryTrait: super::core::AssetTrait {
    fn entitlements_data(&self) -> &Vec<BoxedTypeObject /* EntitlementData */>;
    fn entitlements_data_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EntitlementData */>;
    fn group_names(&self) -> &Vec<String>;
    fn group_names_mut(&mut self) -> &mut Vec<String>;
    fn platform(&self) -> &super::core::GamePlatform;
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform;
    fn entitlement_tag(&self) -> &String;
    fn entitlement_tag_mut(&mut self) -> &mut String;
    fn product_id(&self) -> &String;
    fn product_id_mut(&mut self) -> &mut String;
    fn project_id(&self) -> &String;
    fn project_id_mut(&mut self) -> &mut String;
}

impl EntitlementQueryTrait for EntitlementQuery {
    fn entitlements_data(&self) -> &Vec<BoxedTypeObject /* EntitlementData */> {
        &self.entitlements_data
    }
    fn entitlements_data_mut(&mut self) -> &mut Vec<BoxedTypeObject /* EntitlementData */> {
        &mut self.entitlements_data
    }
    fn group_names(&self) -> &Vec<String> {
        &self.group_names
    }
    fn group_names_mut(&mut self) -> &mut Vec<String> {
        &mut self.group_names
    }
    fn platform(&self) -> &super::core::GamePlatform {
        &self.platform
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        &mut self.platform
    }
    fn entitlement_tag(&self) -> &String {
        &self.entitlement_tag
    }
    fn entitlement_tag_mut(&mut self) -> &mut String {
        &mut self.entitlement_tag
    }
    fn product_id(&self) -> &String {
        &self.product_id
    }
    fn product_id_mut(&mut self) -> &mut String {
        &mut self.product_id
    }
    fn project_id(&self) -> &String {
        &self.project_id
    }
    fn project_id_mut(&mut self) -> &mut String {
        &mut self.project_id
    }
}

impl super::core::AssetTrait for EntitlementQuery {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for EntitlementQuery {
}

pub static ENTITLEMENTQUERY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementQuery",
    name_hash: 2459032534,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(EntitlementQuery, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntitlementQuery as Default>::default())),
            create_boxed: || Box::new(<EntitlementQuery as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EntitlementsData",
                name_hash: 2421825855,
                flags: MemberInfoFlags::new(144),
                field_type: "EntitlementData-Array",
                rust_offset: offset_of!(EntitlementQuery, entitlements_data),
            },
            FieldInfoData {
                name: "GroupNames",
                name_hash: 1803493518,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(EntitlementQuery, group_names),
            },
            FieldInfoData {
                name: "Platform",
                name_hash: 942751002,
                flags: MemberInfoFlags::new(0),
                field_type: "GamePlatform",
                rust_offset: offset_of!(EntitlementQuery, platform),
            },
            FieldInfoData {
                name: "EntitlementTag",
                name_hash: 1654763342,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementQuery, entitlement_tag),
            },
            FieldInfoData {
                name: "ProductId",
                name_hash: 106414083,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementQuery, product_id),
            },
            FieldInfoData {
                name: "ProjectId",
                name_hash: 4152360413,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementQuery, project_id),
            },
        ],
    }),
    array_type: Some(ENTITLEMENTQUERY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntitlementQuery {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITLEMENTQUERY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTITLEMENTQUERY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementQuery-Array",
    name_hash: 1097154914,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntitlementQuery"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntitlementData {
    pub license: String,
    pub entitlement_tag: String,
    pub group_name: String,
    pub product_id: String,
    pub project_id: String,
    pub verify_ownership: bool,
    pub usage_type: EntitlementType,
}

pub trait EntitlementDataTrait: TypeObject {
    fn license(&self) -> &String;
    fn license_mut(&mut self) -> &mut String;
    fn entitlement_tag(&self) -> &String;
    fn entitlement_tag_mut(&mut self) -> &mut String;
    fn group_name(&self) -> &String;
    fn group_name_mut(&mut self) -> &mut String;
    fn product_id(&self) -> &String;
    fn product_id_mut(&mut self) -> &mut String;
    fn project_id(&self) -> &String;
    fn project_id_mut(&mut self) -> &mut String;
    fn verify_ownership(&self) -> &bool;
    fn verify_ownership_mut(&mut self) -> &mut bool;
    fn usage_type(&self) -> &EntitlementType;
    fn usage_type_mut(&mut self) -> &mut EntitlementType;
}

impl EntitlementDataTrait for EntitlementData {
    fn license(&self) -> &String {
        &self.license
    }
    fn license_mut(&mut self) -> &mut String {
        &mut self.license
    }
    fn entitlement_tag(&self) -> &String {
        &self.entitlement_tag
    }
    fn entitlement_tag_mut(&mut self) -> &mut String {
        &mut self.entitlement_tag
    }
    fn group_name(&self) -> &String {
        &self.group_name
    }
    fn group_name_mut(&mut self) -> &mut String {
        &mut self.group_name
    }
    fn product_id(&self) -> &String {
        &self.product_id
    }
    fn product_id_mut(&mut self) -> &mut String {
        &mut self.product_id
    }
    fn project_id(&self) -> &String {
        &self.project_id
    }
    fn project_id_mut(&mut self) -> &mut String {
        &mut self.project_id
    }
    fn verify_ownership(&self) -> &bool {
        &self.verify_ownership
    }
    fn verify_ownership_mut(&mut self) -> &mut bool {
        &mut self.verify_ownership
    }
    fn usage_type(&self) -> &EntitlementType {
        &self.usage_type
    }
    fn usage_type_mut(&mut self) -> &mut EntitlementType {
        &mut self.usage_type
    }
}

pub static ENTITLEMENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementData",
    name_hash: 3068157068,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntitlementData as Default>::default())),
            create_boxed: || Box::new(<EntitlementData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "License",
                name_hash: 979513438,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, license),
            },
            FieldInfoData {
                name: "EntitlementTag",
                name_hash: 1654763342,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, entitlement_tag),
            },
            FieldInfoData {
                name: "GroupName",
                name_hash: 3178263901,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, group_name),
            },
            FieldInfoData {
                name: "ProductId",
                name_hash: 106414083,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, product_id),
            },
            FieldInfoData {
                name: "ProjectId",
                name_hash: 4152360413,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, project_id),
            },
            FieldInfoData {
                name: "VerifyOwnership",
                name_hash: 4151436721,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EntitlementData, verify_ownership),
            },
            FieldInfoData {
                name: "UsageType",
                name_hash: 161626008,
                flags: MemberInfoFlags::new(0),
                field_type: "EntitlementType",
                rust_offset: offset_of!(EntitlementData, usage_type),
            },
        ],
    }),
    array_type: Some(ENTITLEMENTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntitlementData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITLEMENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITLEMENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementData-Array",
    name_hash: 2452712632,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntitlementData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlatformProjectId {
    pub platform: super::core::GamePlatform,
    pub project_id: String,
}

pub trait PlatformProjectIdTrait: TypeObject {
    fn platform(&self) -> &super::core::GamePlatform;
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform;
    fn project_id(&self) -> &String;
    fn project_id_mut(&mut self) -> &mut String;
}

impl PlatformProjectIdTrait for PlatformProjectId {
    fn platform(&self) -> &super::core::GamePlatform {
        &self.platform
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        &mut self.platform
    }
    fn project_id(&self) -> &String {
        &self.project_id
    }
    fn project_id_mut(&mut self) -> &mut String {
        &mut self.project_id
    }
}

pub static PLATFORMPROJECTID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformProjectId",
    name_hash: 2373427298,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlatformProjectId as Default>::default())),
            create_boxed: || Box::new(<PlatformProjectId as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Platform",
                name_hash: 942751002,
                flags: MemberInfoFlags::new(0),
                field_type: "GamePlatform",
                rust_offset: offset_of!(PlatformProjectId, platform),
            },
            FieldInfoData {
                name: "ProjectId",
                name_hash: 4152360413,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PlatformProjectId, project_id),
            },
        ],
    }),
    array_type: Some(PLATFORMPROJECTID_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlatformProjectId {
    fn type_info(&self) -> &'static TypeInfo {
        PLATFORMPROJECTID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PLATFORMPROJECTID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformProjectId-Array",
    name_hash: 929369942,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlatformProjectId"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EntitlementPlatformType {
    pub platform: super::core::GamePlatform,
    pub entitlement_type: EntitlementType,
}

pub trait EntitlementPlatformTypeTrait: TypeObject {
    fn platform(&self) -> &super::core::GamePlatform;
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform;
    fn entitlement_type(&self) -> &EntitlementType;
    fn entitlement_type_mut(&mut self) -> &mut EntitlementType;
}

impl EntitlementPlatformTypeTrait for EntitlementPlatformType {
    fn platform(&self) -> &super::core::GamePlatform {
        &self.platform
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        &mut self.platform
    }
    fn entitlement_type(&self) -> &EntitlementType {
        &self.entitlement_type
    }
    fn entitlement_type_mut(&mut self) -> &mut EntitlementType {
        &mut self.entitlement_type
    }
}

pub static ENTITLEMENTPLATFORMTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementPlatformType",
    name_hash: 448401947,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntitlementPlatformType as Default>::default())),
            create_boxed: || Box::new(<EntitlementPlatformType as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Platform",
                name_hash: 942751002,
                flags: MemberInfoFlags::new(0),
                field_type: "GamePlatform",
                rust_offset: offset_of!(EntitlementPlatformType, platform),
            },
            FieldInfoData {
                name: "EntitlementType",
                name_hash: 3067590660,
                flags: MemberInfoFlags::new(0),
                field_type: "EntitlementType",
                rust_offset: offset_of!(EntitlementPlatformType, entitlement_type),
            },
        ],
    }),
    array_type: Some(ENTITLEMENTPLATFORMTYPE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EntitlementPlatformType {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITLEMENTPLATFORMTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITLEMENTPLATFORMTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementPlatformType-Array",
    name_hash: 590588079,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntitlementPlatformType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EntitlementType {
    #[default]
    EntitlementType_Ignored = 0,
    EntitlementType_Write = 1,
    EntitlementType_Read = 2,
}

pub static ENTITLEMENTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementType",
    name_hash: 3067590660,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ENTITLEMENTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EntitlementType {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITLEMENTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITLEMENTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementType-Array",
    name_hash: 2644511792,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntitlementType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EnsemblePublisherEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub event_name: String,
    pub event_data: String,
}

pub trait EnsemblePublisherEntityDataTrait: super::entity::EntityDataTrait {
    fn event_name(&self) -> &String;
    fn event_name_mut(&mut self) -> &mut String;
    fn event_data(&self) -> &String;
    fn event_data_mut(&mut self) -> &mut String;
}

impl EnsemblePublisherEntityDataTrait for EnsemblePublisherEntityData {
    fn event_name(&self) -> &String {
        &self.event_name
    }
    fn event_name_mut(&mut self) -> &mut String {
        &mut self.event_name
    }
    fn event_data(&self) -> &String {
        &self.event_data
    }
    fn event_data_mut(&mut self) -> &mut String {
        &mut self.event_data
    }
}

impl super::entity::EntityDataTrait for EnsemblePublisherEntityData {
}

impl super::entity::GameObjectDataTrait for EnsemblePublisherEntityData {
}

impl super::core::DataBusPeerTrait for EnsemblePublisherEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnsemblePublisherEntityData {
}

impl super::core::DataContainerTrait for EnsemblePublisherEntityData {
}

pub static ENSEMBLEPUBLISHERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnsemblePublisherEntityData",
    name_hash: 297887643,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(EnsemblePublisherEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnsemblePublisherEntityData as Default>::default())),
            create_boxed: || Box::new(<EnsemblePublisherEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EventName",
                name_hash: 4132530094,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EnsemblePublisherEntityData, event_name),
            },
            FieldInfoData {
                name: "EventData",
                name_hash: 4132606489,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EnsemblePublisherEntityData, event_data),
            },
        ],
    }),
    array_type: Some(ENSEMBLEPUBLISHERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnsemblePublisherEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENSEMBLEPUBLISHERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENSEMBLEPUBLISHERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnsemblePublisherEntityData-Array",
    name_hash: 2529500719,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EnsemblePublisherEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DynamicModelHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait DynamicModelHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl DynamicModelHealthComponentDataTrait for DynamicModelHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for DynamicModelHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for DynamicModelHealthComponentData {
}

impl super::entity::ComponentDataTrait for DynamicModelHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DynamicModelHealthComponentData {
}

impl super::core::DataBusPeerTrait for DynamicModelHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicModelHealthComponentData {
}

impl super::core::DataContainerTrait for DynamicModelHealthComponentData {
}

pub static DYNAMICMODELHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelHealthComponentData",
    name_hash: 1587425788,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(DynamicModelHealthComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicModelHealthComponentData as Default>::default())),
            create_boxed: || Box::new(<DynamicModelHealthComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(DYNAMICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicModelHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICMODELHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelHealthComponentData-Array",
    name_hash: 2688047560,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicModelHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DynamicModelPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
    pub impulse_input: super::core::Vec3,
}

pub trait DynamicModelPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
    fn impulse_input(&self) -> &super::core::Vec3;
    fn impulse_input_mut(&mut self) -> &mut super::core::Vec3;
}

impl DynamicModelPhysicsComponentDataTrait for DynamicModelPhysicsComponentData {
    fn impulse_input(&self) -> &super::core::Vec3 {
        &self.impulse_input
    }
    fn impulse_input_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.impulse_input
    }
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for DynamicModelPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for DynamicModelPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for DynamicModelPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DynamicModelPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for DynamicModelPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicModelPhysicsComponentData {
}

impl super::core::DataContainerTrait for DynamicModelPhysicsComponentData {
}

pub static DYNAMICMODELPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelPhysicsComponentData",
    name_hash: 426006443,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(DynamicModelPhysicsComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicModelPhysicsComponentData as Default>::default())),
            create_boxed: || Box::new(<DynamicModelPhysicsComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ImpulseInput",
                name_hash: 2611741544,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DynamicModelPhysicsComponentData, impulse_input),
            },
        ],
    }),
    array_type: Some(DYNAMICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicModelPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICMODELPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelPhysicsComponentData-Array",
    name_hash: 1156912927,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicModelPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DynamicModelEntityData {
    pub _glacier_base: DynamicGamePhysicsEntityData,
    pub mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub destructible_part_count: u32,
    pub no_collision: bool,
}

pub trait DynamicModelEntityDataTrait: DynamicGamePhysicsEntityDataTrait {
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn destructible_part_count(&self) -> &u32;
    fn destructible_part_count_mut(&mut self) -> &mut u32;
    fn no_collision(&self) -> &bool;
    fn no_collision_mut(&mut self) -> &mut bool;
}

impl DynamicModelEntityDataTrait for DynamicModelEntityData {
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh
    }
    fn destructible_part_count(&self) -> &u32 {
        &self.destructible_part_count
    }
    fn destructible_part_count_mut(&mut self) -> &mut u32 {
        &mut self.destructible_part_count
    }
    fn no_collision(&self) -> &bool {
        &self.no_collision
    }
    fn no_collision_mut(&mut self) -> &mut bool {
        &mut self.no_collision
    }
}

impl DynamicGamePhysicsEntityDataTrait for DynamicModelEntityData {
}

impl super::physics::GamePhysicsEntityDataTrait for DynamicModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for DynamicModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for DynamicModelEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DynamicModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DynamicModelEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicModelEntityData {
}

impl super::core::DataBusPeerTrait for DynamicModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicModelEntityData {
}

impl super::core::DataContainerTrait for DynamicModelEntityData {
}

pub static DYNAMICMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelEntityData",
    name_hash: 1298792692,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DynamicModelEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicModelEntityData as Default>::default())),
            create_boxed: || Box::new(<DynamicModelEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                name_hash: 2088783990,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(DynamicModelEntityData, mesh),
            },
            FieldInfoData {
                name: "DestructiblePartCount",
                name_hash: 539039685,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicModelEntityData, destructible_part_count),
            },
            FieldInfoData {
                name: "NoCollision",
                name_hash: 3513186074,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicModelEntityData, no_collision),
            },
        ],
    }),
    array_type: Some(DYNAMICMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelEntityData-Array",
    name_hash: 1340345536,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct NetFireStarterCell {
    pub x: u8,
    pub y: u8,
    pub start_tick: u32,
    pub radius: u8,
}

pub trait NetFireStarterCellTrait: TypeObject {
    fn x(&self) -> &u8;
    fn x_mut(&mut self) -> &mut u8;
    fn y(&self) -> &u8;
    fn y_mut(&mut self) -> &mut u8;
    fn start_tick(&self) -> &u32;
    fn start_tick_mut(&mut self) -> &mut u32;
    fn radius(&self) -> &u8;
    fn radius_mut(&mut self) -> &mut u8;
}

impl NetFireStarterCellTrait for NetFireStarterCell {
    fn x(&self) -> &u8 {
        &self.x
    }
    fn x_mut(&mut self) -> &mut u8 {
        &mut self.x
    }
    fn y(&self) -> &u8 {
        &self.y
    }
    fn y_mut(&mut self) -> &mut u8 {
        &mut self.y
    }
    fn start_tick(&self) -> &u32 {
        &self.start_tick
    }
    fn start_tick_mut(&mut self) -> &mut u32 {
        &mut self.start_tick
    }
    fn radius(&self) -> &u8 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut u8 {
        &mut self.radius
    }
}

pub static NETFIRESTARTERCELL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetFireStarterCell",
    name_hash: 1473778963,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetFireStarterCell as Default>::default())),
            create_boxed: || Box::new(<NetFireStarterCell as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                name_hash: 177661,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(NetFireStarterCell, x),
            },
            FieldInfoData {
                name: "Y",
                name_hash: 177660,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(NetFireStarterCell, y),
            },
            FieldInfoData {
                name: "StartTick",
                name_hash: 3727579376,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(NetFireStarterCell, start_tick),
            },
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(NetFireStarterCell, radius),
            },
        ],
    }),
    array_type: Some(NETFIRESTARTERCELL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for NetFireStarterCell {
    fn type_info(&self) -> &'static TypeInfo {
        NETFIRESTARTERCELL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NETFIRESTARTERCELL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetFireStarterCell-Array",
    name_hash: 3943206823,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("NetFireStarterCell"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DynamicFireEntityData {
    pub _glacier_base: super::entity::GameComponentEntityData,
    pub width: f32,
    pub length: f32,
    pub height: f32,
    pub fire_tile_size: f32,
    pub max_burn_time: f32,
    pub max_health: f32,
    pub damage_per_second: f32,
    pub cell_f_x_asset: Option<LockedTypeObject /* DynamicFireCellFXAsset */>,
    pub fire_cell_damage_radius: u32,
    pub fire_cell_damage_per_second: f32,
    pub max_damaging_cells: u32,
    pub start_damage_threshold: f32,
    pub end_damage_threshold: f32,
    pub max_fire_starters: u32,
    pub min_fire_starter_radius: f32,
    pub max_fires_per_frame: u32,
    pub max_burning_cells: u32,
    pub quadrant_cell_size: u32,
    pub material_pair: super::entity::MaterialDecl,
    pub mask_shader: super::render_base::SurfaceShaderInstanceDataStruct,
    pub max_quadrant_sounds: u32,
    pub large_fire_threshold: u32,
    pub large_fire_sort_factor: f32,
    pub large_fire_sound: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub medium_fire_threshold: u32,
    pub medium_fire_sort_factor: f32,
    pub medium_fire_sound: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub small_fire_sound: Option<LockedTypeObject /* super::audio::SoundAsset */>,
    pub medium_in_threshold: f32,
    pub large_in_threshold: f32,
    pub large_out_threshold: f32,
    pub medium_out_threshold: f32,
    pub small_fire_weight: f32,
    pub medium_fire_weight: f32,
    pub large_fire_weight: f32,
}

pub trait DynamicFireEntityDataTrait: super::entity::GameComponentEntityDataTrait {
    fn width(&self) -> &f32;
    fn width_mut(&mut self) -> &mut f32;
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
    fn height(&self) -> &f32;
    fn height_mut(&mut self) -> &mut f32;
    fn fire_tile_size(&self) -> &f32;
    fn fire_tile_size_mut(&mut self) -> &mut f32;
    fn max_burn_time(&self) -> &f32;
    fn max_burn_time_mut(&mut self) -> &mut f32;
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn damage_per_second(&self) -> &f32;
    fn damage_per_second_mut(&mut self) -> &mut f32;
    fn cell_f_x_asset(&self) -> &Option<LockedTypeObject /* DynamicFireCellFXAsset */>;
    fn cell_f_x_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* DynamicFireCellFXAsset */>;
    fn fire_cell_damage_radius(&self) -> &u32;
    fn fire_cell_damage_radius_mut(&mut self) -> &mut u32;
    fn fire_cell_damage_per_second(&self) -> &f32;
    fn fire_cell_damage_per_second_mut(&mut self) -> &mut f32;
    fn max_damaging_cells(&self) -> &u32;
    fn max_damaging_cells_mut(&mut self) -> &mut u32;
    fn start_damage_threshold(&self) -> &f32;
    fn start_damage_threshold_mut(&mut self) -> &mut f32;
    fn end_damage_threshold(&self) -> &f32;
    fn end_damage_threshold_mut(&mut self) -> &mut f32;
    fn max_fire_starters(&self) -> &u32;
    fn max_fire_starters_mut(&mut self) -> &mut u32;
    fn min_fire_starter_radius(&self) -> &f32;
    fn min_fire_starter_radius_mut(&mut self) -> &mut f32;
    fn max_fires_per_frame(&self) -> &u32;
    fn max_fires_per_frame_mut(&mut self) -> &mut u32;
    fn max_burning_cells(&self) -> &u32;
    fn max_burning_cells_mut(&mut self) -> &mut u32;
    fn quadrant_cell_size(&self) -> &u32;
    fn quadrant_cell_size_mut(&mut self) -> &mut u32;
    fn material_pair(&self) -> &super::entity::MaterialDecl;
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn mask_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct;
    fn mask_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct;
    fn max_quadrant_sounds(&self) -> &u32;
    fn max_quadrant_sounds_mut(&mut self) -> &mut u32;
    fn large_fire_threshold(&self) -> &u32;
    fn large_fire_threshold_mut(&mut self) -> &mut u32;
    fn large_fire_sort_factor(&self) -> &f32;
    fn large_fire_sort_factor_mut(&mut self) -> &mut f32;
    fn large_fire_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn large_fire_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn medium_fire_threshold(&self) -> &u32;
    fn medium_fire_threshold_mut(&mut self) -> &mut u32;
    fn medium_fire_sort_factor(&self) -> &f32;
    fn medium_fire_sort_factor_mut(&mut self) -> &mut f32;
    fn medium_fire_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn medium_fire_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn small_fire_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn small_fire_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */>;
    fn medium_in_threshold(&self) -> &f32;
    fn medium_in_threshold_mut(&mut self) -> &mut f32;
    fn large_in_threshold(&self) -> &f32;
    fn large_in_threshold_mut(&mut self) -> &mut f32;
    fn large_out_threshold(&self) -> &f32;
    fn large_out_threshold_mut(&mut self) -> &mut f32;
    fn medium_out_threshold(&self) -> &f32;
    fn medium_out_threshold_mut(&mut self) -> &mut f32;
    fn small_fire_weight(&self) -> &f32;
    fn small_fire_weight_mut(&mut self) -> &mut f32;
    fn medium_fire_weight(&self) -> &f32;
    fn medium_fire_weight_mut(&mut self) -> &mut f32;
    fn large_fire_weight(&self) -> &f32;
    fn large_fire_weight_mut(&mut self) -> &mut f32;
}

impl DynamicFireEntityDataTrait for DynamicFireEntityData {
    fn width(&self) -> &f32 {
        &self.width
    }
    fn width_mut(&mut self) -> &mut f32 {
        &mut self.width
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
    fn height(&self) -> &f32 {
        &self.height
    }
    fn height_mut(&mut self) -> &mut f32 {
        &mut self.height
    }
    fn fire_tile_size(&self) -> &f32 {
        &self.fire_tile_size
    }
    fn fire_tile_size_mut(&mut self) -> &mut f32 {
        &mut self.fire_tile_size
    }
    fn max_burn_time(&self) -> &f32 {
        &self.max_burn_time
    }
    fn max_burn_time_mut(&mut self) -> &mut f32 {
        &mut self.max_burn_time
    }
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn damage_per_second(&self) -> &f32 {
        &self.damage_per_second
    }
    fn damage_per_second_mut(&mut self) -> &mut f32 {
        &mut self.damage_per_second
    }
    fn cell_f_x_asset(&self) -> &Option<LockedTypeObject /* DynamicFireCellFXAsset */> {
        &self.cell_f_x_asset
    }
    fn cell_f_x_asset_mut(&mut self) -> &mut Option<LockedTypeObject /* DynamicFireCellFXAsset */> {
        &mut self.cell_f_x_asset
    }
    fn fire_cell_damage_radius(&self) -> &u32 {
        &self.fire_cell_damage_radius
    }
    fn fire_cell_damage_radius_mut(&mut self) -> &mut u32 {
        &mut self.fire_cell_damage_radius
    }
    fn fire_cell_damage_per_second(&self) -> &f32 {
        &self.fire_cell_damage_per_second
    }
    fn fire_cell_damage_per_second_mut(&mut self) -> &mut f32 {
        &mut self.fire_cell_damage_per_second
    }
    fn max_damaging_cells(&self) -> &u32 {
        &self.max_damaging_cells
    }
    fn max_damaging_cells_mut(&mut self) -> &mut u32 {
        &mut self.max_damaging_cells
    }
    fn start_damage_threshold(&self) -> &f32 {
        &self.start_damage_threshold
    }
    fn start_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.start_damage_threshold
    }
    fn end_damage_threshold(&self) -> &f32 {
        &self.end_damage_threshold
    }
    fn end_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.end_damage_threshold
    }
    fn max_fire_starters(&self) -> &u32 {
        &self.max_fire_starters
    }
    fn max_fire_starters_mut(&mut self) -> &mut u32 {
        &mut self.max_fire_starters
    }
    fn min_fire_starter_radius(&self) -> &f32 {
        &self.min_fire_starter_radius
    }
    fn min_fire_starter_radius_mut(&mut self) -> &mut f32 {
        &mut self.min_fire_starter_radius
    }
    fn max_fires_per_frame(&self) -> &u32 {
        &self.max_fires_per_frame
    }
    fn max_fires_per_frame_mut(&mut self) -> &mut u32 {
        &mut self.max_fires_per_frame
    }
    fn max_burning_cells(&self) -> &u32 {
        &self.max_burning_cells
    }
    fn max_burning_cells_mut(&mut self) -> &mut u32 {
        &mut self.max_burning_cells
    }
    fn quadrant_cell_size(&self) -> &u32 {
        &self.quadrant_cell_size
    }
    fn quadrant_cell_size_mut(&mut self) -> &mut u32 {
        &mut self.quadrant_cell_size
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        &self.material_pair
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material_pair
    }
    fn mask_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct {
        &self.mask_shader
    }
    fn mask_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct {
        &mut self.mask_shader
    }
    fn max_quadrant_sounds(&self) -> &u32 {
        &self.max_quadrant_sounds
    }
    fn max_quadrant_sounds_mut(&mut self) -> &mut u32 {
        &mut self.max_quadrant_sounds
    }
    fn large_fire_threshold(&self) -> &u32 {
        &self.large_fire_threshold
    }
    fn large_fire_threshold_mut(&mut self) -> &mut u32 {
        &mut self.large_fire_threshold
    }
    fn large_fire_sort_factor(&self) -> &f32 {
        &self.large_fire_sort_factor
    }
    fn large_fire_sort_factor_mut(&mut self) -> &mut f32 {
        &mut self.large_fire_sort_factor
    }
    fn large_fire_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.large_fire_sound
    }
    fn large_fire_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.large_fire_sound
    }
    fn medium_fire_threshold(&self) -> &u32 {
        &self.medium_fire_threshold
    }
    fn medium_fire_threshold_mut(&mut self) -> &mut u32 {
        &mut self.medium_fire_threshold
    }
    fn medium_fire_sort_factor(&self) -> &f32 {
        &self.medium_fire_sort_factor
    }
    fn medium_fire_sort_factor_mut(&mut self) -> &mut f32 {
        &mut self.medium_fire_sort_factor
    }
    fn medium_fire_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.medium_fire_sound
    }
    fn medium_fire_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.medium_fire_sound
    }
    fn small_fire_sound(&self) -> &Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &self.small_fire_sound
    }
    fn small_fire_sound_mut(&mut self) -> &mut Option<LockedTypeObject /* super::audio::SoundAsset */> {
        &mut self.small_fire_sound
    }
    fn medium_in_threshold(&self) -> &f32 {
        &self.medium_in_threshold
    }
    fn medium_in_threshold_mut(&mut self) -> &mut f32 {
        &mut self.medium_in_threshold
    }
    fn large_in_threshold(&self) -> &f32 {
        &self.large_in_threshold
    }
    fn large_in_threshold_mut(&mut self) -> &mut f32 {
        &mut self.large_in_threshold
    }
    fn large_out_threshold(&self) -> &f32 {
        &self.large_out_threshold
    }
    fn large_out_threshold_mut(&mut self) -> &mut f32 {
        &mut self.large_out_threshold
    }
    fn medium_out_threshold(&self) -> &f32 {
        &self.medium_out_threshold
    }
    fn medium_out_threshold_mut(&mut self) -> &mut f32 {
        &mut self.medium_out_threshold
    }
    fn small_fire_weight(&self) -> &f32 {
        &self.small_fire_weight
    }
    fn small_fire_weight_mut(&mut self) -> &mut f32 {
        &mut self.small_fire_weight
    }
    fn medium_fire_weight(&self) -> &f32 {
        &self.medium_fire_weight
    }
    fn medium_fire_weight_mut(&mut self) -> &mut f32 {
        &mut self.medium_fire_weight
    }
    fn large_fire_weight(&self) -> &f32 {
        &self.large_fire_weight
    }
    fn large_fire_weight_mut(&mut self) -> &mut f32 {
        &mut self.large_fire_weight
    }
}

impl super::entity::GameComponentEntityDataTrait for DynamicFireEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for DynamicFireEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DynamicFireEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DynamicFireEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicFireEntityData {
}

impl super::core::DataBusPeerTrait for DynamicFireEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicFireEntityData {
}

impl super::core::DataContainerTrait for DynamicFireEntityData {
}

pub static DYNAMICFIREENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicFireEntityData",
    name_hash: 1769795267,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DynamicFireEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicFireEntityData as Default>::default())),
            create_boxed: || Box::new(<DynamicFireEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Width",
                name_hash: 226981187,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, width),
            },
            FieldInfoData {
                name: "Length",
                name_hash: 2906827577,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, length),
            },
            FieldInfoData {
                name: "Height",
                name_hash: 3054065626,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, height),
            },
            FieldInfoData {
                name: "FireTileSize",
                name_hash: 3573806220,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, fire_tile_size),
            },
            FieldInfoData {
                name: "MaxBurnTime",
                name_hash: 2897119663,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, max_burn_time),
            },
            FieldInfoData {
                name: "MaxHealth",
                name_hash: 1153188365,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, max_health),
            },
            FieldInfoData {
                name: "DamagePerSecond",
                name_hash: 1464141113,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, damage_per_second),
            },
            FieldInfoData {
                name: "CellFXAsset",
                name_hash: 1491786285,
                flags: MemberInfoFlags::new(0),
                field_type: "DynamicFireCellFXAsset",
                rust_offset: offset_of!(DynamicFireEntityData, cell_f_x_asset),
            },
            FieldInfoData {
                name: "FireCellDamageRadius",
                name_hash: 2320615496,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, fire_cell_damage_radius),
            },
            FieldInfoData {
                name: "FireCellDamagePerSecond",
                name_hash: 1917530823,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, fire_cell_damage_per_second),
            },
            FieldInfoData {
                name: "MaxDamagingCells",
                name_hash: 509293546,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_damaging_cells),
            },
            FieldInfoData {
                name: "StartDamageThreshold",
                name_hash: 1634838713,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, start_damage_threshold),
            },
            FieldInfoData {
                name: "EndDamageThreshold",
                name_hash: 4190353558,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, end_damage_threshold),
            },
            FieldInfoData {
                name: "MaxFireStarters",
                name_hash: 488368973,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_fire_starters),
            },
            FieldInfoData {
                name: "MinFireStarterRadius",
                name_hash: 2735586744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, min_fire_starter_radius),
            },
            FieldInfoData {
                name: "MaxFiresPerFrame",
                name_hash: 1315726848,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_fires_per_frame),
            },
            FieldInfoData {
                name: "MaxBurningCells",
                name_hash: 1670820847,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_burning_cells),
            },
            FieldInfoData {
                name: "QuadrantCellSize",
                name_hash: 1793464174,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, quadrant_cell_size),
            },
            FieldInfoData {
                name: "MaterialPair",
                name_hash: 161392100,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(DynamicFireEntityData, material_pair),
            },
            FieldInfoData {
                name: "MaskShader",
                name_hash: 3852583160,
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderInstanceDataStruct",
                rust_offset: offset_of!(DynamicFireEntityData, mask_shader),
            },
            FieldInfoData {
                name: "MaxQuadrantSounds",
                name_hash: 3763576201,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_quadrant_sounds),
            },
            FieldInfoData {
                name: "LargeFireThreshold",
                name_hash: 3596588599,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, large_fire_threshold),
            },
            FieldInfoData {
                name: "LargeFireSortFactor",
                name_hash: 2306854391,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, large_fire_sort_factor),
            },
            FieldInfoData {
                name: "LargeFireSound",
                name_hash: 3742000483,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(DynamicFireEntityData, large_fire_sound),
            },
            FieldInfoData {
                name: "MediumFireThreshold",
                name_hash: 1718591095,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_fire_threshold),
            },
            FieldInfoData {
                name: "MediumFireSortFactor",
                name_hash: 3668245687,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_fire_sort_factor),
            },
            FieldInfoData {
                name: "MediumFireSound",
                name_hash: 3834408355,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(DynamicFireEntityData, medium_fire_sound),
            },
            FieldInfoData {
                name: "SmallFireSound",
                name_hash: 3219667457,
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(DynamicFireEntityData, small_fire_sound),
            },
            FieldInfoData {
                name: "MediumInThreshold",
                name_hash: 978716776,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_in_threshold),
            },
            FieldInfoData {
                name: "LargeInThreshold",
                name_hash: 1443585576,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, large_in_threshold),
            },
            FieldInfoData {
                name: "LargeOutThreshold",
                name_hash: 953589985,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, large_out_threshold),
            },
            FieldInfoData {
                name: "MediumOutThreshold",
                name_hash: 2813555105,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_out_threshold),
            },
            FieldInfoData {
                name: "SmallFireWeight",
                name_hash: 3301430466,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, small_fire_weight),
            },
            FieldInfoData {
                name: "MediumFireWeight",
                name_hash: 2117770208,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_fire_weight),
            },
            FieldInfoData {
                name: "LargeFireWeight",
                name_hash: 3372477472,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, large_fire_weight),
            },
        ],
    }),
    array_type: Some(DYNAMICFIREENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicFireEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICFIREENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICFIREENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicFireEntityData-Array",
    name_hash: 2817962487,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicFireEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DynamicFireCellFXAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub cell_f_x_list: Vec<Option<LockedTypeObject /* CellFX */>>,
    pub min_smoke_separation_distance: super::core::QualityScalableFloat,
    pub smoke_effect: Vec<Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>>,
}

pub trait DynamicFireCellFXAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn cell_f_x_list(&self) -> &Vec<Option<LockedTypeObject /* CellFX */>>;
    fn cell_f_x_list_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CellFX */>>;
    fn min_smoke_separation_distance(&self) -> &super::core::QualityScalableFloat;
    fn min_smoke_separation_distance_mut(&mut self) -> &mut super::core::QualityScalableFloat;
    fn smoke_effect(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>>;
    fn smoke_effect_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>>;
}

impl DynamicFireCellFXAssetTrait for DynamicFireCellFXAsset {
    fn cell_f_x_list(&self) -> &Vec<Option<LockedTypeObject /* CellFX */>> {
        &self.cell_f_x_list
    }
    fn cell_f_x_list_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* CellFX */>> {
        &mut self.cell_f_x_list
    }
    fn min_smoke_separation_distance(&self) -> &super::core::QualityScalableFloat {
        &self.min_smoke_separation_distance
    }
    fn min_smoke_separation_distance_mut(&mut self) -> &mut super::core::QualityScalableFloat {
        &mut self.min_smoke_separation_distance
    }
    fn smoke_effect(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>> {
        &self.smoke_effect
    }
    fn smoke_effect_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>> {
        &mut self.smoke_effect
    }
}

impl super::core::DataContainerPolicyAssetTrait for DynamicFireCellFXAsset {
}

impl super::core::AssetTrait for DynamicFireCellFXAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for DynamicFireCellFXAsset {
}

pub static DYNAMICFIRECELLFXASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicFireCellFXAsset",
    name_hash: 3703318752,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        super_class_offset: offset_of!(DynamicFireCellFXAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicFireCellFXAsset as Default>::default())),
            create_boxed: || Box::new(<DynamicFireCellFXAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "CellFXList",
                name_hash: 2908073183,
                flags: MemberInfoFlags::new(144),
                field_type: "CellFX-Array",
                rust_offset: offset_of!(DynamicFireCellFXAsset, cell_f_x_list),
            },
            FieldInfoData {
                name: "MinSmokeSeparationDistance",
                name_hash: 2513155419,
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableFloat",
                rust_offset: offset_of!(DynamicFireCellFXAsset, min_smoke_separation_distance),
            },
            FieldInfoData {
                name: "SmokeEffect",
                name_hash: 2905725837,
                flags: MemberInfoFlags::new(144),
                field_type: "EffectBlueprint-Array",
                rust_offset: offset_of!(DynamicFireCellFXAsset, smoke_effect),
            },
        ],
    }),
    array_type: Some(DYNAMICFIRECELLFXASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DynamicFireCellFXAsset {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICFIRECELLFXASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICFIRECELLFXASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicFireCellFXAsset-Array",
    name_hash: 3177299668,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicFireCellFXAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CellFX {
    pub _glacier_base: super::core::DataContainer,
    pub enabled: super::core::QualityScalableBool,
    pub min_spawn_scale: super::core::Vec3,
    pub max_spawn_scale: super::core::Vec3,
    pub spawn_probability: super::core::QualityScalableFloat,
    pub min_spawn_count: super::core::QualityScalableInt,
    pub max_spawn_count: super::core::QualityScalableInt,
    pub peak_burn_percent: f32,
    pub min_peak_flicker_percent: f32,
    pub max_peak_flicker_percent: f32,
    pub min_flicker_amplitude: f32,
    pub max_flicker_amplitude: f32,
    pub min_flicker_freq: f32,
    pub max_flicker_freq: f32,
    pub spawn_scale_multiplier_x: f32,
    pub spawn_scale_multiplier_y: f32,
    pub spawn_scale_multiplier_z: f32,
    pub align_to_terrain_normal: bool,
    pub peak_growth_percent: f32,
    pub growth_offset: f32,
    pub burn_time_multiplier: f32,
    pub effect_mesh: Option<LockedTypeObject /* super::entity::ObjectBlueprint */>,
}

pub trait CellFXTrait: super::core::DataContainerTrait {
    fn enabled(&self) -> &super::core::QualityScalableBool;
    fn enabled_mut(&mut self) -> &mut super::core::QualityScalableBool;
    fn min_spawn_scale(&self) -> &super::core::Vec3;
    fn min_spawn_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn max_spawn_scale(&self) -> &super::core::Vec3;
    fn max_spawn_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn spawn_probability(&self) -> &super::core::QualityScalableFloat;
    fn spawn_probability_mut(&mut self) -> &mut super::core::QualityScalableFloat;
    fn min_spawn_count(&self) -> &super::core::QualityScalableInt;
    fn min_spawn_count_mut(&mut self) -> &mut super::core::QualityScalableInt;
    fn max_spawn_count(&self) -> &super::core::QualityScalableInt;
    fn max_spawn_count_mut(&mut self) -> &mut super::core::QualityScalableInt;
    fn peak_burn_percent(&self) -> &f32;
    fn peak_burn_percent_mut(&mut self) -> &mut f32;
    fn min_peak_flicker_percent(&self) -> &f32;
    fn min_peak_flicker_percent_mut(&mut self) -> &mut f32;
    fn max_peak_flicker_percent(&self) -> &f32;
    fn max_peak_flicker_percent_mut(&mut self) -> &mut f32;
    fn min_flicker_amplitude(&self) -> &f32;
    fn min_flicker_amplitude_mut(&mut self) -> &mut f32;
    fn max_flicker_amplitude(&self) -> &f32;
    fn max_flicker_amplitude_mut(&mut self) -> &mut f32;
    fn min_flicker_freq(&self) -> &f32;
    fn min_flicker_freq_mut(&mut self) -> &mut f32;
    fn max_flicker_freq(&self) -> &f32;
    fn max_flicker_freq_mut(&mut self) -> &mut f32;
    fn spawn_scale_multiplier_x(&self) -> &f32;
    fn spawn_scale_multiplier_x_mut(&mut self) -> &mut f32;
    fn spawn_scale_multiplier_y(&self) -> &f32;
    fn spawn_scale_multiplier_y_mut(&mut self) -> &mut f32;
    fn spawn_scale_multiplier_z(&self) -> &f32;
    fn spawn_scale_multiplier_z_mut(&mut self) -> &mut f32;
    fn align_to_terrain_normal(&self) -> &bool;
    fn align_to_terrain_normal_mut(&mut self) -> &mut bool;
    fn peak_growth_percent(&self) -> &f32;
    fn peak_growth_percent_mut(&mut self) -> &mut f32;
    fn growth_offset(&self) -> &f32;
    fn growth_offset_mut(&mut self) -> &mut f32;
    fn burn_time_multiplier(&self) -> &f32;
    fn burn_time_multiplier_mut(&mut self) -> &mut f32;
    fn effect_mesh(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn effect_mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
}

impl CellFXTrait for CellFX {
    fn enabled(&self) -> &super::core::QualityScalableBool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut super::core::QualityScalableBool {
        &mut self.enabled
    }
    fn min_spawn_scale(&self) -> &super::core::Vec3 {
        &self.min_spawn_scale
    }
    fn min_spawn_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.min_spawn_scale
    }
    fn max_spawn_scale(&self) -> &super::core::Vec3 {
        &self.max_spawn_scale
    }
    fn max_spawn_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.max_spawn_scale
    }
    fn spawn_probability(&self) -> &super::core::QualityScalableFloat {
        &self.spawn_probability
    }
    fn spawn_probability_mut(&mut self) -> &mut super::core::QualityScalableFloat {
        &mut self.spawn_probability
    }
    fn min_spawn_count(&self) -> &super::core::QualityScalableInt {
        &self.min_spawn_count
    }
    fn min_spawn_count_mut(&mut self) -> &mut super::core::QualityScalableInt {
        &mut self.min_spawn_count
    }
    fn max_spawn_count(&self) -> &super::core::QualityScalableInt {
        &self.max_spawn_count
    }
    fn max_spawn_count_mut(&mut self) -> &mut super::core::QualityScalableInt {
        &mut self.max_spawn_count
    }
    fn peak_burn_percent(&self) -> &f32 {
        &self.peak_burn_percent
    }
    fn peak_burn_percent_mut(&mut self) -> &mut f32 {
        &mut self.peak_burn_percent
    }
    fn min_peak_flicker_percent(&self) -> &f32 {
        &self.min_peak_flicker_percent
    }
    fn min_peak_flicker_percent_mut(&mut self) -> &mut f32 {
        &mut self.min_peak_flicker_percent
    }
    fn max_peak_flicker_percent(&self) -> &f32 {
        &self.max_peak_flicker_percent
    }
    fn max_peak_flicker_percent_mut(&mut self) -> &mut f32 {
        &mut self.max_peak_flicker_percent
    }
    fn min_flicker_amplitude(&self) -> &f32 {
        &self.min_flicker_amplitude
    }
    fn min_flicker_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.min_flicker_amplitude
    }
    fn max_flicker_amplitude(&self) -> &f32 {
        &self.max_flicker_amplitude
    }
    fn max_flicker_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.max_flicker_amplitude
    }
    fn min_flicker_freq(&self) -> &f32 {
        &self.min_flicker_freq
    }
    fn min_flicker_freq_mut(&mut self) -> &mut f32 {
        &mut self.min_flicker_freq
    }
    fn max_flicker_freq(&self) -> &f32 {
        &self.max_flicker_freq
    }
    fn max_flicker_freq_mut(&mut self) -> &mut f32 {
        &mut self.max_flicker_freq
    }
    fn spawn_scale_multiplier_x(&self) -> &f32 {
        &self.spawn_scale_multiplier_x
    }
    fn spawn_scale_multiplier_x_mut(&mut self) -> &mut f32 {
        &mut self.spawn_scale_multiplier_x
    }
    fn spawn_scale_multiplier_y(&self) -> &f32 {
        &self.spawn_scale_multiplier_y
    }
    fn spawn_scale_multiplier_y_mut(&mut self) -> &mut f32 {
        &mut self.spawn_scale_multiplier_y
    }
    fn spawn_scale_multiplier_z(&self) -> &f32 {
        &self.spawn_scale_multiplier_z
    }
    fn spawn_scale_multiplier_z_mut(&mut self) -> &mut f32 {
        &mut self.spawn_scale_multiplier_z
    }
    fn align_to_terrain_normal(&self) -> &bool {
        &self.align_to_terrain_normal
    }
    fn align_to_terrain_normal_mut(&mut self) -> &mut bool {
        &mut self.align_to_terrain_normal
    }
    fn peak_growth_percent(&self) -> &f32 {
        &self.peak_growth_percent
    }
    fn peak_growth_percent_mut(&mut self) -> &mut f32 {
        &mut self.peak_growth_percent
    }
    fn growth_offset(&self) -> &f32 {
        &self.growth_offset
    }
    fn growth_offset_mut(&mut self) -> &mut f32 {
        &mut self.growth_offset
    }
    fn burn_time_multiplier(&self) -> &f32 {
        &self.burn_time_multiplier
    }
    fn burn_time_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.burn_time_multiplier
    }
    fn effect_mesh(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &self.effect_mesh
    }
    fn effect_mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &mut self.effect_mesh
    }
}

impl super::core::DataContainerTrait for CellFX {
}

pub static CELLFX_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CellFX",
    name_hash: 2711853789,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(CellFX, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CellFX as Default>::default())),
            create_boxed: || Box::new(<CellFX as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableBool",
                rust_offset: offset_of!(CellFX, enabled),
            },
            FieldInfoData {
                name: "MinSpawnScale",
                name_hash: 986886508,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CellFX, min_spawn_scale),
            },
            FieldInfoData {
                name: "MaxSpawnScale",
                name_hash: 583175410,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CellFX, max_spawn_scale),
            },
            FieldInfoData {
                name: "SpawnProbability",
                name_hash: 2017232915,
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableFloat",
                rust_offset: offset_of!(CellFX, spawn_probability),
            },
            FieldInfoData {
                name: "MinSpawnCount",
                name_hash: 1005991351,
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableInt",
                rust_offset: offset_of!(CellFX, min_spawn_count),
            },
            FieldInfoData {
                name: "MaxSpawnCount",
                name_hash: 564070313,
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableInt",
                rust_offset: offset_of!(CellFX, max_spawn_count),
            },
            FieldInfoData {
                name: "PeakBurnPercent",
                name_hash: 2635127626,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, peak_burn_percent),
            },
            FieldInfoData {
                name: "MinPeakFlickerPercent",
                name_hash: 3401787287,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, min_peak_flicker_percent),
            },
            FieldInfoData {
                name: "MaxPeakFlickerPercent",
                name_hash: 3906678025,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, max_peak_flicker_percent),
            },
            FieldInfoData {
                name: "MinFlickerAmplitude",
                name_hash: 3827620714,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, min_flicker_amplitude),
            },
            FieldInfoData {
                name: "MaxFlickerAmplitude",
                name_hash: 3224389108,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, max_flicker_amplitude),
            },
            FieldInfoData {
                name: "MinFlickerFreq",
                name_hash: 3555522035,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, min_flicker_freq),
            },
            FieldInfoData {
                name: "MaxFlickerFreq",
                name_hash: 741698733,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, max_flicker_freq),
            },
            FieldInfoData {
                name: "SpawnScaleMultiplierX",
                name_hash: 994856213,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, spawn_scale_multiplier_x),
            },
            FieldInfoData {
                name: "SpawnScaleMultiplierY",
                name_hash: 994856212,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, spawn_scale_multiplier_y),
            },
            FieldInfoData {
                name: "SpawnScaleMultiplierZ",
                name_hash: 994856215,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, spawn_scale_multiplier_z),
            },
            FieldInfoData {
                name: "AlignToTerrainNormal",
                name_hash: 3543291927,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CellFX, align_to_terrain_normal),
            },
            FieldInfoData {
                name: "PeakGrowthPercent",
                name_hash: 1764325904,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, peak_growth_percent),
            },
            FieldInfoData {
                name: "GrowthOffset",
                name_hash: 3233081497,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, growth_offset),
            },
            FieldInfoData {
                name: "BurnTimeMultiplier",
                name_hash: 2572017520,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, burn_time_multiplier),
            },
            FieldInfoData {
                name: "EffectMesh",
                name_hash: 1604605313,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(CellFX, effect_mesh),
            },
        ],
    }),
    array_type: Some(CELLFX_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CellFX {
    fn type_info(&self) -> &'static TypeInfo {
        CELLFX_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CELLFX_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CellFX-Array",
    name_hash: 2668885737,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CellFX"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterLookAtTriggerEntityData {
    pub _glacier_base: TriggerEventEntityData,
    pub f_o_v: f32,
    pub min_distance_to_object: f32,
    pub max_distance_to_object: f32,
    pub start_trigger_looking_at: bool,
    pub check_occlusion: bool,
    pub use_entity_direction: bool,
}

pub trait CharacterLookAtTriggerEntityDataTrait: TriggerEventEntityDataTrait {
    fn f_o_v(&self) -> &f32;
    fn f_o_v_mut(&mut self) -> &mut f32;
    fn min_distance_to_object(&self) -> &f32;
    fn min_distance_to_object_mut(&mut self) -> &mut f32;
    fn max_distance_to_object(&self) -> &f32;
    fn max_distance_to_object_mut(&mut self) -> &mut f32;
    fn start_trigger_looking_at(&self) -> &bool;
    fn start_trigger_looking_at_mut(&mut self) -> &mut bool;
    fn check_occlusion(&self) -> &bool;
    fn check_occlusion_mut(&mut self) -> &mut bool;
    fn use_entity_direction(&self) -> &bool;
    fn use_entity_direction_mut(&mut self) -> &mut bool;
}

impl CharacterLookAtTriggerEntityDataTrait for CharacterLookAtTriggerEntityData {
    fn f_o_v(&self) -> &f32 {
        &self.f_o_v
    }
    fn f_o_v_mut(&mut self) -> &mut f32 {
        &mut self.f_o_v
    }
    fn min_distance_to_object(&self) -> &f32 {
        &self.min_distance_to_object
    }
    fn min_distance_to_object_mut(&mut self) -> &mut f32 {
        &mut self.min_distance_to_object
    }
    fn max_distance_to_object(&self) -> &f32 {
        &self.max_distance_to_object
    }
    fn max_distance_to_object_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_to_object
    }
    fn start_trigger_looking_at(&self) -> &bool {
        &self.start_trigger_looking_at
    }
    fn start_trigger_looking_at_mut(&mut self) -> &mut bool {
        &mut self.start_trigger_looking_at
    }
    fn check_occlusion(&self) -> &bool {
        &self.check_occlusion
    }
    fn check_occlusion_mut(&mut self) -> &mut bool {
        &mut self.check_occlusion
    }
    fn use_entity_direction(&self) -> &bool {
        &self.use_entity_direction
    }
    fn use_entity_direction_mut(&mut self) -> &mut bool {
        &mut self.use_entity_direction
    }
}

impl TriggerEventEntityDataTrait for CharacterLookAtTriggerEntityData {
}

impl TriggerEntityDataTrait for CharacterLookAtTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for CharacterLookAtTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CharacterLookAtTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for CharacterLookAtTriggerEntityData {
}

impl super::core::DataBusPeerTrait for CharacterLookAtTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterLookAtTriggerEntityData {
}

impl super::core::DataContainerTrait for CharacterLookAtTriggerEntityData {
}

pub static CHARACTERLOOKATTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterLookAtTriggerEntityData",
    name_hash: 810946461,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGEREVENTENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterLookAtTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterLookAtTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<CharacterLookAtTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FOV",
                name_hash: 193442778,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, f_o_v),
            },
            FieldInfoData {
                name: "MinDistanceToObject",
                name_hash: 3463845186,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, min_distance_to_object),
            },
            FieldInfoData {
                name: "MaxDistanceToObject",
                name_hash: 954132188,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, max_distance_to_object),
            },
            FieldInfoData {
                name: "StartTriggerLookingAt",
                name_hash: 2703714543,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, start_trigger_looking_at),
            },
            FieldInfoData {
                name: "CheckOcclusion",
                name_hash: 3588432334,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, check_occlusion),
            },
            FieldInfoData {
                name: "UseEntityDirection",
                name_hash: 87745112,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, use_entity_direction),
            },
        ],
    }),
    array_type: Some(CHARACTERLOOKATTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterLookAtTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERLOOKATTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERLOOKATTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterLookAtTriggerEntityData-Array",
    name_hash: 322894633,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterLookAtTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct UnderFireTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub radius: f32,
    pub cool_down_time: f32,
    pub use_trigger_on_material_only: bool,
    pub trigger_on_material_only: super::entity::MaterialDecl,
    pub geometries_follow_object: bool,
    pub disable_if_track_entity_is_lost: bool,
    pub triggered_by: AreaTriggerInclude,
    pub random_yaw: bool,
    pub indicate_hit: bool,
    pub team_of_allies: super::gameplay_sim::TeamId,
}

pub trait UnderFireTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn cool_down_time(&self) -> &f32;
    fn cool_down_time_mut(&mut self) -> &mut f32;
    fn use_trigger_on_material_only(&self) -> &bool;
    fn use_trigger_on_material_only_mut(&mut self) -> &mut bool;
    fn trigger_on_material_only(&self) -> &super::entity::MaterialDecl;
    fn trigger_on_material_only_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn geometries_follow_object(&self) -> &bool;
    fn geometries_follow_object_mut(&mut self) -> &mut bool;
    fn disable_if_track_entity_is_lost(&self) -> &bool;
    fn disable_if_track_entity_is_lost_mut(&mut self) -> &mut bool;
    fn triggered_by(&self) -> &AreaTriggerInclude;
    fn triggered_by_mut(&mut self) -> &mut AreaTriggerInclude;
    fn random_yaw(&self) -> &bool;
    fn random_yaw_mut(&mut self) -> &mut bool;
    fn indicate_hit(&self) -> &bool;
    fn indicate_hit_mut(&mut self) -> &mut bool;
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId;
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
}

impl UnderFireTriggerEntityDataTrait for UnderFireTriggerEntityData {
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn cool_down_time(&self) -> &f32 {
        &self.cool_down_time
    }
    fn cool_down_time_mut(&mut self) -> &mut f32 {
        &mut self.cool_down_time
    }
    fn use_trigger_on_material_only(&self) -> &bool {
        &self.use_trigger_on_material_only
    }
    fn use_trigger_on_material_only_mut(&mut self) -> &mut bool {
        &mut self.use_trigger_on_material_only
    }
    fn trigger_on_material_only(&self) -> &super::entity::MaterialDecl {
        &self.trigger_on_material_only
    }
    fn trigger_on_material_only_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.trigger_on_material_only
    }
    fn geometries_follow_object(&self) -> &bool {
        &self.geometries_follow_object
    }
    fn geometries_follow_object_mut(&mut self) -> &mut bool {
        &mut self.geometries_follow_object
    }
    fn disable_if_track_entity_is_lost(&self) -> &bool {
        &self.disable_if_track_entity_is_lost
    }
    fn disable_if_track_entity_is_lost_mut(&mut self) -> &mut bool {
        &mut self.disable_if_track_entity_is_lost
    }
    fn triggered_by(&self) -> &AreaTriggerInclude {
        &self.triggered_by
    }
    fn triggered_by_mut(&mut self) -> &mut AreaTriggerInclude {
        &mut self.triggered_by
    }
    fn random_yaw(&self) -> &bool {
        &self.random_yaw
    }
    fn random_yaw_mut(&mut self) -> &mut bool {
        &mut self.random_yaw
    }
    fn indicate_hit(&self) -> &bool {
        &self.indicate_hit
    }
    fn indicate_hit_mut(&mut self) -> &mut bool {
        &mut self.indicate_hit
    }
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId {
        &self.team_of_allies
    }
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_of_allies
    }
}

impl TriggerEntityDataTrait for UnderFireTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for UnderFireTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for UnderFireTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for UnderFireTriggerEntityData {
}

impl super::core::DataBusPeerTrait for UnderFireTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for UnderFireTriggerEntityData {
}

impl super::core::DataContainerTrait for UnderFireTriggerEntityData {
}

pub static UNDERFIRETRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnderFireTriggerEntityData",
    name_hash: 4793894,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(UnderFireTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnderFireTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<UnderFireTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(UnderFireTriggerEntityData, radius),
            },
            FieldInfoData {
                name: "CoolDownTime",
                name_hash: 282296301,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(UnderFireTriggerEntityData, cool_down_time),
            },
            FieldInfoData {
                name: "UseTriggerOnMaterialOnly",
                name_hash: 306797024,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, use_trigger_on_material_only),
            },
            FieldInfoData {
                name: "TriggerOnMaterialOnly",
                name_hash: 3821487555,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(UnderFireTriggerEntityData, trigger_on_material_only),
            },
            FieldInfoData {
                name: "GeometriesFollowObject",
                name_hash: 2947657501,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, geometries_follow_object),
            },
            FieldInfoData {
                name: "DisableIfTrackEntityIsLost",
                name_hash: 1061491348,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, disable_if_track_entity_is_lost),
            },
            FieldInfoData {
                name: "TriggeredBy",
                name_hash: 1020865575,
                flags: MemberInfoFlags::new(0),
                field_type: "AreaTriggerInclude",
                rust_offset: offset_of!(UnderFireTriggerEntityData, triggered_by),
            },
            FieldInfoData {
                name: "RandomYaw",
                name_hash: 1799468081,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, random_yaw),
            },
            FieldInfoData {
                name: "IndicateHit",
                name_hash: 1494915465,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, indicate_hit),
            },
            FieldInfoData {
                name: "TeamOfAllies",
                name_hash: 3315237551,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(UnderFireTriggerEntityData, team_of_allies),
            },
        ],
    }),
    array_type: Some(UNDERFIRETRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for UnderFireTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        UNDERFIRETRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNDERFIRETRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnderFireTriggerEntityData-Array",
    name_hash: 2864960146,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnderFireTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayerInputTriggerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub entry_input_actions: i32,
    pub value_modifier: f32,
    pub value_modifier_for_mouse: f32,
    pub clamp_value_after_mouse_modifier: bool,
    pub enabled_from_start: bool,
    pub send_trigger_events: bool,
    pub hold_down_time: f32,
    pub accumulated_value_at_start: f32,
    pub trailing_value_at_start: f32,
}

pub trait PlayerInputTriggerEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn entry_input_actions(&self) -> &i32;
    fn entry_input_actions_mut(&mut self) -> &mut i32;
    fn value_modifier(&self) -> &f32;
    fn value_modifier_mut(&mut self) -> &mut f32;
    fn value_modifier_for_mouse(&self) -> &f32;
    fn value_modifier_for_mouse_mut(&mut self) -> &mut f32;
    fn clamp_value_after_mouse_modifier(&self) -> &bool;
    fn clamp_value_after_mouse_modifier_mut(&mut self) -> &mut bool;
    fn enabled_from_start(&self) -> &bool;
    fn enabled_from_start_mut(&mut self) -> &mut bool;
    fn send_trigger_events(&self) -> &bool;
    fn send_trigger_events_mut(&mut self) -> &mut bool;
    fn hold_down_time(&self) -> &f32;
    fn hold_down_time_mut(&mut self) -> &mut f32;
    fn accumulated_value_at_start(&self) -> &f32;
    fn accumulated_value_at_start_mut(&mut self) -> &mut f32;
    fn trailing_value_at_start(&self) -> &f32;
    fn trailing_value_at_start_mut(&mut self) -> &mut f32;
}

impl PlayerInputTriggerEntityDataTrait for PlayerInputTriggerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn entry_input_actions(&self) -> &i32 {
        &self.entry_input_actions
    }
    fn entry_input_actions_mut(&mut self) -> &mut i32 {
        &mut self.entry_input_actions
    }
    fn value_modifier(&self) -> &f32 {
        &self.value_modifier
    }
    fn value_modifier_mut(&mut self) -> &mut f32 {
        &mut self.value_modifier
    }
    fn value_modifier_for_mouse(&self) -> &f32 {
        &self.value_modifier_for_mouse
    }
    fn value_modifier_for_mouse_mut(&mut self) -> &mut f32 {
        &mut self.value_modifier_for_mouse
    }
    fn clamp_value_after_mouse_modifier(&self) -> &bool {
        &self.clamp_value_after_mouse_modifier
    }
    fn clamp_value_after_mouse_modifier_mut(&mut self) -> &mut bool {
        &mut self.clamp_value_after_mouse_modifier
    }
    fn enabled_from_start(&self) -> &bool {
        &self.enabled_from_start
    }
    fn enabled_from_start_mut(&mut self) -> &mut bool {
        &mut self.enabled_from_start
    }
    fn send_trigger_events(&self) -> &bool {
        &self.send_trigger_events
    }
    fn send_trigger_events_mut(&mut self) -> &mut bool {
        &mut self.send_trigger_events
    }
    fn hold_down_time(&self) -> &f32 {
        &self.hold_down_time
    }
    fn hold_down_time_mut(&mut self) -> &mut f32 {
        &mut self.hold_down_time
    }
    fn accumulated_value_at_start(&self) -> &f32 {
        &self.accumulated_value_at_start
    }
    fn accumulated_value_at_start_mut(&mut self) -> &mut f32 {
        &mut self.accumulated_value_at_start
    }
    fn trailing_value_at_start(&self) -> &f32 {
        &self.trailing_value_at_start
    }
    fn trailing_value_at_start_mut(&mut self) -> &mut f32 {
        &mut self.trailing_value_at_start
    }
}

impl super::entity::EntityDataTrait for PlayerInputTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerInputTriggerEntityData {
}

impl super::core::DataBusPeerTrait for PlayerInputTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerInputTriggerEntityData {
}

impl super::core::DataContainerTrait for PlayerInputTriggerEntityData {
}

pub static PLAYERINPUTTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerInputTriggerEntityData",
    name_hash: 1837063795,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlayerInputTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerInputTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<PlayerInputTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, realm),
            },
            FieldInfoData {
                name: "EntryInputActions",
                name_hash: 4012574474,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, entry_input_actions),
            },
            FieldInfoData {
                name: "ValueModifier",
                name_hash: 97668313,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, value_modifier),
            },
            FieldInfoData {
                name: "ValueModifierForMouse",
                name_hash: 917494595,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, value_modifier_for_mouse),
            },
            FieldInfoData {
                name: "ClampValueAfterMouseModifier",
                name_hash: 471493903,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, clamp_value_after_mouse_modifier),
            },
            FieldInfoData {
                name: "EnabledFromStart",
                name_hash: 4059145814,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, enabled_from_start),
            },
            FieldInfoData {
                name: "SendTriggerEvents",
                name_hash: 118708318,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, send_trigger_events),
            },
            FieldInfoData {
                name: "HoldDownTime",
                name_hash: 3128876589,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, hold_down_time),
            },
            FieldInfoData {
                name: "AccumulatedValueAtStart",
                name_hash: 421554895,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, accumulated_value_at_start),
            },
            FieldInfoData {
                name: "TrailingValueAtStart",
                name_hash: 3374840281,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, trailing_value_at_start),
            },
        ],
    }),
    array_type: Some(PLAYERINPUTTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerInputTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERINPUTTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERINPUTTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerInputTriggerEntityData-Array",
    name_hash: 809605703,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerInputTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraEnterAreaTriggerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub local_player_id: super::core::LocalPlayerId,
    pub trigger_for_all_players: bool,
    pub auto_start: bool,
    pub update_pass: super::entity::UpdatePass,
    pub time_treshold: f32,
}

pub trait CameraEnterAreaTriggerEntityDataTrait: super::entity::EntityDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
    fn trigger_for_all_players(&self) -> &bool;
    fn trigger_for_all_players_mut(&mut self) -> &mut bool;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn update_pass(&self) -> &super::entity::UpdatePass;
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass;
    fn time_treshold(&self) -> &f32;
    fn time_treshold_mut(&mut self) -> &mut f32;
}

impl CameraEnterAreaTriggerEntityDataTrait for CameraEnterAreaTriggerEntityData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
    fn trigger_for_all_players(&self) -> &bool {
        &self.trigger_for_all_players
    }
    fn trigger_for_all_players_mut(&mut self) -> &mut bool {
        &mut self.trigger_for_all_players
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn update_pass(&self) -> &super::entity::UpdatePass {
        &self.update_pass
    }
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        &mut self.update_pass
    }
    fn time_treshold(&self) -> &f32 {
        &self.time_treshold
    }
    fn time_treshold_mut(&mut self) -> &mut f32 {
        &mut self.time_treshold
    }
}

impl super::entity::EntityDataTrait for CameraEnterAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for CameraEnterAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for CameraEnterAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraEnterAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for CameraEnterAreaTriggerEntityData {
}

pub static CAMERAENTERAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEnterAreaTriggerEntityData",
    name_hash: 2057877616,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraEnterAreaTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraEnterAreaTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<CameraEnterAreaTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                name_hash: 1029133718,
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, local_player_id),
            },
            FieldInfoData {
                name: "TriggerForAllPlayers",
                name_hash: 1682398375,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, trigger_for_all_players),
            },
            FieldInfoData {
                name: "AutoStart",
                name_hash: 792615882,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, auto_start),
            },
            FieldInfoData {
                name: "UpdatePass",
                name_hash: 2270785669,
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, update_pass),
            },
            FieldInfoData {
                name: "TimeTreshold",
                name_hash: 2862696783,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, time_treshold),
            },
        ],
    }),
    array_type: Some(CAMERAENTERAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraEnterAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAENTERAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAENTERAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEnterAreaTriggerEntityData-Array",
    name_hash: 820950596,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraEnterAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IntersectionTriggerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub update_pass: super::entity::UpdatePass,
    pub condition: IntersectionTriggerCondition,
    pub run_once: bool,
    pub enabled: bool,
}

pub trait IntersectionTriggerEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn update_pass(&self) -> &super::entity::UpdatePass;
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass;
    fn condition(&self) -> &IntersectionTriggerCondition;
    fn condition_mut(&mut self) -> &mut IntersectionTriggerCondition;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl IntersectionTriggerEntityDataTrait for IntersectionTriggerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn update_pass(&self) -> &super::entity::UpdatePass {
        &self.update_pass
    }
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        &mut self.update_pass
    }
    fn condition(&self) -> &IntersectionTriggerCondition {
        &self.condition
    }
    fn condition_mut(&mut self) -> &mut IntersectionTriggerCondition {
        &mut self.condition
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for IntersectionTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for IntersectionTriggerEntityData {
}

impl super::core::DataBusPeerTrait for IntersectionTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntersectionTriggerEntityData {
}

impl super::core::DataContainerTrait for IntersectionTriggerEntityData {
}

pub static INTERSECTIONTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntersectionTriggerEntityData",
    name_hash: 679287035,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(IntersectionTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntersectionTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<IntersectionTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntersectionTriggerEntityData, realm),
            },
            FieldInfoData {
                name: "UpdatePass",
                name_hash: 2270785669,
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(IntersectionTriggerEntityData, update_pass),
            },
            FieldInfoData {
                name: "Condition",
                name_hash: 1800624758,
                flags: MemberInfoFlags::new(0),
                field_type: "IntersectionTriggerCondition",
                rust_offset: offset_of!(IntersectionTriggerEntityData, condition),
            },
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IntersectionTriggerEntityData, run_once),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IntersectionTriggerEntityData, enabled),
            },
        ],
    }),
    array_type: Some(INTERSECTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntersectionTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTERSECTIONTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTERSECTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntersectionTriggerEntityData-Array",
    name_hash: 79728847,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntersectionTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum IntersectionTriggerCondition {
    #[default]
    IntersectionTriggerCondition_OneObjectIntersects = 0,
    IntersectionTriggerCondition_AllObjectsIntersect = 1,
}

pub static INTERSECTIONTRIGGERCONDITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntersectionTriggerCondition",
    name_hash: 1246317635,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(INTERSECTIONTRIGGERCONDITION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for IntersectionTriggerCondition {
    fn type_info(&self) -> &'static TypeInfo {
        INTERSECTIONTRIGGERCONDITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INTERSECTIONTRIGGERCONDITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntersectionTriggerCondition-Array",
    name_hash: 1458777975,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntersectionTriggerCondition"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PlayerTakeOverTriggerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub team_id: super::gameplay_sim::TeamId,
    pub time_to_lose_control: f32,
}

pub trait PlayerTakeOverTriggerEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn team_id(&self) -> &super::gameplay_sim::TeamId;
    fn team_id_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn time_to_lose_control(&self) -> &f32;
    fn time_to_lose_control_mut(&mut self) -> &mut f32;
}

impl PlayerTakeOverTriggerEntityDataTrait for PlayerTakeOverTriggerEntityData {
    fn team_id(&self) -> &super::gameplay_sim::TeamId {
        &self.team_id
    }
    fn team_id_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_id
    }
    fn time_to_lose_control(&self) -> &f32 {
        &self.time_to_lose_control
    }
    fn time_to_lose_control_mut(&mut self) -> &mut f32 {
        &mut self.time_to_lose_control
    }
}

impl super::entity::SpatialEntityDataTrait for PlayerTakeOverTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PlayerTakeOverTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerTakeOverTriggerEntityData {
}

impl super::core::DataBusPeerTrait for PlayerTakeOverTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerTakeOverTriggerEntityData {
}

impl super::core::DataContainerTrait for PlayerTakeOverTriggerEntityData {
}

pub static PLAYERTAKEOVERTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerTakeOverTriggerEntityData",
    name_hash: 4224815696,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PlayerTakeOverTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerTakeOverTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<PlayerTakeOverTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TeamId",
                name_hash: 3220374101,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(PlayerTakeOverTriggerEntityData, team_id),
            },
            FieldInfoData {
                name: "TimeToLoseControl",
                name_hash: 3830029753,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerTakeOverTriggerEntityData, time_to_lose_control),
            },
        ],
    }),
    array_type: Some(PLAYERTAKEOVERTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerTakeOverTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERTAKEOVERTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERTAKEOVERTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerTakeOverTriggerEntityData-Array",
    name_hash: 112963812,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerTakeOverTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DamageAreaTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub damage_characters: bool,
    pub damage_vehicles: bool,
    pub damage_characters_in_vehicles: bool,
    pub damage_bangers: bool,
    pub damage_per_second: f32,
    pub damage_time: f32,
    pub exclude_immortal_characters_in_team: bool,
    pub team_of_immortal_characters: super::gameplay_sim::TeamId,
    pub exclude_shielded_soldiers: bool,
    pub is_never_triggered_by_player: bool,
}

pub trait DamageAreaTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn damage_characters(&self) -> &bool;
    fn damage_characters_mut(&mut self) -> &mut bool;
    fn damage_vehicles(&self) -> &bool;
    fn damage_vehicles_mut(&mut self) -> &mut bool;
    fn damage_characters_in_vehicles(&self) -> &bool;
    fn damage_characters_in_vehicles_mut(&mut self) -> &mut bool;
    fn damage_bangers(&self) -> &bool;
    fn damage_bangers_mut(&mut self) -> &mut bool;
    fn damage_per_second(&self) -> &f32;
    fn damage_per_second_mut(&mut self) -> &mut f32;
    fn damage_time(&self) -> &f32;
    fn damage_time_mut(&mut self) -> &mut f32;
    fn exclude_immortal_characters_in_team(&self) -> &bool;
    fn exclude_immortal_characters_in_team_mut(&mut self) -> &mut bool;
    fn team_of_immortal_characters(&self) -> &super::gameplay_sim::TeamId;
    fn team_of_immortal_characters_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn exclude_shielded_soldiers(&self) -> &bool;
    fn exclude_shielded_soldiers_mut(&mut self) -> &mut bool;
    fn is_never_triggered_by_player(&self) -> &bool;
    fn is_never_triggered_by_player_mut(&mut self) -> &mut bool;
}

impl DamageAreaTriggerEntityDataTrait for DamageAreaTriggerEntityData {
    fn damage_characters(&self) -> &bool {
        &self.damage_characters
    }
    fn damage_characters_mut(&mut self) -> &mut bool {
        &mut self.damage_characters
    }
    fn damage_vehicles(&self) -> &bool {
        &self.damage_vehicles
    }
    fn damage_vehicles_mut(&mut self) -> &mut bool {
        &mut self.damage_vehicles
    }
    fn damage_characters_in_vehicles(&self) -> &bool {
        &self.damage_characters_in_vehicles
    }
    fn damage_characters_in_vehicles_mut(&mut self) -> &mut bool {
        &mut self.damage_characters_in_vehicles
    }
    fn damage_bangers(&self) -> &bool {
        &self.damage_bangers
    }
    fn damage_bangers_mut(&mut self) -> &mut bool {
        &mut self.damage_bangers
    }
    fn damage_per_second(&self) -> &f32 {
        &self.damage_per_second
    }
    fn damage_per_second_mut(&mut self) -> &mut f32 {
        &mut self.damage_per_second
    }
    fn damage_time(&self) -> &f32 {
        &self.damage_time
    }
    fn damage_time_mut(&mut self) -> &mut f32 {
        &mut self.damage_time
    }
    fn exclude_immortal_characters_in_team(&self) -> &bool {
        &self.exclude_immortal_characters_in_team
    }
    fn exclude_immortal_characters_in_team_mut(&mut self) -> &mut bool {
        &mut self.exclude_immortal_characters_in_team
    }
    fn team_of_immortal_characters(&self) -> &super::gameplay_sim::TeamId {
        &self.team_of_immortal_characters
    }
    fn team_of_immortal_characters_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_of_immortal_characters
    }
    fn exclude_shielded_soldiers(&self) -> &bool {
        &self.exclude_shielded_soldiers
    }
    fn exclude_shielded_soldiers_mut(&mut self) -> &mut bool {
        &mut self.exclude_shielded_soldiers
    }
    fn is_never_triggered_by_player(&self) -> &bool {
        &self.is_never_triggered_by_player
    }
    fn is_never_triggered_by_player_mut(&mut self) -> &mut bool {
        &mut self.is_never_triggered_by_player
    }
}

impl TriggerEntityDataTrait for DamageAreaTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DamageAreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DamageAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for DamageAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for DamageAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DamageAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for DamageAreaTriggerEntityData {
}

pub static DAMAGEAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageAreaTriggerEntityData",
    name_hash: 3469588362,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DamageAreaTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DamageAreaTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<DamageAreaTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DamageCharacters",
                name_hash: 3682715684,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_characters),
            },
            FieldInfoData {
                name: "DamageVehicles",
                name_hash: 1372095173,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_vehicles),
            },
            FieldInfoData {
                name: "DamageCharactersInVehicles",
                name_hash: 3696943368,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_characters_in_vehicles),
            },
            FieldInfoData {
                name: "DamageBangers",
                name_hash: 2480211808,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_bangers),
            },
            FieldInfoData {
                name: "DamagePerSecond",
                name_hash: 1464141113,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_per_second),
            },
            FieldInfoData {
                name: "DamageTime",
                name_hash: 3581575931,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_time),
            },
            FieldInfoData {
                name: "ExcludeImmortalCharactersInTeam",
                name_hash: 2802150974,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, exclude_immortal_characters_in_team),
            },
            FieldInfoData {
                name: "TeamOfImmortalCharacters",
                name_hash: 1833832214,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, team_of_immortal_characters),
            },
            FieldInfoData {
                name: "ExcludeShieldedSoldiers",
                name_hash: 3210013316,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, exclude_shielded_soldiers),
            },
            FieldInfoData {
                name: "IsNeverTriggeredByPlayer",
                name_hash: 2649185444,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, is_never_triggered_by_player),
            },
        ],
    }),
    array_type: Some(DAMAGEAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DamageAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DAMAGEAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageAreaTriggerEntityData-Array",
    name_hash: 2481164990,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DamageAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClearAreaTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub remove_soldiers: bool,
    pub remove_vehicles: bool,
    pub remove_bangers: bool,
    pub remove_effects: bool,
    pub remove_mesh_proxies: bool,
    pub remove_static_models: bool,
    pub remove_debris_clusters: bool,
    pub exclude_immortal_soldiers_in_team: bool,
    pub team_of_immortal_soldiers: super::gameplay_sim::TeamId,
}

pub trait ClearAreaTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn remove_soldiers(&self) -> &bool;
    fn remove_soldiers_mut(&mut self) -> &mut bool;
    fn remove_vehicles(&self) -> &bool;
    fn remove_vehicles_mut(&mut self) -> &mut bool;
    fn remove_bangers(&self) -> &bool;
    fn remove_bangers_mut(&mut self) -> &mut bool;
    fn remove_effects(&self) -> &bool;
    fn remove_effects_mut(&mut self) -> &mut bool;
    fn remove_mesh_proxies(&self) -> &bool;
    fn remove_mesh_proxies_mut(&mut self) -> &mut bool;
    fn remove_static_models(&self) -> &bool;
    fn remove_static_models_mut(&mut self) -> &mut bool;
    fn remove_debris_clusters(&self) -> &bool;
    fn remove_debris_clusters_mut(&mut self) -> &mut bool;
    fn exclude_immortal_soldiers_in_team(&self) -> &bool;
    fn exclude_immortal_soldiers_in_team_mut(&mut self) -> &mut bool;
    fn team_of_immortal_soldiers(&self) -> &super::gameplay_sim::TeamId;
    fn team_of_immortal_soldiers_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
}

impl ClearAreaTriggerEntityDataTrait for ClearAreaTriggerEntityData {
    fn remove_soldiers(&self) -> &bool {
        &self.remove_soldiers
    }
    fn remove_soldiers_mut(&mut self) -> &mut bool {
        &mut self.remove_soldiers
    }
    fn remove_vehicles(&self) -> &bool {
        &self.remove_vehicles
    }
    fn remove_vehicles_mut(&mut self) -> &mut bool {
        &mut self.remove_vehicles
    }
    fn remove_bangers(&self) -> &bool {
        &self.remove_bangers
    }
    fn remove_bangers_mut(&mut self) -> &mut bool {
        &mut self.remove_bangers
    }
    fn remove_effects(&self) -> &bool {
        &self.remove_effects
    }
    fn remove_effects_mut(&mut self) -> &mut bool {
        &mut self.remove_effects
    }
    fn remove_mesh_proxies(&self) -> &bool {
        &self.remove_mesh_proxies
    }
    fn remove_mesh_proxies_mut(&mut self) -> &mut bool {
        &mut self.remove_mesh_proxies
    }
    fn remove_static_models(&self) -> &bool {
        &self.remove_static_models
    }
    fn remove_static_models_mut(&mut self) -> &mut bool {
        &mut self.remove_static_models
    }
    fn remove_debris_clusters(&self) -> &bool {
        &self.remove_debris_clusters
    }
    fn remove_debris_clusters_mut(&mut self) -> &mut bool {
        &mut self.remove_debris_clusters
    }
    fn exclude_immortal_soldiers_in_team(&self) -> &bool {
        &self.exclude_immortal_soldiers_in_team
    }
    fn exclude_immortal_soldiers_in_team_mut(&mut self) -> &mut bool {
        &mut self.exclude_immortal_soldiers_in_team
    }
    fn team_of_immortal_soldiers(&self) -> &super::gameplay_sim::TeamId {
        &self.team_of_immortal_soldiers
    }
    fn team_of_immortal_soldiers_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_of_immortal_soldiers
    }
}

impl TriggerEntityDataTrait for ClearAreaTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for ClearAreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for ClearAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for ClearAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for ClearAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClearAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for ClearAreaTriggerEntityData {
}

pub static CLEARAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearAreaTriggerEntityData",
    name_hash: 804356152,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ClearAreaTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClearAreaTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<ClearAreaTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RemoveSoldiers",
                name_hash: 466109562,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_soldiers),
            },
            FieldInfoData {
                name: "RemoveVehicles",
                name_hash: 2903248424,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_vehicles),
            },
            FieldInfoData {
                name: "RemoveBangers",
                name_hash: 708015725,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_bangers),
            },
            FieldInfoData {
                name: "RemoveEffects",
                name_hash: 234155399,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_effects),
            },
            FieldInfoData {
                name: "RemoveMeshProxies",
                name_hash: 539264666,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_mesh_proxies),
            },
            FieldInfoData {
                name: "RemoveStaticModels",
                name_hash: 521881607,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_static_models),
            },
            FieldInfoData {
                name: "RemoveDebrisClusters",
                name_hash: 2304161393,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_debris_clusters),
            },
            FieldInfoData {
                name: "ExcludeImmortalSoldiersInTeam",
                name_hash: 1181765645,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, exclude_immortal_soldiers_in_team),
            },
            FieldInfoData {
                name: "TeamOfImmortalSoldiers",
                name_hash: 3105392997,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, team_of_immortal_soldiers),
            },
        ],
    }),
    array_type: Some(CLEARAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ClearAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLEARAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLEARAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearAreaTriggerEntityData-Array",
    name_hash: 1214359948,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClearAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleStateTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub lock_amount: f32,
    pub allow_human_to_enter_all_seats: bool,
    pub restrict_human_to_specific_seat: bool,
    pub seat_specific_index_for_human: u32,
    pub allow_ai_to_enter_all_seats: bool,
    pub ban_ai_from_specific_seat: bool,
    pub seat_specific_index_for_ai: u32,
    pub bullet_count: u32,
    pub health_to_set: u32,
    pub health_to_check: u32,
    pub trigger_critical_on_health_set: bool,
    pub check_health_greater_or_equal: bool,
    pub destruction_radius: f32,
    pub should_destroy_vehicles: bool,
    pub should_destroy_bangers: bool,
}

pub trait VehicleStateTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn lock_amount(&self) -> &f32;
    fn lock_amount_mut(&mut self) -> &mut f32;
    fn allow_human_to_enter_all_seats(&self) -> &bool;
    fn allow_human_to_enter_all_seats_mut(&mut self) -> &mut bool;
    fn restrict_human_to_specific_seat(&self) -> &bool;
    fn restrict_human_to_specific_seat_mut(&mut self) -> &mut bool;
    fn seat_specific_index_for_human(&self) -> &u32;
    fn seat_specific_index_for_human_mut(&mut self) -> &mut u32;
    fn allow_ai_to_enter_all_seats(&self) -> &bool;
    fn allow_ai_to_enter_all_seats_mut(&mut self) -> &mut bool;
    fn ban_ai_from_specific_seat(&self) -> &bool;
    fn ban_ai_from_specific_seat_mut(&mut self) -> &mut bool;
    fn seat_specific_index_for_ai(&self) -> &u32;
    fn seat_specific_index_for_ai_mut(&mut self) -> &mut u32;
    fn bullet_count(&self) -> &u32;
    fn bullet_count_mut(&mut self) -> &mut u32;
    fn health_to_set(&self) -> &u32;
    fn health_to_set_mut(&mut self) -> &mut u32;
    fn health_to_check(&self) -> &u32;
    fn health_to_check_mut(&mut self) -> &mut u32;
    fn trigger_critical_on_health_set(&self) -> &bool;
    fn trigger_critical_on_health_set_mut(&mut self) -> &mut bool;
    fn check_health_greater_or_equal(&self) -> &bool;
    fn check_health_greater_or_equal_mut(&mut self) -> &mut bool;
    fn destruction_radius(&self) -> &f32;
    fn destruction_radius_mut(&mut self) -> &mut f32;
    fn should_destroy_vehicles(&self) -> &bool;
    fn should_destroy_vehicles_mut(&mut self) -> &mut bool;
    fn should_destroy_bangers(&self) -> &bool;
    fn should_destroy_bangers_mut(&mut self) -> &mut bool;
}

impl VehicleStateTriggerEntityDataTrait for VehicleStateTriggerEntityData {
    fn lock_amount(&self) -> &f32 {
        &self.lock_amount
    }
    fn lock_amount_mut(&mut self) -> &mut f32 {
        &mut self.lock_amount
    }
    fn allow_human_to_enter_all_seats(&self) -> &bool {
        &self.allow_human_to_enter_all_seats
    }
    fn allow_human_to_enter_all_seats_mut(&mut self) -> &mut bool {
        &mut self.allow_human_to_enter_all_seats
    }
    fn restrict_human_to_specific_seat(&self) -> &bool {
        &self.restrict_human_to_specific_seat
    }
    fn restrict_human_to_specific_seat_mut(&mut self) -> &mut bool {
        &mut self.restrict_human_to_specific_seat
    }
    fn seat_specific_index_for_human(&self) -> &u32 {
        &self.seat_specific_index_for_human
    }
    fn seat_specific_index_for_human_mut(&mut self) -> &mut u32 {
        &mut self.seat_specific_index_for_human
    }
    fn allow_ai_to_enter_all_seats(&self) -> &bool {
        &self.allow_ai_to_enter_all_seats
    }
    fn allow_ai_to_enter_all_seats_mut(&mut self) -> &mut bool {
        &mut self.allow_ai_to_enter_all_seats
    }
    fn ban_ai_from_specific_seat(&self) -> &bool {
        &self.ban_ai_from_specific_seat
    }
    fn ban_ai_from_specific_seat_mut(&mut self) -> &mut bool {
        &mut self.ban_ai_from_specific_seat
    }
    fn seat_specific_index_for_ai(&self) -> &u32 {
        &self.seat_specific_index_for_ai
    }
    fn seat_specific_index_for_ai_mut(&mut self) -> &mut u32 {
        &mut self.seat_specific_index_for_ai
    }
    fn bullet_count(&self) -> &u32 {
        &self.bullet_count
    }
    fn bullet_count_mut(&mut self) -> &mut u32 {
        &mut self.bullet_count
    }
    fn health_to_set(&self) -> &u32 {
        &self.health_to_set
    }
    fn health_to_set_mut(&mut self) -> &mut u32 {
        &mut self.health_to_set
    }
    fn health_to_check(&self) -> &u32 {
        &self.health_to_check
    }
    fn health_to_check_mut(&mut self) -> &mut u32 {
        &mut self.health_to_check
    }
    fn trigger_critical_on_health_set(&self) -> &bool {
        &self.trigger_critical_on_health_set
    }
    fn trigger_critical_on_health_set_mut(&mut self) -> &mut bool {
        &mut self.trigger_critical_on_health_set
    }
    fn check_health_greater_or_equal(&self) -> &bool {
        &self.check_health_greater_or_equal
    }
    fn check_health_greater_or_equal_mut(&mut self) -> &mut bool {
        &mut self.check_health_greater_or_equal
    }
    fn destruction_radius(&self) -> &f32 {
        &self.destruction_radius
    }
    fn destruction_radius_mut(&mut self) -> &mut f32 {
        &mut self.destruction_radius
    }
    fn should_destroy_vehicles(&self) -> &bool {
        &self.should_destroy_vehicles
    }
    fn should_destroy_vehicles_mut(&mut self) -> &mut bool {
        &mut self.should_destroy_vehicles
    }
    fn should_destroy_bangers(&self) -> &bool {
        &self.should_destroy_bangers
    }
    fn should_destroy_bangers_mut(&mut self) -> &mut bool {
        &mut self.should_destroy_bangers
    }
}

impl TriggerEntityDataTrait for VehicleStateTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for VehicleStateTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for VehicleStateTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for VehicleStateTriggerEntityData {
}

impl super::core::DataBusPeerTrait for VehicleStateTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleStateTriggerEntityData {
}

impl super::core::DataContainerTrait for VehicleStateTriggerEntityData {
}

pub static VEHICLESTATETRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleStateTriggerEntityData",
    name_hash: 869710329,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleStateTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleStateTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<VehicleStateTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "LockAmount",
                name_hash: 1911182178,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, lock_amount),
            },
            FieldInfoData {
                name: "AllowHumanToEnterAllSeats",
                name_hash: 1793202945,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, allow_human_to_enter_all_seats),
            },
            FieldInfoData {
                name: "RestrictHumanToSpecificSeat",
                name_hash: 3516468286,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, restrict_human_to_specific_seat),
            },
            FieldInfoData {
                name: "SeatSpecificIndexForHuman",
                name_hash: 3193401916,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, seat_specific_index_for_human),
            },
            FieldInfoData {
                name: "AllowAiToEnterAllSeats",
                name_hash: 2314846518,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, allow_ai_to_enter_all_seats),
            },
            FieldInfoData {
                name: "BanAiFromSpecificSeat",
                name_hash: 1238752085,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, ban_ai_from_specific_seat),
            },
            FieldInfoData {
                name: "SeatSpecificIndexForAi",
                name_hash: 1335416267,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, seat_specific_index_for_ai),
            },
            FieldInfoData {
                name: "BulletCount",
                name_hash: 3022064768,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, bullet_count),
            },
            FieldInfoData {
                name: "HealthToSet",
                name_hash: 2415816000,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, health_to_set),
            },
            FieldInfoData {
                name: "HealthToCheck",
                name_hash: 2284800324,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, health_to_check),
            },
            FieldInfoData {
                name: "TriggerCriticalOnHealthSet",
                name_hash: 1831040713,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, trigger_critical_on_health_set),
            },
            FieldInfoData {
                name: "CheckHealthGreaterOrEqual",
                name_hash: 1235807484,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, check_health_greater_or_equal),
            },
            FieldInfoData {
                name: "DestructionRadius",
                name_hash: 3165645571,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, destruction_radius),
            },
            FieldInfoData {
                name: "ShouldDestroyVehicles",
                name_hash: 2908980741,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, should_destroy_vehicles),
            },
            FieldInfoData {
                name: "ShouldDestroyBangers",
                name_hash: 565605152,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, should_destroy_bangers),
            },
        ],
    }),
    array_type: Some(VEHICLESTATETRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleStateTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLESTATETRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLESTATETRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleStateTriggerEntityData-Array",
    name_hash: 895662285,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleStateTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterPoseAction {
    #[default]
    CPTNoAction = 0,
    CPTForceToStand = 1,
    CPTForceToCroch = 2,
    CPTForceToProne = 3,
}

pub static CHARACTERPOSEACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseAction",
    name_hash: 3905168139,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERPOSEACTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterPoseAction {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERPOSEACTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHARACTERPOSEACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseAction-Array",
    name_hash: 2670965183,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterPoseAction"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DelayTriggerEntityData {
    pub _glacier_base: TriggerEventEntityData,
    pub auto_trigger_event: bool,
}

pub trait DelayTriggerEntityDataTrait: TriggerEventEntityDataTrait {
    fn auto_trigger_event(&self) -> &bool;
    fn auto_trigger_event_mut(&mut self) -> &mut bool;
}

impl DelayTriggerEntityDataTrait for DelayTriggerEntityData {
    fn auto_trigger_event(&self) -> &bool {
        &self.auto_trigger_event
    }
    fn auto_trigger_event_mut(&mut self) -> &mut bool {
        &mut self.auto_trigger_event
    }
}

impl TriggerEventEntityDataTrait for DelayTriggerEntityData {
}

impl TriggerEntityDataTrait for DelayTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DelayTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DelayTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for DelayTriggerEntityData {
}

impl super::core::DataBusPeerTrait for DelayTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DelayTriggerEntityData {
}

impl super::core::DataContainerTrait for DelayTriggerEntityData {
}

pub static DELAYTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayTriggerEntityData",
    name_hash: 69202115,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGEREVENTENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DelayTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DelayTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<DelayTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AutoTriggerEvent",
                name_hash: 2983396190,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DelayTriggerEntityData, auto_trigger_event),
            },
        ],
    }),
    array_type: Some(DELAYTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DelayTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DELAYTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELAYTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayTriggerEntityData-Array",
    name_hash: 1699951607,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DelayTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MultipleTriggerEntityData {
    pub _glacier_base: TriggerEventEntityData,
    pub trigger_amount: i32,
}

pub trait MultipleTriggerEntityDataTrait: TriggerEventEntityDataTrait {
    fn trigger_amount(&self) -> &i32;
    fn trigger_amount_mut(&mut self) -> &mut i32;
}

impl MultipleTriggerEntityDataTrait for MultipleTriggerEntityData {
    fn trigger_amount(&self) -> &i32 {
        &self.trigger_amount
    }
    fn trigger_amount_mut(&mut self) -> &mut i32 {
        &mut self.trigger_amount
    }
}

impl TriggerEventEntityDataTrait for MultipleTriggerEntityData {
}

impl TriggerEntityDataTrait for MultipleTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for MultipleTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for MultipleTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for MultipleTriggerEntityData {
}

impl super::core::DataBusPeerTrait for MultipleTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MultipleTriggerEntityData {
}

impl super::core::DataContainerTrait for MultipleTriggerEntityData {
}

pub static MULTIPLETRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTriggerEntityData",
    name_hash: 2962937958,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGEREVENTENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(MultipleTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultipleTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<MultipleTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TriggerAmount",
                name_hash: 2589587985,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleTriggerEntityData, trigger_amount),
            },
        ],
    }),
    array_type: Some(MULTIPLETRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MultipleTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTIPLETRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTIPLETRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTriggerEntityData-Array",
    name_hash: 3344037202,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MultipleTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TriggerEventEntityData {
    pub _glacier_base: TriggerEntityData,
}

pub trait TriggerEventEntityDataTrait: TriggerEntityDataTrait {
}

impl TriggerEventEntityDataTrait for TriggerEventEntityData {
}

impl TriggerEntityDataTrait for TriggerEventEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for TriggerEventEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TriggerEventEntityData {
}

impl super::entity::GameObjectDataTrait for TriggerEventEntityData {
}

impl super::core::DataBusPeerTrait for TriggerEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TriggerEventEntityData {
}

impl super::core::DataContainerTrait for TriggerEventEntityData {
}

pub static TRIGGEREVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerEventEntityData",
    name_hash: 47865018,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TriggerEventEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TriggerEventEntityData as Default>::default())),
            create_boxed: || Box::new(<TriggerEventEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRIGGEREVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TriggerEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRIGGEREVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRIGGEREVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerEventEntityData-Array",
    name_hash: 3436601102,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TriggerEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CombatActionTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub time_to_trigger_on_no_action: f32,
}

pub trait CombatActionTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn time_to_trigger_on_no_action(&self) -> &f32;
    fn time_to_trigger_on_no_action_mut(&mut self) -> &mut f32;
}

impl CombatActionTriggerEntityDataTrait for CombatActionTriggerEntityData {
    fn time_to_trigger_on_no_action(&self) -> &f32 {
        &self.time_to_trigger_on_no_action
    }
    fn time_to_trigger_on_no_action_mut(&mut self) -> &mut f32 {
        &mut self.time_to_trigger_on_no_action
    }
}

impl TriggerEntityDataTrait for CombatActionTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for CombatActionTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CombatActionTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for CombatActionTriggerEntityData {
}

impl super::core::DataBusPeerTrait for CombatActionTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CombatActionTriggerEntityData {
}

impl super::core::DataContainerTrait for CombatActionTriggerEntityData {
}

pub static COMBATACTIONTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatActionTriggerEntityData",
    name_hash: 3727682110,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(CombatActionTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CombatActionTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<CombatActionTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TimeToTriggerOnNoAction",
                name_hash: 1868121293,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatActionTriggerEntityData, time_to_trigger_on_no_action),
            },
        ],
    }),
    array_type: Some(COMBATACTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CombatActionTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMBATACTIONTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMBATACTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatActionTriggerEntityData-Array",
    name_hash: 2243934858,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CombatActionTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GeometryTriggerEntityData {
    pub _glacier_base: AreaTriggerEntityData,
}

pub trait GeometryTriggerEntityDataTrait: AreaTriggerEntityDataTrait {
}

impl GeometryTriggerEntityDataTrait for GeometryTriggerEntityData {
}

impl AreaTriggerEntityDataTrait for GeometryTriggerEntityData {
    fn geometry_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.geometry_transform()
    }
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.geometry_transform_mut()
    }
    fn include(&self) -> &AreaTriggerInclude {
        self._glacier_base.include()
    }
    fn include_mut(&mut self) -> &mut AreaTriggerInclude {
        self._glacier_base.include_mut()
    }
    fn use_character_entity(&self) -> &bool {
        self._glacier_base.use_character_entity()
    }
    fn use_character_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.use_character_entity_mut()
    }
    fn radius(&self) -> &f32 {
        self._glacier_base.radius()
    }
    fn radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.radius_mut()
    }
    fn use_radius_with_geometry_transform(&self) -> &bool {
        self._glacier_base.use_radius_with_geometry_transform()
    }
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_radius_with_geometry_transform_mut()
    }
    fn geometries_follow_object(&self) -> &bool {
        self._glacier_base.geometries_follow_object()
    }
    fn geometries_follow_object_mut(&mut self) -> &mut bool {
        self._glacier_base.geometries_follow_object_mut()
    }
    fn inside_area_event_repeat_time(&self) -> &f32 {
        self._glacier_base.inside_area_event_repeat_time()
    }
    fn inside_area_event_repeat_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.inside_area_event_repeat_time_mut()
    }
    fn one_inside_area_event_per_soldier(&self) -> &bool {
        self._glacier_base.one_inside_area_event_per_soldier()
    }
    fn one_inside_area_event_per_soldier_mut(&mut self) -> &mut bool {
        self._glacier_base.one_inside_area_event_per_soldier_mut()
    }
    fn trigger_only_on_leave(&self) -> &bool {
        self._glacier_base.trigger_only_on_leave()
    }
    fn trigger_only_on_leave_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_only_on_leave_mut()
    }
    fn reset_on_enable(&self) -> &bool {
        self._glacier_base.reset_on_enable()
    }
    fn reset_on_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_on_enable_mut()
    }
    fn trigger_on_leave_on_death(&self) -> &bool {
        self._glacier_base.trigger_on_leave_on_death()
    }
    fn trigger_on_leave_on_death_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_leave_on_death_mut()
    }
    fn trigger_on_leave_on_disable(&self) -> &bool {
        self._glacier_base.trigger_on_leave_on_disable()
    }
    fn trigger_on_leave_on_disable_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_leave_on_disable_mut()
    }
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.team_of_allies()
    }
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.team_of_allies_mut()
    }
}

impl TriggerEntityDataTrait for GeometryTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for GeometryTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for GeometryTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for GeometryTriggerEntityData {
}

impl super::core::DataBusPeerTrait for GeometryTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GeometryTriggerEntityData {
}

impl super::core::DataContainerTrait for GeometryTriggerEntityData {
}

pub static GEOMETRYTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GeometryTriggerEntityData",
    name_hash: 758857868,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AREATRIGGERENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(GeometryTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GeometryTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<GeometryTriggerEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GEOMETRYTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GeometryTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GEOMETRYTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GEOMETRYTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GeometryTriggerEntityData-Array",
    name_hash: 3257356472,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GeometryTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AreaTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub geometry_transform: super::core::LinearTransform,
    pub include: AreaTriggerInclude,
    pub use_character_entity: bool,
    pub radius: f32,
    pub use_radius_with_geometry_transform: bool,
    pub geometries_follow_object: bool,
    pub inside_area_event_repeat_time: f32,
    pub one_inside_area_event_per_soldier: bool,
    pub trigger_only_on_leave: bool,
    pub reset_on_enable: bool,
    pub trigger_on_leave_on_death: bool,
    pub trigger_on_leave_on_disable: bool,
    pub team_of_allies: super::gameplay_sim::TeamId,
}

pub trait AreaTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn geometry_transform(&self) -> &super::core::LinearTransform;
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn include(&self) -> &AreaTriggerInclude;
    fn include_mut(&mut self) -> &mut AreaTriggerInclude;
    fn use_character_entity(&self) -> &bool;
    fn use_character_entity_mut(&mut self) -> &mut bool;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn use_radius_with_geometry_transform(&self) -> &bool;
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool;
    fn geometries_follow_object(&self) -> &bool;
    fn geometries_follow_object_mut(&mut self) -> &mut bool;
    fn inside_area_event_repeat_time(&self) -> &f32;
    fn inside_area_event_repeat_time_mut(&mut self) -> &mut f32;
    fn one_inside_area_event_per_soldier(&self) -> &bool;
    fn one_inside_area_event_per_soldier_mut(&mut self) -> &mut bool;
    fn trigger_only_on_leave(&self) -> &bool;
    fn trigger_only_on_leave_mut(&mut self) -> &mut bool;
    fn reset_on_enable(&self) -> &bool;
    fn reset_on_enable_mut(&mut self) -> &mut bool;
    fn trigger_on_leave_on_death(&self) -> &bool;
    fn trigger_on_leave_on_death_mut(&mut self) -> &mut bool;
    fn trigger_on_leave_on_disable(&self) -> &bool;
    fn trigger_on_leave_on_disable_mut(&mut self) -> &mut bool;
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId;
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
}

impl AreaTriggerEntityDataTrait for AreaTriggerEntityData {
    fn geometry_transform(&self) -> &super::core::LinearTransform {
        &self.geometry_transform
    }
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.geometry_transform
    }
    fn include(&self) -> &AreaTriggerInclude {
        &self.include
    }
    fn include_mut(&mut self) -> &mut AreaTriggerInclude {
        &mut self.include
    }
    fn use_character_entity(&self) -> &bool {
        &self.use_character_entity
    }
    fn use_character_entity_mut(&mut self) -> &mut bool {
        &mut self.use_character_entity
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn use_radius_with_geometry_transform(&self) -> &bool {
        &self.use_radius_with_geometry_transform
    }
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool {
        &mut self.use_radius_with_geometry_transform
    }
    fn geometries_follow_object(&self) -> &bool {
        &self.geometries_follow_object
    }
    fn geometries_follow_object_mut(&mut self) -> &mut bool {
        &mut self.geometries_follow_object
    }
    fn inside_area_event_repeat_time(&self) -> &f32 {
        &self.inside_area_event_repeat_time
    }
    fn inside_area_event_repeat_time_mut(&mut self) -> &mut f32 {
        &mut self.inside_area_event_repeat_time
    }
    fn one_inside_area_event_per_soldier(&self) -> &bool {
        &self.one_inside_area_event_per_soldier
    }
    fn one_inside_area_event_per_soldier_mut(&mut self) -> &mut bool {
        &mut self.one_inside_area_event_per_soldier
    }
    fn trigger_only_on_leave(&self) -> &bool {
        &self.trigger_only_on_leave
    }
    fn trigger_only_on_leave_mut(&mut self) -> &mut bool {
        &mut self.trigger_only_on_leave
    }
    fn reset_on_enable(&self) -> &bool {
        &self.reset_on_enable
    }
    fn reset_on_enable_mut(&mut self) -> &mut bool {
        &mut self.reset_on_enable
    }
    fn trigger_on_leave_on_death(&self) -> &bool {
        &self.trigger_on_leave_on_death
    }
    fn trigger_on_leave_on_death_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_leave_on_death
    }
    fn trigger_on_leave_on_disable(&self) -> &bool {
        &self.trigger_on_leave_on_disable
    }
    fn trigger_on_leave_on_disable_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_leave_on_disable
    }
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId {
        &self.team_of_allies
    }
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_of_allies
    }
}

impl TriggerEntityDataTrait for AreaTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for AreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for AreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for AreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for AreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AreaTriggerEntityData {
}

impl super::core::DataContainerTrait for AreaTriggerEntityData {
}

pub static AREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaTriggerEntityData",
    name_hash: 1226419329,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AreaTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AreaTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<AreaTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "GeometryTransform",
                name_hash: 2190311347,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AreaTriggerEntityData, geometry_transform),
            },
            FieldInfoData {
                name: "Include",
                name_hash: 1669541689,
                flags: MemberInfoFlags::new(0),
                field_type: "AreaTriggerInclude",
                rust_offset: offset_of!(AreaTriggerEntityData, include),
            },
            FieldInfoData {
                name: "UseCharacterEntity",
                name_hash: 3044350724,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, use_character_entity),
            },
            FieldInfoData {
                name: "Radius",
                name_hash: 3298407133,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaTriggerEntityData, radius),
            },
            FieldInfoData {
                name: "UseRadiusWithGeometryTransform",
                name_hash: 2458636042,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, use_radius_with_geometry_transform),
            },
            FieldInfoData {
                name: "GeometriesFollowObject",
                name_hash: 2947657501,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, geometries_follow_object),
            },
            FieldInfoData {
                name: "InsideAreaEventRepeatTime",
                name_hash: 287904832,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaTriggerEntityData, inside_area_event_repeat_time),
            },
            FieldInfoData {
                name: "OneInsideAreaEventPerSoldier",
                name_hash: 1525530667,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, one_inside_area_event_per_soldier),
            },
            FieldInfoData {
                name: "TriggerOnlyOnLeave",
                name_hash: 1941446419,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, trigger_only_on_leave),
            },
            FieldInfoData {
                name: "ResetOnEnable",
                name_hash: 3898886736,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, reset_on_enable),
            },
            FieldInfoData {
                name: "TriggerOnLeaveOnDeath",
                name_hash: 2131908922,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, trigger_on_leave_on_death),
            },
            FieldInfoData {
                name: "TriggerOnLeaveOnDisable",
                name_hash: 2543745682,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, trigger_on_leave_on_disable),
            },
            FieldInfoData {
                name: "TeamOfAllies",
                name_hash: 3315237551,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(AreaTriggerEntityData, team_of_allies),
            },
        ],
    }),
    array_type: Some(AREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaTriggerEntityData-Array",
    name_hash: 3056764469,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AreaTriggerInclude {
    #[default]
    ATNone = 0,
    ATAll = 1,
    ATPlayers = 2,
    ATAI = 3,
    ATAI_Allies = 4,
    ATAI_Enemies = 5,
    ATAllies = 6,
    ATEnemies = 7,
}

pub static AREATRIGGERINCLUDE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaTriggerInclude",
    name_hash: 3502424566,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(AREATRIGGERINCLUDE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AreaTriggerInclude {
    fn type_info(&self) -> &'static TypeInfo {
        AREATRIGGERINCLUDE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AREATRIGGERINCLUDE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaTriggerInclude-Array",
    name_hash: 917882562,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaTriggerInclude"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TriggerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub delay: f32,
    pub run_once: bool,
    pub enabled: bool,
}

pub trait TriggerEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn delay(&self) -> &f32;
    fn delay_mut(&mut self) -> &mut f32;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl TriggerEntityDataTrait for TriggerEntityData {
    fn delay(&self) -> &f32 {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut f32 {
        &mut self.delay
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for TriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TriggerEntityData {
}

impl super::entity::GameObjectDataTrait for TriggerEntityData {
}

impl super::core::DataBusPeerTrait for TriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TriggerEntityData {
}

impl super::core::DataContainerTrait for TriggerEntityData {
}

pub static TRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerEntityData",
    name_hash: 2879308630,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<TriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Delay",
                name_hash: 208768368,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TriggerEntityData, delay),
            },
            FieldInfoData {
                name: "RunOnce",
                name_hash: 709901739,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TriggerEntityData, run_once),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TriggerEntityData, enabled),
            },
        ],
    }),
    array_type: Some(TRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerEntityData-Array",
    name_hash: 1029818594,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestPartBoundingBoxEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub first_vertex_indices: Vec<u32>,
    pub vertex_positions: Vec<BoxedTypeObject /* super::core::Vec3 */>,
}

pub trait TestPartBoundingBoxEntityDataTrait: super::entity::EntityDataTrait {
    fn first_vertex_indices(&self) -> &Vec<u32>;
    fn first_vertex_indices_mut(&mut self) -> &mut Vec<u32>;
    fn vertex_positions(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */>;
    fn vertex_positions_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */>;
}

impl TestPartBoundingBoxEntityDataTrait for TestPartBoundingBoxEntityData {
    fn first_vertex_indices(&self) -> &Vec<u32> {
        &self.first_vertex_indices
    }
    fn first_vertex_indices_mut(&mut self) -> &mut Vec<u32> {
        &mut self.first_vertex_indices
    }
    fn vertex_positions(&self) -> &Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &self.vertex_positions
    }
    fn vertex_positions_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::Vec3 */> {
        &mut self.vertex_positions
    }
}

impl super::entity::EntityDataTrait for TestPartBoundingBoxEntityData {
}

impl super::entity::GameObjectDataTrait for TestPartBoundingBoxEntityData {
}

impl super::core::DataBusPeerTrait for TestPartBoundingBoxEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestPartBoundingBoxEntityData {
}

impl super::core::DataContainerTrait for TestPartBoundingBoxEntityData {
}

pub static TESTPARTBOUNDINGBOXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPartBoundingBoxEntityData",
    name_hash: 3956277992,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestPartBoundingBoxEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestPartBoundingBoxEntityData as Default>::default())),
            create_boxed: || Box::new(<TestPartBoundingBoxEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FirstVertexIndices",
                name_hash: 2737262792,
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(TestPartBoundingBoxEntityData, first_vertex_indices),
            },
            FieldInfoData {
                name: "VertexPositions",
                name_hash: 3277317959,
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(TestPartBoundingBoxEntityData, vertex_positions),
            },
        ],
    }),
    array_type: Some(TESTPARTBOUNDINGBOXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestPartBoundingBoxEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTPARTBOUNDINGBOXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTPARTBOUNDINGBOXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPartBoundingBoxEntityData-Array",
    name_hash: 3908072668,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestPartBoundingBoxEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AssertTimeBombEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub auto_arm: bool,
    pub delay: f32,
}

pub trait AssertTimeBombEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn auto_arm(&self) -> &bool;
    fn auto_arm_mut(&mut self) -> &mut bool;
    fn delay(&self) -> &f32;
    fn delay_mut(&mut self) -> &mut f32;
}

impl AssertTimeBombEntityDataTrait for AssertTimeBombEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn auto_arm(&self) -> &bool {
        &self.auto_arm
    }
    fn auto_arm_mut(&mut self) -> &mut bool {
        &mut self.auto_arm
    }
    fn delay(&self) -> &f32 {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut f32 {
        &mut self.delay
    }
}

impl super::entity::SpatialEntityDataTrait for AssertTimeBombEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for AssertTimeBombEntityData {
}

impl super::entity::GameObjectDataTrait for AssertTimeBombEntityData {
}

impl super::core::DataBusPeerTrait for AssertTimeBombEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AssertTimeBombEntityData {
}

impl super::core::DataContainerTrait for AssertTimeBombEntityData {
}

pub static ASSERTTIMEBOMBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertTimeBombEntityData",
    name_hash: 4068120155,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AssertTimeBombEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AssertTimeBombEntityData as Default>::default())),
            create_boxed: || Box::new(<AssertTimeBombEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AssertTimeBombEntityData, realm),
            },
            FieldInfoData {
                name: "AutoArm",
                name_hash: 888099284,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AssertTimeBombEntityData, auto_arm),
            },
            FieldInfoData {
                name: "Delay",
                name_hash: 208768368,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AssertTimeBombEntityData, delay),
            },
        ],
    }),
    array_type: Some(ASSERTTIMEBOMBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AssertTimeBombEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ASSERTTIMEBOMBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ASSERTTIMEBOMBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertTimeBombEntityData-Array",
    name_hash: 126229871,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AssertTimeBombEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AssertTimeBombBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
}

pub trait AssertTimeBombBlueprintTrait: super::entity::ObjectBlueprintTrait {
}

impl AssertTimeBombBlueprintTrait for AssertTimeBombBlueprint {
}

impl super::entity::ObjectBlueprintTrait for AssertTimeBombBlueprint {
    fn object(&self) -> &Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::EntityData */> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for AssertTimeBombBlueprint {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<LockedTypeObject /* super::schematics::SchematicsBaseAsset */> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for AssertTimeBombBlueprint {
    fn event_connections(&self) -> &Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::entity::EventConnection */> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for AssertTimeBombBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::PropertyConnection */> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::LinkConnection */> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<LockedTypeObject /* super::core::DynamicDataContainer */> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for AssertTimeBombBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AssertTimeBombBlueprint {
}

pub static ASSERTTIMEBOMBBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertTimeBombBlueprint",
    name_hash: 2245151583,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        super_class_offset: offset_of!(AssertTimeBombBlueprint, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AssertTimeBombBlueprint as Default>::default())),
            create_boxed: || Box::new(<AssertTimeBombBlueprint as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(ASSERTTIMEBOMBBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AssertTimeBombBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        ASSERTTIMEBOMBBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ASSERTTIMEBOMBBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertTimeBombBlueprint-Array",
    name_hash: 2387689579,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AssertTimeBombBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AttachmentVerificationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub entity1_bone_name: String,
    pub entity2_bone_name: String,
    pub entity2_offset: super::core::LinearTransform,
    pub epsilon: f32,
    pub fire_assert: bool,
    pub fail_continuously: bool,
}

pub trait AttachmentVerificationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn entity1_bone_name(&self) -> &String;
    fn entity1_bone_name_mut(&mut self) -> &mut String;
    fn entity2_bone_name(&self) -> &String;
    fn entity2_bone_name_mut(&mut self) -> &mut String;
    fn entity2_offset(&self) -> &super::core::LinearTransform;
    fn entity2_offset_mut(&mut self) -> &mut super::core::LinearTransform;
    fn epsilon(&self) -> &f32;
    fn epsilon_mut(&mut self) -> &mut f32;
    fn fire_assert(&self) -> &bool;
    fn fire_assert_mut(&mut self) -> &mut bool;
    fn fail_continuously(&self) -> &bool;
    fn fail_continuously_mut(&mut self) -> &mut bool;
}

impl AttachmentVerificationEntityDataTrait for AttachmentVerificationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn entity1_bone_name(&self) -> &String {
        &self.entity1_bone_name
    }
    fn entity1_bone_name_mut(&mut self) -> &mut String {
        &mut self.entity1_bone_name
    }
    fn entity2_bone_name(&self) -> &String {
        &self.entity2_bone_name
    }
    fn entity2_bone_name_mut(&mut self) -> &mut String {
        &mut self.entity2_bone_name
    }
    fn entity2_offset(&self) -> &super::core::LinearTransform {
        &self.entity2_offset
    }
    fn entity2_offset_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity2_offset
    }
    fn epsilon(&self) -> &f32 {
        &self.epsilon
    }
    fn epsilon_mut(&mut self) -> &mut f32 {
        &mut self.epsilon
    }
    fn fire_assert(&self) -> &bool {
        &self.fire_assert
    }
    fn fire_assert_mut(&mut self) -> &mut bool {
        &mut self.fire_assert
    }
    fn fail_continuously(&self) -> &bool {
        &self.fail_continuously
    }
    fn fail_continuously_mut(&mut self) -> &mut bool {
        &mut self.fail_continuously
    }
}

impl super::entity::EntityDataTrait for AttachmentVerificationEntityData {
}

impl super::entity::GameObjectDataTrait for AttachmentVerificationEntityData {
}

impl super::core::DataBusPeerTrait for AttachmentVerificationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AttachmentVerificationEntityData {
}

impl super::core::DataContainerTrait for AttachmentVerificationEntityData {
}

pub static ATTACHMENTVERIFICATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttachmentVerificationEntityData",
    name_hash: 1869594382,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AttachmentVerificationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AttachmentVerificationEntityData as Default>::default())),
            create_boxed: || Box::new(<AttachmentVerificationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AttachmentVerificationEntityData, realm),
            },
            FieldInfoData {
                name: "Entity1BoneName",
                name_hash: 80230670,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AttachmentVerificationEntityData, entity1_bone_name),
            },
            FieldInfoData {
                name: "Entity2BoneName",
                name_hash: 3191326925,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AttachmentVerificationEntityData, entity2_bone_name),
            },
            FieldInfoData {
                name: "Entity2Offset",
                name_hash: 229772289,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AttachmentVerificationEntityData, entity2_offset),
            },
            FieldInfoData {
                name: "Epsilon",
                name_hash: 211647143,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttachmentVerificationEntityData, epsilon),
            },
            FieldInfoData {
                name: "FireAssert",
                name_hash: 297441247,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AttachmentVerificationEntityData, fire_assert),
            },
            FieldInfoData {
                name: "FailContinuously",
                name_hash: 3872323967,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AttachmentVerificationEntityData, fail_continuously),
            },
        ],
    }),
    array_type: Some(ATTACHMENTVERIFICATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AttachmentVerificationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ATTACHMENTVERIFICATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ATTACHMENTVERIFICATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttachmentVerificationEntityData-Array",
    name_hash: 470607930,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AttachmentVerificationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClosestPointEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub max_distance: f32,
}

pub trait ClosestPointEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn max_distance(&self) -> &f32;
    fn max_distance_mut(&mut self) -> &mut f32;
}

impl ClosestPointEntityDataTrait for ClosestPointEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn max_distance(&self) -> &f32 {
        &self.max_distance
    }
    fn max_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_distance
    }
}

impl super::entity::SpatialEntityDataTrait for ClosestPointEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for ClosestPointEntityData {
}

impl super::entity::GameObjectDataTrait for ClosestPointEntityData {
}

impl super::core::DataBusPeerTrait for ClosestPointEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClosestPointEntityData {
}

impl super::core::DataContainerTrait for ClosestPointEntityData {
}

pub static CLOSESTPOINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClosestPointEntityData",
    name_hash: 3177376691,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ClosestPointEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClosestPointEntityData as Default>::default())),
            create_boxed: || Box::new(<ClosestPointEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ClosestPointEntityData, realm),
            },
            FieldInfoData {
                name: "MaxDistance",
                name_hash: 3520454034,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ClosestPointEntityData, max_distance),
            },
        ],
    }),
    array_type: Some(CLOSESTPOINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ClosestPointEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLOSESTPOINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLOSESTPOINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClosestPointEntityData-Array",
    name_hash: 2812679943,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClosestPointEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct JointValidationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub joint_name: String,
    pub joint_x: f32,
    pub joint_y: f32,
    pub joint_z: f32,
    pub tolerance: f32,
    pub tick: f32,
    pub disable_validation: bool,
}

pub trait JointValidationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn joint_name(&self) -> &String;
    fn joint_name_mut(&mut self) -> &mut String;
    fn joint_x(&self) -> &f32;
    fn joint_x_mut(&mut self) -> &mut f32;
    fn joint_y(&self) -> &f32;
    fn joint_y_mut(&mut self) -> &mut f32;
    fn joint_z(&self) -> &f32;
    fn joint_z_mut(&mut self) -> &mut f32;
    fn tolerance(&self) -> &f32;
    fn tolerance_mut(&mut self) -> &mut f32;
    fn tick(&self) -> &f32;
    fn tick_mut(&mut self) -> &mut f32;
    fn disable_validation(&self) -> &bool;
    fn disable_validation_mut(&mut self) -> &mut bool;
}

impl JointValidationEntityDataTrait for JointValidationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn joint_name(&self) -> &String {
        &self.joint_name
    }
    fn joint_name_mut(&mut self) -> &mut String {
        &mut self.joint_name
    }
    fn joint_x(&self) -> &f32 {
        &self.joint_x
    }
    fn joint_x_mut(&mut self) -> &mut f32 {
        &mut self.joint_x
    }
    fn joint_y(&self) -> &f32 {
        &self.joint_y
    }
    fn joint_y_mut(&mut self) -> &mut f32 {
        &mut self.joint_y
    }
    fn joint_z(&self) -> &f32 {
        &self.joint_z
    }
    fn joint_z_mut(&mut self) -> &mut f32 {
        &mut self.joint_z
    }
    fn tolerance(&self) -> &f32 {
        &self.tolerance
    }
    fn tolerance_mut(&mut self) -> &mut f32 {
        &mut self.tolerance
    }
    fn tick(&self) -> &f32 {
        &self.tick
    }
    fn tick_mut(&mut self) -> &mut f32 {
        &mut self.tick
    }
    fn disable_validation(&self) -> &bool {
        &self.disable_validation
    }
    fn disable_validation_mut(&mut self) -> &mut bool {
        &mut self.disable_validation
    }
}

impl super::entity::EntityDataTrait for JointValidationEntityData {
}

impl super::entity::GameObjectDataTrait for JointValidationEntityData {
}

impl super::core::DataBusPeerTrait for JointValidationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for JointValidationEntityData {
}

impl super::core::DataContainerTrait for JointValidationEntityData {
}

pub static JOINTVALIDATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "JointValidationEntityData",
    name_hash: 1816530931,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(JointValidationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<JointValidationEntityData as Default>::default())),
            create_boxed: || Box::new(<JointValidationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(JointValidationEntityData, realm),
            },
            FieldInfoData {
                name: "JointName",
                name_hash: 2808814612,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(JointValidationEntityData, joint_name),
            },
            FieldInfoData {
                name: "Joint_X",
                name_hash: 3642849524,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, joint_x),
            },
            FieldInfoData {
                name: "Joint_Y",
                name_hash: 3642849525,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, joint_y),
            },
            FieldInfoData {
                name: "Joint_Z",
                name_hash: 3642849526,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, joint_z),
            },
            FieldInfoData {
                name: "Tolerance",
                name_hash: 178343404,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, tolerance),
            },
            FieldInfoData {
                name: "Tick",
                name_hash: 2089313808,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, tick),
            },
            FieldInfoData {
                name: "DisableValidation",
                name_hash: 3566604154,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(JointValidationEntityData, disable_validation),
            },
        ],
    }),
    array_type: Some(JOINTVALIDATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for JointValidationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        JOINTVALIDATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static JOINTVALIDATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "JointValidationEntityData-Array",
    name_hash: 749169607,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("JointValidationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClientPlayerInputPressEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub entry_input_action: i32,
    pub level: f32,
    pub press_for: f32,
}

pub trait ClientPlayerInputPressEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn entry_input_action(&self) -> &i32;
    fn entry_input_action_mut(&mut self) -> &mut i32;
    fn level(&self) -> &f32;
    fn level_mut(&mut self) -> &mut f32;
    fn press_for(&self) -> &f32;
    fn press_for_mut(&mut self) -> &mut f32;
}

impl ClientPlayerInputPressEntityDataTrait for ClientPlayerInputPressEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn entry_input_action(&self) -> &i32 {
        &self.entry_input_action
    }
    fn entry_input_action_mut(&mut self) -> &mut i32 {
        &mut self.entry_input_action
    }
    fn level(&self) -> &f32 {
        &self.level
    }
    fn level_mut(&mut self) -> &mut f32 {
        &mut self.level
    }
    fn press_for(&self) -> &f32 {
        &self.press_for
    }
    fn press_for_mut(&mut self) -> &mut f32 {
        &mut self.press_for
    }
}

impl super::entity::EntityDataTrait for ClientPlayerInputPressEntityData {
}

impl super::entity::GameObjectDataTrait for ClientPlayerInputPressEntityData {
}

impl super::core::DataBusPeerTrait for ClientPlayerInputPressEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClientPlayerInputPressEntityData {
}

impl super::core::DataContainerTrait for ClientPlayerInputPressEntityData {
}

pub static CLIENTPLAYERINPUTPRESSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputPressEntityData",
    name_hash: 2413938549,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ClientPlayerInputPressEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientPlayerInputPressEntityData as Default>::default())),
            create_boxed: || Box::new(<ClientPlayerInputPressEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ClientPlayerInputPressEntityData, realm),
            },
            FieldInfoData {
                name: "EntryInputAction",
                name_hash: 4156259417,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ClientPlayerInputPressEntityData, entry_input_action),
            },
            FieldInfoData {
                name: "Level",
                name_hash: 218262515,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ClientPlayerInputPressEntityData, level),
            },
            FieldInfoData {
                name: "PressFor",
                name_hash: 2624523897,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ClientPlayerInputPressEntityData, press_for),
            },
        ],
    }),
    array_type: Some(CLIENTPLAYERINPUTPRESSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientPlayerInputPressEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPLAYERINPUTPRESSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTPLAYERINPUTPRESSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputPressEntityData-Array",
    name_hash: 1050818625,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClientPlayerInputPressEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClientPlayerInputPlaybackEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub file_name: String,
    pub test_name: String,
    pub teleport: bool,
}

pub trait ClientPlayerInputPlaybackEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn file_name(&self) -> &String;
    fn file_name_mut(&mut self) -> &mut String;
    fn test_name(&self) -> &String;
    fn test_name_mut(&mut self) -> &mut String;
    fn teleport(&self) -> &bool;
    fn teleport_mut(&mut self) -> &mut bool;
}

impl ClientPlayerInputPlaybackEntityDataTrait for ClientPlayerInputPlaybackEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn file_name(&self) -> &String {
        &self.file_name
    }
    fn file_name_mut(&mut self) -> &mut String {
        &mut self.file_name
    }
    fn test_name(&self) -> &String {
        &self.test_name
    }
    fn test_name_mut(&mut self) -> &mut String {
        &mut self.test_name
    }
    fn teleport(&self) -> &bool {
        &self.teleport
    }
    fn teleport_mut(&mut self) -> &mut bool {
        &mut self.teleport
    }
}

impl super::entity::EntityDataTrait for ClientPlayerInputPlaybackEntityData {
}

impl super::entity::GameObjectDataTrait for ClientPlayerInputPlaybackEntityData {
}

impl super::core::DataBusPeerTrait for ClientPlayerInputPlaybackEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClientPlayerInputPlaybackEntityData {
}

impl super::core::DataContainerTrait for ClientPlayerInputPlaybackEntityData {
}

pub static CLIENTPLAYERINPUTPLAYBACKENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputPlaybackEntityData",
    name_hash: 347643037,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ClientPlayerInputPlaybackEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientPlayerInputPlaybackEntityData as Default>::default())),
            create_boxed: || Box::new(<ClientPlayerInputPlaybackEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ClientPlayerInputPlaybackEntityData, realm),
            },
            FieldInfoData {
                name: "FileName",
                name_hash: 1134474212,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientPlayerInputPlaybackEntityData, file_name),
            },
            FieldInfoData {
                name: "TestName",
                name_hash: 1605598740,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientPlayerInputPlaybackEntityData, test_name),
            },
            FieldInfoData {
                name: "Teleport",
                name_hash: 2495240740,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientPlayerInputPlaybackEntityData, teleport),
            },
        ],
    }),
    array_type: Some(CLIENTPLAYERINPUTPLAYBACKENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientPlayerInputPlaybackEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPLAYERINPUTPLAYBACKENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTPLAYERINPUTPLAYBACKENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputPlaybackEntityData-Array",
    name_hash: 211241001,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClientPlayerInputPlaybackEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ClientPlayerInputRecorderEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub file_name_base: String,
    pub test_name: String,
}

pub trait ClientPlayerInputRecorderEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn file_name_base(&self) -> &String;
    fn file_name_base_mut(&mut self) -> &mut String;
    fn test_name(&self) -> &String;
    fn test_name_mut(&mut self) -> &mut String;
}

impl ClientPlayerInputRecorderEntityDataTrait for ClientPlayerInputRecorderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn file_name_base(&self) -> &String {
        &self.file_name_base
    }
    fn file_name_base_mut(&mut self) -> &mut String {
        &mut self.file_name_base
    }
    fn test_name(&self) -> &String {
        &self.test_name
    }
    fn test_name_mut(&mut self) -> &mut String {
        &mut self.test_name
    }
}

impl super::entity::EntityDataTrait for ClientPlayerInputRecorderEntityData {
}

impl super::entity::GameObjectDataTrait for ClientPlayerInputRecorderEntityData {
}

impl super::core::DataBusPeerTrait for ClientPlayerInputRecorderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClientPlayerInputRecorderEntityData {
}

impl super::core::DataContainerTrait for ClientPlayerInputRecorderEntityData {
}

pub static CLIENTPLAYERINPUTRECORDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputRecorderEntityData",
    name_hash: 3527758920,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ClientPlayerInputRecorderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientPlayerInputRecorderEntityData as Default>::default())),
            create_boxed: || Box::new(<ClientPlayerInputRecorderEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ClientPlayerInputRecorderEntityData, realm),
            },
            FieldInfoData {
                name: "FileNameBase",
                name_hash: 2579130353,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientPlayerInputRecorderEntityData, file_name_base),
            },
            FieldInfoData {
                name: "TestName",
                name_hash: 1605598740,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientPlayerInputRecorderEntityData, test_name),
            },
        ],
    }),
    array_type: Some(CLIENTPLAYERINPUTRECORDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientPlayerInputRecorderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPLAYERINPUTRECORDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTPLAYERINPUTRECORDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputRecorderEntityData-Array",
    name_hash: 3160770300,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClientPlayerInputRecorderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LoggingEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub strings: Vec<String>,
    pub realm: super::core::Realm,
    pub float_value: f32,
    pub int_value: i32,
    pub transform_value: super::core::LinearTransform,
    pub vec2_value: super::core::Vec2,
    pub vec3_value: super::core::Vec3,
    pub bool_value: bool,
    pub string_value: String,
}

pub trait LoggingEntityDataTrait: super::entity::EntityDataTrait {
    fn strings(&self) -> &Vec<String>;
    fn strings_mut(&mut self) -> &mut Vec<String>;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn float_value(&self) -> &f32;
    fn float_value_mut(&mut self) -> &mut f32;
    fn int_value(&self) -> &i32;
    fn int_value_mut(&mut self) -> &mut i32;
    fn transform_value(&self) -> &super::core::LinearTransform;
    fn transform_value_mut(&mut self) -> &mut super::core::LinearTransform;
    fn vec2_value(&self) -> &super::core::Vec2;
    fn vec2_value_mut(&mut self) -> &mut super::core::Vec2;
    fn vec3_value(&self) -> &super::core::Vec3;
    fn vec3_value_mut(&mut self) -> &mut super::core::Vec3;
    fn bool_value(&self) -> &bool;
    fn bool_value_mut(&mut self) -> &mut bool;
    fn string_value(&self) -> &String;
    fn string_value_mut(&mut self) -> &mut String;
}

impl LoggingEntityDataTrait for LoggingEntityData {
    fn strings(&self) -> &Vec<String> {
        &self.strings
    }
    fn strings_mut(&mut self) -> &mut Vec<String> {
        &mut self.strings
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn float_value(&self) -> &f32 {
        &self.float_value
    }
    fn float_value_mut(&mut self) -> &mut f32 {
        &mut self.float_value
    }
    fn int_value(&self) -> &i32 {
        &self.int_value
    }
    fn int_value_mut(&mut self) -> &mut i32 {
        &mut self.int_value
    }
    fn transform_value(&self) -> &super::core::LinearTransform {
        &self.transform_value
    }
    fn transform_value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform_value
    }
    fn vec2_value(&self) -> &super::core::Vec2 {
        &self.vec2_value
    }
    fn vec2_value_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.vec2_value
    }
    fn vec3_value(&self) -> &super::core::Vec3 {
        &self.vec3_value
    }
    fn vec3_value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.vec3_value
    }
    fn bool_value(&self) -> &bool {
        &self.bool_value
    }
    fn bool_value_mut(&mut self) -> &mut bool {
        &mut self.bool_value
    }
    fn string_value(&self) -> &String {
        &self.string_value
    }
    fn string_value_mut(&mut self) -> &mut String {
        &mut self.string_value
    }
}

impl super::entity::EntityDataTrait for LoggingEntityData {
}

impl super::entity::GameObjectDataTrait for LoggingEntityData {
}

impl super::core::DataBusPeerTrait for LoggingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LoggingEntityData {
}

impl super::core::DataContainerTrait for LoggingEntityData {
}

pub static LOGGINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoggingEntityData",
    name_hash: 2478443213,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LoggingEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LoggingEntityData as Default>::default())),
            create_boxed: || Box::new(<LoggingEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Strings",
                name_hash: 2189562659,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(LoggingEntityData, strings),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LoggingEntityData, realm),
            },
            FieldInfoData {
                name: "FloatValue",
                name_hash: 3123792190,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LoggingEntityData, float_value),
            },
            FieldInfoData {
                name: "IntValue",
                name_hash: 5685821,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(LoggingEntityData, int_value),
            },
            FieldInfoData {
                name: "TransformValue",
                name_hash: 3606782274,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(LoggingEntityData, transform_value),
            },
            FieldInfoData {
                name: "Vec2Value",
                name_hash: 311491116,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(LoggingEntityData, vec2_value),
            },
            FieldInfoData {
                name: "Vec3Value",
                name_hash: 277101325,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LoggingEntityData, vec3_value),
            },
            FieldInfoData {
                name: "BoolValue",
                name_hash: 176040160,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LoggingEntityData, bool_value),
            },
            FieldInfoData {
                name: "StringValue",
                name_hash: 1269878171,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LoggingEntityData, string_value),
            },
        ],
    }),
    array_type: Some(LOGGINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LoggingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGGINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGGINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoggingEntityData-Array",
    name_hash: 4104888057,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LoggingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DestructionCommandEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub instance_count_destroyed_per_frame: u32,
    pub instance_count_destroyed_per_type: u32,
}

pub trait DestructionCommandEntityDataTrait: super::entity::EntityDataTrait {
    fn instance_count_destroyed_per_frame(&self) -> &u32;
    fn instance_count_destroyed_per_frame_mut(&mut self) -> &mut u32;
    fn instance_count_destroyed_per_type(&self) -> &u32;
    fn instance_count_destroyed_per_type_mut(&mut self) -> &mut u32;
}

impl DestructionCommandEntityDataTrait for DestructionCommandEntityData {
    fn instance_count_destroyed_per_frame(&self) -> &u32 {
        &self.instance_count_destroyed_per_frame
    }
    fn instance_count_destroyed_per_frame_mut(&mut self) -> &mut u32 {
        &mut self.instance_count_destroyed_per_frame
    }
    fn instance_count_destroyed_per_type(&self) -> &u32 {
        &self.instance_count_destroyed_per_type
    }
    fn instance_count_destroyed_per_type_mut(&mut self) -> &mut u32 {
        &mut self.instance_count_destroyed_per_type
    }
}

impl super::entity::EntityDataTrait for DestructionCommandEntityData {
}

impl super::entity::GameObjectDataTrait for DestructionCommandEntityData {
}

impl super::core::DataBusPeerTrait for DestructionCommandEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DestructionCommandEntityData {
}

impl super::core::DataContainerTrait for DestructionCommandEntityData {
}

pub static DESTRUCTIONCOMMANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DestructionCommandEntityData",
    name_hash: 1720852759,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DestructionCommandEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DestructionCommandEntityData as Default>::default())),
            create_boxed: || Box::new(<DestructionCommandEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InstanceCountDestroyedPerFrame",
                name_hash: 961630582,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DestructionCommandEntityData, instance_count_destroyed_per_frame),
            },
            FieldInfoData {
                name: "InstanceCountDestroyedPerType",
                name_hash: 1461542483,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DestructionCommandEntityData, instance_count_destroyed_per_type),
            },
        ],
    }),
    array_type: Some(DESTRUCTIONCOMMANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DestructionCommandEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DESTRUCTIONCOMMANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DESTRUCTIONCOMMANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DestructionCommandEntityData-Array",
    name_hash: 2036025763,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DestructionCommandEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestPointEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub output_name: String,
}

pub trait TestPointEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn output_name(&self) -> &String;
    fn output_name_mut(&mut self) -> &mut String;
}

impl TestPointEntityDataTrait for TestPointEntityData {
    fn output_name(&self) -> &String {
        &self.output_name
    }
    fn output_name_mut(&mut self) -> &mut String {
        &mut self.output_name
    }
}

impl super::entity::SpatialEntityDataTrait for TestPointEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TestPointEntityData {
}

impl super::entity::GameObjectDataTrait for TestPointEntityData {
}

impl super::core::DataBusPeerTrait for TestPointEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestPointEntityData {
}

impl super::core::DataContainerTrait for TestPointEntityData {
}

pub static TESTPOINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPointEntityData",
    name_hash: 1515805684,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestPointEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestPointEntityData as Default>::default())),
            create_boxed: || Box::new(<TestPointEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "OutputName",
                name_hash: 543054269,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestPointEntityData, output_name),
            },
        ],
    }),
    array_type: Some(TESTPOINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TestPointEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTPOINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTPOINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPointEntityData-Array",
    name_hash: 128690112,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestPointEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SoldierMovementSequenceData {
    pub _glacier_base: MovementActionData,
    pub recorded_input: Option<LockedTypeObject /* RecordedInputData */>,
    pub input_recording_index: i32,
    pub ignore_recording_index_filter: bool,
    pub report_when_finished: bool,
}

pub trait SoldierMovementSequenceDataTrait: MovementActionDataTrait {
    fn recorded_input(&self) -> &Option<LockedTypeObject /* RecordedInputData */>;
    fn recorded_input_mut(&mut self) -> &mut Option<LockedTypeObject /* RecordedInputData */>;
    fn input_recording_index(&self) -> &i32;
    fn input_recording_index_mut(&mut self) -> &mut i32;
    fn ignore_recording_index_filter(&self) -> &bool;
    fn ignore_recording_index_filter_mut(&mut self) -> &mut bool;
    fn report_when_finished(&self) -> &bool;
    fn report_when_finished_mut(&mut self) -> &mut bool;
}

impl SoldierMovementSequenceDataTrait for SoldierMovementSequenceData {
    fn recorded_input(&self) -> &Option<LockedTypeObject /* RecordedInputData */> {
        &self.recorded_input
    }
    fn recorded_input_mut(&mut self) -> &mut Option<LockedTypeObject /* RecordedInputData */> {
        &mut self.recorded_input
    }
    fn input_recording_index(&self) -> &i32 {
        &self.input_recording_index
    }
    fn input_recording_index_mut(&mut self) -> &mut i32 {
        &mut self.input_recording_index
    }
    fn ignore_recording_index_filter(&self) -> &bool {
        &self.ignore_recording_index_filter
    }
    fn ignore_recording_index_filter_mut(&mut self) -> &mut bool {
        &mut self.ignore_recording_index_filter
    }
    fn report_when_finished(&self) -> &bool {
        &self.report_when_finished
    }
    fn report_when_finished_mut(&mut self) -> &mut bool {
        &mut self.report_when_finished
    }
}

impl MovementActionDataTrait for SoldierMovementSequenceData {
}

impl super::core::DataContainerTrait for SoldierMovementSequenceData {
}

pub static SOLDIERMOVEMENTSEQUENCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierMovementSequenceData",
    name_hash: 891835523,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MOVEMENTACTIONDATA_TYPE_INFO),
        super_class_offset: offset_of!(SoldierMovementSequenceData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierMovementSequenceData as Default>::default())),
            create_boxed: || Box::new(<SoldierMovementSequenceData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RecordedInput",
                name_hash: 1633327487,
                flags: MemberInfoFlags::new(0),
                field_type: "RecordedInputData",
                rust_offset: offset_of!(SoldierMovementSequenceData, recorded_input),
            },
            FieldInfoData {
                name: "InputRecordingIndex",
                name_hash: 228494272,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierMovementSequenceData, input_recording_index),
            },
            FieldInfoData {
                name: "IgnoreRecordingIndexFilter",
                name_hash: 2391351758,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierMovementSequenceData, ignore_recording_index_filter),
            },
            FieldInfoData {
                name: "ReportWhenFinished",
                name_hash: 644020589,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierMovementSequenceData, report_when_finished),
            },
        ],
    }),
    array_type: Some(SOLDIERMOVEMENTSEQUENCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierMovementSequenceData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERMOVEMENTSEQUENCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERMOVEMENTSEQUENCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierMovementSequenceData-Array",
    name_hash: 3336021815,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SoldierMovementSequenceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RecordedInputData {
    pub _glacier_base: super::core::Asset,
    pub track_data: Vec<BoxedTypeObject /* InputRecorderTrackData */>,
}

pub trait RecordedInputDataTrait: super::core::AssetTrait {
    fn track_data(&self) -> &Vec<BoxedTypeObject /* InputRecorderTrackData */>;
    fn track_data_mut(&mut self) -> &mut Vec<BoxedTypeObject /* InputRecorderTrackData */>;
}

impl RecordedInputDataTrait for RecordedInputData {
    fn track_data(&self) -> &Vec<BoxedTypeObject /* InputRecorderTrackData */> {
        &self.track_data
    }
    fn track_data_mut(&mut self) -> &mut Vec<BoxedTypeObject /* InputRecorderTrackData */> {
        &mut self.track_data
    }
}

impl super::core::AssetTrait for RecordedInputData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RecordedInputData {
}

pub static RECORDEDINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordedInputData",
    name_hash: 1473401999,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(RecordedInputData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordedInputData as Default>::default())),
            create_boxed: || Box::new(<RecordedInputData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "TrackData",
                name_hash: 1756028410,
                flags: MemberInfoFlags::new(144),
                field_type: "InputRecorderTrackData-Array",
                rust_offset: offset_of!(RecordedInputData, track_data),
            },
        ],
    }),
    array_type: Some(RECORDEDINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordedInputData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDEDINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDEDINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordedInputData-Array",
    name_hash: 616608059,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordedInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct InputRecorderData {
    pub _glacier_base: super::core::DataContainer,
    pub file_name_prefix: String,
    pub file_name: String,
    pub auto_increment_file_name: bool,
    pub toggle_record_action: i32,
}

pub trait InputRecorderDataTrait: super::core::DataContainerTrait {
    fn file_name_prefix(&self) -> &String;
    fn file_name_prefix_mut(&mut self) -> &mut String;
    fn file_name(&self) -> &String;
    fn file_name_mut(&mut self) -> &mut String;
    fn auto_increment_file_name(&self) -> &bool;
    fn auto_increment_file_name_mut(&mut self) -> &mut bool;
    fn toggle_record_action(&self) -> &i32;
    fn toggle_record_action_mut(&mut self) -> &mut i32;
}

impl InputRecorderDataTrait for InputRecorderData {
    fn file_name_prefix(&self) -> &String {
        &self.file_name_prefix
    }
    fn file_name_prefix_mut(&mut self) -> &mut String {
        &mut self.file_name_prefix
    }
    fn file_name(&self) -> &String {
        &self.file_name
    }
    fn file_name_mut(&mut self) -> &mut String {
        &mut self.file_name
    }
    fn auto_increment_file_name(&self) -> &bool {
        &self.auto_increment_file_name
    }
    fn auto_increment_file_name_mut(&mut self) -> &mut bool {
        &mut self.auto_increment_file_name
    }
    fn toggle_record_action(&self) -> &i32 {
        &self.toggle_record_action
    }
    fn toggle_record_action_mut(&mut self) -> &mut i32 {
        &mut self.toggle_record_action
    }
}

impl super::core::DataContainerTrait for InputRecorderData {
}

pub static INPUTRECORDERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRecorderData",
    name_hash: 111964057,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(InputRecorderData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputRecorderData as Default>::default())),
            create_boxed: || Box::new(<InputRecorderData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FileNamePrefix",
                name_hash: 452437588,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(InputRecorderData, file_name_prefix),
            },
            FieldInfoData {
                name: "FileName",
                name_hash: 1134474212,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(InputRecorderData, file_name),
            },
            FieldInfoData {
                name: "AutoIncrementFileName",
                name_hash: 4191315274,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputRecorderData, auto_increment_file_name),
            },
            FieldInfoData {
                name: "ToggleRecordAction",
                name_hash: 390577636,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputRecorderData, toggle_record_action),
            },
        ],
    }),
    array_type: Some(INPUTRECORDERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputRecorderData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTRECORDERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INPUTRECORDERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRecorderData-Array",
    name_hash: 2275257645,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InputRecorderData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct InputRecorderTrackData {
    pub name: String,
    pub input_action: i32,
    pub property_track: Option<LockedTypeObject /* super::entity::FloatPropertyTrackData */>,
}

pub trait InputRecorderTrackDataTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn input_action(&self) -> &i32;
    fn input_action_mut(&mut self) -> &mut i32;
    fn property_track(&self) -> &Option<LockedTypeObject /* super::entity::FloatPropertyTrackData */>;
    fn property_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::FloatPropertyTrackData */>;
}

impl InputRecorderTrackDataTrait for InputRecorderTrackData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn input_action_mut(&mut self) -> &mut i32 {
        &mut self.input_action
    }
    fn property_track(&self) -> &Option<LockedTypeObject /* super::entity::FloatPropertyTrackData */> {
        &self.property_track
    }
    fn property_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::FloatPropertyTrackData */> {
        &mut self.property_track
    }
}

pub static INPUTRECORDERTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRecorderTrackData",
    name_hash: 2507334806,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputRecorderTrackData as Default>::default())),
            create_boxed: || Box::new(<InputRecorderTrackData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                name_hash: 2088949890,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(InputRecorderTrackData, name),
            },
            FieldInfoData {
                name: "InputAction",
                name_hash: 1407707693,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputRecorderTrackData, input_action),
            },
            FieldInfoData {
                name: "PropertyTrack",
                name_hash: 3098661837,
                flags: MemberInfoFlags::new(0),
                field_type: "FloatPropertyTrackData",
                rust_offset: offset_of!(InputRecorderTrackData, property_track),
            },
        ],
    }),
    array_type: Some(INPUTRECORDERTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputRecorderTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTRECORDERTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INPUTRECORDERTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRecorderTrackData-Array",
    name_hash: 2907281826,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InputRecorderTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SimpleMovementActionData {
    pub _glacier_base: SimpleMovementActionBaseData,
    pub level: f32,
    pub action: i32,
    pub teleport: bool,
    pub respawn: bool,
    pub special_animation_index: i32,
}

pub trait SimpleMovementActionDataTrait: SimpleMovementActionBaseDataTrait {
    fn level(&self) -> &f32;
    fn level_mut(&mut self) -> &mut f32;
    fn action(&self) -> &i32;
    fn action_mut(&mut self) -> &mut i32;
    fn teleport(&self) -> &bool;
    fn teleport_mut(&mut self) -> &mut bool;
    fn respawn(&self) -> &bool;
    fn respawn_mut(&mut self) -> &mut bool;
    fn special_animation_index(&self) -> &i32;
    fn special_animation_index_mut(&mut self) -> &mut i32;
}

impl SimpleMovementActionDataTrait for SimpleMovementActionData {
    fn level(&self) -> &f32 {
        &self.level
    }
    fn level_mut(&mut self) -> &mut f32 {
        &mut self.level
    }
    fn action(&self) -> &i32 {
        &self.action
    }
    fn action_mut(&mut self) -> &mut i32 {
        &mut self.action
    }
    fn teleport(&self) -> &bool {
        &self.teleport
    }
    fn teleport_mut(&mut self) -> &mut bool {
        &mut self.teleport
    }
    fn respawn(&self) -> &bool {
        &self.respawn
    }
    fn respawn_mut(&mut self) -> &mut bool {
        &mut self.respawn
    }
    fn special_animation_index(&self) -> &i32 {
        &self.special_animation_index
    }
    fn special_animation_index_mut(&mut self) -> &mut i32 {
        &mut self.special_animation_index
    }
}

impl SimpleMovementActionBaseDataTrait for SimpleMovementActionData {
    fn start_time_info(&self) -> &SimpleMovementActionTimeData {
        self._glacier_base.start_time_info()
    }
    fn start_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        self._glacier_base.start_time_info_mut()
    }
    fn run_time_info(&self) -> &SimpleMovementActionTimeData {
        self._glacier_base.run_time_info()
    }
    fn run_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        self._glacier_base.run_time_info_mut()
    }
}

impl MovementActionDataTrait for SimpleMovementActionData {
}

impl super::core::DataContainerTrait for SimpleMovementActionData {
}

pub static SIMPLEMOVEMENTACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionData",
    name_hash: 2823510598,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(SimpleMovementActionData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleMovementActionData as Default>::default())),
            create_boxed: || Box::new(<SimpleMovementActionData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Level",
                name_hash: 218262515,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleMovementActionData, level),
            },
            FieldInfoData {
                name: "Action",
                name_hash: 2484178491,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleMovementActionData, action),
            },
            FieldInfoData {
                name: "Teleport",
                name_hash: 2495240740,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleMovementActionData, teleport),
            },
            FieldInfoData {
                name: "Respawn",
                name_hash: 1303651241,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleMovementActionData, respawn),
            },
            FieldInfoData {
                name: "SpecialAnimationIndex",
                name_hash: 502517260,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleMovementActionData, special_animation_index),
            },
        ],
    }),
    array_type: Some(SIMPLEMOVEMENTACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleMovementActionData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEMOVEMENTACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEMOVEMENTACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionData-Array",
    name_hash: 3578845170,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SimpleMovementActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CameraActionData {
    pub _glacier_base: SimpleMovementActionBaseData,
    pub action_mode: CameraMovementActionMode,
}

pub trait CameraActionDataTrait: SimpleMovementActionBaseDataTrait {
    fn action_mode(&self) -> &CameraMovementActionMode;
    fn action_mode_mut(&mut self) -> &mut CameraMovementActionMode;
}

impl CameraActionDataTrait for CameraActionData {
    fn action_mode(&self) -> &CameraMovementActionMode {
        &self.action_mode
    }
    fn action_mode_mut(&mut self) -> &mut CameraMovementActionMode {
        &mut self.action_mode
    }
}

impl SimpleMovementActionBaseDataTrait for CameraActionData {
    fn start_time_info(&self) -> &SimpleMovementActionTimeData {
        self._glacier_base.start_time_info()
    }
    fn start_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        self._glacier_base.start_time_info_mut()
    }
    fn run_time_info(&self) -> &SimpleMovementActionTimeData {
        self._glacier_base.run_time_info()
    }
    fn run_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        self._glacier_base.run_time_info_mut()
    }
}

impl MovementActionDataTrait for CameraActionData {
}

impl super::core::DataContainerTrait for CameraActionData {
}

pub static CAMERAACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraActionData",
    name_hash: 2007962354,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(CameraActionData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraActionData as Default>::default())),
            create_boxed: || Box::new(<CameraActionData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ActionMode",
                name_hash: 1115046008,
                flags: MemberInfoFlags::new(0),
                field_type: "CameraMovementActionMode",
                rust_offset: offset_of!(CameraActionData, action_mode),
            },
        ],
    }),
    array_type: Some(CAMERAACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraActionData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraActionData-Array",
    name_hash: 1788553670,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SimpleMovementActionBaseData {
    pub _glacier_base: MovementActionData,
    pub start_time_info: SimpleMovementActionTimeData,
    pub run_time_info: SimpleMovementActionTimeData,
}

pub trait SimpleMovementActionBaseDataTrait: MovementActionDataTrait {
    fn start_time_info(&self) -> &SimpleMovementActionTimeData;
    fn start_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData;
    fn run_time_info(&self) -> &SimpleMovementActionTimeData;
    fn run_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData;
}

impl SimpleMovementActionBaseDataTrait for SimpleMovementActionBaseData {
    fn start_time_info(&self) -> &SimpleMovementActionTimeData {
        &self.start_time_info
    }
    fn start_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        &mut self.start_time_info
    }
    fn run_time_info(&self) -> &SimpleMovementActionTimeData {
        &self.run_time_info
    }
    fn run_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        &mut self.run_time_info
    }
}

impl MovementActionDataTrait for SimpleMovementActionBaseData {
}

impl super::core::DataContainerTrait for SimpleMovementActionBaseData {
}

pub static SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionBaseData",
    name_hash: 2415936915,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MOVEMENTACTIONDATA_TYPE_INFO),
        super_class_offset: offset_of!(SimpleMovementActionBaseData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleMovementActionBaseData as Default>::default())),
            create_boxed: || Box::new(<SimpleMovementActionBaseData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StartTimeInfo",
                name_hash: 2015117886,
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleMovementActionTimeData",
                rust_offset: offset_of!(SimpleMovementActionBaseData, start_time_info),
            },
            FieldInfoData {
                name: "RunTimeInfo",
                name_hash: 3849518743,
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleMovementActionTimeData",
                rust_offset: offset_of!(SimpleMovementActionBaseData, run_time_info),
            },
        ],
    }),
    array_type: Some(SIMPLEMOVEMENTACTIONBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleMovementActionBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEMOVEMENTACTIONBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionBaseData-Array",
    name_hash: 162734119,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SimpleMovementActionBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CameraMovementActionMode {
    #[default]
    CameraMovementActionMode_Start = 0,
    CameraMovementActionMode_Stop = 1,
    CameraMovementActionMode_StartAndStop = 2,
}

pub static CAMERAMOVEMENTACTIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraMovementActionMode",
    name_hash: 3735992674,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CAMERAMOVEMENTACTIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CameraMovementActionMode {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAMOVEMENTACTIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERAMOVEMENTACTIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraMovementActionMode-Array",
    name_hash: 3318409302,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraMovementActionMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SimpleMovementActionTimeData {
    pub time: f32,
    pub max_variation: f32,
}

pub trait SimpleMovementActionTimeDataTrait: TypeObject {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn max_variation(&self) -> &f32;
    fn max_variation_mut(&mut self) -> &mut f32;
}

impl SimpleMovementActionTimeDataTrait for SimpleMovementActionTimeData {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn max_variation(&self) -> &f32 {
        &self.max_variation
    }
    fn max_variation_mut(&mut self) -> &mut f32 {
        &mut self.max_variation
    }
}

pub static SIMPLEMOVEMENTACTIONTIMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionTimeData",
    name_hash: 4020447891,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleMovementActionTimeData as Default>::default())),
            create_boxed: || Box::new(<SimpleMovementActionTimeData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleMovementActionTimeData, time),
            },
            FieldInfoData {
                name: "MaxVariation",
                name_hash: 3926522752,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleMovementActionTimeData, max_variation),
            },
        ],
    }),
    array_type: Some(SIMPLEMOVEMENTACTIONTIMEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SimpleMovementActionTimeData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEMOVEMENTACTIONTIMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SIMPLEMOVEMENTACTIONTIMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionTimeData-Array",
    name_hash: 4079863079,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SimpleMovementActionTimeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MovementActionRandomizerData {
    pub _glacier_base: MovementActionData,
    pub reinsert_into_randomized_list_after_use: bool,
    pub actions: Vec<Option<LockedTypeObject /* MovementActionData */>>,
}

pub trait MovementActionRandomizerDataTrait: MovementActionDataTrait {
    fn reinsert_into_randomized_list_after_use(&self) -> &bool;
    fn reinsert_into_randomized_list_after_use_mut(&mut self) -> &mut bool;
    fn actions(&self) -> &Vec<Option<LockedTypeObject /* MovementActionData */>>;
    fn actions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* MovementActionData */>>;
}

impl MovementActionRandomizerDataTrait for MovementActionRandomizerData {
    fn reinsert_into_randomized_list_after_use(&self) -> &bool {
        &self.reinsert_into_randomized_list_after_use
    }
    fn reinsert_into_randomized_list_after_use_mut(&mut self) -> &mut bool {
        &mut self.reinsert_into_randomized_list_after_use
    }
    fn actions(&self) -> &Vec<Option<LockedTypeObject /* MovementActionData */>> {
        &self.actions
    }
    fn actions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* MovementActionData */>> {
        &mut self.actions
    }
}

impl MovementActionDataTrait for MovementActionRandomizerData {
}

impl super::core::DataContainerTrait for MovementActionRandomizerData {
}

pub static MOVEMENTACTIONRANDOMIZERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionRandomizerData",
    name_hash: 2874889463,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MOVEMENTACTIONDATA_TYPE_INFO),
        super_class_offset: offset_of!(MovementActionRandomizerData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementActionRandomizerData as Default>::default())),
            create_boxed: || Box::new(<MovementActionRandomizerData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ReinsertIntoRandomizedListAfterUse",
                name_hash: 201056821,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementActionRandomizerData, reinsert_into_randomized_list_after_use),
            },
            FieldInfoData {
                name: "Actions",
                name_hash: 373511656,
                flags: MemberInfoFlags::new(144),
                field_type: "MovementActionData-Array",
                rust_offset: offset_of!(MovementActionRandomizerData, actions),
            },
        ],
    }),
    array_type: Some(MOVEMENTACTIONRANDOMIZERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MovementActionRandomizerData {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTACTIONRANDOMIZERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVEMENTACTIONRANDOMIZERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionRandomizerData-Array",
    name_hash: 991698627,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MovementActionRandomizerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MovementActionGroupData {
    pub _glacier_base: MovementActionData,
    pub actions: Vec<Option<LockedTypeObject /* MovementActionData */>>,
    pub run_simultaneously: bool,
    pub restart_children: bool,
}

pub trait MovementActionGroupDataTrait: MovementActionDataTrait {
    fn actions(&self) -> &Vec<Option<LockedTypeObject /* MovementActionData */>>;
    fn actions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* MovementActionData */>>;
    fn run_simultaneously(&self) -> &bool;
    fn run_simultaneously_mut(&mut self) -> &mut bool;
    fn restart_children(&self) -> &bool;
    fn restart_children_mut(&mut self) -> &mut bool;
}

impl MovementActionGroupDataTrait for MovementActionGroupData {
    fn actions(&self) -> &Vec<Option<LockedTypeObject /* MovementActionData */>> {
        &self.actions
    }
    fn actions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* MovementActionData */>> {
        &mut self.actions
    }
    fn run_simultaneously(&self) -> &bool {
        &self.run_simultaneously
    }
    fn run_simultaneously_mut(&mut self) -> &mut bool {
        &mut self.run_simultaneously
    }
    fn restart_children(&self) -> &bool {
        &self.restart_children
    }
    fn restart_children_mut(&mut self) -> &mut bool {
        &mut self.restart_children
    }
}

impl MovementActionDataTrait for MovementActionGroupData {
}

impl super::core::DataContainerTrait for MovementActionGroupData {
}

pub static MOVEMENTACTIONGROUPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionGroupData",
    name_hash: 2941333911,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MOVEMENTACTIONDATA_TYPE_INFO),
        super_class_offset: offset_of!(MovementActionGroupData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementActionGroupData as Default>::default())),
            create_boxed: || Box::new(<MovementActionGroupData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Actions",
                name_hash: 373511656,
                flags: MemberInfoFlags::new(144),
                field_type: "MovementActionData-Array",
                rust_offset: offset_of!(MovementActionGroupData, actions),
            },
            FieldInfoData {
                name: "RunSimultaneously",
                name_hash: 2322374336,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementActionGroupData, run_simultaneously),
            },
            FieldInfoData {
                name: "RestartChildren",
                name_hash: 3914911489,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementActionGroupData, restart_children),
            },
        ],
    }),
    array_type: Some(MOVEMENTACTIONGROUPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MovementActionGroupData {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTACTIONGROUPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVEMENTACTIONGROUPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionGroupData-Array",
    name_hash: 910473763,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MovementActionGroupData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MovementActionRoot {
    pub _glacier_base: super::core::Asset,
    pub start_sequence: Option<LockedTypeObject /* MovementActionData */>,
}

pub trait MovementActionRootTrait: super::core::AssetTrait {
    fn start_sequence(&self) -> &Option<LockedTypeObject /* MovementActionData */>;
    fn start_sequence_mut(&mut self) -> &mut Option<LockedTypeObject /* MovementActionData */>;
}

impl MovementActionRootTrait for MovementActionRoot {
    fn start_sequence(&self) -> &Option<LockedTypeObject /* MovementActionData */> {
        &self.start_sequence
    }
    fn start_sequence_mut(&mut self) -> &mut Option<LockedTypeObject /* MovementActionData */> {
        &mut self.start_sequence
    }
}

impl super::core::AssetTrait for MovementActionRoot {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MovementActionRoot {
}

pub static MOVEMENTACTIONROOT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionRoot",
    name_hash: 1860974046,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(MovementActionRoot, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementActionRoot as Default>::default())),
            create_boxed: || Box::new(<MovementActionRoot as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "StartSequence",
                name_hash: 3846144538,
                flags: MemberInfoFlags::new(0),
                field_type: "MovementActionData",
                rust_offset: offset_of!(MovementActionRoot, start_sequence),
            },
        ],
    }),
    array_type: Some(MOVEMENTACTIONROOT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MovementActionRoot {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTACTIONROOT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVEMENTACTIONROOT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionRoot-Array",
    name_hash: 3038410602,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MovementActionRoot"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MovementActionData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait MovementActionDataTrait: super::core::DataContainerTrait {
}

impl MovementActionDataTrait for MovementActionData {
}

impl super::core::DataContainerTrait for MovementActionData {
}

pub static MOVEMENTACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionData",
    name_hash: 1861482920,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(MovementActionData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementActionData as Default>::default())),
            create_boxed: || Box::new(<MovementActionData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(MOVEMENTACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MovementActionData {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVEMENTACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionData-Array",
    name_hash: 891714332,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MovementActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AssertEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub pass: bool,
    pub text: String,
    pub trigger_once: bool,
    pub trigger_on_pass_changed: bool,
}

pub trait AssertEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn pass(&self) -> &bool;
    fn pass_mut(&mut self) -> &mut bool;
    fn text(&self) -> &String;
    fn text_mut(&mut self) -> &mut String;
    fn trigger_once(&self) -> &bool;
    fn trigger_once_mut(&mut self) -> &mut bool;
    fn trigger_on_pass_changed(&self) -> &bool;
    fn trigger_on_pass_changed_mut(&mut self) -> &mut bool;
}

impl AssertEntityDataTrait for AssertEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn pass(&self) -> &bool {
        &self.pass
    }
    fn pass_mut(&mut self) -> &mut bool {
        &mut self.pass
    }
    fn text(&self) -> &String {
        &self.text
    }
    fn text_mut(&mut self) -> &mut String {
        &mut self.text
    }
    fn trigger_once(&self) -> &bool {
        &self.trigger_once
    }
    fn trigger_once_mut(&mut self) -> &mut bool {
        &mut self.trigger_once
    }
    fn trigger_on_pass_changed(&self) -> &bool {
        &self.trigger_on_pass_changed
    }
    fn trigger_on_pass_changed_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_pass_changed
    }
}

impl super::entity::EntityDataTrait for AssertEntityData {
}

impl super::entity::GameObjectDataTrait for AssertEntityData {
}

impl super::core::DataBusPeerTrait for AssertEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AssertEntityData {
}

impl super::core::DataContainerTrait for AssertEntityData {
}

pub static ASSERTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertEntityData",
    name_hash: 3994172620,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AssertEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AssertEntityData as Default>::default())),
            create_boxed: || Box::new(<AssertEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AssertEntityData, realm),
            },
            FieldInfoData {
                name: "Pass",
                name_hash: 2089448340,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AssertEntityData, pass),
            },
            FieldInfoData {
                name: "Text",
                name_hash: 2089309304,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AssertEntityData, text),
            },
            FieldInfoData {
                name: "TriggerOnce",
                name_hash: 1019440090,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AssertEntityData, trigger_once),
            },
            FieldInfoData {
                name: "TriggerOnPassChanged",
                name_hash: 2345625839,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AssertEntityData, trigger_on_pass_changed),
            },
        ],
    }),
    array_type: Some(ASSERTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AssertEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ASSERTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ASSERTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertEntityData-Array",
    name_hash: 3869146488,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AssertEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LinkDebugEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub pipeline_test_enabled: bool,
    pub realm: super::core::Realm,
    pub max_resolved_link_debugs: u32,
    pub test_on_init: bool,
    pub expect_all_targets_to_be_resolvable_from_source: bool,
    pub expect_all_targets_to_be_in_same_sub_level: bool,
    pub expect_all_targets_to_be_immutable: bool,
    pub expect_all_targets_to_be_dynamic: bool,
    pub expected_target_data_count_in_runtime: u32,
    pub expected_target_instance_count_in_runtime: u32,
}

pub trait LinkDebugEntityDataTrait: super::entity::EntityDataTrait {
    fn pipeline_test_enabled(&self) -> &bool;
    fn pipeline_test_enabled_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn max_resolved_link_debugs(&self) -> &u32;
    fn max_resolved_link_debugs_mut(&mut self) -> &mut u32;
    fn test_on_init(&self) -> &bool;
    fn test_on_init_mut(&mut self) -> &mut bool;
    fn expect_all_targets_to_be_resolvable_from_source(&self) -> &bool;
    fn expect_all_targets_to_be_resolvable_from_source_mut(&mut self) -> &mut bool;
    fn expect_all_targets_to_be_in_same_sub_level(&self) -> &bool;
    fn expect_all_targets_to_be_in_same_sub_level_mut(&mut self) -> &mut bool;
    fn expect_all_targets_to_be_immutable(&self) -> &bool;
    fn expect_all_targets_to_be_immutable_mut(&mut self) -> &mut bool;
    fn expect_all_targets_to_be_dynamic(&self) -> &bool;
    fn expect_all_targets_to_be_dynamic_mut(&mut self) -> &mut bool;
    fn expected_target_data_count_in_runtime(&self) -> &u32;
    fn expected_target_data_count_in_runtime_mut(&mut self) -> &mut u32;
    fn expected_target_instance_count_in_runtime(&self) -> &u32;
    fn expected_target_instance_count_in_runtime_mut(&mut self) -> &mut u32;
}

impl LinkDebugEntityDataTrait for LinkDebugEntityData {
    fn pipeline_test_enabled(&self) -> &bool {
        &self.pipeline_test_enabled
    }
    fn pipeline_test_enabled_mut(&mut self) -> &mut bool {
        &mut self.pipeline_test_enabled
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn max_resolved_link_debugs(&self) -> &u32 {
        &self.max_resolved_link_debugs
    }
    fn max_resolved_link_debugs_mut(&mut self) -> &mut u32 {
        &mut self.max_resolved_link_debugs
    }
    fn test_on_init(&self) -> &bool {
        &self.test_on_init
    }
    fn test_on_init_mut(&mut self) -> &mut bool {
        &mut self.test_on_init
    }
    fn expect_all_targets_to_be_resolvable_from_source(&self) -> &bool {
        &self.expect_all_targets_to_be_resolvable_from_source
    }
    fn expect_all_targets_to_be_resolvable_from_source_mut(&mut self) -> &mut bool {
        &mut self.expect_all_targets_to_be_resolvable_from_source
    }
    fn expect_all_targets_to_be_in_same_sub_level(&self) -> &bool {
        &self.expect_all_targets_to_be_in_same_sub_level
    }
    fn expect_all_targets_to_be_in_same_sub_level_mut(&mut self) -> &mut bool {
        &mut self.expect_all_targets_to_be_in_same_sub_level
    }
    fn expect_all_targets_to_be_immutable(&self) -> &bool {
        &self.expect_all_targets_to_be_immutable
    }
    fn expect_all_targets_to_be_immutable_mut(&mut self) -> &mut bool {
        &mut self.expect_all_targets_to_be_immutable
    }
    fn expect_all_targets_to_be_dynamic(&self) -> &bool {
        &self.expect_all_targets_to_be_dynamic
    }
    fn expect_all_targets_to_be_dynamic_mut(&mut self) -> &mut bool {
        &mut self.expect_all_targets_to_be_dynamic
    }
    fn expected_target_data_count_in_runtime(&self) -> &u32 {
        &self.expected_target_data_count_in_runtime
    }
    fn expected_target_data_count_in_runtime_mut(&mut self) -> &mut u32 {
        &mut self.expected_target_data_count_in_runtime
    }
    fn expected_target_instance_count_in_runtime(&self) -> &u32 {
        &self.expected_target_instance_count_in_runtime
    }
    fn expected_target_instance_count_in_runtime_mut(&mut self) -> &mut u32 {
        &mut self.expected_target_instance_count_in_runtime
    }
}

impl super::entity::EntityDataTrait for LinkDebugEntityData {
}

impl super::entity::GameObjectDataTrait for LinkDebugEntityData {
}

impl super::core::DataBusPeerTrait for LinkDebugEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LinkDebugEntityData {
}

impl super::core::DataContainerTrait for LinkDebugEntityData {
}

pub static LINKDEBUGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkDebugEntityData",
    name_hash: 217173119,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LinkDebugEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkDebugEntityData as Default>::default())),
            create_boxed: || Box::new(<LinkDebugEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PipelineTestEnabled",
                name_hash: 2504194036,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, pipeline_test_enabled),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LinkDebugEntityData, realm),
            },
            FieldInfoData {
                name: "MaxResolvedLinkDebugs",
                name_hash: 623440451,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LinkDebugEntityData, max_resolved_link_debugs),
            },
            FieldInfoData {
                name: "TestOnInit",
                name_hash: 473424104,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, test_on_init),
            },
            FieldInfoData {
                name: "ExpectAllTargetsToBeResolvableFromSource",
                name_hash: 1955133941,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, expect_all_targets_to_be_resolvable_from_source),
            },
            FieldInfoData {
                name: "ExpectAllTargetsToBeInSameSubLevel",
                name_hash: 2209521418,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, expect_all_targets_to_be_in_same_sub_level),
            },
            FieldInfoData {
                name: "ExpectAllTargetsToBeImmutable",
                name_hash: 552014471,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, expect_all_targets_to_be_immutable),
            },
            FieldInfoData {
                name: "ExpectAllTargetsToBeDynamic",
                name_hash: 2196287760,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, expect_all_targets_to_be_dynamic),
            },
            FieldInfoData {
                name: "ExpectedTargetDataCountInRuntime",
                name_hash: 4189312642,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LinkDebugEntityData, expected_target_data_count_in_runtime),
            },
            FieldInfoData {
                name: "ExpectedTargetInstanceCountInRuntime",
                name_hash: 525673819,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LinkDebugEntityData, expected_target_instance_count_in_runtime),
            },
        ],
    }),
    array_type: Some(LINKDEBUGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkDebugEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKDEBUGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKDEBUGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkDebugEntityData-Array",
    name_hash: 118329931,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LinkDebugEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DeltaViewerTableEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub table_name: String,
    pub mode: DeltaViewerMode,
    pub columns: Vec<Option<LockedTypeObject /* DeltaViewerColumn */>>,
}

pub trait DeltaViewerTableEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn table_name(&self) -> &String;
    fn table_name_mut(&mut self) -> &mut String;
    fn mode(&self) -> &DeltaViewerMode;
    fn mode_mut(&mut self) -> &mut DeltaViewerMode;
    fn columns(&self) -> &Vec<Option<LockedTypeObject /* DeltaViewerColumn */>>;
    fn columns_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* DeltaViewerColumn */>>;
}

impl DeltaViewerTableEntityDataTrait for DeltaViewerTableEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn table_name(&self) -> &String {
        &self.table_name
    }
    fn table_name_mut(&mut self) -> &mut String {
        &mut self.table_name
    }
    fn mode(&self) -> &DeltaViewerMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut DeltaViewerMode {
        &mut self.mode
    }
    fn columns(&self) -> &Vec<Option<LockedTypeObject /* DeltaViewerColumn */>> {
        &self.columns
    }
    fn columns_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* DeltaViewerColumn */>> {
        &mut self.columns
    }
}

impl super::entity::EntityDataTrait for DeltaViewerTableEntityData {
}

impl super::entity::GameObjectDataTrait for DeltaViewerTableEntityData {
}

impl super::core::DataBusPeerTrait for DeltaViewerTableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DeltaViewerTableEntityData {
}

impl super::core::DataContainerTrait for DeltaViewerTableEntityData {
}

pub static DELTAVIEWERTABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerTableEntityData",
    name_hash: 3077348562,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DeltaViewerTableEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeltaViewerTableEntityData as Default>::default())),
            create_boxed: || Box::new(<DeltaViewerTableEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DeltaViewerTableEntityData, realm),
            },
            FieldInfoData {
                name: "TableName",
                name_hash: 3117168284,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DeltaViewerTableEntityData, table_name),
            },
            FieldInfoData {
                name: "Mode",
                name_hash: 2088772358,
                flags: MemberInfoFlags::new(0),
                field_type: "DeltaViewerMode",
                rust_offset: offset_of!(DeltaViewerTableEntityData, mode),
            },
            FieldInfoData {
                name: "Columns",
                name_hash: 3656598624,
                flags: MemberInfoFlags::new(144),
                field_type: "DeltaViewerColumn-Array",
                rust_offset: offset_of!(DeltaViewerTableEntityData, columns),
            },
        ],
    }),
    array_type: Some(DELTAVIEWERTABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeltaViewerTableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DELTAVIEWERTABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELTAVIEWERTABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerTableEntityData-Array",
    name_hash: 2823623782,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeltaViewerTableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DeltaViewerMode {
    #[default]
    DeltaViewerMode_Log = 0,
    DeltaViewerMode_Timer = 1,
}

pub static DELTAVIEWERMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerMode",
    name_hash: 3510258724,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DELTAVIEWERMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DeltaViewerMode {
    fn type_info(&self) -> &'static TypeInfo {
        DELTAVIEWERMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DELTAVIEWERMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerMode-Array",
    name_hash: 927006608,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeltaViewerMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DeltaViewerColumn {
    pub _glacier_base: super::core::DataContainer,
    pub column_name: String,
    pub value_type: DeltaViewerColumnValueType,
}

pub trait DeltaViewerColumnTrait: super::core::DataContainerTrait {
    fn column_name(&self) -> &String;
    fn column_name_mut(&mut self) -> &mut String;
    fn value_type(&self) -> &DeltaViewerColumnValueType;
    fn value_type_mut(&mut self) -> &mut DeltaViewerColumnValueType;
}

impl DeltaViewerColumnTrait for DeltaViewerColumn {
    fn column_name(&self) -> &String {
        &self.column_name
    }
    fn column_name_mut(&mut self) -> &mut String {
        &mut self.column_name
    }
    fn value_type(&self) -> &DeltaViewerColumnValueType {
        &self.value_type
    }
    fn value_type_mut(&mut self) -> &mut DeltaViewerColumnValueType {
        &mut self.value_type
    }
}

impl super::core::DataContainerTrait for DeltaViewerColumn {
}

pub static DELTAVIEWERCOLUMN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerColumn",
    name_hash: 82223185,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(DeltaViewerColumn, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeltaViewerColumn as Default>::default())),
            create_boxed: || Box::new(<DeltaViewerColumn as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ColumnName",
                name_hash: 2660119028,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DeltaViewerColumn, column_name),
            },
            FieldInfoData {
                name: "ValueType",
                name_hash: 1235276758,
                flags: MemberInfoFlags::new(0),
                field_type: "DeltaViewerColumnValueType",
                rust_offset: offset_of!(DeltaViewerColumn, value_type),
            },
        ],
    }),
    array_type: Some(DELTAVIEWERCOLUMN_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeltaViewerColumn {
    fn type_info(&self) -> &'static TypeInfo {
        DELTAVIEWERCOLUMN_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELTAVIEWERCOLUMN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerColumn-Array",
    name_hash: 623252069,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeltaViewerColumn"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DeltaViewerColumnValueType {
    #[default]
    DeltaViewerColumnValueType_Bool = 0,
    DeltaViewerColumnValueType_Float = 1,
    DeltaViewerColumnValueType_Int = 2,
    DeltaViewerColumnValueType_String = 3,
    DeltaViewerColumnValueType_Count = 4,
}

pub static DELTAVIEWERCOLUMNVALUETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerColumnValueType",
    name_hash: 2876982530,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DELTAVIEWERCOLUMNVALUETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DeltaViewerColumnValueType {
    fn type_info(&self) -> &'static TypeInfo {
        DELTAVIEWERCOLUMNVALUETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DELTAVIEWERCOLUMNVALUETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerColumnValueType-Array",
    name_hash: 2355487798,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeltaViewerColumnValueType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PropertyDebugEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub text_color: super::core::Vec3,
    pub screen_position: super::core::Vec2,
    pub world_position: super::core::Vec3,
    pub value_prefix: String,
    pub multiline: bool,
    pub show_transform_in_world: bool,
    pub show_transform_coordinates: bool,
    pub default_visible: bool,
    pub text_scale: f32,
    pub draw_graph: bool,
    pub graph_size: super::core::Vec2,
    pub graph_mode: PropertyDebugGraphMode,
    pub graph_value_min_max: super::core::Vec2,
    pub float_value: f32,
    pub int_value: i32,
    pub transform_value: super::core::LinearTransform,
    pub vec2_value: super::core::Vec2,
    pub vec3_value: super::core::Vec3,
    pub vec4_value: super::core::Vec4,
    pub string_value: String,
}

pub trait PropertyDebugEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn text_color(&self) -> &super::core::Vec3;
    fn text_color_mut(&mut self) -> &mut super::core::Vec3;
    fn screen_position(&self) -> &super::core::Vec2;
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2;
    fn world_position(&self) -> &super::core::Vec3;
    fn world_position_mut(&mut self) -> &mut super::core::Vec3;
    fn value_prefix(&self) -> &String;
    fn value_prefix_mut(&mut self) -> &mut String;
    fn multiline(&self) -> &bool;
    fn multiline_mut(&mut self) -> &mut bool;
    fn show_transform_in_world(&self) -> &bool;
    fn show_transform_in_world_mut(&mut self) -> &mut bool;
    fn show_transform_coordinates(&self) -> &bool;
    fn show_transform_coordinates_mut(&mut self) -> &mut bool;
    fn default_visible(&self) -> &bool;
    fn default_visible_mut(&mut self) -> &mut bool;
    fn text_scale(&self) -> &f32;
    fn text_scale_mut(&mut self) -> &mut f32;
    fn draw_graph(&self) -> &bool;
    fn draw_graph_mut(&mut self) -> &mut bool;
    fn graph_size(&self) -> &super::core::Vec2;
    fn graph_size_mut(&mut self) -> &mut super::core::Vec2;
    fn graph_mode(&self) -> &PropertyDebugGraphMode;
    fn graph_mode_mut(&mut self) -> &mut PropertyDebugGraphMode;
    fn graph_value_min_max(&self) -> &super::core::Vec2;
    fn graph_value_min_max_mut(&mut self) -> &mut super::core::Vec2;
    fn float_value(&self) -> &f32;
    fn float_value_mut(&mut self) -> &mut f32;
    fn int_value(&self) -> &i32;
    fn int_value_mut(&mut self) -> &mut i32;
    fn transform_value(&self) -> &super::core::LinearTransform;
    fn transform_value_mut(&mut self) -> &mut super::core::LinearTransform;
    fn vec2_value(&self) -> &super::core::Vec2;
    fn vec2_value_mut(&mut self) -> &mut super::core::Vec2;
    fn vec3_value(&self) -> &super::core::Vec3;
    fn vec3_value_mut(&mut self) -> &mut super::core::Vec3;
    fn vec4_value(&self) -> &super::core::Vec4;
    fn vec4_value_mut(&mut self) -> &mut super::core::Vec4;
    fn string_value(&self) -> &String;
    fn string_value_mut(&mut self) -> &mut String;
}

impl PropertyDebugEntityDataTrait for PropertyDebugEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn text_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.text_color
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.screen_position
    }
    fn world_position(&self) -> &super::core::Vec3 {
        &self.world_position
    }
    fn world_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.world_position
    }
    fn value_prefix(&self) -> &String {
        &self.value_prefix
    }
    fn value_prefix_mut(&mut self) -> &mut String {
        &mut self.value_prefix
    }
    fn multiline(&self) -> &bool {
        &self.multiline
    }
    fn multiline_mut(&mut self) -> &mut bool {
        &mut self.multiline
    }
    fn show_transform_in_world(&self) -> &bool {
        &self.show_transform_in_world
    }
    fn show_transform_in_world_mut(&mut self) -> &mut bool {
        &mut self.show_transform_in_world
    }
    fn show_transform_coordinates(&self) -> &bool {
        &self.show_transform_coordinates
    }
    fn show_transform_coordinates_mut(&mut self) -> &mut bool {
        &mut self.show_transform_coordinates
    }
    fn default_visible(&self) -> &bool {
        &self.default_visible
    }
    fn default_visible_mut(&mut self) -> &mut bool {
        &mut self.default_visible
    }
    fn text_scale(&self) -> &f32 {
        &self.text_scale
    }
    fn text_scale_mut(&mut self) -> &mut f32 {
        &mut self.text_scale
    }
    fn draw_graph(&self) -> &bool {
        &self.draw_graph
    }
    fn draw_graph_mut(&mut self) -> &mut bool {
        &mut self.draw_graph
    }
    fn graph_size(&self) -> &super::core::Vec2 {
        &self.graph_size
    }
    fn graph_size_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.graph_size
    }
    fn graph_mode(&self) -> &PropertyDebugGraphMode {
        &self.graph_mode
    }
    fn graph_mode_mut(&mut self) -> &mut PropertyDebugGraphMode {
        &mut self.graph_mode
    }
    fn graph_value_min_max(&self) -> &super::core::Vec2 {
        &self.graph_value_min_max
    }
    fn graph_value_min_max_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.graph_value_min_max
    }
    fn float_value(&self) -> &f32 {
        &self.float_value
    }
    fn float_value_mut(&mut self) -> &mut f32 {
        &mut self.float_value
    }
    fn int_value(&self) -> &i32 {
        &self.int_value
    }
    fn int_value_mut(&mut self) -> &mut i32 {
        &mut self.int_value
    }
    fn transform_value(&self) -> &super::core::LinearTransform {
        &self.transform_value
    }
    fn transform_value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform_value
    }
    fn vec2_value(&self) -> &super::core::Vec2 {
        &self.vec2_value
    }
    fn vec2_value_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.vec2_value
    }
    fn vec3_value(&self) -> &super::core::Vec3 {
        &self.vec3_value
    }
    fn vec3_value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.vec3_value
    }
    fn vec4_value(&self) -> &super::core::Vec4 {
        &self.vec4_value
    }
    fn vec4_value_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.vec4_value
    }
    fn string_value(&self) -> &String {
        &self.string_value
    }
    fn string_value_mut(&mut self) -> &mut String {
        &mut self.string_value
    }
}

impl super::entity::EntityDataTrait for PropertyDebugEntityData {
}

impl super::entity::GameObjectDataTrait for PropertyDebugEntityData {
}

impl super::core::DataBusPeerTrait for PropertyDebugEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PropertyDebugEntityData {
}

impl super::core::DataContainerTrait for PropertyDebugEntityData {
}

pub static PROPERTYDEBUGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyDebugEntityData",
    name_hash: 2134957656,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PropertyDebugEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyDebugEntityData as Default>::default())),
            create_boxed: || Box::new(<PropertyDebugEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PropertyDebugEntityData, realm),
            },
            FieldInfoData {
                name: "TextColor",
                name_hash: 2527550245,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PropertyDebugEntityData, text_color),
            },
            FieldInfoData {
                name: "ScreenPosition",
                name_hash: 2288910864,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PropertyDebugEntityData, screen_position),
            },
            FieldInfoData {
                name: "WorldPosition",
                name_hash: 2133906686,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PropertyDebugEntityData, world_position),
            },
            FieldInfoData {
                name: "ValuePrefix",
                name_hash: 1051050718,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PropertyDebugEntityData, value_prefix),
            },
            FieldInfoData {
                name: "Multiline",
                name_hash: 1101961090,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, multiline),
            },
            FieldInfoData {
                name: "ShowTransformInWorld",
                name_hash: 813393455,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, show_transform_in_world),
            },
            FieldInfoData {
                name: "ShowTransformCoordinates",
                name_hash: 3087196475,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, show_transform_coordinates),
            },
            FieldInfoData {
                name: "DefaultVisible",
                name_hash: 3341302816,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, default_visible),
            },
            FieldInfoData {
                name: "TextScale",
                name_hash: 2508713728,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PropertyDebugEntityData, text_scale),
            },
            FieldInfoData {
                name: "DrawGraph",
                name_hash: 2390505385,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, draw_graph),
            },
            FieldInfoData {
                name: "GraphSize",
                name_hash: 1669730924,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PropertyDebugEntityData, graph_size),
            },
            FieldInfoData {
                name: "GraphMode",
                name_hash: 1669091178,
                flags: MemberInfoFlags::new(0),
                field_type: "PropertyDebugGraphMode",
                rust_offset: offset_of!(PropertyDebugEntityData, graph_mode),
            },
            FieldInfoData {
                name: "GraphValueMinMax",
                name_hash: 1284970780,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PropertyDebugEntityData, graph_value_min_max),
            },
            FieldInfoData {
                name: "FloatValue",
                name_hash: 3123792190,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PropertyDebugEntityData, float_value),
            },
            FieldInfoData {
                name: "IntValue",
                name_hash: 5685821,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyDebugEntityData, int_value),
            },
            FieldInfoData {
                name: "TransformValue",
                name_hash: 3606782274,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PropertyDebugEntityData, transform_value),
            },
            FieldInfoData {
                name: "Vec2Value",
                name_hash: 311491116,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PropertyDebugEntityData, vec2_value),
            },
            FieldInfoData {
                name: "Vec3Value",
                name_hash: 277101325,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PropertyDebugEntityData, vec3_value),
            },
            FieldInfoData {
                name: "Vec4Value",
                name_hash: 242559978,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(PropertyDebugEntityData, vec4_value),
            },
            FieldInfoData {
                name: "StringValue",
                name_hash: 1269878171,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PropertyDebugEntityData, string_value),
            },
        ],
    }),
    array_type: Some(PROPERTYDEBUGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PropertyDebugEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYDEBUGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYDEBUGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyDebugEntityData-Array",
    name_hash: 2918406380,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PropertyDebugEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PropertyDebugGraphMode {
    #[default]
    PropertyDebugGraphMode_Curve = 0,
    PropertyDebugGraphMode_Bar = 1,
}

pub static PROPERTYDEBUGGRAPHMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyDebugGraphMode",
    name_hash: 1599668764,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PROPERTYDEBUGGRAPHMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PropertyDebugGraphMode {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYDEBUGGRAPHMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PROPERTYDEBUGGRAPHMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyDebugGraphMode-Array",
    name_hash: 1250097704,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PropertyDebugGraphMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PrintDebugTextEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub text: String,
    pub text_color: super::core::Vec3,
    pub screen_position: super::core::Vec2,
    pub use_world_position: bool,
    pub world_position: super::core::Vec3,
    pub visible_at_start: bool,
    pub time_to_show: f32,
    pub text_scale: f32,
    pub enabled: bool,
}

pub trait PrintDebugTextEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn text(&self) -> &String;
    fn text_mut(&mut self) -> &mut String;
    fn text_color(&self) -> &super::core::Vec3;
    fn text_color_mut(&mut self) -> &mut super::core::Vec3;
    fn screen_position(&self) -> &super::core::Vec2;
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2;
    fn use_world_position(&self) -> &bool;
    fn use_world_position_mut(&mut self) -> &mut bool;
    fn world_position(&self) -> &super::core::Vec3;
    fn world_position_mut(&mut self) -> &mut super::core::Vec3;
    fn visible_at_start(&self) -> &bool;
    fn visible_at_start_mut(&mut self) -> &mut bool;
    fn time_to_show(&self) -> &f32;
    fn time_to_show_mut(&mut self) -> &mut f32;
    fn text_scale(&self) -> &f32;
    fn text_scale_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl PrintDebugTextEntityDataTrait for PrintDebugTextEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn text(&self) -> &String {
        &self.text
    }
    fn text_mut(&mut self) -> &mut String {
        &mut self.text
    }
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn text_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.text_color
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.screen_position
    }
    fn use_world_position(&self) -> &bool {
        &self.use_world_position
    }
    fn use_world_position_mut(&mut self) -> &mut bool {
        &mut self.use_world_position
    }
    fn world_position(&self) -> &super::core::Vec3 {
        &self.world_position
    }
    fn world_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.world_position
    }
    fn visible_at_start(&self) -> &bool {
        &self.visible_at_start
    }
    fn visible_at_start_mut(&mut self) -> &mut bool {
        &mut self.visible_at_start
    }
    fn time_to_show(&self) -> &f32 {
        &self.time_to_show
    }
    fn time_to_show_mut(&mut self) -> &mut f32 {
        &mut self.time_to_show
    }
    fn text_scale(&self) -> &f32 {
        &self.text_scale
    }
    fn text_scale_mut(&mut self) -> &mut f32 {
        &mut self.text_scale
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for PrintDebugTextEntityData {
}

impl super::entity::GameObjectDataTrait for PrintDebugTextEntityData {
}

impl super::core::DataBusPeerTrait for PrintDebugTextEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PrintDebugTextEntityData {
}

impl super::core::DataContainerTrait for PrintDebugTextEntityData {
}

pub static PRINTDEBUGTEXTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrintDebugTextEntityData",
    name_hash: 1739052723,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(PrintDebugTextEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PrintDebugTextEntityData as Default>::default())),
            create_boxed: || Box::new(<PrintDebugTextEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PrintDebugTextEntityData, realm),
            },
            FieldInfoData {
                name: "Text",
                name_hash: 2089309304,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PrintDebugTextEntityData, text),
            },
            FieldInfoData {
                name: "TextColor",
                name_hash: 2527550245,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PrintDebugTextEntityData, text_color),
            },
            FieldInfoData {
                name: "ScreenPosition",
                name_hash: 2288910864,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PrintDebugTextEntityData, screen_position),
            },
            FieldInfoData {
                name: "UseWorldPosition",
                name_hash: 1769026525,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PrintDebugTextEntityData, use_world_position),
            },
            FieldInfoData {
                name: "WorldPosition",
                name_hash: 2133906686,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PrintDebugTextEntityData, world_position),
            },
            FieldInfoData {
                name: "VisibleAtStart",
                name_hash: 3191871038,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PrintDebugTextEntityData, visible_at_start),
            },
            FieldInfoData {
                name: "TimeToShow",
                name_hash: 1572258312,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PrintDebugTextEntityData, time_to_show),
            },
            FieldInfoData {
                name: "TextScale",
                name_hash: 2508713728,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PrintDebugTextEntityData, text_scale),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PrintDebugTextEntityData, enabled),
            },
        ],
    }),
    array_type: Some(PRINTDEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PrintDebugTextEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PRINTDEBUGTEXTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PRINTDEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrintDebugTextEntityData-Array",
    name_hash: 2863612423,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PrintDebugTextEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestCullIdCullableEffectEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub effect: Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>,
    pub mode: TestCullIdCullableEffectMode,
}

pub trait TestCullIdCullableEffectEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */>;
    fn mode(&self) -> &TestCullIdCullableEffectMode;
    fn mode_mut(&mut self) -> &mut TestCullIdCullableEffectMode;
}

impl TestCullIdCullableEffectEntityDataTrait for TestCullIdCullableEffectEntityData {
    fn effect(&self) -> &Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &self.effect
    }
    fn effect_mut(&mut self) -> &mut Option<LockedTypeObject /* super::effect_base::EffectBlueprint */> {
        &mut self.effect
    }
    fn mode(&self) -> &TestCullIdCullableEffectMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut TestCullIdCullableEffectMode {
        &mut self.mode
    }
}

impl super::entity::SpatialEntityDataTrait for TestCullIdCullableEffectEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TestCullIdCullableEffectEntityData {
}

impl super::entity::GameObjectDataTrait for TestCullIdCullableEffectEntityData {
}

impl super::core::DataBusPeerTrait for TestCullIdCullableEffectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCullIdCullableEffectEntityData {
}

impl super::core::DataContainerTrait for TestCullIdCullableEffectEntityData {
}

pub static TESTCULLIDCULLABLEEFFECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCullIdCullableEffectEntityData",
    name_hash: 80029096,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestCullIdCullableEffectEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCullIdCullableEffectEntityData as Default>::default())),
            create_boxed: || Box::new(<TestCullIdCullableEffectEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Effect",
                name_hash: 2332983090,
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(TestCullIdCullableEffectEntityData, effect),
            },
            FieldInfoData {
                name: "Mode",
                name_hash: 2088772358,
                flags: MemberInfoFlags::new(0),
                field_type: "TestCullIdCullableEffectMode",
                rust_offset: offset_of!(TestCullIdCullableEffectEntityData, mode),
            },
        ],
    }),
    array_type: Some(TESTCULLIDCULLABLEEFFECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TestCullIdCullableEffectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCULLIDCULLABLEEFFECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCULLIDCULLABLEEFFECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCullIdCullableEffectEntityData-Array",
    name_hash: 640198428,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCullIdCullableEffectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TestCullIdCullableEffectMode {
    #[default]
    FirstPersonOnly = 0,
    FirstViewOnly = 1,
    Any = 2,
}

pub static TESTCULLIDCULLABLEEFFECTMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCullIdCullableEffectMode",
    name_hash: 602446080,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(TESTCULLIDCULLABLEEFFECTMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TestCullIdCullableEffectMode {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCULLIDCULLABLEEFFECTMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TESTCULLIDCULLABLEEFFECTMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCullIdCullableEffectMode-Array",
    name_hash: 1691746100,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCullIdCullableEffectMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestEffectEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub active_ctrl_point_count: i32,
}

pub trait TestEffectEntityDataTrait: super::entity::EntityDataTrait {
    fn active_ctrl_point_count(&self) -> &i32;
    fn active_ctrl_point_count_mut(&mut self) -> &mut i32;
}

impl TestEffectEntityDataTrait for TestEffectEntityData {
    fn active_ctrl_point_count(&self) -> &i32 {
        &self.active_ctrl_point_count
    }
    fn active_ctrl_point_count_mut(&mut self) -> &mut i32 {
        &mut self.active_ctrl_point_count
    }
}

impl super::entity::EntityDataTrait for TestEffectEntityData {
}

impl super::entity::GameObjectDataTrait for TestEffectEntityData {
}

impl super::core::DataBusPeerTrait for TestEffectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestEffectEntityData {
}

impl super::core::DataContainerTrait for TestEffectEntityData {
}

pub static TESTEFFECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestEffectEntityData",
    name_hash: 1204341391,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestEffectEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestEffectEntityData as Default>::default())),
            create_boxed: || Box::new(<TestEffectEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ActiveCtrlPointCount",
                name_hash: 3769406799,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TestEffectEntityData, active_ctrl_point_count),
            },
        ],
    }),
    array_type: Some(TESTEFFECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestEffectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTEFFECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTEFFECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestEffectEntityData-Array",
    name_hash: 221751099,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestEffectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestCaseEntityEffectData {
    pub _glacier_base: super::entity::EntityData,
    pub file_name: String,
    pub file_path_is_from_data_root: bool,
    pub num_simulation_step: u32,
    pub auto_test_screen_shot_mode: bool,
}

pub trait TestCaseEntityEffectDataTrait: super::entity::EntityDataTrait {
    fn file_name(&self) -> &String;
    fn file_name_mut(&mut self) -> &mut String;
    fn file_path_is_from_data_root(&self) -> &bool;
    fn file_path_is_from_data_root_mut(&mut self) -> &mut bool;
    fn num_simulation_step(&self) -> &u32;
    fn num_simulation_step_mut(&mut self) -> &mut u32;
    fn auto_test_screen_shot_mode(&self) -> &bool;
    fn auto_test_screen_shot_mode_mut(&mut self) -> &mut bool;
}

impl TestCaseEntityEffectDataTrait for TestCaseEntityEffectData {
    fn file_name(&self) -> &String {
        &self.file_name
    }
    fn file_name_mut(&mut self) -> &mut String {
        &mut self.file_name
    }
    fn file_path_is_from_data_root(&self) -> &bool {
        &self.file_path_is_from_data_root
    }
    fn file_path_is_from_data_root_mut(&mut self) -> &mut bool {
        &mut self.file_path_is_from_data_root
    }
    fn num_simulation_step(&self) -> &u32 {
        &self.num_simulation_step
    }
    fn num_simulation_step_mut(&mut self) -> &mut u32 {
        &mut self.num_simulation_step
    }
    fn auto_test_screen_shot_mode(&self) -> &bool {
        &self.auto_test_screen_shot_mode
    }
    fn auto_test_screen_shot_mode_mut(&mut self) -> &mut bool {
        &mut self.auto_test_screen_shot_mode
    }
}

impl super::entity::EntityDataTrait for TestCaseEntityEffectData {
}

impl super::entity::GameObjectDataTrait for TestCaseEntityEffectData {
}

impl super::core::DataBusPeerTrait for TestCaseEntityEffectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCaseEntityEffectData {
}

impl super::core::DataContainerTrait for TestCaseEntityEffectData {
}

pub static TESTCASEENTITYEFFECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCaseEntityEffectData",
    name_hash: 520552571,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestCaseEntityEffectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCaseEntityEffectData as Default>::default())),
            create_boxed: || Box::new(<TestCaseEntityEffectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "FileName",
                name_hash: 1134474212,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityEffectData, file_name),
            },
            FieldInfoData {
                name: "FilePathIsFromDataRoot",
                name_hash: 2467196148,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TestCaseEntityEffectData, file_path_is_from_data_root),
            },
            FieldInfoData {
                name: "NumSimulationStep",
                name_hash: 1566039602,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TestCaseEntityEffectData, num_simulation_step),
            },
            FieldInfoData {
                name: "AutoTestScreenShotMode",
                name_hash: 1368323347,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TestCaseEntityEffectData, auto_test_screen_shot_mode),
            },
        ],
    }),
    array_type: Some(TESTCASEENTITYEFFECTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestCaseEntityEffectData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCASEENTITYEFFECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCASEENTITYEFFECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCaseEntityEffectData-Array",
    name_hash: 1207572559,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCaseEntityEffectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ScreenshotComparisonEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub allowed_diff_percentage: i32,
    pub screenshot_name: String,
    pub wait_for_streaming: bool,
    pub wait_frames: u32,
    pub enable_debug_rendering: bool,
}

pub trait ScreenshotComparisonEntityDataTrait: super::entity::EntityDataTrait {
    fn allowed_diff_percentage(&self) -> &i32;
    fn allowed_diff_percentage_mut(&mut self) -> &mut i32;
    fn screenshot_name(&self) -> &String;
    fn screenshot_name_mut(&mut self) -> &mut String;
    fn wait_for_streaming(&self) -> &bool;
    fn wait_for_streaming_mut(&mut self) -> &mut bool;
    fn wait_frames(&self) -> &u32;
    fn wait_frames_mut(&mut self) -> &mut u32;
    fn enable_debug_rendering(&self) -> &bool;
    fn enable_debug_rendering_mut(&mut self) -> &mut bool;
}

impl ScreenshotComparisonEntityDataTrait for ScreenshotComparisonEntityData {
    fn allowed_diff_percentage(&self) -> &i32 {
        &self.allowed_diff_percentage
    }
    fn allowed_diff_percentage_mut(&mut self) -> &mut i32 {
        &mut self.allowed_diff_percentage
    }
    fn screenshot_name(&self) -> &String {
        &self.screenshot_name
    }
    fn screenshot_name_mut(&mut self) -> &mut String {
        &mut self.screenshot_name
    }
    fn wait_for_streaming(&self) -> &bool {
        &self.wait_for_streaming
    }
    fn wait_for_streaming_mut(&mut self) -> &mut bool {
        &mut self.wait_for_streaming
    }
    fn wait_frames(&self) -> &u32 {
        &self.wait_frames
    }
    fn wait_frames_mut(&mut self) -> &mut u32 {
        &mut self.wait_frames
    }
    fn enable_debug_rendering(&self) -> &bool {
        &self.enable_debug_rendering
    }
    fn enable_debug_rendering_mut(&mut self) -> &mut bool {
        &mut self.enable_debug_rendering
    }
}

impl super::entity::EntityDataTrait for ScreenshotComparisonEntityData {
}

impl super::entity::GameObjectDataTrait for ScreenshotComparisonEntityData {
}

impl super::core::DataBusPeerTrait for ScreenshotComparisonEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ScreenshotComparisonEntityData {
}

impl super::core::DataContainerTrait for ScreenshotComparisonEntityData {
}

pub static SCREENSHOTCOMPARISONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenshotComparisonEntityData",
    name_hash: 229357787,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ScreenshotComparisonEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScreenshotComparisonEntityData as Default>::default())),
            create_boxed: || Box::new(<ScreenshotComparisonEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "AllowedDiffPercentage",
                name_hash: 2723143976,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, allowed_diff_percentage),
            },
            FieldInfoData {
                name: "ScreenshotName",
                name_hash: 1815685422,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, screenshot_name),
            },
            FieldInfoData {
                name: "WaitForStreaming",
                name_hash: 1423030249,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, wait_for_streaming),
            },
            FieldInfoData {
                name: "WaitFrames",
                name_hash: 851556672,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, wait_frames),
            },
            FieldInfoData {
                name: "EnableDebugRendering",
                name_hash: 1033260095,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, enable_debug_rendering),
            },
        ],
    }),
    array_type: Some(SCREENSHOTCOMPARISONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScreenshotComparisonEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCREENSHOTCOMPARISONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCREENSHOTCOMPARISONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenshotComparisonEntityData-Array",
    name_hash: 3165069295,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ScreenshotComparisonEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestComponentEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub maximum_distance: f32,
}

pub trait TestComponentEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn maximum_distance(&self) -> &f32;
    fn maximum_distance_mut(&mut self) -> &mut f32;
}

impl TestComponentEntityDataTrait for TestComponentEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn maximum_distance(&self) -> &f32 {
        &self.maximum_distance
    }
    fn maximum_distance_mut(&mut self) -> &mut f32 {
        &mut self.maximum_distance
    }
}

impl super::entity::EntityDataTrait for TestComponentEntityData {
}

impl super::entity::GameObjectDataTrait for TestComponentEntityData {
}

impl super::core::DataBusPeerTrait for TestComponentEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestComponentEntityData {
}

impl super::core::DataContainerTrait for TestComponentEntityData {
}

pub static TESTCOMPONENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestComponentEntityData",
    name_hash: 2075792567,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestComponentEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestComponentEntityData as Default>::default())),
            create_boxed: || Box::new(<TestComponentEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestComponentEntityData, realm),
            },
            FieldInfoData {
                name: "MaximumDistance",
                name_hash: 1689294926,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TestComponentEntityData, maximum_distance),
            },
        ],
    }),
    array_type: Some(TESTCOMPONENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestComponentEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCOMPONENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCOMPONENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestComponentEntityData-Array",
    name_hash: 3224874499,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestComponentEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestPhysicsEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait TestPhysicsEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl TestPhysicsEntityDataTrait for TestPhysicsEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for TestPhysicsEntityData {
}

impl super::entity::GameObjectDataTrait for TestPhysicsEntityData {
}

impl super::core::DataBusPeerTrait for TestPhysicsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestPhysicsEntityData {
}

impl super::core::DataContainerTrait for TestPhysicsEntityData {
}

pub static TESTPHYSICSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPhysicsEntityData",
    name_hash: 1903039315,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestPhysicsEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestPhysicsEntityData as Default>::default())),
            create_boxed: || Box::new(<TestPhysicsEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestPhysicsEntityData, realm),
            },
        ],
    }),
    array_type: Some(TESTPHYSICSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestPhysicsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTPHYSICSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTPHYSICSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPhysicsEntityData-Array",
    name_hash: 2648964711,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestPhysicsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestCaseEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub time_out: f32,
    pub enabled: bool,
    pub test_group: String,
    pub stable: bool,
    pub description: String,
    pub test_case_name: String,
    pub test_author_name: String,
    pub cleanup_timeout: f32,
}

pub trait TestCaseEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn time_out(&self) -> &f32;
    fn time_out_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn test_group(&self) -> &String;
    fn test_group_mut(&mut self) -> &mut String;
    fn stable(&self) -> &bool;
    fn stable_mut(&mut self) -> &mut bool;
    fn description(&self) -> &String;
    fn description_mut(&mut self) -> &mut String;
    fn test_case_name(&self) -> &String;
    fn test_case_name_mut(&mut self) -> &mut String;
    fn test_author_name(&self) -> &String;
    fn test_author_name_mut(&mut self) -> &mut String;
    fn cleanup_timeout(&self) -> &f32;
    fn cleanup_timeout_mut(&mut self) -> &mut f32;
}

impl TestCaseEntityDataTrait for TestCaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn time_out(&self) -> &f32 {
        &self.time_out
    }
    fn time_out_mut(&mut self) -> &mut f32 {
        &mut self.time_out
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn test_group(&self) -> &String {
        &self.test_group
    }
    fn test_group_mut(&mut self) -> &mut String {
        &mut self.test_group
    }
    fn stable(&self) -> &bool {
        &self.stable
    }
    fn stable_mut(&mut self) -> &mut bool {
        &mut self.stable
    }
    fn description(&self) -> &String {
        &self.description
    }
    fn description_mut(&mut self) -> &mut String {
        &mut self.description
    }
    fn test_case_name(&self) -> &String {
        &self.test_case_name
    }
    fn test_case_name_mut(&mut self) -> &mut String {
        &mut self.test_case_name
    }
    fn test_author_name(&self) -> &String {
        &self.test_author_name
    }
    fn test_author_name_mut(&mut self) -> &mut String {
        &mut self.test_author_name
    }
    fn cleanup_timeout(&self) -> &f32 {
        &self.cleanup_timeout
    }
    fn cleanup_timeout_mut(&mut self) -> &mut f32 {
        &mut self.cleanup_timeout
    }
}

impl super::entity::EntityDataTrait for TestCaseEntityData {
}

impl super::entity::GameObjectDataTrait for TestCaseEntityData {
}

impl super::core::DataBusPeerTrait for TestCaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCaseEntityData {
}

impl super::core::DataContainerTrait for TestCaseEntityData {
}

pub static TESTCASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCaseEntityData",
    name_hash: 3022041548,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestCaseEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCaseEntityData as Default>::default())),
            create_boxed: || Box::new(<TestCaseEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestCaseEntityData, realm),
            },
            FieldInfoData {
                name: "TimeOut",
                name_hash: 3344659518,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TestCaseEntityData, time_out),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TestCaseEntityData, enabled),
            },
            FieldInfoData {
                name: "TestGroup",
                name_hash: 1436402060,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityData, test_group),
            },
            FieldInfoData {
                name: "Stable",
                name_hash: 3319702312,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TestCaseEntityData, stable),
            },
            FieldInfoData {
                name: "Description",
                name_hash: 1636673251,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityData, description),
            },
            FieldInfoData {
                name: "TestCaseName",
                name_hash: 2495365472,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityData, test_case_name),
            },
            FieldInfoData {
                name: "TestAuthorName",
                name_hash: 512218785,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityData, test_author_name),
            },
            FieldInfoData {
                name: "CleanupTimeout",
                name_hash: 3330050622,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TestCaseEntityData, cleanup_timeout),
            },
        ],
    }),
    array_type: Some(TESTCASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestCaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCaseEntityData-Array",
    name_hash: 3706761848,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DebugMenuItemEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub item_type: DebugMenuItemType,
    pub text: String,
}

pub trait DebugMenuItemEntityDataTrait: super::entity::EntityDataTrait {
    fn item_type(&self) -> &DebugMenuItemType;
    fn item_type_mut(&mut self) -> &mut DebugMenuItemType;
    fn text(&self) -> &String;
    fn text_mut(&mut self) -> &mut String;
}

impl DebugMenuItemEntityDataTrait for DebugMenuItemEntityData {
    fn item_type(&self) -> &DebugMenuItemType {
        &self.item_type
    }
    fn item_type_mut(&mut self) -> &mut DebugMenuItemType {
        &mut self.item_type
    }
    fn text(&self) -> &String {
        &self.text
    }
    fn text_mut(&mut self) -> &mut String {
        &mut self.text
    }
}

impl super::entity::EntityDataTrait for DebugMenuItemEntityData {
}

impl super::entity::GameObjectDataTrait for DebugMenuItemEntityData {
}

impl super::core::DataBusPeerTrait for DebugMenuItemEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DebugMenuItemEntityData {
}

impl super::core::DataContainerTrait for DebugMenuItemEntityData {
}

pub static DEBUGMENUITEMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuItemEntityData",
    name_hash: 3767424377,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DebugMenuItemEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugMenuItemEntityData as Default>::default())),
            create_boxed: || Box::new(<DebugMenuItemEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "ItemType",
                name_hash: 2972161480,
                flags: MemberInfoFlags::new(0),
                field_type: "DebugMenuItemType",
                rust_offset: offset_of!(DebugMenuItemEntityData, item_type),
            },
            FieldInfoData {
                name: "Text",
                name_hash: 2089309304,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DebugMenuItemEntityData, text),
            },
        ],
    }),
    array_type: Some(DEBUGMENUITEMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DebugMenuItemEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGMENUITEMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGMENUITEMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuItemEntityData-Array",
    name_hash: 1329656909,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DebugMenuItemEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DebugMenuItemType {
    #[default]
    DmitItem = 0,
    DmitToggle = 1,
}

pub static DEBUGMENUITEMTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuItemType",
    name_hash: 2083008170,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DEBUGMENUITEMTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DebugMenuItemType {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGMENUITEMTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DEBUGMENUITEMTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuItemType-Array",
    name_hash: 3257329950,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DebugMenuItemType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DebugMenuSubMenuEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub text: String,
}

pub trait DebugMenuSubMenuEntityDataTrait: super::entity::EntityDataTrait {
    fn text(&self) -> &String;
    fn text_mut(&mut self) -> &mut String;
}

impl DebugMenuSubMenuEntityDataTrait for DebugMenuSubMenuEntityData {
    fn text(&self) -> &String {
        &self.text
    }
    fn text_mut(&mut self) -> &mut String {
        &mut self.text
    }
}

impl super::entity::EntityDataTrait for DebugMenuSubMenuEntityData {
}

impl super::entity::GameObjectDataTrait for DebugMenuSubMenuEntityData {
}

impl super::core::DataBusPeerTrait for DebugMenuSubMenuEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DebugMenuSubMenuEntityData {
}

impl super::core::DataContainerTrait for DebugMenuSubMenuEntityData {
}

pub static DEBUGMENUSUBMENUENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuSubMenuEntityData",
    name_hash: 1642763099,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DebugMenuSubMenuEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugMenuSubMenuEntityData as Default>::default())),
            create_boxed: || Box::new(<DebugMenuSubMenuEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Text",
                name_hash: 2089309304,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DebugMenuSubMenuEntityData, text),
            },
        ],
    }),
    array_type: Some(DEBUGMENUSUBMENUENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DebugMenuSubMenuEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGMENUSUBMENUENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGMENUSUBMENUENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuSubMenuEntityData-Array",
    name_hash: 1547688559,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DebugMenuSubMenuEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ConsoleCommandTriggerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub command_name: String,
    pub group_name: String,
    pub realm: super::core::Realm,
    pub update_defaults_on_changed: bool,
    pub arguments: Vec<String>,
}

pub trait ConsoleCommandTriggerEntityDataTrait: super::entity::EntityDataTrait {
    fn command_name(&self) -> &String;
    fn command_name_mut(&mut self) -> &mut String;
    fn group_name(&self) -> &String;
    fn group_name_mut(&mut self) -> &mut String;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn update_defaults_on_changed(&self) -> &bool;
    fn update_defaults_on_changed_mut(&mut self) -> &mut bool;
    fn arguments(&self) -> &Vec<String>;
    fn arguments_mut(&mut self) -> &mut Vec<String>;
}

impl ConsoleCommandTriggerEntityDataTrait for ConsoleCommandTriggerEntityData {
    fn command_name(&self) -> &String {
        &self.command_name
    }
    fn command_name_mut(&mut self) -> &mut String {
        &mut self.command_name
    }
    fn group_name(&self) -> &String {
        &self.group_name
    }
    fn group_name_mut(&mut self) -> &mut String {
        &mut self.group_name
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn update_defaults_on_changed(&self) -> &bool {
        &self.update_defaults_on_changed
    }
    fn update_defaults_on_changed_mut(&mut self) -> &mut bool {
        &mut self.update_defaults_on_changed
    }
    fn arguments(&self) -> &Vec<String> {
        &self.arguments
    }
    fn arguments_mut(&mut self) -> &mut Vec<String> {
        &mut self.arguments
    }
}

impl super::entity::EntityDataTrait for ConsoleCommandTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for ConsoleCommandTriggerEntityData {
}

impl super::core::DataBusPeerTrait for ConsoleCommandTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ConsoleCommandTriggerEntityData {
}

impl super::core::DataContainerTrait for ConsoleCommandTriggerEntityData {
}

pub static CONSOLECOMMANDTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsoleCommandTriggerEntityData",
    name_hash: 2075200358,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ConsoleCommandTriggerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConsoleCommandTriggerEntityData as Default>::default())),
            create_boxed: || Box::new(<ConsoleCommandTriggerEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "CommandName",
                name_hash: 1071676005,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, command_name),
            },
            FieldInfoData {
                name: "GroupName",
                name_hash: 3178263901,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, group_name),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, realm),
            },
            FieldInfoData {
                name: "UpdateDefaultsOnChanged",
                name_hash: 3482528655,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, update_defaults_on_changed),
            },
            FieldInfoData {
                name: "Arguments",
                name_hash: 435589477,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, arguments),
            },
        ],
    }),
    array_type: Some(CONSOLECOMMANDTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConsoleCommandTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CONSOLECOMMANDTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONSOLECOMMANDTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsoleCommandTriggerEntityData-Array",
    name_hash: 3842140242,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ConsoleCommandTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ConsoleCommandEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub commands: Vec<String>,
    pub dynamic_command: String,
    pub realm: super::core::Realm,
}

pub trait ConsoleCommandEntityDataTrait: super::entity::EntityDataTrait {
    fn commands(&self) -> &Vec<String>;
    fn commands_mut(&mut self) -> &mut Vec<String>;
    fn dynamic_command(&self) -> &String;
    fn dynamic_command_mut(&mut self) -> &mut String;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl ConsoleCommandEntityDataTrait for ConsoleCommandEntityData {
    fn commands(&self) -> &Vec<String> {
        &self.commands
    }
    fn commands_mut(&mut self) -> &mut Vec<String> {
        &mut self.commands
    }
    fn dynamic_command(&self) -> &String {
        &self.dynamic_command
    }
    fn dynamic_command_mut(&mut self) -> &mut String {
        &mut self.dynamic_command
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for ConsoleCommandEntityData {
}

impl super::entity::GameObjectDataTrait for ConsoleCommandEntityData {
}

impl super::core::DataBusPeerTrait for ConsoleCommandEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ConsoleCommandEntityData {
}

impl super::core::DataContainerTrait for ConsoleCommandEntityData {
}

pub static CONSOLECOMMANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsoleCommandEntityData",
    name_hash: 346953054,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ConsoleCommandEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConsoleCommandEntityData as Default>::default())),
            create_boxed: || Box::new(<ConsoleCommandEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Commands",
                name_hash: 442350353,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(ConsoleCommandEntityData, commands),
            },
            FieldInfoData {
                name: "DynamicCommand",
                name_hash: 2291757143,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ConsoleCommandEntityData, dynamic_command),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ConsoleCommandEntityData, realm),
            },
        ],
    }),
    array_type: Some(CONSOLECOMMANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConsoleCommandEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CONSOLECOMMANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONSOLECOMMANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsoleCommandEntityData-Array",
    name_hash: 1604712170,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ConsoleCommandEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct DebugTextEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub debug_text: String,
    pub text_color: super::core::Vec3,
    pub realm: super::core::Realm,
    pub centered: bool,
    pub visible: bool,
    pub scale: f32,
    pub depth_test: bool,
    pub scale_with_distance: bool,
}

pub trait DebugTextEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn debug_text(&self) -> &String;
    fn debug_text_mut(&mut self) -> &mut String;
    fn text_color(&self) -> &super::core::Vec3;
    fn text_color_mut(&mut self) -> &mut super::core::Vec3;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn centered(&self) -> &bool;
    fn centered_mut(&mut self) -> &mut bool;
    fn visible(&self) -> &bool;
    fn visible_mut(&mut self) -> &mut bool;
    fn scale(&self) -> &f32;
    fn scale_mut(&mut self) -> &mut f32;
    fn depth_test(&self) -> &bool;
    fn depth_test_mut(&mut self) -> &mut bool;
    fn scale_with_distance(&self) -> &bool;
    fn scale_with_distance_mut(&mut self) -> &mut bool;
}

impl DebugTextEntityDataTrait for DebugTextEntityData {
    fn debug_text(&self) -> &String {
        &self.debug_text
    }
    fn debug_text_mut(&mut self) -> &mut String {
        &mut self.debug_text
    }
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn text_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.text_color
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn centered(&self) -> &bool {
        &self.centered
    }
    fn centered_mut(&mut self) -> &mut bool {
        &mut self.centered
    }
    fn visible(&self) -> &bool {
        &self.visible
    }
    fn visible_mut(&mut self) -> &mut bool {
        &mut self.visible
    }
    fn scale(&self) -> &f32 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut f32 {
        &mut self.scale
    }
    fn depth_test(&self) -> &bool {
        &self.depth_test
    }
    fn depth_test_mut(&mut self) -> &mut bool {
        &mut self.depth_test
    }
    fn scale_with_distance(&self) -> &bool {
        &self.scale_with_distance
    }
    fn scale_with_distance_mut(&mut self) -> &mut bool {
        &mut self.scale_with_distance
    }
}

impl super::entity::SpatialEntityDataTrait for DebugTextEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DebugTextEntityData {
}

impl super::entity::GameObjectDataTrait for DebugTextEntityData {
}

impl super::core::DataBusPeerTrait for DebugTextEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DebugTextEntityData {
}

impl super::core::DataContainerTrait for DebugTextEntityData {
}

pub static DEBUGTEXTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugTextEntityData",
    name_hash: 3556399330,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(DebugTextEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugTextEntityData as Default>::default())),
            create_boxed: || Box::new(<DebugTextEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DebugText",
                name_hash: 859165769,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DebugTextEntityData, debug_text),
            },
            FieldInfoData {
                name: "TextColor",
                name_hash: 2527550245,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DebugTextEntityData, text_color),
            },
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DebugTextEntityData, realm),
            },
            FieldInfoData {
                name: "Centered",
                name_hash: 2363373967,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugTextEntityData, centered),
            },
            FieldInfoData {
                name: "Visible",
                name_hash: 901540267,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugTextEntityData, visible),
            },
            FieldInfoData {
                name: "Scale",
                name_hash: 231223453,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DebugTextEntityData, scale),
            },
            FieldInfoData {
                name: "DepthTest",
                name_hash: 969307550,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugTextEntityData, depth_test),
            },
            FieldInfoData {
                name: "ScaleWithDistance",
                name_hash: 646053404,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugTextEntityData, scale_with_distance),
            },
        ],
    }),
    array_type: Some(DEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DebugTextEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGTEXTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugTextEntityData-Array",
    name_hash: 808462294,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DebugTextEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestCollisionEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub expected_body_collisions: u32,
}

pub trait TestCollisionEventEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn expected_body_collisions(&self) -> &u32;
    fn expected_body_collisions_mut(&mut self) -> &mut u32;
}

impl TestCollisionEventEntityDataTrait for TestCollisionEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn expected_body_collisions(&self) -> &u32 {
        &self.expected_body_collisions
    }
    fn expected_body_collisions_mut(&mut self) -> &mut u32 {
        &mut self.expected_body_collisions
    }
}

impl super::entity::EntityDataTrait for TestCollisionEventEntityData {
}

impl super::entity::GameObjectDataTrait for TestCollisionEventEntityData {
}

impl super::core::DataBusPeerTrait for TestCollisionEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCollisionEventEntityData {
}

impl super::core::DataContainerTrait for TestCollisionEventEntityData {
}

pub static TESTCOLLISIONEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCollisionEventEntityData",
    name_hash: 2638028682,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestCollisionEventEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCollisionEventEntityData as Default>::default())),
            create_boxed: || Box::new(<TestCollisionEventEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestCollisionEventEntityData, realm),
            },
            FieldInfoData {
                name: "ExpectedBodyCollisions",
                name_hash: 3373577574,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TestCollisionEventEntityData, expected_body_collisions),
            },
        ],
    }),
    array_type: Some(TESTCOLLISIONEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestCollisionEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCOLLISIONEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCOLLISIONEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCollisionEventEntityData-Array",
    name_hash: 3795909310,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCollisionEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TestCollisionEventComponentData {
    pub _glacier_base: super::entity::ComponentData,
    pub realm: super::core::Realm,
    pub expected_client_body_collisions: u32,
    pub expected_server_body_collisions: u32,
}

pub trait TestCollisionEventComponentDataTrait: super::entity::ComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn expected_client_body_collisions(&self) -> &u32;
    fn expected_client_body_collisions_mut(&mut self) -> &mut u32;
    fn expected_server_body_collisions(&self) -> &u32;
    fn expected_server_body_collisions_mut(&mut self) -> &mut u32;
}

impl TestCollisionEventComponentDataTrait for TestCollisionEventComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn expected_client_body_collisions(&self) -> &u32 {
        &self.expected_client_body_collisions
    }
    fn expected_client_body_collisions_mut(&mut self) -> &mut u32 {
        &mut self.expected_client_body_collisions
    }
    fn expected_server_body_collisions(&self) -> &u32 {
        &self.expected_server_body_collisions
    }
    fn expected_server_body_collisions_mut(&mut self) -> &mut u32 {
        &mut self.expected_server_body_collisions
    }
}

impl super::entity::ComponentDataTrait for TestCollisionEventComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for TestCollisionEventComponentData {
}

impl super::core::DataBusPeerTrait for TestCollisionEventComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCollisionEventComponentData {
}

impl super::core::DataContainerTrait for TestCollisionEventComponentData {
}

pub static TESTCOLLISIONEVENTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCollisionEventComponentData",
    name_hash: 1585587678,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(TestCollisionEventComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCollisionEventComponentData as Default>::default())),
            create_boxed: || Box::new(<TestCollisionEventComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestCollisionEventComponentData, realm),
            },
            FieldInfoData {
                name: "ExpectedClientBodyCollisions",
                name_hash: 3429908255,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TestCollisionEventComponentData, expected_client_body_collisions),
            },
            FieldInfoData {
                name: "ExpectedServerBodyCollisions",
                name_hash: 1848059715,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TestCollisionEventComponentData, expected_server_body_collisions),
            },
        ],
    }),
    array_type: Some(TESTCOLLISIONEVENTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TestCollisionEventComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCOLLISIONEVENTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCOLLISIONEVENTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCollisionEventComponentData-Array",
    name_hash: 3647235946,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCollisionEventComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct TerrainDynamicDecalEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub physics_material: super::entity::MaterialDecl,
}

pub trait TerrainDynamicDecalEntityDataTrait: super::entity::EntityDataTrait {
    fn physics_material(&self) -> &super::entity::MaterialDecl;
    fn physics_material_mut(&mut self) -> &mut super::entity::MaterialDecl;
}

impl TerrainDynamicDecalEntityDataTrait for TerrainDynamicDecalEntityData {
    fn physics_material(&self) -> &super::entity::MaterialDecl {
        &self.physics_material
    }
    fn physics_material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.physics_material
    }
}

impl super::entity::EntityDataTrait for TerrainDynamicDecalEntityData {
}

impl super::entity::GameObjectDataTrait for TerrainDynamicDecalEntityData {
}

impl super::core::DataBusPeerTrait for TerrainDynamicDecalEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TerrainDynamicDecalEntityData {
}

impl super::core::DataContainerTrait for TerrainDynamicDecalEntityData {
}

pub static TERRAINDYNAMICDECALENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TerrainDynamicDecalEntityData",
    name_hash: 749708355,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(TerrainDynamicDecalEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TerrainDynamicDecalEntityData as Default>::default())),
            create_boxed: || Box::new(<TerrainDynamicDecalEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsMaterial",
                name_hash: 2409463941,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(TerrainDynamicDecalEntityData, physics_material),
            },
        ],
    }),
    array_type: Some(TERRAINDYNAMICDECALENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TerrainDynamicDecalEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TERRAINDYNAMICDECALENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TERRAINDYNAMICDECALENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TerrainDynamicDecalEntityData-Array",
    name_hash: 4072376183,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TerrainDynamicDecalEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SyncedSequenceEntityData {
    pub _glacier_base: super::entity::SequenceEntityData,
}

pub trait SyncedSequenceEntityDataTrait: super::entity::SequenceEntityDataTrait {
}

impl SyncedSequenceEntityDataTrait for SyncedSequenceEntityData {
}

impl super::entity::SequenceEntityDataTrait for SyncedSequenceEntityData {
    fn events(&self) -> &Vec<BoxedTypeObject /* super::entity::SequenceEventData */> {
        self._glacier_base.events()
    }
    fn events_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::entity::SequenceEventData */> {
        self._glacier_base.events_mut()
    }
    fn sequence_start_time(&self) -> &i32 {
        self._glacier_base.sequence_start_time()
    }
    fn sequence_start_time_mut(&mut self) -> &mut i32 {
        self._glacier_base.sequence_start_time_mut()
    }
    fn sequence_length(&self) -> &i32 {
        self._glacier_base.sequence_length()
    }
    fn sequence_length_mut(&mut self) -> &mut i32 {
        self._glacier_base.sequence_length_mut()
    }
    fn looping(&self) -> &bool {
        self._glacier_base.looping()
    }
    fn looping_mut(&mut self) -> &mut bool {
        self._glacier_base.looping_mut()
    }
    fn auto_start(&self) -> &bool {
        self._glacier_base.auto_start()
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_start_mut()
    }
    fn auto_play_first_frame(&self) -> &bool {
        self._glacier_base.auto_play_first_frame()
    }
    fn auto_play_first_frame_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_play_first_frame_mut()
    }
    fn play_in_reverse(&self) -> &bool {
        self._glacier_base.play_in_reverse()
    }
    fn play_in_reverse_mut(&mut self) -> &mut bool {
        self._glacier_base.play_in_reverse_mut()
    }
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn property_tracks(&self) -> &Vec<Option<LockedTypeObject /* super::entity::PropertyTrackData */>> {
        self._glacier_base.property_tracks()
    }
    fn property_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::PropertyTrackData */>> {
        self._glacier_base.property_tracks_mut()
    }
    fn custom_sequence_tracks(&self) -> &Vec<Option<LockedTypeObject /* super::entity::CustomSequenceTrackData */>> {
        self._glacier_base.custom_sequence_tracks()
    }
    fn custom_sequence_tracks_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::CustomSequenceTrackData */>> {
        self._glacier_base.custom_sequence_tracks_mut()
    }
    fn client_update_pass(&self) -> &super::entity::UpdatePass {
        self._glacier_base.client_update_pass()
    }
    fn client_update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        self._glacier_base.client_update_pass_mut()
    }
    fn server_update_pass(&self) -> &super::entity::UpdatePass {
        self._glacier_base.server_update_pass()
    }
    fn server_update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        self._glacier_base.server_update_pass_mut()
    }
    fn external_time(&self) -> &f32 {
        self._glacier_base.external_time()
    }
    fn external_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.external_time_mut()
    }
    fn playback_speed(&self) -> &f32 {
        self._glacier_base.playback_speed()
    }
    fn playback_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.playback_speed_mut()
    }
}

impl super::entity::EntityDataTrait for SyncedSequenceEntityData {
}

impl super::entity::GameObjectDataTrait for SyncedSequenceEntityData {
}

impl super::core::DataBusPeerTrait for SyncedSequenceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SyncedSequenceEntityData {
}

impl super::core::DataContainerTrait for SyncedSequenceEntityData {
}

pub static SYNCEDSEQUENCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SyncedSequenceEntityData",
    name_hash: 3872248759,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SEQUENCEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SyncedSequenceEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SyncedSequenceEntityData as Default>::default())),
            create_boxed: || Box::new(<SyncedSequenceEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SYNCEDSEQUENCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SyncedSequenceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SYNCEDSEQUENCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SYNCEDSEQUENCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SyncedSequenceEntityData-Array",
    name_hash: 2698947843,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SyncedSequenceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameSubViewData {
    pub _glacier_base: super::gameplay_sim::SubViewData,
}

pub trait GameSubViewDataTrait: super::gameplay_sim::SubViewDataTrait {
}

impl GameSubViewDataTrait for GameSubViewData {
}

impl super::gameplay_sim::SubViewDataTrait for GameSubViewData {
}

impl super::core::DataContainerTrait for GameSubViewData {
}

pub static GAMESUBVIEWDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSubViewData",
    name_hash: 1902018450,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::SUBVIEWDATA_TYPE_INFO),
        super_class_offset: offset_of!(GameSubViewData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameSubViewData as Default>::default())),
            create_boxed: || Box::new(<GameSubViewData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMESUBVIEWDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameSubViewData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMESUBVIEWDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMESUBVIEWDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSubViewData-Array",
    name_hash: 4009608870,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameSubViewData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpectatorSubViewData {
    pub _glacier_base: super::gameplay_sim::SubViewData,
}

pub trait SpectatorSubViewDataTrait: super::gameplay_sim::SubViewDataTrait {
}

impl SpectatorSubViewDataTrait for SpectatorSubViewData {
}

impl super::gameplay_sim::SubViewDataTrait for SpectatorSubViewData {
}

impl super::core::DataContainerTrait for SpectatorSubViewData {
}

pub static SPECTATORSUBVIEWDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpectatorSubViewData",
    name_hash: 2764246469,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::SUBVIEWDATA_TYPE_INFO),
        super_class_offset: offset_of!(SpectatorSubViewData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpectatorSubViewData as Default>::default())),
            create_boxed: || Box::new(<SpectatorSubViewData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SPECTATORSUBVIEWDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpectatorSubViewData {
    fn type_info(&self) -> &'static TypeInfo {
        SPECTATORSUBVIEWDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPECTATORSUBVIEWDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpectatorSubViewData-Array",
    name_hash: 2494268913,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SpectatorSubViewData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubLevelStatusEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub sub_level_name: String,
}

pub trait SubLevelStatusEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn sub_level_name(&self) -> &String;
    fn sub_level_name_mut(&mut self) -> &mut String;
}

impl SubLevelStatusEntityDataTrait for SubLevelStatusEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn sub_level_name(&self) -> &String {
        &self.sub_level_name
    }
    fn sub_level_name_mut(&mut self) -> &mut String {
        &mut self.sub_level_name
    }
}

impl super::entity::EntityDataTrait for SubLevelStatusEntityData {
}

impl super::entity::GameObjectDataTrait for SubLevelStatusEntityData {
}

impl super::core::DataBusPeerTrait for SubLevelStatusEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SubLevelStatusEntityData {
}

impl super::core::DataContainerTrait for SubLevelStatusEntityData {
}

pub static SUBLEVELSTATUSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelStatusEntityData",
    name_hash: 3979362760,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SubLevelStatusEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelStatusEntityData as Default>::default())),
            create_boxed: || Box::new(<SubLevelStatusEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SubLevelStatusEntityData, realm),
            },
            FieldInfoData {
                name: "SubLevelName",
                name_hash: 1494912880,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SubLevelStatusEntityData, sub_level_name),
            },
        ],
    }),
    array_type: Some(SUBLEVELSTATUSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubLevelStatusEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELSTATUSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBLEVELSTATUSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelStatusEntityData-Array",
    name_hash: 103584892,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SubLevelStatusEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SubLevelPreloadEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub sub_levels_to_preload: Vec<String>,
}

pub trait SubLevelPreloadEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn sub_levels_to_preload(&self) -> &Vec<String>;
    fn sub_levels_to_preload_mut(&mut self) -> &mut Vec<String>;
}

impl SubLevelPreloadEntityDataTrait for SubLevelPreloadEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn sub_levels_to_preload(&self) -> &Vec<String> {
        &self.sub_levels_to_preload
    }
    fn sub_levels_to_preload_mut(&mut self) -> &mut Vec<String> {
        &mut self.sub_levels_to_preload
    }
}

impl super::entity::EntityDataTrait for SubLevelPreloadEntityData {
}

impl super::entity::GameObjectDataTrait for SubLevelPreloadEntityData {
}

impl super::core::DataBusPeerTrait for SubLevelPreloadEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SubLevelPreloadEntityData {
}

impl super::core::DataContainerTrait for SubLevelPreloadEntityData {
}

pub static SUBLEVELPRELOADENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelPreloadEntityData",
    name_hash: 1867148189,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SubLevelPreloadEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelPreloadEntityData as Default>::default())),
            create_boxed: || Box::new(<SubLevelPreloadEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SubLevelPreloadEntityData, realm),
            },
            FieldInfoData {
                name: "SubLevelsToPreload",
                name_hash: 3522207454,
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SubLevelPreloadEntityData, sub_levels_to_preload),
            },
        ],
    }),
    array_type: Some(SUBLEVELPRELOADENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubLevelPreloadEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELPRELOADENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBLEVELPRELOADENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelPreloadEntityData-Array",
    name_hash: 2802341673,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SubLevelPreloadEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticModelNetworkDestructionComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub max_network_id: u32,
}

pub trait StaticModelNetworkDestructionComponentDataTrait: super::entity::GameComponentDataTrait {
    fn max_network_id(&self) -> &u32;
    fn max_network_id_mut(&mut self) -> &mut u32;
}

impl StaticModelNetworkDestructionComponentDataTrait for StaticModelNetworkDestructionComponentData {
    fn max_network_id(&self) -> &u32 {
        &self.max_network_id
    }
    fn max_network_id_mut(&mut self) -> &mut u32 {
        &mut self.max_network_id
    }
}

impl super::entity::GameComponentDataTrait for StaticModelNetworkDestructionComponentData {
}

impl super::entity::ComponentDataTrait for StaticModelNetworkDestructionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelNetworkDestructionComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelNetworkDestructionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelNetworkDestructionComponentData {
}

impl super::core::DataContainerTrait for StaticModelNetworkDestructionComponentData {
}

pub static STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelNetworkDestructionComponentData",
    name_hash: 142916045,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(StaticModelNetworkDestructionComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelNetworkDestructionComponentData as Default>::default())),
            create_boxed: || Box::new(<StaticModelNetworkDestructionComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MaxNetworkId",
                name_hash: 2339059042,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelNetworkDestructionComponentData, max_network_id),
            },
        ],
    }),
    array_type: Some(STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelNetworkDestructionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelNetworkDestructionComponentData-Array",
    name_hash: 1753058809,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelNetworkDestructionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticModelHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait StaticModelHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl StaticModelHealthComponentDataTrait for StaticModelHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for StaticModelHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for StaticModelHealthComponentData {
}

impl super::entity::ComponentDataTrait for StaticModelHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelHealthComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelHealthComponentData {
}

impl super::core::DataContainerTrait for StaticModelHealthComponentData {
}

pub static STATICMODELHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelHealthComponentData",
    name_hash: 2036675505,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(StaticModelHealthComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelHealthComponentData as Default>::default())),
            create_boxed: || Box::new(<StaticModelHealthComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelHealthComponentData-Array",
    name_hash: 2751849989,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticModelPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
}

pub trait StaticModelPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
}

impl StaticModelPhysicsComponentDataTrait for StaticModelPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for StaticModelPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for StaticModelPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for StaticModelPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelPhysicsComponentData {
}

impl super::core::DataContainerTrait for StaticModelPhysicsComponentData {
}

pub static STATICMODELPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelPhysicsComponentData",
    name_hash: 809874950,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(StaticModelPhysicsComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelPhysicsComponentData as Default>::default())),
            create_boxed: || Box::new(<StaticModelPhysicsComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelPhysicsComponentData-Array",
    name_hash: 2529215282,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct InteractableStaticModelEntityData {
    pub _glacier_base: StaticModelEntityData,
}

pub trait InteractableStaticModelEntityDataTrait: StaticModelEntityDataTrait {
}

impl InteractableStaticModelEntityDataTrait for InteractableStaticModelEntityData {
}

impl StaticModelEntityDataTrait for InteractableStaticModelEntityData {
    fn part_links(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links_mut()
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh_mut()
    }
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms()
    }
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms_mut()
    }
    fn exclude_from_nearby_object_destruction(&self) -> &bool {
        self._glacier_base.exclude_from_nearby_object_destruction()
    }
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool {
        self._glacier_base.exclude_from_nearby_object_destruction_mut()
    }
    fn physics_part_infos(&self) -> &Vec<BoxedTypeObject /* PhysicsPartInfo */> {
        self._glacier_base.physics_part_infos()
    }
    fn physics_part_infos_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PhysicsPartInfo */> {
        self._glacier_base.physics_part_infos_mut()
    }
    fn network_info(&self) -> &StaticModelNetworkInfo {
        self._glacier_base.network_info()
    }
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo {
        self._glacier_base.network_info_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
    fn terrain_shader_nodes_enable(&self) -> &bool {
        self._glacier_base.terrain_shader_nodes_enable()
    }
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.terrain_shader_nodes_enable_mut()
    }
    fn explosion_packs_attachable(&self) -> &bool {
        self._glacier_base.explosion_packs_attachable()
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        self._glacier_base.explosion_packs_attachable_mut()
    }
    fn light_map_weight(&self) -> &f32 {
        self._glacier_base.light_map_weight()
    }
    fn light_map_weight_mut(&mut self) -> &mut f32 {
        self._glacier_base.light_map_weight_mut()
    }
    fn visible(&self) -> &bool {
        self._glacier_base.visible()
    }
    fn visible_mut(&mut self) -> &mut bool {
        self._glacier_base.visible_mut()
    }
    fn overlay_enabled(&self) -> &bool {
        self._glacier_base.overlay_enabled()
    }
    fn overlay_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.overlay_enabled_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for InteractableStaticModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for InteractableStaticModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for InteractableStaticModelEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for InteractableStaticModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for InteractableStaticModelEntityData {
}

impl super::entity::GameObjectDataTrait for InteractableStaticModelEntityData {
}

impl super::core::DataBusPeerTrait for InteractableStaticModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for InteractableStaticModelEntityData {
}

impl super::core::DataContainerTrait for InteractableStaticModelEntityData {
}

pub static INTERACTABLESTATICMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InteractableStaticModelEntityData",
    name_hash: 73278529,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(STATICMODELENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(InteractableStaticModelEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InteractableStaticModelEntityData as Default>::default())),
            create_boxed: || Box::new(<InteractableStaticModelEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTERACTABLESTATICMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for InteractableStaticModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTERACTABLESTATICMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTERACTABLESTATICMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InteractableStaticModelEntityData-Array",
    name_hash: 3650997877,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InteractableStaticModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FenceModelEntityData {
    pub _glacier_base: StaticModelEntityData,
    pub width: f32,
    pub angle: f32,
}

pub trait FenceModelEntityDataTrait: StaticModelEntityDataTrait {
    fn width(&self) -> &f32;
    fn width_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
}

impl FenceModelEntityDataTrait for FenceModelEntityData {
    fn width(&self) -> &f32 {
        &self.width
    }
    fn width_mut(&mut self) -> &mut f32 {
        &mut self.width
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
}

impl StaticModelEntityDataTrait for FenceModelEntityData {
    fn part_links(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links_mut()
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh_mut()
    }
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms()
    }
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms_mut()
    }
    fn exclude_from_nearby_object_destruction(&self) -> &bool {
        self._glacier_base.exclude_from_nearby_object_destruction()
    }
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool {
        self._glacier_base.exclude_from_nearby_object_destruction_mut()
    }
    fn physics_part_infos(&self) -> &Vec<BoxedTypeObject /* PhysicsPartInfo */> {
        self._glacier_base.physics_part_infos()
    }
    fn physics_part_infos_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PhysicsPartInfo */> {
        self._glacier_base.physics_part_infos_mut()
    }
    fn network_info(&self) -> &StaticModelNetworkInfo {
        self._glacier_base.network_info()
    }
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo {
        self._glacier_base.network_info_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
    fn terrain_shader_nodes_enable(&self) -> &bool {
        self._glacier_base.terrain_shader_nodes_enable()
    }
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.terrain_shader_nodes_enable_mut()
    }
    fn explosion_packs_attachable(&self) -> &bool {
        self._glacier_base.explosion_packs_attachable()
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        self._glacier_base.explosion_packs_attachable_mut()
    }
    fn light_map_weight(&self) -> &f32 {
        self._glacier_base.light_map_weight()
    }
    fn light_map_weight_mut(&mut self) -> &mut f32 {
        self._glacier_base.light_map_weight_mut()
    }
    fn visible(&self) -> &bool {
        self._glacier_base.visible()
    }
    fn visible_mut(&mut self) -> &mut bool {
        self._glacier_base.visible_mut()
    }
    fn overlay_enabled(&self) -> &bool {
        self._glacier_base.overlay_enabled()
    }
    fn overlay_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.overlay_enabled_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for FenceModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for FenceModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for FenceModelEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for FenceModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for FenceModelEntityData {
}

impl super::entity::GameObjectDataTrait for FenceModelEntityData {
}

impl super::core::DataBusPeerTrait for FenceModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FenceModelEntityData {
}

impl super::core::DataContainerTrait for FenceModelEntityData {
}

pub static FENCEMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FenceModelEntityData",
    name_hash: 2690416522,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(STATICMODELENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(FenceModelEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FenceModelEntityData as Default>::default())),
            create_boxed: || Box::new(<FenceModelEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Width",
                name_hash: 226981187,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FenceModelEntityData, width),
            },
            FieldInfoData {
                name: "Angle",
                name_hash: 205597860,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FenceModelEntityData, angle),
            },
        ],
    }),
    array_type: Some(FENCEMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FenceModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FENCEMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FENCEMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FenceModelEntityData-Array",
    name_hash: 1466456766,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FenceModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct LadderEntityData {
    pub _glacier_base: StaticModelEntityData,
}

pub trait LadderEntityDataTrait: StaticModelEntityDataTrait {
}

impl LadderEntityDataTrait for LadderEntityData {
}

impl StaticModelEntityDataTrait for LadderEntityData {
    fn part_links(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        self._glacier_base.part_links_mut()
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        self._glacier_base.mesh_mut()
    }
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms()
    }
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms_mut()
    }
    fn exclude_from_nearby_object_destruction(&self) -> &bool {
        self._glacier_base.exclude_from_nearby_object_destruction()
    }
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool {
        self._glacier_base.exclude_from_nearby_object_destruction_mut()
    }
    fn physics_part_infos(&self) -> &Vec<BoxedTypeObject /* PhysicsPartInfo */> {
        self._glacier_base.physics_part_infos()
    }
    fn physics_part_infos_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PhysicsPartInfo */> {
        self._glacier_base.physics_part_infos_mut()
    }
    fn network_info(&self) -> &StaticModelNetworkInfo {
        self._glacier_base.network_info()
    }
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo {
        self._glacier_base.network_info_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
    fn terrain_shader_nodes_enable(&self) -> &bool {
        self._glacier_base.terrain_shader_nodes_enable()
    }
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.terrain_shader_nodes_enable_mut()
    }
    fn explosion_packs_attachable(&self) -> &bool {
        self._glacier_base.explosion_packs_attachable()
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        self._glacier_base.explosion_packs_attachable_mut()
    }
    fn light_map_weight(&self) -> &f32 {
        self._glacier_base.light_map_weight()
    }
    fn light_map_weight_mut(&mut self) -> &mut f32 {
        self._glacier_base.light_map_weight_mut()
    }
    fn visible(&self) -> &bool {
        self._glacier_base.visible()
    }
    fn visible_mut(&mut self) -> &mut bool {
        self._glacier_base.visible_mut()
    }
    fn overlay_enabled(&self) -> &bool {
        self._glacier_base.overlay_enabled()
    }
    fn overlay_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.overlay_enabled_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for LadderEntityData {
}

impl super::entity::GameComponentEntityDataTrait for LadderEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for LadderEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for LadderEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LadderEntityData {
}

impl super::entity::GameObjectDataTrait for LadderEntityData {
}

impl super::core::DataBusPeerTrait for LadderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LadderEntityData {
}

impl super::core::DataContainerTrait for LadderEntityData {
}

pub static LADDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LadderEntityData",
    name_hash: 3706821364,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(STATICMODELENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(LadderEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LadderEntityData as Default>::default())),
            create_boxed: || Box::new(<LadderEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(LADDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LadderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LADDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LADDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LadderEntityData-Array",
    name_hash: 2973181632,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LadderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticModelEntityData {
    pub _glacier_base: super::physics::GamePhysicsEntityData,
    pub part_links: Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>>,
    pub mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub base_pose_transforms: super::core::SparseTransformArray,
    pub exclude_from_nearby_object_destruction: bool,
    pub physics_part_infos: Vec<BoxedTypeObject /* PhysicsPartInfo */>,
    pub network_info: StaticModelNetworkInfo,
    pub animate_physics: bool,
    pub terrain_shader_nodes_enable: bool,
    pub explosion_packs_attachable: bool,
    pub light_map_weight: f32,
    pub visible: bool,
    pub overlay_enabled: bool,
}

pub trait StaticModelEntityDataTrait: super::physics::GamePhysicsEntityDataTrait {
    fn part_links(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>>;
    fn part_links_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>>;
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray;
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray;
    fn exclude_from_nearby_object_destruction(&self) -> &bool;
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool;
    fn physics_part_infos(&self) -> &Vec<BoxedTypeObject /* PhysicsPartInfo */>;
    fn physics_part_infos_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PhysicsPartInfo */>;
    fn network_info(&self) -> &StaticModelNetworkInfo;
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo;
    fn animate_physics(&self) -> &bool;
    fn animate_physics_mut(&mut self) -> &mut bool;
    fn terrain_shader_nodes_enable(&self) -> &bool;
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool;
    fn explosion_packs_attachable(&self) -> &bool;
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool;
    fn light_map_weight(&self) -> &f32;
    fn light_map_weight_mut(&mut self) -> &mut f32;
    fn visible(&self) -> &bool;
    fn visible_mut(&mut self) -> &mut bool;
    fn overlay_enabled(&self) -> &bool;
    fn overlay_enabled_mut(&mut self) -> &mut bool;
}

impl StaticModelEntityDataTrait for StaticModelEntityData {
    fn part_links(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        &self.part_links
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::PartLinkData */>> {
        &mut self.part_links
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh
    }
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray {
        &self.base_pose_transforms
    }
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        &mut self.base_pose_transforms
    }
    fn exclude_from_nearby_object_destruction(&self) -> &bool {
        &self.exclude_from_nearby_object_destruction
    }
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool {
        &mut self.exclude_from_nearby_object_destruction
    }
    fn physics_part_infos(&self) -> &Vec<BoxedTypeObject /* PhysicsPartInfo */> {
        &self.physics_part_infos
    }
    fn physics_part_infos_mut(&mut self) -> &mut Vec<BoxedTypeObject /* PhysicsPartInfo */> {
        &mut self.physics_part_infos
    }
    fn network_info(&self) -> &StaticModelNetworkInfo {
        &self.network_info
    }
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo {
        &mut self.network_info
    }
    fn animate_physics(&self) -> &bool {
        &self.animate_physics
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        &mut self.animate_physics
    }
    fn terrain_shader_nodes_enable(&self) -> &bool {
        &self.terrain_shader_nodes_enable
    }
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool {
        &mut self.terrain_shader_nodes_enable
    }
    fn explosion_packs_attachable(&self) -> &bool {
        &self.explosion_packs_attachable
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        &mut self.explosion_packs_attachable
    }
    fn light_map_weight(&self) -> &f32 {
        &self.light_map_weight
    }
    fn light_map_weight_mut(&mut self) -> &mut f32 {
        &mut self.light_map_weight
    }
    fn visible(&self) -> &bool {
        &self.visible
    }
    fn visible_mut(&mut self) -> &mut bool {
        &mut self.visible
    }
    fn overlay_enabled(&self) -> &bool {
        &self.overlay_enabled
    }
    fn overlay_enabled_mut(&mut self) -> &mut bool {
        &mut self.overlay_enabled
    }
}

impl super::physics::GamePhysicsEntityDataTrait for StaticModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for StaticModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for StaticModelEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for StaticModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for StaticModelEntityData {
}

impl super::entity::GameObjectDataTrait for StaticModelEntityData {
}

impl super::core::DataBusPeerTrait for StaticModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelEntityData {
}

impl super::core::DataContainerTrait for StaticModelEntityData {
}

pub static STATICMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelEntityData",
    name_hash: 3410232665,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::GAMEPHYSICSENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(StaticModelEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelEntityData as Default>::default())),
            create_boxed: || Box::new(<StaticModelEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PartLinks",
                name_hash: 3210318177,
                flags: MemberInfoFlags::new(144),
                field_type: "PartLinkData-Array",
                rust_offset: offset_of!(StaticModelEntityData, part_links),
            },
            FieldInfoData {
                name: "Mesh",
                name_hash: 2088783990,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(StaticModelEntityData, mesh),
            },
            FieldInfoData {
                name: "BasePoseTransforms",
                name_hash: 2949884966,
                flags: MemberInfoFlags::new(0),
                field_type: "SparseTransformArray",
                rust_offset: offset_of!(StaticModelEntityData, base_pose_transforms),
            },
            FieldInfoData {
                name: "ExcludeFromNearbyObjectDestruction",
                name_hash: 2293634461,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, exclude_from_nearby_object_destruction),
            },
            FieldInfoData {
                name: "PhysicsPartInfos",
                name_hash: 361299716,
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsPartInfo-Array",
                rust_offset: offset_of!(StaticModelEntityData, physics_part_infos),
            },
            FieldInfoData {
                name: "NetworkInfo",
                name_hash: 2269252597,
                flags: MemberInfoFlags::new(0),
                field_type: "StaticModelNetworkInfo",
                rust_offset: offset_of!(StaticModelEntityData, network_info),
            },
            FieldInfoData {
                name: "AnimatePhysics",
                name_hash: 443997333,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, animate_physics),
            },
            FieldInfoData {
                name: "TerrainShaderNodesEnable",
                name_hash: 2849017449,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, terrain_shader_nodes_enable),
            },
            FieldInfoData {
                name: "ExplosionPacksAttachable",
                name_hash: 2851996027,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, explosion_packs_attachable),
            },
            FieldInfoData {
                name: "LightMapWeight",
                name_hash: 1434429415,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticModelEntityData, light_map_weight),
            },
            FieldInfoData {
                name: "Visible",
                name_hash: 901540267,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, visible),
            },
            FieldInfoData {
                name: "OverlayEnabled",
                name_hash: 545693530,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, overlay_enabled),
            },
        ],
    }),
    array_type: Some(STATICMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelEntityData-Array",
    name_hash: 2042270573,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct StaticModelNetworkInfo {
    pub part_network_id_ranges: Vec<BoxedTypeObject /* IndexRange */>,
    pub network_id_count: u32,
    pub child_network_infos: Vec<BoxedTypeObject /* ChildStaticModelNetworkInfo */>,
    pub child_network_id_count: u32,
}

pub trait StaticModelNetworkInfoTrait: TypeObject {
    fn part_network_id_ranges(&self) -> &Vec<BoxedTypeObject /* IndexRange */>;
    fn part_network_id_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* IndexRange */>;
    fn network_id_count(&self) -> &u32;
    fn network_id_count_mut(&mut self) -> &mut u32;
    fn child_network_infos(&self) -> &Vec<BoxedTypeObject /* ChildStaticModelNetworkInfo */>;
    fn child_network_infos_mut(&mut self) -> &mut Vec<BoxedTypeObject /* ChildStaticModelNetworkInfo */>;
    fn child_network_id_count(&self) -> &u32;
    fn child_network_id_count_mut(&mut self) -> &mut u32;
}

impl StaticModelNetworkInfoTrait for StaticModelNetworkInfo {
    fn part_network_id_ranges(&self) -> &Vec<BoxedTypeObject /* IndexRange */> {
        &self.part_network_id_ranges
    }
    fn part_network_id_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* IndexRange */> {
        &mut self.part_network_id_ranges
    }
    fn network_id_count(&self) -> &u32 {
        &self.network_id_count
    }
    fn network_id_count_mut(&mut self) -> &mut u32 {
        &mut self.network_id_count
    }
    fn child_network_infos(&self) -> &Vec<BoxedTypeObject /* ChildStaticModelNetworkInfo */> {
        &self.child_network_infos
    }
    fn child_network_infos_mut(&mut self) -> &mut Vec<BoxedTypeObject /* ChildStaticModelNetworkInfo */> {
        &mut self.child_network_infos
    }
    fn child_network_id_count(&self) -> &u32 {
        &self.child_network_id_count
    }
    fn child_network_id_count_mut(&mut self) -> &mut u32 {
        &mut self.child_network_id_count
    }
}

pub static STATICMODELNETWORKINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelNetworkInfo",
    name_hash: 3014820962,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelNetworkInfo as Default>::default())),
            create_boxed: || Box::new(<StaticModelNetworkInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PartNetworkIdRanges",
                name_hash: 2560941869,
                flags: MemberInfoFlags::new(144),
                field_type: "IndexRange-Array",
                rust_offset: offset_of!(StaticModelNetworkInfo, part_network_id_ranges),
            },
            FieldInfoData {
                name: "NetworkIdCount",
                name_hash: 1234693717,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelNetworkInfo, network_id_count),
            },
            FieldInfoData {
                name: "ChildNetworkInfos",
                name_hash: 3109636684,
                flags: MemberInfoFlags::new(144),
                field_type: "ChildStaticModelNetworkInfo-Array",
                rust_offset: offset_of!(StaticModelNetworkInfo, child_network_infos),
            },
            FieldInfoData {
                name: "ChildNetworkIdCount",
                name_hash: 2318313855,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelNetworkInfo, child_network_id_count),
            },
        ],
    }),
    array_type: Some(STATICMODELNETWORKINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StaticModelNetworkInfo {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELNETWORKINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STATICMODELNETWORKINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelNetworkInfo-Array",
    name_hash: 2134569814,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelNetworkInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ChildStaticModelNetworkInfo {
    pub network_range: IndexRange,
    pub parent_part_component_index: u32,
    pub parent_health_state_index: u32,
    pub instance_index: u32,
}

pub trait ChildStaticModelNetworkInfoTrait: TypeObject {
    fn network_range(&self) -> &IndexRange;
    fn network_range_mut(&mut self) -> &mut IndexRange;
    fn parent_part_component_index(&self) -> &u32;
    fn parent_part_component_index_mut(&mut self) -> &mut u32;
    fn parent_health_state_index(&self) -> &u32;
    fn parent_health_state_index_mut(&mut self) -> &mut u32;
    fn instance_index(&self) -> &u32;
    fn instance_index_mut(&mut self) -> &mut u32;
}

impl ChildStaticModelNetworkInfoTrait for ChildStaticModelNetworkInfo {
    fn network_range(&self) -> &IndexRange {
        &self.network_range
    }
    fn network_range_mut(&mut self) -> &mut IndexRange {
        &mut self.network_range
    }
    fn parent_part_component_index(&self) -> &u32 {
        &self.parent_part_component_index
    }
    fn parent_part_component_index_mut(&mut self) -> &mut u32 {
        &mut self.parent_part_component_index
    }
    fn parent_health_state_index(&self) -> &u32 {
        &self.parent_health_state_index
    }
    fn parent_health_state_index_mut(&mut self) -> &mut u32 {
        &mut self.parent_health_state_index
    }
    fn instance_index(&self) -> &u32 {
        &self.instance_index
    }
    fn instance_index_mut(&mut self) -> &mut u32 {
        &mut self.instance_index
    }
}

pub static CHILDSTATICMODELNETWORKINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildStaticModelNetworkInfo",
    name_hash: 3972278600,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildStaticModelNetworkInfo as Default>::default())),
            create_boxed: || Box::new(<ChildStaticModelNetworkInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "NetworkRange",
                name_hash: 1862047044,
                flags: MemberInfoFlags::new(0),
                field_type: "IndexRange",
                rust_offset: offset_of!(ChildStaticModelNetworkInfo, network_range),
            },
            FieldInfoData {
                name: "ParentPartComponentIndex",
                name_hash: 2200889407,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ChildStaticModelNetworkInfo, parent_part_component_index),
            },
            FieldInfoData {
                name: "ParentHealthStateIndex",
                name_hash: 3385119660,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ChildStaticModelNetworkInfo, parent_health_state_index),
            },
            FieldInfoData {
                name: "InstanceIndex",
                name_hash: 521024402,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ChildStaticModelNetworkInfo, instance_index),
            },
        ],
    }),
    array_type: Some(CHILDSTATICMODELNETWORKINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ChildStaticModelNetworkInfo {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDSTATICMODELNETWORKINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHILDSTATICMODELNETWORKINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildStaticModelNetworkInfo-Array",
    name_hash: 1911561212,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildStaticModelNetworkInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct IndexRange {
    pub first: u32,
    pub last: u32,
}

pub trait IndexRangeTrait: TypeObject {
    fn first(&self) -> &u32;
    fn first_mut(&mut self) -> &mut u32;
    fn last(&self) -> &u32;
    fn last_mut(&mut self) -> &mut u32;
}

impl IndexRangeTrait for IndexRange {
    fn first(&self) -> &u32 {
        &self.first
    }
    fn first_mut(&mut self) -> &mut u32 {
        &mut self.first
    }
    fn last(&self) -> &u32 {
        &self.last
    }
    fn last_mut(&mut self) -> &mut u32 {
        &mut self.last
    }
}

pub static INDEXRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IndexRange",
    name_hash: 3477846628,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IndexRange as Default>::default())),
            create_boxed: || Box::new(<IndexRange as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "First",
                name_hash: 206694335,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(IndexRange, first),
            },
            FieldInfoData {
                name: "Last",
                name_hash: 2089018127,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(IndexRange, last),
            },
        ],
    }),
    array_type: Some(INDEXRANGE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for IndexRange {
    fn type_info(&self) -> &'static TypeInfo {
        INDEXRANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INDEXRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IndexRange-Array",
    name_hash: 2046303824,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IndexRange"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct PhysicsPartInfo {
    pub part_component_index: u32,
    pub health_state_index: u32,
}

pub trait PhysicsPartInfoTrait: TypeObject {
    fn part_component_index(&self) -> &u32;
    fn part_component_index_mut(&mut self) -> &mut u32;
    fn health_state_index(&self) -> &u32;
    fn health_state_index_mut(&mut self) -> &mut u32;
}

impl PhysicsPartInfoTrait for PhysicsPartInfo {
    fn part_component_index(&self) -> &u32 {
        &self.part_component_index
    }
    fn part_component_index_mut(&mut self) -> &mut u32 {
        &mut self.part_component_index
    }
    fn health_state_index(&self) -> &u32 {
        &self.health_state_index
    }
    fn health_state_index_mut(&mut self) -> &mut u32 {
        &mut self.health_state_index
    }
}

pub static PHYSICSPARTINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsPartInfo",
    name_hash: 3525012631,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsPartInfo as Default>::default())),
            create_boxed: || Box::new(<PhysicsPartInfo as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "PartComponentIndex",
                name_hash: 4189988995,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PhysicsPartInfo, part_component_index),
            },
            FieldInfoData {
                name: "HealthStateIndex",
                name_hash: 3506272272,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PhysicsPartInfo, health_state_index),
            },
        ],
    }),
    array_type: Some(PHYSICSPARTINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PhysicsPartInfo {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSPARTINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PHYSICSPARTINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsPartInfo-Array",
    name_hash: 1955542307,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicsPartInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct VehicleSpawnReferenceObjectData {
    pub _glacier_base: SpawnReferenceObjectData,
    pub wreck_duration: f32,
    pub set_team_on_spawn: bool,
    pub affected_by_impulse: bool,
    pub enter_restriction: EntryEnterRestriction,
    pub a_i_allowed_to_follow_human_in_vehicle: bool,
    pub a_i_use_exit_points: bool,
    pub apply_damage_to_abandoned_vehicles: bool,
    pub respawn_range: f32,
    pub time_until_abandoned: f32,
    pub time_until_abandoned_is_destroyed: f32,
    pub keep_alive_radius: f32,
    pub active_stance_entry_index: i32,
    pub active_stance: i32,
    pub vehicle_is_near_distance: f32,
    pub enable_available_seat_output: bool,
    pub disregard_spawn_allowed_setting: bool,
}

pub trait VehicleSpawnReferenceObjectDataTrait: SpawnReferenceObjectDataTrait {
    fn wreck_duration(&self) -> &f32;
    fn wreck_duration_mut(&mut self) -> &mut f32;
    fn set_team_on_spawn(&self) -> &bool;
    fn set_team_on_spawn_mut(&mut self) -> &mut bool;
    fn affected_by_impulse(&self) -> &bool;
    fn affected_by_impulse_mut(&mut self) -> &mut bool;
    fn enter_restriction(&self) -> &EntryEnterRestriction;
    fn enter_restriction_mut(&mut self) -> &mut EntryEnterRestriction;
    fn a_i_allowed_to_follow_human_in_vehicle(&self) -> &bool;
    fn a_i_allowed_to_follow_human_in_vehicle_mut(&mut self) -> &mut bool;
    fn a_i_use_exit_points(&self) -> &bool;
    fn a_i_use_exit_points_mut(&mut self) -> &mut bool;
    fn apply_damage_to_abandoned_vehicles(&self) -> &bool;
    fn apply_damage_to_abandoned_vehicles_mut(&mut self) -> &mut bool;
    fn respawn_range(&self) -> &f32;
    fn respawn_range_mut(&mut self) -> &mut f32;
    fn time_until_abandoned(&self) -> &f32;
    fn time_until_abandoned_mut(&mut self) -> &mut f32;
    fn time_until_abandoned_is_destroyed(&self) -> &f32;
    fn time_until_abandoned_is_destroyed_mut(&mut self) -> &mut f32;
    fn keep_alive_radius(&self) -> &f32;
    fn keep_alive_radius_mut(&mut self) -> &mut f32;
    fn active_stance_entry_index(&self) -> &i32;
    fn active_stance_entry_index_mut(&mut self) -> &mut i32;
    fn active_stance(&self) -> &i32;
    fn active_stance_mut(&mut self) -> &mut i32;
    fn vehicle_is_near_distance(&self) -> &f32;
    fn vehicle_is_near_distance_mut(&mut self) -> &mut f32;
    fn enable_available_seat_output(&self) -> &bool;
    fn enable_available_seat_output_mut(&mut self) -> &mut bool;
    fn disregard_spawn_allowed_setting(&self) -> &bool;
    fn disregard_spawn_allowed_setting_mut(&mut self) -> &mut bool;
}

impl VehicleSpawnReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn wreck_duration(&self) -> &f32 {
        &self.wreck_duration
    }
    fn wreck_duration_mut(&mut self) -> &mut f32 {
        &mut self.wreck_duration
    }
    fn set_team_on_spawn(&self) -> &bool {
        &self.set_team_on_spawn
    }
    fn set_team_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.set_team_on_spawn
    }
    fn affected_by_impulse(&self) -> &bool {
        &self.affected_by_impulse
    }
    fn affected_by_impulse_mut(&mut self) -> &mut bool {
        &mut self.affected_by_impulse
    }
    fn enter_restriction(&self) -> &EntryEnterRestriction {
        &self.enter_restriction
    }
    fn enter_restriction_mut(&mut self) -> &mut EntryEnterRestriction {
        &mut self.enter_restriction
    }
    fn a_i_allowed_to_follow_human_in_vehicle(&self) -> &bool {
        &self.a_i_allowed_to_follow_human_in_vehicle
    }
    fn a_i_allowed_to_follow_human_in_vehicle_mut(&mut self) -> &mut bool {
        &mut self.a_i_allowed_to_follow_human_in_vehicle
    }
    fn a_i_use_exit_points(&self) -> &bool {
        &self.a_i_use_exit_points
    }
    fn a_i_use_exit_points_mut(&mut self) -> &mut bool {
        &mut self.a_i_use_exit_points
    }
    fn apply_damage_to_abandoned_vehicles(&self) -> &bool {
        &self.apply_damage_to_abandoned_vehicles
    }
    fn apply_damage_to_abandoned_vehicles_mut(&mut self) -> &mut bool {
        &mut self.apply_damage_to_abandoned_vehicles
    }
    fn respawn_range(&self) -> &f32 {
        &self.respawn_range
    }
    fn respawn_range_mut(&mut self) -> &mut f32 {
        &mut self.respawn_range
    }
    fn time_until_abandoned(&self) -> &f32 {
        &self.time_until_abandoned
    }
    fn time_until_abandoned_mut(&mut self) -> &mut f32 {
        &mut self.time_until_abandoned
    }
    fn time_until_abandoned_is_destroyed(&self) -> &f32 {
        &self.time_until_abandoned_is_destroyed
    }
    fn time_until_abandoned_is_destroyed_mut(&mut self) -> &mut f32 {
        &mut self.time_until_abandoned_is_destroyed
    }
    fn keep_alive_radius(&self) -> &f32 {
        &self.keep_alive_radius
    }
    fn keep_alive_radius_mut(&mut self) -> &mut f32 {
        &mut self.keep_alive_radius
    }
    fn active_stance_entry_index(&self) -> &i32 {
        &self.active_stance_entry_index
    }
    fn active_stance_entry_index_mut(&mut self) -> &mut i32 {
        &mut self.active_stance_entry_index
    }
    fn active_stance(&self) -> &i32 {
        &self.active_stance
    }
    fn active_stance_mut(&mut self) -> &mut i32 {
        &mut self.active_stance
    }
    fn vehicle_is_near_distance(&self) -> &f32 {
        &self.vehicle_is_near_distance
    }
    fn vehicle_is_near_distance_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_is_near_distance
    }
    fn enable_available_seat_output(&self) -> &bool {
        &self.enable_available_seat_output
    }
    fn enable_available_seat_output_mut(&mut self) -> &mut bool {
        &mut self.enable_available_seat_output
    }
    fn disregard_spawn_allowed_setting(&self) -> &bool {
        &self.disregard_spawn_allowed_setting
    }
    fn disregard_spawn_allowed_setting_mut(&mut self) -> &mut bool {
        &mut self.disregard_spawn_allowed_setting
    }
}

impl SpawnReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.team()
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.team_mut()
    }
    fn locked_team(&self) -> &bool {
        self._glacier_base.locked_team()
    }
    fn locked_team_mut(&mut self) -> &mut bool {
        self._glacier_base.locked_team_mut()
    }
    fn spawn_area_radius(&self) -> &f32 {
        self._glacier_base.spawn_area_radius()
    }
    fn spawn_area_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_area_radius_mut()
    }
    fn spawn_protection_radius(&self) -> &f32 {
        self._glacier_base.spawn_protection_radius()
    }
    fn spawn_protection_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_radius_mut()
    }
    fn spawn_protection_check_all_teams(&self) -> &bool {
        self._glacier_base.spawn_protection_check_all_teams()
    }
    fn spawn_protection_check_all_teams_mut(&mut self) -> &mut bool {
        self._glacier_base.spawn_protection_check_all_teams_mut()
    }
    fn spawn_protection_friendly_killed_count(&self) -> &u32 {
        self._glacier_base.spawn_protection_friendly_killed_count()
    }
    fn spawn_protection_friendly_killed_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.spawn_protection_friendly_killed_count_mut()
    }
    fn spawn_protection_friendly_killed_time(&self) -> &f32 {
        self._glacier_base.spawn_protection_friendly_killed_time()
    }
    fn spawn_protection_friendly_killed_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_friendly_killed_time_mut()
    }
    fn clear_bangers_on_spawn(&self) -> &bool {
        self._glacier_base.clear_bangers_on_spawn()
    }
    fn clear_bangers_on_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.clear_bangers_on_spawn_mut()
    }
    fn try_to_spawn_out_of_sight(&self) -> &bool {
        self._glacier_base.try_to_spawn_out_of_sight()
    }
    fn try_to_spawn_out_of_sight_mut(&mut self) -> &mut bool {
        self._glacier_base.try_to_spawn_out_of_sight_mut()
    }
    fn send_weapon_events(&self) -> &bool {
        self._glacier_base.send_weapon_events()
    }
    fn send_weapon_events_mut(&mut self) -> &mut bool {
        self._glacier_base.send_weapon_events_mut()
    }
    fn take_control_on_transform_change(&self) -> &bool {
        self._glacier_base.take_control_on_transform_change()
    }
    fn take_control_on_transform_change_mut(&mut self) -> &mut bool {
        self._glacier_base.take_control_on_transform_change_mut()
    }
    fn return_control_on_idle(&self) -> &bool {
        self._glacier_base.return_control_on_idle()
    }
    fn return_control_on_idle_mut(&mut self) -> &mut bool {
        self._glacier_base.return_control_on_idle_mut()
    }
    fn take_control_entry_index(&self) -> &i32 {
        self._glacier_base.take_control_entry_index()
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.take_control_entry_index_mut()
    }
    fn rotation_yaw(&self) -> &f32 {
        self._glacier_base.rotation_yaw()
    }
    fn rotation_yaw_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_yaw_mut()
    }
    fn rotation_pitch(&self) -> &f32 {
        self._glacier_base.rotation_pitch()
    }
    fn rotation_pitch_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_pitch_mut()
    }
    fn rotation_roll(&self) -> &f32 {
        self._glacier_base.rotation_roll()
    }
    fn rotation_roll_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_roll_mut()
    }
    fn throttle(&self) -> &f32 {
        self._glacier_base.throttle()
    }
    fn throttle_mut(&mut self) -> &mut f32 {
        self._glacier_base.throttle_mut()
    }
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
    fn max_unspawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_unspawn_in_frame()
    }
    fn max_unspawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_unspawn_in_frame_mut()
    }
}

impl super::gameplay_sim::GameplaySpawnReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn extra_spawn_data(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::ExtraSpawnData */>> {
        self._glacier_base.extra_spawn_data()
    }
    fn extra_spawn_data_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::ExtraSpawnData */>> {
        self._glacier_base.extra_spawn_data_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn location_name_sid(&self) -> &String {
        self._glacier_base.location_name_sid()
    }
    fn location_name_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_name_sid_mut()
    }
    fn location_text_sid(&self) -> &String {
        self._glacier_base.location_text_sid()
    }
    fn location_text_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_text_sid_mut()
    }
    fn initial_auto_spawn(&self) -> &bool {
        self._glacier_base.initial_auto_spawn()
    }
    fn initial_auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.initial_auto_spawn_mut()
    }
    fn auto_spawn(&self) -> &bool {
        self._glacier_base.auto_spawn()
    }
    fn auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_spawn_mut()
    }
    fn queue_spawn_event(&self) -> &bool {
        self._glacier_base.queue_spawn_event()
    }
    fn queue_spawn_event_mut(&mut self) -> &mut bool {
        self._glacier_base.queue_spawn_event_mut()
    }
    fn use_as_spawn_point(&self) -> &bool {
        self._glacier_base.use_as_spawn_point()
    }
    fn use_as_spawn_point_mut(&mut self) -> &mut bool {
        self._glacier_base.use_as_spawn_point_mut()
    }
    fn initial_spawn_delay(&self) -> &f32 {
        self._glacier_base.initial_spawn_delay()
    }
    fn initial_spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.initial_spawn_delay_mut()
    }
    fn spawn_delay(&self) -> &f32 {
        self._glacier_base.spawn_delay()
    }
    fn spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_delay_mut()
    }
    fn max_count(&self) -> &i32 {
        self._glacier_base.max_count()
    }
    fn max_count_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_mut()
    }
    fn max_count_simultaneously(&self) -> &i32 {
        self._glacier_base.max_count_simultaneously()
    }
    fn max_count_simultaneously_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_simultaneously_mut()
    }
    fn total_count_simultaneously_of_type(&self) -> &i32 {
        self._glacier_base.total_count_simultaneously_of_type()
    }
    fn total_count_simultaneously_of_type_mut(&mut self) -> &mut i32 {
        self._glacier_base.total_count_simultaneously_of_type_mut()
    }
    fn max_spawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_spawn_in_frame()
    }
    fn max_spawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_spawn_in_frame_mut()
    }
    fn only_send_event_for_human_players(&self) -> &bool {
        self._glacier_base.only_send_event_for_human_players()
    }
    fn only_send_event_for_human_players_mut(&mut self) -> &mut bool {
        self._glacier_base.only_send_event_for_human_players_mut()
    }
    fn controllable_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_transform()
    }
    fn controllable_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_transform_mut()
    }
    fn controllable_input(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_input()
    }
    fn controllable_input_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_input_mut()
    }
}

impl super::entity::SpatialReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* super::entity::Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* super::entity::ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleSpawnReferenceObjectData {
}

impl super::core::DataBusPeerTrait for VehicleSpawnReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleSpawnReferenceObjectData {
}

impl super::core::DataContainerTrait for VehicleSpawnReferenceObjectData {
}

pub static VEHICLESPAWNREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSpawnReferenceObjectData",
    name_hash: 1633828776,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPAWNREFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(VehicleSpawnReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleSpawnReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<VehicleSpawnReferenceObjectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "WreckDuration",
                name_hash: 3721892947,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, wreck_duration),
            },
            FieldInfoData {
                name: "SetTeamOnSpawn",
                name_hash: 1290825280,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, set_team_on_spawn),
            },
            FieldInfoData {
                name: "AffectedByImpulse",
                name_hash: 3802426327,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, affected_by_impulse),
            },
            FieldInfoData {
                name: "EnterRestriction",
                name_hash: 1187365209,
                flags: MemberInfoFlags::new(0),
                field_type: "EntryEnterRestriction",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, enter_restriction),
            },
            FieldInfoData {
                name: "AIAllowedToFollowHumanInVehicle",
                name_hash: 2451649407,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, a_i_allowed_to_follow_human_in_vehicle),
            },
            FieldInfoData {
                name: "AIUseExitPoints",
                name_hash: 2789081681,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, a_i_use_exit_points),
            },
            FieldInfoData {
                name: "ApplyDamageToAbandonedVehicles",
                name_hash: 3721191714,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, apply_damage_to_abandoned_vehicles),
            },
            FieldInfoData {
                name: "RespawnRange",
                name_hash: 696491990,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, respawn_range),
            },
            FieldInfoData {
                name: "TimeUntilAbandoned",
                name_hash: 590788402,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, time_until_abandoned),
            },
            FieldInfoData {
                name: "TimeUntilAbandonedIsDestroyed",
                name_hash: 1439912203,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, time_until_abandoned_is_destroyed),
            },
            FieldInfoData {
                name: "KeepAliveRadius",
                name_hash: 3493637041,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, keep_alive_radius),
            },
            FieldInfoData {
                name: "ActiveStanceEntryIndex",
                name_hash: 1513018797,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, active_stance_entry_index),
            },
            FieldInfoData {
                name: "ActiveStance",
                name_hash: 3998105031,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, active_stance),
            },
            FieldInfoData {
                name: "VehicleIsNearDistance",
                name_hash: 3573981180,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, vehicle_is_near_distance),
            },
            FieldInfoData {
                name: "EnableAvailableSeatOutput",
                name_hash: 154114977,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, enable_available_seat_output),
            },
            FieldInfoData {
                name: "DisregardSpawnAllowedSetting",
                name_hash: 3707783529,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, disregard_spawn_allowed_setting),
            },
        ],
    }),
    array_type: Some(VEHICLESPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleSpawnReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLESPAWNREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLESPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSpawnReferenceObjectData-Array",
    name_hash: 783368476,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleSpawnReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterSpawnReferenceObjectData {
    pub _glacier_base: SpawnReferenceObjectData,
    pub vehicle_entry_index: u32,
    pub allow_fallback_on_next_availabe_vehicle_entry: bool,
    pub template: Option<LockedTypeObject /* CharacterSpawnTemplateData */>,
    pub spawn_visible: bool,
    pub human_target_preference: f32,
    pub is_target: bool,
    pub affect_minimap_position: bool,
    pub show_as_label_only: bool,
    pub show_in_menu: bool,
    pub menu_show_order: i32,
}

pub trait CharacterSpawnReferenceObjectDataTrait: SpawnReferenceObjectDataTrait {
    fn vehicle_entry_index(&self) -> &u32;
    fn vehicle_entry_index_mut(&mut self) -> &mut u32;
    fn allow_fallback_on_next_availabe_vehicle_entry(&self) -> &bool;
    fn allow_fallback_on_next_availabe_vehicle_entry_mut(&mut self) -> &mut bool;
    fn template(&self) -> &Option<LockedTypeObject /* CharacterSpawnTemplateData */>;
    fn template_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterSpawnTemplateData */>;
    fn spawn_visible(&self) -> &bool;
    fn spawn_visible_mut(&mut self) -> &mut bool;
    fn human_target_preference(&self) -> &f32;
    fn human_target_preference_mut(&mut self) -> &mut f32;
    fn is_target(&self) -> &bool;
    fn is_target_mut(&mut self) -> &mut bool;
    fn affect_minimap_position(&self) -> &bool;
    fn affect_minimap_position_mut(&mut self) -> &mut bool;
    fn show_as_label_only(&self) -> &bool;
    fn show_as_label_only_mut(&mut self) -> &mut bool;
    fn show_in_menu(&self) -> &bool;
    fn show_in_menu_mut(&mut self) -> &mut bool;
    fn menu_show_order(&self) -> &i32;
    fn menu_show_order_mut(&mut self) -> &mut i32;
}

impl CharacterSpawnReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn vehicle_entry_index(&self) -> &u32 {
        &self.vehicle_entry_index
    }
    fn vehicle_entry_index_mut(&mut self) -> &mut u32 {
        &mut self.vehicle_entry_index
    }
    fn allow_fallback_on_next_availabe_vehicle_entry(&self) -> &bool {
        &self.allow_fallback_on_next_availabe_vehicle_entry
    }
    fn allow_fallback_on_next_availabe_vehicle_entry_mut(&mut self) -> &mut bool {
        &mut self.allow_fallback_on_next_availabe_vehicle_entry
    }
    fn template(&self) -> &Option<LockedTypeObject /* CharacterSpawnTemplateData */> {
        &self.template
    }
    fn template_mut(&mut self) -> &mut Option<LockedTypeObject /* CharacterSpawnTemplateData */> {
        &mut self.template
    }
    fn spawn_visible(&self) -> &bool {
        &self.spawn_visible
    }
    fn spawn_visible_mut(&mut self) -> &mut bool {
        &mut self.spawn_visible
    }
    fn human_target_preference(&self) -> &f32 {
        &self.human_target_preference
    }
    fn human_target_preference_mut(&mut self) -> &mut f32 {
        &mut self.human_target_preference
    }
    fn is_target(&self) -> &bool {
        &self.is_target
    }
    fn is_target_mut(&mut self) -> &mut bool {
        &mut self.is_target
    }
    fn affect_minimap_position(&self) -> &bool {
        &self.affect_minimap_position
    }
    fn affect_minimap_position_mut(&mut self) -> &mut bool {
        &mut self.affect_minimap_position
    }
    fn show_as_label_only(&self) -> &bool {
        &self.show_as_label_only
    }
    fn show_as_label_only_mut(&mut self) -> &mut bool {
        &mut self.show_as_label_only
    }
    fn show_in_menu(&self) -> &bool {
        &self.show_in_menu
    }
    fn show_in_menu_mut(&mut self) -> &mut bool {
        &mut self.show_in_menu
    }
    fn menu_show_order(&self) -> &i32 {
        &self.menu_show_order
    }
    fn menu_show_order_mut(&mut self) -> &mut i32 {
        &mut self.menu_show_order
    }
}

impl SpawnReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.team()
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.team_mut()
    }
    fn locked_team(&self) -> &bool {
        self._glacier_base.locked_team()
    }
    fn locked_team_mut(&mut self) -> &mut bool {
        self._glacier_base.locked_team_mut()
    }
    fn spawn_area_radius(&self) -> &f32 {
        self._glacier_base.spawn_area_radius()
    }
    fn spawn_area_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_area_radius_mut()
    }
    fn spawn_protection_radius(&self) -> &f32 {
        self._glacier_base.spawn_protection_radius()
    }
    fn spawn_protection_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_radius_mut()
    }
    fn spawn_protection_check_all_teams(&self) -> &bool {
        self._glacier_base.spawn_protection_check_all_teams()
    }
    fn spawn_protection_check_all_teams_mut(&mut self) -> &mut bool {
        self._glacier_base.spawn_protection_check_all_teams_mut()
    }
    fn spawn_protection_friendly_killed_count(&self) -> &u32 {
        self._glacier_base.spawn_protection_friendly_killed_count()
    }
    fn spawn_protection_friendly_killed_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.spawn_protection_friendly_killed_count_mut()
    }
    fn spawn_protection_friendly_killed_time(&self) -> &f32 {
        self._glacier_base.spawn_protection_friendly_killed_time()
    }
    fn spawn_protection_friendly_killed_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_friendly_killed_time_mut()
    }
    fn clear_bangers_on_spawn(&self) -> &bool {
        self._glacier_base.clear_bangers_on_spawn()
    }
    fn clear_bangers_on_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.clear_bangers_on_spawn_mut()
    }
    fn try_to_spawn_out_of_sight(&self) -> &bool {
        self._glacier_base.try_to_spawn_out_of_sight()
    }
    fn try_to_spawn_out_of_sight_mut(&mut self) -> &mut bool {
        self._glacier_base.try_to_spawn_out_of_sight_mut()
    }
    fn send_weapon_events(&self) -> &bool {
        self._glacier_base.send_weapon_events()
    }
    fn send_weapon_events_mut(&mut self) -> &mut bool {
        self._glacier_base.send_weapon_events_mut()
    }
    fn take_control_on_transform_change(&self) -> &bool {
        self._glacier_base.take_control_on_transform_change()
    }
    fn take_control_on_transform_change_mut(&mut self) -> &mut bool {
        self._glacier_base.take_control_on_transform_change_mut()
    }
    fn return_control_on_idle(&self) -> &bool {
        self._glacier_base.return_control_on_idle()
    }
    fn return_control_on_idle_mut(&mut self) -> &mut bool {
        self._glacier_base.return_control_on_idle_mut()
    }
    fn take_control_entry_index(&self) -> &i32 {
        self._glacier_base.take_control_entry_index()
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.take_control_entry_index_mut()
    }
    fn rotation_yaw(&self) -> &f32 {
        self._glacier_base.rotation_yaw()
    }
    fn rotation_yaw_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_yaw_mut()
    }
    fn rotation_pitch(&self) -> &f32 {
        self._glacier_base.rotation_pitch()
    }
    fn rotation_pitch_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_pitch_mut()
    }
    fn rotation_roll(&self) -> &f32 {
        self._glacier_base.rotation_roll()
    }
    fn rotation_roll_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_roll_mut()
    }
    fn throttle(&self) -> &f32 {
        self._glacier_base.throttle()
    }
    fn throttle_mut(&mut self) -> &mut f32 {
        self._glacier_base.throttle_mut()
    }
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
    fn max_unspawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_unspawn_in_frame()
    }
    fn max_unspawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_unspawn_in_frame_mut()
    }
}

impl super::gameplay_sim::GameplaySpawnReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn extra_spawn_data(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::ExtraSpawnData */>> {
        self._glacier_base.extra_spawn_data()
    }
    fn extra_spawn_data_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::ExtraSpawnData */>> {
        self._glacier_base.extra_spawn_data_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn location_name_sid(&self) -> &String {
        self._glacier_base.location_name_sid()
    }
    fn location_name_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_name_sid_mut()
    }
    fn location_text_sid(&self) -> &String {
        self._glacier_base.location_text_sid()
    }
    fn location_text_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_text_sid_mut()
    }
    fn initial_auto_spawn(&self) -> &bool {
        self._glacier_base.initial_auto_spawn()
    }
    fn initial_auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.initial_auto_spawn_mut()
    }
    fn auto_spawn(&self) -> &bool {
        self._glacier_base.auto_spawn()
    }
    fn auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_spawn_mut()
    }
    fn queue_spawn_event(&self) -> &bool {
        self._glacier_base.queue_spawn_event()
    }
    fn queue_spawn_event_mut(&mut self) -> &mut bool {
        self._glacier_base.queue_spawn_event_mut()
    }
    fn use_as_spawn_point(&self) -> &bool {
        self._glacier_base.use_as_spawn_point()
    }
    fn use_as_spawn_point_mut(&mut self) -> &mut bool {
        self._glacier_base.use_as_spawn_point_mut()
    }
    fn initial_spawn_delay(&self) -> &f32 {
        self._glacier_base.initial_spawn_delay()
    }
    fn initial_spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.initial_spawn_delay_mut()
    }
    fn spawn_delay(&self) -> &f32 {
        self._glacier_base.spawn_delay()
    }
    fn spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_delay_mut()
    }
    fn max_count(&self) -> &i32 {
        self._glacier_base.max_count()
    }
    fn max_count_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_mut()
    }
    fn max_count_simultaneously(&self) -> &i32 {
        self._glacier_base.max_count_simultaneously()
    }
    fn max_count_simultaneously_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_simultaneously_mut()
    }
    fn total_count_simultaneously_of_type(&self) -> &i32 {
        self._glacier_base.total_count_simultaneously_of_type()
    }
    fn total_count_simultaneously_of_type_mut(&mut self) -> &mut i32 {
        self._glacier_base.total_count_simultaneously_of_type_mut()
    }
    fn max_spawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_spawn_in_frame()
    }
    fn max_spawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_spawn_in_frame_mut()
    }
    fn only_send_event_for_human_players(&self) -> &bool {
        self._glacier_base.only_send_event_for_human_players()
    }
    fn only_send_event_for_human_players_mut(&mut self) -> &mut bool {
        self._glacier_base.only_send_event_for_human_players_mut()
    }
    fn controllable_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_transform()
    }
    fn controllable_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_transform_mut()
    }
    fn controllable_input(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_input()
    }
    fn controllable_input_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_input_mut()
    }
}

impl super::entity::SpatialReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* super::entity::Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* super::entity::ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterSpawnReferenceObjectData {
}

impl super::core::DataBusPeerTrait for CharacterSpawnReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterSpawnReferenceObjectData {
}

impl super::core::DataContainerTrait for CharacterSpawnReferenceObjectData {
}

pub static CHARACTERSPAWNREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSpawnReferenceObjectData",
    name_hash: 3251809257,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPAWNREFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(CharacterSpawnReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterSpawnReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<CharacterSpawnReferenceObjectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "VehicleEntryIndex",
                name_hash: 3148172503,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, vehicle_entry_index),
            },
            FieldInfoData {
                name: "AllowFallbackOnNextAvailabeVehicleEntry",
                name_hash: 1228692495,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, allow_fallback_on_next_availabe_vehicle_entry),
            },
            FieldInfoData {
                name: "Template",
                name_hash: 2427043285,
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterSpawnTemplateData",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, template),
            },
            FieldInfoData {
                name: "SpawnVisible",
                name_hash: 4108959760,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, spawn_visible),
            },
            FieldInfoData {
                name: "HumanTargetPreference",
                name_hash: 1981794192,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, human_target_preference),
            },
            FieldInfoData {
                name: "IsTarget",
                name_hash: 495955022,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, is_target),
            },
            FieldInfoData {
                name: "AffectMinimapPosition",
                name_hash: 3321046512,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, affect_minimap_position),
            },
            FieldInfoData {
                name: "ShowAsLabelOnly",
                name_hash: 3871506022,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, show_as_label_only),
            },
            FieldInfoData {
                name: "ShowInMenu",
                name_hash: 2144492082,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, show_in_menu),
            },
            FieldInfoData {
                name: "MenuShowOrder",
                name_hash: 2658455803,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, menu_show_order),
            },
        ],
    }),
    array_type: Some(CHARACTERSPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterSpawnReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSPAWNREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSpawnReferenceObjectData-Array",
    name_hash: 3514393309,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterSpawnReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterToComponentsSpawnTemplateMessage {
}

pub trait CharacterToComponentsSpawnTemplateMessageTrait: TypeObject {
}

impl CharacterToComponentsSpawnTemplateMessageTrait for CharacterToComponentsSpawnTemplateMessage {
}

pub static CHARACTERTOCOMPONENTSSPAWNTEMPLATEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterToComponentsSpawnTemplateMessage",
    name_hash: 2956761371,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterToComponentsSpawnTemplateMessage as Default>::default())),
            create_boxed: || Box::new(<CharacterToComponentsSpawnTemplateMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for CharacterToComponentsSpawnTemplateMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERTOCOMPONENTSSPAWNTEMPLATEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct CharacterSpawnTemplateData {
    pub _glacier_base: super::core::Asset,
    pub customize_character_data: Option<LockedTypeObject /* CustomizeCharacterData */>,
    pub sensing: Option<LockedTypeObject /* GameSensingTemplateData */>,
    pub behaviour: Option<LockedTypeObject /* GameBehaviourTemplateData */>,
    pub animation_template: Option<LockedTypeObject /* AnimationSpawnTemplate */>,
    pub voice_over_labels: Vec<Option<LockedTypeObject /* super::audio::VoiceOverLabel */>>,
}

pub trait CharacterSpawnTemplateDataTrait: super::core::AssetTrait {
    fn customize_character_data(&self) -> &Option<LockedTypeObject /* CustomizeCharacterData */>;
    fn customize_character_data_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizeCharacterData */>;
    fn sensing(&self) -> &Option<LockedTypeObject /* GameSensingTemplateData */>;
    fn sensing_mut(&mut self) -> &mut Option<LockedTypeObject /* GameSensingTemplateData */>;
    fn behaviour(&self) -> &Option<LockedTypeObject /* GameBehaviourTemplateData */>;
    fn behaviour_mut(&mut self) -> &mut Option<LockedTypeObject /* GameBehaviourTemplateData */>;
    fn animation_template(&self) -> &Option<LockedTypeObject /* AnimationSpawnTemplate */>;
    fn animation_template_mut(&mut self) -> &mut Option<LockedTypeObject /* AnimationSpawnTemplate */>;
    fn voice_over_labels(&self) -> &Vec<Option<LockedTypeObject /* super::audio::VoiceOverLabel */>>;
    fn voice_over_labels_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::audio::VoiceOverLabel */>>;
}

impl CharacterSpawnTemplateDataTrait for CharacterSpawnTemplateData {
    fn customize_character_data(&self) -> &Option<LockedTypeObject /* CustomizeCharacterData */> {
        &self.customize_character_data
    }
    fn customize_character_data_mut(&mut self) -> &mut Option<LockedTypeObject /* CustomizeCharacterData */> {
        &mut self.customize_character_data
    }
    fn sensing(&self) -> &Option<LockedTypeObject /* GameSensingTemplateData */> {
        &self.sensing
    }
    fn sensing_mut(&mut self) -> &mut Option<LockedTypeObject /* GameSensingTemplateData */> {
        &mut self.sensing
    }
    fn behaviour(&self) -> &Option<LockedTypeObject /* GameBehaviourTemplateData */> {
        &self.behaviour
    }
    fn behaviour_mut(&mut self) -> &mut Option<LockedTypeObject /* GameBehaviourTemplateData */> {
        &mut self.behaviour
    }
    fn animation_template(&self) -> &Option<LockedTypeObject /* AnimationSpawnTemplate */> {
        &self.animation_template
    }
    fn animation_template_mut(&mut self) -> &mut Option<LockedTypeObject /* AnimationSpawnTemplate */> {
        &mut self.animation_template
    }
    fn voice_over_labels(&self) -> &Vec<Option<LockedTypeObject /* super::audio::VoiceOverLabel */>> {
        &self.voice_over_labels
    }
    fn voice_over_labels_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::audio::VoiceOverLabel */>> {
        &mut self.voice_over_labels
    }
}

impl super::core::AssetTrait for CharacterSpawnTemplateData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterSpawnTemplateData {
}

pub static CHARACTERSPAWNTEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSpawnTemplateData",
    name_hash: 2372808935,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(CharacterSpawnTemplateData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterSpawnTemplateData as Default>::default())),
            create_boxed: || Box::new(<CharacterSpawnTemplateData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "CustomizeCharacterData",
                name_hash: 3784213897,
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizeCharacterData",
                rust_offset: offset_of!(CharacterSpawnTemplateData, customize_character_data),
            },
            FieldInfoData {
                name: "Sensing",
                name_hash: 2773286638,
                flags: MemberInfoFlags::new(0),
                field_type: "GameSensingTemplateData",
                rust_offset: offset_of!(CharacterSpawnTemplateData, sensing),
            },
            FieldInfoData {
                name: "Behaviour",
                name_hash: 513159228,
                flags: MemberInfoFlags::new(0),
                field_type: "GameBehaviourTemplateData",
                rust_offset: offset_of!(CharacterSpawnTemplateData, behaviour),
            },
            FieldInfoData {
                name: "AnimationTemplate",
                name_hash: 4294916323,
                flags: MemberInfoFlags::new(0),
                field_type: "AnimationSpawnTemplate",
                rust_offset: offset_of!(CharacterSpawnTemplateData, animation_template),
            },
            FieldInfoData {
                name: "VoiceOverLabels",
                name_hash: 2741340584,
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabel-Array",
                rust_offset: offset_of!(CharacterSpawnTemplateData, voice_over_labels),
            },
        ],
    }),
    array_type: Some(CHARACTERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterSpawnTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSPAWNTEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSpawnTemplateData-Array",
    name_hash: 525415123,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterSpawnTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AlternateSpawnEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub team: super::gameplay_sim::TeamId,
    pub priority: f32,
    pub enabled: bool,
}

pub trait AlternateSpawnEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn priority(&self) -> &f32;
    fn priority_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl AlternateSpawnEntityDataTrait for AlternateSpawnEntityData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn priority(&self) -> &f32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut f32 {
        &mut self.priority
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for AlternateSpawnEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for AlternateSpawnEntityData {
}

impl super::entity::GameObjectDataTrait for AlternateSpawnEntityData {
}

impl super::core::DataBusPeerTrait for AlternateSpawnEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AlternateSpawnEntityData {
}

impl super::core::DataContainerTrait for AlternateSpawnEntityData {
}

pub static ALTERNATESPAWNENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlternateSpawnEntityData",
    name_hash: 654045477,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AlternateSpawnEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AlternateSpawnEntityData as Default>::default())),
            create_boxed: || Box::new(<AlternateSpawnEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                name_hash: 2089309528,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(AlternateSpawnEntityData, team),
            },
            FieldInfoData {
                name: "Priority",
                name_hash: 3062102871,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateSpawnEntityData, priority),
            },
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateSpawnEntityData, enabled),
            },
        ],
    }),
    array_type: Some(ALTERNATESPAWNENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AlternateSpawnEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ALTERNATESPAWNENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ALTERNATESPAWNENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlternateSpawnEntityData-Array",
    name_hash: 935438737,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AlternateSpawnEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameBehaviourTemplateData {
    pub _glacier_base: super::core::Asset,
}

pub trait GameBehaviourTemplateDataTrait: super::core::AssetTrait {
}

impl GameBehaviourTemplateDataTrait for GameBehaviourTemplateData {
}

impl super::core::AssetTrait for GameBehaviourTemplateData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for GameBehaviourTemplateData {
}

pub static GAMEBEHAVIOURTEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameBehaviourTemplateData",
    name_hash: 2722238130,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(GameBehaviourTemplateData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameBehaviourTemplateData as Default>::default())),
            create_boxed: || Box::new(<GameBehaviourTemplateData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMEBEHAVIOURTEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameBehaviourTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEBEHAVIOURTEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEBEHAVIOURTEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameBehaviourTemplateData-Array",
    name_hash: 3644601606,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameBehaviourTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct GameSensingTemplateData {
    pub _glacier_base: super::core::Asset,
}

pub trait GameSensingTemplateDataTrait: super::core::AssetTrait {
}

impl GameSensingTemplateDataTrait for GameSensingTemplateData {
}

impl super::core::AssetTrait for GameSensingTemplateData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for GameSensingTemplateData {
}

pub static GAMESENSINGTEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSensingTemplateData",
    name_hash: 11655520,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(GameSensingTemplateData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameSensingTemplateData as Default>::default())),
            create_boxed: || Box::new(<GameSensingTemplateData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMESENSINGTEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameSensingTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMESENSINGTEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMESENSINGTEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSensingTemplateData-Array",
    name_hash: 3422146388,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameSensingTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimationSpawnTemplate {
    pub _glacier_base: super::core::DataContainer,
    pub run_style: Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */>,
}

pub trait AnimationSpawnTemplateTrait: super::core::DataContainerTrait {
    fn run_style(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */>;
    fn run_style_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */>;
}

impl AnimationSpawnTemplateTrait for AnimationSpawnTemplate {
    fn run_style(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */> {
        &self.run_style
    }
    fn run_style_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */> {
        &mut self.run_style
    }
}

impl super::core::DataContainerTrait for AnimationSpawnTemplate {
}

pub static ANIMATIONSPAWNTEMPLATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationSpawnTemplate",
    name_hash: 1550031480,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        super_class_offset: offset_of!(AnimationSpawnTemplate, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationSpawnTemplate as Default>::default())),
            create_boxed: || Box::new(<AnimationSpawnTemplate as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "RunStyle",
                name_hash: 1984199259,
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(AnimationSpawnTemplate, run_style),
            },
        ],
    }),
    array_type: Some(ANIMATIONSPAWNTEMPLATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationSpawnTemplate {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONSPAWNTEMPLATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONSPAWNTEMPLATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationSpawnTemplate-Array",
    name_hash: 575304780,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationSpawnTemplate"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SpawnReferenceObjectData {
    pub _glacier_base: super::gameplay_sim::GameplaySpawnReferenceObjectData,
    pub team: super::gameplay_sim::TeamId,
    pub locked_team: bool,
    pub spawn_area_radius: f32,
    pub spawn_protection_radius: f32,
    pub spawn_protection_check_all_teams: bool,
    pub spawn_protection_friendly_killed_count: u32,
    pub spawn_protection_friendly_killed_time: f32,
    pub clear_bangers_on_spawn: bool,
    pub try_to_spawn_out_of_sight: bool,
    pub send_weapon_events: bool,
    pub take_control_on_transform_change: bool,
    pub return_control_on_idle: bool,
    pub take_control_entry_index: i32,
    pub rotation_yaw: f32,
    pub rotation_pitch: f32,
    pub rotation_roll: f32,
    pub throttle: f32,
    pub time_delta_type: super::entity::TimeDeltaType,
    pub max_unspawn_in_frame: i32,
}

pub trait SpawnReferenceObjectDataTrait: super::gameplay_sim::GameplaySpawnReferenceObjectDataTrait {
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn locked_team(&self) -> &bool;
    fn locked_team_mut(&mut self) -> &mut bool;
    fn spawn_area_radius(&self) -> &f32;
    fn spawn_area_radius_mut(&mut self) -> &mut f32;
    fn spawn_protection_radius(&self) -> &f32;
    fn spawn_protection_radius_mut(&mut self) -> &mut f32;
    fn spawn_protection_check_all_teams(&self) -> &bool;
    fn spawn_protection_check_all_teams_mut(&mut self) -> &mut bool;
    fn spawn_protection_friendly_killed_count(&self) -> &u32;
    fn spawn_protection_friendly_killed_count_mut(&mut self) -> &mut u32;
    fn spawn_protection_friendly_killed_time(&self) -> &f32;
    fn spawn_protection_friendly_killed_time_mut(&mut self) -> &mut f32;
    fn clear_bangers_on_spawn(&self) -> &bool;
    fn clear_bangers_on_spawn_mut(&mut self) -> &mut bool;
    fn try_to_spawn_out_of_sight(&self) -> &bool;
    fn try_to_spawn_out_of_sight_mut(&mut self) -> &mut bool;
    fn send_weapon_events(&self) -> &bool;
    fn send_weapon_events_mut(&mut self) -> &mut bool;
    fn take_control_on_transform_change(&self) -> &bool;
    fn take_control_on_transform_change_mut(&mut self) -> &mut bool;
    fn return_control_on_idle(&self) -> &bool;
    fn return_control_on_idle_mut(&mut self) -> &mut bool;
    fn take_control_entry_index(&self) -> &i32;
    fn take_control_entry_index_mut(&mut self) -> &mut i32;
    fn rotation_yaw(&self) -> &f32;
    fn rotation_yaw_mut(&mut self) -> &mut f32;
    fn rotation_pitch(&self) -> &f32;
    fn rotation_pitch_mut(&mut self) -> &mut f32;
    fn rotation_roll(&self) -> &f32;
    fn rotation_roll_mut(&mut self) -> &mut f32;
    fn throttle(&self) -> &f32;
    fn throttle_mut(&mut self) -> &mut f32;
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType;
    fn max_unspawn_in_frame(&self) -> &i32;
    fn max_unspawn_in_frame_mut(&mut self) -> &mut i32;
}

impl SpawnReferenceObjectDataTrait for SpawnReferenceObjectData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn locked_team(&self) -> &bool {
        &self.locked_team
    }
    fn locked_team_mut(&mut self) -> &mut bool {
        &mut self.locked_team
    }
    fn spawn_area_radius(&self) -> &f32 {
        &self.spawn_area_radius
    }
    fn spawn_area_radius_mut(&mut self) -> &mut f32 {
        &mut self.spawn_area_radius
    }
    fn spawn_protection_radius(&self) -> &f32 {
        &self.spawn_protection_radius
    }
    fn spawn_protection_radius_mut(&mut self) -> &mut f32 {
        &mut self.spawn_protection_radius
    }
    fn spawn_protection_check_all_teams(&self) -> &bool {
        &self.spawn_protection_check_all_teams
    }
    fn spawn_protection_check_all_teams_mut(&mut self) -> &mut bool {
        &mut self.spawn_protection_check_all_teams
    }
    fn spawn_protection_friendly_killed_count(&self) -> &u32 {
        &self.spawn_protection_friendly_killed_count
    }
    fn spawn_protection_friendly_killed_count_mut(&mut self) -> &mut u32 {
        &mut self.spawn_protection_friendly_killed_count
    }
    fn spawn_protection_friendly_killed_time(&self) -> &f32 {
        &self.spawn_protection_friendly_killed_time
    }
    fn spawn_protection_friendly_killed_time_mut(&mut self) -> &mut f32 {
        &mut self.spawn_protection_friendly_killed_time
    }
    fn clear_bangers_on_spawn(&self) -> &bool {
        &self.clear_bangers_on_spawn
    }
    fn clear_bangers_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.clear_bangers_on_spawn
    }
    fn try_to_spawn_out_of_sight(&self) -> &bool {
        &self.try_to_spawn_out_of_sight
    }
    fn try_to_spawn_out_of_sight_mut(&mut self) -> &mut bool {
        &mut self.try_to_spawn_out_of_sight
    }
    fn send_weapon_events(&self) -> &bool {
        &self.send_weapon_events
    }
    fn send_weapon_events_mut(&mut self) -> &mut bool {
        &mut self.send_weapon_events
    }
    fn take_control_on_transform_change(&self) -> &bool {
        &self.take_control_on_transform_change
    }
    fn take_control_on_transform_change_mut(&mut self) -> &mut bool {
        &mut self.take_control_on_transform_change
    }
    fn return_control_on_idle(&self) -> &bool {
        &self.return_control_on_idle
    }
    fn return_control_on_idle_mut(&mut self) -> &mut bool {
        &mut self.return_control_on_idle
    }
    fn take_control_entry_index(&self) -> &i32 {
        &self.take_control_entry_index
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        &mut self.take_control_entry_index
    }
    fn rotation_yaw(&self) -> &f32 {
        &self.rotation_yaw
    }
    fn rotation_yaw_mut(&mut self) -> &mut f32 {
        &mut self.rotation_yaw
    }
    fn rotation_pitch(&self) -> &f32 {
        &self.rotation_pitch
    }
    fn rotation_pitch_mut(&mut self) -> &mut f32 {
        &mut self.rotation_pitch
    }
    fn rotation_roll(&self) -> &f32 {
        &self.rotation_roll
    }
    fn rotation_roll_mut(&mut self) -> &mut f32 {
        &mut self.rotation_roll
    }
    fn throttle(&self) -> &f32 {
        &self.throttle
    }
    fn throttle_mut(&mut self) -> &mut f32 {
        &mut self.throttle
    }
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        &mut self.time_delta_type
    }
    fn max_unspawn_in_frame(&self) -> &i32 {
        &self.max_unspawn_in_frame
    }
    fn max_unspawn_in_frame_mut(&mut self) -> &mut i32 {
        &mut self.max_unspawn_in_frame
    }
}

impl super::gameplay_sim::GameplaySpawnReferenceObjectDataTrait for SpawnReferenceObjectData {
    fn extra_spawn_data(&self) -> &Vec<Option<LockedTypeObject /* super::gameplay_sim::ExtraSpawnData */>> {
        self._glacier_base.extra_spawn_data()
    }
    fn extra_spawn_data_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::gameplay_sim::ExtraSpawnData */>> {
        self._glacier_base.extra_spawn_data_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn location_name_sid(&self) -> &String {
        self._glacier_base.location_name_sid()
    }
    fn location_name_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_name_sid_mut()
    }
    fn location_text_sid(&self) -> &String {
        self._glacier_base.location_text_sid()
    }
    fn location_text_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_text_sid_mut()
    }
    fn initial_auto_spawn(&self) -> &bool {
        self._glacier_base.initial_auto_spawn()
    }
    fn initial_auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.initial_auto_spawn_mut()
    }
    fn auto_spawn(&self) -> &bool {
        self._glacier_base.auto_spawn()
    }
    fn auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_spawn_mut()
    }
    fn queue_spawn_event(&self) -> &bool {
        self._glacier_base.queue_spawn_event()
    }
    fn queue_spawn_event_mut(&mut self) -> &mut bool {
        self._glacier_base.queue_spawn_event_mut()
    }
    fn use_as_spawn_point(&self) -> &bool {
        self._glacier_base.use_as_spawn_point()
    }
    fn use_as_spawn_point_mut(&mut self) -> &mut bool {
        self._glacier_base.use_as_spawn_point_mut()
    }
    fn initial_spawn_delay(&self) -> &f32 {
        self._glacier_base.initial_spawn_delay()
    }
    fn initial_spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.initial_spawn_delay_mut()
    }
    fn spawn_delay(&self) -> &f32 {
        self._glacier_base.spawn_delay()
    }
    fn spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_delay_mut()
    }
    fn max_count(&self) -> &i32 {
        self._glacier_base.max_count()
    }
    fn max_count_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_mut()
    }
    fn max_count_simultaneously(&self) -> &i32 {
        self._glacier_base.max_count_simultaneously()
    }
    fn max_count_simultaneously_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_simultaneously_mut()
    }
    fn total_count_simultaneously_of_type(&self) -> &i32 {
        self._glacier_base.total_count_simultaneously_of_type()
    }
    fn total_count_simultaneously_of_type_mut(&mut self) -> &mut i32 {
        self._glacier_base.total_count_simultaneously_of_type_mut()
    }
    fn max_spawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_spawn_in_frame()
    }
    fn max_spawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_spawn_in_frame_mut()
    }
    fn only_send_event_for_human_players(&self) -> &bool {
        self._glacier_base.only_send_event_for_human_players()
    }
    fn only_send_event_for_human_players_mut(&mut self) -> &mut bool {
        self._glacier_base.only_send_event_for_human_players_mut()
    }
    fn controllable_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_transform()
    }
    fn controllable_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_transform_mut()
    }
    fn controllable_input(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_input()
    }
    fn controllable_input_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_input_mut()
    }
}

impl super::entity::SpatialReferenceObjectDataTrait for SpawnReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for SpawnReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<LockedTypeObject /* super::entity::Blueprint */> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::Blueprint */> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<LockedTypeObject /* super::entity::ObjectVariation */> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectVariation */> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for SpawnReferenceObjectData {
}

impl super::core::DataBusPeerTrait for SpawnReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpawnReferenceObjectData {
}

impl super::core::DataContainerTrait for SpawnReferenceObjectData {
}

pub static SPAWNREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpawnReferenceObjectData",
    name_hash: 3063314640,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPLAYSPAWNREFERENCEOBJECTDATA_TYPE_INFO),
        super_class_offset: offset_of!(SpawnReferenceObjectData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpawnReferenceObjectData as Default>::default())),
            create_boxed: || Box::new(<SpawnReferenceObjectData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                name_hash: 2089309528,
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(SpawnReferenceObjectData, team),
            },
            FieldInfoData {
                name: "LockedTeam",
                name_hash: 3253636210,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, locked_team),
            },
            FieldInfoData {
                name: "SpawnAreaRadius",
                name_hash: 3063192433,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_area_radius),
            },
            FieldInfoData {
                name: "SpawnProtectionRadius",
                name_hash: 2354991365,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_protection_radius),
            },
            FieldInfoData {
                name: "SpawnProtectionCheckAllTeams",
                name_hash: 2964373364,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_protection_check_all_teams),
            },
            FieldInfoData {
                name: "SpawnProtectionFriendlyKilledCount",
                name_hash: 2532884410,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_protection_friendly_killed_count),
            },
            FieldInfoData {
                name: "SpawnProtectionFriendlyKilledTime",
                name_hash: 466526060,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_protection_friendly_killed_time),
            },
            FieldInfoData {
                name: "ClearBangersOnSpawn",
                name_hash: 2093968904,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, clear_bangers_on_spawn),
            },
            FieldInfoData {
                name: "TryToSpawnOutOfSight",
                name_hash: 2673481532,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, try_to_spawn_out_of_sight),
            },
            FieldInfoData {
                name: "SendWeaponEvents",
                name_hash: 3343414756,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, send_weapon_events),
            },
            FieldInfoData {
                name: "TakeControlOnTransformChange",
                name_hash: 1281873042,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, take_control_on_transform_change),
            },
            FieldInfoData {
                name: "ReturnControlOnIdle",
                name_hash: 4289379661,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, return_control_on_idle),
            },
            FieldInfoData {
                name: "TakeControlEntryIndex",
                name_hash: 1823842163,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SpawnReferenceObjectData, take_control_entry_index),
            },
            FieldInfoData {
                name: "RotationYaw",
                name_hash: 1136606110,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, rotation_yaw),
            },
            FieldInfoData {
                name: "RotationPitch",
                name_hash: 803224183,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, rotation_pitch),
            },
            FieldInfoData {
                name: "RotationRoll",
                name_hash: 3148161004,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, rotation_roll),
            },
            FieldInfoData {
                name: "Throttle",
                name_hash: 2709773613,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, throttle),
            },
            FieldInfoData {
                name: "TimeDeltaType",
                name_hash: 1100516816,
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(SpawnReferenceObjectData, time_delta_type),
            },
            FieldInfoData {
                name: "MaxUnspawnInFrame",
                name_hash: 4062715371,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SpawnReferenceObjectData, max_unspawn_in_frame),
            },
        ],
    }),
    array_type: Some(SPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpawnReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SPAWNREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpawnReferenceObjectData-Array",
    name_hash: 338917220,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SpawnReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EntryEnterRestriction {
    #[default]
    EntryEnterRestriction_NoRestriction = 0,
    EntryEnterRestriction_OnlyPrimaryEntry = 1,
}

pub static ENTRYENTERRESTRICTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryEnterRestriction",
    name_hash: 4186607789,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ENTRYENTERRESTRICTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EntryEnterRestriction {
    fn type_info(&self) -> &'static TypeInfo {
        ENTRYENTERRESTRICTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTRYENTERRESTRICTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryEnterRestriction-Array",
    name_hash: 1747535129,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntryEnterRestriction"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerSpawnType {
    #[default]
    PlayerSpawnType_HumanPlayer = 0,
    PlayerSpawnType_AiPlayer = 1,
    PlayerSpawnType_Actor = 2,
    PlayerSpawnType_BrainAI = 3,
    PlayerSpawnType_Ai2Player = 300,
}

pub static PLAYERSPAWNTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerSpawnType",
    name_hash: 350489269,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERSPAWNTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerSpawnType {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERSPAWNTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PLAYERSPAWNTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerSpawnType-Array",
    name_hash: 2957617921,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerSpawnType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SlowMotionEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub time_scale: f32,
    pub scale_down_transition_time: f32,
    pub scale_up_transition_time: f32,
}

pub trait SlowMotionEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn time_scale(&self) -> &f32;
    fn time_scale_mut(&mut self) -> &mut f32;
    fn scale_down_transition_time(&self) -> &f32;
    fn scale_down_transition_time_mut(&mut self) -> &mut f32;
    fn scale_up_transition_time(&self) -> &f32;
    fn scale_up_transition_time_mut(&mut self) -> &mut f32;
}

impl SlowMotionEntityDataTrait for SlowMotionEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn time_scale(&self) -> &f32 {
        &self.time_scale
    }
    fn time_scale_mut(&mut self) -> &mut f32 {
        &mut self.time_scale
    }
    fn scale_down_transition_time(&self) -> &f32 {
        &self.scale_down_transition_time
    }
    fn scale_down_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.scale_down_transition_time
    }
    fn scale_up_transition_time(&self) -> &f32 {
        &self.scale_up_transition_time
    }
    fn scale_up_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.scale_up_transition_time
    }
}

impl super::entity::EntityDataTrait for SlowMotionEntityData {
}

impl super::entity::GameObjectDataTrait for SlowMotionEntityData {
}

impl super::core::DataBusPeerTrait for SlowMotionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SlowMotionEntityData {
}

impl super::core::DataContainerTrait for SlowMotionEntityData {
}

pub static SLOWMOTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SlowMotionEntityData",
    name_hash: 3878611959,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SlowMotionEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SlowMotionEntityData as Default>::default())),
            create_boxed: || Box::new(<SlowMotionEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SlowMotionEntityData, realm),
            },
            FieldInfoData {
                name: "TimeScale",
                name_hash: 169511528,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SlowMotionEntityData, time_scale),
            },
            FieldInfoData {
                name: "ScaleDownTransitionTime",
                name_hash: 3146782549,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SlowMotionEntityData, scale_down_transition_time),
            },
            FieldInfoData {
                name: "ScaleUpTransitionTime",
                name_hash: 877920322,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SlowMotionEntityData, scale_up_transition_time),
            },
        ],
    }),
    array_type: Some(SLOWMOTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SlowMotionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SLOWMOTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SLOWMOTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SlowMotionEntityData-Array",
    name_hash: 1661269443,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SlowMotionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CollisionNetState {
    pub position: super::core::Vec3,
    pub normal: super::core::Vec3,
    pub material: super::entity::MaterialDecl,
    pub own_material: super::entity::MaterialDecl,
    pub speed: f32,
    pub time: f32,
}

pub trait CollisionNetStateTrait: TypeObject {
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn normal(&self) -> &super::core::Vec3;
    fn normal_mut(&mut self) -> &mut super::core::Vec3;
    fn material(&self) -> &super::entity::MaterialDecl;
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn own_material(&self) -> &super::entity::MaterialDecl;
    fn own_material_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
}

impl CollisionNetStateTrait for CollisionNetState {
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn normal(&self) -> &super::core::Vec3 {
        &self.normal
    }
    fn normal_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.normal
    }
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material
    }
    fn own_material(&self) -> &super::entity::MaterialDecl {
        &self.own_material
    }
    fn own_material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.own_material
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
}

pub static COLLISIONNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionNetState",
    name_hash: 39899475,
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CollisionNetState as Default>::default())),
            create_boxed: || Box::new(<CollisionNetState as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Position",
                name_hash: 3402582524,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CollisionNetState, position),
            },
            FieldInfoData {
                name: "Normal",
                name_hash: 2827188502,
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CollisionNetState, normal),
            },
            FieldInfoData {
                name: "Material",
                name_hash: 845639918,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(CollisionNetState, material),
            },
            FieldInfoData {
                name: "OwnMaterial",
                name_hash: 3762967288,
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(CollisionNetState, own_material),
            },
            FieldInfoData {
                name: "Speed",
                name_hash: 230887042,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionNetState, speed),
            },
            FieldInfoData {
                name: "Time",
                name_hash: 2089313744,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionNetState, time),
            },
        ],
    }),
    array_type: Some(COLLISIONNETSTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CollisionNetState {
    fn type_info(&self) -> &'static TypeInfo {
        COLLISIONNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COLLISIONNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionNetState-Array",
    name_hash: 1433222247,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CollisionNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ServerSettings {
    pub _glacier_base: super::core::SystemSettings,
    pub instance_path: String,
    pub remote_control_port: u32,
    pub query_provider_enabled: bool,
    pub max_queries_per_second: u32,
    pub debris_cluster_enabled: bool,
    pub vegetation_enabled: bool,
    pub water_physics_enabled: bool,
    pub is_deserting_allowed: bool,
    pub is_render_damage_events: bool,
    pub respawn_on_death_position: bool,
    pub is_stats_enabled: bool,
    pub is_network_stats_enabled: bool,
    pub is_ai_enabled: bool,
    pub is_destruction_enabled: bool,
    pub is_soldier_animation_enabled: bool,
    pub is_soldier_detailed_collision_enabled: bool,
    pub load_save_point: bool,
    pub save_point: String,
    pub disable_cutscenes: bool,
    pub havok_visual_debugger: bool,
    pub havok_capture_to_file: bool,
    pub show_trigger_debug_text: bool,
    pub timeout_game: bool,
    pub timeout_time: f32,
    pub player_count_needed_for_multiplayer: u32,
    pub a_i_looks_into_camera: bool,
    pub debug_menu_click: String,
    pub deathmatch_debug_info: bool,
    pub vehicle_interaction_ignores_see_through: bool,
    pub congestion_ctrl: CongestionControlSettings,
    pub job_enable: bool,
    pub threading_enable: bool,
    pub draw_active_physics_objects: bool,
    pub is_ranked: bool,
    pub unlock_resolver: bool,
    pub scoring_log_enabled: bool,
    pub instant_update_enabled: bool,
    pub loading_timeout: f32,
    pub ingame_timeout: f32,
    pub outgoing_frequency: f32,
    pub incoming_frequency: f32,
    pub incoming_rate: u32,
    pub outgoing_rate: u32,
    pub playlist: String,
    pub force_playlist: bool,
    pub dedicated_server_cpu: i32,
    pub auto_unspawn_bangers: bool,
    pub regulated_a_i_throttle: bool,
    pub enable_animation_culling: bool,
    pub fall_back_to_squad_spawn: bool,
    pub save_game_version: u32,
    pub save_game_use_profile_saves: bool,
    pub server_name: String,
    pub server_password: String,
    pub vehicle_spawn_allowed: bool,
    pub vehicle_spawn_delay_modifier: f32,
    pub human_health_multiplier: f32,
    pub respawn_time_modifier: f32,
    pub administration_enabled: bool,
    pub administration_log_enabled: bool,
    pub administration_time_stamp_log_names: bool,
    pub administration_events_enabled: bool,
    pub administration_server_name_restricted: bool,
    pub administration_password: String,
    pub remote_administration_port: String,
    pub extended_juice_logging_enabled: bool,
}

pub trait ServerSettingsTrait: super::core::SystemSettingsTrait {
    fn instance_path(&self) -> &String;
    fn instance_path_mut(&mut self) -> &mut String;
    fn remote_control_port(&self) -> &u32;
    fn remote_control_port_mut(&mut self) -> &mut u32;
    fn query_provider_enabled(&self) -> &bool;
    fn query_provider_enabled_mut(&mut self) -> &mut bool;
    fn max_queries_per_second(&self) -> &u32;
    fn max_queries_per_second_mut(&mut self) -> &mut u32;
    fn debris_cluster_enabled(&self) -> &bool;
    fn debris_cluster_enabled_mut(&mut self) -> &mut bool;
    fn vegetation_enabled(&self) -> &bool;
    fn vegetation_enabled_mut(&mut self) -> &mut bool;
    fn water_physics_enabled(&self) -> &bool;
    fn water_physics_enabled_mut(&mut self) -> &mut bool;
    fn is_deserting_allowed(&self) -> &bool;
    fn is_deserting_allowed_mut(&mut self) -> &mut bool;
    fn is_render_damage_events(&self) -> &bool;
    fn is_render_damage_events_mut(&mut self) -> &mut bool;
    fn respawn_on_death_position(&self) -> &bool;
    fn respawn_on_death_position_mut(&mut self) -> &mut bool;
    fn is_stats_enabled(&self) -> &bool;
    fn is_stats_enabled_mut(&mut self) -> &mut bool;
    fn is_network_stats_enabled(&self) -> &bool;
    fn is_network_stats_enabled_mut(&mut self) -> &mut bool;
    fn is_ai_enabled(&self) -> &bool;
    fn is_ai_enabled_mut(&mut self) -> &mut bool;
    fn is_destruction_enabled(&self) -> &bool;
    fn is_destruction_enabled_mut(&mut self) -> &mut bool;
    fn is_soldier_animation_enabled(&self) -> &bool;
    fn is_soldier_animation_enabled_mut(&mut self) -> &mut bool;
    fn is_soldier_detailed_collision_enabled(&self) -> &bool;
    fn is_soldier_detailed_collision_enabled_mut(&mut self) -> &mut bool;
    fn load_save_point(&self) -> &bool;
    fn load_save_point_mut(&mut self) -> &mut bool;
    fn save_point(&self) -> &String;
    fn save_point_mut(&mut self) -> &mut String;
    fn disable_cutscenes(&self) -> &bool;
    fn disable_cutscenes_mut(&mut self) -> &mut bool;
    fn havok_visual_debugger(&self) -> &bool;
    fn havok_visual_debugger_mut(&mut self) -> &mut bool;
    fn havok_capture_to_file(&self) -> &bool;
    fn havok_capture_to_file_mut(&mut self) -> &mut bool;
    fn show_trigger_debug_text(&self) -> &bool;
    fn show_trigger_debug_text_mut(&mut self) -> &mut bool;
    fn timeout_game(&self) -> &bool;
    fn timeout_game_mut(&mut self) -> &mut bool;
    fn timeout_time(&self) -> &f32;
    fn timeout_time_mut(&mut self) -> &mut f32;
    fn player_count_needed_for_multiplayer(&self) -> &u32;
    fn player_count_needed_for_multiplayer_mut(&mut self) -> &mut u32;
    fn a_i_looks_into_camera(&self) -> &bool;
    fn a_i_looks_into_camera_mut(&mut self) -> &mut bool;
    fn debug_menu_click(&self) -> &String;
    fn debug_menu_click_mut(&mut self) -> &mut String;
    fn deathmatch_debug_info(&self) -> &bool;
    fn deathmatch_debug_info_mut(&mut self) -> &mut bool;
    fn vehicle_interaction_ignores_see_through(&self) -> &bool;
    fn vehicle_interaction_ignores_see_through_mut(&mut self) -> &mut bool;
    fn congestion_ctrl(&self) -> &CongestionControlSettings;
    fn congestion_ctrl_mut(&mut self) -> &mut CongestionControlSettings;
    fn job_enable(&self) -> &bool;
    fn job_enable_mut(&mut self) -> &mut bool;
    fn threading_enable(&self) -> &bool;
    fn threading_enable_mut(&mut self) -> &mut bool;
    fn draw_active_physics_objects(&self) -> &bool;
    fn draw_active_physics_objects_mut(&mut self) -> &mut bool;
    fn is_ranked(&self) -> &bool;
    fn is_ranked_mut(&mut self) -> &mut bool;
    fn unlock_resolver(&self) -> &bool;
    fn unlock_resolver_mut(&mut self) -> &mut bool;
    fn scoring_log_enabled(&self) -> &bool;
    fn scoring_log_enabled_mut(&mut self) -> &mut bool;
    fn instant_update_enabled(&self) -> &bool;
    fn instant_update_enabled_mut(&mut self) -> &mut bool;
    fn loading_timeout(&self) -> &f32;
    fn loading_timeout_mut(&mut self) -> &mut f32;
    fn ingame_timeout(&self) -> &f32;
    fn ingame_timeout_mut(&mut self) -> &mut f32;
    fn outgoing_frequency(&self) -> &f32;
    fn outgoing_frequency_mut(&mut self) -> &mut f32;
    fn incoming_frequency(&self) -> &f32;
    fn incoming_frequency_mut(&mut self) -> &mut f32;
    fn incoming_rate(&self) -> &u32;
    fn incoming_rate_mut(&mut self) -> &mut u32;
    fn outgoing_rate(&self) -> &u32;
    fn outgoing_rate_mut(&mut self) -> &mut u32;
    fn playlist(&self) -> &String;
    fn playlist_mut(&mut self) -> &mut String;
    fn force_playlist(&self) -> &bool;
    fn force_playlist_mut(&mut self) -> &mut bool;
    fn dedicated_server_cpu(&self) -> &i32;
    fn dedicated_server_cpu_mut(&mut self) -> &mut i32;
    fn auto_unspawn_bangers(&self) -> &bool;
    fn auto_unspawn_bangers_mut(&mut self) -> &mut bool;
    fn regulated_a_i_throttle(&self) -> &bool;
    fn regulated_a_i_throttle_mut(&mut self) -> &mut bool;
    fn enable_animation_culling(&self) -> &bool;
    fn enable_animation_culling_mut(&mut self) -> &mut bool;
    fn fall_back_to_squad_spawn(&self) -> &bool;
    fn fall_back_to_squad_spawn_mut(&mut self) -> &mut bool;
    fn save_game_version(&self) -> &u32;
    fn save_game_version_mut(&mut self) -> &mut u32;
    fn save_game_use_profile_saves(&self) -> &bool;
    fn save_game_use_profile_saves_mut(&mut self) -> &mut bool;
    fn server_name(&self) -> &String;
    fn server_name_mut(&mut self) -> &mut String;
    fn server_password(&self) -> &String;
    fn server_password_mut(&mut self) -> &mut String;
    fn vehicle_spawn_allowed(&self) -> &bool;
    fn vehicle_spawn_allowed_mut(&mut self) -> &mut bool;
    fn vehicle_spawn_delay_modifier(&self) -> &f32;
    fn vehicle_spawn_delay_modifier_mut(&mut self) -> &mut f32;
    fn human_health_multiplier(&self) -> &f32;
    fn human_health_multiplier_mut(&mut self) -> &mut f32;
    fn respawn_time_modifier(&self) -> &f32;
    fn respawn_time_modifier_mut(&mut self) -> &mut f32;
    fn administration_enabled(&self) -> &bool;
    fn administration_enabled_mut(&mut self) -> &mut bool;
    fn administration_log_enabled(&self) -> &bool;
    fn administration_log_enabled_mut(&mut self) -> &mut bool;
    fn administration_time_stamp_log_names(&self) -> &bool;
    fn administration_time_stamp_log_names_mut(&mut self) -> &mut bool;
    fn administration_events_enabled(&self) -> &bool;
    fn administration_events_enabled_mut(&mut self) -> &mut bool;
    fn administration_server_name_restricted(&self) -> &bool;
    fn administration_server_name_restricted_mut(&mut self) -> &mut bool;
    fn administration_password(&self) -> &String;
    fn administration_password_mut(&mut self) -> &mut String;
    fn remote_administration_port(&self) -> &String;
    fn remote_administration_port_mut(&mut self) -> &mut String;
    fn extended_juice_logging_enabled(&self) -> &bool;
    fn extended_juice_logging_enabled_mut(&mut self) -> &mut bool;
}

impl ServerSettingsTrait for ServerSettings {
    fn instance_path(&self) -> &String {
        &self.instance_path
    }
    fn instance_path_mut(&mut self) -> &mut String {
        &mut self.instance_path
    }
    fn remote_control_port(&self) -> &u32 {
        &self.remote_control_port
    }
    fn remote_control_port_mut(&mut self) -> &mut u32 {
        &mut self.remote_control_port
    }
    fn query_provider_enabled(&self) -> &bool {
        &self.query_provider_enabled
    }
    fn query_provider_enabled_mut(&mut self) -> &mut bool {
        &mut self.query_provider_enabled
    }
    fn max_queries_per_second(&self) -> &u32 {
        &self.max_queries_per_second
    }
    fn max_queries_per_second_mut(&mut self) -> &mut u32 {
        &mut self.max_queries_per_second
    }
    fn debris_cluster_enabled(&self) -> &bool {
        &self.debris_cluster_enabled
    }
    fn debris_cluster_enabled_mut(&mut self) -> &mut bool {
        &mut self.debris_cluster_enabled
    }
    fn vegetation_enabled(&self) -> &bool {
        &self.vegetation_enabled
    }
    fn vegetation_enabled_mut(&mut self) -> &mut bool {
        &mut self.vegetation_enabled
    }
    fn water_physics_enabled(&self) -> &bool {
        &self.water_physics_enabled
    }
    fn water_physics_enabled_mut(&mut self) -> &mut bool {
        &mut self.water_physics_enabled
    }
    fn is_deserting_allowed(&self) -> &bool {
        &self.is_deserting_allowed
    }
    fn is_deserting_allowed_mut(&mut self) -> &mut bool {
        &mut self.is_deserting_allowed
    }
    fn is_render_damage_events(&self) -> &bool {
        &self.is_render_damage_events
    }
    fn is_render_damage_events_mut(&mut self) -> &mut bool {
        &mut self.is_render_damage_events
    }
    fn respawn_on_death_position(&self) -> &bool {
        &self.respawn_on_death_position
    }
    fn respawn_on_death_position_mut(&mut self) -> &mut bool {
        &mut self.respawn_on_death_position
    }
    fn is_stats_enabled(&self) -> &bool {
        &self.is_stats_enabled
    }
    fn is_stats_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_stats_enabled
    }
    fn is_network_stats_enabled(&self) -> &bool {
        &self.is_network_stats_enabled
    }
    fn is_network_stats_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_network_stats_enabled
    }
    fn is_ai_enabled(&self) -> &bool {
        &self.is_ai_enabled
    }
    fn is_ai_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_ai_enabled
    }
    fn is_destruction_enabled(&self) -> &bool {
        &self.is_destruction_enabled
    }
    fn is_destruction_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_destruction_enabled
    }
    fn is_soldier_animation_enabled(&self) -> &bool {
        &self.is_soldier_animation_enabled
    }
    fn is_soldier_animation_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_soldier_animation_enabled
    }
    fn is_soldier_detailed_collision_enabled(&self) -> &bool {
        &self.is_soldier_detailed_collision_enabled
    }
    fn is_soldier_detailed_collision_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_soldier_detailed_collision_enabled
    }
    fn load_save_point(&self) -> &bool {
        &self.load_save_point
    }
    fn load_save_point_mut(&mut self) -> &mut bool {
        &mut self.load_save_point
    }
    fn save_point(&self) -> &String {
        &self.save_point
    }
    fn save_point_mut(&mut self) -> &mut String {
        &mut self.save_point
    }
    fn disable_cutscenes(&self) -> &bool {
        &self.disable_cutscenes
    }
    fn disable_cutscenes_mut(&mut self) -> &mut bool {
        &mut self.disable_cutscenes
    }
    fn havok_visual_debugger(&self) -> &bool {
        &self.havok_visual_debugger
    }
    fn havok_visual_debugger_mut(&mut self) -> &mut bool {
        &mut self.havok_visual_debugger
    }
    fn havok_capture_to_file(&self) -> &bool {
        &self.havok_capture_to_file
    }
    fn havok_capture_to_file_mut(&mut self) -> &mut bool {
        &mut self.havok_capture_to_file
    }
    fn show_trigger_debug_text(&self) -> &bool {
        &self.show_trigger_debug_text
    }
    fn show_trigger_debug_text_mut(&mut self) -> &mut bool {
        &mut self.show_trigger_debug_text
    }
    fn timeout_game(&self) -> &bool {
        &self.timeout_game
    }
    fn timeout_game_mut(&mut self) -> &mut bool {
        &mut self.timeout_game
    }
    fn timeout_time(&self) -> &f32 {
        &self.timeout_time
    }
    fn timeout_time_mut(&mut self) -> &mut f32 {
        &mut self.timeout_time
    }
    fn player_count_needed_for_multiplayer(&self) -> &u32 {
        &self.player_count_needed_for_multiplayer
    }
    fn player_count_needed_for_multiplayer_mut(&mut self) -> &mut u32 {
        &mut self.player_count_needed_for_multiplayer
    }
    fn a_i_looks_into_camera(&self) -> &bool {
        &self.a_i_looks_into_camera
    }
    fn a_i_looks_into_camera_mut(&mut self) -> &mut bool {
        &mut self.a_i_looks_into_camera
    }
    fn debug_menu_click(&self) -> &String {
        &self.debug_menu_click
    }
    fn debug_menu_click_mut(&mut self) -> &mut String {
        &mut self.debug_menu_click
    }
    fn deathmatch_debug_info(&self) -> &bool {
        &self.deathmatch_debug_info
    }
    fn deathmatch_debug_info_mut(&mut self) -> &mut bool {
        &mut self.deathmatch_debug_info
    }
    fn vehicle_interaction_ignores_see_through(&self) -> &bool {
        &self.vehicle_interaction_ignores_see_through
    }
    fn vehicle_interaction_ignores_see_through_mut(&mut self) -> &mut bool {
        &mut self.vehicle_interaction_ignores_see_through
    }
    fn congestion_ctrl(&self) -> &CongestionControlSettings {
        &self.congestion_ctrl
    }
    fn congestion_ctrl_mut(&mut self) -> &mut CongestionControlSettings {
        &mut self.congestion_ctrl
    }
    fn job_enable(&self) -> &bool {
        &self.job_enable
    }
    fn job_enable_mut(&mut self) -> &mut bool {
        &mut self.job_enable
    }
    fn threading_enable(&self) -> &bool {
        &self.threading_enable
    }
    fn threading_enable_mut(&mut self) -> &mut bool {
        &mut self.threading_enable
    }
    fn draw_active_physics_objects(&self) -> &bool {
        &self.draw_active_physics_objects
    }
    fn draw_active_physics_objects_mut(&mut self) -> &mut bool {
        &mut self.draw_active_physics_objects
    }
    fn is_ranked(&self) -> &bool {
        &self.is_ranked
    }
    fn is_ranked_mut(&mut self) -> &mut bool {
        &mut self.is_ranked
    }
    fn unlock_resolver(&self) -> &bool {
        &self.unlock_resolver
    }
    fn unlock_resolver_mut(&mut self) -> &mut bool {
        &mut self.unlock_resolver
    }
    fn scoring_log_enabled(&self) -> &bool {
        &self.scoring_log_enabled
    }
    fn scoring_log_enabled_mut(&mut self) -> &mut bool {
        &mut self.scoring_log_enabled
    }
    fn instant_update_enabled(&self) -> &bool {
        &self.instant_update_enabled
    }
    fn instant_update_enabled_mut(&mut self) -> &mut bool {
        &mut self.instant_update_enabled
    }
    fn loading_timeout(&self) -> &f32 {
        &self.loading_timeout
    }
    fn loading_timeout_mut(&mut self) -> &mut f32 {
        &mut self.loading_timeout
    }
    fn ingame_timeout(&self) -> &f32 {
        &self.ingame_timeout
    }
    fn ingame_timeout_mut(&mut self) -> &mut f32 {
        &mut self.ingame_timeout
    }
    fn outgoing_frequency(&self) -> &f32 {
        &self.outgoing_frequency
    }
    fn outgoing_frequency_mut(&mut self) -> &mut f32 {
        &mut self.outgoing_frequency
    }
    fn incoming_frequency(&self) -> &f32 {
        &self.incoming_frequency
    }
    fn incoming_frequency_mut(&mut self) -> &mut f32 {
        &mut self.incoming_frequency
    }
    fn incoming_rate(&self) -> &u32 {
        &self.incoming_rate
    }
    fn incoming_rate_mut(&mut self) -> &mut u32 {
        &mut self.incoming_rate
    }
    fn outgoing_rate(&self) -> &u32 {
        &self.outgoing_rate
    }
    fn outgoing_rate_mut(&mut self) -> &mut u32 {
        &mut self.outgoing_rate
    }
    fn playlist(&self) -> &String {
        &self.playlist
    }
    fn playlist_mut(&mut self) -> &mut String {
        &mut self.playlist
    }
    fn force_playlist(&self) -> &bool {
        &self.force_playlist
    }
    fn force_playlist_mut(&mut self) -> &mut bool {
        &mut self.force_playlist
    }
    fn dedicated_server_cpu(&self) -> &i32 {
        &self.dedicated_server_cpu
    }
    fn dedicated_server_cpu_mut(&mut self) -> &mut i32 {
        &mut self.dedicated_server_cpu
    }
    fn auto_unspawn_bangers(&self) -> &bool {
        &self.auto_unspawn_bangers
    }
    fn auto_unspawn_bangers_mut(&mut self) -> &mut bool {
        &mut self.auto_unspawn_bangers
    }
    fn regulated_a_i_throttle(&self) -> &bool {
        &self.regulated_a_i_throttle
    }
    fn regulated_a_i_throttle_mut(&mut self) -> &mut bool {
        &mut self.regulated_a_i_throttle
    }
    fn enable_animation_culling(&self) -> &bool {
        &self.enable_animation_culling
    }
    fn enable_animation_culling_mut(&mut self) -> &mut bool {
        &mut self.enable_animation_culling
    }
    fn fall_back_to_squad_spawn(&self) -> &bool {
        &self.fall_back_to_squad_spawn
    }
    fn fall_back_to_squad_spawn_mut(&mut self) -> &mut bool {
        &mut self.fall_back_to_squad_spawn
    }
    fn save_game_version(&self) -> &u32 {
        &self.save_game_version
    }
    fn save_game_version_mut(&mut self) -> &mut u32 {
        &mut self.save_game_version
    }
    fn save_game_use_profile_saves(&self) -> &bool {
        &self.save_game_use_profile_saves
    }
    fn save_game_use_profile_saves_mut(&mut self) -> &mut bool {
        &mut self.save_game_use_profile_saves
    }
    fn server_name(&self) -> &String {
        &self.server_name
    }
    fn server_name_mut(&mut self) -> &mut String {
        &mut self.server_name
    }
    fn server_password(&self) -> &String {
        &self.server_password
    }
    fn server_password_mut(&mut self) -> &mut String {
        &mut self.server_password
    }
    fn vehicle_spawn_allowed(&self) -> &bool {
        &self.vehicle_spawn_allowed
    }
    fn vehicle_spawn_allowed_mut(&mut self) -> &mut bool {
        &mut self.vehicle_spawn_allowed
    }
    fn vehicle_spawn_delay_modifier(&self) -> &f32 {
        &self.vehicle_spawn_delay_modifier
    }
    fn vehicle_spawn_delay_modifier_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_spawn_delay_modifier
    }
    fn human_health_multiplier(&self) -> &f32 {
        &self.human_health_multiplier
    }
    fn human_health_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.human_health_multiplier
    }
    fn respawn_time_modifier(&self) -> &f32 {
        &self.respawn_time_modifier
    }
    fn respawn_time_modifier_mut(&mut self) -> &mut f32 {
        &mut self.respawn_time_modifier
    }
    fn administration_enabled(&self) -> &bool {
        &self.administration_enabled
    }
    fn administration_enabled_mut(&mut self) -> &mut bool {
        &mut self.administration_enabled
    }
    fn administration_log_enabled(&self) -> &bool {
        &self.administration_log_enabled
    }
    fn administration_log_enabled_mut(&mut self) -> &mut bool {
        &mut self.administration_log_enabled
    }
    fn administration_time_stamp_log_names(&self) -> &bool {
        &self.administration_time_stamp_log_names
    }
    fn administration_time_stamp_log_names_mut(&mut self) -> &mut bool {
        &mut self.administration_time_stamp_log_names
    }
    fn administration_events_enabled(&self) -> &bool {
        &self.administration_events_enabled
    }
    fn administration_events_enabled_mut(&mut self) -> &mut bool {
        &mut self.administration_events_enabled
    }
    fn administration_server_name_restricted(&self) -> &bool {
        &self.administration_server_name_restricted
    }
    fn administration_server_name_restricted_mut(&mut self) -> &mut bool {
        &mut self.administration_server_name_restricted
    }
    fn administration_password(&self) -> &String {
        &self.administration_password
    }
    fn administration_password_mut(&mut self) -> &mut String {
        &mut self.administration_password
    }
    fn remote_administration_port(&self) -> &String {
        &self.remote_administration_port
    }
    fn remote_administration_port_mut(&mut self) -> &mut String {
        &mut self.remote_administration_port
    }
    fn extended_juice_logging_enabled(&self) -> &bool {
        &self.extended_juice_logging_enabled
    }
    fn extended_juice_logging_enabled_mut(&mut self) -> &mut bool {
        &mut self.extended_juice_logging_enabled
    }
}

impl super::core::SystemSettingsTrait for ServerSettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        self._glacier_base.platform_mut()
    }
}

impl super::core::DataContainerTrait for ServerSettings {
}

pub static SERVERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerSettings",
    name_hash: 1659091941,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        super_class_offset: offset_of!(ServerSettings, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerSettings as Default>::default())),
            create_boxed: || Box::new(<ServerSettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "InstancePath",
                name_hash: 1188027073,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, instance_path),
            },
            FieldInfoData {
                name: "RemoteControlPort",
                name_hash: 2050172703,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, remote_control_port),
            },
            FieldInfoData {
                name: "QueryProviderEnabled",
                name_hash: 2501867691,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, query_provider_enabled),
            },
            FieldInfoData {
                name: "MaxQueriesPerSecond",
                name_hash: 1108763338,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, max_queries_per_second),
            },
            FieldInfoData {
                name: "DebrisClusterEnabled",
                name_hash: 3885754465,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, debris_cluster_enabled),
            },
            FieldInfoData {
                name: "VegetationEnabled",
                name_hash: 1260276984,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, vegetation_enabled),
            },
            FieldInfoData {
                name: "WaterPhysicsEnabled",
                name_hash: 4150371006,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, water_physics_enabled),
            },
            FieldInfoData {
                name: "IsDesertingAllowed",
                name_hash: 686355126,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_deserting_allowed),
            },
            FieldInfoData {
                name: "IsRenderDamageEvents",
                name_hash: 1150027009,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_render_damage_events),
            },
            FieldInfoData {
                name: "RespawnOnDeathPosition",
                name_hash: 4145685869,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, respawn_on_death_position),
            },
            FieldInfoData {
                name: "IsStatsEnabled",
                name_hash: 18279707,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_stats_enabled),
            },
            FieldInfoData {
                name: "IsNetworkStatsEnabled",
                name_hash: 3782966053,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_network_stats_enabled),
            },
            FieldInfoData {
                name: "IsAiEnabled",
                name_hash: 2380226514,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_ai_enabled),
            },
            FieldInfoData {
                name: "IsDestructionEnabled",
                name_hash: 3503383684,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_destruction_enabled),
            },
            FieldInfoData {
                name: "IsSoldierAnimationEnabled",
                name_hash: 3800480326,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_soldier_animation_enabled),
            },
            FieldInfoData {
                name: "IsSoldierDetailedCollisionEnabled",
                name_hash: 2603752286,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_soldier_detailed_collision_enabled),
            },
            FieldInfoData {
                name: "LoadSavePoint",
                name_hash: 740179758,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, load_save_point),
            },
            FieldInfoData {
                name: "SavePoint",
                name_hash: 1886045224,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, save_point),
            },
            FieldInfoData {
                name: "DisableCutscenes",
                name_hash: 2592294494,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, disable_cutscenes),
            },
            FieldInfoData {
                name: "HavokVisualDebugger",
                name_hash: 1929453227,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, havok_visual_debugger),
            },
            FieldInfoData {
                name: "HavokCaptureToFile",
                name_hash: 199879943,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, havok_capture_to_file),
            },
            FieldInfoData {
                name: "ShowTriggerDebugText",
                name_hash: 379584722,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, show_trigger_debug_text),
            },
            FieldInfoData {
                name: "TimeoutGame",
                name_hash: 2552389232,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, timeout_game),
            },
            FieldInfoData {
                name: "TimeoutTime",
                name_hash: 2552048779,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, timeout_time),
            },
            FieldInfoData {
                name: "PlayerCountNeededForMultiplayer",
                name_hash: 2906149535,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, player_count_needed_for_multiplayer),
            },
            FieldInfoData {
                name: "AILooksIntoCamera",
                name_hash: 2811501308,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, a_i_looks_into_camera),
            },
            FieldInfoData {
                name: "DebugMenuClick",
                name_hash: 219459689,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, debug_menu_click),
            },
            FieldInfoData {
                name: "DeathmatchDebugInfo",
                name_hash: 167269973,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, deathmatch_debug_info),
            },
            FieldInfoData {
                name: "VehicleInteractionIgnoresSeeThrough",
                name_hash: 1991943140,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, vehicle_interaction_ignores_see_through),
            },
            FieldInfoData {
                name: "CongestionCtrl",
                name_hash: 3706061507,
                flags: MemberInfoFlags::new(0),
                field_type: "CongestionControlSettings",
                rust_offset: offset_of!(ServerSettings, congestion_ctrl),
            },
            FieldInfoData {
                name: "JobEnable",
                name_hash: 442685923,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, job_enable),
            },
            FieldInfoData {
                name: "ThreadingEnable",
                name_hash: 3470873770,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, threading_enable),
            },
            FieldInfoData {
                name: "DrawActivePhysicsObjects",
                name_hash: 3563516612,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, draw_active_physics_objects),
            },
            FieldInfoData {
                name: "IsRanked",
                name_hash: 421704968,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_ranked),
            },
            FieldInfoData {
                name: "UnlockResolver",
                name_hash: 3015574227,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, unlock_resolver),
            },
            FieldInfoData {
                name: "ScoringLogEnabled",
                name_hash: 3740384009,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, scoring_log_enabled),
            },
            FieldInfoData {
                name: "InstantUpdateEnabled",
                name_hash: 3442025066,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, instant_update_enabled),
            },
            FieldInfoData {
                name: "LoadingTimeout",
                name_hash: 1203409176,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, loading_timeout),
            },
            FieldInfoData {
                name: "IngameTimeout",
                name_hash: 178921847,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, ingame_timeout),
            },
            FieldInfoData {
                name: "OutgoingFrequency",
                name_hash: 657578791,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, outgoing_frequency),
            },
            FieldInfoData {
                name: "IncomingFrequency",
                name_hash: 1185543623,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, incoming_frequency),
            },
            FieldInfoData {
                name: "IncomingRate",
                name_hash: 2958796769,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, incoming_rate),
            },
            FieldInfoData {
                name: "OutgoingRate",
                name_hash: 3079887233,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, outgoing_rate),
            },
            FieldInfoData {
                name: "Playlist",
                name_hash: 927771683,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, playlist),
            },
            FieldInfoData {
                name: "ForcePlaylist",
                name_hash: 2185859614,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, force_playlist),
            },
            FieldInfoData {
                name: "DedicatedServerCpu",
                name_hash: 4012132925,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ServerSettings, dedicated_server_cpu),
            },
            FieldInfoData {
                name: "AutoUnspawnBangers",
                name_hash: 2106862756,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, auto_unspawn_bangers),
            },
            FieldInfoData {
                name: "RegulatedAIThrottle",
                name_hash: 3666128056,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, regulated_a_i_throttle),
            },
            FieldInfoData {
                name: "EnableAnimationCulling",
                name_hash: 4034860932,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, enable_animation_culling),
            },
            FieldInfoData {
                name: "FallBackToSquadSpawn",
                name_hash: 2693064955,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, fall_back_to_squad_spawn),
            },
            FieldInfoData {
                name: "SaveGameVersion",
                name_hash: 1621131600,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, save_game_version),
            },
            FieldInfoData {
                name: "SaveGameUseProfileSaves",
                name_hash: 510479728,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, save_game_use_profile_saves),
            },
            FieldInfoData {
                name: "ServerName",
                name_hash: 1802252391,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, server_name),
            },
            FieldInfoData {
                name: "ServerPassword",
                name_hash: 82517919,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, server_password),
            },
            FieldInfoData {
                name: "VehicleSpawnAllowed",
                name_hash: 108238142,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, vehicle_spawn_allowed),
            },
            FieldInfoData {
                name: "VehicleSpawnDelayModifier",
                name_hash: 1247328452,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, vehicle_spawn_delay_modifier),
            },
            FieldInfoData {
                name: "HumanHealthMultiplier",
                name_hash: 1831700397,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, human_health_multiplier),
            },
            FieldInfoData {
                name: "RespawnTimeModifier",
                name_hash: 3384743563,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, respawn_time_modifier),
            },
            FieldInfoData {
                name: "AdministrationEnabled",
                name_hash: 567396142,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_enabled),
            },
            FieldInfoData {
                name: "AdministrationLogEnabled",
                name_hash: 3026093994,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_log_enabled),
            },
            FieldInfoData {
                name: "AdministrationTimeStampLogNames",
                name_hash: 1296337333,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_time_stamp_log_names),
            },
            FieldInfoData {
                name: "AdministrationEventsEnabled",
                name_hash: 4266105137,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_events_enabled),
            },
            FieldInfoData {
                name: "AdministrationServerNameRestricted",
                name_hash: 3896564372,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_server_name_restricted),
            },
            FieldInfoData {
                name: "AdministrationPassword",
                name_hash: 1271615764,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, administration_password),
            },
            FieldInfoData {
                name: "RemoteAdministrationPort",
                name_hash: 947290198,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, remote_administration_port),
            },
            FieldInfoData {
                name: "ExtendedJuiceLoggingEnabled",
                name_hash: 3726008820,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, extended_juice_logging_enabled),
            },
        ],
    }),
    array_type: Some(SERVERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ServerSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SERVERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerSettings-Array",
    name_hash: 3184968913,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ServerSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct CongestionControlSettings {
    pub enabled: bool,
    pub latency_sample_count: u32,
    pub latency_ms_min: f32,
    pub latency_ms_max: f32,
    pub packet_loss_min: f32,
    pub packet_loss_max: f32,
    pub latency_incr_ms_min: f32,
    pub latency_incr_ms_max: f32,
    pub connection_grade_bad: f32,
    pub connection_grade_good: f32,
    pub connection_grade_best: f32,
    pub freq_change_step_scale: f32,
    pub freq_dist_scale_min: f32,
    pub freq_dist_bias_max: f32,
}

pub trait CongestionControlSettingsTrait: TypeObject {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn latency_sample_count(&self) -> &u32;
    fn latency_sample_count_mut(&mut self) -> &mut u32;
    fn latency_ms_min(&self) -> &f32;
    fn latency_ms_min_mut(&mut self) -> &mut f32;
    fn latency_ms_max(&self) -> &f32;
    fn latency_ms_max_mut(&mut self) -> &mut f32;
    fn packet_loss_min(&self) -> &f32;
    fn packet_loss_min_mut(&mut self) -> &mut f32;
    fn packet_loss_max(&self) -> &f32;
    fn packet_loss_max_mut(&mut self) -> &mut f32;
    fn latency_incr_ms_min(&self) -> &f32;
    fn latency_incr_ms_min_mut(&mut self) -> &mut f32;
    fn latency_incr_ms_max(&self) -> &f32;
    fn latency_incr_ms_max_mut(&mut self) -> &mut f32;
    fn connection_grade_bad(&self) -> &f32;
    fn connection_grade_bad_mut(&mut self) -> &mut f32;
    fn connection_grade_good(&self) -> &f32;
    fn connection_grade_good_mut(&mut self) -> &mut f32;
    fn connection_grade_best(&self) -> &f32;
    fn connection_grade_best_mut(&mut self) -> &mut f32;
    fn freq_change_step_scale(&self) -> &f32;
    fn freq_change_step_scale_mut(&mut self) -> &mut f32;
    fn freq_dist_scale_min(&self) -> &f32;
    fn freq_dist_scale_min_mut(&mut self) -> &mut f32;
    fn freq_dist_bias_max(&self) -> &f32;
    fn freq_dist_bias_max_mut(&mut self) -> &mut f32;
}

impl CongestionControlSettingsTrait for CongestionControlSettings {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn latency_sample_count(&self) -> &u32 {
        &self.latency_sample_count
    }
    fn latency_sample_count_mut(&mut self) -> &mut u32 {
        &mut self.latency_sample_count
    }
    fn latency_ms_min(&self) -> &f32 {
        &self.latency_ms_min
    }
    fn latency_ms_min_mut(&mut self) -> &mut f32 {
        &mut self.latency_ms_min
    }
    fn latency_ms_max(&self) -> &f32 {
        &self.latency_ms_max
    }
    fn latency_ms_max_mut(&mut self) -> &mut f32 {
        &mut self.latency_ms_max
    }
    fn packet_loss_min(&self) -> &f32 {
        &self.packet_loss_min
    }
    fn packet_loss_min_mut(&mut self) -> &mut f32 {
        &mut self.packet_loss_min
    }
    fn packet_loss_max(&self) -> &f32 {
        &self.packet_loss_max
    }
    fn packet_loss_max_mut(&mut self) -> &mut f32 {
        &mut self.packet_loss_max
    }
    fn latency_incr_ms_min(&self) -> &f32 {
        &self.latency_incr_ms_min
    }
    fn latency_incr_ms_min_mut(&mut self) -> &mut f32 {
        &mut self.latency_incr_ms_min
    }
    fn latency_incr_ms_max(&self) -> &f32 {
        &self.latency_incr_ms_max
    }
    fn latency_incr_ms_max_mut(&mut self) -> &mut f32 {
        &mut self.latency_incr_ms_max
    }
    fn connection_grade_bad(&self) -> &f32 {
        &self.connection_grade_bad
    }
    fn connection_grade_bad_mut(&mut self) -> &mut f32 {
        &mut self.connection_grade_bad
    }
    fn connection_grade_good(&self) -> &f32 {
        &self.connection_grade_good
    }
    fn connection_grade_good_mut(&mut self) -> &mut f32 {
        &mut self.connection_grade_good
    }
    fn connection_grade_best(&self) -> &f32 {
        &self.connection_grade_best
    }
    fn connection_grade_best_mut(&mut self) -> &mut f32 {
        &mut self.connection_grade_best
    }
    fn freq_change_step_scale(&self) -> &f32 {
        &self.freq_change_step_scale
    }
    fn freq_change_step_scale_mut(&mut self) -> &mut f32 {
        &mut self.freq_change_step_scale
    }
    fn freq_dist_scale_min(&self) -> &f32 {
        &self.freq_dist_scale_min
    }
    fn freq_dist_scale_min_mut(&mut self) -> &mut f32 {
        &mut self.freq_dist_scale_min
    }
    fn freq_dist_bias_max(&self) -> &f32 {
        &self.freq_dist_bias_max
    }
    fn freq_dist_bias_max_mut(&mut self) -> &mut f32 {
        &mut self.freq_dist_bias_max
    }
}

pub static CONGESTIONCONTROLSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CongestionControlSettings",
    name_hash: 2321414472,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CongestionControlSettings as Default>::default())),
            create_boxed: || Box::new(<CongestionControlSettings as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                name_hash: 2662400,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CongestionControlSettings, enabled),
            },
            FieldInfoData {
                name: "LatencySampleCount",
                name_hash: 186892840,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CongestionControlSettings, latency_sample_count),
            },
            FieldInfoData {
                name: "LatencyMsMin",
                name_hash: 1672707033,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, latency_ms_min),
            },
            FieldInfoData {
                name: "LatencyMsMax",
                name_hash: 1672707271,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, latency_ms_max),
            },
            FieldInfoData {
                name: "PacketLossMin",
                name_hash: 960954180,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, packet_loss_min),
            },
            FieldInfoData {
                name: "PacketLossMax",
                name_hash: 960953946,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, packet_loss_max),
            },
            FieldInfoData {
                name: "LatencyIncrMsMin",
                name_hash: 1689117167,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, latency_incr_ms_min),
            },
            FieldInfoData {
                name: "LatencyIncrMsMax",
                name_hash: 1689117425,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, latency_incr_ms_max),
            },
            FieldInfoData {
                name: "ConnectionGradeBad",
                name_hash: 4275282433,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, connection_grade_bad),
            },
            FieldInfoData {
                name: "ConnectionGradeGood",
                name_hash: 3645202117,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, connection_grade_good),
            },
            FieldInfoData {
                name: "ConnectionGradeBest",
                name_hash: 3645363110,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, connection_grade_best),
            },
            FieldInfoData {
                name: "FreqChangeStepScale",
                name_hash: 1825530217,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, freq_change_step_scale),
            },
            FieldInfoData {
                name: "FreqDistScaleMin",
                name_hash: 3676351901,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, freq_dist_scale_min),
            },
            FieldInfoData {
                name: "FreqDistBiasMax",
                name_hash: 2106204898,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, freq_dist_bias_max),
            },
        ],
    }),
    array_type: Some(CONGESTIONCONTROLSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CongestionControlSettings {
    fn type_info(&self) -> &'static TypeInfo {
        CONGESTIONCONTROLSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CONGESTIONCONTROLSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CongestionControlSettings-Array",
    name_hash: 1873144828,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CongestionControlSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct ModelAnimationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub auto_start: bool,
    pub looping: bool,
    pub reset_after_stop: bool,
    pub play_first_frame: bool,
    pub default_animation: String,
    pub animation_index: i32,
    pub animation_set: Option<LockedTypeObject /* super::ant::AntAnimationSetAsset */>,
    pub external_time: f32,
    pub playback_speed: f32,
    pub instance_seed: i32,
    pub animation_entity_space: super::core::LinearTransform,
    pub animation_entity_space_active: bool,
    pub bone_to_place: super::entity::GameplayBones,
    pub disable_culling: bool,
    pub enable_joint_world_transform_output: bool,
    pub model_animation_transform_type: ModelAnimationTransformType,
    pub joint_world_transform_update_order: ModelAnimationUpdateOrder,
    pub show_debug_transforms: bool,
    pub joint_output_field_hashes: Vec<i32>,
}

pub trait ModelAnimationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn looping(&self) -> &bool;
    fn looping_mut(&mut self) -> &mut bool;
    fn reset_after_stop(&self) -> &bool;
    fn reset_after_stop_mut(&mut self) -> &mut bool;
    fn play_first_frame(&self) -> &bool;
    fn play_first_frame_mut(&mut self) -> &mut bool;
    fn default_animation(&self) -> &String;
    fn default_animation_mut(&mut self) -> &mut String;
    fn animation_index(&self) -> &i32;
    fn animation_index_mut(&mut self) -> &mut i32;
    fn animation_set(&self) -> &Option<LockedTypeObject /* super::ant::AntAnimationSetAsset */>;
    fn animation_set_mut(&mut self) -> &mut Option<LockedTypeObject /* super::ant::AntAnimationSetAsset */>;
    fn external_time(&self) -> &f32;
    fn external_time_mut(&mut self) -> &mut f32;
    fn playback_speed(&self) -> &f32;
    fn playback_speed_mut(&mut self) -> &mut f32;
    fn instance_seed(&self) -> &i32;
    fn instance_seed_mut(&mut self) -> &mut i32;
    fn animation_entity_space(&self) -> &super::core::LinearTransform;
    fn animation_entity_space_mut(&mut self) -> &mut super::core::LinearTransform;
    fn animation_entity_space_active(&self) -> &bool;
    fn animation_entity_space_active_mut(&mut self) -> &mut bool;
    fn bone_to_place(&self) -> &super::entity::GameplayBones;
    fn bone_to_place_mut(&mut self) -> &mut super::entity::GameplayBones;
    fn disable_culling(&self) -> &bool;
    fn disable_culling_mut(&mut self) -> &mut bool;
    fn enable_joint_world_transform_output(&self) -> &bool;
    fn enable_joint_world_transform_output_mut(&mut self) -> &mut bool;
    fn model_animation_transform_type(&self) -> &ModelAnimationTransformType;
    fn model_animation_transform_type_mut(&mut self) -> &mut ModelAnimationTransformType;
    fn joint_world_transform_update_order(&self) -> &ModelAnimationUpdateOrder;
    fn joint_world_transform_update_order_mut(&mut self) -> &mut ModelAnimationUpdateOrder;
    fn show_debug_transforms(&self) -> &bool;
    fn show_debug_transforms_mut(&mut self) -> &mut bool;
    fn joint_output_field_hashes(&self) -> &Vec<i32>;
    fn joint_output_field_hashes_mut(&mut self) -> &mut Vec<i32>;
}

impl ModelAnimationEntityDataTrait for ModelAnimationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn looping_mut(&mut self) -> &mut bool {
        &mut self.looping
    }
    fn reset_after_stop(&self) -> &bool {
        &self.reset_after_stop
    }
    fn reset_after_stop_mut(&mut self) -> &mut bool {
        &mut self.reset_after_stop
    }
    fn play_first_frame(&self) -> &bool {
        &self.play_first_frame
    }
    fn play_first_frame_mut(&mut self) -> &mut bool {
        &mut self.play_first_frame
    }
    fn default_animation(&self) -> &String {
        &self.default_animation
    }
    fn default_animation_mut(&mut self) -> &mut String {
        &mut self.default_animation
    }
    fn animation_index(&self) -> &i32 {
        &self.animation_index
    }
    fn animation_index_mut(&mut self) -> &mut i32 {
        &mut self.animation_index
    }
    fn animation_set(&self) -> &Option<LockedTypeObject /* super::ant::AntAnimationSetAsset */> {
        &self.animation_set
    }
    fn animation_set_mut(&mut self) -> &mut Option<LockedTypeObject /* super::ant::AntAnimationSetAsset */> {
        &mut self.animation_set
    }
    fn external_time(&self) -> &f32 {
        &self.external_time
    }
    fn external_time_mut(&mut self) -> &mut f32 {
        &mut self.external_time
    }
    fn playback_speed(&self) -> &f32 {
        &self.playback_speed
    }
    fn playback_speed_mut(&mut self) -> &mut f32 {
        &mut self.playback_speed
    }
    fn instance_seed(&self) -> &i32 {
        &self.instance_seed
    }
    fn instance_seed_mut(&mut self) -> &mut i32 {
        &mut self.instance_seed
    }
    fn animation_entity_space(&self) -> &super::core::LinearTransform {
        &self.animation_entity_space
    }
    fn animation_entity_space_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.animation_entity_space
    }
    fn animation_entity_space_active(&self) -> &bool {
        &self.animation_entity_space_active
    }
    fn animation_entity_space_active_mut(&mut self) -> &mut bool {
        &mut self.animation_entity_space_active
    }
    fn bone_to_place(&self) -> &super::entity::GameplayBones {
        &self.bone_to_place
    }
    fn bone_to_place_mut(&mut self) -> &mut super::entity::GameplayBones {
        &mut self.bone_to_place
    }
    fn disable_culling(&self) -> &bool {
        &self.disable_culling
    }
    fn disable_culling_mut(&mut self) -> &mut bool {
        &mut self.disable_culling
    }
    fn enable_joint_world_transform_output(&self) -> &bool {
        &self.enable_joint_world_transform_output
    }
    fn enable_joint_world_transform_output_mut(&mut self) -> &mut bool {
        &mut self.enable_joint_world_transform_output
    }
    fn model_animation_transform_type(&self) -> &ModelAnimationTransformType {
        &self.model_animation_transform_type
    }
    fn model_animation_transform_type_mut(&mut self) -> &mut ModelAnimationTransformType {
        &mut self.model_animation_transform_type
    }
    fn joint_world_transform_update_order(&self) -> &ModelAnimationUpdateOrder {
        &self.joint_world_transform_update_order
    }
    fn joint_world_transform_update_order_mut(&mut self) -> &mut ModelAnimationUpdateOrder {
        &mut self.joint_world_transform_update_order
    }
    fn show_debug_transforms(&self) -> &bool {
        &self.show_debug_transforms
    }
    fn show_debug_transforms_mut(&mut self) -> &mut bool {
        &mut self.show_debug_transforms
    }
    fn joint_output_field_hashes(&self) -> &Vec<i32> {
        &self.joint_output_field_hashes
    }
    fn joint_output_field_hashes_mut(&mut self) -> &mut Vec<i32> {
        &mut self.joint_output_field_hashes
    }
}

impl super::entity::EntityDataTrait for ModelAnimationEntityData {
}

impl super::entity::GameObjectDataTrait for ModelAnimationEntityData {
}

impl super::core::DataBusPeerTrait for ModelAnimationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ModelAnimationEntityData {
}

impl super::core::DataContainerTrait for ModelAnimationEntityData {
}

pub static MODELANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationEntityData",
    name_hash: 1027636247,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(ModelAnimationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ModelAnimationEntityData as Default>::default())),
            create_boxed: || Box::new(<ModelAnimationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ModelAnimationEntityData, realm),
            },
            FieldInfoData {
                name: "AutoStart",
                name_hash: 792615882,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, auto_start),
            },
            FieldInfoData {
                name: "Looping",
                name_hash: 1366646169,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, looping),
            },
            FieldInfoData {
                name: "ResetAfterStop",
                name_hash: 3668699372,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, reset_after_stop),
            },
            FieldInfoData {
                name: "PlayFirstFrame",
                name_hash: 2522640870,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, play_first_frame),
            },
            FieldInfoData {
                name: "DefaultAnimation",
                name_hash: 1576290296,
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ModelAnimationEntityData, default_animation),
            },
            FieldInfoData {
                name: "AnimationIndex",
                name_hash: 3090730541,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ModelAnimationEntityData, animation_index),
            },
            FieldInfoData {
                name: "AnimationSet",
                name_hash: 2168045937,
                flags: MemberInfoFlags::new(0),
                field_type: "AntAnimationSetAsset",
                rust_offset: offset_of!(ModelAnimationEntityData, animation_set),
            },
            FieldInfoData {
                name: "ExternalTime",
                name_hash: 2162678253,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ModelAnimationEntityData, external_time),
            },
            FieldInfoData {
                name: "PlaybackSpeed",
                name_hash: 2521405901,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ModelAnimationEntityData, playback_speed),
            },
            FieldInfoData {
                name: "InstanceSeed",
                name_hash: 1188203099,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ModelAnimationEntityData, instance_seed),
            },
            FieldInfoData {
                name: "AnimationEntitySpace",
                name_hash: 3836649996,
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ModelAnimationEntityData, animation_entity_space),
            },
            FieldInfoData {
                name: "AnimationEntitySpaceActive",
                name_hash: 3057023040,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, animation_entity_space_active),
            },
            FieldInfoData {
                name: "BoneToPlace",
                name_hash: 893212963,
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(ModelAnimationEntityData, bone_to_place),
            },
            FieldInfoData {
                name: "DisableCulling",
                name_hash: 900615207,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, disable_culling),
            },
            FieldInfoData {
                name: "EnableJointWorldTransformOutput",
                name_hash: 3310194691,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, enable_joint_world_transform_output),
            },
            FieldInfoData {
                name: "ModelAnimationTransformType",
                name_hash: 503696712,
                flags: MemberInfoFlags::new(0),
                field_type: "ModelAnimationTransformType",
                rust_offset: offset_of!(ModelAnimationEntityData, model_animation_transform_type),
            },
            FieldInfoData {
                name: "JointWorldTransformUpdateOrder",
                name_hash: 3480116738,
                flags: MemberInfoFlags::new(0),
                field_type: "ModelAnimationUpdateOrder",
                rust_offset: offset_of!(ModelAnimationEntityData, joint_world_transform_update_order),
            },
            FieldInfoData {
                name: "ShowDebugTransforms",
                name_hash: 431328136,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, show_debug_transforms),
            },
            FieldInfoData {
                name: "JointOutputFieldHashes",
                name_hash: 4135396458,
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ModelAnimationEntityData, joint_output_field_hashes),
            },
        ],
    }),
    array_type: Some(MODELANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ModelAnimationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MODELANIMATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MODELANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationEntityData-Array",
    name_hash: 237102243,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ModelAnimationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ModelAnimationTransformType {
    #[default]
    ModelAnimationTransformType_World = 0,
    ModelAnimationTransformType_Model = 1,
    ModelAnimationTransformType_Local = 2,
}

pub static MODELANIMATIONTRANSFORMTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationTransformType",
    name_hash: 503696712,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MODELANIMATIONTRANSFORMTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ModelAnimationTransformType {
    fn type_info(&self) -> &'static TypeInfo {
        MODELANIMATIONTRANSFORMTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MODELANIMATIONTRANSFORMTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationTransformType-Array",
    name_hash: 517783548,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ModelAnimationTransformType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ModelAnimationUpdateOrder {
    #[default]
    ModelAnimationUpdateOrder_PostAnimation = 0,
    ModelAnimationUpdateOrder_PreInput = 1,
}

pub static MODELANIMATIONUPDATEORDER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationUpdateOrder",
    name_hash: 1714274147,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MODELANIMATIONUPDATEORDER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ModelAnimationUpdateOrder {
    fn type_info(&self) -> &'static TypeInfo {
        MODELANIMATIONUPDATEORDER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MODELANIMATIONUPDATEORDER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationUpdateOrder-Array",
    name_hash: 1960964951,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ModelAnimationUpdateOrder"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimationEnumerationChoiceEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub value: i32,
}

pub trait AnimationEnumerationChoiceEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl AnimationEnumerationChoiceEntityDataTrait for AnimationEnumerationChoiceEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

impl super::entity::EntityDataTrait for AnimationEnumerationChoiceEntityData {
}

impl super::entity::GameObjectDataTrait for AnimationEnumerationChoiceEntityData {
}

impl super::core::DataBusPeerTrait for AnimationEnumerationChoiceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationEnumerationChoiceEntityData {
}

impl super::core::DataContainerTrait for AnimationEnumerationChoiceEntityData {
}

pub static ANIMATIONENUMERATIONCHOICEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationEnumerationChoiceEntityData",
    name_hash: 3041205290,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AnimationEnumerationChoiceEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationEnumerationChoiceEntityData as Default>::default())),
            create_boxed: || Box::new(<AnimationEnumerationChoiceEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AnimationEnumerationChoiceEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                name_hash: 225375086,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AnimationEnumerationChoiceEntityData, value),
            },
        ],
    }),
    array_type: Some(ANIMATIONENUMERATIONCHOICEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationEnumerationChoiceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONENUMERATIONCHOICEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONENUMERATIONCHOICEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationEnumerationChoiceEntityData-Array",
    name_hash: 2275407518,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationEnumerationChoiceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimationEnumerationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub ant_enum: Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */>,
    pub detect_changes_from_start: bool,
}

pub trait AnimationEnumerationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn ant_enum(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */>;
    fn ant_enum_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */>;
    fn detect_changes_from_start(&self) -> &bool;
    fn detect_changes_from_start_mut(&mut self) -> &mut bool;
}

impl AnimationEnumerationEntityDataTrait for AnimationEnumerationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn ant_enum(&self) -> &Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */> {
        &self.ant_enum
    }
    fn ant_enum_mut(&mut self) -> &mut Option<LockedTypeObject /* super::gameplay_sim::AntEnumeration */> {
        &mut self.ant_enum
    }
    fn detect_changes_from_start(&self) -> &bool {
        &self.detect_changes_from_start
    }
    fn detect_changes_from_start_mut(&mut self) -> &mut bool {
        &mut self.detect_changes_from_start
    }
}

impl super::entity::EntityDataTrait for AnimationEnumerationEntityData {
}

impl super::entity::GameObjectDataTrait for AnimationEnumerationEntityData {
}

impl super::core::DataBusPeerTrait for AnimationEnumerationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationEnumerationEntityData {
}

impl super::core::DataContainerTrait for AnimationEnumerationEntityData {
}

pub static ANIMATIONENUMERATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationEnumerationEntityData",
    name_hash: 2800679137,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AnimationEnumerationEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationEnumerationEntityData as Default>::default())),
            create_boxed: || Box::new(<AnimationEnumerationEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AnimationEnumerationEntityData, realm),
            },
            FieldInfoData {
                name: "AntEnum",
                name_hash: 577236237,
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(AnimationEnumerationEntityData, ant_enum),
            },
            FieldInfoData {
                name: "DetectChangesFromStart",
                name_hash: 641413121,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimationEnumerationEntityData, detect_changes_from_start),
            },
        ],
    }),
    array_type: Some(ANIMATIONENUMERATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationEnumerationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONENUMERATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONENUMERATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationEnumerationEntityData-Array",
    name_hash: 492573653,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationEnumerationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct AnimationSignalEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub signal: super::ant::AntRef,
    pub int_game_state: super::ant::AntRef,
    pub float_game_state: super::ant::AntRef,
    pub value_int: i32,
    pub value_float: f32,
    pub reset: bool,
    pub continuous: bool,
}

pub trait AnimationSignalEntityDataTrait: super::entity::EntityDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn int_game_state(&self) -> &super::ant::AntRef;
    fn int_game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn float_game_state(&self) -> &super::ant::AntRef;
    fn float_game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value_int(&self) -> &i32;
    fn value_int_mut(&mut self) -> &mut i32;
    fn value_float(&self) -> &f32;
    fn value_float_mut(&mut self) -> &mut f32;
    fn reset(&self) -> &bool;
    fn reset_mut(&mut self) -> &mut bool;
    fn continuous(&self) -> &bool;
    fn continuous_mut(&mut self) -> &mut bool;
}

impl AnimationSignalEntityDataTrait for AnimationSignalEntityData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn int_game_state(&self) -> &super::ant::AntRef {
        &self.int_game_state
    }
    fn int_game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.int_game_state
    }
    fn float_game_state(&self) -> &super::ant::AntRef {
        &self.float_game_state
    }
    fn float_game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.float_game_state
    }
    fn value_int(&self) -> &i32 {
        &self.value_int
    }
    fn value_int_mut(&mut self) -> &mut i32 {
        &mut self.value_int
    }
    fn value_float(&self) -> &f32 {
        &self.value_float
    }
    fn value_float_mut(&mut self) -> &mut f32 {
        &mut self.value_float
    }
    fn reset(&self) -> &bool {
        &self.reset
    }
    fn reset_mut(&mut self) -> &mut bool {
        &mut self.reset
    }
    fn continuous(&self) -> &bool {
        &self.continuous
    }
    fn continuous_mut(&mut self) -> &mut bool {
        &mut self.continuous
    }
}

impl super::entity::EntityDataTrait for AnimationSignalEntityData {
}

impl super::entity::GameObjectDataTrait for AnimationSignalEntityData {
}

impl super::core::DataBusPeerTrait for AnimationSignalEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationSignalEntityData {
}

impl super::core::DataContainerTrait for AnimationSignalEntityData {
}

pub static ANIMATIONSIGNALENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationSignalEntityData",
    name_hash: 814440518,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(AnimationSignalEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationSignalEntityData as Default>::default())),
            create_boxed: || Box::new(<AnimationSignalEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                name_hash: 3351504027,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationSignalEntityData, signal),
            },
            FieldInfoData {
                name: "IntGameState",
                name_hash: 1230275407,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationSignalEntityData, int_game_state),
            },
            FieldInfoData {
                name: "FloatGameState",
                name_hash: 4256423628,
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationSignalEntityData, float_game_state),
            },
            FieldInfoData {
                name: "ValueInt",
                name_hash: 3291173693,
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AnimationSignalEntityData, value_int),
            },
            FieldInfoData {
                name: "ValueFloat",
                name_hash: 2084221214,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AnimationSignalEntityData, value_float),
            },
            FieldInfoData {
                name: "Reset",
                name_hash: 229946160,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimationSignalEntityData, reset),
            },
            FieldInfoData {
                name: "Continuous",
                name_hash: 2748037352,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimationSignalEntityData, continuous),
            },
        ],
    }),
    array_type: Some(ANIMATIONSIGNALENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationSignalEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONSIGNALENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONSIGNALENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationSignalEntityData-Array",
    name_hash: 1794989554,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationSignalEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ScoringVisibilityType {
    #[default]
    ScoringVisibilityType_Major = 0,
    ScoringVisibilityType_Minor = 1,
    ScoringVisibilityType_Hidden = 2,
}

pub static SCORINGVISIBILITYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScoringVisibilityType",
    name_hash: 1799457718,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(SCORINGVISIBILITYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ScoringVisibilityType {
    fn type_info(&self) -> &'static TypeInfo {
        SCORINGVISIBILITYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SCORINGVISIBILITYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScoringVisibilityType-Array",
    name_hash: 1986338818,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ScoringVisibilityType"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct FloatRecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait FloatRecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl FloatRecordPropertyTrackDataTrait for FloatRecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for FloatRecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for FloatRecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for FloatRecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for FloatRecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for FloatRecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for FloatRecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatRecordPropertyTrackData {
}

impl super::core::DataContainerTrait for FloatRecordPropertyTrackData {
}

pub static FLOATRECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatRecordPropertyTrackData",
    name_hash: 69813248,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(FloatRecordPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatRecordPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<FloatRecordPropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatRecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATRECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatRecordPropertyTrackData-Array",
    name_hash: 2611669556,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FloatRecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait BoolValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl BoolValidatePropertyTrackDataTrait for BoolValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for BoolValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<LockedTypeObject /* super::timeline::TimelineTrackData */> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for BoolValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for BoolValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for BoolValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for BoolValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for BoolValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoolValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for BoolValidatePropertyTrackData {
}

pub static BOOLVALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolValidatePropertyTrackData",
    name_hash: 3843423381,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(BoolValidatePropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolValidatePropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<BoolValidatePropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLVALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolValidatePropertyTrackData-Array",
    name_hash: 2197638177,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoolValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BoolRecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait BoolRecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl BoolRecordPropertyTrackDataTrait for BoolRecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for BoolRecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* TrimmingRangeKeyframe */>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<BoxedTypeObject /* TrimmedRecordingRange */> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for BoolRecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for BoolRecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for BoolRecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::timeline::TimelineTrackDataConditionsBase */>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for BoolRecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for BoolRecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoolRecordPropertyTrackData {
}

impl super::core::DataContainerTrait for BoolRecordPropertyTrackData {
}

pub static BOOLRECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolRecordPropertyTrackData",
    name_hash: 3889003102,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        super_class_offset: offset_of!(BoolRecordPropertyTrackData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolRecordPropertyTrackData as Default>::default())),
            create_boxed: || Box::new(<BoolRecordPropertyTrackData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolRecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLRECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolRecordPropertyTrackData-Array",
    name_hash: 2281511914,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoolRecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SyncedTimelineStateChangeMessageBase {
}

pub trait SyncedTimelineStateChangeMessageBaseTrait: TypeObject {
}

impl SyncedTimelineStateChangeMessageBaseTrait for SyncedTimelineStateChangeMessageBase {
}

pub static SYNCEDTIMELINESTATECHANGEMESSAGEBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SyncedTimelineStateChangeMessageBase",
    name_hash: 2979164727,
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SyncedTimelineStateChangeMessageBase as Default>::default())),
            create_boxed: || Box::new(<SyncedTimelineStateChangeMessageBase as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 255,
};

impl TypeObject for SyncedTimelineStateChangeMessageBase {
    fn type_info(&self) -> &'static TypeInfo {
        SYNCEDTIMELINESTATECHANGEMESSAGEBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct SharedLockGateEntityData {
    pub _glacier_base: SharedLockBaseEntityData,
}

pub trait SharedLockGateEntityDataTrait: SharedLockBaseEntityDataTrait {
}

impl SharedLockGateEntityDataTrait for SharedLockGateEntityData {
}

impl SharedLockBaseEntityDataTrait for SharedLockGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn asset(&self) -> &Option<LockedTypeObject /* SharedLockAsset */> {
        self._glacier_base.asset()
    }
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* SharedLockAsset */> {
        self._glacier_base.asset_mut()
    }
}

impl super::entity::EntityDataTrait for SharedLockGateEntityData {
}

impl super::entity::GameObjectDataTrait for SharedLockGateEntityData {
}

impl super::core::DataBusPeerTrait for SharedLockGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SharedLockGateEntityData {
}

impl super::core::DataContainerTrait for SharedLockGateEntityData {
}

pub static SHAREDLOCKGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockGateEntityData",
    name_hash: 1644527611,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHAREDLOCKBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SharedLockGateEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockGateEntityData as Default>::default())),
            create_boxed: || Box::new(<SharedLockGateEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHAREDLOCKGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedLockGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockGateEntityData-Array",
    name_hash: 4072290255,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SharedLockObserverEntityData {
    pub _glacier_base: SharedLockBaseEntityData,
}

pub trait SharedLockObserverEntityDataTrait: SharedLockBaseEntityDataTrait {
}

impl SharedLockObserverEntityDataTrait for SharedLockObserverEntityData {
}

impl SharedLockBaseEntityDataTrait for SharedLockObserverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn asset(&self) -> &Option<LockedTypeObject /* SharedLockAsset */> {
        self._glacier_base.asset()
    }
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* SharedLockAsset */> {
        self._glacier_base.asset_mut()
    }
}

impl super::entity::EntityDataTrait for SharedLockObserverEntityData {
}

impl super::entity::GameObjectDataTrait for SharedLockObserverEntityData {
}

impl super::core::DataBusPeerTrait for SharedLockObserverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SharedLockObserverEntityData {
}

impl super::core::DataContainerTrait for SharedLockObserverEntityData {
}

pub static SHAREDLOCKOBSERVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockObserverEntityData",
    name_hash: 286299364,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHAREDLOCKBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SharedLockObserverEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockObserverEntityData as Default>::default())),
            create_boxed: || Box::new(<SharedLockObserverEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHAREDLOCKOBSERVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedLockObserverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKOBSERVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKOBSERVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockObserverEntityData-Array",
    name_hash: 2476136656,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockObserverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SharedLockControllerEntityData {
    pub _glacier_base: SharedLockBaseEntityData,
}

pub trait SharedLockControllerEntityDataTrait: SharedLockBaseEntityDataTrait {
}

impl SharedLockControllerEntityDataTrait for SharedLockControllerEntityData {
}

impl SharedLockBaseEntityDataTrait for SharedLockControllerEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn asset(&self) -> &Option<LockedTypeObject /* SharedLockAsset */> {
        self._glacier_base.asset()
    }
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* SharedLockAsset */> {
        self._glacier_base.asset_mut()
    }
}

impl super::entity::EntityDataTrait for SharedLockControllerEntityData {
}

impl super::entity::GameObjectDataTrait for SharedLockControllerEntityData {
}

impl super::core::DataBusPeerTrait for SharedLockControllerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SharedLockControllerEntityData {
}

impl super::core::DataContainerTrait for SharedLockControllerEntityData {
}

pub static SHAREDLOCKCONTROLLERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockControllerEntityData",
    name_hash: 1495494288,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHAREDLOCKBASEENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SharedLockControllerEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockControllerEntityData as Default>::default())),
            create_boxed: || Box::new(<SharedLockControllerEntityData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHAREDLOCKCONTROLLERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedLockControllerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKCONTROLLERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKCONTROLLERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockControllerEntityData-Array",
    name_hash: 2664283300,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockControllerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SharedLockBaseEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub asset: Option<LockedTypeObject /* SharedLockAsset */>,
}

pub trait SharedLockBaseEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn asset(&self) -> &Option<LockedTypeObject /* SharedLockAsset */>;
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* SharedLockAsset */>;
}

impl SharedLockBaseEntityDataTrait for SharedLockBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn asset(&self) -> &Option<LockedTypeObject /* SharedLockAsset */> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<LockedTypeObject /* SharedLockAsset */> {
        &mut self.asset
    }
}

impl super::entity::EntityDataTrait for SharedLockBaseEntityData {
}

impl super::entity::GameObjectDataTrait for SharedLockBaseEntityData {
}

impl super::core::DataBusPeerTrait for SharedLockBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SharedLockBaseEntityData {
}

impl super::core::DataContainerTrait for SharedLockBaseEntityData {
}

pub static SHAREDLOCKBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockBaseEntityData",
    name_hash: 1018702969,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(SharedLockBaseEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockBaseEntityData as Default>::default())),
            create_boxed: || Box::new(<SharedLockBaseEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SharedLockBaseEntityData, realm),
            },
            FieldInfoData {
                name: "Asset",
                name_hash: 205976053,
                flags: MemberInfoFlags::new(0),
                field_type: "SharedLockAsset",
                rust_offset: offset_of!(SharedLockBaseEntityData, asset),
            },
        ],
    }),
    array_type: Some(SHAREDLOCKBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SharedLockBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockBaseEntityData-Array",
    name_hash: 2402290509,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct SharedLockAsset {
    pub _glacier_base: super::core::Asset,
    pub realm: super::core::Realm,
}

pub trait SharedLockAssetTrait: super::core::AssetTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl SharedLockAssetTrait for SharedLockAsset {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::core::AssetTrait for SharedLockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SharedLockAsset {
}

pub static SHAREDLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockAsset",
    name_hash: 3963825655,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        super_class_offset: offset_of!(SharedLockAsset, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockAsset as Default>::default())),
            create_boxed: || Box::new(<SharedLockAsset as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                name_hash: 229961746,
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SharedLockAsset, realm),
            },
        ],
    }),
    array_type: Some(SHAREDLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedLockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockAsset-Array",
    name_hash: 1791145923,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct MorphComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub mesh_blueprint: Option<LockedTypeObject /* super::entity::ObjectBlueprint */>,
}

pub trait MorphComponentDataTrait: super::entity::GameComponentDataTrait {
    fn mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
    fn mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */>;
}

impl MorphComponentDataTrait for MorphComponentData {
    fn mesh_blueprint(&self) -> &Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &self.mesh_blueprint
    }
    fn mesh_blueprint_mut(&mut self) -> &mut Option<LockedTypeObject /* super::entity::ObjectBlueprint */> {
        &mut self.mesh_blueprint
    }
}

impl super::entity::GameComponentDataTrait for MorphComponentData {
}

impl super::entity::ComponentDataTrait for MorphComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for MorphComponentData {
}

impl super::core::DataBusPeerTrait for MorphComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MorphComponentData {
}

impl super::core::DataContainerTrait for MorphComponentData {
}

pub static MORPHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MorphComponentData",
    name_hash: 3739345330,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(MorphComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MorphComponentData as Default>::default())),
            create_boxed: || Box::new(<MorphComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "MeshBlueprint",
                name_hash: 1662348825,
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(MorphComponentData, mesh_blueprint),
            },
        ],
    }),
    array_type: Some(MORPHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MorphComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MORPHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MORPHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MorphComponentData-Array",
    name_hash: 288245766,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MorphComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BreakableModelHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait BreakableModelHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl BreakableModelHealthComponentDataTrait for BreakableModelHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for BreakableModelHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for BreakableModelHealthComponentData {
}

impl super::entity::ComponentDataTrait for BreakableModelHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BreakableModelHealthComponentData {
}

impl super::core::DataBusPeerTrait for BreakableModelHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakableModelHealthComponentData {
}

impl super::core::DataContainerTrait for BreakableModelHealthComponentData {
}

pub static BREAKABLEMODELHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelHealthComponentData",
    name_hash: 2729209500,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(BreakableModelHealthComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelHealthComponentData as Default>::default())),
            create_boxed: || Box::new(<BreakableModelHealthComponentData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(BREAKABLEMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakableModelHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLEMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelHealthComponentData-Array",
    name_hash: 2396374696,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableModelHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BreakableModelPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
    pub breakable_bodies: Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>>,
}

pub trait BreakableModelPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
    fn breakable_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>>;
    fn breakable_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>>;
}

impl BreakableModelPhysicsComponentDataTrait for BreakableModelPhysicsComponentData {
    fn breakable_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        &self.breakable_bodies
    }
    fn breakable_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        &mut self.breakable_bodies
    }
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for BreakableModelPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::effect_base::EffectParameter */>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for BreakableModelPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsBodyData */>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::PhysicsConstraintData */>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::physics::PhysicsPartData */> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for BreakableModelPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BreakableModelPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for BreakableModelPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakableModelPhysicsComponentData {
}

impl super::core::DataContainerTrait for BreakableModelPhysicsComponentData {
}

pub static BREAKABLEMODELPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelPhysicsComponentData",
    name_hash: 295577227,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(BreakableModelPhysicsComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelPhysicsComponentData as Default>::default())),
            create_boxed: || Box::new(<BreakableModelPhysicsComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BreakableBodies",
                name_hash: 27145702,
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsBodyData-Array",
                rust_offset: offset_of!(BreakableModelPhysicsComponentData, breakable_bodies),
            },
        ],
    }),
    array_type: Some(BREAKABLEMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakableModelPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLEMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelPhysicsComponentData-Array",
    name_hash: 4016198975,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableModelPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage {
}

pub trait BreakableModelToComponentsSpawnPartObjectsOnCollapseMessageTrait: TypeObject {
}

impl BreakableModelToComponentsSpawnPartObjectsOnCollapseMessageTrait for BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage {
}

pub static BREAKABLEMODELTOCOMPONENTSSPAWNPARTOBJECTSONCOLLAPSEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage",
    name_hash: 366595059,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage as Default>::default())),
            create_boxed: || Box::new(<BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELTOCOMPONENTSSPAWNPARTOBJECTSONCOLLAPSEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct BreakableModelToComponentsCollapseMessage {
}

pub trait BreakableModelToComponentsCollapseMessageTrait: TypeObject {
}

impl BreakableModelToComponentsCollapseMessageTrait for BreakableModelToComponentsCollapseMessage {
}

pub static BREAKABLEMODELTOCOMPONENTSCOLLAPSEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelToComponentsCollapseMessage",
    name_hash: 2515223800,
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelToComponentsCollapseMessage as Default>::default())),
            create_boxed: || Box::new(<BreakableModelToComponentsCollapseMessage as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for BreakableModelToComponentsCollapseMessage {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELTOCOMPONENTSCOLLAPSEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Debug, Default)]
#[repr(C)]
pub struct BreakableModelEntityData {
    pub _glacier_base: super::physics::GamePhysicsEntityData,
    pub decal_volume_shader: Option<LockedTypeObject /* super::render_base::SurfaceShaderBaseAsset */>,
    pub decal_volume_scale_factor: f32,
    pub mesh: Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>,
    pub edge_models_data: Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */>,
}

pub trait BreakableModelEntityDataTrait: super::physics::GamePhysicsEntityDataTrait {
    fn decal_volume_shader(&self) -> &Option<LockedTypeObject /* super::render_base::SurfaceShaderBaseAsset */>;
    fn decal_volume_shader_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::SurfaceShaderBaseAsset */>;
    fn decal_volume_scale_factor(&self) -> &f32;
    fn decal_volume_scale_factor_mut(&mut self) -> &mut f32;
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */>;
    fn edge_models_data(&self) -> &Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */>;
    fn edge_models_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */>;
}

impl BreakableModelEntityDataTrait for BreakableModelEntityData {
    fn decal_volume_shader(&self) -> &Option<LockedTypeObject /* super::render_base::SurfaceShaderBaseAsset */> {
        &self.decal_volume_shader
    }
    fn decal_volume_shader_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::SurfaceShaderBaseAsset */> {
        &mut self.decal_volume_shader
    }
    fn decal_volume_scale_factor(&self) -> &f32 {
        &self.decal_volume_scale_factor
    }
    fn decal_volume_scale_factor_mut(&mut self) -> &mut f32 {
        &mut self.decal_volume_scale_factor
    }
    fn mesh(&self) -> &Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<LockedTypeObject /* super::render_base::MeshBaseAsset */> {
        &mut self.mesh
    }
    fn edge_models_data(&self) -> &Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */> {
        &self.edge_models_data
    }
    fn edge_models_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */> {
        &mut self.edge_models_data
    }
}

impl super::physics::GamePhysicsEntityDataTrait for BreakableModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for BreakableModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for BreakableModelEntityData {
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<BoxedTypeObject /* super::core::AxisAlignedBox */> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for BreakableModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for BreakableModelEntityData {
}

impl super::entity::GameObjectDataTrait for BreakableModelEntityData {
}

impl super::core::DataBusPeerTrait for BreakableModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakableModelEntityData {
}

impl super::core::DataContainerTrait for BreakableModelEntityData {
}

pub static BREAKABLEMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelEntityData",
    name_hash: 1964384148,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::GAMEPHYSICSENTITYDATA_TYPE_INFO),
        super_class_offset: offset_of!(BreakableModelEntityData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelEntityData as Default>::default())),
            create_boxed: || Box::new(<BreakableModelEntityData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "DecalVolumeShader",
                name_hash: 1251902379,
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderBaseAsset",
                rust_offset: offset_of!(BreakableModelEntityData, decal_volume_shader),
            },
            FieldInfoData {
                name: "DecalVolumeScaleFactor",
                name_hash: 3086740471,
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BreakableModelEntityData, decal_volume_scale_factor),
            },
            FieldInfoData {
                name: "Mesh",
                name_hash: 2088783990,
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(BreakableModelEntityData, mesh),
            },
            FieldInfoData {
                name: "EdgeModelsData",
                name_hash: 3558352074,
                flags: MemberInfoFlags::new(0),
                field_type: "EdgeModelsBaseData",
                rust_offset: offset_of!(BreakableModelEntityData, edge_models_data),
            },
        ],
    }),
    array_type: Some(BREAKABLEMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakableModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLEMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelEntityData-Array",
    name_hash: 2374032288,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct EdgeModelComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub edge_models_data: Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */>,
    pub rigid_bodies: Vec<Option<LockedTypeObject /* super::physics::RigidBodyData */>>,
}

pub trait EdgeModelComponentDataTrait: super::entity::GameComponentDataTrait {
    fn edge_models_data(&self) -> &Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */>;
    fn edge_models_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */>;
    fn rigid_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::RigidBodyData */>>;
    fn rigid_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::RigidBodyData */>>;
}

impl EdgeModelComponentDataTrait for EdgeModelComponentData {
    fn edge_models_data(&self) -> &Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */> {
        &self.edge_models_data
    }
    fn edge_models_data_mut(&mut self) -> &mut Option<LockedTypeObject /* super::world_base::EdgeModelsBaseData */> {
        &mut self.edge_models_data
    }
    fn rigid_bodies(&self) -> &Vec<Option<LockedTypeObject /* super::physics::RigidBodyData */>> {
        &self.rigid_bodies
    }
    fn rigid_bodies_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::physics::RigidBodyData */>> {
        &mut self.rigid_bodies
    }
}

impl super::entity::GameComponentDataTrait for EdgeModelComponentData {
}

impl super::entity::ComponentDataTrait for EdgeModelComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EdgeModelComponentData {
}

impl super::core::DataBusPeerTrait for EdgeModelComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EdgeModelComponentData {
}

impl super::core::DataContainerTrait for EdgeModelComponentData {
}

pub static EDGEMODELCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EdgeModelComponentData",
    name_hash: 952298326,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(EdgeModelComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EdgeModelComponentData as Default>::default())),
            create_boxed: || Box::new(<EdgeModelComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "EdgeModelsData",
                name_hash: 3558352074,
                flags: MemberInfoFlags::new(0),
                field_type: "EdgeModelsBaseData",
                rust_offset: offset_of!(EdgeModelComponentData, edge_models_data),
            },
            FieldInfoData {
                name: "RigidBodies",
                name_hash: 3015855522,
                flags: MemberInfoFlags::new(144),
                field_type: "RigidBodyData-Array",
                rust_offset: offset_of!(EdgeModelComponentData, rigid_bodies),
            },
        ],
    }),
    array_type: Some(EDGEMODELCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EdgeModelComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        EDGEMODELCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EDGEMODELCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EdgeModelComponentData-Array",
    name_hash: 788787426,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EdgeModelComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BreakableControllerComponentData {
    pub _glacier_base: super::physics::DestructionControllerComponentData,
    pub breakable_part_count: u32,
    pub network_id_count: u32,
}

pub trait BreakableControllerComponentDataTrait: super::physics::DestructionControllerComponentDataTrait {
    fn breakable_part_count(&self) -> &u32;
    fn breakable_part_count_mut(&mut self) -> &mut u32;
    fn network_id_count(&self) -> &u32;
    fn network_id_count_mut(&mut self) -> &mut u32;
}

impl BreakableControllerComponentDataTrait for BreakableControllerComponentData {
    fn breakable_part_count(&self) -> &u32 {
        &self.breakable_part_count
    }
    fn breakable_part_count_mut(&mut self) -> &mut u32 {
        &mut self.breakable_part_count
    }
    fn network_id_count(&self) -> &u32 {
        &self.network_id_count
    }
    fn network_id_count_mut(&mut self) -> &mut u32 {
        &mut self.network_id_count
    }
}

impl super::physics::DestructionControllerComponentDataTrait for BreakableControllerComponentData {
    fn structural_integrity_analyzer_enable(&self) -> &bool {
        self._glacier_base.structural_integrity_analyzer_enable()
    }
    fn structural_integrity_analyzer_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.structural_integrity_analyzer_enable_mut()
    }
    fn breaking_length(&self) -> &f32 {
        self._glacier_base.breaking_length()
    }
    fn breaking_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.breaking_length_mut()
    }
    fn fracture_position(&self) -> &f32 {
        self._glacier_base.fracture_position()
    }
    fn fracture_position_mut(&mut self) -> &mut f32 {
        self._glacier_base.fracture_position_mut()
    }
    fn destruction_radius(&self) -> &f32 {
        self._glacier_base.destruction_radius()
    }
    fn destruction_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.destruction_radius_mut()
    }
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn refine_radius(&self) -> &f32 {
        self._glacier_base.refine_radius()
    }
    fn refine_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.refine_radius_mut()
    }
}

impl super::entity::GameComponentDataTrait for BreakableControllerComponentData {
}

impl super::entity::ComponentDataTrait for BreakableControllerComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BreakableControllerComponentData {
}

impl super::core::DataBusPeerTrait for BreakableControllerComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakableControllerComponentData {
}

impl super::core::DataContainerTrait for BreakableControllerComponentData {
}

pub static BREAKABLECONTROLLERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentData",
    name_hash: 3494296147,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::DESTRUCTIONCONTROLLERCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(BreakableControllerComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableControllerComponentData as Default>::default())),
            create_boxed: || Box::new(<BreakableControllerComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "BreakablePartCount",
                name_hash: 3849422468,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BreakableControllerComponentData, breakable_part_count),
            },
            FieldInfoData {
                name: "NetworkIdCount",
                name_hash: 1234693717,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BreakableControllerComponentData, network_id_count),
            },
        ],
    }),
    array_type: Some(BREAKABLECONTROLLERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakableControllerComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLECONTROLLERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLECONTROLLERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentData-Array",
    name_hash: 4234012007,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableControllerComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BreakableControllerComponentNetworkIdMultiplier {
    #[default]
    BreakableControllerComponentNetworkIdMultiplier_HidePartObjects = 0,
    BreakableControllerComponentNetworkIdMultiplier_DisablePart = 1,
    BreakableControllerComponentNetworkIdMultiplier_PartCount = 2,
}

pub static BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentNetworkIdMultiplier",
    name_hash: 628046363,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BreakableControllerComponentNetworkIdMultiplier {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentNetworkIdMultiplier-Array",
    name_hash: 3139883183,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableControllerComponentNetworkIdMultiplier"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BreakableControllerComponentNetworkId {
    #[default]
    BreakableControllerComponentNetworkId_Collapsed = 0,
    BreakableControllerComponentNetworkId_SpawnPartObjectsOnCollapse = 1,
    BreakableControllerComponentNetworkId_ExtraPartCount = 2,
}

pub static BREAKABLECONTROLLERCOMPONENTNETWORKID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentNetworkId",
    name_hash: 2186806864,
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BREAKABLECONTROLLERCOMPONENTNETWORKID_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BreakableControllerComponentNetworkId {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLECONTROLLERCOMPONENTNETWORKID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BREAKABLECONTROLLERCOMPONENTNETWORKID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentNetworkId-Array",
    name_hash: 1028203748,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableControllerComponentNetworkId"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct BreakablePartComponentData {
    pub _glacier_base: super::physics::DestructionPartComponentData,
    pub health_percentage: u32,
    pub collapsable: bool,
    pub destroy_nearby_static_entities: bool,
}

pub trait BreakablePartComponentDataTrait: super::physics::DestructionPartComponentDataTrait {
    fn health_percentage(&self) -> &u32;
    fn health_percentage_mut(&mut self) -> &mut u32;
    fn collapsable(&self) -> &bool;
    fn collapsable_mut(&mut self) -> &mut bool;
    fn destroy_nearby_static_entities(&self) -> &bool;
    fn destroy_nearby_static_entities_mut(&mut self) -> &mut bool;
}

impl BreakablePartComponentDataTrait for BreakablePartComponentData {
    fn health_percentage(&self) -> &u32 {
        &self.health_percentage
    }
    fn health_percentage_mut(&mut self) -> &mut u32 {
        &mut self.health_percentage
    }
    fn collapsable(&self) -> &bool {
        &self.collapsable
    }
    fn collapsable_mut(&mut self) -> &mut bool {
        &mut self.collapsable
    }
    fn destroy_nearby_static_entities(&self) -> &bool {
        &self.destroy_nearby_static_entities
    }
    fn destroy_nearby_static_entities_mut(&mut self) -> &mut bool {
        &mut self.destroy_nearby_static_entities
    }
}

impl super::physics::DestructionPartComponentDataTrait for BreakablePartComponentData {
    fn objects(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.objects_mut()
    }
    fn part_index(&self) -> &u32 {
        self._glacier_base.part_index()
    }
    fn part_index_mut(&mut self) -> &mut u32 {
        self._glacier_base.part_index_mut()
    }
    fn fixed(&self) -> &bool {
        self._glacier_base.fixed()
    }
    fn fixed_mut(&mut self) -> &mut bool {
        self._glacier_base.fixed_mut()
    }
    fn fragile(&self) -> &bool {
        self._glacier_base.fragile()
    }
    fn fragile_mut(&mut self) -> &mut bool {
        self._glacier_base.fragile_mut()
    }
}

impl super::entity::GameComponentDataTrait for BreakablePartComponentData {
}

impl super::entity::ComponentDataTrait for BreakablePartComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<LockedTypeObject /* super::entity::GameObjectData */>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BreakablePartComponentData {
}

impl super::core::DataBusPeerTrait for BreakablePartComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakablePartComponentData {
}

impl super::core::DataContainerTrait for BreakablePartComponentData {
}

pub static BREAKABLEPARTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakablePartComponentData",
    name_hash: 21750776,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::DESTRUCTIONPARTCOMPONENTDATA_TYPE_INFO),
        super_class_offset: offset_of!(BreakablePartComponentData, _glacier_base),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakablePartComponentData as Default>::default())),
            create_boxed: || Box::new(<BreakablePartComponentData as Default>::default()),
        },
        fields: &[
            FieldInfoData {
                name: "HealthPercentage",
                name_hash: 3168756705,
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BreakablePartComponentData, health_percentage),
            },
            FieldInfoData {
                name: "Collapsable",
                name_hash: 3767665825,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BreakablePartComponentData, collapsable),
            },
            FieldInfoData {
                name: "DestroyNearbyStaticEntities",
                name_hash: 986094273,
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BreakablePartComponentData, destroy_nearby_static_entities),
            },
        ],
    }),
    array_type: Some(BREAKABLEPARTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakablePartComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEPARTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLEPARTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakablePartComponentData-Array",
    name_hash: 2913197516,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakablePartComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Debug, Default)]
#[repr(C)]
pub struct RawFileData {
}

pub trait RawFileDataTrait: TypeObject {
}

impl RawFileDataTrait for RawFileData {
}

pub static RAWFILEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileData",
    name_hash: 4173038295,
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        super_class_offset: 0,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RawFileData as Default>::default())),
            create_boxed: || Box::new(<RawFileData as Default>::default()),
        },
        fields: &[
        ],
    }),
    array_type: Some(RAWFILEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RawFileData {
    fn type_info(&self) -> &'static TypeInfo {
        RAWFILEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RAWFILEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileData-Array",
    name_hash: 3383147491,
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RawFileData"),
    array_type: None,
    alignment: 8,
};


