use std::{mem::offset_of, any::Any, option::Option, sync::Arc};
use tokio::sync::Mutex;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData, TypeObject, TypeFunctions,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_game_shared_types(registry: &mut TypeRegistry) {
    registry.register_type(FADETRACKDATA_TYPE_INFO);
    registry.register_type(FADETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(FADETRACKKEYFRAME_TYPE_INFO);
    registry.register_type(FADETRACKKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(FADETRACKKEYFRAMETYPE_TYPE_INFO);
    registry.register_type(FADETRACKKEYFRAMETYPE_ARRAY_TYPE_INFO);
    registry.register_type(TRACKBUILDERDATA_TYPE_INFO);
    registry.register_type(TRACKBUILDERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ACTORTOBLUEPRINTGUIDROW_TYPE_INFO);
    registry.register_type(ACTORTOBLUEPRINTGUIDROW_ARRAY_TYPE_INFO);
    registry.register_type(CUTSCENESAVEDSETTINGSDATA_TYPE_INFO);
    registry.register_type(CUTSCENESAVEDSETTINGSDATA_ARRAY_TYPE_INFO);
    registry.register_type(IMPORTTARGET_TYPE_INFO);
    registry.register_type(IMPORTTARGET_ARRAY_TYPE_INFO);
    registry.register_type(IMPORTERSOURCE_TYPE_INFO);
    registry.register_type(IMPORTERSOURCE_ARRAY_TYPE_INFO);
    registry.register_type(CUTSCENESAVEDSETTINGS_PATHTYPE_TYPE_INFO);
    registry.register_type(CUTSCENESAVEDSETTINGS_PATHTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CUTSCENEQUALITYLEVEL_TYPE_INFO);
    registry.register_type(CUTSCENEQUALITYLEVEL_ARRAY_TYPE_INFO);
    registry.register_type(CUTSCENEACTORTYPE_TYPE_INFO);
    registry.register_type(CUTSCENEACTORTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CAMERATRACKDATA_TYPE_INFO);
    registry.register_type(CAMERATRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERATRACKBASEDATA_TYPE_INFO);
    registry.register_type(CAMERATRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERALOOKATLAYERDATA_TYPE_INFO);
    registry.register_type(CAMERALOOKATLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAFOCUSTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERAFOCUSTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADOFTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERADOFTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERADIRECTORTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORTRACKBASEDATA_TYPE_INFO);
    registry.register_type(CAMERADIRECTORTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORKEYFRAME_TYPE_INFO);
    registry.register_type(CAMERADIRECTORKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACUTBEHAVIOR_TYPE_INFO);
    registry.register_type(CAMERACUTBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORPROXYTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERADIRECTORPROXYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERADIRECTORPROXYKEYFRAME_TYPE_INFO);
    registry.register_type(CAMERADIRECTORPROXYKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACUTVISIBILITYTRACKDATA_TYPE_INFO);
    registry.register_type(CAMERACUTVISIBILITYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACUTVISIBILITYKEYFRAME_TYPE_INFO);
    registry.register_type(CAMERACUTVISIBILITYKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAATTACHTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(CAMERAATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ATTACHTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(ATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTTRAJECTORYTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(ANTTRAJECTORYTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTSLOTTRACKDATA_TYPE_INFO);
    registry.register_type(ANTSLOTTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTSIGNALTRACKDATA_TYPE_INFO);
    registry.register_type(ANTSIGNALTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTENUMTRACKDATA_TYPE_INFO);
    registry.register_type(ANTENUMTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTENUMKEYFRAME_TYPE_INFO);
    registry.register_type(ANTENUMKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(ANTVEC3TRACKDATA_TYPE_INFO);
    registry.register_type(ANTVEC3TRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTINTTRACKDATA_TYPE_INFO);
    registry.register_type(ANTINTTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTFLOATTRACKDATA_TYPE_INFO);
    registry.register_type(ANTFLOATTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTBOOLTRACKDATA_TYPE_INFO);
    registry.register_type(ANTBOOLTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTEVALTRACKDATA_TYPE_INFO);
    registry.register_type(ANTEVALTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTCONTROLTRACKDATA_TYPE_INFO);
    registry.register_type(ANTCONTROLTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TELEPORTKEYFRAME_TYPE_INFO);
    registry.register_type(TELEPORTKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(ANTBONETRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(ANTBONETRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTBONETRACKDATA_TYPE_INFO);
    registry.register_type(ANTBONETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTBONEANIMATIONTRACKDATA_TYPE_INFO);
    registry.register_type(ANTBONEANIMATIONTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTANIMATABLECAMERATRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(ANTANIMATABLECAMERATRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTANIMATABLECAMERATRACKDATA_TYPE_INFO);
    registry.register_type(ANTANIMATABLECAMERATRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPOSETRACKDATA_TYPE_INFO);
    registry.register_type(ANIMATIONPOSETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPOSELAYERROOTDATA_TYPE_INFO);
    registry.register_type(ANIMATIONPOSELAYERROOTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPOSELAYERDATA_TYPE_INFO);
    registry.register_type(ANIMATIONPOSELAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPOSEKEYFRAME_TYPE_INFO);
    registry.register_type(ANIMATIONPOSEKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(SQT_TYPE_INFO);
    registry.register_type(SQT_ARRAY_TYPE_INFO);
    registry.register_type(VEC3VALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC3VALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEC3RECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(VEC3RECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALIDATETRACKDATA_TYPE_INFO);
    registry.register_type(VALIDATETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO);
    registry.register_type(VALIDATEPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALIDATELINKTRACKBASEDATA_TYPE_INFO);
    registry.register_type(VALIDATELINKTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMVALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(TRANSFORMVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMRECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(TRANSFORMRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDTRACKDATA_TYPE_INFO);
    registry.register_type(RECORDTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRIMMEDRECORDINGRANGE_TYPE_INFO);
    registry.register_type(TRIMMEDRECORDINGRANGE_ARRAY_TYPE_INFO);
    registry.register_type(TRIMMINGRANGEKEYFRAME_TYPE_INFO);
    registry.register_type(TRIMMINGRANGEKEYFRAME_ARRAY_TYPE_INFO);
    registry.register_type(RECORDLINKTRACKBASEDATA_TYPE_INFO);
    registry.register_type(RECORDLINKTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO);
    registry.register_type(RECORDPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERPOSEVALIDATETRACKDATA_TYPE_INFO);
    registry.register_type(CHARACTERPOSEVALIDATETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(POSEVALIDATETRACKDATA_TYPE_INFO);
    registry.register_type(POSEVALIDATETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERPOSERECORDTRACKDATA_TYPE_INFO);
    registry.register_type(CHARACTERPOSERECORDTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(POSERECORDTRACKDATA_TYPE_INFO);
    registry.register_type(POSERECORDTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTVALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(INTVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTRECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(INTRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLOATVALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(FLOATVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEANTGAMESTATEENTITYDATA_TYPE_INFO);
    registry.register_type(WRITEANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(READANTGAMESTATEENTITYDATA_TYPE_INFO);
    registry.register_type(READANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVECTOR3TRANSFORMGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEVECTOR3GAMESTATE_TYPE_INFO);
    registry.register_type(WRITEVECTOR3GAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEQUATERNIONGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEQUATERNIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEBOOLGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEBOOLGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEINTGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEINTGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEFLOATGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEFLOATGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEENUMERATIONGAMESTATE_TYPE_INFO);
    registry.register_type(WRITEENUMERATIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO);
    registry.register_type(READVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READQUATERNIONGAMESTATE_TYPE_INFO);
    registry.register_type(READQUATERNIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READVECTOR3TRANSFORMGAMESTATE_TYPE_INFO);
    registry.register_type(READVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READVECTOR3GAMESTATE_TYPE_INFO);
    registry.register_type(READVECTOR3GAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READBOOLGAMESTATE_TYPE_INFO);
    registry.register_type(READBOOLGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READINTGAMESTATE_TYPE_INFO);
    registry.register_type(READINTGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READFLOATGAMESTATE_TYPE_INFO);
    registry.register_type(READFLOATGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(READENUMERATIONGAMESTATE_TYPE_INFO);
    registry.register_type(READENUMERATIONGAMESTATE_ARRAY_TYPE_INFO);
    registry.register_type(WRITEANTGAMESTATEDATA_TYPE_INFO);
    registry.register_type(WRITEANTGAMESTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(READANTGAMESTATEDATA_TYPE_INFO);
    registry.register_type(READANTGAMESTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTGAMESTATEDATA_TYPE_INFO);
    registry.register_type(ANTGAMESTATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(ANTEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTEVENTDATA_TYPE_INFO);
    registry.register_type(ANTEVENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONPROXYBANKDATA_TYPE_INFO);
    registry.register_type(ANIMATIONPROXYBANKDATA_ARRAY_TYPE_INFO);
    registry.register_type(BONEFAKEPHYSICSDATA_TYPE_INFO);
    registry.register_type(BONEFAKEPHYSICSDATA_ARRAY_TYPE_INFO);
    registry.register_type(ADDFAKECOLLISIONENTITYDATA_TYPE_INFO);
    registry.register_type(ADDFAKECOLLISIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDVEHICLETRACKDATA_TYPE_INFO);
    registry.register_type(RECORDVEHICLETRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDROOTTRANSFORMTRACKDATA_TYPE_INFO);
    registry.register_type(RECORDROOTTRANSFORMTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDENTRYINPUTTRACKDATA_TYPE_INFO);
    registry.register_type(RECORDENTRYINPUTTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDENTRYINPUTTYPE_TYPE_INFO);
    registry.register_type(RECORDENTRYINPUTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRACKDATA_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRACKUPDATEINFO_TYPE_INFO);
    registry.register_type(PHYSICALCAMERATRACKUPDATEINFO_ARRAY_TYPE_INFO);
    registry.register_type(PATHTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(PATHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(GROUNDATTACHTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(GROUNDATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(GROUNDATTACHMETHOD_TYPE_INFO);
    registry.register_type(GROUNDATTACHMETHOD_ARRAY_TYPE_INFO);
    registry.register_type(GAMEPLAYCAMERATRACKDATA_TYPE_INFO);
    registry.register_type(GAMEPLAYCAMERATRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAWFILEDATAASSET_TYPE_INFO);
    registry.register_type(RAWFILEDATAASSET_ARRAY_TYPE_INFO);
    registry.register_type(RAWFILERESOURCEASSET_TYPE_INFO);
    registry.register_type(RAWFILERESOURCEASSET_ARRAY_TYPE_INFO);
    registry.register_type(RAWFILEASSET_TYPE_INFO);
    registry.register_type(RAWFILEASSET_ARRAY_TYPE_INFO);
    registry.register_type(PLAYANIMATIONVISUALIZERENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYANIMATIONVISUALIZERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENANIMATIONENTITYBINDING_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENANIMATIONENTITYBINDING_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCESTATGROUP_TYPE_INFO);
    registry.register_type(PERSISTENCESTATGROUP_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCESTATTABLE_TYPE_INFO);
    registry.register_type(PERSISTENCESTATTABLE_ARRAY_TYPE_INFO);
    registry.register_type(ABSTRACTPERSISTENCEDATA_TYPE_INFO);
    registry.register_type(ABSTRACTPERSISTENCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEHISTORYTYPE_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEHISTORYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ABSTRACTLEADERBOARDDATA_TYPE_INFO);
    registry.register_type(ABSTRACTLEADERBOARDDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCEGAMEDATA_TYPE_INFO);
    registry.register_type(PERSISTENCEGAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCEDATA_TYPE_INFO);
    registry.register_type(RICHPRESENCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCEPROPERTY_TYPE_INFO);
    registry.register_type(RICHPRESENCEPROPERTY_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCEPROPERTYTYPE_TYPE_INFO);
    registry.register_type(RICHPRESENCEPROPERTYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTSETTING_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTSETTING_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXT_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXT_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTVALUEWITHKEY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTVALUEWITHKEY_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTVALUE_TYPE_INFO);
    registry.register_type(RICHPRESENCECONTEXTVALUE_ARRAY_TYPE_INFO);
    registry.register_type(RICHPRESENCEPRESENCESTRING_TYPE_INFO);
    registry.register_type(RICHPRESENCEPRESENCESTRING_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCEDATA_TYPE_INFO);
    registry.register_type(PERSISTENCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCECONSUMABLEMAPPING_TYPE_INFO);
    registry.register_type(PERSISTENCECONSUMABLEMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCEGAMETYPE_TYPE_INFO);
    registry.register_type(PERSISTENCEGAMETYPE_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENCERETENTIONPOLICY_TYPE_INFO);
    registry.register_type(PERSISTENCERETENTIONPOLICY_ARRAY_TYPE_INFO);
    registry.register_type(STATPERIOD_TYPE_INFO);
    registry.register_type(STATPERIOD_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATESTATREF_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATESTATREF_ARRAY_TYPE_INFO);
    registry.register_type(ABSTRACTPERSISTENTSTATREF_TYPE_INFO);
    registry.register_type(ABSTRACTPERSISTENTSTATREF_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATE_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATE_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATEDATA_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEDATAKIND_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEDATAKIND_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEDATATYPE_TYPE_INFO);
    registry.register_type(PERSISTENTVALUEDATATYPE_ARRAY_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETYPE_TYPE_INFO);
    registry.register_type(PERSISTENTVALUETYPE_ARRAY_TYPE_INFO);
    registry.register_type(CONSUMABLEGROUP_TYPE_INFO);
    registry.register_type(CONSUMABLEGROUP_ARRAY_TYPE_INFO);
    registry.register_type(PA2TARGETCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PA2TARGETCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PA2TARGETPROPERTIES_TYPE_INFO);
    registry.register_type(PA2TARGETPROPERTIES_ARRAY_TYPE_INFO);
    registry.register_type(PA2BONELIST_TYPE_INFO);
    registry.register_type(PA2BONELIST_ARRAY_TYPE_INFO);
    registry.register_type(PA2BONE_TYPE_INFO);
    registry.register_type(PA2BONE_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTHIGHLIGHTENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTHIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERINVEHICLESCENARIOENTITYDATA_TYPE_INFO);
    registry.register_type(CHARACTERINVEHICLESCENARIOENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTIPLEACTORSCENARIOENTITYDATA_TYPE_INFO);
    registry.register_type(MULTIPLEACTORSCENARIOENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BILLBOARDTRANSFORMENTITYDATA_TYPE_INFO);
    registry.register_type(BILLBOARDTRANSFORMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BILLBOARDTRANSFORMROTATIONAXIS_TYPE_INFO);
    registry.register_type(BILLBOARDTRANSFORMROTATIONAXIS_ARRAY_TYPE_INFO);
    registry.register_type(WATERDEPTHENTITYDATA_TYPE_INFO);
    registry.register_type(WATERDEPTHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRANSFORMSNAPTOGROUNDENTITYDATA_TYPE_INFO);
    registry.register_type(TRANSFORMSNAPTOGROUNDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESHEMITTERDYNAMICSTATE_TYPE_INFO);
    registry.register_type(MESHEMITTERDYNAMICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MESHEMITTERSTATICSTATE_TYPE_INFO);
    registry.register_type(MESHEMITTERSTATICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MESHEMITTERCONTROLENTITYDATA_TYPE_INFO);
    registry.register_type(MESHEMITTERCONTROLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLDYNAMICSTATE_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLDYNAMICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLSTATICSTATE_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLSTATICSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLENTITYDATA_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLTYPE_TYPE_INFO);
    registry.register_type(MEMORYPOOLCONTROLTYPE_ARRAY_TYPE_INFO);
    registry.register_type(PLAYVFXENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYVFXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VFXLOCATIONCONTROL_TYPE_INFO);
    registry.register_type(VFXLOCATIONCONTROL_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYEREVENTENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYEREVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERITERATORENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERITERATORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INCLUSIONSETTINGENTITYDATA_TYPE_INFO);
    registry.register_type(INCLUSIONSETTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TELEPORTENTITYDATA_TYPE_INFO);
    registry.register_type(TELEPORTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STREAMINGGATEENTITYDATA_TYPE_INFO);
    registry.register_type(STREAMINGGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZECHARACTERENTITYDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZECHARACTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZEBASEENTITYDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZEBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALPLAYERFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(LOCALPLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTAREAQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTAREAQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREAQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(AREAQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREAPROXIMITYENTITYDATA_TYPE_INFO);
    registry.register_type(AREAPROXIMITYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTRESTRICTIONENTITYDATA_TYPE_INFO);
    registry.register_type(INPUTRESTRICTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTIFSWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTIFSWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEAMFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(TEAMFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLATFORMSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(PLATFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSPLITTERENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTSPLITTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTMEMORYENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTMEMORYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPEEDEVENTGATEENTITYDATA_TYPE_INFO);
    registry.register_type(SPEEDEVENTGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCOMPAREGATEENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTCOMPAREGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTCOMPAREGATETYPE_TYPE_INFO);
    registry.register_type(EVENTCOMPAREGATETYPE_ARRAY_TYPE_INFO);
    registry.register_type(SAVEGAMELOADEDENTITYDATA_TYPE_INFO);
    registry.register_type(SAVEGAMELOADEDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SAVEENTITYDATA_TYPE_INFO);
    registry.register_type(SAVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARTENTITYDATA_TYPE_INFO);
    registry.register_type(STARTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STARTPOINTENTITYDATA_TYPE_INFO);
    registry.register_type(STARTPOINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SERVERSTARTPOINTLOADEDFROMDSUBLEVELMESSAGE_TYPE_INFO);
    registry.register_type(MAPMARKERENTITYDATA_TYPE_INFO);
    registry.register_type(MAPMARKERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MAPMARKERCOLORTYPE_TYPE_INFO);
    registry.register_type(MAPMARKERCOLORTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MAPMARKERTYPE_TYPE_INFO);
    registry.register_type(MAPMARKERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MESSAGEENTITYDATA_TYPE_INFO);
    registry.register_type(MESSAGEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESSAGEENTITYINFO_TYPE_INFO);
    registry.register_type(MESSAGEENTITYINFO_ARRAY_TYPE_INFO);
    registry.register_type(TACTICALOBJECTIVEENTITYDATA_TYPE_INFO);
    registry.register_type(TACTICALOBJECTIVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LEVELCONTROLENTITYDATA_TYPE_INFO);
    registry.register_type(LEVELCONTROLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTIVEENTITYDATA_TYPE_INFO);
    registry.register_type(OBJECTIVEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESSAGERECIEVER_TYPE_INFO);
    registry.register_type(MESSAGERECIEVER_ARRAY_TYPE_INFO);
    registry.register_type(MISSIONOBJECTIVEHUDDATA_TYPE_INFO);
    registry.register_type(MISSIONOBJECTIVEHUDDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTIVETYPE_TYPE_INFO);
    registry.register_type(OBJECTIVETYPE_ARRAY_TYPE_INFO);
    registry.register_type(FADEENTITYDATA_TYPE_INFO);
    registry.register_type(FADEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BLINKTYPE_TYPE_INFO);
    registry.register_type(BLINKTYPE_ARRAY_TYPE_INFO);
    registry.register_type(KILLALLENTITYDATA_TYPE_INFO);
    registry.register_type(KILLALLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(KILLALLPLAYERENUM_TYPE_INFO);
    registry.register_type(KILLALLPLAYERENUM_ARRAY_TYPE_INFO);
    registry.register_type(WAYPOINTTRIGGERENTITYBASEDATA_TYPE_INFO);
    registry.register_type(WAYPOINTTRIGGERENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMBATAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(COMBATAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SURROUNDINGGEOMETRYENTITYDATA_TYPE_INFO);
    registry.register_type(SURROUNDINGGEOMETRYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(UICOMBATAREAENTITYDATA_TYPE_INFO);
    registry.register_type(UICOMBATAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALLOWEDVEHICLESDATA_TYPE_INFO);
    registry.register_type(ALLOWEDVEHICLESDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEATHAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(DEATHAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HUMANPLAYERENTITYDATA_TYPE_INFO);
    registry.register_type(HUMANPLAYERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HUMANPLAYERPROXYENTITYDATA_TYPE_INFO);
    registry.register_type(HUMANPLAYERPROXYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEAMENTITYDATA_TYPE_INFO);
    registry.register_type(TEAMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEAMDATA_TYPE_INFO);
    registry.register_type(TEAMDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICAVOIDANCEENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICAVOIDANCEMODE_TYPE_INFO);
    registry.register_type(DYNAMICAVOIDANCEMODE_ARRAY_TYPE_INFO);
    registry.register_type(ANTDYNAMICAVOIDANCEBINDING_TYPE_INFO);
    registry.register_type(ANTDYNAMICAVOIDANCEBINDING_ARRAY_TYPE_INFO);
    registry.register_type(DRIVERSTATICOBJECTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DRIVERSTATICOBJECTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DRIVERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DRIVERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DRIVERSETTINGS_TYPE_INFO);
    registry.register_type(DRIVERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(REGULATEDSTEERING_TYPE_INFO);
    registry.register_type(REGULATEDSTEERING_ARRAY_TYPE_INFO);
    registry.register_type(PID_TYPE_INFO);
    registry.register_type(PID_ARRAY_TYPE_INFO);
    registry.register_type(DIFFICULTYINDEXENTITYDATA_TYPE_INFO);
    registry.register_type(DIFFICULTYINDEXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIFFICULTYDATAS_TYPE_INFO);
    registry.register_type(DIFFICULTYDATAS_ARRAY_TYPE_INFO);
    registry.register_type(DIFFICULTYDATA_TYPE_INFO);
    registry.register_type(DIFFICULTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIFFICULTY_TYPE_INFO);
    registry.register_type(DIFFICULTY_ARRAY_TYPE_INFO);
    registry.register_type(GAMEAIDIFFICULTYDATA_TYPE_INFO);
    registry.register_type(GAMEAIDIFFICULTYDATA_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKEDUNLOCK_TYPE_INFO);
    registry.register_type(NETWORKEDUNLOCK_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZECHARACTERDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZECHARACTERDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZEVISUAL_TYPE_INFO);
    registry.register_type(CUSTOMIZEVISUAL_ARRAY_TYPE_INFO);
    registry.register_type(NETWORKPLAYERSELECTEDUNLOCKASSETSMESSAGE_TYPE_INFO);
    registry.register_type(CAMOUNLOCKSELECTION_TYPE_INFO);
    registry.register_type(CAMOUNLOCKSELECTION_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECUSTOMIZATIONASSET_TYPE_INFO);
    registry.register_type(VEHICLECUSTOMIZATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERCUSTOMIZATIONASSET_TYPE_INFO);
    registry.register_type(CHARACTERCUSTOMIZATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONUNLOCKPARTS_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONUNLOCKPARTS_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONTABLE_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONTABLE_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEVISUALCUSTOMIZATIONASSET_TYPE_INFO);
    registry.register_type(VEHICLEVISUALCUSTOMIZATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(TEXTUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(TEXTUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHADERTEXTUREUNLOCKPARTCOLLECTION_TYPE_INFO);
    registry.register_type(SHADERTEXTUREUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(SHADERCOLORUNLOCKPARTCOLLECTION_TYPE_INFO);
    registry.register_type(SHADERCOLORUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO);
    registry.register_type(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZEDMESHMATERIALSDATA_TYPE_INFO);
    registry.register_type(CUSTOMIZEDMESHMATERIALSDATA_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKABLETEXTURESLICECOLLECTION_TYPE_INFO);
    registry.register_type(UNLOCKABLETEXTURESLICECOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKABLETEXTURECOLLECTION_TYPE_INFO);
    registry.register_type(UNLOCKABLETEXTURECOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKABLECOLORCOLLECTION_TYPE_INFO);
    registry.register_type(UNLOCKABLECOLORCOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKABLESHADERPARAMETERVALUECOLLECTION_TYPE_INFO);
    registry.register_type(UNLOCKABLESHADERPARAMETERVALUECOLLECTION_ARRAY_TYPE_INFO);
    registry.register_type(TEXTURESLICEUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(TEXTURESLICEUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTUREASSETUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(TEXTUREASSETUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTUREUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(TEXTUREUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEXTUREREFERENCE_TYPE_INFO);
    registry.register_type(TEXTUREREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(COLORUNLOCKPARTDATA_TYPE_INFO);
    registry.register_type(COLORUNLOCKPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLORREFERENCE_TYPE_INFO);
    registry.register_type(COLORREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(AREAIMMUNITYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AREAIMMUNITYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WATERDEPTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WATERDEPTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LADDERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(LADDERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYTOCOMPONENTSRESETMESSAGE_TYPE_INFO);
    registry.register_type(ALTERNATECAMERAVIEWDATA_TYPE_INFO);
    registry.register_type(ALTERNATECAMERAVIEWDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLLISIONEFFECTSPAWNCOMPONENTDATA_TYPE_INFO);
    registry.register_type(COLLISIONEFFECTSPAWNCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(EFFECTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(EFFECTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONCONSTANTS_TYPE_INFO);
    registry.register_type(CUSTOMIZATIONCONSTANTS_ARRAY_TYPE_INFO);
    registry.register_type(REGULARCAMERAVIEWDATA_TYPE_INFO);
    registry.register_type(REGULARCAMERAVIEWDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTSUPPRESSIONDATA_TYPE_INFO);
    registry.register_type(INPUTSUPPRESSIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONCLASSIFICATION_TYPE_INFO);
    registry.register_type(WEAPONCLASSIFICATION_ARRAY_TYPE_INFO);
    registry.register_type(BUOYANTPARTSDATA_TYPE_INFO);
    registry.register_type(BUOYANTPARTSDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUOYANTPARTS_TYPE_INFO);
    registry.register_type(BUOYANTPARTS_ARRAY_TYPE_INFO);
    registry.register_type(SKELETONCOLLISIONDATA_TYPE_INFO);
    registry.register_type(SKELETONCOLLISIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(BONECOLLISIONDATA_TYPE_INFO);
    registry.register_type(BONECOLLISIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONEDATA_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONESNAPAIMDATA_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONESNAPAIMDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONEPRIORITIESDATA_TYPE_INFO);
    registry.register_type(AIMASSISTCOLLISIONBONEPRIORITIESDATA_ARRAY_TYPE_INFO);
    registry.register_type(HITREACTIONTYPE_TYPE_INFO);
    registry.register_type(HITREACTIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(PITCHMODIFIER_TYPE_INFO);
    registry.register_type(PITCHMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(ACTIONSUPPRESSOR_TYPE_INFO);
    registry.register_type(ACTIONSUPPRESSOR_ARRAY_TYPE_INFO);
    registry.register_type(GROUPCOMPONENTDATA_TYPE_INFO);
    registry.register_type(GROUPCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLORPALETTE_TYPE_INFO);
    registry.register_type(COLORPALETTE_ARRAY_TYPE_INFO);
    registry.register_type(OBBCOLLISIONENTITYDATA_TYPE_INFO);
    registry.register_type(OBBCOLLISIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPHERECOLLISIONENTITYDATA_TYPE_INFO);
    registry.register_type(SPHERECOLLISIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTGAMESETTINGS_TYPE_INFO);
    registry.register_type(CLIENTGAMESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERTOCOMPONENTSONKILLEDMESSAGE_TYPE_INFO);
    registry.register_type(CHARACTERENTITYDATA_TYPE_INFO);
    registry.register_type(CHARACTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSOUNDDATA_TYPE_INFO);
    registry.register_type(CHARACTERSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(PERSONVIEWMODE_TYPE_INFO);
    registry.register_type(PERSONVIEWMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERENTITYDEATHTYPE_TYPE_INFO);
    registry.register_type(CHARACTERENTITYDEATHTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERENTITYHITDIRECTION_TYPE_INFO);
    registry.register_type(CHARACTERENTITYHITDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERMESHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERMESHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERCUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERTOCOMPONENTSONACTIVEVIEWCHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(CHARACTERMASTERPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERMASTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARELATIVEINPUTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CAMERARELATIVEINPUTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTINPUTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ANTINPUTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTDRIVENCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ANTDRIVENCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERCAMERACOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERCAMERACOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERCAMERAENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERCAMERAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TARGETMODE_TYPE_INFO);
    registry.register_type(TARGETMODE_ARRAY_TYPE_INFO);
    registry.register_type(TARGETCAMERAENTITYDATA_TYPE_INFO);
    registry.register_type(TARGETCAMERAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOOKATCAMERAENTITYDATA_TYPE_INFO);
    registry.register_type(LOOKATCAMERAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAENTITYDATA_TYPE_INFO);
    registry.register_type(CAMERAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAENTITYBASEDATA_TYPE_INFO);
    registry.register_type(CAMERAENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPOSUREMODE_TYPE_INFO);
    registry.register_type(EXPOSUREMODE_ARRAY_TYPE_INFO);
    registry.register_type(CAMERALENSPRESET_TYPE_INFO);
    registry.register_type(CAMERALENSPRESET_ARRAY_TYPE_INFO);
    registry.register_type(CAMERABODYPRESET_TYPE_INFO);
    registry.register_type(CAMERABODYPRESET_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECAMERADATA_TYPE_INFO);
    registry.register_type(VEHICLECAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERALEAPDATA_TYPE_INFO);
    registry.register_type(CAMERALEAPDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICCAMERADATA_TYPE_INFO);
    registry.register_type(STATICCAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(CHASECAMERADATA_TYPE_INFO);
    registry.register_type(CHASECAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(FPSCAMERADATA_TYPE_INFO);
    registry.register_type(FPSCAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(HUDIMPACTDATA_TYPE_INFO);
    registry.register_type(HUDIMPACTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BLUREFFECTDATA_TYPE_INFO);
    registry.register_type(BLUREFFECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TURNEFFECTDATA_TYPE_INFO);
    registry.register_type(TURNEFFECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERASINECURVEDATA_TYPE_INFO);
    registry.register_type(CAMERASINECURVEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUILDCONFIGFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(BUILDCONFIGFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERASSET_TYPE_INFO);
    registry.register_type(CHARACTERASSET_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEASSET_TYPE_INFO);
    registry.register_type(VEHICLEASSET_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERBLUEPRINT_TYPE_INFO);
    registry.register_type(CHARACTERBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEBLUEPRINT_TYPE_INFO);
    registry.register_type(VEHICLEBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_TYPE_INFO);
    registry.register_type(BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANGERHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BANGERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANGERPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BANGERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANGERENTITYDATA_TYPE_INFO);
    registry.register_type(BANGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WORLDRENDERERSWITCHENTITYDATA_TYPE_INFO);
    registry.register_type(WORLDRENDERERSWITCHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CANNEDSCENARIOENTITYDATA_TYPE_INFO);
    registry.register_type(CANNEDSCENARIOENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WARPANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(WARPANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WARPANIMATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WARPANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CANNEDANIMATIONBINDING_TYPE_INFO);
    registry.register_type(CANNEDANIMATIONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(WARPANIMATIONBINDING_TYPE_INFO);
    registry.register_type(WARPANIMATIONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(WARNINGSYSTEMCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WARNINGSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WARNINGPLAYERTYPE_TYPE_INFO);
    registry.register_type(WARNINGPLAYERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(LENSFLARECOMPONENTDATA_TYPE_INFO);
    registry.register_type(LENSFLARECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPHEREREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO);
    registry.register_type(SPHEREREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOXREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO);
    registry.register_type(BOXREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO);
    registry.register_type(REFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LIGHTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(LIGHTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEINPUTSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLEINPUTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(HEALTHZONEINFO_TYPE_INFO);
    registry.register_type(HEALTHZONEINFO_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECAMERACONTROLBINDING_TYPE_INFO);
    registry.register_type(VEHICLECAMERACONTROLBINDING_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERREADBINDING_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERREADBINDING_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERBINDING_TYPE_INFO);
    registry.register_type(VEHICLEENTRYLISTENERBINDING_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTCAMERATOCOMPONENTSINITMESSAGE_TYPE_INFO);
    registry.register_type(VEHICLETOCOMPONENTSSTARTDISABLEDDAMAGEDMESSAGE_TYPE_INFO);
    registry.register_type(CLIENTVEHICLETOCOMPONENTSHEALTHCHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(VEHICLEENTITYDATA_TYPE_INFO);
    registry.register_type(VEHICLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLESOUNDCATEGORY_TYPE_INFO);
    registry.register_type(AIVEHICLESOUNDCATEGORY_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATEDDRIVERENTITYDATA_TYPE_INFO);
    registry.register_type(ANIMATEDDRIVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(NORMALIZESETTINGS_TYPE_INFO);
    registry.register_type(NORMALIZESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESOUNDDATA_TYPE_INFO);
    registry.register_type(VEHICLESOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLELOCKABLEINFODATA_TYPE_INFO);
    registry.register_type(VEHICLELOCKABLEINFODATA_ARRAY_TYPE_INFO);
    registry.register_type(ANGLEOFIMPACTDATA_TYPE_INFO);
    registry.register_type(ANGLEOFIMPACTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MPMODEDATA_TYPE_INFO);
    registry.register_type(MPMODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEHEALTHZONEDATA_TYPE_INFO);
    registry.register_type(VEHICLEHEALTHZONEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEHUDDATA_TYPE_INFO);
    registry.register_type(VEHICLEHUDDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHILDMOVINGBODYDATA_TYPE_INFO);
    registry.register_type(CHILDMOVINGBODYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHILDROTATIONBODYDATA_TYPE_INFO);
    registry.register_type(CHILDROTATIONBODYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(IKCOMPONENTDATA_TYPE_INFO);
    registry.register_type(IKCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHASSISCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHASSISCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLDATA_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLPERSPEEDDATA_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLPERSPEEDDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLENUM_TYPE_INFO);
    registry.register_type(CAMERARELATIVECONTROLENUM_ARRAY_TYPE_INFO);
    registry.register_type(LANDINGGEARLOGICDATA_TYPE_INFO);
    registry.register_type(LANDINGGEARLOGICDATA_ARRAY_TYPE_INFO);
    registry.register_type(LANDINGGEARCONDITIONDATA_TYPE_INFO);
    registry.register_type(LANDINGGEARCONDITIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEWATEREFFECTDATA_TYPE_INFO);
    registry.register_type(VEHICLEWATEREFFECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEEXITPOINTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEEXITPOINTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACOMPONENTDATA_TYPE_INFO);
    registry.register_type(CAMERACOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANCECAMERADATA_TYPE_INFO);
    registry.register_type(STANCECAMERADATA_ARRAY_TYPE_INFO);
    registry.register_type(TURRETROTATIONINFO_TYPE_INFO);
    registry.register_type(TURRETROTATIONINFO_ARRAY_TYPE_INFO);
    registry.register_type(ROTATIONCHANNEL_TYPE_INFO);
    registry.register_type(ROTATIONCHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(CHILDBARRELCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHILDBARRELCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALIGNMENTDATA_TYPE_INFO);
    registry.register_type(ALIGNMENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROTORCOMPONENTDATA_TYPE_INFO);
    registry.register_type(ROTORCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROTORMODELDATA_TYPE_INFO);
    registry.register_type(ROTORMODELDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRACKCOMPONENTDATA_TYPE_INFO);
    registry.register_type(TRACKCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(FAKEPHYSICSMESHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(FAKEPHYSICSMESHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MESHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MESHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECUSTOMIZATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLECUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEMESHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEMESHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROTATIONAXISENUM_TYPE_INFO);
    registry.register_type(ROTATIONAXISENUM_ARRAY_TYPE_INFO);
    registry.register_type(TRACKWHEELCOMPONENTDATA_TYPE_INFO);
    registry.register_type(TRACKWHEELCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(WHEELCOMPONENTDATA_TYPE_INFO);
    registry.register_type(WHEELCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANCEFILTERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STANCEFILTERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENGINECOMPONENTDATA_TYPE_INFO);
    registry.register_type(ENGINECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHILDCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHILDCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VEHICLEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTRYCOMPONENTSOUNDDATA_TYPE_INFO);
    registry.register_type(ENTRYCOMPONENTSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANCESWITCHSOUNDDATA_TYPE_INFO);
    registry.register_type(STANCESWITCHSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERACOMPONENTSOUNDDATA_TYPE_INFO);
    registry.register_type(CAMERACOMPONENTSOUNDDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASICUNLOCKINFO_TYPE_INFO);
    registry.register_type(BASICUNLOCKINFO_ARRAY_TYPE_INFO);
    registry.register_type(VALUEUNLOCKASSET_TYPE_INFO);
    registry.register_type(VALUEUNLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(BOOLUNLOCKVALUEPAIR_TYPE_INFO);
    registry.register_type(BOOLUNLOCKVALUEPAIR_ARRAY_TYPE_INFO);
    registry.register_type(INTUNLOCKVALUEPAIR_TYPE_INFO);
    registry.register_type(INTUNLOCKVALUEPAIR_ARRAY_TYPE_INFO);
    registry.register_type(FLOATUNLOCKVALUEPAIR_TYPE_INFO);
    registry.register_type(FLOATUNLOCKVALUEPAIR_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKVALUEPAIR_TYPE_INFO);
    registry.register_type(UNLOCKVALUEPAIR_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKASSETPAIR_TYPE_INFO);
    registry.register_type(UNLOCKASSETPAIR_ARRAY_TYPE_INFO);
    registry.register_type(VISUALUNLOCKASSET_TYPE_INFO);
    registry.register_type(VISUALUNLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBLUEPRINTBUNDLE_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBLUEPRINTBUNDLE_ARRAY_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBUNDLEASSET_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBUNDLEASSET_ARRAY_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBUNDLEMODE_TYPE_INFO);
    registry.register_type(VISUALUNLOCKBUNDLEMODE_ARRAY_TYPE_INFO);
    registry.register_type(MULTIUNLOCKASSET_TYPE_INFO);
    registry.register_type(MULTIUNLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKASSET_TYPE_INFO);
    registry.register_type(UNLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(MESHANDVARIATIONPAIR_TYPE_INFO);
    registry.register_type(MESHANDVARIATIONPAIR_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKASSETBASE_TYPE_INFO);
    registry.register_type(UNLOCKASSETBASE_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKAVAILABILITY_TYPE_INFO);
    registry.register_type(UNLOCKAVAILABILITY_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKUSERDATABASE_TYPE_INFO);
    registry.register_type(UNLOCKUSERDATABASE_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKCOMPONENTDATA_TYPE_INFO);
    registry.register_type(UNLOCKCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(UNLOCKSPAWNTYPE_TYPE_INFO);
    registry.register_type(UNLOCKSPAWNTYPE_ARRAY_TYPE_INFO);
    registry.register_type(UIMESSAGETYPE_TYPE_INFO);
    registry.register_type(UIMESSAGETYPE_ARRAY_TYPE_INFO);
    registry.register_type(LIGHTDIMMERENTITYDATA_TYPE_INFO);
    registry.register_type(LIGHTDIMMERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(KINECTSERVICEDATA_TYPE_INFO);
    registry.register_type(KINECTSERVICEDATA_ARRAY_TYPE_INFO);
    registry.register_type(UIWORLDICONBEHAVIOR_TYPE_INFO);
    registry.register_type(UIWORLDICONBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(UICOMBATAREAASSET_TYPE_INFO);
    registry.register_type(UICOMBATAREAASSET_ARRAY_TYPE_INFO);
    registry.register_type(SPOTTINGTYPE_TYPE_INFO);
    registry.register_type(SPOTTINGTYPE_ARRAY_TYPE_INFO);
    registry.register_type(UIPARTDATA_TYPE_INFO);
    registry.register_type(UIPARTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCKINGTYPEASSET_TYPE_INFO);
    registry.register_type(LOCKINGTYPEASSET_ARRAY_TYPE_INFO);
    registry.register_type(CROSSHAIRTYPEASSET_TYPE_INFO);
    registry.register_type(CROSSHAIRTYPEASSET_ARRAY_TYPE_INFO);
    registry.register_type(UIPARTPROPERTYLIST_TYPE_INFO);
    registry.register_type(UIPARTPROPERTYLIST_ARRAY_TYPE_INFO);
    registry.register_type(UIPARTPROPERTIES_TYPE_INFO);
    registry.register_type(UIPARTPROPERTIES_ARRAY_TYPE_INFO);
    registry.register_type(UIHUDICON_TYPE_INFO);
    registry.register_type(UIHUDICON_ARRAY_TYPE_INFO);
    registry.register_type(UIPARTIDENTIFIER_TYPE_INFO);
    registry.register_type(UIPARTIDENTIFIER_ARRAY_TYPE_INFO);
    registry.register_type(COLLISIONMETHODENUM_TYPE_INFO);
    registry.register_type(COLLISIONMETHODENUM_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELGROUPHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELGROUPHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELGROUPPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELGROUPPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELGROUPENTITYDATA_TYPE_INFO);
    registry.register_type(STATICMODELGROUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELGROUPMEMBERDATA_TYPE_INFO);
    registry.register_type(STATICMODELGROUPMEMBERDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMESPLINEENTITYDATA_TYPE_INFO);
    registry.register_type(GAMESPLINEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMESPLINEDATA_TYPE_INFO);
    registry.register_type(GAMESPLINEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LICENSEEGAMESETTINGS_TYPE_INFO);
    registry.register_type(LICENSEEGAMESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SIGNIFICANCESETTINGS_TYPE_INFO);
    registry.register_type(SIGNIFICANCESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SKU_TYPE_INFO);
    registry.register_type(SKU_ARRAY_TYPE_INFO);
    registry.register_type(INTERACTIONENTITYDATA_TYPE_INFO);
    registry.register_type(INTERACTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PREDESTRUCTIONENTITYDATA_TYPE_INFO);
    registry.register_type(PREDESTRUCTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONENTITYDATA_TYPE_INFO);
    registry.register_type(EXPLOSIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPLOSIONWINDFORCEDATA_TYPE_INFO);
    registry.register_type(EXPLOSIONWINDFORCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEINDICATIONTYPE_TYPE_INFO);
    registry.register_type(DAMAGEINDICATIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICGAMEPHYSICSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERANIMATIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(VOICEOVERANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERMANAGERCONTROLENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVERMANAGERCONTROLENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DETACHEDSOUNDLISTENERENTITYDATA_TYPE_INFO);
    registry.register_type(DETACHEDSOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDLISTENERENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDAREAENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONENTITYTRACKINFO_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONENTITYTRACKINFO_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SERVERPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO);
    registry.register_type(CLIENTPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO);
    registry.register_type(PLAYANIMATIONDATA_TYPE_INFO);
    registry.register_type(PLAYANIMATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(FBPROXYCONTROLLERENTITYDATA_TYPE_INFO);
    registry.register_type(FBPROXYCONTROLLERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FBPROXYCONTROLLERENTITYBINDING_TYPE_INFO);
    registry.register_type(FBPROXYCONTROLLERENTITYBINDING_ARRAY_TYPE_INFO);
    registry.register_type(FACEPOSERENTITYDATA_TYPE_INFO);
    registry.register_type(FACEPOSERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSYNCREACHEDCLIENTMESSAGE_TYPE_INFO);
    registry.register_type(EVENTSYNCENTITYDATA_TYPE_INFO);
    registry.register_type(EVENTSYNCENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(CHARACTERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PLAYERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMEENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(GAMEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTENTRYIDENUM_TYPE_INFO);
    registry.register_type(ANTENTRYIDENUM_ARRAY_TYPE_INFO);
    registry.register_type(ENTITLEMENTQUERY_TYPE_INFO);
    registry.register_type(ENTITLEMENTQUERY_ARRAY_TYPE_INFO);
    registry.register_type(ENTITLEMENTDATA_TYPE_INFO);
    registry.register_type(ENTITLEMENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLATFORMPROJECTID_TYPE_INFO);
    registry.register_type(PLATFORMPROJECTID_ARRAY_TYPE_INFO);
    registry.register_type(ENTITLEMENTPLATFORMTYPE_TYPE_INFO);
    registry.register_type(ENTITLEMENTPLATFORMTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ENTITLEMENTTYPE_TYPE_INFO);
    registry.register_type(ENTITLEMENTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ENSEMBLEPUBLISHERENTITYDATA_TYPE_INFO);
    registry.register_type(ENSEMBLEPUBLISHERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICMODELHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DYNAMICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICMODELPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(DYNAMICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICMODELENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(NETFIRESTARTERCELL_TYPE_INFO);
    registry.register_type(NETFIRESTARTERCELL_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICFIREENTITYDATA_TYPE_INFO);
    registry.register_type(DYNAMICFIREENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICFIRECELLFXASSET_TYPE_INFO);
    registry.register_type(DYNAMICFIRECELLFXASSET_ARRAY_TYPE_INFO);
    registry.register_type(CELLFX_TYPE_INFO);
    registry.register_type(CELLFX_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERLOOKATTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(CHARACTERLOOKATTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(UNDERFIRETRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(UNDERFIRETRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERINPUTTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERINPUTTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAENTERAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(CAMERAENTERAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERSECTIONTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(INTERSECTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERSECTIONTRIGGERCONDITION_TYPE_INFO);
    registry.register_type(INTERSECTIONTRIGGERCONDITION_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERTAKEOVERTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERTAKEOVERTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(DAMAGEAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLEARAREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(CLEARAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESTATETRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(VEHICLESTATETRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERPOSEACTION_TYPE_INFO);
    registry.register_type(CHARACTERPOSEACTION_ARRAY_TYPE_INFO);
    registry.register_type(DELAYTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(DELAYTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTIPLETRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(MULTIPLETRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TRIGGEREVENTENTITYDATA_TYPE_INFO);
    registry.register_type(TRIGGEREVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMBATACTIONTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(COMBATACTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GEOMETRYTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(GEOMETRYTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREATRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(AREATRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREATRIGGERINCLUDE_TYPE_INFO);
    registry.register_type(AREATRIGGERINCLUDE_ARRAY_TYPE_INFO);
    registry.register_type(TRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(TRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTPARTBOUNDINGBOXENTITYDATA_TYPE_INFO);
    registry.register_type(TESTPARTBOUNDINGBOXENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ASSERTTIMEBOMBENTITYDATA_TYPE_INFO);
    registry.register_type(ASSERTTIMEBOMBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ASSERTTIMEBOMBBLUEPRINT_TYPE_INFO);
    registry.register_type(ASSERTTIMEBOMBBLUEPRINT_ARRAY_TYPE_INFO);
    registry.register_type(ATTACHMENTVERIFICATIONENTITYDATA_TYPE_INFO);
    registry.register_type(ATTACHMENTVERIFICATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLOSESTPOINTENTITYDATA_TYPE_INFO);
    registry.register_type(CLOSESTPOINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(JOINTVALIDATIONENTITYDATA_TYPE_INFO);
    registry.register_type(JOINTVALIDATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTPRESSENTITYDATA_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTPRESSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTPLAYBACKENTITYDATA_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTPLAYBACKENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTRECORDERENTITYDATA_TYPE_INFO);
    registry.register_type(CLIENTPLAYERINPUTRECORDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGGINGENTITYDATA_TYPE_INFO);
    registry.register_type(LOGGINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DESTRUCTIONCOMMANDENTITYDATA_TYPE_INFO);
    registry.register_type(DESTRUCTIONCOMMANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTPOINTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTPOINTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERMOVEMENTSEQUENCEDATA_TYPE_INFO);
    registry.register_type(SOLDIERMOVEMENTSEQUENCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECORDEDINPUTDATA_TYPE_INFO);
    registry.register_type(RECORDEDINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTRECORDERDATA_TYPE_INFO);
    registry.register_type(INPUTRECORDERDATA_ARRAY_TYPE_INFO);
    registry.register_type(INPUTRECORDERTRACKDATA_TYPE_INFO);
    registry.register_type(INPUTRECORDERTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONDATA_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAACTIONDATA_TYPE_INFO);
    registry.register_type(CAMERAACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CAMERAMOVEMENTACTIONMODE_TYPE_INFO);
    registry.register_type(CAMERAMOVEMENTACTIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONTIMEDATA_TYPE_INFO);
    registry.register_type(SIMPLEMOVEMENTACTIONTIMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONRANDOMIZERDATA_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONRANDOMIZERDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONGROUPDATA_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONGROUPDATA_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONROOT_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONROOT_ARRAY_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONDATA_TYPE_INFO);
    registry.register_type(MOVEMENTACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(ASSERTENTITYDATA_TYPE_INFO);
    registry.register_type(ASSERTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKDEBUGENTITYDATA_TYPE_INFO);
    registry.register_type(LINKDEBUGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELTAVIEWERTABLEENTITYDATA_TYPE_INFO);
    registry.register_type(DELTAVIEWERTABLEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELTAVIEWERMODE_TYPE_INFO);
    registry.register_type(DELTAVIEWERMODE_ARRAY_TYPE_INFO);
    registry.register_type(DELTAVIEWERCOLUMN_TYPE_INFO);
    registry.register_type(DELTAVIEWERCOLUMN_ARRAY_TYPE_INFO);
    registry.register_type(DELTAVIEWERCOLUMNVALUETYPE_TYPE_INFO);
    registry.register_type(DELTAVIEWERCOLUMNVALUETYPE_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYDEBUGENTITYDATA_TYPE_INFO);
    registry.register_type(PROPERTYDEBUGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYDEBUGGRAPHMODE_TYPE_INFO);
    registry.register_type(PROPERTYDEBUGGRAPHMODE_ARRAY_TYPE_INFO);
    registry.register_type(PRINTDEBUGTEXTENTITYDATA_TYPE_INFO);
    registry.register_type(PRINTDEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCULLIDCULLABLEEFFECTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTCULLIDCULLABLEEFFECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCULLIDCULLABLEEFFECTMODE_TYPE_INFO);
    registry.register_type(TESTCULLIDCULLABLEEFFECTMODE_ARRAY_TYPE_INFO);
    registry.register_type(TESTEFFECTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTEFFECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCASEENTITYEFFECTDATA_TYPE_INFO);
    registry.register_type(TESTCASEENTITYEFFECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCREENSHOTCOMPARISONENTITYDATA_TYPE_INFO);
    registry.register_type(SCREENSHOTCOMPARISONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCOMPONENTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTCOMPONENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTPHYSICSENTITYDATA_TYPE_INFO);
    registry.register_type(TESTPHYSICSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCASEENTITYDATA_TYPE_INFO);
    registry.register_type(TESTCASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGMENUITEMENTITYDATA_TYPE_INFO);
    registry.register_type(DEBUGMENUITEMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGMENUITEMTYPE_TYPE_INFO);
    registry.register_type(DEBUGMENUITEMTYPE_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGMENUSUBMENUENTITYDATA_TYPE_INFO);
    registry.register_type(DEBUGMENUSUBMENUENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONSOLECOMMANDTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(CONSOLECOMMANDTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONSOLECOMMANDENTITYDATA_TYPE_INFO);
    registry.register_type(CONSOLECOMMANDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGTEXTENTITYDATA_TYPE_INFO);
    registry.register_type(DEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCOLLISIONEVENTENTITYDATA_TYPE_INFO);
    registry.register_type(TESTCOLLISIONEVENTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TESTCOLLISIONEVENTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(TESTCOLLISIONEVENTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(TERRAINDYNAMICDECALENTITYDATA_TYPE_INFO);
    registry.register_type(TERRAINDYNAMICDECALENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SYNCEDSEQUENCEENTITYDATA_TYPE_INFO);
    registry.register_type(SYNCEDSEQUENCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMESUBVIEWDATA_TYPE_INFO);
    registry.register_type(GAMESUBVIEWDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPECTATORSUBVIEWDATA_TYPE_INFO);
    registry.register_type(SPECTATORSUBVIEWDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBLEVELSTATUSENTITYDATA_TYPE_INFO);
    registry.register_type(SUBLEVELSTATUSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUBLEVELPRELOADENTITYDATA_TYPE_INFO);
    registry.register_type(SUBLEVELPRELOADENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(STATICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTERACTABLESTATICMODELENTITYDATA_TYPE_INFO);
    registry.register_type(INTERACTABLESTATICMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FENCEMODELENTITYDATA_TYPE_INFO);
    registry.register_type(FENCEMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LADDERENTITYDATA_TYPE_INFO);
    registry.register_type(LADDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELENTITYDATA_TYPE_INFO);
    registry.register_type(STATICMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STATICMODELNETWORKINFO_TYPE_INFO);
    registry.register_type(STATICMODELNETWORKINFO_ARRAY_TYPE_INFO);
    registry.register_type(CHILDSTATICMODELNETWORKINFO_TYPE_INFO);
    registry.register_type(CHILDSTATICMODELNETWORKINFO_ARRAY_TYPE_INFO);
    registry.register_type(INDEXRANGE_TYPE_INFO);
    registry.register_type(INDEXRANGE_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSPARTINFO_TYPE_INFO);
    registry.register_type(PHYSICSPARTINFO_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESPAWNREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(VEHICLESPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERSPAWNREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(CHARACTERSPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHARACTERTOCOMPONENTSSPAWNTEMPLATEMESSAGE_TYPE_INFO);
    registry.register_type(CHARACTERSPAWNTEMPLATEDATA_TYPE_INFO);
    registry.register_type(CHARACTERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALTERNATESPAWNENTITYDATA_TYPE_INFO);
    registry.register_type(ALTERNATESPAWNENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMEBEHAVIOURTEMPLATEDATA_TYPE_INFO);
    registry.register_type(GAMEBEHAVIOURTEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAMESENSINGTEMPLATEDATA_TYPE_INFO);
    registry.register_type(GAMESENSINGTEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONSPAWNTEMPLATE_TYPE_INFO);
    registry.register_type(ANIMATIONSPAWNTEMPLATE_ARRAY_TYPE_INFO);
    registry.register_type(SPAWNREFERENCEOBJECTDATA_TYPE_INFO);
    registry.register_type(SPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENTRYENTERRESTRICTION_TYPE_INFO);
    registry.register_type(ENTRYENTERRESTRICTION_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERSPAWNTYPE_TYPE_INFO);
    registry.register_type(PLAYERSPAWNTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SLOWMOTIONENTITYDATA_TYPE_INFO);
    registry.register_type(SLOWMOTIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLLISIONNETSTATE_TYPE_INFO);
    registry.register_type(COLLISIONNETSTATE_ARRAY_TYPE_INFO);
    registry.register_type(SERVERSETTINGS_TYPE_INFO);
    registry.register_type(SERVERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CONGESTIONCONTROLSETTINGS_TYPE_INFO);
    registry.register_type(CONGESTIONCONTROLSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(MODELANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(MODELANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MODELANIMATIONTRANSFORMTYPE_TYPE_INFO);
    registry.register_type(MODELANIMATIONTRANSFORMTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MODELANIMATIONUPDATEORDER_TYPE_INFO);
    registry.register_type(MODELANIMATIONUPDATEORDER_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONENUMERATIONCHOICEENTITYDATA_TYPE_INFO);
    registry.register_type(ANIMATIONENUMERATIONCHOICEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONENUMERATIONENTITYDATA_TYPE_INFO);
    registry.register_type(ANIMATIONENUMERATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANIMATIONSIGNALENTITYDATA_TYPE_INFO);
    registry.register_type(ANIMATIONSIGNALENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCORINGVISIBILITYTYPE_TYPE_INFO);
    registry.register_type(SCORINGVISIBILITYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(FLOATRECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(FLOATRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLVALIDATEPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(BOOLVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(BOOLRECORDPROPERTYTRACKDATA_TYPE_INFO);
    registry.register_type(BOOLRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SYNCEDTIMELINESTATECHANGEMESSAGEBASE_TYPE_INFO);
    registry.register_type(SHAREDLOCKGATEENTITYDATA_TYPE_INFO);
    registry.register_type(SHAREDLOCKGATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDLOCKOBSERVERENTITYDATA_TYPE_INFO);
    registry.register_type(SHAREDLOCKOBSERVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDLOCKCONTROLLERENTITYDATA_TYPE_INFO);
    registry.register_type(SHAREDLOCKCONTROLLERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDLOCKBASEENTITYDATA_TYPE_INFO);
    registry.register_type(SHAREDLOCKBASEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHAREDLOCKASSET_TYPE_INFO);
    registry.register_type(SHAREDLOCKASSET_ARRAY_TYPE_INFO);
    registry.register_type(MORPHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(MORPHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLEMODELHEALTHCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BREAKABLEMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLEMODELPHYSICSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BREAKABLEMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLEMODELTOCOMPONENTSSPAWNPARTOBJECTSONCOLLAPSEMESSAGE_TYPE_INFO);
    registry.register_type(BREAKABLEMODELTOCOMPONENTSCOLLAPSEMESSAGE_TYPE_INFO);
    registry.register_type(BREAKABLEMODELENTITYDATA_TYPE_INFO);
    registry.register_type(BREAKABLEMODELENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(EDGEMODELCOMPONENTDATA_TYPE_INFO);
    registry.register_type(EDGEMODELCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTNETWORKID_TYPE_INFO);
    registry.register_type(BREAKABLECONTROLLERCOMPONENTNETWORKID_ARRAY_TYPE_INFO);
    registry.register_type(BREAKABLEPARTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(BREAKABLEPARTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(RAWFILEDATA_TYPE_INFO);
    registry.register_type(RAWFILEDATA_ARRAY_TYPE_INFO);
}

#[derive(Clone, Debug, Default)]
pub struct FadeTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub keyframes: Vec<Option<Arc<Mutex<dyn FadeTrackKeyframeTrait>>>>,
    pub fade_screen: bool,
    pub fade_u_i: bool,
    pub fade_audio: bool,
    pub fade_movie: bool,
    pub fade_rumble: bool,
    pub block_input: bool,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait FadeTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn FadeTrackKeyframeTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn FadeTrackKeyframeTrait>>>>;
    fn fade_screen(&self) -> &bool;
    fn fade_screen_mut(&mut self) -> &mut bool;
    fn fade_u_i(&self) -> &bool;
    fn fade_u_i_mut(&mut self) -> &mut bool;
    fn fade_audio(&self) -> &bool;
    fn fade_audio_mut(&mut self) -> &mut bool;
    fn fade_movie(&self) -> &bool;
    fn fade_movie_mut(&mut self) -> &mut bool;
    fn fade_rumble(&self) -> &bool;
    fn fade_rumble_mut(&mut self) -> &mut bool;
    fn block_input(&self) -> &bool;
    fn block_input_mut(&mut self) -> &mut bool;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl FadeTrackDataTrait for FadeTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn FadeTrackKeyframeTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn FadeTrackKeyframeTrait>>>> {
        &mut self.keyframes
    }
    fn fade_screen(&self) -> &bool {
        &self.fade_screen
    }
    fn fade_screen_mut(&mut self) -> &mut bool {
        &mut self.fade_screen
    }
    fn fade_u_i(&self) -> &bool {
        &self.fade_u_i
    }
    fn fade_u_i_mut(&mut self) -> &mut bool {
        &mut self.fade_u_i
    }
    fn fade_audio(&self) -> &bool {
        &self.fade_audio
    }
    fn fade_audio_mut(&mut self) -> &mut bool {
        &mut self.fade_audio
    }
    fn fade_movie(&self) -> &bool {
        &self.fade_movie
    }
    fn fade_movie_mut(&mut self) -> &mut bool {
        &mut self.fade_movie
    }
    fn fade_rumble(&self) -> &bool {
        &self.fade_rumble
    }
    fn fade_rumble_mut(&mut self) -> &mut bool {
        &mut self.fade_rumble
    }
    fn block_input(&self) -> &bool {
        &self.block_input
    }
    fn block_input_mut(&mut self) -> &mut bool {
        &mut self.block_input
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::timeline::TimelineTrackDataTrait for FadeTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for FadeTrackData {
}

impl super::core::DataBusPeerTrait for FadeTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FadeTrackData {
}

impl super::core::DataContainerTrait for FadeTrackData {
}

pub static FADETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FadeTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "FadeTrackKeyframe-Array",
                rust_offset: offset_of!(FadeTrackData, keyframes),
            },
            FieldInfoData {
                name: "FadeScreen",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_screen),
            },
            FieldInfoData {
                name: "FadeUI",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_u_i),
            },
            FieldInfoData {
                name: "FadeAudio",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_audio),
            },
            FieldInfoData {
                name: "FadeMovie",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_movie),
            },
            FieldInfoData {
                name: "FadeRumble",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, fade_rumble),
            },
            FieldInfoData {
                name: "BlockInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeTrackData, block_input),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(FadeTrackData, local_player_id),
            },
        ],
    }),
    array_type: Some(FADETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FadeTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        FADETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FADETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FadeTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FadeTrackKeyframe {
    pub _glacier_base: super::core::DataContainer,
    pub time: f32,
    pub length: f32,
    pub fade_type: FadeTrackKeyframeType,
}

pub trait FadeTrackKeyframeTrait: super::core::DataContainerTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
    fn fade_type(&self) -> &FadeTrackKeyframeType;
    fn fade_type_mut(&mut self) -> &mut FadeTrackKeyframeType;
}

impl FadeTrackKeyframeTrait for FadeTrackKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
    fn fade_type(&self) -> &FadeTrackKeyframeType {
        &self.fade_type
    }
    fn fade_type_mut(&mut self) -> &mut FadeTrackKeyframeType {
        &mut self.fade_type
    }
}

impl super::core::DataContainerTrait for FadeTrackKeyframe {
}

pub static FADETRACKKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackKeyframe",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FadeTrackKeyframe as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FadeTrackKeyframe, time),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FadeTrackKeyframe, length),
            },
            FieldInfoData {
                name: "FadeType",
                flags: MemberInfoFlags::new(0),
                field_type: "FadeTrackKeyframeType",
                rust_offset: offset_of!(FadeTrackKeyframe, fade_type),
            },
        ],
    }),
    array_type: Some(FADETRACKKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FadeTrackKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        FADETRACKKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FADETRACKKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackKeyframe-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FadeTrackKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum FadeTrackKeyframeType {
    #[default]
    FadeTrackKeyframeType_FadeOut = 0,
    FadeTrackKeyframeType_FadeIn = 1,
    FadeTrackKeyframeTypeCount = 2,
}

pub static FADETRACKKEYFRAMETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackKeyframeType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(FADETRACKKEYFRAMETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FadeTrackKeyframeType {
    fn type_info(&self) -> &'static TypeInfo {
        FADETRACKKEYFRAMETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FADETRACKKEYFRAMETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeTrackKeyframeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FadeTrackKeyframeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TrackBuilderData {
    pub _glacier_base: super::timeline::TimelineExtraData,
}

pub trait TrackBuilderDataTrait: super::timeline::TimelineExtraDataTrait {
}

impl TrackBuilderDataTrait for TrackBuilderData {
}

impl super::timeline::TimelineExtraDataTrait for TrackBuilderData {
}

impl super::core::DataContainerTrait for TrackBuilderData {
}

pub static TRACKBUILDERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackBuilderData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINEEXTRADATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrackBuilderData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRACKBUILDERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TrackBuilderData {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKBUILDERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRACKBUILDERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackBuilderData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrackBuilderData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ActorToBlueprintGuidRow {
}

pub trait ActorToBlueprintGuidRowTrait: TypeObject {
}

impl ActorToBlueprintGuidRowTrait for ActorToBlueprintGuidRow {
}

pub static ACTORTOBLUEPRINTGUIDROW_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActorToBlueprintGuidRow",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ActorToBlueprintGuidRow as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ACTORTOBLUEPRINTGUIDROW_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ActorToBlueprintGuidRow {
    fn type_info(&self) -> &'static TypeInfo {
        ACTORTOBLUEPRINTGUIDROW_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ACTORTOBLUEPRINTGUIDROW_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActorToBlueprintGuidRow-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ActorToBlueprintGuidRow"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CutsceneSavedSettingsData {
    pub _glacier_base: super::timeline::TimelineExtraData,
}

pub trait CutsceneSavedSettingsDataTrait: super::timeline::TimelineExtraDataTrait {
}

impl CutsceneSavedSettingsDataTrait for CutsceneSavedSettingsData {
}

impl super::timeline::TimelineExtraDataTrait for CutsceneSavedSettingsData {
}

impl super::core::DataContainerTrait for CutsceneSavedSettingsData {
}

pub static CUTSCENESAVEDSETTINGSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneSavedSettingsData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINEEXTRADATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CutsceneSavedSettingsData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CUTSCENESAVEDSETTINGSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CutsceneSavedSettingsData {
    fn type_info(&self) -> &'static TypeInfo {
        CUTSCENESAVEDSETTINGSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUTSCENESAVEDSETTINGSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneSavedSettingsData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CutsceneSavedSettingsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ImportTarget {
}

pub trait ImportTargetTrait: TypeObject {
}

impl ImportTargetTrait for ImportTarget {
}

pub static IMPORTTARGET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImportTarget",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ImportTarget as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(IMPORTTARGET_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ImportTarget {
    fn type_info(&self) -> &'static TypeInfo {
        IMPORTTARGET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static IMPORTTARGET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImportTarget-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ImportTarget"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ImporterSource {
    #[default]
    DCC = 0,
    ANT = 1,
}

pub static IMPORTERSOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImporterSource",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(IMPORTERSOURCE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ImporterSource {
    fn type_info(&self) -> &'static TypeInfo {
        IMPORTERSOURCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static IMPORTERSOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImporterSource-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ImporterSource"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CutsceneSavedSettingsPathType {
    #[default]
    PathType_Absolute = 0,
    PathType_Relative = 1,
}

pub static CUTSCENESAVEDSETTINGS_PATHTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneSavedSettings_PathType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CUTSCENESAVEDSETTINGS_PATHTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CutsceneSavedSettingsPathType {
    fn type_info(&self) -> &'static TypeInfo {
        CUTSCENESAVEDSETTINGS_PATHTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUTSCENESAVEDSETTINGS_PATHTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneSavedSettings_PathType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CutsceneSavedSettings_PathType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CutsceneQualityLevel {
    #[default]
    CutsceneQualityLevel_Invalid = 4294967295,
    CutsceneQualityLevel_Low = 0,
    CutsceneQualityLevel_Medium = 1,
    CutsceneQualityLevel_High = 2,
    CutsceneQualityLevel_VeryHigh = 3,
    CutsceneQualityLevel_Uncompressed = 4,
}

pub static CUTSCENEQUALITYLEVEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneQualityLevel",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CUTSCENEQUALITYLEVEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CutsceneQualityLevel {
    fn type_info(&self) -> &'static TypeInfo {
        CUTSCENEQUALITYLEVEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUTSCENEQUALITYLEVEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneQualityLevel-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CutsceneQualityLevel"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CutsceneActorType {
    #[default]
    Invalid = 4294967295,
    Character = 0,
    Camera = 1,
    SchematicProp = 2,
    Prop = 3,
    Max = 4,
}

pub static CUTSCENEACTORTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneActorType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CUTSCENEACTORTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CutsceneActorType {
    fn type_info(&self) -> &'static TypeInfo {
        CUTSCENEACTORTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUTSCENEACTORTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CutsceneActorType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CutsceneActorType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraTrackData {
    pub _glacier_base: PhysicalCameraTrackData,
    pub layered_transform_track: Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>,
}

pub trait CameraTrackDataTrait: PhysicalCameraTrackDataTrait {
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
}

impl CameraTrackDataTrait for CameraTrackData {
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &mut self.layered_transform_track
    }
}

impl PhysicalCameraTrackDataTrait for CameraTrackData {
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children_mut()
    }
}

impl CameraTrackBaseDataTrait for CameraTrackData {
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraTrackData {
}

impl super::core::DataBusPeerTrait for CameraTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraTrackData {
}

impl super::core::DataContainerTrait for CameraTrackData {
}

pub static CAMERATRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICALCAMERATRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayeredTransformTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(CameraTrackData, layered_transform_track),
            },
        ],
    }),
    array_type: Some(CAMERATRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERATRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERATRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraTrackBaseData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub transition_data_pack: Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>>,
}

pub trait CameraTrackBaseDataTrait: super::timeline::TimelineTrackDataTrait {
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>>;
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>>;
}

impl CameraTrackBaseDataTrait for CameraTrackBaseData {
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        &self.transition_data_pack
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        &mut self.transition_data_pack
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraTrackBaseData {
}

impl super::core::DataBusPeerTrait for CameraTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraTrackBaseData {
}

impl super::core::DataContainerTrait for CameraTrackBaseData {
}

pub static CAMERATRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTrackBaseData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraTrackBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TransitionDataPack",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraTransitionEffectDataPack",
                rust_offset: offset_of!(CameraTrackBaseData, transition_data_pack),
            },
        ],
    }),
    array_type: Some(CAMERATRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CameraTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERATRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERATRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraTrackBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraLookAtLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub look_at_transform_track: Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>,
}

pub trait CameraLookAtLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn look_at_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
    fn look_at_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
}

impl CameraLookAtLayerDataTrait for CameraLookAtLayerData {
    fn look_at_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &self.look_at_transform_track
    }
    fn look_at_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &mut self.look_at_transform_track
    }
}

impl super::timeline::TransformLayerDataTrait for CameraLookAtLayerData {
    fn weight(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraLookAtLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraLookAtLayerData {
}

impl super::core::DataBusPeerTrait for CameraLookAtLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraLookAtLayerData {
}

impl super::core::DataContainerTrait for CameraLookAtLayerData {
}

pub static CAMERALOOKATLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLookAtLayerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraLookAtLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LookAtTransformTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(CameraLookAtLayerData, look_at_transform_track),
            },
        ],
    }),
    array_type: Some(CAMERALOOKATLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraLookAtLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERALOOKATLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERALOOKATLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLookAtLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraLookAtLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraFocusTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub default_transform: super::core::LinearTransform,
    pub layered_transform_track: Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>,
}

pub trait CameraFocusTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn default_transform(&self) -> &super::core::LinearTransform;
    fn default_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
}

impl CameraFocusTrackDataTrait for CameraFocusTrackData {
    fn default_transform(&self) -> &super::core::LinearTransform {
        &self.default_transform
    }
    fn default_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.default_transform
    }
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &mut self.layered_transform_track
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraFocusTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraFocusTrackData {
}

impl super::core::DataBusPeerTrait for CameraFocusTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraFocusTrackData {
}

impl super::core::DataContainerTrait for CameraFocusTrackData {
}

pub static CAMERAFOCUSTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraFocusTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraFocusTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CameraFocusTrackData, default_transform),
            },
            FieldInfoData {
                name: "LayeredTransformTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(CameraFocusTrackData, layered_transform_track),
            },
        ],
    }),
    array_type: Some(CAMERAFOCUSTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraFocusTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAFOCUSTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAFOCUSTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraFocusTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraFocusTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraDofTrackData {
    pub _glacier_base: super::timeline::EntityTrackBaseData,
}

pub trait CameraDofTrackDataTrait: super::timeline::EntityTrackBaseDataTrait {
}

impl CameraDofTrackDataTrait for CameraDofTrackData {
}

impl super::timeline::EntityTrackBaseDataTrait for CameraDofTrackData {
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children_mut()
    }
    fn inherited_to_child_conversation_lines(&self) -> &bool {
        self._glacier_base.inherited_to_child_conversation_lines()
    }
    fn inherited_to_child_conversation_lines_mut(&mut self) -> &mut bool {
        self._glacier_base.inherited_to_child_conversation_lines_mut()
    }
    fn required(&self) -> &bool {
        self._glacier_base.required()
    }
    fn required_mut(&mut self) -> &mut bool {
        self._glacier_base.required_mut()
    }
    fn handle_deleted_entity(&self) -> &bool {
        self._glacier_base.handle_deleted_entity()
    }
    fn handle_deleted_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.handle_deleted_entity_mut()
    }
    fn entity_sharing_policy(&self) -> &super::timeline::EntityTrackSharingPolicy {
        self._glacier_base.entity_sharing_policy()
    }
    fn entity_sharing_policy_mut(&mut self) -> &mut super::timeline::EntityTrackSharingPolicy {
        self._glacier_base.entity_sharing_policy_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraDofTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraDofTrackData {
}

impl super::core::DataBusPeerTrait for CameraDofTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraDofTrackData {
}

impl super::core::DataContainerTrait for CameraDofTrackData {
}

pub static CAMERADOFTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDofTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::ENTITYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDofTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CAMERADOFTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDofTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADOFTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADOFTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDofTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDofTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraDirectorTrackData {
    pub _glacier_base: CameraDirectorTrackBaseData,
    pub keyframes: Vec<Option<Arc<Mutex<dyn CameraDirectorKeyframeTrait>>>>,
}

pub trait CameraDirectorTrackDataTrait: CameraDirectorTrackBaseDataTrait {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn CameraDirectorKeyframeTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CameraDirectorKeyframeTrait>>>>;
}

impl CameraDirectorTrackDataTrait for CameraDirectorTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn CameraDirectorKeyframeTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CameraDirectorKeyframeTrait>>>> {
        &mut self.keyframes
    }
}

impl CameraDirectorTrackBaseDataTrait for CameraDirectorTrackData {
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children_mut()
    }
    fn post_timeline_camera(&self) -> &Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>> {
        self._glacier_base.post_timeline_camera()
    }
    fn post_timeline_camera_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>> {
        self._glacier_base.post_timeline_camera_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraDirectorTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraDirectorTrackData {
}

impl super::core::DataBusPeerTrait for CameraDirectorTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraDirectorTrackData {
}

impl super::core::DataContainerTrait for CameraDirectorTrackData {
}

pub static CAMERADIRECTORTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERADIRECTORTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "CameraDirectorKeyframe-Array",
                rust_offset: offset_of!(CameraDirectorTrackData, keyframes),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDirectorTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraDirectorTrackBaseData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub children: Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>,
    pub post_timeline_camera: Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>>,
}

pub trait CameraDirectorTrackBaseDataTrait: super::timeline::TimelineTrackDataTrait {
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn post_timeline_camera(&self) -> &Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>>;
    fn post_timeline_camera_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>>;
}

impl CameraDirectorTrackBaseDataTrait for CameraDirectorTrackBaseData {
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &self.children
    }
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &mut self.children
    }
    fn post_timeline_camera(&self) -> &Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>> {
        &self.post_timeline_camera
    }
    fn post_timeline_camera_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>> {
        &mut self.post_timeline_camera
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraDirectorTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraDirectorTrackBaseData {
}

impl super::core::DataBusPeerTrait for CameraDirectorTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraDirectorTrackBaseData {
}

impl super::core::DataContainerTrait for CameraDirectorTrackBaseData {
}

pub static CAMERADIRECTORTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorTrackBaseData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorTrackBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Children",
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(CameraDirectorTrackBaseData, children),
            },
            FieldInfoData {
                name: "PostTimelineCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraTrackBaseData",
                rust_offset: offset_of!(CameraDirectorTrackBaseData, post_timeline_camera),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CameraDirectorTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorTrackBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraDirectorKeyframe {
    pub _glacier_base: super::timeline::TimelineKeyframeData,
    pub time: f32,
    pub camera_track: Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>>,
    pub camera_cut_behavior: CameraCutBehavior,
    pub parent_director_track: Option<Arc<Mutex<dyn CameraDirectorTrackBaseDataTrait>>>,
}

pub trait CameraDirectorKeyframeTrait: super::timeline::TimelineKeyframeDataTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn camera_track(&self) -> &Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>>;
    fn camera_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>>;
    fn camera_cut_behavior(&self) -> &CameraCutBehavior;
    fn camera_cut_behavior_mut(&mut self) -> &mut CameraCutBehavior;
    fn parent_director_track(&self) -> &Option<Arc<Mutex<dyn CameraDirectorTrackBaseDataTrait>>>;
    fn parent_director_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraDirectorTrackBaseDataTrait>>>;
}

impl CameraDirectorKeyframeTrait for CameraDirectorKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn camera_track(&self) -> &Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>> {
        &self.camera_track
    }
    fn camera_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraTrackBaseDataTrait>>> {
        &mut self.camera_track
    }
    fn camera_cut_behavior(&self) -> &CameraCutBehavior {
        &self.camera_cut_behavior
    }
    fn camera_cut_behavior_mut(&mut self) -> &mut CameraCutBehavior {
        &mut self.camera_cut_behavior
    }
    fn parent_director_track(&self) -> &Option<Arc<Mutex<dyn CameraDirectorTrackBaseDataTrait>>> {
        &self.parent_director_track
    }
    fn parent_director_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraDirectorTrackBaseDataTrait>>> {
        &mut self.parent_director_track
    }
}

impl super::timeline::TimelineKeyframeDataTrait for CameraDirectorKeyframe {
}

impl super::core::DataContainerTrait for CameraDirectorKeyframe {
}

pub static CAMERADIRECTORKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorKeyframe",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINEKEYFRAMEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorKeyframe as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraDirectorKeyframe, time),
            },
            FieldInfoData {
                name: "CameraTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraTrackBaseData",
                rust_offset: offset_of!(CameraDirectorKeyframe, camera_track),
            },
            FieldInfoData {
                name: "CameraCutBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraCutBehavior",
                rust_offset: offset_of!(CameraDirectorKeyframe, camera_cut_behavior),
            },
            FieldInfoData {
                name: "ParentDirectorTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraDirectorTrackBaseData",
                rust_offset: offset_of!(CameraDirectorKeyframe, parent_director_track),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDirectorKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorKeyframe-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CameraCutBehavior {
    #[default]
    CameraCutBehavior_CameraCut = 0,
    CameraCutBehavior_StraightCut = 1,
    CameraCutBehavior_Continuous = 2,
}

pub static CAMERACUTBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CAMERACUTBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CameraCutBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACUTBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERACUTBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraCutBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraDirectorProxyTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub children: Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>,
    pub keyframes: Vec<Option<Arc<Mutex<dyn CameraDirectorProxyKeyframeTrait>>>>,
}

pub trait CameraDirectorProxyTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn CameraDirectorProxyKeyframeTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CameraDirectorProxyKeyframeTrait>>>>;
}

impl CameraDirectorProxyTrackDataTrait for CameraDirectorProxyTrackData {
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &self.children
    }
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &mut self.children
    }
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn CameraDirectorProxyKeyframeTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CameraDirectorProxyKeyframeTrait>>>> {
        &mut self.keyframes
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraDirectorProxyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraDirectorProxyTrackData {
}

impl super::core::DataBusPeerTrait for CameraDirectorProxyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraDirectorProxyTrackData {
}

impl super::core::DataContainerTrait for CameraDirectorProxyTrackData {
}

pub static CAMERADIRECTORPROXYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorProxyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorProxyTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Children",
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(CameraDirectorProxyTrackData, children),
            },
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "CameraDirectorProxyKeyframe-Array",
                rust_offset: offset_of!(CameraDirectorProxyTrackData, keyframes),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORPROXYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDirectorProxyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORPROXYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORPROXYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorProxyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorProxyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraDirectorProxyKeyframe {
    pub _glacier_base: super::core::DataContainer,
    pub time: f32,
    pub jump_cut: bool,
}

pub trait CameraDirectorProxyKeyframeTrait: super::core::DataContainerTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn jump_cut(&self) -> &bool;
    fn jump_cut_mut(&mut self) -> &mut bool;
}

impl CameraDirectorProxyKeyframeTrait for CameraDirectorProxyKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn jump_cut(&self) -> &bool {
        &self.jump_cut
    }
    fn jump_cut_mut(&mut self) -> &mut bool {
        &mut self.jump_cut
    }
}

impl super::core::DataContainerTrait for CameraDirectorProxyKeyframe {
}

pub static CAMERADIRECTORPROXYKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorProxyKeyframe",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraDirectorProxyKeyframe as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraDirectorProxyKeyframe, time),
            },
            FieldInfoData {
                name: "JumpCut",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraDirectorProxyKeyframe, jump_cut),
            },
        ],
    }),
    array_type: Some(CAMERADIRECTORPROXYKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraDirectorProxyKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERADIRECTORPROXYKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERADIRECTORPROXYKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraDirectorProxyKeyframe-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraDirectorProxyKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraCutVisibilityTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub set_initial_visibility_on_start: bool,
    pub initial_visibility: bool,
    pub visibility: bool,
    pub keyframes: Vec<Option<Arc<Mutex<dyn CameraCutVisibilityKeyframeTrait>>>>,
    pub start_time: f32,
    pub end_time: f32,
}

pub trait CameraCutVisibilityTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn set_initial_visibility_on_start(&self) -> &bool;
    fn set_initial_visibility_on_start_mut(&mut self) -> &mut bool;
    fn initial_visibility(&self) -> &bool;
    fn initial_visibility_mut(&mut self) -> &mut bool;
    fn visibility(&self) -> &bool;
    fn visibility_mut(&mut self) -> &mut bool;
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn CameraCutVisibilityKeyframeTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CameraCutVisibilityKeyframeTrait>>>>;
    fn start_time(&self) -> &f32;
    fn start_time_mut(&mut self) -> &mut f32;
    fn end_time(&self) -> &f32;
    fn end_time_mut(&mut self) -> &mut f32;
}

impl CameraCutVisibilityTrackDataTrait for CameraCutVisibilityTrackData {
    fn set_initial_visibility_on_start(&self) -> &bool {
        &self.set_initial_visibility_on_start
    }
    fn set_initial_visibility_on_start_mut(&mut self) -> &mut bool {
        &mut self.set_initial_visibility_on_start
    }
    fn initial_visibility(&self) -> &bool {
        &self.initial_visibility
    }
    fn initial_visibility_mut(&mut self) -> &mut bool {
        &mut self.initial_visibility
    }
    fn visibility(&self) -> &bool {
        &self.visibility
    }
    fn visibility_mut(&mut self) -> &mut bool {
        &mut self.visibility
    }
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn CameraCutVisibilityKeyframeTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CameraCutVisibilityKeyframeTrait>>>> {
        &mut self.keyframes
    }
    fn start_time(&self) -> &f32 {
        &self.start_time
    }
    fn start_time_mut(&mut self) -> &mut f32 {
        &mut self.start_time
    }
    fn end_time(&self) -> &f32 {
        &self.end_time
    }
    fn end_time_mut(&mut self) -> &mut f32 {
        &mut self.end_time
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraCutVisibilityTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraCutVisibilityTrackData {
}

impl super::core::DataBusPeerTrait for CameraCutVisibilityTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraCutVisibilityTrackData {
}

impl super::core::DataContainerTrait for CameraCutVisibilityTrackData {
}

pub static CAMERACUTVISIBILITYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutVisibilityTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraCutVisibilityTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SetInitialVisibilityOnStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, set_initial_visibility_on_start),
            },
            FieldInfoData {
                name: "InitialVisibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, initial_visibility),
            },
            FieldInfoData {
                name: "Visibility",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, visibility),
            },
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "CameraCutVisibilityKeyframe-Array",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, keyframes),
            },
            FieldInfoData {
                name: "StartTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, start_time),
            },
            FieldInfoData {
                name: "EndTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraCutVisibilityTrackData, end_time),
            },
        ],
    }),
    array_type: Some(CAMERACUTVISIBILITYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraCutVisibilityTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACUTVISIBILITYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERACUTVISIBILITYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutVisibilityTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraCutVisibilityTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraCutVisibilityKeyframe {
    pub _glacier_base: super::core::DataContainer,
    pub time: f32,
    pub guid_chain: Vec<glacier_util::guid::Guid>,
}

pub trait CameraCutVisibilityKeyframeTrait: super::core::DataContainerTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn guid_chain(&self) -> &Vec<glacier_util::guid::Guid>;
    fn guid_chain_mut(&mut self) -> &mut Vec<glacier_util::guid::Guid>;
}

impl CameraCutVisibilityKeyframeTrait for CameraCutVisibilityKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn guid_chain(&self) -> &Vec<glacier_util::guid::Guid> {
        &self.guid_chain
    }
    fn guid_chain_mut(&mut self) -> &mut Vec<glacier_util::guid::Guid> {
        &mut self.guid_chain
    }
}

impl super::core::DataContainerTrait for CameraCutVisibilityKeyframe {
}

pub static CAMERACUTVISIBILITYKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutVisibilityKeyframe",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraCutVisibilityKeyframe as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraCutVisibilityKeyframe, time),
            },
            FieldInfoData {
                name: "GuidChain",
                flags: MemberInfoFlags::new(144),
                field_type: "Guid-Array",
                rust_offset: offset_of!(CameraCutVisibilityKeyframe, guid_chain),
            },
        ],
    }),
    array_type: Some(CAMERACUTVISIBILITYKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraCutVisibilityKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACUTVISIBILITYKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERACUTVISIBILITYKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraCutVisibilityKeyframe-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraCutVisibilityKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraAttachTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
}

pub trait CameraAttachTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
}

impl CameraAttachTransformLayerDataTrait for CameraAttachTransformLayerData {
}

impl super::timeline::TransformLayerDataTrait for CameraAttachTransformLayerData {
    fn weight(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CameraAttachTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraAttachTransformLayerData {
}

impl super::core::DataBusPeerTrait for CameraAttachTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraAttachTransformLayerData {
}

impl super::core::DataContainerTrait for CameraAttachTransformLayerData {
}

pub static CAMERAATTACHTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraAttachTransformLayerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraAttachTransformLayerData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CAMERAATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraAttachTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAATTACHTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraAttachTransformLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraAttachTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AttachTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub attach_entity: Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>,
    pub attach_offset: super::core::LinearTransform,
    pub child_bone_name: String,
    pub parent_bone_name: String,
    pub attach_entity_guid_chain: Vec<glacier_util::guid::Guid>,
    pub force_use_parent_trajectory_transform: bool,
}

pub trait AttachTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn attach_entity(&self) -> &Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>;
    fn attach_entity_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>;
    fn attach_offset(&self) -> &super::core::LinearTransform;
    fn attach_offset_mut(&mut self) -> &mut super::core::LinearTransform;
    fn child_bone_name(&self) -> &String;
    fn child_bone_name_mut(&mut self) -> &mut String;
    fn parent_bone_name(&self) -> &String;
    fn parent_bone_name_mut(&mut self) -> &mut String;
    fn attach_entity_guid_chain(&self) -> &Vec<glacier_util::guid::Guid>;
    fn attach_entity_guid_chain_mut(&mut self) -> &mut Vec<glacier_util::guid::Guid>;
    fn force_use_parent_trajectory_transform(&self) -> &bool;
    fn force_use_parent_trajectory_transform_mut(&mut self) -> &mut bool;
}

impl AttachTransformLayerDataTrait for AttachTransformLayerData {
    fn attach_entity(&self) -> &Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>> {
        &self.attach_entity
    }
    fn attach_entity_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>> {
        &mut self.attach_entity
    }
    fn attach_offset(&self) -> &super::core::LinearTransform {
        &self.attach_offset
    }
    fn attach_offset_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.attach_offset
    }
    fn child_bone_name(&self) -> &String {
        &self.child_bone_name
    }
    fn child_bone_name_mut(&mut self) -> &mut String {
        &mut self.child_bone_name
    }
    fn parent_bone_name(&self) -> &String {
        &self.parent_bone_name
    }
    fn parent_bone_name_mut(&mut self) -> &mut String {
        &mut self.parent_bone_name
    }
    fn attach_entity_guid_chain(&self) -> &Vec<glacier_util::guid::Guid> {
        &self.attach_entity_guid_chain
    }
    fn attach_entity_guid_chain_mut(&mut self) -> &mut Vec<glacier_util::guid::Guid> {
        &mut self.attach_entity_guid_chain
    }
    fn force_use_parent_trajectory_transform(&self) -> &bool {
        &self.force_use_parent_trajectory_transform
    }
    fn force_use_parent_trajectory_transform_mut(&mut self) -> &mut bool {
        &mut self.force_use_parent_trajectory_transform
    }
}

impl super::timeline::TransformLayerDataTrait for AttachTransformLayerData {
    fn weight(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for AttachTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for AttachTransformLayerData {
}

impl super::core::DataBusPeerTrait for AttachTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AttachTransformLayerData {
}

impl super::core::DataContainerTrait for AttachTransformLayerData {
}

pub static ATTACHTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttachTransformLayerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AttachTransformLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AttachEntity",
                flags: MemberInfoFlags::new(0),
                field_type: "GameObjectData",
                rust_offset: offset_of!(AttachTransformLayerData, attach_entity),
            },
            FieldInfoData {
                name: "AttachOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AttachTransformLayerData, attach_offset),
            },
            FieldInfoData {
                name: "ChildBoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AttachTransformLayerData, child_bone_name),
            },
            FieldInfoData {
                name: "ParentBoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AttachTransformLayerData, parent_bone_name),
            },
            FieldInfoData {
                name: "AttachEntityGuidChain",
                flags: MemberInfoFlags::new(144),
                field_type: "Guid-Array",
                rust_offset: offset_of!(AttachTransformLayerData, attach_entity_guid_chain),
            },
            FieldInfoData {
                name: "ForceUseParentTrajectoryTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AttachTransformLayerData, force_use_parent_trajectory_transform),
            },
        ],
    }),
    array_type: Some(ATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AttachTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ATTACHTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttachTransformLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AttachTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTTrajectoryTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
}

pub trait ANTTrajectoryTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
}

impl ANTTrajectoryTransformLayerDataTrait for ANTTrajectoryTransformLayerData {
}

impl super::timeline::TransformLayerDataTrait for ANTTrajectoryTransformLayerData {
    fn weight(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTTrajectoryTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTTrajectoryTransformLayerData {
}

impl super::core::DataBusPeerTrait for ANTTrajectoryTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTTrajectoryTransformLayerData {
}

impl super::core::DataContainerTrait for ANTTrajectoryTransformLayerData {
}

pub static ANTTRAJECTORYTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTTrajectoryTransformLayerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTTrajectoryTransformLayerData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANTTRAJECTORYTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTTrajectoryTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTTRAJECTORYTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTTRAJECTORYTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTTrajectoryTransformLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTTrajectoryTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTSlotTrackData {
    pub _glacier_base: super::timeline::PropertyTrackBaseData,
    pub slot_name: String,
}

pub trait ANTSlotTrackDataTrait: super::timeline::PropertyTrackBaseDataTrait {
    fn slot_name(&self) -> &String;
    fn slot_name_mut(&mut self) -> &mut String;
}

impl ANTSlotTrackDataTrait for ANTSlotTrackData {
    fn slot_name(&self) -> &String {
        &self.slot_name
    }
    fn slot_name_mut(&mut self) -> &mut String {
        &mut self.slot_name
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTSlotTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTSlotTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTSlotTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTSlotTrackData {
}

impl super::core::DataBusPeerTrait for ANTSlotTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTSlotTrackData {
}

impl super::core::DataContainerTrait for ANTSlotTrackData {
}

pub static ANTSLOTTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTSlotTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::PROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTSlotTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SlotName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ANTSlotTrackData, slot_name),
            },
        ],
    }),
    array_type: Some(ANTSLOTTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTSlotTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTSLOTTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTSLOTTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTSlotTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTSlotTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTSignalTrackData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub signal_tracks: Vec<Option<Arc<Mutex<dyn super::timeline::PropertyTrackBaseDataTrait>>>>,
}

pub trait ANTSignalTrackDataTrait: super::timeline::LinkTrackDataTrait {
    fn signal_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::PropertyTrackBaseDataTrait>>>>;
    fn signal_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::PropertyTrackBaseDataTrait>>>>;
}

impl ANTSignalTrackDataTrait for ANTSignalTrackData {
    fn signal_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::PropertyTrackBaseDataTrait>>>> {
        &self.signal_tracks
    }
    fn signal_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::PropertyTrackBaseDataTrait>>>> {
        &mut self.signal_tracks
    }
}

impl super::timeline::LinkTrackDataTrait for ANTSignalTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTSignalTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTSignalTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTSignalTrackData {
}

impl super::core::DataBusPeerTrait for ANTSignalTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTSignalTrackData {
}

impl super::core::DataContainerTrait for ANTSignalTrackData {
}

pub static ANTSIGNALTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTSignalTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTSignalTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SignalTracks",
                flags: MemberInfoFlags::new(144),
                field_type: "PropertyTrackBaseData-Array",
                rust_offset: offset_of!(ANTSignalTrackData, signal_tracks),
            },
        ],
    }),
    array_type: Some(ANTSIGNALTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTSignalTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTSIGNALTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTSIGNALTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTSignalTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTSignalTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTEnumTrackData {
    pub _glacier_base: super::timeline::PropertyTrackBaseData,
    pub keyframes: Vec<ANTEnumKeyframe>,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: i32,
}

pub trait ANTEnumTrackDataTrait: super::timeline::PropertyTrackBaseDataTrait {
    fn keyframes(&self) -> &Vec<ANTEnumKeyframe>;
    fn keyframes_mut(&mut self) -> &mut Vec<ANTEnumKeyframe>;
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &i32;
    fn reset_value_mut(&mut self) -> &mut i32;
}

impl ANTEnumTrackDataTrait for ANTEnumTrackData {
    fn keyframes(&self) -> &Vec<ANTEnumKeyframe> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<ANTEnumKeyframe> {
        &mut self.keyframes
    }
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &i32 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut i32 {
        &mut self.reset_value
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTEnumTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTEnumTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTEnumTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTEnumTrackData {
}

impl super::core::DataBusPeerTrait for ANTEnumTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTEnumTrackData {
}

impl super::core::DataContainerTrait for ANTEnumTrackData {
}

pub static ANTENUMTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEnumTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::PROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTEnumTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "ANTEnumKeyframe-Array",
                rust_offset: offset_of!(ANTEnumTrackData, keyframes),
            },
            FieldInfoData {
                name: "Signal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTEnumTrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTEnumTrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ANTEnumTrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTENUMTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTEnumTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTENUMTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTENUMTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEnumTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTEnumTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTEnumKeyframe {
    pub time: f32,
    pub value: i32,
}

pub trait ANTEnumKeyframeTrait: TypeObject {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl ANTEnumKeyframeTrait for ANTEnumKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

pub static ANTENUMKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEnumKeyframe",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTEnumKeyframe as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ANTEnumKeyframe, time),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ANTEnumKeyframe, value),
            },
        ],
    }),
    array_type: Some(ANTENUMKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ANTEnumKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        ANTENUMKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTENUMKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEnumKeyframe-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTEnumKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTVec3TrackData {
    pub _glacier_base: super::timeline::Vec3TrackData,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: super::core::Vec3,
}

pub trait ANTVec3TrackDataTrait: super::timeline::Vec3TrackDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &super::core::Vec3;
    fn reset_value_mut(&mut self) -> &mut super::core::Vec3;
}

impl ANTVec3TrackDataTrait for ANTVec3TrackData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &super::core::Vec3 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.reset_value
    }
}

impl super::timeline::Vec3TrackDataTrait for ANTVec3TrackData {
    fn x(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.x()
    }
    fn x_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.x_mut()
    }
    fn y(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.y()
    }
    fn y_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.y_mut()
    }
    fn z(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.z()
    }
    fn z_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.z_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTVec3TrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTVec3TrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTVec3TrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTVec3TrackData {
}

impl super::core::DataBusPeerTrait for ANTVec3TrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTVec3TrackData {
}

impl super::core::DataContainerTrait for ANTVec3TrackData {
}

pub static ANTVEC3TRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTVec3TrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::VEC3TRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTVec3TrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTVec3TrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTVec3TrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ANTVec3TrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTVEC3TRACKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ANTVec3TrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTVEC3TRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTVEC3TRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTVec3TrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTVec3TrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTIntTrackData {
    pub _glacier_base: super::timeline::IntTrackData,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: i32,
}

pub trait ANTIntTrackDataTrait: super::timeline::IntTrackDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &i32;
    fn reset_value_mut(&mut self) -> &mut i32;
}

impl ANTIntTrackDataTrait for ANTIntTrackData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &i32 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut i32 {
        &mut self.reset_value
    }
}

impl super::timeline::IntTrackDataTrait for ANTIntTrackData {
    fn keyframes(&self) -> &Vec<super::timeline::IntKeyframe> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<super::timeline::IntKeyframe> {
        self._glacier_base.keyframes_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTIntTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTIntTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTIntTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTIntTrackData {
}

impl super::core::DataBusPeerTrait for ANTIntTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTIntTrackData {
}

impl super::core::DataContainerTrait for ANTIntTrackData {
}

pub static ANTINTTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTIntTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::INTTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTIntTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTIntTrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTIntTrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ANTIntTrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTINTTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTIntTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTINTTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTINTTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTIntTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTIntTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTFloatTrackData {
    pub _glacier_base: super::timeline::FloatTrackData,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: f32,
}

pub trait ANTFloatTrackDataTrait: super::timeline::FloatTrackDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &f32;
    fn reset_value_mut(&mut self) -> &mut f32;
}

impl ANTFloatTrackDataTrait for ANTFloatTrackData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &f32 {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut f32 {
        &mut self.reset_value
    }
}

impl super::timeline::FloatTrackDataTrait for ANTFloatTrackData {
    fn curve_data(&self) -> &Option<Arc<Mutex<dyn super::timeline::CurveDataTrait>>> {
        self._glacier_base.curve_data()
    }
    fn curve_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::CurveDataTrait>>> {
        self._glacier_base.curve_data_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTFloatTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTFloatTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTFloatTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTFloatTrackData {
}

impl super::core::DataBusPeerTrait for ANTFloatTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTFloatTrackData {
}

impl super::core::DataContainerTrait for ANTFloatTrackData {
}

pub static ANTFLOATTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTFloatTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::FLOATTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTFloatTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTFloatTrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTFloatTrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ANTFloatTrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTFLOATTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTFloatTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTFLOATTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTFLOATTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTFloatTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTFloatTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTBoolTrackData {
    pub _glacier_base: super::timeline::BoolTrackData,
    pub signal: super::ant::AntRef,
    pub reset_on_leave: bool,
    pub reset_value: bool,
}

pub trait ANTBoolTrackDataTrait: super::timeline::BoolTrackDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn reset_on_leave(&self) -> &bool;
    fn reset_on_leave_mut(&mut self) -> &mut bool;
    fn reset_value(&self) -> &bool;
    fn reset_value_mut(&mut self) -> &mut bool;
}

impl ANTBoolTrackDataTrait for ANTBoolTrackData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn reset_on_leave(&self) -> &bool {
        &self.reset_on_leave
    }
    fn reset_on_leave_mut(&mut self) -> &mut bool {
        &mut self.reset_on_leave
    }
    fn reset_value(&self) -> &bool {
        &self.reset_value
    }
    fn reset_value_mut(&mut self) -> &mut bool {
        &mut self.reset_value
    }
}

impl super::timeline::BoolTrackDataTrait for ANTBoolTrackData {
    fn keyframes(&self) -> &Vec<super::timeline::BoolKeyframe> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<super::timeline::BoolKeyframe> {
        self._glacier_base.keyframes_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTBoolTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTBoolTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTBoolTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTBoolTrackData {
}

impl super::core::DataBusPeerTrait for ANTBoolTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTBoolTrackData {
}

impl super::core::DataContainerTrait for ANTBoolTrackData {
}

pub static ANTBOOLTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoolTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::BOOLTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTBoolTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTBoolTrackData, signal),
            },
            FieldInfoData {
                name: "ResetOnLeave",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoolTrackData, reset_on_leave),
            },
            FieldInfoData {
                name: "ResetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoolTrackData, reset_value),
            },
        ],
    }),
    array_type: Some(ANTBOOLTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTBoolTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTBOOLTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTBOOLTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoolTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTBoolTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTEvalTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub eval_data: Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>>,
}

pub trait ANTEvalTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn eval_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>>;
    fn eval_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>>;
}

impl ANTEvalTrackDataTrait for ANTEvalTrackData {
    fn eval_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>> {
        &self.eval_data
    }
    fn eval_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>> {
        &mut self.eval_data
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTEvalTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTEvalTrackData {
}

impl super::core::DataBusPeerTrait for ANTEvalTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTEvalTrackData {
}

impl super::core::DataContainerTrait for ANTEvalTrackData {
}

pub static ANTEVALTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEvalTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTEvalTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EvalData",
                flags: MemberInfoFlags::new(0),
                field_type: "ANTEvaluatorData",
                rust_offset: offset_of!(ANTEvalTrackData, eval_data),
            },
        ],
    }),
    array_type: Some(ANTEVALTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTEvalTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTEVALTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTEVALTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTEvalTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTEvalTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTControlTrackData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub eval_data: Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>>,
    pub teleport_keyframes: Vec<TeleportKeyframe>,
    pub hide_when_no_clip: bool,
    pub force_disable_animation_l_o_d: bool,
    pub allow_previous_animations_to_carry_forward: bool,
}

pub trait ANTControlTrackDataTrait: super::timeline::LinkTrackDataTrait {
    fn eval_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>>;
    fn eval_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>>;
    fn teleport_keyframes(&self) -> &Vec<TeleportKeyframe>;
    fn teleport_keyframes_mut(&mut self) -> &mut Vec<TeleportKeyframe>;
    fn hide_when_no_clip(&self) -> &bool;
    fn hide_when_no_clip_mut(&mut self) -> &mut bool;
    fn force_disable_animation_l_o_d(&self) -> &bool;
    fn force_disable_animation_l_o_d_mut(&mut self) -> &mut bool;
    fn allow_previous_animations_to_carry_forward(&self) -> &bool;
    fn allow_previous_animations_to_carry_forward_mut(&mut self) -> &mut bool;
}

impl ANTControlTrackDataTrait for ANTControlTrackData {
    fn eval_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>> {
        &self.eval_data
    }
    fn eval_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_timeline::ANTEvaluatorDataTrait>>> {
        &mut self.eval_data
    }
    fn teleport_keyframes(&self) -> &Vec<TeleportKeyframe> {
        &self.teleport_keyframes
    }
    fn teleport_keyframes_mut(&mut self) -> &mut Vec<TeleportKeyframe> {
        &mut self.teleport_keyframes
    }
    fn hide_when_no_clip(&self) -> &bool {
        &self.hide_when_no_clip
    }
    fn hide_when_no_clip_mut(&mut self) -> &mut bool {
        &mut self.hide_when_no_clip
    }
    fn force_disable_animation_l_o_d(&self) -> &bool {
        &self.force_disable_animation_l_o_d
    }
    fn force_disable_animation_l_o_d_mut(&mut self) -> &mut bool {
        &mut self.force_disable_animation_l_o_d
    }
    fn allow_previous_animations_to_carry_forward(&self) -> &bool {
        &self.allow_previous_animations_to_carry_forward
    }
    fn allow_previous_animations_to_carry_forward_mut(&mut self) -> &mut bool {
        &mut self.allow_previous_animations_to_carry_forward
    }
}

impl super::timeline::LinkTrackDataTrait for ANTControlTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTControlTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTControlTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTControlTrackData {
}

impl super::core::DataBusPeerTrait for ANTControlTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTControlTrackData {
}

impl super::core::DataContainerTrait for ANTControlTrackData {
}

pub static ANTCONTROLTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTControlTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTControlTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EvalData",
                flags: MemberInfoFlags::new(0),
                field_type: "ANTEvaluatorData",
                rust_offset: offset_of!(ANTControlTrackData, eval_data),
            },
            FieldInfoData {
                name: "TeleportKeyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "TeleportKeyframe-Array",
                rust_offset: offset_of!(ANTControlTrackData, teleport_keyframes),
            },
            FieldInfoData {
                name: "HideWhenNoClip",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTControlTrackData, hide_when_no_clip),
            },
            FieldInfoData {
                name: "ForceDisableAnimationLOD",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTControlTrackData, force_disable_animation_l_o_d),
            },
            FieldInfoData {
                name: "AllowPreviousAnimationsToCarryForward",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTControlTrackData, allow_previous_animations_to_carry_forward),
            },
        ],
    }),
    array_type: Some(ANTCONTROLTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTControlTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTCONTROLTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTCONTROLTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTControlTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTControlTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TeleportKeyframe {
    pub time: f32,
}

pub trait TeleportKeyframeTrait: TypeObject {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
}

impl TeleportKeyframeTrait for TeleportKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
}

pub static TELEPORTKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeleportKeyframe",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeleportKeyframe as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TeleportKeyframe, time),
            },
        ],
    }),
    array_type: Some(TELEPORTKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TeleportKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        TELEPORTKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TELEPORTKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeleportKeyframe-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeleportKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTBoneTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub bone_name: String,
}

pub trait ANTBoneTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
}

impl ANTBoneTransformLayerDataTrait for ANTBoneTransformLayerData {
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
}

impl super::timeline::TransformLayerDataTrait for ANTBoneTransformLayerData {
    fn weight(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTBoneTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTBoneTransformLayerData {
}

impl super::core::DataBusPeerTrait for ANTBoneTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTBoneTransformLayerData {
}

impl super::core::DataContainerTrait for ANTBoneTransformLayerData {
}

pub static ANTBONETRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneTransformLayerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTBoneTransformLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ANTBoneTransformLayerData, bone_name),
            },
        ],
    }),
    array_type: Some(ANTBONETRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTBoneTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTBONETRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTBONETRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneTransformLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTBoneTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTBoneTrackData {
    pub _glacier_base: super::timeline::LayeredTransformTrackData,
    pub bone_name: String,
    pub apply_layered_transform: bool,
    pub relative_to_parent: bool,
    pub apply90_degree_correction: bool,
}

pub trait ANTBoneTrackDataTrait: super::timeline::LayeredTransformTrackDataTrait {
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
    fn apply_layered_transform(&self) -> &bool;
    fn apply_layered_transform_mut(&mut self) -> &mut bool;
    fn relative_to_parent(&self) -> &bool;
    fn relative_to_parent_mut(&mut self) -> &mut bool;
    fn apply90_degree_correction(&self) -> &bool;
    fn apply90_degree_correction_mut(&mut self) -> &mut bool;
}

impl ANTBoneTrackDataTrait for ANTBoneTrackData {
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
    fn apply_layered_transform(&self) -> &bool {
        &self.apply_layered_transform
    }
    fn apply_layered_transform_mut(&mut self) -> &mut bool {
        &mut self.apply_layered_transform
    }
    fn relative_to_parent(&self) -> &bool {
        &self.relative_to_parent
    }
    fn relative_to_parent_mut(&mut self) -> &mut bool {
        &mut self.relative_to_parent
    }
    fn apply90_degree_correction(&self) -> &bool {
        &self.apply90_degree_correction
    }
    fn apply90_degree_correction_mut(&mut self) -> &mut bool {
        &mut self.apply90_degree_correction
    }
}

impl super::timeline::LayeredTransformTrackDataTrait for ANTBoneTrackData {
    fn layer_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TransformLayerDataTrait>>>> {
        self._glacier_base.layer_tracks()
    }
    fn layer_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TransformLayerDataTrait>>>> {
        self._glacier_base.layer_tracks_mut()
    }
    fn use_timeline_space(&self) -> &bool {
        self._glacier_base.use_timeline_space()
    }
    fn use_timeline_space_mut(&mut self) -> &mut bool {
        self._glacier_base.use_timeline_space_mut()
    }
    fn transform_space_enabled(&self) -> &bool {
        self._glacier_base.transform_space_enabled()
    }
    fn transform_space_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.transform_space_enabled_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for ANTBoneTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for ANTBoneTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTBoneTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTBoneTrackData {
}

impl super::core::DataBusPeerTrait for ANTBoneTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTBoneTrackData {
}

impl super::core::DataContainerTrait for ANTBoneTrackData {
}

pub static ANTBONETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LAYEREDTRANSFORMTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTBoneTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ANTBoneTrackData, bone_name),
            },
            FieldInfoData {
                name: "ApplyLayeredTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoneTrackData, apply_layered_transform),
            },
            FieldInfoData {
                name: "RelativeToParent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoneTrackData, relative_to_parent),
            },
            FieldInfoData {
                name: "Apply90DegreeCorrection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ANTBoneTrackData, apply90_degree_correction),
            },
        ],
    }),
    array_type: Some(ANTBONETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTBoneTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTBONETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTBONETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTBoneTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTBoneAnimationTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub layered_transform_track: Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>,
    pub ant_eval_track: Option<Arc<Mutex<dyn ANTEvalTrackDataTrait>>>,
    pub bone_tracks: Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>,
}

pub trait ANTBoneAnimationTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
    fn ant_eval_track(&self) -> &Option<Arc<Mutex<dyn ANTEvalTrackDataTrait>>>;
    fn ant_eval_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ANTEvalTrackDataTrait>>>;
    fn bone_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn bone_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
}

impl ANTBoneAnimationTrackDataTrait for ANTBoneAnimationTrackData {
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &mut self.layered_transform_track
    }
    fn ant_eval_track(&self) -> &Option<Arc<Mutex<dyn ANTEvalTrackDataTrait>>> {
        &self.ant_eval_track
    }
    fn ant_eval_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ANTEvalTrackDataTrait>>> {
        &mut self.ant_eval_track
    }
    fn bone_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &self.bone_tracks
    }
    fn bone_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &mut self.bone_tracks
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTBoneAnimationTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTBoneAnimationTrackData {
}

impl super::core::DataBusPeerTrait for ANTBoneAnimationTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTBoneAnimationTrackData {
}

impl super::core::DataContainerTrait for ANTBoneAnimationTrackData {
}

pub static ANTBONEANIMATIONTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneAnimationTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTBoneAnimationTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayeredTransformTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(ANTBoneAnimationTrackData, layered_transform_track),
            },
            FieldInfoData {
                name: "AntEvalTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "ANTEvalTrackData",
                rust_offset: offset_of!(ANTBoneAnimationTrackData, ant_eval_track),
            },
            FieldInfoData {
                name: "BoneTracks",
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(ANTBoneAnimationTrackData, bone_tracks),
            },
        ],
    }),
    array_type: Some(ANTBONEANIMATIONTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTBoneAnimationTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTBONEANIMATIONTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTBONEANIMATIONTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTBoneAnimationTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTBoneAnimationTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTAnimatableCameraTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
}

pub trait ANTAnimatableCameraTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
}

impl ANTAnimatableCameraTransformLayerDataTrait for ANTAnimatableCameraTransformLayerData {
}

impl super::timeline::TransformLayerDataTrait for ANTAnimatableCameraTransformLayerData {
    fn weight(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTAnimatableCameraTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTAnimatableCameraTransformLayerData {
}

impl super::core::DataBusPeerTrait for ANTAnimatableCameraTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTAnimatableCameraTransformLayerData {
}

impl super::core::DataContainerTrait for ANTAnimatableCameraTransformLayerData {
}

pub static ANTANIMATABLECAMERATRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTAnimatableCameraTransformLayerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTAnimatableCameraTransformLayerData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANTANIMATABLECAMERATRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTAnimatableCameraTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTANIMATABLECAMERATRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTANIMATABLECAMERATRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTAnimatableCameraTransformLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTAnimatableCameraTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ANTAnimatableCameraTrackData {
    pub _glacier_base: PhysicalCameraTrackData,
    pub layered_transform_track: Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>,
    pub ant_control_track: Option<Arc<Mutex<dyn ANTControlTrackDataTrait>>>,
    pub camera_actor: super::ant::AntRef,
}

pub trait ANTAnimatableCameraTrackDataTrait: PhysicalCameraTrackDataTrait {
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
    fn ant_control_track(&self) -> &Option<Arc<Mutex<dyn ANTControlTrackDataTrait>>>;
    fn ant_control_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ANTControlTrackDataTrait>>>;
    fn camera_actor(&self) -> &super::ant::AntRef;
    fn camera_actor_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ANTAnimatableCameraTrackDataTrait for ANTAnimatableCameraTrackData {
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &mut self.layered_transform_track
    }
    fn ant_control_track(&self) -> &Option<Arc<Mutex<dyn ANTControlTrackDataTrait>>> {
        &self.ant_control_track
    }
    fn ant_control_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ANTControlTrackDataTrait>>> {
        &mut self.ant_control_track
    }
    fn camera_actor(&self) -> &super::ant::AntRef {
        &self.camera_actor
    }
    fn camera_actor_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.camera_actor
    }
}

impl PhysicalCameraTrackDataTrait for ANTAnimatableCameraTrackData {
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children_mut()
    }
}

impl CameraTrackBaseDataTrait for ANTAnimatableCameraTrackData {
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ANTAnimatableCameraTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ANTAnimatableCameraTrackData {
}

impl super::core::DataBusPeerTrait for ANTAnimatableCameraTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ANTAnimatableCameraTrackData {
}

impl super::core::DataContainerTrait for ANTAnimatableCameraTrackData {
}

pub static ANTANIMATABLECAMERATRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTAnimatableCameraTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PHYSICALCAMERATRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ANTAnimatableCameraTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayeredTransformTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(ANTAnimatableCameraTrackData, layered_transform_track),
            },
            FieldInfoData {
                name: "AntControlTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "ANTControlTrackData",
                rust_offset: offset_of!(ANTAnimatableCameraTrackData, ant_control_track),
            },
            FieldInfoData {
                name: "CameraActor",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ANTAnimatableCameraTrackData, camera_actor),
            },
        ],
    }),
    array_type: Some(ANTANIMATABLECAMERATRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ANTAnimatableCameraTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTANIMATABLECAMERATRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTANIMATABLECAMERATRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ANTAnimatableCameraTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ANTAnimatableCameraTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationPoseTrackData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub layer_tracks: Vec<Option<Arc<Mutex<dyn AnimationPoseLayerDataTrait>>>>,
}

pub trait AnimationPoseTrackDataTrait: super::timeline::LinkTrackDataTrait {
    fn layer_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn AnimationPoseLayerDataTrait>>>>;
    fn layer_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AnimationPoseLayerDataTrait>>>>;
}

impl AnimationPoseTrackDataTrait for AnimationPoseTrackData {
    fn layer_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn AnimationPoseLayerDataTrait>>>> {
        &self.layer_tracks
    }
    fn layer_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AnimationPoseLayerDataTrait>>>> {
        &mut self.layer_tracks
    }
}

impl super::timeline::LinkTrackDataTrait for AnimationPoseTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for AnimationPoseTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for AnimationPoseTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for AnimationPoseTrackData {
}

impl super::core::DataBusPeerTrait for AnimationPoseTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationPoseTrackData {
}

impl super::core::DataContainerTrait for AnimationPoseTrackData {
}

pub static ANIMATIONPOSETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationPoseTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayerTracks",
                flags: MemberInfoFlags::new(144),
                field_type: "AnimationPoseLayerData-Array",
                rust_offset: offset_of!(AnimationPoseTrackData, layer_tracks),
            },
        ],
    }),
    array_type: Some(ANIMATIONPOSETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationPoseTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPOSETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPOSETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationPoseTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationPoseLayerRootData {
    pub _glacier_base: super::timeline::GroupTrackRootData,
    pub keyframes: Vec<Option<Arc<Mutex<dyn AnimationPoseKeyframeTrait>>>>,
}

pub trait AnimationPoseLayerRootDataTrait: super::timeline::GroupTrackRootDataTrait {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn AnimationPoseKeyframeTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AnimationPoseKeyframeTrait>>>>;
}

impl AnimationPoseLayerRootDataTrait for AnimationPoseLayerRootData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn AnimationPoseKeyframeTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AnimationPoseKeyframeTrait>>>> {
        &mut self.keyframes
    }
}

impl super::timeline::GroupTrackRootDataTrait for AnimationPoseLayerRootData {
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children()
    }
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        self._glacier_base.children_mut()
    }
}

impl super::core::AssetTrait for AnimationPoseLayerRootData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AnimationPoseLayerRootData {
}

pub static ANIMATIONPOSELAYERROOTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseLayerRootData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::GROUPTRACKROOTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationPoseLayerRootData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "AnimationPoseKeyframe-Array",
                rust_offset: offset_of!(AnimationPoseLayerRootData, keyframes),
            },
        ],
    }),
    array_type: Some(ANIMATIONPOSELAYERROOTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationPoseLayerRootData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPOSELAYERROOTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPOSELAYERROOTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseLayerRootData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationPoseLayerRootData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationPoseLayerData {
    pub _glacier_base: super::timeline::GroupTrackData,
}

pub trait AnimationPoseLayerDataTrait: super::timeline::GroupTrackDataTrait {
}

impl AnimationPoseLayerDataTrait for AnimationPoseLayerData {
}

impl super::timeline::GroupTrackDataTrait for AnimationPoseLayerData {
    fn root_data(&self) -> &Option<Arc<Mutex<dyn super::timeline::GroupTrackRootDataTrait>>> {
        self._glacier_base.root_data()
    }
    fn root_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::GroupTrackRootDataTrait>>> {
        self._glacier_base.root_data_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for AnimationPoseLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for AnimationPoseLayerData {
}

impl super::core::DataBusPeerTrait for AnimationPoseLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationPoseLayerData {
}

impl super::core::DataContainerTrait for AnimationPoseLayerData {
}

pub static ANIMATIONPOSELAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseLayerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::GROUPTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationPoseLayerData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANIMATIONPOSELAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationPoseLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPOSELAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPOSELAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationPoseLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationPoseKeyframe {
    pub _glacier_base: super::timeline::TimelineKeyframeData,
    pub time: f32,
    pub pose: Vec<Sqt>,
}

pub trait AnimationPoseKeyframeTrait: super::timeline::TimelineKeyframeDataTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn pose(&self) -> &Vec<Sqt>;
    fn pose_mut(&mut self) -> &mut Vec<Sqt>;
}

impl AnimationPoseKeyframeTrait for AnimationPoseKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn pose(&self) -> &Vec<Sqt> {
        &self.pose
    }
    fn pose_mut(&mut self) -> &mut Vec<Sqt> {
        &mut self.pose
    }
}

impl super::timeline::TimelineKeyframeDataTrait for AnimationPoseKeyframe {
}

impl super::core::DataContainerTrait for AnimationPoseKeyframe {
}

pub static ANIMATIONPOSEKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseKeyframe",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINEKEYFRAMEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationPoseKeyframe as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AnimationPoseKeyframe, time),
            },
            FieldInfoData {
                name: "Pose",
                flags: MemberInfoFlags::new(144),
                field_type: "Sqt-Array",
                rust_offset: offset_of!(AnimationPoseKeyframe, pose),
            },
        ],
    }),
    array_type: Some(ANIMATIONPOSEKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationPoseKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPOSEKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPOSEKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationPoseKeyframe-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationPoseKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Sqt {
    pub scale: super::core::Vec3,
    pub quat_value: super::core::Vec4,
    pub translation: super::core::Vec3,
}

pub trait SqtTrait: TypeObject {
    fn scale(&self) -> &super::core::Vec3;
    fn scale_mut(&mut self) -> &mut super::core::Vec3;
    fn quat_value(&self) -> &super::core::Vec4;
    fn quat_value_mut(&mut self) -> &mut super::core::Vec4;
    fn translation(&self) -> &super::core::Vec3;
    fn translation_mut(&mut self) -> &mut super::core::Vec3;
}

impl SqtTrait for Sqt {
    fn scale(&self) -> &super::core::Vec3 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.scale
    }
    fn quat_value(&self) -> &super::core::Vec4 {
        &self.quat_value
    }
    fn quat_value_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.quat_value
    }
    fn translation(&self) -> &super::core::Vec3 {
        &self.translation
    }
    fn translation_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.translation
    }
}

pub static SQT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Sqt",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Sqt as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Sqt, scale),
            },
            FieldInfoData {
                name: "QuatValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(Sqt, quat_value),
            },
            FieldInfoData {
                name: "Translation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(Sqt, translation),
            },
        ],
    }),
    array_type: Some(SQT_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for Sqt {
    fn type_info(&self) -> &'static TypeInfo {
        SQT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SQT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Sqt-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("Sqt"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3ValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait Vec3ValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl Vec3ValidatePropertyTrackDataTrait for Vec3ValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for Vec3ValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for Vec3ValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for Vec3ValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for Vec3ValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for Vec3ValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for Vec3ValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec3ValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for Vec3ValidatePropertyTrackData {
}

pub static VEC3VALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ValidatePropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3ValidatePropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3VALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3ValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3VALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3VALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3ValidatePropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("Vec3ValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Vec3RecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait Vec3RecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl Vec3RecordPropertyTrackDataTrait for Vec3RecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for Vec3RecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for Vec3RecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for Vec3RecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for Vec3RecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for Vec3RecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for Vec3RecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for Vec3RecordPropertyTrackData {
}

impl super::core::DataContainerTrait for Vec3RecordPropertyTrackData {
}

pub static VEC3RECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3RecordPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Vec3RecordPropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEC3RECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Vec3RecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VEC3RECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEC3RECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Vec3RecordPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("Vec3RecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValidateTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub children: Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>,
    pub recorded_data: Option<Arc<Mutex<dyn super::timeline::GroupTrackRootDataTrait>>>,
}

pub trait ValidateTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn recorded_data(&self) -> &Option<Arc<Mutex<dyn super::timeline::GroupTrackRootDataTrait>>>;
    fn recorded_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::GroupTrackRootDataTrait>>>;
}

impl ValidateTrackDataTrait for ValidateTrackData {
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &self.children
    }
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &mut self.children
    }
    fn recorded_data(&self) -> &Option<Arc<Mutex<dyn super::timeline::GroupTrackRootDataTrait>>> {
        &self.recorded_data
    }
    fn recorded_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::GroupTrackRootDataTrait>>> {
        &mut self.recorded_data
    }
}

impl super::timeline::TimelineTrackDataTrait for ValidateTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ValidateTrackData {
}

impl super::core::DataBusPeerTrait for ValidateTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ValidateTrackData {
}

impl super::core::DataContainerTrait for ValidateTrackData {
}

pub static VALIDATETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidateTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValidateTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Children",
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(ValidateTrackData, children),
            },
            FieldInfoData {
                name: "RecordedData",
                flags: MemberInfoFlags::new(0),
                field_type: "GroupTrackRootData",
                rust_offset: offset_of!(ValidateTrackData, recorded_data),
            },
        ],
    }),
    array_type: Some(VALIDATETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValidateTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        VALIDATETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALIDATETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidateTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ValidateTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValidatePropertyTrackBaseData {
    pub _glacier_base: super::timeline::PropertyReaderTrackBaseData,
    pub recorded_data_track: Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>,
    pub auto_generated: bool,
    pub recorded_key_time_data: glacier_reflect::builtin::ResourceRef,
    pub recorded_key_value_data: glacier_reflect::builtin::ResourceRef,
}

pub trait ValidatePropertyTrackBaseDataTrait: super::timeline::PropertyReaderTrackBaseDataTrait {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>;
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>;
    fn auto_generated(&self) -> &bool;
    fn auto_generated_mut(&mut self) -> &mut bool;
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
}

impl ValidatePropertyTrackBaseDataTrait for ValidatePropertyTrackBaseData {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        &self.recorded_data_track
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        &mut self.recorded_data_track
    }
    fn auto_generated(&self) -> &bool {
        &self.auto_generated
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        &mut self.auto_generated
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.recorded_key_time_data
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.recorded_key_time_data
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.recorded_key_value_data
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.recorded_key_value_data
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for ValidatePropertyTrackBaseData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for ValidatePropertyTrackBaseData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ValidatePropertyTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ValidatePropertyTrackBaseData {
}

impl super::core::DataBusPeerTrait for ValidatePropertyTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ValidatePropertyTrackBaseData {
}

impl super::core::DataContainerTrait for ValidatePropertyTrackBaseData {
}

pub static VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidatePropertyTrackBaseData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::PROPERTYREADERTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValidatePropertyTrackBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RecordedDataTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "TimelineTrackData",
                rust_offset: offset_of!(ValidatePropertyTrackBaseData, recorded_data_track),
            },
            FieldInfoData {
                name: "AutoGenerated",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ValidatePropertyTrackBaseData, auto_generated),
            },
            FieldInfoData {
                name: "RecordedKeyTimeData",
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(ValidatePropertyTrackBaseData, recorded_key_time_data),
            },
            FieldInfoData {
                name: "RecordedKeyValueData",
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(ValidatePropertyTrackBaseData, recorded_key_value_data),
            },
        ],
    }),
    array_type: Some(VALIDATEPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ValidatePropertyTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALIDATEPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidatePropertyTrackBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ValidatePropertyTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValidateLinkTrackBaseData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub recorded_data_track: Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>,
    pub auto_generated: bool,
    pub recorded_key_time_data: glacier_reflect::builtin::ResourceRef,
    pub recorded_key_value_data: glacier_reflect::builtin::ResourceRef,
}

pub trait ValidateLinkTrackBaseDataTrait: super::timeline::LinkTrackDataTrait {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>;
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>;
    fn auto_generated(&self) -> &bool;
    fn auto_generated_mut(&mut self) -> &mut bool;
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
}

impl ValidateLinkTrackBaseDataTrait for ValidateLinkTrackBaseData {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        &self.recorded_data_track
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        &mut self.recorded_data_track
    }
    fn auto_generated(&self) -> &bool {
        &self.auto_generated
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        &mut self.auto_generated
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.recorded_key_time_data
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.recorded_key_time_data
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.recorded_key_value_data
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.recorded_key_value_data
    }
}

impl super::timeline::LinkTrackDataTrait for ValidateLinkTrackBaseData {
}

impl super::timeline::SchematicPinTrackDataTrait for ValidateLinkTrackBaseData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for ValidateLinkTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for ValidateLinkTrackBaseData {
}

impl super::core::DataBusPeerTrait for ValidateLinkTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ValidateLinkTrackBaseData {
}

impl super::core::DataContainerTrait for ValidateLinkTrackBaseData {
}

pub static VALIDATELINKTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidateLinkTrackBaseData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValidateLinkTrackBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RecordedDataTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "TimelineTrackData",
                rust_offset: offset_of!(ValidateLinkTrackBaseData, recorded_data_track),
            },
            FieldInfoData {
                name: "AutoGenerated",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ValidateLinkTrackBaseData, auto_generated),
            },
            FieldInfoData {
                name: "RecordedKeyTimeData",
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(ValidateLinkTrackBaseData, recorded_key_time_data),
            },
            FieldInfoData {
                name: "RecordedKeyValueData",
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(ValidateLinkTrackBaseData, recorded_key_value_data),
            },
        ],
    }),
    array_type: Some(VALIDATELINKTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for ValidateLinkTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        VALIDATELINKTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALIDATELINKTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidateLinkTrackBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ValidateLinkTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait TransformValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl TransformValidatePropertyTrackDataTrait for TransformValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for TransformValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for TransformValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for TransformValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for TransformValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for TransformValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for TransformValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for TransformValidatePropertyTrackData {
}

pub static TRANSFORMVALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformValidatePropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformValidatePropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMVALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformValidatePropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TransformValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformRecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait TransformRecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl TransformRecordPropertyTrackDataTrait for TransformRecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for TransformRecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for TransformRecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for TransformRecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for TransformRecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for TransformRecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for TransformRecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformRecordPropertyTrackData {
}

impl super::core::DataContainerTrait for TransformRecordPropertyTrackData {
}

pub static TRANSFORMRECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformRecordPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformRecordPropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRANSFORMRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TransformRecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMRECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformRecordPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TransformRecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RecordTrackData {
    pub _glacier_base: super::timeline::GroupTrackData,
}

pub trait RecordTrackDataTrait: super::timeline::GroupTrackDataTrait {
}

impl RecordTrackDataTrait for RecordTrackData {
}

impl super::timeline::GroupTrackDataTrait for RecordTrackData {
    fn root_data(&self) -> &Option<Arc<Mutex<dyn super::timeline::GroupTrackRootDataTrait>>> {
        self._glacier_base.root_data()
    }
    fn root_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::GroupTrackRootDataTrait>>> {
        self._glacier_base.root_data_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordTrackData {
}

impl super::core::DataBusPeerTrait for RecordTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordTrackData {
}

impl super::core::DataContainerTrait for RecordTrackData {
}

pub static RECORDTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::GROUPTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RECORDTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TrimmedRecordingRange {
    pub start_frame: i32,
    pub end_frame: i32,
}

pub trait TrimmedRecordingRangeTrait: TypeObject {
    fn start_frame(&self) -> &i32;
    fn start_frame_mut(&mut self) -> &mut i32;
    fn end_frame(&self) -> &i32;
    fn end_frame_mut(&mut self) -> &mut i32;
}

impl TrimmedRecordingRangeTrait for TrimmedRecordingRange {
    fn start_frame(&self) -> &i32 {
        &self.start_frame
    }
    fn start_frame_mut(&mut self) -> &mut i32 {
        &mut self.start_frame
    }
    fn end_frame(&self) -> &i32 {
        &self.end_frame
    }
    fn end_frame_mut(&mut self) -> &mut i32 {
        &mut self.end_frame
    }
}

pub static TRIMMEDRECORDINGRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrimmedRecordingRange",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrimmedRecordingRange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TrimmedRecordingRange, start_frame),
            },
            FieldInfoData {
                name: "EndFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TrimmedRecordingRange, end_frame),
            },
        ],
    }),
    array_type: Some(TRIMMEDRECORDINGRANGE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TrimmedRecordingRange {
    fn type_info(&self) -> &'static TypeInfo {
        TRIMMEDRECORDINGRANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TRIMMEDRECORDINGRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrimmedRecordingRange-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrimmedRecordingRange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TrimmingRangeKeyframe {
    pub _glacier_base: super::core::DataContainer,
    pub time: f32,
    pub length: f32,
}

pub trait TrimmingRangeKeyframeTrait: super::core::DataContainerTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
}

impl TrimmingRangeKeyframeTrait for TrimmingRangeKeyframe {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
}

impl super::core::DataContainerTrait for TrimmingRangeKeyframe {
}

pub static TRIMMINGRANGEKEYFRAME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrimmingRangeKeyframe",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrimmingRangeKeyframe as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrimmingRangeKeyframe, time),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrimmingRangeKeyframe, length),
            },
        ],
    }),
    array_type: Some(TRIMMINGRANGEKEYFRAME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TrimmingRangeKeyframe {
    fn type_info(&self) -> &'static TypeInfo {
        TRIMMINGRANGEKEYFRAME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRIMMINGRANGEKEYFRAME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrimmingRangeKeyframe-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrimmingRangeKeyframe"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RecordLinkTrackBaseData {
    pub _glacier_base: super::timeline::LinkTrackData,
    pub keyframes: Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>>,
    pub trimmed_recording_ranges: Vec<TrimmedRecordingRange>,
}

pub trait RecordLinkTrackBaseDataTrait: super::timeline::LinkTrackDataTrait {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>>;
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange>;
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange>;
}

impl RecordLinkTrackBaseDataTrait for RecordLinkTrackBaseData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        &mut self.keyframes
    }
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange> {
        &self.trimmed_recording_ranges
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange> {
        &mut self.trimmed_recording_ranges
    }
}

impl super::timeline::LinkTrackDataTrait for RecordLinkTrackBaseData {
}

impl super::timeline::SchematicPinTrackDataTrait for RecordLinkTrackBaseData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordLinkTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordLinkTrackBaseData {
}

impl super::core::DataBusPeerTrait for RecordLinkTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordLinkTrackBaseData {
}

impl super::core::DataContainerTrait for RecordLinkTrackBaseData {
}

pub static RECORDLINKTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordLinkTrackBaseData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LINKTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordLinkTrackBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "TrimmingRangeKeyframe-Array",
                rust_offset: offset_of!(RecordLinkTrackBaseData, keyframes),
            },
            FieldInfoData {
                name: "TrimmedRecordingRanges",
                flags: MemberInfoFlags::new(144),
                field_type: "TrimmedRecordingRange-Array",
                rust_offset: offset_of!(RecordLinkTrackBaseData, trimmed_recording_ranges),
            },
        ],
    }),
    array_type: Some(RECORDLINKTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RecordLinkTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDLINKTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDLINKTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordLinkTrackBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordLinkTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RecordPropertyTrackBaseData {
    pub _glacier_base: super::timeline::PropertyReaderTrackBaseData,
    pub keyframes: Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>>,
    pub trimmed_recording_ranges: Vec<TrimmedRecordingRange>,
}

pub trait RecordPropertyTrackBaseDataTrait: super::timeline::PropertyReaderTrackBaseDataTrait {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>>;
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange>;
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange>;
}

impl RecordPropertyTrackBaseDataTrait for RecordPropertyTrackBaseData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        &mut self.keyframes
    }
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange> {
        &self.trimmed_recording_ranges
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange> {
        &mut self.trimmed_recording_ranges
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for RecordPropertyTrackBaseData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for RecordPropertyTrackBaseData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordPropertyTrackBaseData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordPropertyTrackBaseData {
}

impl super::core::DataBusPeerTrait for RecordPropertyTrackBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordPropertyTrackBaseData {
}

impl super::core::DataContainerTrait for RecordPropertyTrackBaseData {
}

pub static RECORDPROPERTYTRACKBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordPropertyTrackBaseData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::PROPERTYREADERTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordPropertyTrackBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "TrimmingRangeKeyframe-Array",
                rust_offset: offset_of!(RecordPropertyTrackBaseData, keyframes),
            },
            FieldInfoData {
                name: "TrimmedRecordingRanges",
                flags: MemberInfoFlags::new(144),
                field_type: "TrimmedRecordingRange-Array",
                rust_offset: offset_of!(RecordPropertyTrackBaseData, trimmed_recording_ranges),
            },
        ],
    }),
    array_type: Some(RECORDPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RecordPropertyTrackBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDPROPERTYTRACKBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDPROPERTYTRACKBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordPropertyTrackBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordPropertyTrackBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterPoseValidateTrackData {
    pub _glacier_base: PoseValidateTrackData,
}

pub trait CharacterPoseValidateTrackDataTrait: PoseValidateTrackDataTrait {
}

impl CharacterPoseValidateTrackDataTrait for CharacterPoseValidateTrackData {
}

impl PoseValidateTrackDataTrait for CharacterPoseValidateTrackData {
}

impl ValidateLinkTrackBaseDataTrait for CharacterPoseValidateTrackData {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for CharacterPoseValidateTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for CharacterPoseValidateTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CharacterPoseValidateTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterPoseValidateTrackData {
}

impl super::core::DataBusPeerTrait for CharacterPoseValidateTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterPoseValidateTrackData {
}

impl super::core::DataContainerTrait for CharacterPoseValidateTrackData {
}

pub static CHARACTERPOSEVALIDATETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseValidateTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(POSEVALIDATETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterPoseValidateTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERPOSEVALIDATETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterPoseValidateTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERPOSEVALIDATETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERPOSEVALIDATETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseValidateTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterPoseValidateTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PoseValidateTrackData {
    pub _glacier_base: ValidateLinkTrackBaseData,
}

pub trait PoseValidateTrackDataTrait: ValidateLinkTrackBaseDataTrait {
}

impl PoseValidateTrackDataTrait for PoseValidateTrackData {
}

impl ValidateLinkTrackBaseDataTrait for PoseValidateTrackData {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for PoseValidateTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for PoseValidateTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for PoseValidateTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for PoseValidateTrackData {
}

impl super::core::DataBusPeerTrait for PoseValidateTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PoseValidateTrackData {
}

impl super::core::DataContainerTrait for PoseValidateTrackData {
}

pub static POSEVALIDATETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseValidateTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATELINKTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PoseValidateTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(POSEVALIDATETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PoseValidateTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        POSEVALIDATETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static POSEVALIDATETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseValidateTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PoseValidateTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterPoseRecordTrackData {
    pub _glacier_base: PoseRecordTrackData,
}

pub trait CharacterPoseRecordTrackDataTrait: PoseRecordTrackDataTrait {
}

impl CharacterPoseRecordTrackDataTrait for CharacterPoseRecordTrackData {
}

impl PoseRecordTrackDataTrait for CharacterPoseRecordTrackData {
    fn bones_to_record(&self) -> &super::entity::BoneSelection {
        self._glacier_base.bones_to_record()
    }
    fn bones_to_record_mut(&mut self) -> &mut super::entity::BoneSelection {
        self._glacier_base.bones_to_record_mut()
    }
}

impl RecordLinkTrackBaseDataTrait for CharacterPoseRecordTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for CharacterPoseRecordTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for CharacterPoseRecordTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for CharacterPoseRecordTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterPoseRecordTrackData {
}

impl super::core::DataBusPeerTrait for CharacterPoseRecordTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterPoseRecordTrackData {
}

impl super::core::DataContainerTrait for CharacterPoseRecordTrackData {
}

pub static CHARACTERPOSERECORDTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseRecordTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(POSERECORDTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterPoseRecordTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERPOSERECORDTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterPoseRecordTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERPOSERECORDTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERPOSERECORDTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseRecordTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterPoseRecordTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PoseRecordTrackData {
    pub _glacier_base: RecordLinkTrackBaseData,
    pub bones_to_record: super::entity::BoneSelection,
}

pub trait PoseRecordTrackDataTrait: RecordLinkTrackBaseDataTrait {
    fn bones_to_record(&self) -> &super::entity::BoneSelection;
    fn bones_to_record_mut(&mut self) -> &mut super::entity::BoneSelection;
}

impl PoseRecordTrackDataTrait for PoseRecordTrackData {
    fn bones_to_record(&self) -> &super::entity::BoneSelection {
        &self.bones_to_record
    }
    fn bones_to_record_mut(&mut self) -> &mut super::entity::BoneSelection {
        &mut self.bones_to_record
    }
}

impl RecordLinkTrackBaseDataTrait for PoseRecordTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for PoseRecordTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for PoseRecordTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for PoseRecordTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for PoseRecordTrackData {
}

impl super::core::DataBusPeerTrait for PoseRecordTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PoseRecordTrackData {
}

impl super::core::DataContainerTrait for PoseRecordTrackData {
}

pub static POSERECORDTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseRecordTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDLINKTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PoseRecordTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BonesToRecord",
                flags: MemberInfoFlags::new(0),
                field_type: "BoneSelection",
                rust_offset: offset_of!(PoseRecordTrackData, bones_to_record),
            },
        ],
    }),
    array_type: Some(POSERECORDTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for PoseRecordTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        POSERECORDTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static POSERECORDTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseRecordTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PoseRecordTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait IntValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl IntValidatePropertyTrackDataTrait for IntValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for IntValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for IntValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for IntValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for IntValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for IntValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for IntValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for IntValidatePropertyTrackData {
}

pub static INTVALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntValidatePropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntValidatePropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        INTVALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntValidatePropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntRecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait IntRecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl IntRecordPropertyTrackDataTrait for IntRecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for IntRecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for IntRecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for IntRecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for IntRecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for IntRecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for IntRecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntRecordPropertyTrackData {
}

impl super::core::DataContainerTrait for IntRecordPropertyTrackData {
}

pub static INTRECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntRecordPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntRecordPropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntRecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        INTRECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntRecordPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntRecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait FloatValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl FloatValidatePropertyTrackDataTrait for FloatValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for FloatValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for FloatValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for FloatValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for FloatValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for FloatValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for FloatValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for FloatValidatePropertyTrackData {
}

pub static FLOATVALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatValidatePropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatValidatePropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATVALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatValidatePropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FloatValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteAntGameStateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub ant_game_states: Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>>,
    pub write_continuously: bool,
    pub write_once_on_spawn: bool,
    pub write_on_property_changed: bool,
    pub num_properties: i32,
    pub num_ant_assets: i32,
}

pub trait WriteAntGameStateEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn ant_game_states(&self) -> &Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>>;
    fn ant_game_states_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>>;
    fn write_continuously(&self) -> &bool;
    fn write_continuously_mut(&mut self) -> &mut bool;
    fn write_once_on_spawn(&self) -> &bool;
    fn write_once_on_spawn_mut(&mut self) -> &mut bool;
    fn write_on_property_changed(&self) -> &bool;
    fn write_on_property_changed_mut(&mut self) -> &mut bool;
    fn num_properties(&self) -> &i32;
    fn num_properties_mut(&mut self) -> &mut i32;
    fn num_ant_assets(&self) -> &i32;
    fn num_ant_assets_mut(&mut self) -> &mut i32;
}

impl WriteAntGameStateEntityDataTrait for WriteAntGameStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn ant_game_states(&self) -> &Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>> {
        &self.ant_game_states
    }
    fn ant_game_states_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>> {
        &mut self.ant_game_states
    }
    fn write_continuously(&self) -> &bool {
        &self.write_continuously
    }
    fn write_continuously_mut(&mut self) -> &mut bool {
        &mut self.write_continuously
    }
    fn write_once_on_spawn(&self) -> &bool {
        &self.write_once_on_spawn
    }
    fn write_once_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.write_once_on_spawn
    }
    fn write_on_property_changed(&self) -> &bool {
        &self.write_on_property_changed
    }
    fn write_on_property_changed_mut(&mut self) -> &mut bool {
        &mut self.write_on_property_changed
    }
    fn num_properties(&self) -> &i32 {
        &self.num_properties
    }
    fn num_properties_mut(&mut self) -> &mut i32 {
        &mut self.num_properties
    }
    fn num_ant_assets(&self) -> &i32 {
        &self.num_ant_assets
    }
    fn num_ant_assets_mut(&mut self) -> &mut i32 {
        &mut self.num_ant_assets
    }
}

impl super::entity::EntityDataTrait for WriteAntGameStateEntityData {
}

impl super::entity::GameObjectDataTrait for WriteAntGameStateEntityData {
}

impl super::core::DataBusPeerTrait for WriteAntGameStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WriteAntGameStateEntityData {
}

impl super::core::DataContainerTrait for WriteAntGameStateEntityData {
}

pub static WRITEANTGAMESTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteAntGameStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteAntGameStateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WriteAntGameStateEntityData, realm),
            },
            FieldInfoData {
                name: "AntGameStates",
                flags: MemberInfoFlags::new(144),
                field_type: "WriteAntGameStateData-Array",
                rust_offset: offset_of!(WriteAntGameStateEntityData, ant_game_states),
            },
            FieldInfoData {
                name: "WriteContinuously",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WriteAntGameStateEntityData, write_continuously),
            },
            FieldInfoData {
                name: "WriteOnceOnSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WriteAntGameStateEntityData, write_once_on_spawn),
            },
            FieldInfoData {
                name: "WriteOnPropertyChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WriteAntGameStateEntityData, write_on_property_changed),
            },
            FieldInfoData {
                name: "NumProperties",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteAntGameStateEntityData, num_properties),
            },
            FieldInfoData {
                name: "NumAntAssets",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteAntGameStateEntityData, num_ant_assets),
            },
        ],
    }),
    array_type: Some(WRITEANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteAntGameStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEANTGAMESTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteAntGameStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteAntGameStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadAntGameStateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub ant_game_states: Vec<Option<Arc<Mutex<dyn ReadAntGameStateDataTrait>>>>,
    pub start_reading_continously_on_spawn: bool,
    pub read_once_on_spawn: bool,
    pub num_properties: i32,
    pub num_ant_assets: i32,
}

pub trait ReadAntGameStateEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn ant_game_states(&self) -> &Vec<Option<Arc<Mutex<dyn ReadAntGameStateDataTrait>>>>;
    fn ant_game_states_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ReadAntGameStateDataTrait>>>>;
    fn start_reading_continously_on_spawn(&self) -> &bool;
    fn start_reading_continously_on_spawn_mut(&mut self) -> &mut bool;
    fn read_once_on_spawn(&self) -> &bool;
    fn read_once_on_spawn_mut(&mut self) -> &mut bool;
    fn num_properties(&self) -> &i32;
    fn num_properties_mut(&mut self) -> &mut i32;
    fn num_ant_assets(&self) -> &i32;
    fn num_ant_assets_mut(&mut self) -> &mut i32;
}

impl ReadAntGameStateEntityDataTrait for ReadAntGameStateEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn ant_game_states(&self) -> &Vec<Option<Arc<Mutex<dyn ReadAntGameStateDataTrait>>>> {
        &self.ant_game_states
    }
    fn ant_game_states_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ReadAntGameStateDataTrait>>>> {
        &mut self.ant_game_states
    }
    fn start_reading_continously_on_spawn(&self) -> &bool {
        &self.start_reading_continously_on_spawn
    }
    fn start_reading_continously_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.start_reading_continously_on_spawn
    }
    fn read_once_on_spawn(&self) -> &bool {
        &self.read_once_on_spawn
    }
    fn read_once_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.read_once_on_spawn
    }
    fn num_properties(&self) -> &i32 {
        &self.num_properties
    }
    fn num_properties_mut(&mut self) -> &mut i32 {
        &mut self.num_properties
    }
    fn num_ant_assets(&self) -> &i32 {
        &self.num_ant_assets
    }
    fn num_ant_assets_mut(&mut self) -> &mut i32 {
        &mut self.num_ant_assets
    }
}

impl super::entity::EntityDataTrait for ReadAntGameStateEntityData {
}

impl super::entity::GameObjectDataTrait for ReadAntGameStateEntityData {
}

impl super::core::DataBusPeerTrait for ReadAntGameStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReadAntGameStateEntityData {
}

impl super::core::DataContainerTrait for ReadAntGameStateEntityData {
}

pub static READANTGAMESTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadAntGameStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadAntGameStateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ReadAntGameStateEntityData, realm),
            },
            FieldInfoData {
                name: "AntGameStates",
                flags: MemberInfoFlags::new(144),
                field_type: "ReadAntGameStateData-Array",
                rust_offset: offset_of!(ReadAntGameStateEntityData, ant_game_states),
            },
            FieldInfoData {
                name: "StartReadingContinouslyOnSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReadAntGameStateEntityData, start_reading_continously_on_spawn),
            },
            FieldInfoData {
                name: "ReadOnceOnSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ReadAntGameStateEntityData, read_once_on_spawn),
            },
            FieldInfoData {
                name: "NumProperties",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ReadAntGameStateEntityData, num_properties),
            },
            FieldInfoData {
                name: "NumAntAssets",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ReadAntGameStateEntityData, num_ant_assets),
            },
        ],
    }),
    array_type: Some(READANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadAntGameStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        READANTGAMESTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READANTGAMESTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadAntGameStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadAntGameStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteVector3AndQuaternionGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state_vec: super::ant::AntRef,
    pub game_state_quat: super::ant::AntRef,
    pub value: super::core::LinearTransform,
}

pub trait WriteVector3AndQuaternionGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state_vec(&self) -> &super::ant::AntRef;
    fn game_state_vec_mut(&mut self) -> &mut super::ant::AntRef;
    fn game_state_quat(&self) -> &super::ant::AntRef;
    fn game_state_quat_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &super::core::LinearTransform;
    fn value_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl WriteVector3AndQuaternionGameStateTrait for WriteVector3AndQuaternionGameState {
    fn game_state_vec(&self) -> &super::ant::AntRef {
        &self.game_state_vec
    }
    fn game_state_vec_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state_vec
    }
    fn game_state_quat(&self) -> &super::ant::AntRef {
        &self.game_state_quat
    }
    fn game_state_quat_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state_quat
    }
    fn value(&self) -> &super::core::LinearTransform {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteVector3AndQuaternionGameState {
}

impl AntGameStateDataTrait for WriteVector3AndQuaternionGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteVector3AndQuaternionGameState {
}

pub static WRITEVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3AndQuaternionGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVector3AndQuaternionGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameStateVec",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteVector3AndQuaternionGameState, game_state_vec),
            },
            FieldInfoData {
                name: "GameStateQuat",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteVector3AndQuaternionGameState, game_state_quat),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WriteVector3AndQuaternionGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WriteVector3AndQuaternionGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3AndQuaternionGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteVector3AndQuaternionGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteVector3TransformGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: super::core::LinearTransform,
}

pub trait WriteVector3TransformGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &super::core::LinearTransform;
    fn value_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl WriteVector3TransformGameStateTrait for WriteVector3TransformGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &super::core::LinearTransform {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteVector3TransformGameState {
}

impl AntGameStateDataTrait for WriteVector3TransformGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteVector3TransformGameState {
}

pub static WRITEVECTOR3TRANSFORMGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3TransformGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVector3TransformGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteVector3TransformGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WriteVector3TransformGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WriteVector3TransformGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVECTOR3TRANSFORMGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3TransformGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteVector3TransformGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteVector3GameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: super::core::Vec3,
}

pub trait WriteVector3GameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &super::core::Vec3;
    fn value_mut(&mut self) -> &mut super::core::Vec3;
}

impl WriteVector3GameStateTrait for WriteVector3GameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &super::core::Vec3 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteVector3GameState {
}

impl AntGameStateDataTrait for WriteVector3GameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteVector3GameState {
}

pub static WRITEVECTOR3GAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3GameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteVector3GameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteVector3GameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(WriteVector3GameState, value),
            },
        ],
    }),
    array_type: Some(WRITEVECTOR3GAMESTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WriteVector3GameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEVECTOR3GAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEVECTOR3GAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteVector3GameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteVector3GameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteQuaternionGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: super::core::LinearTransform,
}

pub trait WriteQuaternionGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &super::core::LinearTransform;
    fn value_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl WriteQuaternionGameStateTrait for WriteQuaternionGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &super::core::LinearTransform {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteQuaternionGameState {
}

impl AntGameStateDataTrait for WriteQuaternionGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteQuaternionGameState {
}

pub static WRITEQUATERNIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteQuaternionGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteQuaternionGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteQuaternionGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WriteQuaternionGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEQUATERNIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WriteQuaternionGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEQUATERNIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEQUATERNIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteQuaternionGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteQuaternionGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteBoolGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: bool,
}

pub trait WriteBoolGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &bool;
    fn value_mut(&mut self) -> &mut bool;
}

impl WriteBoolGameStateTrait for WriteBoolGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &bool {
        &self.value
    }
    fn value_mut(&mut self) -> &mut bool {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteBoolGameState {
}

impl AntGameStateDataTrait for WriteBoolGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteBoolGameState {
}

pub static WRITEBOOLGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteBoolGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteBoolGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteBoolGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WriteBoolGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEBOOLGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteBoolGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEBOOLGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEBOOLGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteBoolGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteBoolGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteIntGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: i32,
}

pub trait WriteIntGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl WriteIntGameStateTrait for WriteIntGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteIntGameState {
}

impl AntGameStateDataTrait for WriteIntGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteIntGameState {
}

pub static WRITEINTGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteIntGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteIntGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteIntGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteIntGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEINTGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteIntGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEINTGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEINTGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteIntGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteIntGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteFloatGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: f32,
}

pub trait WriteFloatGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl WriteFloatGameStateTrait for WriteFloatGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteFloatGameState {
}

impl AntGameStateDataTrait for WriteFloatGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteFloatGameState {
}

pub static WRITEFLOATGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteFloatGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteFloatGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteFloatGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WriteFloatGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEFLOATGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteFloatGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEFLOATGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEFLOATGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteFloatGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteFloatGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteEnumerationGameState {
    pub _glacier_base: WriteAntGameStateData,
    pub game_state: super::ant::AntRef,
    pub value: i32,
}

pub trait WriteEnumerationGameStateTrait: WriteAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl WriteEnumerationGameStateTrait for WriteEnumerationGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

impl WriteAntGameStateDataTrait for WriteEnumerationGameState {
}

impl AntGameStateDataTrait for WriteEnumerationGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteEnumerationGameState {
}

pub static WRITEENUMERATIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteEnumerationGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WRITEANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteEnumerationGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WriteEnumerationGameState, game_state),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WriteEnumerationGameState, value),
            },
        ],
    }),
    array_type: Some(WRITEENUMERATIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteEnumerationGameState {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEENUMERATIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEENUMERATIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteEnumerationGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteEnumerationGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadVector3AndQuaternionGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state_vec: super::ant::AntRef,
    pub game_state_quat: super::ant::AntRef,
}

pub trait ReadVector3AndQuaternionGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state_vec(&self) -> &super::ant::AntRef;
    fn game_state_vec_mut(&mut self) -> &mut super::ant::AntRef;
    fn game_state_quat(&self) -> &super::ant::AntRef;
    fn game_state_quat_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadVector3AndQuaternionGameStateTrait for ReadVector3AndQuaternionGameState {
    fn game_state_vec(&self) -> &super::ant::AntRef {
        &self.game_state_vec
    }
    fn game_state_vec_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state_vec
    }
    fn game_state_quat(&self) -> &super::ant::AntRef {
        &self.game_state_quat
    }
    fn game_state_quat_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state_quat
    }
}

impl ReadAntGameStateDataTrait for ReadVector3AndQuaternionGameState {
}

impl AntGameStateDataTrait for ReadVector3AndQuaternionGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadVector3AndQuaternionGameState {
}

pub static READVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3AndQuaternionGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVector3AndQuaternionGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameStateVec",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadVector3AndQuaternionGameState, game_state_vec),
            },
            FieldInfoData {
                name: "GameStateQuat",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadVector3AndQuaternionGameState, game_state_quat),
            },
        ],
    }),
    array_type: Some(READVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVector3AndQuaternionGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READVECTOR3ANDQUATERNIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READVECTOR3ANDQUATERNIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3AndQuaternionGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadVector3AndQuaternionGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadQuaternionGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadQuaternionGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadQuaternionGameStateTrait for ReadQuaternionGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadQuaternionGameState {
}

impl AntGameStateDataTrait for ReadQuaternionGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadQuaternionGameState {
}

pub static READQUATERNIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadQuaternionGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadQuaternionGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadQuaternionGameState, game_state),
            },
        ],
    }),
    array_type: Some(READQUATERNIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadQuaternionGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READQUATERNIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READQUATERNIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadQuaternionGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadQuaternionGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadVector3TransformGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadVector3TransformGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadVector3TransformGameStateTrait for ReadVector3TransformGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadVector3TransformGameState {
}

impl AntGameStateDataTrait for ReadVector3TransformGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadVector3TransformGameState {
}

pub static READVECTOR3TRANSFORMGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3TransformGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVector3TransformGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadVector3TransformGameState, game_state),
            },
        ],
    }),
    array_type: Some(READVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVector3TransformGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READVECTOR3TRANSFORMGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READVECTOR3TRANSFORMGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3TransformGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadVector3TransformGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadVector3GameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadVector3GameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadVector3GameStateTrait for ReadVector3GameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadVector3GameState {
}

impl AntGameStateDataTrait for ReadVector3GameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadVector3GameState {
}

pub static READVECTOR3GAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3GameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadVector3GameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadVector3GameState, game_state),
            },
        ],
    }),
    array_type: Some(READVECTOR3GAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadVector3GameState {
    fn type_info(&self) -> &'static TypeInfo {
        READVECTOR3GAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READVECTOR3GAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadVector3GameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadVector3GameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadBoolGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadBoolGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadBoolGameStateTrait for ReadBoolGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadBoolGameState {
}

impl AntGameStateDataTrait for ReadBoolGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadBoolGameState {
}

pub static READBOOLGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadBoolGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadBoolGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadBoolGameState, game_state),
            },
        ],
    }),
    array_type: Some(READBOOLGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadBoolGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READBOOLGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READBOOLGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadBoolGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadBoolGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadIntGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadIntGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadIntGameStateTrait for ReadIntGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadIntGameState {
}

impl AntGameStateDataTrait for ReadIntGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadIntGameState {
}

pub static READINTGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadIntGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadIntGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadIntGameState, game_state),
            },
        ],
    }),
    array_type: Some(READINTGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadIntGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READINTGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READINTGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadIntGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadIntGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadFloatGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadFloatGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadFloatGameStateTrait for ReadFloatGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadFloatGameState {
}

impl AntGameStateDataTrait for ReadFloatGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadFloatGameState {
}

pub static READFLOATGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadFloatGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadFloatGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadFloatGameState, game_state),
            },
        ],
    }),
    array_type: Some(READFLOATGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadFloatGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READFLOATGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READFLOATGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadFloatGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadFloatGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadEnumerationGameState {
    pub _glacier_base: ReadAntGameStateData,
    pub game_state: super::ant::AntRef,
}

pub trait ReadEnumerationGameStateTrait: ReadAntGameStateDataTrait {
    fn game_state(&self) -> &super::ant::AntRef;
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl ReadEnumerationGameStateTrait for ReadEnumerationGameState {
    fn game_state(&self) -> &super::ant::AntRef {
        &self.game_state
    }
    fn game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.game_state
    }
}

impl ReadAntGameStateDataTrait for ReadEnumerationGameState {
}

impl AntGameStateDataTrait for ReadEnumerationGameState {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadEnumerationGameState {
}

pub static READENUMERATIONGAMESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadEnumerationGameState",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(READANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadEnumerationGameState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ReadEnumerationGameState, game_state),
            },
        ],
    }),
    array_type: Some(READENUMERATIONGAMESTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadEnumerationGameState {
    fn type_info(&self) -> &'static TypeInfo {
        READENUMERATIONGAMESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READENUMERATIONGAMESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadEnumerationGameState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadEnumerationGameState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WriteAntGameStateData {
    pub _glacier_base: AntGameStateData,
}

pub trait WriteAntGameStateDataTrait: AntGameStateDataTrait {
}

impl WriteAntGameStateDataTrait for WriteAntGameStateData {
}

impl AntGameStateDataTrait for WriteAntGameStateData {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for WriteAntGameStateData {
}

pub static WRITEANTGAMESTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteAntGameStateData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WriteAntGameStateData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WRITEANTGAMESTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WriteAntGameStateData {
    fn type_info(&self) -> &'static TypeInfo {
        WRITEANTGAMESTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WRITEANTGAMESTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WriteAntGameStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WriteAntGameStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReadAntGameStateData {
    pub _glacier_base: AntGameStateData,
}

pub trait ReadAntGameStateDataTrait: AntGameStateDataTrait {
}

impl ReadAntGameStateDataTrait for ReadAntGameStateData {
}

impl AntGameStateDataTrait for ReadAntGameStateData {
    fn property_hash(&self) -> &i32 {
        self._glacier_base.property_hash()
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.property_hash_mut()
    }
}

impl super::core::DataContainerTrait for ReadAntGameStateData {
}

pub static READANTGAMESTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadAntGameStateData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ANTGAMESTATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReadAntGameStateData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(READANTGAMESTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReadAntGameStateData {
    fn type_info(&self) -> &'static TypeInfo {
        READANTGAMESTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static READANTGAMESTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReadAntGameStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReadAntGameStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AntGameStateData {
    pub _glacier_base: super::core::DataContainer,
    pub property_hash: i32,
}

pub trait AntGameStateDataTrait: super::core::DataContainerTrait {
    fn property_hash(&self) -> &i32;
    fn property_hash_mut(&mut self) -> &mut i32;
}

impl AntGameStateDataTrait for AntGameStateData {
    fn property_hash(&self) -> &i32 {
        &self.property_hash
    }
    fn property_hash_mut(&mut self) -> &mut i32 {
        &mut self.property_hash
    }
}

impl super::core::DataContainerTrait for AntGameStateData {
}

pub static ANTGAMESTATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntGameStateData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntGameStateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PropertyHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AntGameStateData, property_hash),
            },
        ],
    }),
    array_type: Some(ANTGAMESTATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AntGameStateData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTGAMESTATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTGAMESTATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntGameStateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntGameStateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AntEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub require_link: bool,
    pub send_as_player_event: bool,
    pub on_enter_events: Vec<AntEventData>,
    pub on_update_events: Vec<AntEventData>,
    pub on_leave_events: Vec<AntEventData>,
    pub auto_activate: bool,
}

pub trait AntEventEntityDataTrait: super::entity::EntityDataTrait {
    fn require_link(&self) -> &bool;
    fn require_link_mut(&mut self) -> &mut bool;
    fn send_as_player_event(&self) -> &bool;
    fn send_as_player_event_mut(&mut self) -> &mut bool;
    fn on_enter_events(&self) -> &Vec<AntEventData>;
    fn on_enter_events_mut(&mut self) -> &mut Vec<AntEventData>;
    fn on_update_events(&self) -> &Vec<AntEventData>;
    fn on_update_events_mut(&mut self) -> &mut Vec<AntEventData>;
    fn on_leave_events(&self) -> &Vec<AntEventData>;
    fn on_leave_events_mut(&mut self) -> &mut Vec<AntEventData>;
    fn auto_activate(&self) -> &bool;
    fn auto_activate_mut(&mut self) -> &mut bool;
}

impl AntEventEntityDataTrait for AntEventEntityData {
    fn require_link(&self) -> &bool {
        &self.require_link
    }
    fn require_link_mut(&mut self) -> &mut bool {
        &mut self.require_link
    }
    fn send_as_player_event(&self) -> &bool {
        &self.send_as_player_event
    }
    fn send_as_player_event_mut(&mut self) -> &mut bool {
        &mut self.send_as_player_event
    }
    fn on_enter_events(&self) -> &Vec<AntEventData> {
        &self.on_enter_events
    }
    fn on_enter_events_mut(&mut self) -> &mut Vec<AntEventData> {
        &mut self.on_enter_events
    }
    fn on_update_events(&self) -> &Vec<AntEventData> {
        &self.on_update_events
    }
    fn on_update_events_mut(&mut self) -> &mut Vec<AntEventData> {
        &mut self.on_update_events
    }
    fn on_leave_events(&self) -> &Vec<AntEventData> {
        &self.on_leave_events
    }
    fn on_leave_events_mut(&mut self) -> &mut Vec<AntEventData> {
        &mut self.on_leave_events
    }
    fn auto_activate(&self) -> &bool {
        &self.auto_activate
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        &mut self.auto_activate
    }
}

impl super::entity::EntityDataTrait for AntEventEntityData {
}

impl super::entity::GameObjectDataTrait for AntEventEntityData {
}

impl super::core::DataBusPeerTrait for AntEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AntEventEntityData {
}

impl super::core::DataContainerTrait for AntEventEntityData {
}

pub static ANTEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RequireLink",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntEventEntityData, require_link),
            },
            FieldInfoData {
                name: "SendAsPlayerEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntEventEntityData, send_as_player_event),
            },
            FieldInfoData {
                name: "OnEnterEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "AntEventData-Array",
                rust_offset: offset_of!(AntEventEntityData, on_enter_events),
            },
            FieldInfoData {
                name: "OnUpdateEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "AntEventData-Array",
                rust_offset: offset_of!(AntEventEntityData, on_update_events),
            },
            FieldInfoData {
                name: "OnLeaveEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "AntEventData-Array",
                rust_offset: offset_of!(AntEventEntityData, on_leave_events),
            },
            FieldInfoData {
                name: "AutoActivate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntEventEntityData, auto_activate),
            },
        ],
    }),
    array_type: Some(ANTEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AntEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AntEventData {
    pub tag_id: i32,
    pub event: super::entity::EventSpec,
}

pub trait AntEventDataTrait: TypeObject {
    fn tag_id(&self) -> &i32;
    fn tag_id_mut(&mut self) -> &mut i32;
    fn event(&self) -> &super::entity::EventSpec;
    fn event_mut(&mut self) -> &mut super::entity::EventSpec;
}

impl AntEventDataTrait for AntEventData {
    fn tag_id(&self) -> &i32 {
        &self.tag_id
    }
    fn tag_id_mut(&mut self) -> &mut i32 {
        &mut self.tag_id
    }
    fn event(&self) -> &super::entity::EventSpec {
        &self.event
    }
    fn event_mut(&mut self) -> &mut super::entity::EventSpec {
        &mut self.event
    }
}

pub static ANTEVENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEventData",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntEventData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TagId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AntEventData, tag_id),
            },
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: "EventSpec",
                rust_offset: offset_of!(AntEventData, event),
            },
        ],
    }),
    array_type: Some(ANTEVENTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AntEventData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTEVENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTEVENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEventData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntEventData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationProxyBankData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub proxy_bank: super::ant::AntRef,
    pub proxy_bank_pointer: super::ant::AntRef,
}

pub trait AnimationProxyBankDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn proxy_bank(&self) -> &super::ant::AntRef;
    fn proxy_bank_mut(&mut self) -> &mut super::ant::AntRef;
    fn proxy_bank_pointer(&self) -> &super::ant::AntRef;
    fn proxy_bank_pointer_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AnimationProxyBankDataTrait for AnimationProxyBankData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn proxy_bank(&self) -> &super::ant::AntRef {
        &self.proxy_bank
    }
    fn proxy_bank_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.proxy_bank
    }
    fn proxy_bank_pointer(&self) -> &super::ant::AntRef {
        &self.proxy_bank_pointer
    }
    fn proxy_bank_pointer_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.proxy_bank_pointer
    }
}

impl super::entity::EntityDataTrait for AnimationProxyBankData {
}

impl super::entity::GameObjectDataTrait for AnimationProxyBankData {
}

impl super::core::DataBusPeerTrait for AnimationProxyBankData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationProxyBankData {
}

impl super::core::DataContainerTrait for AnimationProxyBankData {
}

pub static ANIMATIONPROXYBANKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationProxyBankData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationProxyBankData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AnimationProxyBankData, realm),
            },
            FieldInfoData {
                name: "ProxyBank",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationProxyBankData, proxy_bank),
            },
            FieldInfoData {
                name: "ProxyBankPointer",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationProxyBankData, proxy_bank_pointer),
            },
        ],
    }),
    array_type: Some(ANIMATIONPROXYBANKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationProxyBankData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONPROXYBANKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONPROXYBANKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationProxyBankData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationProxyBankData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoneFakePhysicsData {
    pub _glacier_base: super::core::DataContainer,
    pub fake_physics: Option<Arc<Mutex<dyn super::physics::FakePhysicsDataTrait>>>,
    pub bone_name: String,
    pub bone_id: i32,
}

pub trait BoneFakePhysicsDataTrait: super::core::DataContainerTrait {
    fn fake_physics(&self) -> &Option<Arc<Mutex<dyn super::physics::FakePhysicsDataTrait>>>;
    fn fake_physics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::FakePhysicsDataTrait>>>;
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
    fn bone_id(&self) -> &i32;
    fn bone_id_mut(&mut self) -> &mut i32;
}

impl BoneFakePhysicsDataTrait for BoneFakePhysicsData {
    fn fake_physics(&self) -> &Option<Arc<Mutex<dyn super::physics::FakePhysicsDataTrait>>> {
        &self.fake_physics
    }
    fn fake_physics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::FakePhysicsDataTrait>>> {
        &mut self.fake_physics
    }
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
    fn bone_id(&self) -> &i32 {
        &self.bone_id
    }
    fn bone_id_mut(&mut self) -> &mut i32 {
        &mut self.bone_id
    }
}

impl super::core::DataContainerTrait for BoneFakePhysicsData {
}

pub static BONEFAKEPHYSICSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneFakePhysicsData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoneFakePhysicsData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FakePhysics",
                flags: MemberInfoFlags::new(0),
                field_type: "FakePhysicsData",
                rust_offset: offset_of!(BoneFakePhysicsData, fake_physics),
            },
            FieldInfoData {
                name: "BoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BoneFakePhysicsData, bone_name),
            },
            FieldInfoData {
                name: "BoneId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BoneFakePhysicsData, bone_id),
            },
        ],
    }),
    array_type: Some(BONEFAKEPHYSICSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoneFakePhysicsData {
    fn type_info(&self) -> &'static TypeInfo {
        BONEFAKEPHYSICSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BONEFAKEPHYSICSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneFakePhysicsData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoneFakePhysicsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AddFakeCollisionEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub apply_to_all_parts: bool,
    pub part_index: u32,
    pub position: super::core::Vec3,
    pub normal: super::core::Vec3,
    pub speed: f32,
    pub material: super::entity::MaterialDecl,
    pub impulse_direction: super::core::Vec3,
    pub impulse_magnitude: f32,
    pub damage: f32,
}

pub trait AddFakeCollisionEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn apply_to_all_parts(&self) -> &bool;
    fn apply_to_all_parts_mut(&mut self) -> &mut bool;
    fn part_index(&self) -> &u32;
    fn part_index_mut(&mut self) -> &mut u32;
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn normal(&self) -> &super::core::Vec3;
    fn normal_mut(&mut self) -> &mut super::core::Vec3;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
    fn material(&self) -> &super::entity::MaterialDecl;
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn impulse_direction(&self) -> &super::core::Vec3;
    fn impulse_direction_mut(&mut self) -> &mut super::core::Vec3;
    fn impulse_magnitude(&self) -> &f32;
    fn impulse_magnitude_mut(&mut self) -> &mut f32;
    fn damage(&self) -> &f32;
    fn damage_mut(&mut self) -> &mut f32;
}

impl AddFakeCollisionEntityDataTrait for AddFakeCollisionEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn apply_to_all_parts(&self) -> &bool {
        &self.apply_to_all_parts
    }
    fn apply_to_all_parts_mut(&mut self) -> &mut bool {
        &mut self.apply_to_all_parts
    }
    fn part_index(&self) -> &u32 {
        &self.part_index
    }
    fn part_index_mut(&mut self) -> &mut u32 {
        &mut self.part_index
    }
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn normal(&self) -> &super::core::Vec3 {
        &self.normal
    }
    fn normal_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.normal
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material
    }
    fn impulse_direction(&self) -> &super::core::Vec3 {
        &self.impulse_direction
    }
    fn impulse_direction_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.impulse_direction
    }
    fn impulse_magnitude(&self) -> &f32 {
        &self.impulse_magnitude
    }
    fn impulse_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.impulse_magnitude
    }
    fn damage(&self) -> &f32 {
        &self.damage
    }
    fn damage_mut(&mut self) -> &mut f32 {
        &mut self.damage
    }
}

impl super::entity::EntityDataTrait for AddFakeCollisionEntityData {
}

impl super::entity::GameObjectDataTrait for AddFakeCollisionEntityData {
}

impl super::core::DataBusPeerTrait for AddFakeCollisionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AddFakeCollisionEntityData {
}

impl super::core::DataContainerTrait for AddFakeCollisionEntityData {
}

pub static ADDFAKECOLLISIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddFakeCollisionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AddFakeCollisionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AddFakeCollisionEntityData, realm),
            },
            FieldInfoData {
                name: "ApplyToAllParts",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AddFakeCollisionEntityData, apply_to_all_parts),
            },
            FieldInfoData {
                name: "PartIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AddFakeCollisionEntityData, part_index),
            },
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AddFakeCollisionEntityData, position),
            },
            FieldInfoData {
                name: "Normal",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AddFakeCollisionEntityData, normal),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AddFakeCollisionEntityData, speed),
            },
            FieldInfoData {
                name: "Material",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(AddFakeCollisionEntityData, material),
            },
            FieldInfoData {
                name: "ImpulseDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AddFakeCollisionEntityData, impulse_direction),
            },
            FieldInfoData {
                name: "ImpulseMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AddFakeCollisionEntityData, impulse_magnitude),
            },
            FieldInfoData {
                name: "Damage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AddFakeCollisionEntityData, damage),
            },
        ],
    }),
    array_type: Some(ADDFAKECOLLISIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AddFakeCollisionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ADDFAKECOLLISIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ADDFAKECOLLISIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AddFakeCollisionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AddFakeCollisionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RecordVehicleTrackData {
    pub _glacier_base: super::timeline::RecordTrackBaseData,
    pub children_tracks: Vec<Option<Arc<Mutex<dyn super::timeline::RecordTrackChildrenDataTrait>>>>,
}

pub trait RecordVehicleTrackDataTrait: super::timeline::RecordTrackBaseDataTrait {
    fn children_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::RecordTrackChildrenDataTrait>>>>;
    fn children_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::RecordTrackChildrenDataTrait>>>>;
}

impl RecordVehicleTrackDataTrait for RecordVehicleTrackData {
    fn children_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::RecordTrackChildrenDataTrait>>>> {
        &self.children_tracks
    }
    fn children_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::RecordTrackChildrenDataTrait>>>> {
        &mut self.children_tracks
    }
}

impl super::timeline::RecordTrackBaseDataTrait for RecordVehicleTrackData {
    fn frames_to_skip_per_key(&self) -> &i32 {
        self._glacier_base.frames_to_skip_per_key()
    }
    fn frames_to_skip_per_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.frames_to_skip_per_key_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for RecordVehicleTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for RecordVehicleTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordVehicleTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordVehicleTrackData {
}

impl super::core::DataBusPeerTrait for RecordVehicleTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordVehicleTrackData {
}

impl super::core::DataContainerTrait for RecordVehicleTrackData {
}

pub static RECORDVEHICLETRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordVehicleTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::RECORDTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordVehicleTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ChildrenTracks",
                flags: MemberInfoFlags::new(144),
                field_type: "RecordTrackChildrenData-Array",
                rust_offset: offset_of!(RecordVehicleTrackData, children_tracks),
            },
        ],
    }),
    array_type: Some(RECORDVEHICLETRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordVehicleTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDVEHICLETRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDVEHICLETRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordVehicleTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordVehicleTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RecordRootTransformTrackData {
    pub _glacier_base: super::timeline::RecordTrackChildrenData,
    pub layered_transform_track: Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>,
    pub keyed_transform_track: Option<Arc<Mutex<dyn super::timeline::KeyedTransformLayerDataTrait>>>,
}

pub trait RecordRootTransformTrackDataTrait: super::timeline::RecordTrackChildrenDataTrait {
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>>;
    fn keyed_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::KeyedTransformLayerDataTrait>>>;
    fn keyed_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::KeyedTransformLayerDataTrait>>>;
}

impl RecordRootTransformTrackDataTrait for RecordRootTransformTrackData {
    fn layered_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &self.layered_transform_track
    }
    fn layered_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::LayeredTransformTrackDataTrait>>> {
        &mut self.layered_transform_track
    }
    fn keyed_transform_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::KeyedTransformLayerDataTrait>>> {
        &self.keyed_transform_track
    }
    fn keyed_transform_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::KeyedTransformLayerDataTrait>>> {
        &mut self.keyed_transform_track
    }
}

impl super::timeline::RecordTrackChildrenDataTrait for RecordRootTransformTrackData {
}

impl super::timeline::RecordTrackBaseDataTrait for RecordRootTransformTrackData {
    fn frames_to_skip_per_key(&self) -> &i32 {
        self._glacier_base.frames_to_skip_per_key()
    }
    fn frames_to_skip_per_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.frames_to_skip_per_key_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for RecordRootTransformTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for RecordRootTransformTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordRootTransformTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordRootTransformTrackData {
}

impl super::core::DataBusPeerTrait for RecordRootTransformTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordRootTransformTrackData {
}

impl super::core::DataContainerTrait for RecordRootTransformTrackData {
}

pub static RECORDROOTTRANSFORMTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordRootTransformTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::RECORDTRACKCHILDRENDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordRootTransformTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayeredTransformTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "LayeredTransformTrackData",
                rust_offset: offset_of!(RecordRootTransformTrackData, layered_transform_track),
            },
            FieldInfoData {
                name: "KeyedTransformTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "KeyedTransformLayerData",
                rust_offset: offset_of!(RecordRootTransformTrackData, keyed_transform_track),
            },
        ],
    }),
    array_type: Some(RECORDROOTTRANSFORMTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordRootTransformTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDROOTTRANSFORMTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDROOTTRANSFORMTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordRootTransformTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordRootTransformTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RecordEntryInputTrackData {
    pub _glacier_base: super::timeline::RecordTrackChildrenData,
    pub entry_id: u32,
    pub fire_input: Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>,
    pub pitch_input: Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>,
    pub yaw_input: Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>,
    pub roll_input: Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>,
    pub throttle_input: Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>,
    pub digital_bit_flags_input: Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>,
    pub aiming_yaw: Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>,
    pub aiming_pitch: Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>,
}

pub trait RecordEntryInputTrackDataTrait: super::timeline::RecordTrackChildrenDataTrait {
    fn entry_id(&self) -> &u32;
    fn entry_id_mut(&mut self) -> &mut u32;
    fn fire_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn fire_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn pitch_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn pitch_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn yaw_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn yaw_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn roll_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn roll_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn throttle_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn digital_bit_flags_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn digital_bit_flags_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn aiming_yaw(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn aiming_yaw_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn aiming_pitch(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn aiming_pitch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
}

impl RecordEntryInputTrackDataTrait for RecordEntryInputTrackData {
    fn entry_id(&self) -> &u32 {
        &self.entry_id
    }
    fn entry_id_mut(&mut self) -> &mut u32 {
        &mut self.entry_id
    }
    fn fire_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &self.fire_input
    }
    fn fire_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &mut self.fire_input
    }
    fn pitch_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &self.pitch_input
    }
    fn pitch_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &mut self.pitch_input
    }
    fn yaw_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &self.yaw_input
    }
    fn yaw_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &mut self.yaw_input
    }
    fn roll_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &self.roll_input
    }
    fn roll_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &mut self.roll_input
    }
    fn throttle_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &self.throttle_input
    }
    fn throttle_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &mut self.throttle_input
    }
    fn digital_bit_flags_input(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &self.digital_bit_flags_input
    }
    fn digital_bit_flags_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &mut self.digital_bit_flags_input
    }
    fn aiming_yaw(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &self.aiming_yaw
    }
    fn aiming_yaw_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &mut self.aiming_yaw
    }
    fn aiming_pitch(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &self.aiming_pitch
    }
    fn aiming_pitch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &mut self.aiming_pitch
    }
}

impl super::timeline::RecordTrackChildrenDataTrait for RecordEntryInputTrackData {
}

impl super::timeline::RecordTrackBaseDataTrait for RecordEntryInputTrackData {
    fn frames_to_skip_per_key(&self) -> &i32 {
        self._glacier_base.frames_to_skip_per_key()
    }
    fn frames_to_skip_per_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.frames_to_skip_per_key_mut()
    }
}

impl super::timeline::LinkTrackDataTrait for RecordEntryInputTrackData {
}

impl super::timeline::SchematicPinTrackDataTrait for RecordEntryInputTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for RecordEntryInputTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for RecordEntryInputTrackData {
}

impl super::core::DataBusPeerTrait for RecordEntryInputTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RecordEntryInputTrackData {
}

impl super::core::DataContainerTrait for RecordEntryInputTrackData {
}

pub static RECORDENTRYINPUTTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordEntryInputTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::RECORDTRACKCHILDRENDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordEntryInputTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EntryId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RecordEntryInputTrackData, entry_id),
            },
            FieldInfoData {
                name: "FireInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, fire_input),
            },
            FieldInfoData {
                name: "PitchInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, pitch_input),
            },
            FieldInfoData {
                name: "YawInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, yaw_input),
            },
            FieldInfoData {
                name: "RollInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, roll_input),
            },
            FieldInfoData {
                name: "ThrottleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, throttle_input),
            },
            FieldInfoData {
                name: "DigitalBitFlagsInput",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, digital_bit_flags_input),
            },
            FieldInfoData {
                name: "AimingYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, aiming_yaw),
            },
            FieldInfoData {
                name: "AimingPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(RecordEntryInputTrackData, aiming_pitch),
            },
        ],
    }),
    array_type: Some(RECORDENTRYINPUTTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordEntryInputTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDENTRYINPUTTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDENTRYINPUTTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordEntryInputTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordEntryInputTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RecordEntryInputType {
    #[default]
    RecordEntryInputType_FireInput = 0,
    RecordEntryInputType_PitchInput = 1,
    RecordEntryInputType_YawInput = 2,
    RecordEntryInputType_RollInput = 3,
    RecordEntryInputType_ThrottleInput = 4,
    RecordEntryInputType_DigitalBitFlagsInput = 5,
    RecordEntryInputType_AimingYaw = 6,
    RecordEntryInputType_AimingPitch = 7,
    RecordEntryInputTypeCount = 8,
}

pub static RECORDENTRYINPUTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordEntryInputType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(RECORDENTRYINPUTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RecordEntryInputType {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDENTRYINPUTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RECORDENTRYINPUTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordEntryInputType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordEntryInputType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicalCameraTrackData {
    pub _glacier_base: CameraTrackBaseData,
    pub physical_camera_body: Option<Arc<Mutex<dyn CameraBodyPresetTrait>>>,
    pub physical_camera_lens: Option<Arc<Mutex<dyn CameraLensPresetTrait>>>,
    pub exposure_mode: ExposureMode,
    pub auto_exposure_method: super::render_base::AutoExposureMethod,
    pub children: Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>,
}

pub trait PhysicalCameraTrackDataTrait: CameraTrackBaseDataTrait {
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>>;
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>>;
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>>;
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>>;
    fn exposure_mode(&self) -> &ExposureMode;
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode;
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod;
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod;
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
}

impl PhysicalCameraTrackDataTrait for PhysicalCameraTrackData {
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        &self.physical_camera_body
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        &mut self.physical_camera_body
    }
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        &self.physical_camera_lens
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        &mut self.physical_camera_lens
    }
    fn exposure_mode(&self) -> &ExposureMode {
        &self.exposure_mode
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        &mut self.exposure_mode
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        &self.auto_exposure_method
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        &mut self.auto_exposure_method
    }
    fn children(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &self.children
    }
    fn children_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &mut self.children
    }
}

impl CameraTrackBaseDataTrait for PhysicalCameraTrackData {
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for PhysicalCameraTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for PhysicalCameraTrackData {
}

impl super::core::DataBusPeerTrait for PhysicalCameraTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PhysicalCameraTrackData {
}

impl super::core::DataContainerTrait for PhysicalCameraTrackData {
}

pub static PHYSICALCAMERATRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicalCameraTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicalCameraBody",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraBodyPreset",
                rust_offset: offset_of!(PhysicalCameraTrackData, physical_camera_body),
            },
            FieldInfoData {
                name: "PhysicalCameraLens",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraLensPreset",
                rust_offset: offset_of!(PhysicalCameraTrackData, physical_camera_lens),
            },
            FieldInfoData {
                name: "ExposureMode",
                flags: MemberInfoFlags::new(0),
                field_type: "ExposureMode",
                rust_offset: offset_of!(PhysicalCameraTrackData, exposure_mode),
            },
            FieldInfoData {
                name: "AutoExposureMethod",
                flags: MemberInfoFlags::new(0),
                field_type: "AutoExposureMethod",
                rust_offset: offset_of!(PhysicalCameraTrackData, auto_exposure_method),
            },
            FieldInfoData {
                name: "Children",
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(PhysicalCameraTrackData, children),
            },
        ],
    }),
    array_type: Some(PHYSICALCAMERATRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicalCameraTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICALCAMERATRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHYSICALCAMERATRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicalCameraTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicalCameraTrackUpdateInfo {
    pub transform: super::core::LinearTransform,
    pub field_of_view: f32,
    pub focal_length: f32,
    pub focus_distance: f32,
    pub exposure_compensation: f32,
    pub aperture: f32,
    pub shutter_speed: f32,
    pub e_v: f32,
    pub i_s_o: f32,
    pub spot_meter_scale: f32,
    pub spot_meter_offset_x: f32,
    pub spot_meter_offset_y: f32,
    pub near_plane: f32,
    pub far_plane: f32,
}

pub trait PhysicalCameraTrackUpdateInfoTrait: TypeObject {
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn field_of_view(&self) -> &f32;
    fn field_of_view_mut(&mut self) -> &mut f32;
    fn focal_length(&self) -> &f32;
    fn focal_length_mut(&mut self) -> &mut f32;
    fn focus_distance(&self) -> &f32;
    fn focus_distance_mut(&mut self) -> &mut f32;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn aperture(&self) -> &f32;
    fn aperture_mut(&mut self) -> &mut f32;
    fn shutter_speed(&self) -> &f32;
    fn shutter_speed_mut(&mut self) -> &mut f32;
    fn e_v(&self) -> &f32;
    fn e_v_mut(&mut self) -> &mut f32;
    fn i_s_o(&self) -> &f32;
    fn i_s_o_mut(&mut self) -> &mut f32;
    fn spot_meter_scale(&self) -> &f32;
    fn spot_meter_scale_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_x(&self) -> &f32;
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_y(&self) -> &f32;
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32;
    fn near_plane(&self) -> &f32;
    fn near_plane_mut(&mut self) -> &mut f32;
    fn far_plane(&self) -> &f32;
    fn far_plane_mut(&mut self) -> &mut f32;
}

impl PhysicalCameraTrackUpdateInfoTrait for PhysicalCameraTrackUpdateInfo {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn field_of_view(&self) -> &f32 {
        &self.field_of_view
    }
    fn field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view
    }
    fn focal_length(&self) -> &f32 {
        &self.focal_length
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        &mut self.focal_length
    }
    fn focus_distance(&self) -> &f32 {
        &self.focus_distance
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        &mut self.focus_distance
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn aperture(&self) -> &f32 {
        &self.aperture
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        &mut self.aperture
    }
    fn shutter_speed(&self) -> &f32 {
        &self.shutter_speed
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        &mut self.shutter_speed
    }
    fn e_v(&self) -> &f32 {
        &self.e_v
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        &mut self.e_v
    }
    fn i_s_o(&self) -> &f32 {
        &self.i_s_o
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        &mut self.i_s_o
    }
    fn spot_meter_scale(&self) -> &f32 {
        &self.spot_meter_scale
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_scale
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        &self.spot_meter_offset_x
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_x
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        &self.spot_meter_offset_y
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_y
    }
    fn near_plane(&self) -> &f32 {
        &self.near_plane
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        &mut self.near_plane
    }
    fn far_plane(&self) -> &f32 {
        &self.far_plane
    }
    fn far_plane_mut(&mut self) -> &mut f32 {
        &mut self.far_plane
    }
}

pub static PHYSICALCAMERATRACKUPDATEINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTrackUpdateInfo",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicalCameraTrackUpdateInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, transform),
            },
            FieldInfoData {
                name: "FieldOfView",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, field_of_view),
            },
            FieldInfoData {
                name: "FocalLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, focal_length),
            },
            FieldInfoData {
                name: "FocusDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, focus_distance),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, exposure_compensation),
            },
            FieldInfoData {
                name: "Aperture",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, aperture),
            },
            FieldInfoData {
                name: "ShutterSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, shutter_speed),
            },
            FieldInfoData {
                name: "EV",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, e_v),
            },
            FieldInfoData {
                name: "ISO",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, i_s_o),
            },
            FieldInfoData {
                name: "SpotMeterScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, spot_meter_scale),
            },
            FieldInfoData {
                name: "SpotMeterOffsetX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, spot_meter_offset_x),
            },
            FieldInfoData {
                name: "SpotMeterOffsetY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, spot_meter_offset_y),
            },
            FieldInfoData {
                name: "NearPlane",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, near_plane),
            },
            FieldInfoData {
                name: "FarPlane",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicalCameraTrackUpdateInfo, far_plane),
            },
        ],
    }),
    array_type: Some(PHYSICALCAMERATRACKUPDATEINFO_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PhysicalCameraTrackUpdateInfo {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICALCAMERATRACKUPDATEINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PHYSICALCAMERATRACKUPDATEINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicalCameraTrackUpdateInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicalCameraTrackUpdateInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PathTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub path_entity_guid: glacier_util::guid::Guid,
    pub force_upright: bool,
    pub up_axis: super::core::Vec3,
    pub timing_curve: Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>,
    pub attach_offset: super::core::LinearTransform,
}

pub trait PathTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn path_entity_guid(&self) -> &glacier_util::guid::Guid;
    fn path_entity_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn force_upright(&self) -> &bool;
    fn force_upright_mut(&mut self) -> &mut bool;
    fn up_axis(&self) -> &super::core::Vec3;
    fn up_axis_mut(&mut self) -> &mut super::core::Vec3;
    fn timing_curve(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn timing_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>>;
    fn attach_offset(&self) -> &super::core::LinearTransform;
    fn attach_offset_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl PathTransformLayerDataTrait for PathTransformLayerData {
    fn path_entity_guid(&self) -> &glacier_util::guid::Guid {
        &self.path_entity_guid
    }
    fn path_entity_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.path_entity_guid
    }
    fn force_upright(&self) -> &bool {
        &self.force_upright
    }
    fn force_upright_mut(&mut self) -> &mut bool {
        &mut self.force_upright
    }
    fn up_axis(&self) -> &super::core::Vec3 {
        &self.up_axis
    }
    fn up_axis_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.up_axis
    }
    fn timing_curve(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &self.timing_curve
    }
    fn timing_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        &mut self.timing_curve
    }
    fn attach_offset(&self) -> &super::core::LinearTransform {
        &self.attach_offset
    }
    fn attach_offset_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.attach_offset
    }
}

impl super::timeline::TransformLayerDataTrait for PathTransformLayerData {
    fn weight(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for PathTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for PathTransformLayerData {
}

impl super::core::DataBusPeerTrait for PathTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PathTransformLayerData {
}

impl super::core::DataContainerTrait for PathTransformLayerData {
}

pub static PATHTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathTransformLayerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PathTransformLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PathEntityGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(PathTransformLayerData, path_entity_guid),
            },
            FieldInfoData {
                name: "ForceUpright",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PathTransformLayerData, force_upright),
            },
            FieldInfoData {
                name: "UpAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PathTransformLayerData, up_axis),
            },
            FieldInfoData {
                name: "TimingCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatTrackData",
                rust_offset: offset_of!(PathTransformLayerData, timing_curve),
            },
            FieldInfoData {
                name: "AttachOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PathTransformLayerData, attach_offset),
            },
        ],
    }),
    array_type: Some(PATHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PathTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        PATHTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PATHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathTransformLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PathTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GroundAttachTransformLayerData {
    pub _glacier_base: super::timeline::TransformLayerData,
    pub attach_method: GroundAttachMethod,
    pub raycast_start_height: f32,
    pub raycast_end_height: f32,
    pub allow_above_ground: bool,
}

pub trait GroundAttachTransformLayerDataTrait: super::timeline::TransformLayerDataTrait {
    fn attach_method(&self) -> &GroundAttachMethod;
    fn attach_method_mut(&mut self) -> &mut GroundAttachMethod;
    fn raycast_start_height(&self) -> &f32;
    fn raycast_start_height_mut(&mut self) -> &mut f32;
    fn raycast_end_height(&self) -> &f32;
    fn raycast_end_height_mut(&mut self) -> &mut f32;
    fn allow_above_ground(&self) -> &bool;
    fn allow_above_ground_mut(&mut self) -> &mut bool;
}

impl GroundAttachTransformLayerDataTrait for GroundAttachTransformLayerData {
    fn attach_method(&self) -> &GroundAttachMethod {
        &self.attach_method
    }
    fn attach_method_mut(&mut self) -> &mut GroundAttachMethod {
        &mut self.attach_method
    }
    fn raycast_start_height(&self) -> &f32 {
        &self.raycast_start_height
    }
    fn raycast_start_height_mut(&mut self) -> &mut f32 {
        &mut self.raycast_start_height
    }
    fn raycast_end_height(&self) -> &f32 {
        &self.raycast_end_height
    }
    fn raycast_end_height_mut(&mut self) -> &mut f32 {
        &mut self.raycast_end_height
    }
    fn allow_above_ground(&self) -> &bool {
        &self.allow_above_ground
    }
    fn allow_above_ground_mut(&mut self) -> &mut bool {
        &mut self.allow_above_ground
    }
}

impl super::timeline::TransformLayerDataTrait for GroundAttachTransformLayerData {
    fn weight(&self) -> &Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::FloatTrackDataTrait>>> {
        self._glacier_base.weight_mut()
    }
    fn blendtype(&self) -> &super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype()
    }
    fn blendtype_mut(&mut self) -> &mut super::timeline::LayeredTransformBlendType {
        self._glacier_base.blendtype_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for GroundAttachTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for GroundAttachTransformLayerData {
}

impl super::core::DataBusPeerTrait for GroundAttachTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GroundAttachTransformLayerData {
}

impl super::core::DataContainerTrait for GroundAttachTransformLayerData {
}

pub static GROUNDATTACHTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundAttachTransformLayerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TRANSFORMLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GroundAttachTransformLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AttachMethod",
                flags: MemberInfoFlags::new(0),
                field_type: "GroundAttachMethod",
                rust_offset: offset_of!(GroundAttachTransformLayerData, attach_method),
            },
            FieldInfoData {
                name: "RaycastStartHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GroundAttachTransformLayerData, raycast_start_height),
            },
            FieldInfoData {
                name: "RaycastEndHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GroundAttachTransformLayerData, raycast_end_height),
            },
            FieldInfoData {
                name: "AllowAboveGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GroundAttachTransformLayerData, allow_above_ground),
            },
        ],
    }),
    array_type: Some(GROUNDATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GroundAttachTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        GROUNDATTACHTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GROUNDATTACHTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundAttachTransformLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GroundAttachTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GroundAttachMethod {
    #[default]
    GroundAttachMethod_SyncRaycast = 0,
    GroundAttachMethod_AsyncRaycast = 1,
}

pub static GROUNDATTACHMETHOD_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundAttachMethod",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(GROUNDATTACHMETHOD_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GroundAttachMethod {
    fn type_info(&self) -> &'static TypeInfo {
        GROUNDATTACHMETHOD_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GROUNDATTACHMETHOD_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroundAttachMethod-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GroundAttachMethod"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameplayCameraTrackData {
    pub _glacier_base: CameraTrackBaseData,
}

pub trait GameplayCameraTrackDataTrait: CameraTrackBaseDataTrait {
}

impl GameplayCameraTrackDataTrait for GameplayCameraTrackData {
}

impl CameraTrackBaseDataTrait for GameplayCameraTrackData {
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for GameplayCameraTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for GameplayCameraTrackData {
}

impl super::core::DataBusPeerTrait for GameplayCameraTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameplayCameraTrackData {
}

impl super::core::DataContainerTrait for GameplayCameraTrackData {
}

pub static GAMEPLAYCAMERATRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayCameraTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERATRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameplayCameraTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMEPLAYCAMERATRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameplayCameraTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEPLAYCAMERATRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEPLAYCAMERATRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameplayCameraTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameplayCameraTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RawFileDataAsset {
    pub _glacier_base: RawFileAsset,
    pub raw_data: Vec<u8>,
    pub size: u32,
}

pub trait RawFileDataAssetTrait: RawFileAssetTrait {
    fn raw_data(&self) -> &Vec<u8>;
    fn raw_data_mut(&mut self) -> &mut Vec<u8>;
    fn size(&self) -> &u32;
    fn size_mut(&mut self) -> &mut u32;
}

impl RawFileDataAssetTrait for RawFileDataAsset {
    fn raw_data(&self) -> &Vec<u8> {
        &self.raw_data
    }
    fn raw_data_mut(&mut self) -> &mut Vec<u8> {
        &mut self.raw_data
    }
    fn size(&self) -> &u32 {
        &self.size
    }
    fn size_mut(&mut self) -> &mut u32 {
        &mut self.size
    }
}

impl RawFileAssetTrait for RawFileDataAsset {
}

impl super::core::AssetTrait for RawFileDataAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RawFileDataAsset {
}

pub static RAWFILEDATAASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileDataAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RAWFILEASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RawFileDataAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RawData",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint8-Array",
                rust_offset: offset_of!(RawFileDataAsset, raw_data),
            },
            FieldInfoData {
                name: "Size",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RawFileDataAsset, size),
            },
        ],
    }),
    array_type: Some(RAWFILEDATAASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RawFileDataAsset {
    fn type_info(&self) -> &'static TypeInfo {
        RAWFILEDATAASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RAWFILEDATAASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileDataAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RawFileDataAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RawFileResourceAsset {
    pub _glacier_base: RawFileAsset,
    pub resource: glacier_reflect::builtin::ResourceRef,
}

pub trait RawFileResourceAssetTrait: RawFileAssetTrait {
    fn resource(&self) -> &glacier_reflect::builtin::ResourceRef;
    fn resource_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef;
}

impl RawFileResourceAssetTrait for RawFileResourceAsset {
    fn resource(&self) -> &glacier_reflect::builtin::ResourceRef {
        &self.resource
    }
    fn resource_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        &mut self.resource
    }
}

impl RawFileAssetTrait for RawFileResourceAsset {
}

impl super::core::AssetTrait for RawFileResourceAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RawFileResourceAsset {
}

pub static RAWFILERESOURCEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileResourceAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RAWFILEASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RawFileResourceAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Resource",
                flags: MemberInfoFlags::new(0),
                field_type: "ResourceRef",
                rust_offset: offset_of!(RawFileResourceAsset, resource),
            },
        ],
    }),
    array_type: Some(RAWFILERESOURCEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RawFileResourceAsset {
    fn type_info(&self) -> &'static TypeInfo {
        RAWFILERESOURCEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RAWFILERESOURCEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileResourceAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RawFileResourceAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RawFileAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait RawFileAssetTrait: super::core::AssetTrait {
}

impl RawFileAssetTrait for RawFileAsset {
}

impl super::core::AssetTrait for RawFileAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RawFileAsset {
}

pub static RAWFILEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RawFileAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RAWFILEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RawFileAsset {
    fn type_info(&self) -> &'static TypeInfo {
        RAWFILEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RAWFILEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RawFileAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayAnimationVisualizerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
}

pub trait PlayAnimationVisualizerEntityDataTrait: super::entity::SpatialEntityDataTrait {
}

impl PlayAnimationVisualizerEntityDataTrait for PlayAnimationVisualizerEntityData {
}

impl super::entity::SpatialEntityDataTrait for PlayAnimationVisualizerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PlayAnimationVisualizerEntityData {
}

impl super::entity::GameObjectDataTrait for PlayAnimationVisualizerEntityData {
}

impl super::core::DataBusPeerTrait for PlayAnimationVisualizerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayAnimationVisualizerEntityData {
}

impl super::core::DataContainerTrait for PlayAnimationVisualizerEntityData {
}

pub static PLAYANIMATIONVISUALIZERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationVisualizerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayAnimationVisualizerEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PLAYANIMATIONVISUALIZERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayAnimationVisualizerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYANIMATIONVISUALIZERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYANIMATIONVISUALIZERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationVisualizerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayAnimationVisualizerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsDrivenAnimationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub binding: PhysicsDrivenAnimationEntityBinding,
    pub animation_entity_space_priority: i32,
}

pub trait PhysicsDrivenAnimationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn binding(&self) -> &PhysicsDrivenAnimationEntityBinding;
    fn binding_mut(&mut self) -> &mut PhysicsDrivenAnimationEntityBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
}

impl PhysicsDrivenAnimationEntityDataTrait for PhysicsDrivenAnimationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn binding(&self) -> &PhysicsDrivenAnimationEntityBinding {
        &self.binding
    }
    fn binding_mut(&mut self) -> &mut PhysicsDrivenAnimationEntityBinding {
        &mut self.binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
}

impl super::entity::EntityDataTrait for PhysicsDrivenAnimationEntityData {
}

impl super::entity::GameObjectDataTrait for PhysicsDrivenAnimationEntityData {
}

impl super::core::DataBusPeerTrait for PhysicsDrivenAnimationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PhysicsDrivenAnimationEntityData {
}

impl super::core::DataContainerTrait for PhysicsDrivenAnimationEntityData {
}

pub static PHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenAnimationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsDrivenAnimationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityData, realm),
            },
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsDrivenAnimationEntityBinding",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityData, binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityData, animation_entity_space_priority),
            },
        ],
    }),
    array_type: Some(PHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsDrivenAnimationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenAnimationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicsDrivenAnimationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsDrivenAnimationEntityBinding {
    pub physics_motion_target: super::ant::AntRef,
    pub aim_left_right: super::ant::AntRef,
    pub aim_up_down: super::ant::AntRef,
    pub crouch: super::ant::AntRef,
    pub force_set_trajectory: super::ant::AntRef,
    pub in_air: super::ant::AntRef,
    pub skydive: super::ant::AntRef,
    pub parachute: super::ant::AntRef,
    pub swim: super::ant::AntRef,
    pub input_backward: super::ant::AntRef,
    pub input_forward: super::ant::AntRef,
    pub input_left: super::ant::AntRef,
    pub input_right: super::ant::AntRef,
    pub input_exclusive_backward: super::ant::AntRef,
    pub input_exclusive_forward: super::ant::AntRef,
    pub input_exclusive_left: super::ant::AntRef,
    pub input_exclusive_right: super::ant::AntRef,
    pub is_enemy: super::ant::AntRef,
    pub jump: super::ant::AntRef,
    pub lean_left_right: super::ant::AntRef,
    pub prone: super::ant::AntRef,
    pub sprint: super::ant::AntRef,
    pub ground_supported: super::ant::AntRef,
    pub ground_normal: super::ant::AntRef,
    pub ground_distance: super::ant::AntRef,
    pub ground_angle_z: super::ant::AntRef,
    pub ground_angle_x: super::ant::AntRef,
    pub ground_angle_facing_pitch: super::ant::AntRef,
    pub ground_angle_facing_roll: super::ant::AntRef,
    pub is_client_animatable: super::ant::AntRef,
    pub vertical_impact: super::ant::AntRef,
    pub vertical_impact_speed: super::ant::AntRef,
    pub false_signal: super::ant::AntRef,
    pub lock_arms_to_camera_weight: super::ant::AntRef,
    pub wind_direction: super::ant::AntRef,
    pub wind_strength: super::ant::AntRef,
    pub water_depth: super::ant::AntRef,
    pub eye_water_depth: super::ant::AntRef,
}

pub trait PhysicsDrivenAnimationEntityBindingTrait: TypeObject {
    fn physics_motion_target(&self) -> &super::ant::AntRef;
    fn physics_motion_target_mut(&mut self) -> &mut super::ant::AntRef;
    fn aim_left_right(&self) -> &super::ant::AntRef;
    fn aim_left_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn aim_up_down(&self) -> &super::ant::AntRef;
    fn aim_up_down_mut(&mut self) -> &mut super::ant::AntRef;
    fn crouch(&self) -> &super::ant::AntRef;
    fn crouch_mut(&mut self) -> &mut super::ant::AntRef;
    fn force_set_trajectory(&self) -> &super::ant::AntRef;
    fn force_set_trajectory_mut(&mut self) -> &mut super::ant::AntRef;
    fn in_air(&self) -> &super::ant::AntRef;
    fn in_air_mut(&mut self) -> &mut super::ant::AntRef;
    fn skydive(&self) -> &super::ant::AntRef;
    fn skydive_mut(&mut self) -> &mut super::ant::AntRef;
    fn parachute(&self) -> &super::ant::AntRef;
    fn parachute_mut(&mut self) -> &mut super::ant::AntRef;
    fn swim(&self) -> &super::ant::AntRef;
    fn swim_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_backward(&self) -> &super::ant::AntRef;
    fn input_backward_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_forward(&self) -> &super::ant::AntRef;
    fn input_forward_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_left(&self) -> &super::ant::AntRef;
    fn input_left_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_right(&self) -> &super::ant::AntRef;
    fn input_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_exclusive_backward(&self) -> &super::ant::AntRef;
    fn input_exclusive_backward_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_exclusive_forward(&self) -> &super::ant::AntRef;
    fn input_exclusive_forward_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_exclusive_left(&self) -> &super::ant::AntRef;
    fn input_exclusive_left_mut(&mut self) -> &mut super::ant::AntRef;
    fn input_exclusive_right(&self) -> &super::ant::AntRef;
    fn input_exclusive_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_enemy(&self) -> &super::ant::AntRef;
    fn is_enemy_mut(&mut self) -> &mut super::ant::AntRef;
    fn jump(&self) -> &super::ant::AntRef;
    fn jump_mut(&mut self) -> &mut super::ant::AntRef;
    fn lean_left_right(&self) -> &super::ant::AntRef;
    fn lean_left_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn prone(&self) -> &super::ant::AntRef;
    fn prone_mut(&mut self) -> &mut super::ant::AntRef;
    fn sprint(&self) -> &super::ant::AntRef;
    fn sprint_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_supported(&self) -> &super::ant::AntRef;
    fn ground_supported_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_normal(&self) -> &super::ant::AntRef;
    fn ground_normal_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_distance(&self) -> &super::ant::AntRef;
    fn ground_distance_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_angle_z(&self) -> &super::ant::AntRef;
    fn ground_angle_z_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_angle_x(&self) -> &super::ant::AntRef;
    fn ground_angle_x_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_angle_facing_pitch(&self) -> &super::ant::AntRef;
    fn ground_angle_facing_pitch_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_angle_facing_roll(&self) -> &super::ant::AntRef;
    fn ground_angle_facing_roll_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_client_animatable(&self) -> &super::ant::AntRef;
    fn is_client_animatable_mut(&mut self) -> &mut super::ant::AntRef;
    fn vertical_impact(&self) -> &super::ant::AntRef;
    fn vertical_impact_mut(&mut self) -> &mut super::ant::AntRef;
    fn vertical_impact_speed(&self) -> &super::ant::AntRef;
    fn vertical_impact_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn false_signal(&self) -> &super::ant::AntRef;
    fn false_signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn lock_arms_to_camera_weight(&self) -> &super::ant::AntRef;
    fn lock_arms_to_camera_weight_mut(&mut self) -> &mut super::ant::AntRef;
    fn wind_direction(&self) -> &super::ant::AntRef;
    fn wind_direction_mut(&mut self) -> &mut super::ant::AntRef;
    fn wind_strength(&self) -> &super::ant::AntRef;
    fn wind_strength_mut(&mut self) -> &mut super::ant::AntRef;
    fn water_depth(&self) -> &super::ant::AntRef;
    fn water_depth_mut(&mut self) -> &mut super::ant::AntRef;
    fn eye_water_depth(&self) -> &super::ant::AntRef;
    fn eye_water_depth_mut(&mut self) -> &mut super::ant::AntRef;
}

impl PhysicsDrivenAnimationEntityBindingTrait for PhysicsDrivenAnimationEntityBinding {
    fn physics_motion_target(&self) -> &super::ant::AntRef {
        &self.physics_motion_target
    }
    fn physics_motion_target_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.physics_motion_target
    }
    fn aim_left_right(&self) -> &super::ant::AntRef {
        &self.aim_left_right
    }
    fn aim_left_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.aim_left_right
    }
    fn aim_up_down(&self) -> &super::ant::AntRef {
        &self.aim_up_down
    }
    fn aim_up_down_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.aim_up_down
    }
    fn crouch(&self) -> &super::ant::AntRef {
        &self.crouch
    }
    fn crouch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.crouch
    }
    fn force_set_trajectory(&self) -> &super::ant::AntRef {
        &self.force_set_trajectory
    }
    fn force_set_trajectory_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.force_set_trajectory
    }
    fn in_air(&self) -> &super::ant::AntRef {
        &self.in_air
    }
    fn in_air_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_air
    }
    fn skydive(&self) -> &super::ant::AntRef {
        &self.skydive
    }
    fn skydive_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.skydive
    }
    fn parachute(&self) -> &super::ant::AntRef {
        &self.parachute
    }
    fn parachute_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.parachute
    }
    fn swim(&self) -> &super::ant::AntRef {
        &self.swim
    }
    fn swim_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.swim
    }
    fn input_backward(&self) -> &super::ant::AntRef {
        &self.input_backward
    }
    fn input_backward_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_backward
    }
    fn input_forward(&self) -> &super::ant::AntRef {
        &self.input_forward
    }
    fn input_forward_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_forward
    }
    fn input_left(&self) -> &super::ant::AntRef {
        &self.input_left
    }
    fn input_left_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_left
    }
    fn input_right(&self) -> &super::ant::AntRef {
        &self.input_right
    }
    fn input_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_right
    }
    fn input_exclusive_backward(&self) -> &super::ant::AntRef {
        &self.input_exclusive_backward
    }
    fn input_exclusive_backward_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_exclusive_backward
    }
    fn input_exclusive_forward(&self) -> &super::ant::AntRef {
        &self.input_exclusive_forward
    }
    fn input_exclusive_forward_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_exclusive_forward
    }
    fn input_exclusive_left(&self) -> &super::ant::AntRef {
        &self.input_exclusive_left
    }
    fn input_exclusive_left_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_exclusive_left
    }
    fn input_exclusive_right(&self) -> &super::ant::AntRef {
        &self.input_exclusive_right
    }
    fn input_exclusive_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.input_exclusive_right
    }
    fn is_enemy(&self) -> &super::ant::AntRef {
        &self.is_enemy
    }
    fn is_enemy_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_enemy
    }
    fn jump(&self) -> &super::ant::AntRef {
        &self.jump
    }
    fn jump_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.jump
    }
    fn lean_left_right(&self) -> &super::ant::AntRef {
        &self.lean_left_right
    }
    fn lean_left_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.lean_left_right
    }
    fn prone(&self) -> &super::ant::AntRef {
        &self.prone
    }
    fn prone_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.prone
    }
    fn sprint(&self) -> &super::ant::AntRef {
        &self.sprint
    }
    fn sprint_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.sprint
    }
    fn ground_supported(&self) -> &super::ant::AntRef {
        &self.ground_supported
    }
    fn ground_supported_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_supported
    }
    fn ground_normal(&self) -> &super::ant::AntRef {
        &self.ground_normal
    }
    fn ground_normal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_normal
    }
    fn ground_distance(&self) -> &super::ant::AntRef {
        &self.ground_distance
    }
    fn ground_distance_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_distance
    }
    fn ground_angle_z(&self) -> &super::ant::AntRef {
        &self.ground_angle_z
    }
    fn ground_angle_z_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_angle_z
    }
    fn ground_angle_x(&self) -> &super::ant::AntRef {
        &self.ground_angle_x
    }
    fn ground_angle_x_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_angle_x
    }
    fn ground_angle_facing_pitch(&self) -> &super::ant::AntRef {
        &self.ground_angle_facing_pitch
    }
    fn ground_angle_facing_pitch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_angle_facing_pitch
    }
    fn ground_angle_facing_roll(&self) -> &super::ant::AntRef {
        &self.ground_angle_facing_roll
    }
    fn ground_angle_facing_roll_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_angle_facing_roll
    }
    fn is_client_animatable(&self) -> &super::ant::AntRef {
        &self.is_client_animatable
    }
    fn is_client_animatable_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_client_animatable
    }
    fn vertical_impact(&self) -> &super::ant::AntRef {
        &self.vertical_impact
    }
    fn vertical_impact_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vertical_impact
    }
    fn vertical_impact_speed(&self) -> &super::ant::AntRef {
        &self.vertical_impact_speed
    }
    fn vertical_impact_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vertical_impact_speed
    }
    fn false_signal(&self) -> &super::ant::AntRef {
        &self.false_signal
    }
    fn false_signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.false_signal
    }
    fn lock_arms_to_camera_weight(&self) -> &super::ant::AntRef {
        &self.lock_arms_to_camera_weight
    }
    fn lock_arms_to_camera_weight_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.lock_arms_to_camera_weight
    }
    fn wind_direction(&self) -> &super::ant::AntRef {
        &self.wind_direction
    }
    fn wind_direction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.wind_direction
    }
    fn wind_strength(&self) -> &super::ant::AntRef {
        &self.wind_strength
    }
    fn wind_strength_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.wind_strength
    }
    fn water_depth(&self) -> &super::ant::AntRef {
        &self.water_depth
    }
    fn water_depth_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.water_depth
    }
    fn eye_water_depth(&self) -> &super::ant::AntRef {
        &self.eye_water_depth
    }
    fn eye_water_depth_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.eye_water_depth
    }
}

pub static PHYSICSDRIVENANIMATIONENTITYBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenAnimationEntityBinding",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsDrivenAnimationEntityBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsMotionTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, physics_motion_target),
            },
            FieldInfoData {
                name: "AimLeftRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, aim_left_right),
            },
            FieldInfoData {
                name: "AimUpDown",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, aim_up_down),
            },
            FieldInfoData {
                name: "Crouch",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, crouch),
            },
            FieldInfoData {
                name: "ForceSetTrajectory",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, force_set_trajectory),
            },
            FieldInfoData {
                name: "InAir",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, in_air),
            },
            FieldInfoData {
                name: "Skydive",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, skydive),
            },
            FieldInfoData {
                name: "Parachute",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, parachute),
            },
            FieldInfoData {
                name: "Swim",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, swim),
            },
            FieldInfoData {
                name: "InputBackward",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_backward),
            },
            FieldInfoData {
                name: "InputForward",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_forward),
            },
            FieldInfoData {
                name: "InputLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_left),
            },
            FieldInfoData {
                name: "InputRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_right),
            },
            FieldInfoData {
                name: "InputExclusiveBackward",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_exclusive_backward),
            },
            FieldInfoData {
                name: "InputExclusiveForward",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_exclusive_forward),
            },
            FieldInfoData {
                name: "InputExclusiveLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_exclusive_left),
            },
            FieldInfoData {
                name: "InputExclusiveRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, input_exclusive_right),
            },
            FieldInfoData {
                name: "IsEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, is_enemy),
            },
            FieldInfoData {
                name: "Jump",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, jump),
            },
            FieldInfoData {
                name: "LeanLeftRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, lean_left_right),
            },
            FieldInfoData {
                name: "Prone",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, prone),
            },
            FieldInfoData {
                name: "Sprint",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, sprint),
            },
            FieldInfoData {
                name: "GroundSupported",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_supported),
            },
            FieldInfoData {
                name: "GroundNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_normal),
            },
            FieldInfoData {
                name: "GroundDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_distance),
            },
            FieldInfoData {
                name: "GroundAngleZ",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_angle_z),
            },
            FieldInfoData {
                name: "GroundAngleX",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_angle_x),
            },
            FieldInfoData {
                name: "GroundAngleFacingPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_angle_facing_pitch),
            },
            FieldInfoData {
                name: "GroundAngleFacingRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, ground_angle_facing_roll),
            },
            FieldInfoData {
                name: "IsClientAnimatable",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, is_client_animatable),
            },
            FieldInfoData {
                name: "VerticalImpact",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, vertical_impact),
            },
            FieldInfoData {
                name: "VerticalImpactSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, vertical_impact_speed),
            },
            FieldInfoData {
                name: "FalseSignal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, false_signal),
            },
            FieldInfoData {
                name: "LockArmsToCameraWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, lock_arms_to_camera_weight),
            },
            FieldInfoData {
                name: "WindDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, wind_direction),
            },
            FieldInfoData {
                name: "WindStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, wind_strength),
            },
            FieldInfoData {
                name: "WaterDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, water_depth),
            },
            FieldInfoData {
                name: "EyeWaterDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PhysicsDrivenAnimationEntityBinding, eye_water_depth),
            },
        ],
    }),
    array_type: Some(PHYSICSDRIVENANIMATIONENTITYBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PhysicsDrivenAnimationEntityBinding {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSDRIVENANIMATIONENTITYBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PHYSICSDRIVENANIMATIONENTITYBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenAnimationEntityBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicsDrivenAnimationEntityBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PersistenceStatGroup {
    pub _glacier_base: super::core::DataContainer,
    pub group_name: String,
}

pub trait PersistenceStatGroupTrait: super::core::DataContainerTrait {
    fn group_name(&self) -> &String;
    fn group_name_mut(&mut self) -> &mut String;
}

impl PersistenceStatGroupTrait for PersistenceStatGroup {
    fn group_name(&self) -> &String {
        &self.group_name
    }
    fn group_name_mut(&mut self) -> &mut String {
        &mut self.group_name
    }
}

impl super::core::DataContainerTrait for PersistenceStatGroup {
}

pub static PERSISTENCESTATGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceStatGroup",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceStatGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GroupName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistenceStatGroup, group_name),
            },
        ],
    }),
    array_type: Some(PERSISTENCESTATGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceStatGroup {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCESTATGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCESTATGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceStatGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceStatGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PersistenceStatTable {
    pub _glacier_base: super::core::DataContainer,
    pub table_name: String,
    pub owner_persistence_data: Option<Arc<Mutex<dyn AbstractPersistenceDataTrait>>>,
}

pub trait PersistenceStatTableTrait: super::core::DataContainerTrait {
    fn table_name(&self) -> &String;
    fn table_name_mut(&mut self) -> &mut String;
    fn owner_persistence_data(&self) -> &Option<Arc<Mutex<dyn AbstractPersistenceDataTrait>>>;
    fn owner_persistence_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AbstractPersistenceDataTrait>>>;
}

impl PersistenceStatTableTrait for PersistenceStatTable {
    fn table_name(&self) -> &String {
        &self.table_name
    }
    fn table_name_mut(&mut self) -> &mut String {
        &mut self.table_name
    }
    fn owner_persistence_data(&self) -> &Option<Arc<Mutex<dyn AbstractPersistenceDataTrait>>> {
        &self.owner_persistence_data
    }
    fn owner_persistence_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AbstractPersistenceDataTrait>>> {
        &mut self.owner_persistence_data
    }
}

impl super::core::DataContainerTrait for PersistenceStatTable {
}

pub static PERSISTENCESTATTABLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceStatTable",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceStatTable as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TableName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistenceStatTable, table_name),
            },
            FieldInfoData {
                name: "OwnerPersistenceData",
                flags: MemberInfoFlags::new(0),
                field_type: "AbstractPersistenceData",
                rust_offset: offset_of!(PersistenceStatTable, owner_persistence_data),
            },
        ],
    }),
    array_type: Some(PERSISTENCESTATTABLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceStatTable {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCESTATTABLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCESTATTABLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceStatTable-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceStatTable"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbstractPersistenceData {
    pub _glacier_base: super::core::Asset,
}

pub trait AbstractPersistenceDataTrait: super::core::AssetTrait {
}

impl AbstractPersistenceDataTrait for AbstractPersistenceData {
}

impl super::core::AssetTrait for AbstractPersistenceData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AbstractPersistenceData {
}

pub static ABSTRACTPERSISTENCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractPersistenceData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbstractPersistenceData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ABSTRACTPERSISTENCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbstractPersistenceData {
    fn type_info(&self) -> &'static TypeInfo {
        ABSTRACTPERSISTENCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ABSTRACTPERSISTENCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractPersistenceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AbstractPersistenceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistentValueHistoryType {
    #[default]
    PersistentValueHistoryType_None = 0,
    PersistentValueHistoryType_Delta = 1,
    PersistentValueHistoryType_DeltaAndAbsolute = 2,
    PersistentValueHistoryType_HistoryOnly = 3,
}

pub static PERSISTENTVALUEHISTORYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueHistoryType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENTVALUEHISTORYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistentValueHistoryType {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUEHISTORYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUEHISTORYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueHistoryType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueHistoryType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbstractLeaderboardData {
    pub _glacier_base: super::core::DataContainer,
    pub leaderboard_name: String,
}

pub trait AbstractLeaderboardDataTrait: super::core::DataContainerTrait {
    fn leaderboard_name(&self) -> &String;
    fn leaderboard_name_mut(&mut self) -> &mut String;
}

impl AbstractLeaderboardDataTrait for AbstractLeaderboardData {
    fn leaderboard_name(&self) -> &String {
        &self.leaderboard_name
    }
    fn leaderboard_name_mut(&mut self) -> &mut String {
        &mut self.leaderboard_name
    }
}

impl super::core::DataContainerTrait for AbstractLeaderboardData {
}

pub static ABSTRACTLEADERBOARDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractLeaderboardData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbstractLeaderboardData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LeaderboardName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AbstractLeaderboardData, leaderboard_name),
            },
        ],
    }),
    array_type: Some(ABSTRACTLEADERBOARDDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AbstractLeaderboardData {
    fn type_info(&self) -> &'static TypeInfo {
        ABSTRACTLEADERBOARDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ABSTRACTLEADERBOARDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractLeaderboardData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AbstractLeaderboardData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PersistenceGameData {
    pub _glacier_base: super::core::Asset,
    pub assets: Vec<Option<Arc<Mutex<dyn super::core::AssetTrait>>>>,
}

pub trait PersistenceGameDataTrait: super::core::AssetTrait {
    fn assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::AssetTrait>>>>;
    fn assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::core::AssetTrait>>>>;
}

impl PersistenceGameDataTrait for PersistenceGameData {
    fn assets(&self) -> &Vec<Option<Arc<Mutex<dyn super::core::AssetTrait>>>> {
        &self.assets
    }
    fn assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::core::AssetTrait>>>> {
        &mut self.assets
    }
}

impl super::core::AssetTrait for PersistenceGameData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PersistenceGameData {
}

pub static PERSISTENCEGAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceGameData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceGameData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Assets",
                flags: MemberInfoFlags::new(144),
                field_type: "Asset-Array",
                rust_offset: offset_of!(PersistenceGameData, assets),
            },
        ],
    }),
    array_type: Some(PERSISTENCEGAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceGameData {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCEGAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCEGAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceGameData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceGameData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RichPresenceData {
    pub _glacier_base: super::core::Asset,
    pub presence_modes: Vec<Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>>,
    pub default_mode: Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>,
    pub inactive_mode: Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>,
    pub contexts: Vec<Option<Arc<Mutex<dyn RichPresenceContextTrait>>>>,
    pub properties: Vec<RichPresenceProperty>,
}

pub trait RichPresenceDataTrait: super::core::AssetTrait {
    fn presence_modes(&self) -> &Vec<Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>>;
    fn presence_modes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>>;
    fn default_mode(&self) -> &Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>;
    fn default_mode_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>;
    fn inactive_mode(&self) -> &Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>;
    fn inactive_mode_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>;
    fn contexts(&self) -> &Vec<Option<Arc<Mutex<dyn RichPresenceContextTrait>>>>;
    fn contexts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RichPresenceContextTrait>>>>;
    fn properties(&self) -> &Vec<RichPresenceProperty>;
    fn properties_mut(&mut self) -> &mut Vec<RichPresenceProperty>;
}

impl RichPresenceDataTrait for RichPresenceData {
    fn presence_modes(&self) -> &Vec<Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>> {
        &self.presence_modes
    }
    fn presence_modes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>>> {
        &mut self.presence_modes
    }
    fn default_mode(&self) -> &Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>> {
        &self.default_mode
    }
    fn default_mode_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>> {
        &mut self.default_mode
    }
    fn inactive_mode(&self) -> &Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>> {
        &self.inactive_mode
    }
    fn inactive_mode_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresencePresenceStringTrait>>> {
        &mut self.inactive_mode
    }
    fn contexts(&self) -> &Vec<Option<Arc<Mutex<dyn RichPresenceContextTrait>>>> {
        &self.contexts
    }
    fn contexts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RichPresenceContextTrait>>>> {
        &mut self.contexts
    }
    fn properties(&self) -> &Vec<RichPresenceProperty> {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut Vec<RichPresenceProperty> {
        &mut self.properties
    }
}

impl super::core::AssetTrait for RichPresenceData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RichPresenceData {
}

pub static RICHPRESENCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PresenceModes",
                flags: MemberInfoFlags::new(144),
                field_type: "RichPresencePresenceString-Array",
                rust_offset: offset_of!(RichPresenceData, presence_modes),
            },
            FieldInfoData {
                name: "DefaultMode",
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresencePresenceString",
                rust_offset: offset_of!(RichPresenceData, default_mode),
            },
            FieldInfoData {
                name: "InactiveMode",
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresencePresenceString",
                rust_offset: offset_of!(RichPresenceData, inactive_mode),
            },
            FieldInfoData {
                name: "Contexts",
                flags: MemberInfoFlags::new(144),
                field_type: "RichPresenceContext-Array",
                rust_offset: offset_of!(RichPresenceData, contexts),
            },
            FieldInfoData {
                name: "Properties",
                flags: MemberInfoFlags::new(144),
                field_type: "RichPresenceProperty-Array",
                rust_offset: offset_of!(RichPresenceData, properties),
            },
        ],
    }),
    array_type: Some(RICHPRESENCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceData {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RichPresenceProperty {
    pub name: String,
    pub property_type: RichPresencePropertyType,
}

pub trait RichPresencePropertyTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn property_type(&self) -> &RichPresencePropertyType;
    fn property_type_mut(&mut self) -> &mut RichPresencePropertyType;
}

impl RichPresencePropertyTrait for RichPresenceProperty {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn property_type(&self) -> &RichPresencePropertyType {
        &self.property_type
    }
    fn property_type_mut(&mut self) -> &mut RichPresencePropertyType {
        &mut self.property_type
    }
}

pub static RICHPRESENCEPROPERTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceProperty",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceProperty as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceProperty, name),
            },
            FieldInfoData {
                name: "PropertyType",
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresencePropertyType",
                rust_offset: offset_of!(RichPresenceProperty, property_type),
            },
        ],
    }),
    array_type: Some(RICHPRESENCEPROPERTY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceProperty {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCEPROPERTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RICHPRESENCEPROPERTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceProperty-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceProperty"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RichPresencePropertyType {
    #[default]
    RichPresencePropertyType_Float = 0,
    RichPresencePropertyType_Integer = 1,
    RichPresencePropertyType_LongFloat = 2,
    RichPresencePropertyType_LongInteger = 3,
}

pub static RICHPRESENCEPROPERTYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresencePropertyType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(RICHPRESENCEPROPERTYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RichPresencePropertyType {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCEPROPERTYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RICHPRESENCEPROPERTYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresencePropertyType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresencePropertyType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RichPresenceContextSetting {
    pub context: Option<Arc<Mutex<dyn RichPresenceContextTrait>>>,
    pub value: Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>,
}

pub trait RichPresenceContextSettingTrait: TypeObject {
    fn context(&self) -> &Option<Arc<Mutex<dyn RichPresenceContextTrait>>>;
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresenceContextTrait>>>;
    fn value(&self) -> &Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>;
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>;
}

impl RichPresenceContextSettingTrait for RichPresenceContextSetting {
    fn context(&self) -> &Option<Arc<Mutex<dyn RichPresenceContextTrait>>> {
        &self.context
    }
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresenceContextTrait>>> {
        &mut self.context
    }
    fn value(&self) -> &Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>> {
        &self.value
    }
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>> {
        &mut self.value
    }
}

pub static RICHPRESENCECONTEXTSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextSetting",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceContextSetting as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Context",
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresenceContext",
                rust_offset: offset_of!(RichPresenceContextSetting, context),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresenceContextValue",
                rust_offset: offset_of!(RichPresenceContextSetting, value),
            },
        ],
    }),
    array_type: Some(RICHPRESENCECONTEXTSETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceContextSetting {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCECONTEXTSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RICHPRESENCECONTEXTSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceContextSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RichPresenceContext {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub values: Vec<Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>>,
    pub default_value: Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>,
    pub index: u8,
    pub stat_code: String,
}

pub trait RichPresenceContextTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>>;
    fn values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>>;
    fn default_value(&self) -> &Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>;
    fn default_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>;
    fn index(&self) -> &u8;
    fn index_mut(&mut self) -> &mut u8;
    fn stat_code(&self) -> &String;
    fn stat_code_mut(&mut self) -> &mut String;
}

impl RichPresenceContextTrait for RichPresenceContext {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>>> {
        &mut self.values
    }
    fn default_value(&self) -> &Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>> {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RichPresenceContextValueTrait>>> {
        &mut self.default_value
    }
    fn index(&self) -> &u8 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut u8 {
        &mut self.index
    }
    fn stat_code(&self) -> &String {
        &self.stat_code
    }
    fn stat_code_mut(&mut self) -> &mut String {
        &mut self.stat_code
    }
}

impl super::core::DataContainerTrait for RichPresenceContext {
}

pub static RICHPRESENCECONTEXT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContext",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceContext as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceContext, name),
            },
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "RichPresenceContextValue-Array",
                rust_offset: offset_of!(RichPresenceContext, values),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "RichPresenceContextValue",
                rust_offset: offset_of!(RichPresenceContext, default_value),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RichPresenceContext, index),
            },
            FieldInfoData {
                name: "StatCode",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceContext, stat_code),
            },
        ],
    }),
    array_type: Some(RICHPRESENCECONTEXT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceContext {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCECONTEXT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCECONTEXT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContext-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceContext"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RichPresenceContextValueWithKey {
    pub _glacier_base: RichPresenceContextValue,
    pub key: String,
}

pub trait RichPresenceContextValueWithKeyTrait: RichPresenceContextValueTrait {
    fn key(&self) -> &String;
    fn key_mut(&mut self) -> &mut String;
}

impl RichPresenceContextValueWithKeyTrait for RichPresenceContextValueWithKey {
    fn key(&self) -> &String {
        &self.key
    }
    fn key_mut(&mut self) -> &mut String {
        &mut self.key
    }
}

impl RichPresenceContextValueTrait for RichPresenceContextValueWithKey {
    fn s_i_d(&self) -> &String {
        self._glacier_base.s_i_d()
    }
    fn s_i_d_mut(&mut self) -> &mut String {
        self._glacier_base.s_i_d_mut()
    }
    fn index(&self) -> &u8 {
        self._glacier_base.index()
    }
    fn index_mut(&mut self) -> &mut u8 {
        self._glacier_base.index_mut()
    }
}

impl super::core::DataContainerTrait for RichPresenceContextValueWithKey {
}

pub static RICHPRESENCECONTEXTVALUEWITHKEY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextValueWithKey",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RICHPRESENCECONTEXTVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceContextValueWithKey as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Key",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceContextValueWithKey, key),
            },
        ],
    }),
    array_type: Some(RICHPRESENCECONTEXTVALUEWITHKEY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceContextValueWithKey {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCECONTEXTVALUEWITHKEY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCECONTEXTVALUEWITHKEY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextValueWithKey-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceContextValueWithKey"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RichPresenceContextValue {
    pub _glacier_base: super::core::DataContainer,
    pub s_i_d: String,
    pub index: u8,
}

pub trait RichPresenceContextValueTrait: super::core::DataContainerTrait {
    fn s_i_d(&self) -> &String;
    fn s_i_d_mut(&mut self) -> &mut String;
    fn index(&self) -> &u8;
    fn index_mut(&mut self) -> &mut u8;
}

impl RichPresenceContextValueTrait for RichPresenceContextValue {
    fn s_i_d(&self) -> &String {
        &self.s_i_d
    }
    fn s_i_d_mut(&mut self) -> &mut String {
        &mut self.s_i_d
    }
    fn index(&self) -> &u8 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut u8 {
        &mut self.index
    }
}

impl super::core::DataContainerTrait for RichPresenceContextValue {
}

pub static RICHPRESENCECONTEXTVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextValue",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresenceContextValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SID",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresenceContextValue, s_i_d),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RichPresenceContextValue, index),
            },
        ],
    }),
    array_type: Some(RICHPRESENCECONTEXTVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresenceContextValue {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCECONTEXTVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCECONTEXTVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresenceContextValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresenceContextValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RichPresencePresenceString {
    pub _glacier_base: super::core::DataContainer,
    pub s_i_d: String,
    pub interpolated: bool,
    pub index: u8,
}

pub trait RichPresencePresenceStringTrait: super::core::DataContainerTrait {
    fn s_i_d(&self) -> &String;
    fn s_i_d_mut(&mut self) -> &mut String;
    fn interpolated(&self) -> &bool;
    fn interpolated_mut(&mut self) -> &mut bool;
    fn index(&self) -> &u8;
    fn index_mut(&mut self) -> &mut u8;
}

impl RichPresencePresenceStringTrait for RichPresencePresenceString {
    fn s_i_d(&self) -> &String {
        &self.s_i_d
    }
    fn s_i_d_mut(&mut self) -> &mut String {
        &mut self.s_i_d
    }
    fn interpolated(&self) -> &bool {
        &self.interpolated
    }
    fn interpolated_mut(&mut self) -> &mut bool {
        &mut self.interpolated
    }
    fn index(&self) -> &u8 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut u8 {
        &mut self.index
    }
}

impl super::core::DataContainerTrait for RichPresencePresenceString {
}

pub static RICHPRESENCEPRESENCESTRING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresencePresenceString",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RichPresencePresenceString as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SID",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(RichPresencePresenceString, s_i_d),
            },
            FieldInfoData {
                name: "Interpolated",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RichPresencePresenceString, interpolated),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(RichPresencePresenceString, index),
            },
        ],
    }),
    array_type: Some(RICHPRESENCEPRESENCESTRING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RichPresencePresenceString {
    fn type_info(&self) -> &'static TypeInfo {
        RICHPRESENCEPRESENCESTRING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RICHPRESENCEPRESENCESTRING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RichPresencePresenceString-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RichPresencePresenceString"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PersistenceData {
    pub _glacier_base: AbstractPersistenceData,
    pub persistence_name: String,
    pub club_persistence_name: String,
    pub delta_game_reports: bool,
    pub values: Vec<PersistentValueTemplateData>,
    pub server_default_group: Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>>,
    pub client_default_group: Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>>,
    pub retention_policy: Option<Arc<Mutex<dyn PersistenceRetentionPolicyTrait>>>,
    pub history_daily: bool,
    pub history_weekly: bool,
    pub history_monthly: bool,
    pub output_properties: bool,
    pub consumable_mappings: Vec<PersistenceConsumableMapping>,
}

pub trait PersistenceDataTrait: AbstractPersistenceDataTrait {
    fn persistence_name(&self) -> &String;
    fn persistence_name_mut(&mut self) -> &mut String;
    fn club_persistence_name(&self) -> &String;
    fn club_persistence_name_mut(&mut self) -> &mut String;
    fn delta_game_reports(&self) -> &bool;
    fn delta_game_reports_mut(&mut self) -> &mut bool;
    fn values(&self) -> &Vec<PersistentValueTemplateData>;
    fn values_mut(&mut self) -> &mut Vec<PersistentValueTemplateData>;
    fn server_default_group(&self) -> &Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>>;
    fn server_default_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>>;
    fn client_default_group(&self) -> &Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>>;
    fn client_default_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>>;
    fn retention_policy(&self) -> &Option<Arc<Mutex<dyn PersistenceRetentionPolicyTrait>>>;
    fn retention_policy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PersistenceRetentionPolicyTrait>>>;
    fn history_daily(&self) -> &bool;
    fn history_daily_mut(&mut self) -> &mut bool;
    fn history_weekly(&self) -> &bool;
    fn history_weekly_mut(&mut self) -> &mut bool;
    fn history_monthly(&self) -> &bool;
    fn history_monthly_mut(&mut self) -> &mut bool;
    fn output_properties(&self) -> &bool;
    fn output_properties_mut(&mut self) -> &mut bool;
    fn consumable_mappings(&self) -> &Vec<PersistenceConsumableMapping>;
    fn consumable_mappings_mut(&mut self) -> &mut Vec<PersistenceConsumableMapping>;
}

impl PersistenceDataTrait for PersistenceData {
    fn persistence_name(&self) -> &String {
        &self.persistence_name
    }
    fn persistence_name_mut(&mut self) -> &mut String {
        &mut self.persistence_name
    }
    fn club_persistence_name(&self) -> &String {
        &self.club_persistence_name
    }
    fn club_persistence_name_mut(&mut self) -> &mut String {
        &mut self.club_persistence_name
    }
    fn delta_game_reports(&self) -> &bool {
        &self.delta_game_reports
    }
    fn delta_game_reports_mut(&mut self) -> &mut bool {
        &mut self.delta_game_reports
    }
    fn values(&self) -> &Vec<PersistentValueTemplateData> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<PersistentValueTemplateData> {
        &mut self.values
    }
    fn server_default_group(&self) -> &Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>> {
        &self.server_default_group
    }
    fn server_default_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>> {
        &mut self.server_default_group
    }
    fn client_default_group(&self) -> &Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>> {
        &self.client_default_group
    }
    fn client_default_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PersistenceStatGroupTrait>>> {
        &mut self.client_default_group
    }
    fn retention_policy(&self) -> &Option<Arc<Mutex<dyn PersistenceRetentionPolicyTrait>>> {
        &self.retention_policy
    }
    fn retention_policy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PersistenceRetentionPolicyTrait>>> {
        &mut self.retention_policy
    }
    fn history_daily(&self) -> &bool {
        &self.history_daily
    }
    fn history_daily_mut(&mut self) -> &mut bool {
        &mut self.history_daily
    }
    fn history_weekly(&self) -> &bool {
        &self.history_weekly
    }
    fn history_weekly_mut(&mut self) -> &mut bool {
        &mut self.history_weekly
    }
    fn history_monthly(&self) -> &bool {
        &self.history_monthly
    }
    fn history_monthly_mut(&mut self) -> &mut bool {
        &mut self.history_monthly
    }
    fn output_properties(&self) -> &bool {
        &self.output_properties
    }
    fn output_properties_mut(&mut self) -> &mut bool {
        &mut self.output_properties
    }
    fn consumable_mappings(&self) -> &Vec<PersistenceConsumableMapping> {
        &self.consumable_mappings
    }
    fn consumable_mappings_mut(&mut self) -> &mut Vec<PersistenceConsumableMapping> {
        &mut self.consumable_mappings
    }
}

impl AbstractPersistenceDataTrait for PersistenceData {
}

impl super::core::AssetTrait for PersistenceData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PersistenceData {
}

pub static PERSISTENCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTPERSISTENCEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PersistenceName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistenceData, persistence_name),
            },
            FieldInfoData {
                name: "ClubPersistenceName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistenceData, club_persistence_name),
            },
            FieldInfoData {
                name: "DeltaGameReports",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, delta_game_reports),
            },
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "PersistentValueTemplateData-Array",
                rust_offset: offset_of!(PersistenceData, values),
            },
            FieldInfoData {
                name: "ServerDefaultGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "PersistenceStatGroup",
                rust_offset: offset_of!(PersistenceData, server_default_group),
            },
            FieldInfoData {
                name: "ClientDefaultGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "PersistenceStatGroup",
                rust_offset: offset_of!(PersistenceData, client_default_group),
            },
            FieldInfoData {
                name: "RetentionPolicy",
                flags: MemberInfoFlags::new(0),
                field_type: "PersistenceRetentionPolicy",
                rust_offset: offset_of!(PersistenceData, retention_policy),
            },
            FieldInfoData {
                name: "HistoryDaily",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, history_daily),
            },
            FieldInfoData {
                name: "HistoryWeekly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, history_weekly),
            },
            FieldInfoData {
                name: "HistoryMonthly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, history_monthly),
            },
            FieldInfoData {
                name: "OutputProperties",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistenceData, output_properties),
            },
            FieldInfoData {
                name: "ConsumableMappings",
                flags: MemberInfoFlags::new(144),
                field_type: "PersistenceConsumableMapping-Array",
                rust_offset: offset_of!(PersistenceData, consumable_mappings),
            },
        ],
    }),
    array_type: Some(PERSISTENCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceData {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PersistenceConsumableMapping {
    pub group: ConsumableGroup,
}

pub trait PersistenceConsumableMappingTrait: TypeObject {
    fn group(&self) -> &ConsumableGroup;
    fn group_mut(&mut self) -> &mut ConsumableGroup;
}

impl PersistenceConsumableMappingTrait for PersistenceConsumableMapping {
    fn group(&self) -> &ConsumableGroup {
        &self.group
    }
    fn group_mut(&mut self) -> &mut ConsumableGroup {
        &mut self.group
    }
}

pub static PERSISTENCECONSUMABLEMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceConsumableMapping",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceConsumableMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: "ConsumableGroup",
                rust_offset: offset_of!(PersistenceConsumableMapping, group),
            },
        ],
    }),
    array_type: Some(PERSISTENCECONSUMABLEMAPPING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PersistenceConsumableMapping {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCECONSUMABLEMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENCECONSUMABLEMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceConsumableMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceConsumableMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistenceGameType {
    #[default]
    PersistenceGameType_Singleplayer = 0,
    PersistenceGameType_Cooperative = 1,
    PersistenceGameType_Multiplayer = 2,
    PersistenceGameType_Count = 3,
}

pub static PERSISTENCEGAMETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceGameType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENCEGAMETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistenceGameType {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCEGAMETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENCEGAMETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceGameType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceGameType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PersistenceRetentionPolicy {
    pub _glacier_base: super::core::Asset,
    pub daily_history_count: i32,
    pub weekly_history_count: i32,
    pub monthly_history_count: i32,
}

pub trait PersistenceRetentionPolicyTrait: super::core::AssetTrait {
    fn daily_history_count(&self) -> &i32;
    fn daily_history_count_mut(&mut self) -> &mut i32;
    fn weekly_history_count(&self) -> &i32;
    fn weekly_history_count_mut(&mut self) -> &mut i32;
    fn monthly_history_count(&self) -> &i32;
    fn monthly_history_count_mut(&mut self) -> &mut i32;
}

impl PersistenceRetentionPolicyTrait for PersistenceRetentionPolicy {
    fn daily_history_count(&self) -> &i32 {
        &self.daily_history_count
    }
    fn daily_history_count_mut(&mut self) -> &mut i32 {
        &mut self.daily_history_count
    }
    fn weekly_history_count(&self) -> &i32 {
        &self.weekly_history_count
    }
    fn weekly_history_count_mut(&mut self) -> &mut i32 {
        &mut self.weekly_history_count
    }
    fn monthly_history_count(&self) -> &i32 {
        &self.monthly_history_count
    }
    fn monthly_history_count_mut(&mut self) -> &mut i32 {
        &mut self.monthly_history_count
    }
}

impl super::core::AssetTrait for PersistenceRetentionPolicy {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PersistenceRetentionPolicy {
}

pub static PERSISTENCERETENTIONPOLICY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceRetentionPolicy",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistenceRetentionPolicy as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DailyHistoryCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PersistenceRetentionPolicy, daily_history_count),
            },
            FieldInfoData {
                name: "WeeklyHistoryCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PersistenceRetentionPolicy, weekly_history_count),
            },
            FieldInfoData {
                name: "MonthlyHistoryCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PersistenceRetentionPolicy, monthly_history_count),
            },
        ],
    }),
    array_type: Some(PERSISTENCERETENTIONPOLICY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistenceRetentionPolicy {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENCERETENTIONPOLICY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENCERETENTIONPOLICY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistenceRetentionPolicy-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistenceRetentionPolicy"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum StatPeriod {
    #[default]
    StatPeriod_AllTime = 0,
    StatPeriod_Monthly = 1,
    StatPeriod_Weekly = 2,
    StatPeriod_Daily = 3,
    StatPeriod_Size = 4,
    StatPeriod_Error = 5,
}

pub static STATPERIOD_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StatPeriod",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(STATPERIOD_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for StatPeriod {
    fn type_info(&self) -> &'static TypeInfo {
        STATPERIOD_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STATPERIOD_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StatPeriod-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StatPeriod"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PersistentValueTemplateStatRef {
    pub _glacier_base: AbstractPersistentStatRef,
    pub definition: Option<Arc<Mutex<dyn PersistentValueTemplateTrait>>>,
}

pub trait PersistentValueTemplateStatRefTrait: AbstractPersistentStatRefTrait {
    fn definition(&self) -> &Option<Arc<Mutex<dyn PersistentValueTemplateTrait>>>;
    fn definition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PersistentValueTemplateTrait>>>;
}

impl PersistentValueTemplateStatRefTrait for PersistentValueTemplateStatRef {
    fn definition(&self) -> &Option<Arc<Mutex<dyn PersistentValueTemplateTrait>>> {
        &self.definition
    }
    fn definition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PersistentValueTemplateTrait>>> {
        &mut self.definition
    }
}

impl AbstractPersistentStatRefTrait for PersistentValueTemplateStatRef {
}

impl super::core::DataContainerTrait for PersistentValueTemplateStatRef {
}

pub static PERSISTENTVALUETEMPLATESTATREF_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplateStatRef",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTPERSISTENTSTATREF_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistentValueTemplateStatRef as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Definition",
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueTemplate",
                rust_offset: offset_of!(PersistentValueTemplateStatRef, definition),
            },
        ],
    }),
    array_type: Some(PERSISTENTVALUETEMPLATESTATREF_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistentValueTemplateStatRef {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUETEMPLATESTATREF_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENTVALUETEMPLATESTATREF_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplateStatRef-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueTemplateStatRef"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbstractPersistentStatRef {
    pub _glacier_base: super::core::DataContainer,
}

pub trait AbstractPersistentStatRefTrait: super::core::DataContainerTrait {
}

impl AbstractPersistentStatRefTrait for AbstractPersistentStatRef {
}

impl super::core::DataContainerTrait for AbstractPersistentStatRef {
}

pub static ABSTRACTPERSISTENTSTATREF_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractPersistentStatRef",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbstractPersistentStatRef as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ABSTRACTPERSISTENTSTATREF_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbstractPersistentStatRef {
    fn type_info(&self) -> &'static TypeInfo {
        ABSTRACTPERSISTENTSTATREF_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ABSTRACTPERSISTENTSTATREF_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractPersistentStatRef-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AbstractPersistentStatRef"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PersistentValueTemplate {
    pub _glacier_base: super::core::DataContainer,
    pub data: PersistentValueTemplateData,
    pub derived_formula_refs: Vec<Option<Arc<Mutex<dyn AbstractPersistentStatRefTrait>>>>,
}

pub trait PersistentValueTemplateTrait: super::core::DataContainerTrait {
    fn data(&self) -> &PersistentValueTemplateData;
    fn data_mut(&mut self) -> &mut PersistentValueTemplateData;
    fn derived_formula_refs(&self) -> &Vec<Option<Arc<Mutex<dyn AbstractPersistentStatRefTrait>>>>;
    fn derived_formula_refs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AbstractPersistentStatRefTrait>>>>;
}

impl PersistentValueTemplateTrait for PersistentValueTemplate {
    fn data(&self) -> &PersistentValueTemplateData {
        &self.data
    }
    fn data_mut(&mut self) -> &mut PersistentValueTemplateData {
        &mut self.data
    }
    fn derived_formula_refs(&self) -> &Vec<Option<Arc<Mutex<dyn AbstractPersistentStatRefTrait>>>> {
        &self.derived_formula_refs
    }
    fn derived_formula_refs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AbstractPersistentStatRefTrait>>>> {
        &mut self.derived_formula_refs
    }
}

impl super::core::DataContainerTrait for PersistentValueTemplate {
}

pub static PERSISTENTVALUETEMPLATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplate",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistentValueTemplate as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Data",
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueTemplateData",
                rust_offset: offset_of!(PersistentValueTemplate, data),
            },
            FieldInfoData {
                name: "DerivedFormulaRefs",
                flags: MemberInfoFlags::new(144),
                field_type: "AbstractPersistentStatRef-Array",
                rust_offset: offset_of!(PersistentValueTemplate, derived_formula_refs),
            },
        ],
    }),
    array_type: Some(PERSISTENTVALUETEMPLATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistentValueTemplate {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUETEMPLATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PERSISTENTVALUETEMPLATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplate-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueTemplate"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PersistentValueTemplateData {
    pub name: String,
    pub default_value: String,
    pub default_float_value: f32,
    pub value_type: PersistentValueType,
    pub data_type: PersistentValueDataType,
    pub history_type: PersistentValueHistoryType,
    pub club_stat: bool,
}

pub trait PersistentValueTemplateDataTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn default_value(&self) -> &String;
    fn default_value_mut(&mut self) -> &mut String;
    fn default_float_value(&self) -> &f32;
    fn default_float_value_mut(&mut self) -> &mut f32;
    fn value_type(&self) -> &PersistentValueType;
    fn value_type_mut(&mut self) -> &mut PersistentValueType;
    fn data_type(&self) -> &PersistentValueDataType;
    fn data_type_mut(&mut self) -> &mut PersistentValueDataType;
    fn history_type(&self) -> &PersistentValueHistoryType;
    fn history_type_mut(&mut self) -> &mut PersistentValueHistoryType;
    fn club_stat(&self) -> &bool;
    fn club_stat_mut(&mut self) -> &mut bool;
}

impl PersistentValueTemplateDataTrait for PersistentValueTemplateData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn default_value(&self) -> &String {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut String {
        &mut self.default_value
    }
    fn default_float_value(&self) -> &f32 {
        &self.default_float_value
    }
    fn default_float_value_mut(&mut self) -> &mut f32 {
        &mut self.default_float_value
    }
    fn value_type(&self) -> &PersistentValueType {
        &self.value_type
    }
    fn value_type_mut(&mut self) -> &mut PersistentValueType {
        &mut self.value_type
    }
    fn data_type(&self) -> &PersistentValueDataType {
        &self.data_type
    }
    fn data_type_mut(&mut self) -> &mut PersistentValueDataType {
        &mut self.data_type
    }
    fn history_type(&self) -> &PersistentValueHistoryType {
        &self.history_type
    }
    fn history_type_mut(&mut self) -> &mut PersistentValueHistoryType {
        &mut self.history_type
    }
    fn club_stat(&self) -> &bool {
        &self.club_stat
    }
    fn club_stat_mut(&mut self) -> &mut bool {
        &mut self.club_stat
    }
}

pub static PERSISTENTVALUETEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplateData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PersistentValueTemplateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistentValueTemplateData, name),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PersistentValueTemplateData, default_value),
            },
            FieldInfoData {
                name: "DefaultFloatValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PersistentValueTemplateData, default_float_value),
            },
            FieldInfoData {
                name: "ValueType",
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueType",
                rust_offset: offset_of!(PersistentValueTemplateData, value_type),
            },
            FieldInfoData {
                name: "DataType",
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueDataType",
                rust_offset: offset_of!(PersistentValueTemplateData, data_type),
            },
            FieldInfoData {
                name: "HistoryType",
                flags: MemberInfoFlags::new(0),
                field_type: "PersistentValueHistoryType",
                rust_offset: offset_of!(PersistentValueTemplateData, history_type),
            },
            FieldInfoData {
                name: "ClubStat",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PersistentValueTemplateData, club_stat),
            },
        ],
    }),
    array_type: Some(PERSISTENTVALUETEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PersistentValueTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUETEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUETEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueTemplateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistentValueDataKind {
    #[default]
    PersistentValueDataKind_Raw = 0,
    PersistentValueDataKind_Seconds = 1,
    PersistentValueDataKind_Minutes = 2,
    PersistentValueDataKind_Hours = 3,
    PersistentValueDataKind_Percent = 4,
}

pub static PERSISTENTVALUEDATAKIND_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueDataKind",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENTVALUEDATAKIND_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistentValueDataKind {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUEDATAKIND_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUEDATAKIND_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueDataKind-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueDataKind"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistentValueDataType {
    #[default]
    PersistentValueDataType_Decimal = 0,
    PersistentValueDataType_Integer = 1,
    PersistentValueDataType_String = 2,
}

pub static PERSISTENTVALUEDATATYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueDataType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENTVALUEDATATYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistentValueDataType {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUEDATATYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUEDATATYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueDataType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueDataType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersistentValueType {
    #[default]
    PersistentValueType_Set = 0,
    PersistentValueType_High = 1,
    PersistentValueType_Low = 2,
    PersistentValueType_Increment = 3,
    PersistentValueType_Decrement = 4,
}

pub static PERSISTENTVALUETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSISTENTVALUETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersistentValueType {
    fn type_info(&self) -> &'static TypeInfo {
        PERSISTENTVALUETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSISTENTVALUETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersistentValueType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersistentValueType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ConsumableGroup {
    #[default]
    ConsumableGroup_0 = 0,
    ConsumableGroup_1 = 1,
    ConsumableGroup_2 = 2,
    ConsumableGroup_3 = 3,
    ConsumableGroup_4 = 4,
    ConsumableGroup_5 = 5,
    ConsumableGroup_6 = 6,
    ConsumableGroup_7 = 7,
    ConsumableGroup_Count = 8,
}

pub static CONSUMABLEGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsumableGroup",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CONSUMABLEGROUP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ConsumableGroup {
    fn type_info(&self) -> &'static TypeInfo {
        CONSUMABLEGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CONSUMABLEGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsumableGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ConsumableGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PA2TargetComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub target_properties: Option<Arc<Mutex<dyn PA2TargetPropertiesTrait>>>,
}

pub trait PA2TargetComponentDataTrait: super::entity::GameComponentDataTrait {
    fn target_properties(&self) -> &Option<Arc<Mutex<dyn PA2TargetPropertiesTrait>>>;
    fn target_properties_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PA2TargetPropertiesTrait>>>;
}

impl PA2TargetComponentDataTrait for PA2TargetComponentData {
    fn target_properties(&self) -> &Option<Arc<Mutex<dyn PA2TargetPropertiesTrait>>> {
        &self.target_properties
    }
    fn target_properties_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PA2TargetPropertiesTrait>>> {
        &mut self.target_properties
    }
}

impl super::entity::GameComponentDataTrait for PA2TargetComponentData {
}

impl super::entity::ComponentDataTrait for PA2TargetComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for PA2TargetComponentData {
}

impl super::core::DataBusPeerTrait for PA2TargetComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PA2TargetComponentData {
}

impl super::core::DataContainerTrait for PA2TargetComponentData {
}

pub static PA2TARGETCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2TargetComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PA2TargetComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetProperties",
                flags: MemberInfoFlags::new(0),
                field_type: "PA2TargetProperties",
                rust_offset: offset_of!(PA2TargetComponentData, target_properties),
            },
        ],
    }),
    array_type: Some(PA2TARGETCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PA2TargetComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PA2TARGETCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PA2TARGETCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2TargetComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PA2TargetComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PA2TargetProperties {
    pub _glacier_base: super::core::Asset,
    pub bone_targets: Vec<Option<Arc<Mutex<dyn PA2BoneListTrait>>>>,
}

pub trait PA2TargetPropertiesTrait: super::core::AssetTrait {
    fn bone_targets(&self) -> &Vec<Option<Arc<Mutex<dyn PA2BoneListTrait>>>>;
    fn bone_targets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn PA2BoneListTrait>>>>;
}

impl PA2TargetPropertiesTrait for PA2TargetProperties {
    fn bone_targets(&self) -> &Vec<Option<Arc<Mutex<dyn PA2BoneListTrait>>>> {
        &self.bone_targets
    }
    fn bone_targets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn PA2BoneListTrait>>>> {
        &mut self.bone_targets
    }
}

impl super::core::AssetTrait for PA2TargetProperties {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for PA2TargetProperties {
}

pub static PA2TARGETPROPERTIES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2TargetProperties",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PA2TargetProperties as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoneTargets",
                flags: MemberInfoFlags::new(144),
                field_type: "PA2BoneList-Array",
                rust_offset: offset_of!(PA2TargetProperties, bone_targets),
            },
        ],
    }),
    array_type: Some(PA2TARGETPROPERTIES_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PA2TargetProperties {
    fn type_info(&self) -> &'static TypeInfo {
        PA2TARGETPROPERTIES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PA2TARGETPROPERTIES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2TargetProperties-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PA2TargetProperties"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PA2BoneList {
    pub _glacier_base: super::core::DataContainer,
    pub bones: Vec<Option<Arc<Mutex<dyn PA2BoneTrait>>>>,
}

pub trait PA2BoneListTrait: super::core::DataContainerTrait {
    fn bones(&self) -> &Vec<Option<Arc<Mutex<dyn PA2BoneTrait>>>>;
    fn bones_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn PA2BoneTrait>>>>;
}

impl PA2BoneListTrait for PA2BoneList {
    fn bones(&self) -> &Vec<Option<Arc<Mutex<dyn PA2BoneTrait>>>> {
        &self.bones
    }
    fn bones_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn PA2BoneTrait>>>> {
        &mut self.bones
    }
}

impl super::core::DataContainerTrait for PA2BoneList {
}

pub static PA2BONELIST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2BoneList",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PA2BoneList as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Bones",
                flags: MemberInfoFlags::new(144),
                field_type: "PA2Bone-Array",
                rust_offset: offset_of!(PA2BoneList, bones),
            },
        ],
    }),
    array_type: Some(PA2BONELIST_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PA2BoneList {
    fn type_info(&self) -> &'static TypeInfo {
        PA2BONELIST_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PA2BONELIST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2BoneList-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PA2BoneList"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PA2Bone {
    pub _glacier_base: super::core::DataContainer,
    pub bone: u32,
}

pub trait PA2BoneTrait: super::core::DataContainerTrait {
    fn bone(&self) -> &u32;
    fn bone_mut(&mut self) -> &mut u32;
}

impl PA2BoneTrait for PA2Bone {
    fn bone(&self) -> &u32 {
        &self.bone
    }
    fn bone_mut(&mut self) -> &mut u32 {
        &mut self.bone
    }
}

impl super::core::DataContainerTrait for PA2Bone {
}

pub static PA2BONE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2Bone",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PA2Bone as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Bone",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PA2Bone, bone),
            },
        ],
    }),
    array_type: Some(PA2BONE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PA2Bone {
    fn type_info(&self) -> &'static TypeInfo {
        PA2BONE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PA2BONE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PA2Bone-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PA2Bone"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectHighlightEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub player_id: super::core::LocalPlayerId,
    pub object_highlight_type: super::world_base::ObjectHighlightType,
    pub index: i32,
    pub enable: bool,
    pub draw_at_foreground: bool,
    pub is_mask: bool,
}

pub trait ObjectHighlightEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn player_id(&self) -> &super::core::LocalPlayerId;
    fn player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
    fn object_highlight_type(&self) -> &super::world_base::ObjectHighlightType;
    fn object_highlight_type_mut(&mut self) -> &mut super::world_base::ObjectHighlightType;
    fn index(&self) -> &i32;
    fn index_mut(&mut self) -> &mut i32;
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn draw_at_foreground(&self) -> &bool;
    fn draw_at_foreground_mut(&mut self) -> &mut bool;
    fn is_mask(&self) -> &bool;
    fn is_mask_mut(&mut self) -> &mut bool;
}

impl ObjectHighlightEntityDataTrait for ObjectHighlightEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn player_id(&self) -> &super::core::LocalPlayerId {
        &self.player_id
    }
    fn player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.player_id
    }
    fn object_highlight_type(&self) -> &super::world_base::ObjectHighlightType {
        &self.object_highlight_type
    }
    fn object_highlight_type_mut(&mut self) -> &mut super::world_base::ObjectHighlightType {
        &mut self.object_highlight_type
    }
    fn index(&self) -> &i32 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut i32 {
        &mut self.index
    }
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn draw_at_foreground(&self) -> &bool {
        &self.draw_at_foreground
    }
    fn draw_at_foreground_mut(&mut self) -> &mut bool {
        &mut self.draw_at_foreground
    }
    fn is_mask(&self) -> &bool {
        &self.is_mask
    }
    fn is_mask_mut(&mut self) -> &mut bool {
        &mut self.is_mask
    }
}

impl super::entity::EntityDataTrait for ObjectHighlightEntityData {
}

impl super::entity::GameObjectDataTrait for ObjectHighlightEntityData {
}

impl super::core::DataBusPeerTrait for ObjectHighlightEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectHighlightEntityData {
}

impl super::core::DataContainerTrait for ObjectHighlightEntityData {
}

pub static OBJECTHIGHLIGHTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectHighlightEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectHighlightEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ObjectHighlightEntityData, realm),
            },
            FieldInfoData {
                name: "PlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(ObjectHighlightEntityData, player_id),
            },
            FieldInfoData {
                name: "ObjectHighlightType",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectHighlightType",
                rust_offset: offset_of!(ObjectHighlightEntityData, object_highlight_type),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ObjectHighlightEntityData, index),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectHighlightEntityData, enable),
            },
            FieldInfoData {
                name: "DrawAtForeground",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectHighlightEntityData, draw_at_foreground),
            },
            FieldInfoData {
                name: "IsMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectHighlightEntityData, is_mask),
            },
        ],
    }),
    array_type: Some(OBJECTHIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectHighlightEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTHIGHLIGHTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTHIGHLIGHTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectHighlightEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ObjectHighlightEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterInVehicleScenarioEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub scenario_ant_ref: super::ant::AntRef,
    pub level_id: i32,
    pub scenario_id: i32,
    pub actor_id: i32,
    pub part_id: i32,
    pub enabled: bool,
}

pub trait CharacterInVehicleScenarioEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn scenario_ant_ref(&self) -> &super::ant::AntRef;
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef;
    fn level_id(&self) -> &i32;
    fn level_id_mut(&mut self) -> &mut i32;
    fn scenario_id(&self) -> &i32;
    fn scenario_id_mut(&mut self) -> &mut i32;
    fn actor_id(&self) -> &i32;
    fn actor_id_mut(&mut self) -> &mut i32;
    fn part_id(&self) -> &i32;
    fn part_id_mut(&mut self) -> &mut i32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl CharacterInVehicleScenarioEntityDataTrait for CharacterInVehicleScenarioEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn scenario_ant_ref(&self) -> &super::ant::AntRef {
        &self.scenario_ant_ref
    }
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.scenario_ant_ref
    }
    fn level_id(&self) -> &i32 {
        &self.level_id
    }
    fn level_id_mut(&mut self) -> &mut i32 {
        &mut self.level_id
    }
    fn scenario_id(&self) -> &i32 {
        &self.scenario_id
    }
    fn scenario_id_mut(&mut self) -> &mut i32 {
        &mut self.scenario_id
    }
    fn actor_id(&self) -> &i32 {
        &self.actor_id
    }
    fn actor_id_mut(&mut self) -> &mut i32 {
        &mut self.actor_id
    }
    fn part_id(&self) -> &i32 {
        &self.part_id
    }
    fn part_id_mut(&mut self) -> &mut i32 {
        &mut self.part_id
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for CharacterInVehicleScenarioEntityData {
}

impl super::entity::GameObjectDataTrait for CharacterInVehicleScenarioEntityData {
}

impl super::core::DataBusPeerTrait for CharacterInVehicleScenarioEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterInVehicleScenarioEntityData {
}

impl super::core::DataContainerTrait for CharacterInVehicleScenarioEntityData {
}

pub static CHARACTERINVEHICLESCENARIOENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterInVehicleScenarioEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterInVehicleScenarioEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, realm),
            },
            FieldInfoData {
                name: "ScenarioAntRef",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, scenario_ant_ref),
            },
            FieldInfoData {
                name: "LevelId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, level_id),
            },
            FieldInfoData {
                name: "ScenarioId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, scenario_id),
            },
            FieldInfoData {
                name: "ActorId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, actor_id),
            },
            FieldInfoData {
                name: "PartId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, part_id),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterInVehicleScenarioEntityData, enabled),
            },
        ],
    }),
    array_type: Some(CHARACTERINVEHICLESCENARIOENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterInVehicleScenarioEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERINVEHICLESCENARIOENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERINVEHICLESCENARIOENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterInVehicleScenarioEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterInVehicleScenarioEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultipleActorScenarioEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub world_space: bool,
    pub world_space_connect_transform: super::core::LinearTransform,
    pub scenario_ant_ref: super::ant::AntRef,
    pub level_choice: i32,
    pub scenario_choice: i32,
    pub aligning_enabled: bool,
    pub use_input_event_player_as_player1: bool,
    pub actor1: i32,
    pub actor1_part: i32,
    pub actor1_second_part: i32,
    pub actor2: i32,
    pub actor2_part: i32,
    pub actor2_second_part: i32,
    pub actor3: i32,
    pub actor3_part: i32,
    pub actor3_second_part: i32,
    pub actor4: i32,
    pub actor4_part: i32,
    pub actor4_second_part: i32,
    pub actor5: i32,
    pub actor5_part: i32,
    pub actor5_second_part: i32,
    pub actor6: i32,
    pub actor6_part: i32,
    pub actor6_second_part: i32,
    pub scenario_active: bool,
    pub actor1_prepared: bool,
    pub actor2_prepared: bool,
    pub actor3_prepared: bool,
    pub actor4_prepared: bool,
    pub actor5_prepared: bool,
    pub actor6_prepared: bool,
    pub check_actor1_finished: bool,
    pub check_actor2_finished: bool,
    pub check_actor3_finished: bool,
    pub check_actor4_finished: bool,
    pub check_actor5_finished: bool,
    pub check_actor6_finished: bool,
    pub external_time: f32,
    pub use_external_time: bool,
    pub realm: super::core::Realm,
}

pub trait MultipleActorScenarioEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn world_space(&self) -> &bool;
    fn world_space_mut(&mut self) -> &mut bool;
    fn world_space_connect_transform(&self) -> &super::core::LinearTransform;
    fn world_space_connect_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn scenario_ant_ref(&self) -> &super::ant::AntRef;
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef;
    fn level_choice(&self) -> &i32;
    fn level_choice_mut(&mut self) -> &mut i32;
    fn scenario_choice(&self) -> &i32;
    fn scenario_choice_mut(&mut self) -> &mut i32;
    fn aligning_enabled(&self) -> &bool;
    fn aligning_enabled_mut(&mut self) -> &mut bool;
    fn use_input_event_player_as_player1(&self) -> &bool;
    fn use_input_event_player_as_player1_mut(&mut self) -> &mut bool;
    fn actor1(&self) -> &i32;
    fn actor1_mut(&mut self) -> &mut i32;
    fn actor1_part(&self) -> &i32;
    fn actor1_part_mut(&mut self) -> &mut i32;
    fn actor1_second_part(&self) -> &i32;
    fn actor1_second_part_mut(&mut self) -> &mut i32;
    fn actor2(&self) -> &i32;
    fn actor2_mut(&mut self) -> &mut i32;
    fn actor2_part(&self) -> &i32;
    fn actor2_part_mut(&mut self) -> &mut i32;
    fn actor2_second_part(&self) -> &i32;
    fn actor2_second_part_mut(&mut self) -> &mut i32;
    fn actor3(&self) -> &i32;
    fn actor3_mut(&mut self) -> &mut i32;
    fn actor3_part(&self) -> &i32;
    fn actor3_part_mut(&mut self) -> &mut i32;
    fn actor3_second_part(&self) -> &i32;
    fn actor3_second_part_mut(&mut self) -> &mut i32;
    fn actor4(&self) -> &i32;
    fn actor4_mut(&mut self) -> &mut i32;
    fn actor4_part(&self) -> &i32;
    fn actor4_part_mut(&mut self) -> &mut i32;
    fn actor4_second_part(&self) -> &i32;
    fn actor4_second_part_mut(&mut self) -> &mut i32;
    fn actor5(&self) -> &i32;
    fn actor5_mut(&mut self) -> &mut i32;
    fn actor5_part(&self) -> &i32;
    fn actor5_part_mut(&mut self) -> &mut i32;
    fn actor5_second_part(&self) -> &i32;
    fn actor5_second_part_mut(&mut self) -> &mut i32;
    fn actor6(&self) -> &i32;
    fn actor6_mut(&mut self) -> &mut i32;
    fn actor6_part(&self) -> &i32;
    fn actor6_part_mut(&mut self) -> &mut i32;
    fn actor6_second_part(&self) -> &i32;
    fn actor6_second_part_mut(&mut self) -> &mut i32;
    fn scenario_active(&self) -> &bool;
    fn scenario_active_mut(&mut self) -> &mut bool;
    fn actor1_prepared(&self) -> &bool;
    fn actor1_prepared_mut(&mut self) -> &mut bool;
    fn actor2_prepared(&self) -> &bool;
    fn actor2_prepared_mut(&mut self) -> &mut bool;
    fn actor3_prepared(&self) -> &bool;
    fn actor3_prepared_mut(&mut self) -> &mut bool;
    fn actor4_prepared(&self) -> &bool;
    fn actor4_prepared_mut(&mut self) -> &mut bool;
    fn actor5_prepared(&self) -> &bool;
    fn actor5_prepared_mut(&mut self) -> &mut bool;
    fn actor6_prepared(&self) -> &bool;
    fn actor6_prepared_mut(&mut self) -> &mut bool;
    fn check_actor1_finished(&self) -> &bool;
    fn check_actor1_finished_mut(&mut self) -> &mut bool;
    fn check_actor2_finished(&self) -> &bool;
    fn check_actor2_finished_mut(&mut self) -> &mut bool;
    fn check_actor3_finished(&self) -> &bool;
    fn check_actor3_finished_mut(&mut self) -> &mut bool;
    fn check_actor4_finished(&self) -> &bool;
    fn check_actor4_finished_mut(&mut self) -> &mut bool;
    fn check_actor5_finished(&self) -> &bool;
    fn check_actor5_finished_mut(&mut self) -> &mut bool;
    fn check_actor6_finished(&self) -> &bool;
    fn check_actor6_finished_mut(&mut self) -> &mut bool;
    fn external_time(&self) -> &f32;
    fn external_time_mut(&mut self) -> &mut f32;
    fn use_external_time(&self) -> &bool;
    fn use_external_time_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl MultipleActorScenarioEntityDataTrait for MultipleActorScenarioEntityData {
    fn world_space(&self) -> &bool {
        &self.world_space
    }
    fn world_space_mut(&mut self) -> &mut bool {
        &mut self.world_space
    }
    fn world_space_connect_transform(&self) -> &super::core::LinearTransform {
        &self.world_space_connect_transform
    }
    fn world_space_connect_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.world_space_connect_transform
    }
    fn scenario_ant_ref(&self) -> &super::ant::AntRef {
        &self.scenario_ant_ref
    }
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.scenario_ant_ref
    }
    fn level_choice(&self) -> &i32 {
        &self.level_choice
    }
    fn level_choice_mut(&mut self) -> &mut i32 {
        &mut self.level_choice
    }
    fn scenario_choice(&self) -> &i32 {
        &self.scenario_choice
    }
    fn scenario_choice_mut(&mut self) -> &mut i32 {
        &mut self.scenario_choice
    }
    fn aligning_enabled(&self) -> &bool {
        &self.aligning_enabled
    }
    fn aligning_enabled_mut(&mut self) -> &mut bool {
        &mut self.aligning_enabled
    }
    fn use_input_event_player_as_player1(&self) -> &bool {
        &self.use_input_event_player_as_player1
    }
    fn use_input_event_player_as_player1_mut(&mut self) -> &mut bool {
        &mut self.use_input_event_player_as_player1
    }
    fn actor1(&self) -> &i32 {
        &self.actor1
    }
    fn actor1_mut(&mut self) -> &mut i32 {
        &mut self.actor1
    }
    fn actor1_part(&self) -> &i32 {
        &self.actor1_part
    }
    fn actor1_part_mut(&mut self) -> &mut i32 {
        &mut self.actor1_part
    }
    fn actor1_second_part(&self) -> &i32 {
        &self.actor1_second_part
    }
    fn actor1_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor1_second_part
    }
    fn actor2(&self) -> &i32 {
        &self.actor2
    }
    fn actor2_mut(&mut self) -> &mut i32 {
        &mut self.actor2
    }
    fn actor2_part(&self) -> &i32 {
        &self.actor2_part
    }
    fn actor2_part_mut(&mut self) -> &mut i32 {
        &mut self.actor2_part
    }
    fn actor2_second_part(&self) -> &i32 {
        &self.actor2_second_part
    }
    fn actor2_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor2_second_part
    }
    fn actor3(&self) -> &i32 {
        &self.actor3
    }
    fn actor3_mut(&mut self) -> &mut i32 {
        &mut self.actor3
    }
    fn actor3_part(&self) -> &i32 {
        &self.actor3_part
    }
    fn actor3_part_mut(&mut self) -> &mut i32 {
        &mut self.actor3_part
    }
    fn actor3_second_part(&self) -> &i32 {
        &self.actor3_second_part
    }
    fn actor3_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor3_second_part
    }
    fn actor4(&self) -> &i32 {
        &self.actor4
    }
    fn actor4_mut(&mut self) -> &mut i32 {
        &mut self.actor4
    }
    fn actor4_part(&self) -> &i32 {
        &self.actor4_part
    }
    fn actor4_part_mut(&mut self) -> &mut i32 {
        &mut self.actor4_part
    }
    fn actor4_second_part(&self) -> &i32 {
        &self.actor4_second_part
    }
    fn actor4_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor4_second_part
    }
    fn actor5(&self) -> &i32 {
        &self.actor5
    }
    fn actor5_mut(&mut self) -> &mut i32 {
        &mut self.actor5
    }
    fn actor5_part(&self) -> &i32 {
        &self.actor5_part
    }
    fn actor5_part_mut(&mut self) -> &mut i32 {
        &mut self.actor5_part
    }
    fn actor5_second_part(&self) -> &i32 {
        &self.actor5_second_part
    }
    fn actor5_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor5_second_part
    }
    fn actor6(&self) -> &i32 {
        &self.actor6
    }
    fn actor6_mut(&mut self) -> &mut i32 {
        &mut self.actor6
    }
    fn actor6_part(&self) -> &i32 {
        &self.actor6_part
    }
    fn actor6_part_mut(&mut self) -> &mut i32 {
        &mut self.actor6_part
    }
    fn actor6_second_part(&self) -> &i32 {
        &self.actor6_second_part
    }
    fn actor6_second_part_mut(&mut self) -> &mut i32 {
        &mut self.actor6_second_part
    }
    fn scenario_active(&self) -> &bool {
        &self.scenario_active
    }
    fn scenario_active_mut(&mut self) -> &mut bool {
        &mut self.scenario_active
    }
    fn actor1_prepared(&self) -> &bool {
        &self.actor1_prepared
    }
    fn actor1_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor1_prepared
    }
    fn actor2_prepared(&self) -> &bool {
        &self.actor2_prepared
    }
    fn actor2_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor2_prepared
    }
    fn actor3_prepared(&self) -> &bool {
        &self.actor3_prepared
    }
    fn actor3_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor3_prepared
    }
    fn actor4_prepared(&self) -> &bool {
        &self.actor4_prepared
    }
    fn actor4_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor4_prepared
    }
    fn actor5_prepared(&self) -> &bool {
        &self.actor5_prepared
    }
    fn actor5_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor5_prepared
    }
    fn actor6_prepared(&self) -> &bool {
        &self.actor6_prepared
    }
    fn actor6_prepared_mut(&mut self) -> &mut bool {
        &mut self.actor6_prepared
    }
    fn check_actor1_finished(&self) -> &bool {
        &self.check_actor1_finished
    }
    fn check_actor1_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor1_finished
    }
    fn check_actor2_finished(&self) -> &bool {
        &self.check_actor2_finished
    }
    fn check_actor2_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor2_finished
    }
    fn check_actor3_finished(&self) -> &bool {
        &self.check_actor3_finished
    }
    fn check_actor3_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor3_finished
    }
    fn check_actor4_finished(&self) -> &bool {
        &self.check_actor4_finished
    }
    fn check_actor4_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor4_finished
    }
    fn check_actor5_finished(&self) -> &bool {
        &self.check_actor5_finished
    }
    fn check_actor5_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor5_finished
    }
    fn check_actor6_finished(&self) -> &bool {
        &self.check_actor6_finished
    }
    fn check_actor6_finished_mut(&mut self) -> &mut bool {
        &mut self.check_actor6_finished
    }
    fn external_time(&self) -> &f32 {
        &self.external_time
    }
    fn external_time_mut(&mut self) -> &mut f32 {
        &mut self.external_time
    }
    fn use_external_time(&self) -> &bool {
        &self.use_external_time
    }
    fn use_external_time_mut(&mut self) -> &mut bool {
        &mut self.use_external_time
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::SpatialEntityDataTrait for MultipleActorScenarioEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for MultipleActorScenarioEntityData {
}

impl super::entity::GameObjectDataTrait for MultipleActorScenarioEntityData {
}

impl super::core::DataBusPeerTrait for MultipleActorScenarioEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MultipleActorScenarioEntityData {
}

impl super::core::DataContainerTrait for MultipleActorScenarioEntityData {
}

pub static MULTIPLEACTORSCENARIOENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleActorScenarioEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultipleActorScenarioEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WorldSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, world_space),
            },
            FieldInfoData {
                name: "WorldSpaceConnectTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, world_space_connect_transform),
            },
            FieldInfoData {
                name: "ScenarioAntRef",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, scenario_ant_ref),
            },
            FieldInfoData {
                name: "LevelChoice",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, level_choice),
            },
            FieldInfoData {
                name: "ScenarioChoice",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, scenario_choice),
            },
            FieldInfoData {
                name: "AligningEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, aligning_enabled),
            },
            FieldInfoData {
                name: "UseInputEventPlayerAsPlayer1",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, use_input_event_player_as_player1),
            },
            FieldInfoData {
                name: "Actor1",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor1),
            },
            FieldInfoData {
                name: "Actor1Part",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor1_part),
            },
            FieldInfoData {
                name: "Actor1SecondPart",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor1_second_part),
            },
            FieldInfoData {
                name: "Actor2",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor2),
            },
            FieldInfoData {
                name: "Actor2Part",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor2_part),
            },
            FieldInfoData {
                name: "Actor2SecondPart",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor2_second_part),
            },
            FieldInfoData {
                name: "Actor3",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor3),
            },
            FieldInfoData {
                name: "Actor3Part",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor3_part),
            },
            FieldInfoData {
                name: "Actor3SecondPart",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor3_second_part),
            },
            FieldInfoData {
                name: "Actor4",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor4),
            },
            FieldInfoData {
                name: "Actor4Part",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor4_part),
            },
            FieldInfoData {
                name: "Actor4SecondPart",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor4_second_part),
            },
            FieldInfoData {
                name: "Actor5",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor5),
            },
            FieldInfoData {
                name: "Actor5Part",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor5_part),
            },
            FieldInfoData {
                name: "Actor5SecondPart",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor5_second_part),
            },
            FieldInfoData {
                name: "Actor6",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor6),
            },
            FieldInfoData {
                name: "Actor6Part",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor6_part),
            },
            FieldInfoData {
                name: "Actor6SecondPart",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor6_second_part),
            },
            FieldInfoData {
                name: "ScenarioActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, scenario_active),
            },
            FieldInfoData {
                name: "Actor1Prepared",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor1_prepared),
            },
            FieldInfoData {
                name: "Actor2Prepared",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor2_prepared),
            },
            FieldInfoData {
                name: "Actor3Prepared",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor3_prepared),
            },
            FieldInfoData {
                name: "Actor4Prepared",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor4_prepared),
            },
            FieldInfoData {
                name: "Actor5Prepared",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor5_prepared),
            },
            FieldInfoData {
                name: "Actor6Prepared",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, actor6_prepared),
            },
            FieldInfoData {
                name: "CheckActor1Finished",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor1_finished),
            },
            FieldInfoData {
                name: "CheckActor2Finished",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor2_finished),
            },
            FieldInfoData {
                name: "CheckActor3Finished",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor3_finished),
            },
            FieldInfoData {
                name: "CheckActor4Finished",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor4_finished),
            },
            FieldInfoData {
                name: "CheckActor5Finished",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor5_finished),
            },
            FieldInfoData {
                name: "CheckActor6Finished",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, check_actor6_finished),
            },
            FieldInfoData {
                name: "ExternalTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, external_time),
            },
            FieldInfoData {
                name: "UseExternalTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, use_external_time),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MultipleActorScenarioEntityData, realm),
            },
        ],
    }),
    array_type: Some(MULTIPLEACTORSCENARIOENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MultipleActorScenarioEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTIPLEACTORSCENARIOENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTIPLEACTORSCENARIOENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleActorScenarioEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MultipleActorScenarioEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BillboardTransformEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub rotation_axis: BillboardTransformRotationAxis,
    pub ignore_translation: bool,
    pub r#in: super::core::LinearTransform,
}

pub trait BillboardTransformEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn rotation_axis(&self) -> &BillboardTransformRotationAxis;
    fn rotation_axis_mut(&mut self) -> &mut BillboardTransformRotationAxis;
    fn ignore_translation(&self) -> &bool;
    fn ignore_translation_mut(&mut self) -> &mut bool;
    fn r#in(&self) -> &super::core::LinearTransform;
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl BillboardTransformEntityDataTrait for BillboardTransformEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn rotation_axis(&self) -> &BillboardTransformRotationAxis {
        &self.rotation_axis
    }
    fn rotation_axis_mut(&mut self) -> &mut BillboardTransformRotationAxis {
        &mut self.rotation_axis
    }
    fn ignore_translation(&self) -> &bool {
        &self.ignore_translation
    }
    fn ignore_translation_mut(&mut self) -> &mut bool {
        &mut self.ignore_translation
    }
    fn r#in(&self) -> &super::core::LinearTransform {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.r#in
    }
}

impl super::entity::SpatialEntityDataTrait for BillboardTransformEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for BillboardTransformEntityData {
}

impl super::entity::GameObjectDataTrait for BillboardTransformEntityData {
}

impl super::core::DataBusPeerTrait for BillboardTransformEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BillboardTransformEntityData {
}

impl super::core::DataContainerTrait for BillboardTransformEntityData {
}

pub static BILLBOARDTRANSFORMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BillboardTransformEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BillboardTransformEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BillboardTransformEntityData, realm),
            },
            FieldInfoData {
                name: "RotationAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "BillboardTransformRotationAxis",
                rust_offset: offset_of!(BillboardTransformEntityData, rotation_axis),
            },
            FieldInfoData {
                name: "IgnoreTranslation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BillboardTransformEntityData, ignore_translation),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(BillboardTransformEntityData, r#in),
            },
        ],
    }),
    array_type: Some(BILLBOARDTRANSFORMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BillboardTransformEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BILLBOARDTRANSFORMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BILLBOARDTRANSFORMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BillboardTransformEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BillboardTransformEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BillboardTransformRotationAxis {
    #[default]
    BillboardTransformRotationAxis_All = 0,
    BillboardTransformRotationAxis_X = 1,
    BillboardTransformRotationAxis_Y = 2,
    BillboardTransformRotationAxis_Z = 3,
}

pub static BILLBOARDTRANSFORMROTATIONAXIS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BillboardTransformRotationAxis",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BILLBOARDTRANSFORMROTATIONAXIS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BillboardTransformRotationAxis {
    fn type_info(&self) -> &'static TypeInfo {
        BILLBOARDTRANSFORMROTATIONAXIS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BILLBOARDTRANSFORMROTATIONAXIS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BillboardTransformRotationAxis-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BillboardTransformRotationAxis"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaterDepthEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub default_enabled: bool,
}

pub trait WaterDepthEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn default_enabled(&self) -> &bool;
    fn default_enabled_mut(&mut self) -> &mut bool;
}

impl WaterDepthEntityDataTrait for WaterDepthEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn default_enabled(&self) -> &bool {
        &self.default_enabled
    }
    fn default_enabled_mut(&mut self) -> &mut bool {
        &mut self.default_enabled
    }
}

impl super::entity::SpatialEntityDataTrait for WaterDepthEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for WaterDepthEntityData {
}

impl super::entity::GameObjectDataTrait for WaterDepthEntityData {
}

impl super::core::DataBusPeerTrait for WaterDepthEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WaterDepthEntityData {
}

impl super::core::DataContainerTrait for WaterDepthEntityData {
}

pub static WATERDEPTHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterDepthEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaterDepthEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WaterDepthEntityData, realm),
            },
            FieldInfoData {
                name: "DefaultEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthEntityData, default_enabled),
            },
        ],
    }),
    array_type: Some(WATERDEPTHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WaterDepthEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WATERDEPTHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WATERDEPTHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterDepthEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WaterDepthEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TransformSnapToGroundEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub r#in: super::core::LinearTransform,
    pub distance_to_ground: f32,
    pub ray_cast_length: f32,
    pub ray_cast_up_offset: f32,
    pub align_with_ground_normal: bool,
    pub ignore_water: bool,
}

pub trait TransformSnapToGroundEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn r#in(&self) -> &super::core::LinearTransform;
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform;
    fn distance_to_ground(&self) -> &f32;
    fn distance_to_ground_mut(&mut self) -> &mut f32;
    fn ray_cast_length(&self) -> &f32;
    fn ray_cast_length_mut(&mut self) -> &mut f32;
    fn ray_cast_up_offset(&self) -> &f32;
    fn ray_cast_up_offset_mut(&mut self) -> &mut f32;
    fn align_with_ground_normal(&self) -> &bool;
    fn align_with_ground_normal_mut(&mut self) -> &mut bool;
    fn ignore_water(&self) -> &bool;
    fn ignore_water_mut(&mut self) -> &mut bool;
}

impl TransformSnapToGroundEntityDataTrait for TransformSnapToGroundEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn r#in(&self) -> &super::core::LinearTransform {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.r#in
    }
    fn distance_to_ground(&self) -> &f32 {
        &self.distance_to_ground
    }
    fn distance_to_ground_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_ground
    }
    fn ray_cast_length(&self) -> &f32 {
        &self.ray_cast_length
    }
    fn ray_cast_length_mut(&mut self) -> &mut f32 {
        &mut self.ray_cast_length
    }
    fn ray_cast_up_offset(&self) -> &f32 {
        &self.ray_cast_up_offset
    }
    fn ray_cast_up_offset_mut(&mut self) -> &mut f32 {
        &mut self.ray_cast_up_offset
    }
    fn align_with_ground_normal(&self) -> &bool {
        &self.align_with_ground_normal
    }
    fn align_with_ground_normal_mut(&mut self) -> &mut bool {
        &mut self.align_with_ground_normal
    }
    fn ignore_water(&self) -> &bool {
        &self.ignore_water
    }
    fn ignore_water_mut(&mut self) -> &mut bool {
        &mut self.ignore_water
    }
}

impl super::entity::EntityDataTrait for TransformSnapToGroundEntityData {
}

impl super::entity::GameObjectDataTrait for TransformSnapToGroundEntityData {
}

impl super::core::DataBusPeerTrait for TransformSnapToGroundEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TransformSnapToGroundEntityData {
}

impl super::core::DataContainerTrait for TransformSnapToGroundEntityData {
}

pub static TRANSFORMSNAPTOGROUNDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSnapToGroundEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TransformSnapToGroundEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, realm),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, r#in),
            },
            FieldInfoData {
                name: "DistanceToGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, distance_to_ground),
            },
            FieldInfoData {
                name: "RayCastLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, ray_cast_length),
            },
            FieldInfoData {
                name: "RayCastUpOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, ray_cast_up_offset),
            },
            FieldInfoData {
                name: "AlignWithGroundNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, align_with_ground_normal),
            },
            FieldInfoData {
                name: "IgnoreWater",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TransformSnapToGroundEntityData, ignore_water),
            },
        ],
    }),
    array_type: Some(TRANSFORMSNAPTOGROUNDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TransformSnapToGroundEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRANSFORMSNAPTOGROUNDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRANSFORMSNAPTOGROUNDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TransformSnapToGroundEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TransformSnapToGroundEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshEmitterDynamicState {
}

pub trait MeshEmitterDynamicStateTrait: TypeObject {
}

impl MeshEmitterDynamicStateTrait for MeshEmitterDynamicState {
}

pub static MESHEMITTERDYNAMICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterDynamicState",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshEmitterDynamicState as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MESHEMITTERDYNAMICSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MeshEmitterDynamicState {
    fn type_info(&self) -> &'static TypeInfo {
        MESHEMITTERDYNAMICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MESHEMITTERDYNAMICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterDynamicState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshEmitterDynamicState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshEmitterStaticState {
    pub mesh_emitter: Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>>,
    pub transform_space: super::state_stream::TransformSpaceHandle,
    pub field_flag_changed0: u8,
}

pub trait MeshEmitterStaticStateTrait: TypeObject {
    fn mesh_emitter(&self) -> &Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>>;
    fn mesh_emitter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>>;
    fn transform_space(&self) -> &super::state_stream::TransformSpaceHandle;
    fn transform_space_mut(&mut self) -> &mut super::state_stream::TransformSpaceHandle;
    fn field_flag_changed0(&self) -> &u8;
    fn field_flag_changed0_mut(&mut self) -> &mut u8;
}

impl MeshEmitterStaticStateTrait for MeshEmitterStaticState {
    fn mesh_emitter(&self) -> &Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>> {
        &self.mesh_emitter
    }
    fn mesh_emitter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>> {
        &mut self.mesh_emitter
    }
    fn transform_space(&self) -> &super::state_stream::TransformSpaceHandle {
        &self.transform_space
    }
    fn transform_space_mut(&mut self) -> &mut super::state_stream::TransformSpaceHandle {
        &mut self.transform_space
    }
    fn field_flag_changed0(&self) -> &u8 {
        &self.field_flag_changed0
    }
    fn field_flag_changed0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_changed0
    }
}

pub static MESHEMITTERSTATICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterStaticState",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshEmitterStaticState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MeshEmitter",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshEmitterBaseAsset",
                rust_offset: offset_of!(MeshEmitterStaticState, mesh_emitter),
            },
            FieldInfoData {
                name: "TransformSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "TransformSpaceHandle",
                rust_offset: offset_of!(MeshEmitterStaticState, transform_space),
            },
            FieldInfoData {
                name: "FieldFlagChanged0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(MeshEmitterStaticState, field_flag_changed0),
            },
        ],
    }),
    array_type: Some(MESHEMITTERSTATICSTATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeshEmitterStaticState {
    fn type_info(&self) -> &'static TypeInfo {
        MESHEMITTERSTATICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MESHEMITTERSTATICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterStaticState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshEmitterStaticState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshEmitterControlEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub mesh_emitter: Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>>,
}

pub trait MeshEmitterControlEntityDataTrait: super::entity::EntityDataTrait {
    fn mesh_emitter(&self) -> &Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>>;
    fn mesh_emitter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>>;
}

impl MeshEmitterControlEntityDataTrait for MeshEmitterControlEntityData {
    fn mesh_emitter(&self) -> &Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>> {
        &self.mesh_emitter
    }
    fn mesh_emitter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::MeshEmitterBaseAssetTrait>>> {
        &mut self.mesh_emitter
    }
}

impl super::entity::EntityDataTrait for MeshEmitterControlEntityData {
}

impl super::entity::GameObjectDataTrait for MeshEmitterControlEntityData {
}

impl super::core::DataBusPeerTrait for MeshEmitterControlEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MeshEmitterControlEntityData {
}

impl super::core::DataContainerTrait for MeshEmitterControlEntityData {
}

pub static MESHEMITTERCONTROLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterControlEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshEmitterControlEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MeshEmitter",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshEmitterBaseAsset",
                rust_offset: offset_of!(MeshEmitterControlEntityData, mesh_emitter),
            },
        ],
    }),
    array_type: Some(MESHEMITTERCONTROLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeshEmitterControlEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MESHEMITTERCONTROLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHEMITTERCONTROLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshEmitterControlEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshEmitterControlEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MemoryPoolControlDynamicState {
}

pub trait MemoryPoolControlDynamicStateTrait: TypeObject {
}

impl MemoryPoolControlDynamicStateTrait for MemoryPoolControlDynamicState {
}

pub static MEMORYPOOLCONTROLDYNAMICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlDynamicState",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MemoryPoolControlDynamicState as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MEMORYPOOLCONTROLDYNAMICSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MemoryPoolControlDynamicState {
    fn type_info(&self) -> &'static TypeInfo {
        MEMORYPOOLCONTROLDYNAMICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MEMORYPOOLCONTROLDYNAMICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlDynamicState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MemoryPoolControlDynamicState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MemoryPoolControlStaticState {
    pub memory_pool: MemoryPoolControlType,
    pub memory_target_override_k_b: i32,
    pub field_flag_changed0: u8,
}

pub trait MemoryPoolControlStaticStateTrait: TypeObject {
    fn memory_pool(&self) -> &MemoryPoolControlType;
    fn memory_pool_mut(&mut self) -> &mut MemoryPoolControlType;
    fn memory_target_override_k_b(&self) -> &i32;
    fn memory_target_override_k_b_mut(&mut self) -> &mut i32;
    fn field_flag_changed0(&self) -> &u8;
    fn field_flag_changed0_mut(&mut self) -> &mut u8;
}

impl MemoryPoolControlStaticStateTrait for MemoryPoolControlStaticState {
    fn memory_pool(&self) -> &MemoryPoolControlType {
        &self.memory_pool
    }
    fn memory_pool_mut(&mut self) -> &mut MemoryPoolControlType {
        &mut self.memory_pool
    }
    fn memory_target_override_k_b(&self) -> &i32 {
        &self.memory_target_override_k_b
    }
    fn memory_target_override_k_b_mut(&mut self) -> &mut i32 {
        &mut self.memory_target_override_k_b
    }
    fn field_flag_changed0(&self) -> &u8 {
        &self.field_flag_changed0
    }
    fn field_flag_changed0_mut(&mut self) -> &mut u8 {
        &mut self.field_flag_changed0
    }
}

pub static MEMORYPOOLCONTROLSTATICSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlStaticState",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MemoryPoolControlStaticState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MemoryPool",
                flags: MemberInfoFlags::new(0),
                field_type: "MemoryPoolControlType",
                rust_offset: offset_of!(MemoryPoolControlStaticState, memory_pool),
            },
            FieldInfoData {
                name: "MemoryTargetOverrideKB",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MemoryPoolControlStaticState, memory_target_override_k_b),
            },
            FieldInfoData {
                name: "FieldFlagChanged0",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(MemoryPoolControlStaticState, field_flag_changed0),
            },
        ],
    }),
    array_type: Some(MEMORYPOOLCONTROLSTATICSTATE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MemoryPoolControlStaticState {
    fn type_info(&self) -> &'static TypeInfo {
        MEMORYPOOLCONTROLSTATICSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MEMORYPOOLCONTROLSTATICSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlStaticState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MemoryPoolControlStaticState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MemoryPoolControlEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub memory_pool: MemoryPoolControlType,
    pub activate_override_on_init: bool,
    pub memory_target_override_k_b: i32,
}

pub trait MemoryPoolControlEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn memory_pool(&self) -> &MemoryPoolControlType;
    fn memory_pool_mut(&mut self) -> &mut MemoryPoolControlType;
    fn activate_override_on_init(&self) -> &bool;
    fn activate_override_on_init_mut(&mut self) -> &mut bool;
    fn memory_target_override_k_b(&self) -> &i32;
    fn memory_target_override_k_b_mut(&mut self) -> &mut i32;
}

impl MemoryPoolControlEntityDataTrait for MemoryPoolControlEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn memory_pool(&self) -> &MemoryPoolControlType {
        &self.memory_pool
    }
    fn memory_pool_mut(&mut self) -> &mut MemoryPoolControlType {
        &mut self.memory_pool
    }
    fn activate_override_on_init(&self) -> &bool {
        &self.activate_override_on_init
    }
    fn activate_override_on_init_mut(&mut self) -> &mut bool {
        &mut self.activate_override_on_init
    }
    fn memory_target_override_k_b(&self) -> &i32 {
        &self.memory_target_override_k_b
    }
    fn memory_target_override_k_b_mut(&mut self) -> &mut i32 {
        &mut self.memory_target_override_k_b
    }
}

impl super::entity::EntityDataTrait for MemoryPoolControlEntityData {
}

impl super::entity::GameObjectDataTrait for MemoryPoolControlEntityData {
}

impl super::core::DataBusPeerTrait for MemoryPoolControlEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MemoryPoolControlEntityData {
}

impl super::core::DataContainerTrait for MemoryPoolControlEntityData {
}

pub static MEMORYPOOLCONTROLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MemoryPoolControlEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MemoryPoolControlEntityData, realm),
            },
            FieldInfoData {
                name: "MemoryPool",
                flags: MemberInfoFlags::new(0),
                field_type: "MemoryPoolControlType",
                rust_offset: offset_of!(MemoryPoolControlEntityData, memory_pool),
            },
            FieldInfoData {
                name: "ActivateOverrideOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MemoryPoolControlEntityData, activate_override_on_init),
            },
            FieldInfoData {
                name: "MemoryTargetOverrideKB",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MemoryPoolControlEntityData, memory_target_override_k_b),
            },
        ],
    }),
    array_type: Some(MEMORYPOOLCONTROLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MemoryPoolControlEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MEMORYPOOLCONTROLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MEMORYPOOLCONTROLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MemoryPoolControlEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MemoryPoolControlType {
    #[default]
    MemoryPoolControlType_Texture = 0,
    MemoryPoolControlType_Mesh = 1,
    MemoryPoolControlType_Max = 2,
}

pub static MEMORYPOOLCONTROLTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MEMORYPOOLCONTROLTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MemoryPoolControlType {
    fn type_info(&self) -> &'static TypeInfo {
        MEMORYPOOLCONTROLTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MEMORYPOOLCONTROLTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemoryPoolControlType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MemoryPoolControlType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayVFXEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub visual_effect: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
    pub effect_location: VFXLocationControl,
    pub location_a: VFXLocationControl,
    pub location_b: VFXLocationControl,
    pub location_c: VFXLocationControl,
    pub raw_transform_effect_location: super::core::LinearTransform,
    pub raw_transform_location_a: super::core::LinearTransform,
    pub raw_transform_location_b: super::core::LinearTransform,
    pub raw_transform_location_c: super::core::LinearTransform,
}

pub trait PlayVFXEntityDataTrait: super::entity::EntityDataTrait {
    fn visual_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn visual_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn effect_location(&self) -> &VFXLocationControl;
    fn effect_location_mut(&mut self) -> &mut VFXLocationControl;
    fn location_a(&self) -> &VFXLocationControl;
    fn location_a_mut(&mut self) -> &mut VFXLocationControl;
    fn location_b(&self) -> &VFXLocationControl;
    fn location_b_mut(&mut self) -> &mut VFXLocationControl;
    fn location_c(&self) -> &VFXLocationControl;
    fn location_c_mut(&mut self) -> &mut VFXLocationControl;
    fn raw_transform_effect_location(&self) -> &super::core::LinearTransform;
    fn raw_transform_effect_location_mut(&mut self) -> &mut super::core::LinearTransform;
    fn raw_transform_location_a(&self) -> &super::core::LinearTransform;
    fn raw_transform_location_a_mut(&mut self) -> &mut super::core::LinearTransform;
    fn raw_transform_location_b(&self) -> &super::core::LinearTransform;
    fn raw_transform_location_b_mut(&mut self) -> &mut super::core::LinearTransform;
    fn raw_transform_location_c(&self) -> &super::core::LinearTransform;
    fn raw_transform_location_c_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl PlayVFXEntityDataTrait for PlayVFXEntityData {
    fn visual_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.visual_effect
    }
    fn visual_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &mut self.visual_effect
    }
    fn effect_location(&self) -> &VFXLocationControl {
        &self.effect_location
    }
    fn effect_location_mut(&mut self) -> &mut VFXLocationControl {
        &mut self.effect_location
    }
    fn location_a(&self) -> &VFXLocationControl {
        &self.location_a
    }
    fn location_a_mut(&mut self) -> &mut VFXLocationControl {
        &mut self.location_a
    }
    fn location_b(&self) -> &VFXLocationControl {
        &self.location_b
    }
    fn location_b_mut(&mut self) -> &mut VFXLocationControl {
        &mut self.location_b
    }
    fn location_c(&self) -> &VFXLocationControl {
        &self.location_c
    }
    fn location_c_mut(&mut self) -> &mut VFXLocationControl {
        &mut self.location_c
    }
    fn raw_transform_effect_location(&self) -> &super::core::LinearTransform {
        &self.raw_transform_effect_location
    }
    fn raw_transform_effect_location_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.raw_transform_effect_location
    }
    fn raw_transform_location_a(&self) -> &super::core::LinearTransform {
        &self.raw_transform_location_a
    }
    fn raw_transform_location_a_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.raw_transform_location_a
    }
    fn raw_transform_location_b(&self) -> &super::core::LinearTransform {
        &self.raw_transform_location_b
    }
    fn raw_transform_location_b_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.raw_transform_location_b
    }
    fn raw_transform_location_c(&self) -> &super::core::LinearTransform {
        &self.raw_transform_location_c
    }
    fn raw_transform_location_c_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.raw_transform_location_c
    }
}

impl super::entity::EntityDataTrait for PlayVFXEntityData {
}

impl super::entity::GameObjectDataTrait for PlayVFXEntityData {
}

impl super::core::DataBusPeerTrait for PlayVFXEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayVFXEntityData {
}

impl super::core::DataContainerTrait for PlayVFXEntityData {
}

pub static PLAYVFXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayVFXEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayVFXEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VisualEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(PlayVFXEntityData, visual_effect),
            },
            FieldInfoData {
                name: "EffectLocation",
                flags: MemberInfoFlags::new(0),
                field_type: "VFXLocationControl",
                rust_offset: offset_of!(PlayVFXEntityData, effect_location),
            },
            FieldInfoData {
                name: "LocationA",
                flags: MemberInfoFlags::new(0),
                field_type: "VFXLocationControl",
                rust_offset: offset_of!(PlayVFXEntityData, location_a),
            },
            FieldInfoData {
                name: "LocationB",
                flags: MemberInfoFlags::new(0),
                field_type: "VFXLocationControl",
                rust_offset: offset_of!(PlayVFXEntityData, location_b),
            },
            FieldInfoData {
                name: "LocationC",
                flags: MemberInfoFlags::new(0),
                field_type: "VFXLocationControl",
                rust_offset: offset_of!(PlayVFXEntityData, location_c),
            },
            FieldInfoData {
                name: "RawTransformEffectLocation",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayVFXEntityData, raw_transform_effect_location),
            },
            FieldInfoData {
                name: "RawTransformLocationA",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayVFXEntityData, raw_transform_location_a),
            },
            FieldInfoData {
                name: "RawTransformLocationB",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayVFXEntityData, raw_transform_location_b),
            },
            FieldInfoData {
                name: "RawTransformLocationC",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayVFXEntityData, raw_transform_location_c),
            },
        ],
    }),
    array_type: Some(PLAYVFXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayVFXEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYVFXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYVFXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayVFXEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayVFXEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VFXLocationControl {
    pub attachment: i32,
    pub stay_attached: bool,
    pub preserve_orientation: bool,
    pub offset_from_character_forward: bool,
    pub offset: super::core::LinearTransform,
}

pub trait VFXLocationControlTrait: TypeObject {
    fn attachment(&self) -> &i32;
    fn attachment_mut(&mut self) -> &mut i32;
    fn stay_attached(&self) -> &bool;
    fn stay_attached_mut(&mut self) -> &mut bool;
    fn preserve_orientation(&self) -> &bool;
    fn preserve_orientation_mut(&mut self) -> &mut bool;
    fn offset_from_character_forward(&self) -> &bool;
    fn offset_from_character_forward_mut(&mut self) -> &mut bool;
    fn offset(&self) -> &super::core::LinearTransform;
    fn offset_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl VFXLocationControlTrait for VFXLocationControl {
    fn attachment(&self) -> &i32 {
        &self.attachment
    }
    fn attachment_mut(&mut self) -> &mut i32 {
        &mut self.attachment
    }
    fn stay_attached(&self) -> &bool {
        &self.stay_attached
    }
    fn stay_attached_mut(&mut self) -> &mut bool {
        &mut self.stay_attached
    }
    fn preserve_orientation(&self) -> &bool {
        &self.preserve_orientation
    }
    fn preserve_orientation_mut(&mut self) -> &mut bool {
        &mut self.preserve_orientation
    }
    fn offset_from_character_forward(&self) -> &bool {
        &self.offset_from_character_forward
    }
    fn offset_from_character_forward_mut(&mut self) -> &mut bool {
        &mut self.offset_from_character_forward
    }
    fn offset(&self) -> &super::core::LinearTransform {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.offset
    }
}

pub static VFXLOCATIONCONTROL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VFXLocationControl",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VFXLocationControl as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Attachment",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VFXLocationControl, attachment),
            },
            FieldInfoData {
                name: "StayAttached",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VFXLocationControl, stay_attached),
            },
            FieldInfoData {
                name: "PreserveOrientation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VFXLocationControl, preserve_orientation),
            },
            FieldInfoData {
                name: "OffsetFromCharacterForward",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VFXLocationControl, offset_from_character_forward),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(VFXLocationControl, offset),
            },
        ],
    }),
    array_type: Some(VFXLOCATIONCONTROL_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VFXLocationControl {
    fn type_info(&self) -> &'static TypeInfo {
        VFXLOCATIONCONTROL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VFXLOCATIONCONTROL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VFXLocationControl-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VFXLocationControl"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalPlayerEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub all_local_players: bool,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait LocalPlayerEventEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn all_local_players(&self) -> &bool;
    fn all_local_players_mut(&mut self) -> &mut bool;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl LocalPlayerEventEntityDataTrait for LocalPlayerEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn all_local_players(&self) -> &bool {
        &self.all_local_players
    }
    fn all_local_players_mut(&mut self) -> &mut bool {
        &mut self.all_local_players
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for LocalPlayerEventEntityData {
}

impl super::entity::GameObjectDataTrait for LocalPlayerEventEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlayerEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalPlayerEventEntityData {
}

impl super::core::DataContainerTrait for LocalPlayerEventEntityData {
}

pub static LOCALPLAYEREVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocalPlayerEventEntityData, realm),
            },
            FieldInfoData {
                name: "AllLocalPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LocalPlayerEventEntityData, all_local_players),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LocalPlayerEventEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(LOCALPLAYEREVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYEREVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALPLAYEREVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LocalPlayerEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerIteratorEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub team: super::gameplay_sim::TeamId,
    pub alive: bool,
    pub randomize_from_start: bool,
}

pub trait PlayerIteratorEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn alive(&self) -> &bool;
    fn alive_mut(&mut self) -> &mut bool;
    fn randomize_from_start(&self) -> &bool;
    fn randomize_from_start_mut(&mut self) -> &mut bool;
}

impl PlayerIteratorEntityDataTrait for PlayerIteratorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn alive(&self) -> &bool {
        &self.alive
    }
    fn alive_mut(&mut self) -> &mut bool {
        &mut self.alive
    }
    fn randomize_from_start(&self) -> &bool {
        &self.randomize_from_start
    }
    fn randomize_from_start_mut(&mut self) -> &mut bool {
        &mut self.randomize_from_start
    }
}

impl super::entity::EntityDataTrait for PlayerIteratorEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerIteratorEntityData {
}

impl super::core::DataBusPeerTrait for PlayerIteratorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerIteratorEntityData {
}

impl super::core::DataContainerTrait for PlayerIteratorEntityData {
}

pub static PLAYERITERATORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerIteratorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerIteratorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayerIteratorEntityData, realm),
            },
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(PlayerIteratorEntityData, team),
            },
            FieldInfoData {
                name: "Alive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerIteratorEntityData, alive),
            },
            FieldInfoData {
                name: "RandomizeFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerIteratorEntityData, randomize_from_start),
            },
        ],
    }),
    array_type: Some(PLAYERITERATORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerIteratorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERITERATORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERITERATORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerIteratorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerIteratorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InclusionSettingEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub setting: String,
    pub settings: Vec<String>,
}

pub trait InclusionSettingEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn setting(&self) -> &String;
    fn setting_mut(&mut self) -> &mut String;
    fn settings(&self) -> &Vec<String>;
    fn settings_mut(&mut self) -> &mut Vec<String>;
}

impl InclusionSettingEntityDataTrait for InclusionSettingEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn setting(&self) -> &String {
        &self.setting
    }
    fn setting_mut(&mut self) -> &mut String {
        &mut self.setting
    }
    fn settings(&self) -> &Vec<String> {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut Vec<String> {
        &mut self.settings
    }
}

impl super::entity::EntityDataTrait for InclusionSettingEntityData {
}

impl super::entity::GameObjectDataTrait for InclusionSettingEntityData {
}

impl super::core::DataBusPeerTrait for InclusionSettingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for InclusionSettingEntityData {
}

impl super::core::DataContainerTrait for InclusionSettingEntityData {
}

pub static INCLUSIONSETTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InclusionSettingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InclusionSettingEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(InclusionSettingEntityData, realm),
            },
            FieldInfoData {
                name: "Setting",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(InclusionSettingEntityData, setting),
            },
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(InclusionSettingEntityData, settings),
            },
        ],
    }),
    array_type: Some(INCLUSIONSETTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InclusionSettingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INCLUSIONSETTINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INCLUSIONSETTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InclusionSettingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InclusionSettingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TeleportEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub new_position_transform: super::core::LinearTransform,
    pub check_below_ground: bool,
    pub default_teleport_player: bool,
}

pub trait TeleportEntityDataTrait: super::entity::EntityDataTrait {
    fn new_position_transform(&self) -> &super::core::LinearTransform;
    fn new_position_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn check_below_ground(&self) -> &bool;
    fn check_below_ground_mut(&mut self) -> &mut bool;
    fn default_teleport_player(&self) -> &bool;
    fn default_teleport_player_mut(&mut self) -> &mut bool;
}

impl TeleportEntityDataTrait for TeleportEntityData {
    fn new_position_transform(&self) -> &super::core::LinearTransform {
        &self.new_position_transform
    }
    fn new_position_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.new_position_transform
    }
    fn check_below_ground(&self) -> &bool {
        &self.check_below_ground
    }
    fn check_below_ground_mut(&mut self) -> &mut bool {
        &mut self.check_below_ground
    }
    fn default_teleport_player(&self) -> &bool {
        &self.default_teleport_player
    }
    fn default_teleport_player_mut(&mut self) -> &mut bool {
        &mut self.default_teleport_player
    }
}

impl super::entity::EntityDataTrait for TeleportEntityData {
}

impl super::entity::GameObjectDataTrait for TeleportEntityData {
}

impl super::core::DataBusPeerTrait for TeleportEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TeleportEntityData {
}

impl super::core::DataContainerTrait for TeleportEntityData {
}

pub static TELEPORTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeleportEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeleportEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NewPositionTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TeleportEntityData, new_position_transform),
            },
            FieldInfoData {
                name: "CheckBelowGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeleportEntityData, check_below_ground),
            },
            FieldInfoData {
                name: "DefaultTeleportPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeleportEntityData, default_teleport_player),
            },
        ],
    }),
    array_type: Some(TELEPORTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TeleportEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TELEPORTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TELEPORTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeleportEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeleportEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StreamingGateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub timeout: f32,
}

pub trait StreamingGateEntityDataTrait: super::entity::EntityDataTrait {
    fn timeout(&self) -> &f32;
    fn timeout_mut(&mut self) -> &mut f32;
}

impl StreamingGateEntityDataTrait for StreamingGateEntityData {
    fn timeout(&self) -> &f32 {
        &self.timeout
    }
    fn timeout_mut(&mut self) -> &mut f32 {
        &mut self.timeout
    }
}

impl super::entity::EntityDataTrait for StreamingGateEntityData {
}

impl super::entity::GameObjectDataTrait for StreamingGateEntityData {
}

impl super::core::DataBusPeerTrait for StreamingGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StreamingGateEntityData {
}

impl super::core::DataContainerTrait for StreamingGateEntityData {
}

pub static STREAMINGGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamingGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StreamingGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Timeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StreamingGateEntityData, timeout),
            },
        ],
    }),
    array_type: Some(STREAMINGGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamingGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMINGGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STREAMINGGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamingGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StreamingGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomizeCharacterEntityData {
    pub _glacier_base: CustomizeBaseEntityData,
    pub customize_character_data: Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>>,
}

pub trait CustomizeCharacterEntityDataTrait: CustomizeBaseEntityDataTrait {
    fn customize_character_data(&self) -> &Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>>;
    fn customize_character_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>>;
}

impl CustomizeCharacterEntityDataTrait for CustomizeCharacterEntityData {
    fn customize_character_data(&self) -> &Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>> {
        &self.customize_character_data
    }
    fn customize_character_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>> {
        &mut self.customize_character_data
    }
}

impl CustomizeBaseEntityDataTrait for CustomizeCharacterEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::entity::EntityDataTrait for CustomizeCharacterEntityData {
}

impl super::entity::GameObjectDataTrait for CustomizeCharacterEntityData {
}

impl super::core::DataBusPeerTrait for CustomizeCharacterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CustomizeCharacterEntityData {
}

impl super::core::DataContainerTrait for CustomizeCharacterEntityData {
}

pub static CUSTOMIZECHARACTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeCharacterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CUSTOMIZEBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeCharacterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CustomizeCharacterData",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizeCharacterData",
                rust_offset: offset_of!(CustomizeCharacterEntityData, customize_character_data),
            },
        ],
    }),
    array_type: Some(CUSTOMIZECHARACTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizeCharacterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZECHARACTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZECHARACTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeCharacterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizeCharacterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomizeBaseEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait CustomizeBaseEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl CustomizeBaseEntityDataTrait for CustomizeBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for CustomizeBaseEntityData {
}

impl super::entity::GameObjectDataTrait for CustomizeBaseEntityData {
}

impl super::core::DataBusPeerTrait for CustomizeBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CustomizeBaseEntityData {
}

impl super::core::DataContainerTrait for CustomizeBaseEntityData {
}

pub static CUSTOMIZEBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeBaseEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeBaseEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(CustomizeBaseEntityData, realm),
            },
        ],
    }),
    array_type: Some(CUSTOMIZEBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CustomizeBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZEBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZEBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeBaseEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizeBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalPlayerFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait LocalPlayerFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl LocalPlayerFilterEntityDataTrait for LocalPlayerFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for LocalPlayerFilterEntityData {
}

impl super::entity::GameObjectDataTrait for LocalPlayerFilterEntityData {
}

impl super::core::DataBusPeerTrait for LocalPlayerFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LocalPlayerFilterEntityData {
}

impl super::core::DataContainerTrait for LocalPlayerFilterEntityData {
}

pub static LOCALPLAYERFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalPlayerFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LocalPlayerFilterEntityData, realm),
            },
        ],
    }),
    array_type: Some(LOCALPLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalPlayerFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALPLAYERFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALPLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalPlayerFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LocalPlayerFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub invert_filter: bool,
    pub forward_to_spectators: bool,
}

pub trait PlayerFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn invert_filter(&self) -> &bool;
    fn invert_filter_mut(&mut self) -> &mut bool;
    fn forward_to_spectators(&self) -> &bool;
    fn forward_to_spectators_mut(&mut self) -> &mut bool;
}

impl PlayerFilterEntityDataTrait for PlayerFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn invert_filter(&self) -> &bool {
        &self.invert_filter
    }
    fn invert_filter_mut(&mut self) -> &mut bool {
        &mut self.invert_filter
    }
    fn forward_to_spectators(&self) -> &bool {
        &self.forward_to_spectators
    }
    fn forward_to_spectators_mut(&mut self) -> &mut bool {
        &mut self.forward_to_spectators
    }
}

impl super::entity::EntityDataTrait for PlayerFilterEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerFilterEntityData {
}

impl super::core::DataBusPeerTrait for PlayerFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerFilterEntityData {
}

impl super::core::DataContainerTrait for PlayerFilterEntityData {
}

pub static PLAYERFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayerFilterEntityData, realm),
            },
            FieldInfoData {
                name: "InvertFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerFilterEntityData, invert_filter),
            },
            FieldInfoData {
                name: "ForwardToSpectators",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerFilterEntityData, forward_to_spectators),
            },
        ],
    }),
    array_type: Some(PLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectAreaQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub geometry_transform: super::core::LinearTransform,
    pub radius: f32,
}

pub trait ObjectAreaQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn geometry_transform(&self) -> &super::core::LinearTransform;
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
}

impl ObjectAreaQueryEntityDataTrait for ObjectAreaQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn geometry_transform(&self) -> &super::core::LinearTransform {
        &self.geometry_transform
    }
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.geometry_transform
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
}

impl super::entity::EntityDataTrait for ObjectAreaQueryEntityData {
}

impl super::entity::GameObjectDataTrait for ObjectAreaQueryEntityData {
}

impl super::core::DataBusPeerTrait for ObjectAreaQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectAreaQueryEntityData {
}

impl super::core::DataContainerTrait for ObjectAreaQueryEntityData {
}

pub static OBJECTAREAQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectAreaQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ObjectAreaQueryEntityData, realm),
            },
            FieldInfoData {
                name: "GeometryTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ObjectAreaQueryEntityData, geometry_transform),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectAreaQueryEntityData, radius),
            },
        ],
    }),
    array_type: Some(OBJECTAREAQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObjectAreaQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTAREAQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTAREAQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectAreaQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ObjectAreaQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AreaQueryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub enabled: bool,
    pub geometry_transform: super::core::LinearTransform,
    pub use_character_entity: bool,
    pub radius: f32,
    pub use_radius_with_geometry_transform: bool,
    pub query_using_extra_player_in_double_player_event: bool,
    pub only_query_if_on_different_teams: bool,
}

pub trait AreaQueryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn geometry_transform(&self) -> &super::core::LinearTransform;
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn use_character_entity(&self) -> &bool;
    fn use_character_entity_mut(&mut self) -> &mut bool;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn use_radius_with_geometry_transform(&self) -> &bool;
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool;
    fn query_using_extra_player_in_double_player_event(&self) -> &bool;
    fn query_using_extra_player_in_double_player_event_mut(&mut self) -> &mut bool;
    fn only_query_if_on_different_teams(&self) -> &bool;
    fn only_query_if_on_different_teams_mut(&mut self) -> &mut bool;
}

impl AreaQueryEntityDataTrait for AreaQueryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn geometry_transform(&self) -> &super::core::LinearTransform {
        &self.geometry_transform
    }
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.geometry_transform
    }
    fn use_character_entity(&self) -> &bool {
        &self.use_character_entity
    }
    fn use_character_entity_mut(&mut self) -> &mut bool {
        &mut self.use_character_entity
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn use_radius_with_geometry_transform(&self) -> &bool {
        &self.use_radius_with_geometry_transform
    }
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool {
        &mut self.use_radius_with_geometry_transform
    }
    fn query_using_extra_player_in_double_player_event(&self) -> &bool {
        &self.query_using_extra_player_in_double_player_event
    }
    fn query_using_extra_player_in_double_player_event_mut(&mut self) -> &mut bool {
        &mut self.query_using_extra_player_in_double_player_event
    }
    fn only_query_if_on_different_teams(&self) -> &bool {
        &self.only_query_if_on_different_teams
    }
    fn only_query_if_on_different_teams_mut(&mut self) -> &mut bool {
        &mut self.only_query_if_on_different_teams
    }
}

impl super::entity::EntityDataTrait for AreaQueryEntityData {
}

impl super::entity::GameObjectDataTrait for AreaQueryEntityData {
}

impl super::core::DataBusPeerTrait for AreaQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AreaQueryEntityData {
}

impl super::core::DataContainerTrait for AreaQueryEntityData {
}

pub static AREAQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AreaQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AreaQueryEntityData, realm),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, enabled),
            },
            FieldInfoData {
                name: "GeometryTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AreaQueryEntityData, geometry_transform),
            },
            FieldInfoData {
                name: "UseCharacterEntity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, use_character_entity),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaQueryEntityData, radius),
            },
            FieldInfoData {
                name: "UseRadiusWithGeometryTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, use_radius_with_geometry_transform),
            },
            FieldInfoData {
                name: "QueryUsingExtraPlayerInDoublePlayerEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, query_using_extra_player_in_double_player_event),
            },
            FieldInfoData {
                name: "OnlyQueryIfOnDifferentTeams",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaQueryEntityData, only_query_if_on_different_teams),
            },
        ],
    }),
    array_type: Some(AREAQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AreaQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AREAQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AREAQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AreaProximityEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub auto_start: bool,
    pub update_pass: super::entity::UpdatePass,
    pub proximity_distance: f32,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait AreaProximityEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn update_pass(&self) -> &super::entity::UpdatePass;
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass;
    fn proximity_distance(&self) -> &f32;
    fn proximity_distance_mut(&mut self) -> &mut f32;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl AreaProximityEntityDataTrait for AreaProximityEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn update_pass(&self) -> &super::entity::UpdatePass {
        &self.update_pass
    }
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        &mut self.update_pass
    }
    fn proximity_distance(&self) -> &f32 {
        &self.proximity_distance
    }
    fn proximity_distance_mut(&mut self) -> &mut f32 {
        &mut self.proximity_distance
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for AreaProximityEntityData {
}

impl super::entity::GameObjectDataTrait for AreaProximityEntityData {
}

impl super::core::DataBusPeerTrait for AreaProximityEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AreaProximityEntityData {
}

impl super::core::DataContainerTrait for AreaProximityEntityData {
}

pub static AREAPROXIMITYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaProximityEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AreaProximityEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AreaProximityEntityData, realm),
            },
            FieldInfoData {
                name: "AutoStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaProximityEntityData, auto_start),
            },
            FieldInfoData {
                name: "UpdatePass",
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(AreaProximityEntityData, update_pass),
            },
            FieldInfoData {
                name: "ProximityDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaProximityEntityData, proximity_distance),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(AreaProximityEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(AREAPROXIMITYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AreaProximityEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AREAPROXIMITYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AREAPROXIMITYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaProximityEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaProximityEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputRestrictionEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub override_previous_input_restriction: bool,
    pub apply_restrictions_to_specific_player: bool,
    pub disabled_inputs: Vec<i32>,
}

pub trait InputRestrictionEntityDataTrait: super::entity::EntityDataTrait {
    fn override_previous_input_restriction(&self) -> &bool;
    fn override_previous_input_restriction_mut(&mut self) -> &mut bool;
    fn apply_restrictions_to_specific_player(&self) -> &bool;
    fn apply_restrictions_to_specific_player_mut(&mut self) -> &mut bool;
    fn disabled_inputs(&self) -> &Vec<i32>;
    fn disabled_inputs_mut(&mut self) -> &mut Vec<i32>;
}

impl InputRestrictionEntityDataTrait for InputRestrictionEntityData {
    fn override_previous_input_restriction(&self) -> &bool {
        &self.override_previous_input_restriction
    }
    fn override_previous_input_restriction_mut(&mut self) -> &mut bool {
        &mut self.override_previous_input_restriction
    }
    fn apply_restrictions_to_specific_player(&self) -> &bool {
        &self.apply_restrictions_to_specific_player
    }
    fn apply_restrictions_to_specific_player_mut(&mut self) -> &mut bool {
        &mut self.apply_restrictions_to_specific_player
    }
    fn disabled_inputs(&self) -> &Vec<i32> {
        &self.disabled_inputs
    }
    fn disabled_inputs_mut(&mut self) -> &mut Vec<i32> {
        &mut self.disabled_inputs
    }
}

impl super::entity::EntityDataTrait for InputRestrictionEntityData {
}

impl super::entity::GameObjectDataTrait for InputRestrictionEntityData {
}

impl super::core::DataBusPeerTrait for InputRestrictionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for InputRestrictionEntityData {
}

impl super::core::DataContainerTrait for InputRestrictionEntityData {
}

pub static INPUTRESTRICTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRestrictionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputRestrictionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OverridePreviousInputRestriction",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputRestrictionEntityData, override_previous_input_restriction),
            },
            FieldInfoData {
                name: "ApplyRestrictionsToSpecificPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputRestrictionEntityData, apply_restrictions_to_specific_player),
            },
            FieldInfoData {
                name: "DisabledInputs",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(InputRestrictionEntityData, disabled_inputs),
            },
        ],
    }),
    array_type: Some(INPUTRESTRICTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputRestrictionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTRESTRICTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INPUTRESTRICTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRestrictionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InputRestrictionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventIfSwitchEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub start_state: bool,
    pub run_once: bool,
}

pub trait EventIfSwitchEntityDataTrait: super::entity::EntityDataTrait {
    fn start_state(&self) -> &bool;
    fn start_state_mut(&mut self) -> &mut bool;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
}

impl EventIfSwitchEntityDataTrait for EventIfSwitchEntityData {
    fn start_state(&self) -> &bool {
        &self.start_state
    }
    fn start_state_mut(&mut self) -> &mut bool {
        &mut self.start_state
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
}

impl super::entity::EntityDataTrait for EventIfSwitchEntityData {
}

impl super::entity::GameObjectDataTrait for EventIfSwitchEntityData {
}

impl super::core::DataBusPeerTrait for EventIfSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventIfSwitchEntityData {
}

impl super::core::DataContainerTrait for EventIfSwitchEntityData {
}

pub static EVENTIFSWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventIfSwitchEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventIfSwitchEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventIfSwitchEntityData, start_state),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventIfSwitchEntityData, run_once),
            },
        ],
    }),
    array_type: Some(EVENTIFSWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventIfSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTIFSWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTIFSWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventIfSwitchEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventIfSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TeamFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub invert_filter: bool,
    pub team: super::gameplay_sim::TeamId,
    pub generate_event_for_every_matching_team_member: bool,
    pub get_team_from_player_event: bool,
}

pub trait TeamFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn invert_filter(&self) -> &bool;
    fn invert_filter_mut(&mut self) -> &mut bool;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn generate_event_for_every_matching_team_member(&self) -> &bool;
    fn generate_event_for_every_matching_team_member_mut(&mut self) -> &mut bool;
    fn get_team_from_player_event(&self) -> &bool;
    fn get_team_from_player_event_mut(&mut self) -> &mut bool;
}

impl TeamFilterEntityDataTrait for TeamFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn invert_filter(&self) -> &bool {
        &self.invert_filter
    }
    fn invert_filter_mut(&mut self) -> &mut bool {
        &mut self.invert_filter
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn generate_event_for_every_matching_team_member(&self) -> &bool {
        &self.generate_event_for_every_matching_team_member
    }
    fn generate_event_for_every_matching_team_member_mut(&mut self) -> &mut bool {
        &mut self.generate_event_for_every_matching_team_member
    }
    fn get_team_from_player_event(&self) -> &bool {
        &self.get_team_from_player_event
    }
    fn get_team_from_player_event_mut(&mut self) -> &mut bool {
        &mut self.get_team_from_player_event
    }
}

impl super::entity::EntityDataTrait for TeamFilterEntityData {
}

impl super::entity::GameObjectDataTrait for TeamFilterEntityData {
}

impl super::core::DataBusPeerTrait for TeamFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TeamFilterEntityData {
}

impl super::core::DataContainerTrait for TeamFilterEntityData {
}

pub static TEAMFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeamFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TeamFilterEntityData, realm),
            },
            FieldInfoData {
                name: "InvertFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeamFilterEntityData, invert_filter),
            },
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(TeamFilterEntityData, team),
            },
            FieldInfoData {
                name: "GenerateEventForEveryMatchingTeamMember",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeamFilterEntityData, generate_event_for_every_matching_team_member),
            },
            FieldInfoData {
                name: "GetTeamFromPlayerEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeamFilterEntityData, get_team_from_player_event),
            },
        ],
    }),
    array_type: Some(TEAMFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TeamFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TEAMFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEAMFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeamFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlatformSplitterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub run_once: bool,
    pub realm: super::core::Realm,
}

pub trait PlatformSplitterEntityDataTrait: super::entity::EntityDataTrait {
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl PlatformSplitterEntityDataTrait for PlatformSplitterEntityData {
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for PlatformSplitterEntityData {
}

impl super::entity::GameObjectDataTrait for PlatformSplitterEntityData {
}

impl super::core::DataBusPeerTrait for PlatformSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlatformSplitterEntityData {
}

impl super::core::DataContainerTrait for PlatformSplitterEntityData {
}

pub static PLATFORMSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformSplitterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlatformSplitterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlatformSplitterEntityData, run_once),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlatformSplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(PLATFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlatformSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLATFORMSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLATFORMSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformSplitterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlatformSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSplitterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub run_once: bool,
    pub realm: super::core::Realm,
}

pub trait EventSplitterEntityDataTrait: super::entity::EntityDataTrait {
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl EventSplitterEntityDataTrait for EventSplitterEntityData {
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for EventSplitterEntityData {
}

impl super::entity::GameObjectDataTrait for EventSplitterEntityData {
}

impl super::core::DataBusPeerTrait for EventSplitterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventSplitterEntityData {
}

impl super::core::DataContainerTrait for EventSplitterEntityData {
}

pub static EVENTSPLITTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSplitterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSplitterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventSplitterEntityData, run_once),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventSplitterEntityData, realm),
            },
        ],
    }),
    array_type: Some(EVENTSPLITTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSplitterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSPLITTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSPLITTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSplitterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventSplitterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventMemoryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait EventMemoryEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl EventMemoryEntityDataTrait for EventMemoryEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for EventMemoryEntityData {
}

impl super::entity::GameObjectDataTrait for EventMemoryEntityData {
}

impl super::core::DataBusPeerTrait for EventMemoryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventMemoryEntityData {
}

impl super::core::DataContainerTrait for EventMemoryEntityData {
}

pub static EVENTMEMORYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventMemoryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventMemoryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventMemoryEntityData, realm),
            },
        ],
    }),
    array_type: Some(EVENTMEMORYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventMemoryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTMEMORYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTMEMORYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventMemoryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventMemoryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpeedEventGateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub min_speed: f32,
    pub max_speed: f32,
}

pub trait SpeedEventGateEntityDataTrait: super::entity::EntityDataTrait {
    fn min_speed(&self) -> &f32;
    fn min_speed_mut(&mut self) -> &mut f32;
    fn max_speed(&self) -> &f32;
    fn max_speed_mut(&mut self) -> &mut f32;
}

impl SpeedEventGateEntityDataTrait for SpeedEventGateEntityData {
    fn min_speed(&self) -> &f32 {
        &self.min_speed
    }
    fn min_speed_mut(&mut self) -> &mut f32 {
        &mut self.min_speed
    }
    fn max_speed(&self) -> &f32 {
        &self.max_speed
    }
    fn max_speed_mut(&mut self) -> &mut f32 {
        &mut self.max_speed
    }
}

impl super::entity::EntityDataTrait for SpeedEventGateEntityData {
}

impl super::entity::GameObjectDataTrait for SpeedEventGateEntityData {
}

impl super::core::DataBusPeerTrait for SpeedEventGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpeedEventGateEntityData {
}

impl super::core::DataContainerTrait for SpeedEventGateEntityData {
}

pub static SPEEDEVENTGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpeedEventGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpeedEventGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeedEventGateEntityData, min_speed),
            },
            FieldInfoData {
                name: "MaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpeedEventGateEntityData, max_speed),
            },
        ],
    }),
    array_type: Some(SPEEDEVENTGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpeedEventGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPEEDEVENTGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPEEDEVENTGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpeedEventGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SpeedEventGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventCompareGateEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub value: i32,
    pub compare_type: EventCompareGateType,
    pub realm: super::core::Realm,
}

pub trait EventCompareGateEntityDataTrait: super::entity::EntityDataTrait {
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
    fn compare_type(&self) -> &EventCompareGateType;
    fn compare_type_mut(&mut self) -> &mut EventCompareGateType;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl EventCompareGateEntityDataTrait for EventCompareGateEntityData {
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
    fn compare_type(&self) -> &EventCompareGateType {
        &self.compare_type
    }
    fn compare_type_mut(&mut self) -> &mut EventCompareGateType {
        &mut self.compare_type
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for EventCompareGateEntityData {
}

impl super::entity::GameObjectDataTrait for EventCompareGateEntityData {
}

impl super::core::DataBusPeerTrait for EventCompareGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventCompareGateEntityData {
}

impl super::core::DataContainerTrait for EventCompareGateEntityData {
}

pub static EVENTCOMPAREGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventCompareGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventCompareGateEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EventCompareGateEntityData, value),
            },
            FieldInfoData {
                name: "CompareType",
                flags: MemberInfoFlags::new(0),
                field_type: "EventCompareGateType",
                rust_offset: offset_of!(EventCompareGateEntityData, compare_type),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(EventCompareGateEntityData, realm),
            },
        ],
    }),
    array_type: Some(EVENTCOMPAREGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventCompareGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCOMPAREGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTCOMPAREGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventCompareGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventCompareGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EventCompareGateType {
    #[default]
    EventCompareGate_Equals = 0,
    EventCompareGate_NotEquals = 1,
    EventCompareGate_Less = 2,
    EventCompareGate_LessEquals = 3,
    EventCompareGate_Greater = 4,
    EventCompareGate_GreaterEquals = 5,
}

pub static EVENTCOMPAREGATETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventCompareGateType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(EVENTCOMPAREGATETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EventCompareGateType {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTCOMPAREGATETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTCOMPAREGATETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventCompareGateType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventCompareGateType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SaveGameLoadedEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait SaveGameLoadedEntityDataTrait: super::entity::EntityDataTrait {
}

impl SaveGameLoadedEntityDataTrait for SaveGameLoadedEntityData {
}

impl super::entity::EntityDataTrait for SaveGameLoadedEntityData {
}

impl super::entity::GameObjectDataTrait for SaveGameLoadedEntityData {
}

impl super::core::DataBusPeerTrait for SaveGameLoadedEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SaveGameLoadedEntityData {
}

impl super::core::DataContainerTrait for SaveGameLoadedEntityData {
}

pub static SAVEGAMELOADEDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SaveGameLoadedEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SaveGameLoadedEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SAVEGAMELOADEDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SaveGameLoadedEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SAVEGAMELOADEDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SAVEGAMELOADEDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SaveGameLoadedEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SaveGameLoadedEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SaveEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub save_screen_texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub level_name: String,
    pub save_file_name: String,
    pub save_name_s_i_d: String,
    pub check_for_human_player: bool,
}

pub trait SaveEntityDataTrait: super::entity::EntityDataTrait {
    fn save_screen_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn save_screen_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn level_name(&self) -> &String;
    fn level_name_mut(&mut self) -> &mut String;
    fn save_file_name(&self) -> &String;
    fn save_file_name_mut(&mut self) -> &mut String;
    fn save_name_s_i_d(&self) -> &String;
    fn save_name_s_i_d_mut(&mut self) -> &mut String;
    fn check_for_human_player(&self) -> &bool;
    fn check_for_human_player_mut(&mut self) -> &mut bool;
}

impl SaveEntityDataTrait for SaveEntityData {
    fn save_screen_texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.save_screen_texture
    }
    fn save_screen_texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.save_screen_texture
    }
    fn level_name(&self) -> &String {
        &self.level_name
    }
    fn level_name_mut(&mut self) -> &mut String {
        &mut self.level_name
    }
    fn save_file_name(&self) -> &String {
        &self.save_file_name
    }
    fn save_file_name_mut(&mut self) -> &mut String {
        &mut self.save_file_name
    }
    fn save_name_s_i_d(&self) -> &String {
        &self.save_name_s_i_d
    }
    fn save_name_s_i_d_mut(&mut self) -> &mut String {
        &mut self.save_name_s_i_d
    }
    fn check_for_human_player(&self) -> &bool {
        &self.check_for_human_player
    }
    fn check_for_human_player_mut(&mut self) -> &mut bool {
        &mut self.check_for_human_player
    }
}

impl super::entity::EntityDataTrait for SaveEntityData {
}

impl super::entity::GameObjectDataTrait for SaveEntityData {
}

impl super::core::DataBusPeerTrait for SaveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SaveEntityData {
}

impl super::core::DataContainerTrait for SaveEntityData {
}

pub static SAVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SaveEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SaveEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SaveScreenTexture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(SaveEntityData, save_screen_texture),
            },
            FieldInfoData {
                name: "LevelName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SaveEntityData, level_name),
            },
            FieldInfoData {
                name: "SaveFileName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SaveEntityData, save_file_name),
            },
            FieldInfoData {
                name: "SaveNameSID",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SaveEntityData, save_name_s_i_d),
            },
            FieldInfoData {
                name: "CheckForHumanPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SaveEntityData, check_for_human_player),
            },
        ],
    }),
    array_type: Some(SAVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SaveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SAVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SAVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SaveEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SaveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StartEntityData {
    pub _glacier_base: StartPointEntityData,
}

pub trait StartEntityDataTrait: StartPointEntityDataTrait {
}

impl StartEntityDataTrait for StartEntityData {
}

impl StartPointEntityDataTrait for StartEntityData {
    fn start_name(&self) -> &String {
        self._glacier_base.start_name()
    }
    fn start_name_mut(&mut self) -> &mut String {
        self._glacier_base.start_name_mut()
    }
}

impl super::entity::EntityDataTrait for StartEntityData {
}

impl super::entity::GameObjectDataTrait for StartEntityData {
}

impl super::core::DataBusPeerTrait for StartEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StartEntityData {
}

impl super::core::DataContainerTrait for StartEntityData {
}

pub static STARTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(STARTPOINTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StartEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STARTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StartEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STARTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STARTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StartEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StartPointEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub start_name: String,
}

pub trait StartPointEntityDataTrait: super::entity::EntityDataTrait {
    fn start_name(&self) -> &String;
    fn start_name_mut(&mut self) -> &mut String;
}

impl StartPointEntityDataTrait for StartPointEntityData {
    fn start_name(&self) -> &String {
        &self.start_name
    }
    fn start_name_mut(&mut self) -> &mut String {
        &mut self.start_name
    }
}

impl super::entity::EntityDataTrait for StartPointEntityData {
}

impl super::entity::GameObjectDataTrait for StartPointEntityData {
}

impl super::core::DataBusPeerTrait for StartPointEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StartPointEntityData {
}

impl super::core::DataContainerTrait for StartPointEntityData {
}

pub static STARTPOINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartPointEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StartPointEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(StartPointEntityData, start_name),
            },
        ],
    }),
    array_type: Some(STARTPOINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StartPointEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STARTPOINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STARTPOINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartPointEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StartPointEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ServerStartPointLoadedFromDSubLevelMessage {
}

pub trait ServerStartPointLoadedFromDSubLevelMessageTrait: TypeObject {
}

impl ServerStartPointLoadedFromDSubLevelMessageTrait for ServerStartPointLoadedFromDSubLevelMessage {
}

pub static SERVERSTARTPOINTLOADEDFROMDSUBLEVELMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerStartPointLoadedFromDSubLevelMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerStartPointLoadedFromDSubLevelMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ServerStartPointLoadedFromDSubLevelMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERSTARTPOINTLOADEDFROMDSUBLEVELMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct MapMarkerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub sid: String,
    pub name_letter: String,
    pub nr_of_passengers: i32,
    pub nr_of_entries: i32,
    pub is_visible: bool,
    pub show_radius: f32,
    pub hide_radius: f32,
    pub blink_time: f32,
    pub marker_type: MapMarkerType,
    pub visible_for_team: super::gameplay_sim::TeamId,
    pub owner_team: super::gameplay_sim::TeamId,
    pub hud_icon: UIHudIcon,
    pub icon_name: String,
    pub icon_behavior: Option<Arc<Mutex<dyn UIWorldIconBehaviorTrait>>>,
    pub vertical_offset: f32,
    pub show_air_target_box: bool,
    pub is_focus_point: bool,
    pub focus_point_radius: f32,
    pub focus_priority: i32,
    pub snap: bool,
    pub only_show_snapped: bool,
    pub use_marker_transform: bool,
    pub server_controlled_position: bool,
    pub position_static: bool,
    pub enabled: bool,
    pub show_distance_in_text: bool,
    pub progress_time: f32,
    pub progress: f32,
    pub tracked_players_in_range: u32,
    pub show_progress: bool,
    pub tracking_player_range: f32,
    pub instant_flag_return_radius: f32,
    pub progress_player_speed_up_percentage: f32,
    pub base_transform: super::core::Vec3,
    pub progress_time1_player: f32,
    pub progress_min_time: f32,
    pub visual_transform: super::core::LinearTransform,
}

pub trait MapMarkerEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn sid(&self) -> &String;
    fn sid_mut(&mut self) -> &mut String;
    fn name_letter(&self) -> &String;
    fn name_letter_mut(&mut self) -> &mut String;
    fn nr_of_passengers(&self) -> &i32;
    fn nr_of_passengers_mut(&mut self) -> &mut i32;
    fn nr_of_entries(&self) -> &i32;
    fn nr_of_entries_mut(&mut self) -> &mut i32;
    fn is_visible(&self) -> &bool;
    fn is_visible_mut(&mut self) -> &mut bool;
    fn show_radius(&self) -> &f32;
    fn show_radius_mut(&mut self) -> &mut f32;
    fn hide_radius(&self) -> &f32;
    fn hide_radius_mut(&mut self) -> &mut f32;
    fn blink_time(&self) -> &f32;
    fn blink_time_mut(&mut self) -> &mut f32;
    fn marker_type(&self) -> &MapMarkerType;
    fn marker_type_mut(&mut self) -> &mut MapMarkerType;
    fn visible_for_team(&self) -> &super::gameplay_sim::TeamId;
    fn visible_for_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn owner_team(&self) -> &super::gameplay_sim::TeamId;
    fn owner_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn hud_icon(&self) -> &UIHudIcon;
    fn hud_icon_mut(&mut self) -> &mut UIHudIcon;
    fn icon_name(&self) -> &String;
    fn icon_name_mut(&mut self) -> &mut String;
    fn icon_behavior(&self) -> &Option<Arc<Mutex<dyn UIWorldIconBehaviorTrait>>>;
    fn icon_behavior_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UIWorldIconBehaviorTrait>>>;
    fn vertical_offset(&self) -> &f32;
    fn vertical_offset_mut(&mut self) -> &mut f32;
    fn show_air_target_box(&self) -> &bool;
    fn show_air_target_box_mut(&mut self) -> &mut bool;
    fn is_focus_point(&self) -> &bool;
    fn is_focus_point_mut(&mut self) -> &mut bool;
    fn focus_point_radius(&self) -> &f32;
    fn focus_point_radius_mut(&mut self) -> &mut f32;
    fn focus_priority(&self) -> &i32;
    fn focus_priority_mut(&mut self) -> &mut i32;
    fn snap(&self) -> &bool;
    fn snap_mut(&mut self) -> &mut bool;
    fn only_show_snapped(&self) -> &bool;
    fn only_show_snapped_mut(&mut self) -> &mut bool;
    fn use_marker_transform(&self) -> &bool;
    fn use_marker_transform_mut(&mut self) -> &mut bool;
    fn server_controlled_position(&self) -> &bool;
    fn server_controlled_position_mut(&mut self) -> &mut bool;
    fn position_static(&self) -> &bool;
    fn position_static_mut(&mut self) -> &mut bool;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn show_distance_in_text(&self) -> &bool;
    fn show_distance_in_text_mut(&mut self) -> &mut bool;
    fn progress_time(&self) -> &f32;
    fn progress_time_mut(&mut self) -> &mut f32;
    fn progress(&self) -> &f32;
    fn progress_mut(&mut self) -> &mut f32;
    fn tracked_players_in_range(&self) -> &u32;
    fn tracked_players_in_range_mut(&mut self) -> &mut u32;
    fn show_progress(&self) -> &bool;
    fn show_progress_mut(&mut self) -> &mut bool;
    fn tracking_player_range(&self) -> &f32;
    fn tracking_player_range_mut(&mut self) -> &mut f32;
    fn instant_flag_return_radius(&self) -> &f32;
    fn instant_flag_return_radius_mut(&mut self) -> &mut f32;
    fn progress_player_speed_up_percentage(&self) -> &f32;
    fn progress_player_speed_up_percentage_mut(&mut self) -> &mut f32;
    fn base_transform(&self) -> &super::core::Vec3;
    fn base_transform_mut(&mut self) -> &mut super::core::Vec3;
    fn progress_time1_player(&self) -> &f32;
    fn progress_time1_player_mut(&mut self) -> &mut f32;
    fn progress_min_time(&self) -> &f32;
    fn progress_min_time_mut(&mut self) -> &mut f32;
    fn visual_transform(&self) -> &super::core::LinearTransform;
    fn visual_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl MapMarkerEntityDataTrait for MapMarkerEntityData {
    fn sid(&self) -> &String {
        &self.sid
    }
    fn sid_mut(&mut self) -> &mut String {
        &mut self.sid
    }
    fn name_letter(&self) -> &String {
        &self.name_letter
    }
    fn name_letter_mut(&mut self) -> &mut String {
        &mut self.name_letter
    }
    fn nr_of_passengers(&self) -> &i32 {
        &self.nr_of_passengers
    }
    fn nr_of_passengers_mut(&mut self) -> &mut i32 {
        &mut self.nr_of_passengers
    }
    fn nr_of_entries(&self) -> &i32 {
        &self.nr_of_entries
    }
    fn nr_of_entries_mut(&mut self) -> &mut i32 {
        &mut self.nr_of_entries
    }
    fn is_visible(&self) -> &bool {
        &self.is_visible
    }
    fn is_visible_mut(&mut self) -> &mut bool {
        &mut self.is_visible
    }
    fn show_radius(&self) -> &f32 {
        &self.show_radius
    }
    fn show_radius_mut(&mut self) -> &mut f32 {
        &mut self.show_radius
    }
    fn hide_radius(&self) -> &f32 {
        &self.hide_radius
    }
    fn hide_radius_mut(&mut self) -> &mut f32 {
        &mut self.hide_radius
    }
    fn blink_time(&self) -> &f32 {
        &self.blink_time
    }
    fn blink_time_mut(&mut self) -> &mut f32 {
        &mut self.blink_time
    }
    fn marker_type(&self) -> &MapMarkerType {
        &self.marker_type
    }
    fn marker_type_mut(&mut self) -> &mut MapMarkerType {
        &mut self.marker_type
    }
    fn visible_for_team(&self) -> &super::gameplay_sim::TeamId {
        &self.visible_for_team
    }
    fn visible_for_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.visible_for_team
    }
    fn owner_team(&self) -> &super::gameplay_sim::TeamId {
        &self.owner_team
    }
    fn owner_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.owner_team
    }
    fn hud_icon(&self) -> &UIHudIcon {
        &self.hud_icon
    }
    fn hud_icon_mut(&mut self) -> &mut UIHudIcon {
        &mut self.hud_icon
    }
    fn icon_name(&self) -> &String {
        &self.icon_name
    }
    fn icon_name_mut(&mut self) -> &mut String {
        &mut self.icon_name
    }
    fn icon_behavior(&self) -> &Option<Arc<Mutex<dyn UIWorldIconBehaviorTrait>>> {
        &self.icon_behavior
    }
    fn icon_behavior_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UIWorldIconBehaviorTrait>>> {
        &mut self.icon_behavior
    }
    fn vertical_offset(&self) -> &f32 {
        &self.vertical_offset
    }
    fn vertical_offset_mut(&mut self) -> &mut f32 {
        &mut self.vertical_offset
    }
    fn show_air_target_box(&self) -> &bool {
        &self.show_air_target_box
    }
    fn show_air_target_box_mut(&mut self) -> &mut bool {
        &mut self.show_air_target_box
    }
    fn is_focus_point(&self) -> &bool {
        &self.is_focus_point
    }
    fn is_focus_point_mut(&mut self) -> &mut bool {
        &mut self.is_focus_point
    }
    fn focus_point_radius(&self) -> &f32 {
        &self.focus_point_radius
    }
    fn focus_point_radius_mut(&mut self) -> &mut f32 {
        &mut self.focus_point_radius
    }
    fn focus_priority(&self) -> &i32 {
        &self.focus_priority
    }
    fn focus_priority_mut(&mut self) -> &mut i32 {
        &mut self.focus_priority
    }
    fn snap(&self) -> &bool {
        &self.snap
    }
    fn snap_mut(&mut self) -> &mut bool {
        &mut self.snap
    }
    fn only_show_snapped(&self) -> &bool {
        &self.only_show_snapped
    }
    fn only_show_snapped_mut(&mut self) -> &mut bool {
        &mut self.only_show_snapped
    }
    fn use_marker_transform(&self) -> &bool {
        &self.use_marker_transform
    }
    fn use_marker_transform_mut(&mut self) -> &mut bool {
        &mut self.use_marker_transform
    }
    fn server_controlled_position(&self) -> &bool {
        &self.server_controlled_position
    }
    fn server_controlled_position_mut(&mut self) -> &mut bool {
        &mut self.server_controlled_position
    }
    fn position_static(&self) -> &bool {
        &self.position_static
    }
    fn position_static_mut(&mut self) -> &mut bool {
        &mut self.position_static
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn show_distance_in_text(&self) -> &bool {
        &self.show_distance_in_text
    }
    fn show_distance_in_text_mut(&mut self) -> &mut bool {
        &mut self.show_distance_in_text
    }
    fn progress_time(&self) -> &f32 {
        &self.progress_time
    }
    fn progress_time_mut(&mut self) -> &mut f32 {
        &mut self.progress_time
    }
    fn progress(&self) -> &f32 {
        &self.progress
    }
    fn progress_mut(&mut self) -> &mut f32 {
        &mut self.progress
    }
    fn tracked_players_in_range(&self) -> &u32 {
        &self.tracked_players_in_range
    }
    fn tracked_players_in_range_mut(&mut self) -> &mut u32 {
        &mut self.tracked_players_in_range
    }
    fn show_progress(&self) -> &bool {
        &self.show_progress
    }
    fn show_progress_mut(&mut self) -> &mut bool {
        &mut self.show_progress
    }
    fn tracking_player_range(&self) -> &f32 {
        &self.tracking_player_range
    }
    fn tracking_player_range_mut(&mut self) -> &mut f32 {
        &mut self.tracking_player_range
    }
    fn instant_flag_return_radius(&self) -> &f32 {
        &self.instant_flag_return_radius
    }
    fn instant_flag_return_radius_mut(&mut self) -> &mut f32 {
        &mut self.instant_flag_return_radius
    }
    fn progress_player_speed_up_percentage(&self) -> &f32 {
        &self.progress_player_speed_up_percentage
    }
    fn progress_player_speed_up_percentage_mut(&mut self) -> &mut f32 {
        &mut self.progress_player_speed_up_percentage
    }
    fn base_transform(&self) -> &super::core::Vec3 {
        &self.base_transform
    }
    fn base_transform_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.base_transform
    }
    fn progress_time1_player(&self) -> &f32 {
        &self.progress_time1_player
    }
    fn progress_time1_player_mut(&mut self) -> &mut f32 {
        &mut self.progress_time1_player
    }
    fn progress_min_time(&self) -> &f32 {
        &self.progress_min_time
    }
    fn progress_min_time_mut(&mut self) -> &mut f32 {
        &mut self.progress_min_time
    }
    fn visual_transform(&self) -> &super::core::LinearTransform {
        &self.visual_transform
    }
    fn visual_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.visual_transform
    }
}

impl super::entity::SpatialEntityDataTrait for MapMarkerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for MapMarkerEntityData {
}

impl super::entity::GameObjectDataTrait for MapMarkerEntityData {
}

impl super::core::DataBusPeerTrait for MapMarkerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MapMarkerEntityData {
}

impl super::core::DataContainerTrait for MapMarkerEntityData {
}

pub static MAPMARKERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MapMarkerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Sid",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MapMarkerEntityData, sid),
            },
            FieldInfoData {
                name: "NameLetter",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MapMarkerEntityData, name_letter),
            },
            FieldInfoData {
                name: "NrOfPassengers",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MapMarkerEntityData, nr_of_passengers),
            },
            FieldInfoData {
                name: "NrOfEntries",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MapMarkerEntityData, nr_of_entries),
            },
            FieldInfoData {
                name: "IsVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, is_visible),
            },
            FieldInfoData {
                name: "ShowRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, show_radius),
            },
            FieldInfoData {
                name: "HideRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, hide_radius),
            },
            FieldInfoData {
                name: "BlinkTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, blink_time),
            },
            FieldInfoData {
                name: "MarkerType",
                flags: MemberInfoFlags::new(0),
                field_type: "MapMarkerType",
                rust_offset: offset_of!(MapMarkerEntityData, marker_type),
            },
            FieldInfoData {
                name: "VisibleForTeam",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(MapMarkerEntityData, visible_for_team),
            },
            FieldInfoData {
                name: "OwnerTeam",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(MapMarkerEntityData, owner_team),
            },
            FieldInfoData {
                name: "HudIcon",
                flags: MemberInfoFlags::new(0),
                field_type: "UIHudIcon",
                rust_offset: offset_of!(MapMarkerEntityData, hud_icon),
            },
            FieldInfoData {
                name: "IconName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MapMarkerEntityData, icon_name),
            },
            FieldInfoData {
                name: "IconBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "UIWorldIconBehavior",
                rust_offset: offset_of!(MapMarkerEntityData, icon_behavior),
            },
            FieldInfoData {
                name: "VerticalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, vertical_offset),
            },
            FieldInfoData {
                name: "ShowAirTargetBox",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, show_air_target_box),
            },
            FieldInfoData {
                name: "IsFocusPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, is_focus_point),
            },
            FieldInfoData {
                name: "FocusPointRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, focus_point_radius),
            },
            FieldInfoData {
                name: "FocusPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MapMarkerEntityData, focus_priority),
            },
            FieldInfoData {
                name: "Snap",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, snap),
            },
            FieldInfoData {
                name: "OnlyShowSnapped",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, only_show_snapped),
            },
            FieldInfoData {
                name: "UseMarkerTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, use_marker_transform),
            },
            FieldInfoData {
                name: "ServerControlledPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, server_controlled_position),
            },
            FieldInfoData {
                name: "PositionStatic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, position_static),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, enabled),
            },
            FieldInfoData {
                name: "ShowDistanceInText",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, show_distance_in_text),
            },
            FieldInfoData {
                name: "ProgressTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress_time),
            },
            FieldInfoData {
                name: "Progress",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress),
            },
            FieldInfoData {
                name: "TrackedPlayersInRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MapMarkerEntityData, tracked_players_in_range),
            },
            FieldInfoData {
                name: "ShowProgress",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MapMarkerEntityData, show_progress),
            },
            FieldInfoData {
                name: "TrackingPlayerRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, tracking_player_range),
            },
            FieldInfoData {
                name: "InstantFlagReturnRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, instant_flag_return_radius),
            },
            FieldInfoData {
                name: "ProgressPlayerSpeedUpPercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress_player_speed_up_percentage),
            },
            FieldInfoData {
                name: "BaseTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(MapMarkerEntityData, base_transform),
            },
            FieldInfoData {
                name: "ProgressTime1Player",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress_time1_player),
            },
            FieldInfoData {
                name: "ProgressMinTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MapMarkerEntityData, progress_min_time),
            },
            FieldInfoData {
                name: "VisualTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(MapMarkerEntityData, visual_transform),
            },
        ],
    }),
    array_type: Some(MAPMARKERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MapMarkerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MAPMARKERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MAPMARKERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MapMarkerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MapMarkerColorType {
    #[default]
    MMCTRed = 0,
    MMCTBlue = 1,
    MMCTGreen = 2,
}

pub static MAPMARKERCOLORTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerColorType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MAPMARKERCOLORTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MapMarkerColorType {
    fn type_info(&self) -> &'static TypeInfo {
        MAPMARKERCOLORTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MAPMARKERCOLORTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerColorType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MapMarkerColorType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MapMarkerType {
    #[default]
    MMTMissionObjective = 0,
    MMTSecondaryMissionObjective = 1,
    MMTSoldier = 2,
    MMTVehicle = 3,
    MMTAmmoCrate = 4,
    MMTGeneric = 5,
    MMTFlag = 6,
    MMTTactical = 7,
    MMTWarning = 8,
}

pub static MAPMARKERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MAPMARKERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MapMarkerType {
    fn type_info(&self) -> &'static TypeInfo {
        MAPMARKERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MAPMARKERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MapMarkerType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MapMarkerType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MessageEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub message_info: Option<Arc<Mutex<dyn MessageEntityInfoTrait>>>,
    pub enabled: bool,
}

pub trait MessageEntityDataTrait: super::entity::EntityDataTrait {
    fn message_info(&self) -> &Option<Arc<Mutex<dyn MessageEntityInfoTrait>>>;
    fn message_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MessageEntityInfoTrait>>>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl MessageEntityDataTrait for MessageEntityData {
    fn message_info(&self) -> &Option<Arc<Mutex<dyn MessageEntityInfoTrait>>> {
        &self.message_info
    }
    fn message_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MessageEntityInfoTrait>>> {
        &mut self.message_info
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for MessageEntityData {
}

impl super::entity::GameObjectDataTrait for MessageEntityData {
}

impl super::core::DataBusPeerTrait for MessageEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MessageEntityData {
}

impl super::core::DataContainerTrait for MessageEntityData {
}

pub static MESSAGEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MessageEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MessageInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "MessageEntityInfo",
                rust_offset: offset_of!(MessageEntityData, message_info),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MessageEntityData, enabled),
            },
        ],
    }),
    array_type: Some(MESSAGEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MessageEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MESSAGEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESSAGEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MessageEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MessageEntityInfo {
    pub _glacier_base: super::core::DataContainer,
}

pub trait MessageEntityInfoTrait: super::core::DataContainerTrait {
}

impl MessageEntityInfoTrait for MessageEntityInfo {
}

impl super::core::DataContainerTrait for MessageEntityInfo {
}

pub static MESSAGEENTITYINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageEntityInfo",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MessageEntityInfo as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MESSAGEENTITYINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MessageEntityInfo {
    fn type_info(&self) -> &'static TypeInfo {
        MESSAGEENTITYINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESSAGEENTITYINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageEntityInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MessageEntityInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TacticalObjectiveEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub mission_sid: String,
    pub briefing_sid_team1: String,
    pub briefing_sid_team2: String,
    pub team1_timer: f32,
    pub team2_timer: f32,
}

pub trait TacticalObjectiveEntityDataTrait: super::entity::EntityDataTrait {
    fn mission_sid(&self) -> &String;
    fn mission_sid_mut(&mut self) -> &mut String;
    fn briefing_sid_team1(&self) -> &String;
    fn briefing_sid_team1_mut(&mut self) -> &mut String;
    fn briefing_sid_team2(&self) -> &String;
    fn briefing_sid_team2_mut(&mut self) -> &mut String;
    fn team1_timer(&self) -> &f32;
    fn team1_timer_mut(&mut self) -> &mut f32;
    fn team2_timer(&self) -> &f32;
    fn team2_timer_mut(&mut self) -> &mut f32;
}

impl TacticalObjectiveEntityDataTrait for TacticalObjectiveEntityData {
    fn mission_sid(&self) -> &String {
        &self.mission_sid
    }
    fn mission_sid_mut(&mut self) -> &mut String {
        &mut self.mission_sid
    }
    fn briefing_sid_team1(&self) -> &String {
        &self.briefing_sid_team1
    }
    fn briefing_sid_team1_mut(&mut self) -> &mut String {
        &mut self.briefing_sid_team1
    }
    fn briefing_sid_team2(&self) -> &String {
        &self.briefing_sid_team2
    }
    fn briefing_sid_team2_mut(&mut self) -> &mut String {
        &mut self.briefing_sid_team2
    }
    fn team1_timer(&self) -> &f32 {
        &self.team1_timer
    }
    fn team1_timer_mut(&mut self) -> &mut f32 {
        &mut self.team1_timer
    }
    fn team2_timer(&self) -> &f32 {
        &self.team2_timer
    }
    fn team2_timer_mut(&mut self) -> &mut f32 {
        &mut self.team2_timer
    }
}

impl super::entity::EntityDataTrait for TacticalObjectiveEntityData {
}

impl super::entity::GameObjectDataTrait for TacticalObjectiveEntityData {
}

impl super::core::DataBusPeerTrait for TacticalObjectiveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TacticalObjectiveEntityData {
}

impl super::core::DataContainerTrait for TacticalObjectiveEntityData {
}

pub static TACTICALOBJECTIVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TacticalObjectiveEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TacticalObjectiveEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MissionSid",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TacticalObjectiveEntityData, mission_sid),
            },
            FieldInfoData {
                name: "BriefingSidTeam1",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TacticalObjectiveEntityData, briefing_sid_team1),
            },
            FieldInfoData {
                name: "BriefingSidTeam2",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TacticalObjectiveEntityData, briefing_sid_team2),
            },
            FieldInfoData {
                name: "Team1Timer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TacticalObjectiveEntityData, team1_timer),
            },
            FieldInfoData {
                name: "Team2Timer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TacticalObjectiveEntityData, team2_timer),
            },
        ],
    }),
    array_type: Some(TACTICALOBJECTIVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TacticalObjectiveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TACTICALOBJECTIVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TACTICALOBJECTIVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TacticalObjectiveEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TacticalObjectiveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LevelControlEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub level_to_load: String,
    pub inclusion_options: String,
    pub start_point: String,
    pub roll_credits: bool,
    pub do_persistent_save: bool,
    pub check_single_player_level_installed: bool,
    pub force_reload_resources: bool,
    pub level_manager_initial_level: String,
}

pub trait LevelControlEntityDataTrait: super::entity::EntityDataTrait {
    fn level_to_load(&self) -> &String;
    fn level_to_load_mut(&mut self) -> &mut String;
    fn inclusion_options(&self) -> &String;
    fn inclusion_options_mut(&mut self) -> &mut String;
    fn start_point(&self) -> &String;
    fn start_point_mut(&mut self) -> &mut String;
    fn roll_credits(&self) -> &bool;
    fn roll_credits_mut(&mut self) -> &mut bool;
    fn do_persistent_save(&self) -> &bool;
    fn do_persistent_save_mut(&mut self) -> &mut bool;
    fn check_single_player_level_installed(&self) -> &bool;
    fn check_single_player_level_installed_mut(&mut self) -> &mut bool;
    fn force_reload_resources(&self) -> &bool;
    fn force_reload_resources_mut(&mut self) -> &mut bool;
    fn level_manager_initial_level(&self) -> &String;
    fn level_manager_initial_level_mut(&mut self) -> &mut String;
}

impl LevelControlEntityDataTrait for LevelControlEntityData {
    fn level_to_load(&self) -> &String {
        &self.level_to_load
    }
    fn level_to_load_mut(&mut self) -> &mut String {
        &mut self.level_to_load
    }
    fn inclusion_options(&self) -> &String {
        &self.inclusion_options
    }
    fn inclusion_options_mut(&mut self) -> &mut String {
        &mut self.inclusion_options
    }
    fn start_point(&self) -> &String {
        &self.start_point
    }
    fn start_point_mut(&mut self) -> &mut String {
        &mut self.start_point
    }
    fn roll_credits(&self) -> &bool {
        &self.roll_credits
    }
    fn roll_credits_mut(&mut self) -> &mut bool {
        &mut self.roll_credits
    }
    fn do_persistent_save(&self) -> &bool {
        &self.do_persistent_save
    }
    fn do_persistent_save_mut(&mut self) -> &mut bool {
        &mut self.do_persistent_save
    }
    fn check_single_player_level_installed(&self) -> &bool {
        &self.check_single_player_level_installed
    }
    fn check_single_player_level_installed_mut(&mut self) -> &mut bool {
        &mut self.check_single_player_level_installed
    }
    fn force_reload_resources(&self) -> &bool {
        &self.force_reload_resources
    }
    fn force_reload_resources_mut(&mut self) -> &mut bool {
        &mut self.force_reload_resources
    }
    fn level_manager_initial_level(&self) -> &String {
        &self.level_manager_initial_level
    }
    fn level_manager_initial_level_mut(&mut self) -> &mut String {
        &mut self.level_manager_initial_level
    }
}

impl super::entity::EntityDataTrait for LevelControlEntityData {
}

impl super::entity::GameObjectDataTrait for LevelControlEntityData {
}

impl super::core::DataBusPeerTrait for LevelControlEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LevelControlEntityData {
}

impl super::core::DataContainerTrait for LevelControlEntityData {
}

pub static LEVELCONTROLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelControlEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LevelControlEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LevelToLoad",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelControlEntityData, level_to_load),
            },
            FieldInfoData {
                name: "InclusionOptions",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelControlEntityData, inclusion_options),
            },
            FieldInfoData {
                name: "StartPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelControlEntityData, start_point),
            },
            FieldInfoData {
                name: "RollCredits",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelControlEntityData, roll_credits),
            },
            FieldInfoData {
                name: "DoPersistentSave",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelControlEntityData, do_persistent_save),
            },
            FieldInfoData {
                name: "CheckSinglePlayerLevelInstalled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelControlEntityData, check_single_player_level_installed),
            },
            FieldInfoData {
                name: "ForceReloadResources",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LevelControlEntityData, force_reload_resources),
            },
            FieldInfoData {
                name: "LevelManagerInitialLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LevelControlEntityData, level_manager_initial_level),
            },
        ],
    }),
    array_type: Some(LEVELCONTROLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LevelControlEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LEVELCONTROLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LEVELCONTROLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LevelControlEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LevelControlEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectiveEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub hud_data: Option<Arc<Mutex<dyn MissionObjectiveHudDataTrait>>>,
    pub objective_type: ObjectiveType,
    pub display_time: f32,
    pub delay_time: f32,
    pub objective_sid: String,
    pub objective_brief_sid: String,
    pub success_sid: String,
    pub tutorial: bool,
    pub retrigger_success_on_show_objective: bool,
    pub reciever: MessageReciever,
    pub team_id: super::gameplay_sim::TeamId,
    pub squad_id: super::gameplay_sim::SquadId,
    pub display_success: bool,
}

pub trait ObjectiveEntityDataTrait: super::entity::EntityDataTrait {
    fn hud_data(&self) -> &Option<Arc<Mutex<dyn MissionObjectiveHudDataTrait>>>;
    fn hud_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MissionObjectiveHudDataTrait>>>;
    fn objective_type(&self) -> &ObjectiveType;
    fn objective_type_mut(&mut self) -> &mut ObjectiveType;
    fn display_time(&self) -> &f32;
    fn display_time_mut(&mut self) -> &mut f32;
    fn delay_time(&self) -> &f32;
    fn delay_time_mut(&mut self) -> &mut f32;
    fn objective_sid(&self) -> &String;
    fn objective_sid_mut(&mut self) -> &mut String;
    fn objective_brief_sid(&self) -> &String;
    fn objective_brief_sid_mut(&mut self) -> &mut String;
    fn success_sid(&self) -> &String;
    fn success_sid_mut(&mut self) -> &mut String;
    fn tutorial(&self) -> &bool;
    fn tutorial_mut(&mut self) -> &mut bool;
    fn retrigger_success_on_show_objective(&self) -> &bool;
    fn retrigger_success_on_show_objective_mut(&mut self) -> &mut bool;
    fn reciever(&self) -> &MessageReciever;
    fn reciever_mut(&mut self) -> &mut MessageReciever;
    fn team_id(&self) -> &super::gameplay_sim::TeamId;
    fn team_id_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn squad_id(&self) -> &super::gameplay_sim::SquadId;
    fn squad_id_mut(&mut self) -> &mut super::gameplay_sim::SquadId;
    fn display_success(&self) -> &bool;
    fn display_success_mut(&mut self) -> &mut bool;
}

impl ObjectiveEntityDataTrait for ObjectiveEntityData {
    fn hud_data(&self) -> &Option<Arc<Mutex<dyn MissionObjectiveHudDataTrait>>> {
        &self.hud_data
    }
    fn hud_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MissionObjectiveHudDataTrait>>> {
        &mut self.hud_data
    }
    fn objective_type(&self) -> &ObjectiveType {
        &self.objective_type
    }
    fn objective_type_mut(&mut self) -> &mut ObjectiveType {
        &mut self.objective_type
    }
    fn display_time(&self) -> &f32 {
        &self.display_time
    }
    fn display_time_mut(&mut self) -> &mut f32 {
        &mut self.display_time
    }
    fn delay_time(&self) -> &f32 {
        &self.delay_time
    }
    fn delay_time_mut(&mut self) -> &mut f32 {
        &mut self.delay_time
    }
    fn objective_sid(&self) -> &String {
        &self.objective_sid
    }
    fn objective_sid_mut(&mut self) -> &mut String {
        &mut self.objective_sid
    }
    fn objective_brief_sid(&self) -> &String {
        &self.objective_brief_sid
    }
    fn objective_brief_sid_mut(&mut self) -> &mut String {
        &mut self.objective_brief_sid
    }
    fn success_sid(&self) -> &String {
        &self.success_sid
    }
    fn success_sid_mut(&mut self) -> &mut String {
        &mut self.success_sid
    }
    fn tutorial(&self) -> &bool {
        &self.tutorial
    }
    fn tutorial_mut(&mut self) -> &mut bool {
        &mut self.tutorial
    }
    fn retrigger_success_on_show_objective(&self) -> &bool {
        &self.retrigger_success_on_show_objective
    }
    fn retrigger_success_on_show_objective_mut(&mut self) -> &mut bool {
        &mut self.retrigger_success_on_show_objective
    }
    fn reciever(&self) -> &MessageReciever {
        &self.reciever
    }
    fn reciever_mut(&mut self) -> &mut MessageReciever {
        &mut self.reciever
    }
    fn team_id(&self) -> &super::gameplay_sim::TeamId {
        &self.team_id
    }
    fn team_id_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_id
    }
    fn squad_id(&self) -> &super::gameplay_sim::SquadId {
        &self.squad_id
    }
    fn squad_id_mut(&mut self) -> &mut super::gameplay_sim::SquadId {
        &mut self.squad_id
    }
    fn display_success(&self) -> &bool {
        &self.display_success
    }
    fn display_success_mut(&mut self) -> &mut bool {
        &mut self.display_success
    }
}

impl super::entity::EntityDataTrait for ObjectiveEntityData {
}

impl super::entity::GameObjectDataTrait for ObjectiveEntityData {
}

impl super::core::DataBusPeerTrait for ObjectiveEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ObjectiveEntityData {
}

impl super::core::DataContainerTrait for ObjectiveEntityData {
}

pub static OBJECTIVEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectiveEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectiveEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HudData",
                flags: MemberInfoFlags::new(0),
                field_type: "MissionObjectiveHudData",
                rust_offset: offset_of!(ObjectiveEntityData, hud_data),
            },
            FieldInfoData {
                name: "ObjectiveType",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectiveType",
                rust_offset: offset_of!(ObjectiveEntityData, objective_type),
            },
            FieldInfoData {
                name: "DisplayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectiveEntityData, display_time),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectiveEntityData, delay_time),
            },
            FieldInfoData {
                name: "ObjectiveSid",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ObjectiveEntityData, objective_sid),
            },
            FieldInfoData {
                name: "ObjectiveBriefSid",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ObjectiveEntityData, objective_brief_sid),
            },
            FieldInfoData {
                name: "SuccessSid",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ObjectiveEntityData, success_sid),
            },
            FieldInfoData {
                name: "Tutorial",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectiveEntityData, tutorial),
            },
            FieldInfoData {
                name: "RetriggerSuccessOnShowObjective",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectiveEntityData, retrigger_success_on_show_objective),
            },
            FieldInfoData {
                name: "Reciever",
                flags: MemberInfoFlags::new(0),
                field_type: "MessageReciever",
                rust_offset: offset_of!(ObjectiveEntityData, reciever),
            },
            FieldInfoData {
                name: "TeamId",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(ObjectiveEntityData, team_id),
            },
            FieldInfoData {
                name: "SquadId",
                flags: MemberInfoFlags::new(0),
                field_type: "SquadId",
                rust_offset: offset_of!(ObjectiveEntityData, squad_id),
            },
            FieldInfoData {
                name: "DisplaySuccess",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectiveEntityData, display_success),
            },
        ],
    }),
    array_type: Some(OBJECTIVEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectiveEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTIVEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTIVEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectiveEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ObjectiveEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MessageReciever {
    #[default]
    MrAll = 0,
    MrTeam = 1,
    MrTeamAndSquad = 2,
    MrPlayer = 3,
}

pub static MESSAGERECIEVER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageReciever",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MESSAGERECIEVER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MessageReciever {
    fn type_info(&self) -> &'static TypeInfo {
        MESSAGERECIEVER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MESSAGERECIEVER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MessageReciever-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MessageReciever"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MissionObjectiveHudData {
    pub _glacier_base: super::core::DataContainer,
    pub camera_position: super::core::Vec3,
    pub camera_rotation: f32,
    pub camera_fov: f32,
    pub camera_distance: f32,
    pub camera_look_distance: f32,
    pub vertical_boundaries: super::core::Vec2,
    pub horizontal_boundaries: super::core::Vec2,
}

pub trait MissionObjectiveHudDataTrait: super::core::DataContainerTrait {
    fn camera_position(&self) -> &super::core::Vec3;
    fn camera_position_mut(&mut self) -> &mut super::core::Vec3;
    fn camera_rotation(&self) -> &f32;
    fn camera_rotation_mut(&mut self) -> &mut f32;
    fn camera_fov(&self) -> &f32;
    fn camera_fov_mut(&mut self) -> &mut f32;
    fn camera_distance(&self) -> &f32;
    fn camera_distance_mut(&mut self) -> &mut f32;
    fn camera_look_distance(&self) -> &f32;
    fn camera_look_distance_mut(&mut self) -> &mut f32;
    fn vertical_boundaries(&self) -> &super::core::Vec2;
    fn vertical_boundaries_mut(&mut self) -> &mut super::core::Vec2;
    fn horizontal_boundaries(&self) -> &super::core::Vec2;
    fn horizontal_boundaries_mut(&mut self) -> &mut super::core::Vec2;
}

impl MissionObjectiveHudDataTrait for MissionObjectiveHudData {
    fn camera_position(&self) -> &super::core::Vec3 {
        &self.camera_position
    }
    fn camera_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.camera_position
    }
    fn camera_rotation(&self) -> &f32 {
        &self.camera_rotation
    }
    fn camera_rotation_mut(&mut self) -> &mut f32 {
        &mut self.camera_rotation
    }
    fn camera_fov(&self) -> &f32 {
        &self.camera_fov
    }
    fn camera_fov_mut(&mut self) -> &mut f32 {
        &mut self.camera_fov
    }
    fn camera_distance(&self) -> &f32 {
        &self.camera_distance
    }
    fn camera_distance_mut(&mut self) -> &mut f32 {
        &mut self.camera_distance
    }
    fn camera_look_distance(&self) -> &f32 {
        &self.camera_look_distance
    }
    fn camera_look_distance_mut(&mut self) -> &mut f32 {
        &mut self.camera_look_distance
    }
    fn vertical_boundaries(&self) -> &super::core::Vec2 {
        &self.vertical_boundaries
    }
    fn vertical_boundaries_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.vertical_boundaries
    }
    fn horizontal_boundaries(&self) -> &super::core::Vec2 {
        &self.horizontal_boundaries
    }
    fn horizontal_boundaries_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.horizontal_boundaries
    }
}

impl super::core::DataContainerTrait for MissionObjectiveHudData {
}

pub static MISSIONOBJECTIVEHUDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MissionObjectiveHudData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MissionObjectiveHudData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CameraPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_position),
            },
            FieldInfoData {
                name: "CameraRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_rotation),
            },
            FieldInfoData {
                name: "CameraFov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_fov),
            },
            FieldInfoData {
                name: "CameraDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_distance),
            },
            FieldInfoData {
                name: "CameraLookDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MissionObjectiveHudData, camera_look_distance),
            },
            FieldInfoData {
                name: "VerticalBoundaries",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(MissionObjectiveHudData, vertical_boundaries),
            },
            FieldInfoData {
                name: "HorizontalBoundaries",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(MissionObjectiveHudData, horizontal_boundaries),
            },
        ],
    }),
    array_type: Some(MISSIONOBJECTIVEHUDDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MissionObjectiveHudData {
    fn type_info(&self) -> &'static TypeInfo {
        MISSIONOBJECTIVEHUDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MISSIONOBJECTIVEHUDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MissionObjectiveHudData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MissionObjectiveHudData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ObjectiveType {
    #[default]
    OTPrimary = 0,
    OTTactical = 1,
    OTChildMisson = 2,
}

pub static OBJECTIVETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectiveType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(OBJECTIVETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ObjectiveType {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTIVETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static OBJECTIVETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectiveType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ObjectiveType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FadeEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub fade_screen: bool,
    pub fade_u_i: bool,
    pub fade_audio: bool,
    pub fade_movie: bool,
    pub fade_rumble: bool,
    pub system_fade: bool,
    pub block_input: bool,
    pub fade_time: f32,
    pub max_wait_faded_while_streaming_time: f32,
    pub start_faded: bool,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait FadeEntityDataTrait: super::entity::EntityDataTrait {
    fn fade_screen(&self) -> &bool;
    fn fade_screen_mut(&mut self) -> &mut bool;
    fn fade_u_i(&self) -> &bool;
    fn fade_u_i_mut(&mut self) -> &mut bool;
    fn fade_audio(&self) -> &bool;
    fn fade_audio_mut(&mut self) -> &mut bool;
    fn fade_movie(&self) -> &bool;
    fn fade_movie_mut(&mut self) -> &mut bool;
    fn fade_rumble(&self) -> &bool;
    fn fade_rumble_mut(&mut self) -> &mut bool;
    fn system_fade(&self) -> &bool;
    fn system_fade_mut(&mut self) -> &mut bool;
    fn block_input(&self) -> &bool;
    fn block_input_mut(&mut self) -> &mut bool;
    fn fade_time(&self) -> &f32;
    fn fade_time_mut(&mut self) -> &mut f32;
    fn max_wait_faded_while_streaming_time(&self) -> &f32;
    fn max_wait_faded_while_streaming_time_mut(&mut self) -> &mut f32;
    fn start_faded(&self) -> &bool;
    fn start_faded_mut(&mut self) -> &mut bool;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl FadeEntityDataTrait for FadeEntityData {
    fn fade_screen(&self) -> &bool {
        &self.fade_screen
    }
    fn fade_screen_mut(&mut self) -> &mut bool {
        &mut self.fade_screen
    }
    fn fade_u_i(&self) -> &bool {
        &self.fade_u_i
    }
    fn fade_u_i_mut(&mut self) -> &mut bool {
        &mut self.fade_u_i
    }
    fn fade_audio(&self) -> &bool {
        &self.fade_audio
    }
    fn fade_audio_mut(&mut self) -> &mut bool {
        &mut self.fade_audio
    }
    fn fade_movie(&self) -> &bool {
        &self.fade_movie
    }
    fn fade_movie_mut(&mut self) -> &mut bool {
        &mut self.fade_movie
    }
    fn fade_rumble(&self) -> &bool {
        &self.fade_rumble
    }
    fn fade_rumble_mut(&mut self) -> &mut bool {
        &mut self.fade_rumble
    }
    fn system_fade(&self) -> &bool {
        &self.system_fade
    }
    fn system_fade_mut(&mut self) -> &mut bool {
        &mut self.system_fade
    }
    fn block_input(&self) -> &bool {
        &self.block_input
    }
    fn block_input_mut(&mut self) -> &mut bool {
        &mut self.block_input
    }
    fn fade_time(&self) -> &f32 {
        &self.fade_time
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        &mut self.fade_time
    }
    fn max_wait_faded_while_streaming_time(&self) -> &f32 {
        &self.max_wait_faded_while_streaming_time
    }
    fn max_wait_faded_while_streaming_time_mut(&mut self) -> &mut f32 {
        &mut self.max_wait_faded_while_streaming_time
    }
    fn start_faded(&self) -> &bool {
        &self.start_faded
    }
    fn start_faded_mut(&mut self) -> &mut bool {
        &mut self.start_faded
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for FadeEntityData {
}

impl super::entity::GameObjectDataTrait for FadeEntityData {
}

impl super::core::DataBusPeerTrait for FadeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FadeEntityData {
}

impl super::core::DataContainerTrait for FadeEntityData {
}

pub static FADEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FadeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FadeScreen",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_screen),
            },
            FieldInfoData {
                name: "FadeUI",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_u_i),
            },
            FieldInfoData {
                name: "FadeAudio",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_audio),
            },
            FieldInfoData {
                name: "FadeMovie",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_movie),
            },
            FieldInfoData {
                name: "FadeRumble",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, fade_rumble),
            },
            FieldInfoData {
                name: "SystemFade",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, system_fade),
            },
            FieldInfoData {
                name: "BlockInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, block_input),
            },
            FieldInfoData {
                name: "FadeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FadeEntityData, fade_time),
            },
            FieldInfoData {
                name: "MaxWaitFadedWhileStreamingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FadeEntityData, max_wait_faded_while_streaming_time),
            },
            FieldInfoData {
                name: "StartFaded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FadeEntityData, start_faded),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(FadeEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(FADEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FadeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FADEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FADEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FadeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BlinkType {
    #[default]
    BTHold = 0,
    BTBlink = 1,
    BTCount = 2,
}

pub static BLINKTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlinkType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BLINKTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BlinkType {
    fn type_info(&self) -> &'static TypeInfo {
        BLINKTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BLINKTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlinkType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BlinkType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct KillAllEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub team: super::gameplay_sim::TeamId,
    pub kill_players: KillAllPlayerEnum,
    pub damage_giving_player: i32,
}

pub trait KillAllEntityDataTrait: super::entity::EntityDataTrait {
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn kill_players(&self) -> &KillAllPlayerEnum;
    fn kill_players_mut(&mut self) -> &mut KillAllPlayerEnum;
    fn damage_giving_player(&self) -> &i32;
    fn damage_giving_player_mut(&mut self) -> &mut i32;
}

impl KillAllEntityDataTrait for KillAllEntityData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn kill_players(&self) -> &KillAllPlayerEnum {
        &self.kill_players
    }
    fn kill_players_mut(&mut self) -> &mut KillAllPlayerEnum {
        &mut self.kill_players
    }
    fn damage_giving_player(&self) -> &i32 {
        &self.damage_giving_player
    }
    fn damage_giving_player_mut(&mut self) -> &mut i32 {
        &mut self.damage_giving_player
    }
}

impl super::entity::EntityDataTrait for KillAllEntityData {
}

impl super::entity::GameObjectDataTrait for KillAllEntityData {
}

impl super::core::DataBusPeerTrait for KillAllEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for KillAllEntityData {
}

impl super::core::DataContainerTrait for KillAllEntityData {
}

pub static KILLALLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillAllEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<KillAllEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(KillAllEntityData, team),
            },
            FieldInfoData {
                name: "KillPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: "KillAllPlayerEnum",
                rust_offset: offset_of!(KillAllEntityData, kill_players),
            },
            FieldInfoData {
                name: "DamageGivingPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(KillAllEntityData, damage_giving_player),
            },
        ],
    }),
    array_type: Some(KILLALLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for KillAllEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        KILLALLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static KILLALLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillAllEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("KillAllEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum KillAllPlayerEnum {
    #[default]
    KillAllPlayer_Both = 0,
    KillAllPlayer_HumanOnly = 1,
    KillAllPlayer_AIOnly = 2,
}

pub static KILLALLPLAYERENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillAllPlayerEnum",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(KILLALLPLAYERENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for KillAllPlayerEnum {
    fn type_info(&self) -> &'static TypeInfo {
        KILLALLPLAYERENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static KILLALLPLAYERENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KillAllPlayerEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("KillAllPlayerEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaypointTriggerEntityBaseData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait WaypointTriggerEntityBaseDataTrait: super::entity::EntityDataTrait {
}

impl WaypointTriggerEntityBaseDataTrait for WaypointTriggerEntityBaseData {
}

impl super::entity::EntityDataTrait for WaypointTriggerEntityBaseData {
}

impl super::entity::GameObjectDataTrait for WaypointTriggerEntityBaseData {
}

impl super::core::DataBusPeerTrait for WaypointTriggerEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WaypointTriggerEntityBaseData {
}

impl super::core::DataContainerTrait for WaypointTriggerEntityBaseData {
}

pub static WAYPOINTTRIGGERENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointTriggerEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaypointTriggerEntityBaseData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WAYPOINTTRIGGERENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaypointTriggerEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        WAYPOINTTRIGGERENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WAYPOINTTRIGGERENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointTriggerEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WaypointTriggerEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CombatAreaTriggerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub time_to_return: u32,
    pub is_ai_allowed_outside: bool,
    pub team: super::gameplay_sim::TeamId,
    pub is_team_specific: bool,
    pub enabled: bool,
}

pub trait CombatAreaTriggerEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn time_to_return(&self) -> &u32;
    fn time_to_return_mut(&mut self) -> &mut u32;
    fn is_ai_allowed_outside(&self) -> &bool;
    fn is_ai_allowed_outside_mut(&mut self) -> &mut bool;
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn is_team_specific(&self) -> &bool;
    fn is_team_specific_mut(&mut self) -> &mut bool;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl CombatAreaTriggerEntityDataTrait for CombatAreaTriggerEntityData {
    fn time_to_return(&self) -> &u32 {
        &self.time_to_return
    }
    fn time_to_return_mut(&mut self) -> &mut u32 {
        &mut self.time_to_return
    }
    fn is_ai_allowed_outside(&self) -> &bool {
        &self.is_ai_allowed_outside
    }
    fn is_ai_allowed_outside_mut(&mut self) -> &mut bool {
        &mut self.is_ai_allowed_outside
    }
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn is_team_specific(&self) -> &bool {
        &self.is_team_specific
    }
    fn is_team_specific_mut(&mut self) -> &mut bool {
        &mut self.is_team_specific
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for CombatAreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CombatAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for CombatAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for CombatAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CombatAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for CombatAreaTriggerEntityData {
}

pub static COMBATAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatAreaTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CombatAreaTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TimeToReturn",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, time_to_return),
            },
            FieldInfoData {
                name: "IsAiAllowedOutside",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, is_ai_allowed_outside),
            },
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, team),
            },
            FieldInfoData {
                name: "IsTeamSpecific",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, is_team_specific),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CombatAreaTriggerEntityData, enabled),
            },
        ],
    }),
    array_type: Some(COMBATAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CombatAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMBATAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMBATAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatAreaTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CombatAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SurroundingGeometryEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub allowed_vehicle_list: Option<Arc<Mutex<dyn AllowedVehiclesDataTrait>>>,
    pub combat_area: Option<Arc<Mutex<dyn CombatAreaTriggerEntityDataTrait>>>,
    pub combat_area_index: u32,
    pub enabled: bool,
}

pub trait SurroundingGeometryEntityDataTrait: super::entity::EntityDataTrait {
    fn allowed_vehicle_list(&self) -> &Option<Arc<Mutex<dyn AllowedVehiclesDataTrait>>>;
    fn allowed_vehicle_list_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AllowedVehiclesDataTrait>>>;
    fn combat_area(&self) -> &Option<Arc<Mutex<dyn CombatAreaTriggerEntityDataTrait>>>;
    fn combat_area_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CombatAreaTriggerEntityDataTrait>>>;
    fn combat_area_index(&self) -> &u32;
    fn combat_area_index_mut(&mut self) -> &mut u32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl SurroundingGeometryEntityDataTrait for SurroundingGeometryEntityData {
    fn allowed_vehicle_list(&self) -> &Option<Arc<Mutex<dyn AllowedVehiclesDataTrait>>> {
        &self.allowed_vehicle_list
    }
    fn allowed_vehicle_list_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AllowedVehiclesDataTrait>>> {
        &mut self.allowed_vehicle_list
    }
    fn combat_area(&self) -> &Option<Arc<Mutex<dyn CombatAreaTriggerEntityDataTrait>>> {
        &self.combat_area
    }
    fn combat_area_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CombatAreaTriggerEntityDataTrait>>> {
        &mut self.combat_area
    }
    fn combat_area_index(&self) -> &u32 {
        &self.combat_area_index
    }
    fn combat_area_index_mut(&mut self) -> &mut u32 {
        &mut self.combat_area_index
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for SurroundingGeometryEntityData {
}

impl super::entity::GameObjectDataTrait for SurroundingGeometryEntityData {
}

impl super::core::DataBusPeerTrait for SurroundingGeometryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SurroundingGeometryEntityData {
}

impl super::core::DataContainerTrait for SurroundingGeometryEntityData {
}

pub static SURROUNDINGGEOMETRYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SurroundingGeometryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SurroundingGeometryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AllowedVehicleList",
                flags: MemberInfoFlags::new(0),
                field_type: "AllowedVehiclesData",
                rust_offset: offset_of!(SurroundingGeometryEntityData, allowed_vehicle_list),
            },
            FieldInfoData {
                name: "CombatArea",
                flags: MemberInfoFlags::new(0),
                field_type: "CombatAreaTriggerEntityData",
                rust_offset: offset_of!(SurroundingGeometryEntityData, combat_area),
            },
            FieldInfoData {
                name: "CombatAreaIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SurroundingGeometryEntityData, combat_area_index),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SurroundingGeometryEntityData, enabled),
            },
        ],
    }),
    array_type: Some(SURROUNDINGGEOMETRYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SurroundingGeometryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SURROUNDINGGEOMETRYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SURROUNDINGGEOMETRYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SurroundingGeometryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SurroundingGeometryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UICombatAreaEntityData {
    pub _glacier_base: super::entity::GameObjectData,
    pub asset: Option<Arc<Mutex<dyn UICombatAreaAssetTrait>>>,
}

pub trait UICombatAreaEntityDataTrait: super::entity::GameObjectDataTrait {
    fn asset(&self) -> &Option<Arc<Mutex<dyn UICombatAreaAssetTrait>>>;
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UICombatAreaAssetTrait>>>;
}

impl UICombatAreaEntityDataTrait for UICombatAreaEntityData {
    fn asset(&self) -> &Option<Arc<Mutex<dyn UICombatAreaAssetTrait>>> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UICombatAreaAssetTrait>>> {
        &mut self.asset
    }
}

impl super::entity::GameObjectDataTrait for UICombatAreaEntityData {
}

impl super::core::DataBusPeerTrait for UICombatAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for UICombatAreaEntityData {
}

impl super::core::DataContainerTrait for UICombatAreaEntityData {
}

pub static UICOMBATAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UICombatAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UICombatAreaEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: "UICombatAreaAsset",
                rust_offset: offset_of!(UICombatAreaEntityData, asset),
            },
        ],
    }),
    array_type: Some(UICOMBATAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UICombatAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        UICOMBATAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UICOMBATAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UICombatAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UICombatAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AllowedVehiclesData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait AllowedVehiclesDataTrait: super::core::DataContainerTrait {
}

impl AllowedVehiclesDataTrait for AllowedVehiclesData {
}

impl super::core::DataContainerTrait for AllowedVehiclesData {
}

pub static ALLOWEDVEHICLESDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AllowedVehiclesData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AllowedVehiclesData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ALLOWEDVEHICLESDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AllowedVehiclesData {
    fn type_info(&self) -> &'static TypeInfo {
        ALLOWEDVEHICLESDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ALLOWEDVEHICLESDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AllowedVehiclesData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AllowedVehiclesData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DeathAreaTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub damage: f32,
    pub time_to_return: f32,
}

pub trait DeathAreaTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn damage(&self) -> &f32;
    fn damage_mut(&mut self) -> &mut f32;
    fn time_to_return(&self) -> &f32;
    fn time_to_return_mut(&mut self) -> &mut f32;
}

impl DeathAreaTriggerEntityDataTrait for DeathAreaTriggerEntityData {
    fn damage(&self) -> &f32 {
        &self.damage
    }
    fn damage_mut(&mut self) -> &mut f32 {
        &mut self.damage
    }
    fn time_to_return(&self) -> &f32 {
        &self.time_to_return
    }
    fn time_to_return_mut(&mut self) -> &mut f32 {
        &mut self.time_to_return
    }
}

impl TriggerEntityDataTrait for DeathAreaTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DeathAreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DeathAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for DeathAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for DeathAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DeathAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for DeathAreaTriggerEntityData {
}

pub static DEATHAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeathAreaTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeathAreaTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Damage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DeathAreaTriggerEntityData, damage),
            },
            FieldInfoData {
                name: "TimeToReturn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DeathAreaTriggerEntityData, time_to_return),
            },
        ],
    }),
    array_type: Some(DEATHAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DeathAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEATHAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEATHAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeathAreaTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeathAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HumanPlayerEntityData {
    pub _glacier_base: HumanPlayerProxyEntityData,
    pub player_killed_delay: f32,
    pub post_revive_short_respawn_time: f32,
    pub max_revive_count: i32,
}

pub trait HumanPlayerEntityDataTrait: HumanPlayerProxyEntityDataTrait {
    fn player_killed_delay(&self) -> &f32;
    fn player_killed_delay_mut(&mut self) -> &mut f32;
    fn post_revive_short_respawn_time(&self) -> &f32;
    fn post_revive_short_respawn_time_mut(&mut self) -> &mut f32;
    fn max_revive_count(&self) -> &i32;
    fn max_revive_count_mut(&mut self) -> &mut i32;
}

impl HumanPlayerEntityDataTrait for HumanPlayerEntityData {
    fn player_killed_delay(&self) -> &f32 {
        &self.player_killed_delay
    }
    fn player_killed_delay_mut(&mut self) -> &mut f32 {
        &mut self.player_killed_delay
    }
    fn post_revive_short_respawn_time(&self) -> &f32 {
        &self.post_revive_short_respawn_time
    }
    fn post_revive_short_respawn_time_mut(&mut self) -> &mut f32 {
        &mut self.post_revive_short_respawn_time
    }
    fn max_revive_count(&self) -> &i32 {
        &self.max_revive_count
    }
    fn max_revive_count_mut(&mut self) -> &mut i32 {
        &mut self.max_revive_count
    }
}

impl HumanPlayerProxyEntityDataTrait for HumanPlayerEntityData {
    fn enable_on_died_on_melee_event(&self) -> &bool {
        self._glacier_base.enable_on_died_on_melee_event()
    }
    fn enable_on_died_on_melee_event_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_on_died_on_melee_event_mut()
    }
    fn enable_on_died_in_water_event(&self) -> &bool {
        self._glacier_base.enable_on_died_in_water_event()
    }
    fn enable_on_died_in_water_event_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_on_died_in_water_event_mut()
    }
}

impl super::entity::EntityDataTrait for HumanPlayerEntityData {
}

impl super::entity::GameObjectDataTrait for HumanPlayerEntityData {
}

impl super::core::DataBusPeerTrait for HumanPlayerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for HumanPlayerEntityData {
}

impl super::core::DataContainerTrait for HumanPlayerEntityData {
}

pub static HUMANPLAYERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HumanPlayerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(HUMANPLAYERPROXYENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HumanPlayerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlayerKilledDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HumanPlayerEntityData, player_killed_delay),
            },
            FieldInfoData {
                name: "PostReviveShortRespawnTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HumanPlayerEntityData, post_revive_short_respawn_time),
            },
            FieldInfoData {
                name: "MaxReviveCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(HumanPlayerEntityData, max_revive_count),
            },
        ],
    }),
    array_type: Some(HUMANPLAYERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HumanPlayerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        HUMANPLAYERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HUMANPLAYERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HumanPlayerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HumanPlayerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HumanPlayerProxyEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enable_on_died_on_melee_event: bool,
    pub enable_on_died_in_water_event: bool,
}

pub trait HumanPlayerProxyEntityDataTrait: super::entity::EntityDataTrait {
    fn enable_on_died_on_melee_event(&self) -> &bool;
    fn enable_on_died_on_melee_event_mut(&mut self) -> &mut bool;
    fn enable_on_died_in_water_event(&self) -> &bool;
    fn enable_on_died_in_water_event_mut(&mut self) -> &mut bool;
}

impl HumanPlayerProxyEntityDataTrait for HumanPlayerProxyEntityData {
    fn enable_on_died_on_melee_event(&self) -> &bool {
        &self.enable_on_died_on_melee_event
    }
    fn enable_on_died_on_melee_event_mut(&mut self) -> &mut bool {
        &mut self.enable_on_died_on_melee_event
    }
    fn enable_on_died_in_water_event(&self) -> &bool {
        &self.enable_on_died_in_water_event
    }
    fn enable_on_died_in_water_event_mut(&mut self) -> &mut bool {
        &mut self.enable_on_died_in_water_event
    }
}

impl super::entity::EntityDataTrait for HumanPlayerProxyEntityData {
}

impl super::entity::GameObjectDataTrait for HumanPlayerProxyEntityData {
}

impl super::core::DataBusPeerTrait for HumanPlayerProxyEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for HumanPlayerProxyEntityData {
}

impl super::core::DataContainerTrait for HumanPlayerProxyEntityData {
}

pub static HUMANPLAYERPROXYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HumanPlayerProxyEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HumanPlayerProxyEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnableOnDiedOnMeleeEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HumanPlayerProxyEntityData, enable_on_died_on_melee_event),
            },
            FieldInfoData {
                name: "EnableOnDiedInWaterEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HumanPlayerProxyEntityData, enable_on_died_in_water_event),
            },
        ],
    }),
    array_type: Some(HUMANPLAYERPROXYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HumanPlayerProxyEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        HUMANPLAYERPROXYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HUMANPLAYERPROXYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HumanPlayerProxyEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HumanPlayerProxyEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TeamEntityData {
    pub _glacier_base: super::gameplay_sim::GameplayTeamEntityData,
}

pub trait TeamEntityDataTrait: super::gameplay_sim::GameplayTeamEntityDataTrait {
}

impl TeamEntityDataTrait for TeamEntityData {
}

impl super::gameplay_sim::GameplayTeamEntityDataTrait for TeamEntityData {
    fn team(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameplayTeamDataTrait>>> {
        self._glacier_base.team()
    }
    fn team_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameplayTeamDataTrait>>> {
        self._glacier_base.team_mut()
    }
    fn id(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.id_mut()
    }
}

impl super::entity::EntityDataTrait for TeamEntityData {
}

impl super::entity::GameObjectDataTrait for TeamEntityData {
}

impl super::core::DataBusPeerTrait for TeamEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TeamEntityData {
}

impl super::core::DataContainerTrait for TeamEntityData {
}

pub static TEAMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPLAYTEAMENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeamEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TEAMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TeamEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TEAMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEAMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeamEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TeamData {
    pub _glacier_base: super::gameplay_sim::GameplayTeamData,
    pub soldier: Option<Arc<Mutex<dyn CharacterBlueprintTrait>>>,
    pub soldier_customization: Vec<Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>>>,
    pub vehicle_customization: Vec<Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>>,
}

pub trait TeamDataTrait: super::gameplay_sim::GameplayTeamDataTrait {
    fn soldier(&self) -> &Option<Arc<Mutex<dyn CharacterBlueprintTrait>>>;
    fn soldier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterBlueprintTrait>>>;
    fn soldier_customization(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>>>;
    fn soldier_customization_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>>>;
    fn vehicle_customization(&self) -> &Vec<Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>>;
    fn vehicle_customization_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>>;
}

impl TeamDataTrait for TeamData {
    fn soldier(&self) -> &Option<Arc<Mutex<dyn CharacterBlueprintTrait>>> {
        &self.soldier
    }
    fn soldier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterBlueprintTrait>>> {
        &mut self.soldier
    }
    fn soldier_customization(&self) -> &Vec<Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>>> {
        &self.soldier_customization
    }
    fn soldier_customization_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>>> {
        &mut self.soldier_customization
    }
    fn vehicle_customization(&self) -> &Vec<Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>> {
        &self.vehicle_customization
    }
    fn vehicle_customization_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>> {
        &mut self.vehicle_customization
    }
}

impl super::gameplay_sim::GameplayTeamDataTrait for TeamData {
    fn faction(&self) -> &super::gameplay_sim::FactionId {
        self._glacier_base.faction()
    }
    fn faction_mut(&mut self) -> &mut super::gameplay_sim::FactionId {
        self._glacier_base.faction_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for TeamData {
}

impl super::core::AssetTrait for TeamData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for TeamData {
}

pub static TEAMDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPLAYTEAMDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeamData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Soldier",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterBlueprint",
                rust_offset: offset_of!(TeamData, soldier),
            },
            FieldInfoData {
                name: "SoldierCustomization",
                flags: MemberInfoFlags::new(144),
                field_type: "CharacterCustomizationAsset-Array",
                rust_offset: offset_of!(TeamData, soldier_customization),
            },
            FieldInfoData {
                name: "VehicleCustomization",
                flags: MemberInfoFlags::new(144),
                field_type: "VehicleCustomizationAsset-Array",
                rust_offset: offset_of!(TeamData, vehicle_customization),
            },
        ],
    }),
    array_type: Some(TEAMDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TeamData {
    fn type_info(&self) -> &'static TypeInfo {
        TEAMDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEAMDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TeamData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicAvoidanceEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub repel_others: DynamicAvoidanceMode,
    pub affected_by_repelling_force: bool,
    pub predicted_by_others: bool,
    pub report_predicted_collision: DynamicAvoidanceMode,
    pub collision_radius: f32,
    pub ant_binding: AntDynamicAvoidanceBinding,
    pub realm: super::core::Realm,
}

pub trait DynamicAvoidanceEntityDataTrait: super::entity::EntityDataTrait {
    fn repel_others(&self) -> &DynamicAvoidanceMode;
    fn repel_others_mut(&mut self) -> &mut DynamicAvoidanceMode;
    fn affected_by_repelling_force(&self) -> &bool;
    fn affected_by_repelling_force_mut(&mut self) -> &mut bool;
    fn predicted_by_others(&self) -> &bool;
    fn predicted_by_others_mut(&mut self) -> &mut bool;
    fn report_predicted_collision(&self) -> &DynamicAvoidanceMode;
    fn report_predicted_collision_mut(&mut self) -> &mut DynamicAvoidanceMode;
    fn collision_radius(&self) -> &f32;
    fn collision_radius_mut(&mut self) -> &mut f32;
    fn ant_binding(&self) -> &AntDynamicAvoidanceBinding;
    fn ant_binding_mut(&mut self) -> &mut AntDynamicAvoidanceBinding;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl DynamicAvoidanceEntityDataTrait for DynamicAvoidanceEntityData {
    fn repel_others(&self) -> &DynamicAvoidanceMode {
        &self.repel_others
    }
    fn repel_others_mut(&mut self) -> &mut DynamicAvoidanceMode {
        &mut self.repel_others
    }
    fn affected_by_repelling_force(&self) -> &bool {
        &self.affected_by_repelling_force
    }
    fn affected_by_repelling_force_mut(&mut self) -> &mut bool {
        &mut self.affected_by_repelling_force
    }
    fn predicted_by_others(&self) -> &bool {
        &self.predicted_by_others
    }
    fn predicted_by_others_mut(&mut self) -> &mut bool {
        &mut self.predicted_by_others
    }
    fn report_predicted_collision(&self) -> &DynamicAvoidanceMode {
        &self.report_predicted_collision
    }
    fn report_predicted_collision_mut(&mut self) -> &mut DynamicAvoidanceMode {
        &mut self.report_predicted_collision
    }
    fn collision_radius(&self) -> &f32 {
        &self.collision_radius
    }
    fn collision_radius_mut(&mut self) -> &mut f32 {
        &mut self.collision_radius
    }
    fn ant_binding(&self) -> &AntDynamicAvoidanceBinding {
        &self.ant_binding
    }
    fn ant_binding_mut(&mut self) -> &mut AntDynamicAvoidanceBinding {
        &mut self.ant_binding
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for DynamicAvoidanceEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicAvoidanceEntityData {
}

impl super::core::DataBusPeerTrait for DynamicAvoidanceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicAvoidanceEntityData {
}

impl super::core::DataContainerTrait for DynamicAvoidanceEntityData {
}

pub static DYNAMICAVOIDANCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAvoidanceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicAvoidanceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RepelOthers",
                flags: MemberInfoFlags::new(0),
                field_type: "DynamicAvoidanceMode",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, repel_others),
            },
            FieldInfoData {
                name: "AffectedByRepellingForce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, affected_by_repelling_force),
            },
            FieldInfoData {
                name: "PredictedByOthers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, predicted_by_others),
            },
            FieldInfoData {
                name: "ReportPredictedCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "DynamicAvoidanceMode",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, report_predicted_collision),
            },
            FieldInfoData {
                name: "CollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, collision_radius),
            },
            FieldInfoData {
                name: "AntBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "AntDynamicAvoidanceBinding",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, ant_binding),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DynamicAvoidanceEntityData, realm),
            },
        ],
    }),
    array_type: Some(DYNAMICAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DynamicAvoidanceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICAVOIDANCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAvoidanceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicAvoidanceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DynamicAvoidanceMode {
    #[default]
    DynamicAvoidanceMode_Never = 0,
    DynamicAvoidanceMode_WhenScripted = 1,
    DynamicAvoidanceMode_WhenNotScripted = 2,
    DynamicAvoidanceMode_Always = 3,
}

pub static DYNAMICAVOIDANCEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAvoidanceMode",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DYNAMICAVOIDANCEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DynamicAvoidanceMode {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICAVOIDANCEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DYNAMICAVOIDANCEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicAvoidanceMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicAvoidanceMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AntDynamicAvoidanceBinding {
    pub time_until_collision: super::ant::AntRef,
    pub distance_until_collision: super::ant::AntRef,
    pub normalized_velocity: super::ant::AntRef,
    pub speed: super::ant::AntRef,
}

pub trait AntDynamicAvoidanceBindingTrait: TypeObject {
    fn time_until_collision(&self) -> &super::ant::AntRef;
    fn time_until_collision_mut(&mut self) -> &mut super::ant::AntRef;
    fn distance_until_collision(&self) -> &super::ant::AntRef;
    fn distance_until_collision_mut(&mut self) -> &mut super::ant::AntRef;
    fn normalized_velocity(&self) -> &super::ant::AntRef;
    fn normalized_velocity_mut(&mut self) -> &mut super::ant::AntRef;
    fn speed(&self) -> &super::ant::AntRef;
    fn speed_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AntDynamicAvoidanceBindingTrait for AntDynamicAvoidanceBinding {
    fn time_until_collision(&self) -> &super::ant::AntRef {
        &self.time_until_collision
    }
    fn time_until_collision_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.time_until_collision
    }
    fn distance_until_collision(&self) -> &super::ant::AntRef {
        &self.distance_until_collision
    }
    fn distance_until_collision_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.distance_until_collision
    }
    fn normalized_velocity(&self) -> &super::ant::AntRef {
        &self.normalized_velocity
    }
    fn normalized_velocity_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.normalized_velocity
    }
    fn speed(&self) -> &super::ant::AntRef {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.speed
    }
}

pub static ANTDYNAMICAVOIDANCEBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntDynamicAvoidanceBinding",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntDynamicAvoidanceBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TimeUntilCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AntDynamicAvoidanceBinding, time_until_collision),
            },
            FieldInfoData {
                name: "DistanceUntilCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AntDynamicAvoidanceBinding, distance_until_collision),
            },
            FieldInfoData {
                name: "NormalizedVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AntDynamicAvoidanceBinding, normalized_velocity),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AntDynamicAvoidanceBinding, speed),
            },
        ],
    }),
    array_type: Some(ANTDYNAMICAVOIDANCEBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AntDynamicAvoidanceBinding {
    fn type_info(&self) -> &'static TypeInfo {
        ANTDYNAMICAVOIDANCEBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTDYNAMICAVOIDANCEBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntDynamicAvoidanceBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntDynamicAvoidanceBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DriverStaticObjectComponentData {
    pub _glacier_base: DriverComponentData,
    pub acceleration: f32,
    pub deceleration: f32,
    pub turning_radius: f32,
    pub turn_while_still: bool,
    pub align_with_ground_normal: bool,
}

pub trait DriverStaticObjectComponentDataTrait: DriverComponentDataTrait {
    fn acceleration(&self) -> &f32;
    fn acceleration_mut(&mut self) -> &mut f32;
    fn deceleration(&self) -> &f32;
    fn deceleration_mut(&mut self) -> &mut f32;
    fn turning_radius(&self) -> &f32;
    fn turning_radius_mut(&mut self) -> &mut f32;
    fn turn_while_still(&self) -> &bool;
    fn turn_while_still_mut(&mut self) -> &mut bool;
    fn align_with_ground_normal(&self) -> &bool;
    fn align_with_ground_normal_mut(&mut self) -> &mut bool;
}

impl DriverStaticObjectComponentDataTrait for DriverStaticObjectComponentData {
    fn acceleration(&self) -> &f32 {
        &self.acceleration
    }
    fn acceleration_mut(&mut self) -> &mut f32 {
        &mut self.acceleration
    }
    fn deceleration(&self) -> &f32 {
        &self.deceleration
    }
    fn deceleration_mut(&mut self) -> &mut f32 {
        &mut self.deceleration
    }
    fn turning_radius(&self) -> &f32 {
        &self.turning_radius
    }
    fn turning_radius_mut(&mut self) -> &mut f32 {
        &mut self.turning_radius
    }
    fn turn_while_still(&self) -> &bool {
        &self.turn_while_still
    }
    fn turn_while_still_mut(&mut self) -> &mut bool {
        &mut self.turn_while_still
    }
    fn align_with_ground_normal(&self) -> &bool {
        &self.align_with_ground_normal
    }
    fn align_with_ground_normal_mut(&mut self) -> &mut bool {
        &mut self.align_with_ground_normal
    }
}

impl DriverComponentDataTrait for DriverStaticObjectComponentData {
    fn wanted_speed(&self) -> &f32 {
        self._glacier_base.wanted_speed()
    }
    fn wanted_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.wanted_speed_mut()
    }
    fn settings(&self) -> &Option<Arc<Mutex<dyn DriverSettingsTrait>>> {
        self._glacier_base.settings()
    }
    fn settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DriverSettingsTrait>>> {
        self._glacier_base.settings_mut()
    }
    fn control_vehicle(&self) -> &bool {
        self._glacier_base.control_vehicle()
    }
    fn control_vehicle_mut(&mut self) -> &mut bool {
        self._glacier_base.control_vehicle_mut()
    }
    fn invert_steering_on_reverse(&self) -> &bool {
        self._glacier_base.invert_steering_on_reverse()
    }
    fn invert_steering_on_reverse_mut(&mut self) -> &mut bool {
        self._glacier_base.invert_steering_on_reverse_mut()
    }
}

impl super::entity::GameComponentDataTrait for DriverStaticObjectComponentData {
}

impl super::entity::ComponentDataTrait for DriverStaticObjectComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DriverStaticObjectComponentData {
}

impl super::core::DataBusPeerTrait for DriverStaticObjectComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DriverStaticObjectComponentData {
}

impl super::core::DataContainerTrait for DriverStaticObjectComponentData {
}

pub static DRIVERSTATICOBJECTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverStaticObjectComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DRIVERCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DriverStaticObjectComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Acceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverStaticObjectComponentData, acceleration),
            },
            FieldInfoData {
                name: "Deceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverStaticObjectComponentData, deceleration),
            },
            FieldInfoData {
                name: "TurningRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverStaticObjectComponentData, turning_radius),
            },
            FieldInfoData {
                name: "TurnWhileStill",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverStaticObjectComponentData, turn_while_still),
            },
            FieldInfoData {
                name: "AlignWithGroundNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverStaticObjectComponentData, align_with_ground_normal),
            },
        ],
    }),
    array_type: Some(DRIVERSTATICOBJECTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DriverStaticObjectComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DRIVERSTATICOBJECTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DRIVERSTATICOBJECTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverStaticObjectComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DriverStaticObjectComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DriverComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub wanted_speed: f32,
    pub settings: Option<Arc<Mutex<dyn DriverSettingsTrait>>>,
    pub control_vehicle: bool,
    pub invert_steering_on_reverse: bool,
}

pub trait DriverComponentDataTrait: super::entity::GameComponentDataTrait {
    fn wanted_speed(&self) -> &f32;
    fn wanted_speed_mut(&mut self) -> &mut f32;
    fn settings(&self) -> &Option<Arc<Mutex<dyn DriverSettingsTrait>>>;
    fn settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DriverSettingsTrait>>>;
    fn control_vehicle(&self) -> &bool;
    fn control_vehicle_mut(&mut self) -> &mut bool;
    fn invert_steering_on_reverse(&self) -> &bool;
    fn invert_steering_on_reverse_mut(&mut self) -> &mut bool;
}

impl DriverComponentDataTrait for DriverComponentData {
    fn wanted_speed(&self) -> &f32 {
        &self.wanted_speed
    }
    fn wanted_speed_mut(&mut self) -> &mut f32 {
        &mut self.wanted_speed
    }
    fn settings(&self) -> &Option<Arc<Mutex<dyn DriverSettingsTrait>>> {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DriverSettingsTrait>>> {
        &mut self.settings
    }
    fn control_vehicle(&self) -> &bool {
        &self.control_vehicle
    }
    fn control_vehicle_mut(&mut self) -> &mut bool {
        &mut self.control_vehicle
    }
    fn invert_steering_on_reverse(&self) -> &bool {
        &self.invert_steering_on_reverse
    }
    fn invert_steering_on_reverse_mut(&mut self) -> &mut bool {
        &mut self.invert_steering_on_reverse
    }
}

impl super::entity::GameComponentDataTrait for DriverComponentData {
}

impl super::entity::ComponentDataTrait for DriverComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DriverComponentData {
}

impl super::core::DataBusPeerTrait for DriverComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DriverComponentData {
}

impl super::core::DataContainerTrait for DriverComponentData {
}

pub static DRIVERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DriverComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WantedSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverComponentData, wanted_speed),
            },
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(0),
                field_type: "DriverSettings",
                rust_offset: offset_of!(DriverComponentData, settings),
            },
            FieldInfoData {
                name: "ControlVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverComponentData, control_vehicle),
            },
            FieldInfoData {
                name: "InvertSteeringOnReverse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverComponentData, invert_steering_on_reverse),
            },
        ],
    }),
    array_type: Some(DRIVERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DriverComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DRIVERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DRIVERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DriverComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DriverSettings {
    pub _glacier_base: super::core::Asset,
    pub use_corridor_to_limit_dynamic_radius: bool,
    pub use_inverted_input_to_get_unstuck: bool,
    pub use_inverted_input_for_points_within_turn_radius: bool,
    pub short_probe_distance: f32,
    pub long_probe_distance: f32,
    pub align_large_angle: f32,
    pub align_small_angle: f32,
    pub min_radius: f32,
    pub radius_growth_speed: f32,
    pub stopping_deceleration: f32,
    pub steering_sensitivity: f32,
    pub regulated_steering: Option<Arc<Mutex<dyn RegulatedSteeringTrait>>>,
    pub max_brake_output: f32,
    pub min_brake_output: f32,
    pub square_brake_output: bool,
    pub look_ahead_time: f32,
    pub angle_diff_for_no_slowdown: f32,
    pub angle_diff_for_full_slowdown: f32,
    pub velocity_at_full_slowdown: f32,
    pub vel_diff_at_min_acc: f32,
    pub vel_diff_at_max_acc: f32,
    pub use_square_vel_diff_curve_acc: bool,
    pub min_acc: f32,
    pub max_acc: f32,
    pub vel_diff_at_min_dec: f32,
    pub vel_diff_at_max_dec: f32,
    pub use_square_vel_diff_curve_dec: bool,
    pub min_dec: f32,
    pub max_dec: f32,
    pub acc_diff_at_min_throttle_velocity_accelerating: f32,
    pub acc_diff_at_max_throttle_velocity_accelerating: f32,
    pub use_square_acc_diff_curve_acc: bool,
    pub min_throttle_velocity_accelerating: f32,
    pub max_throttle_velocity_accelerating: f32,
    pub acc_diff_at_min_throttle_velocity_decelerating: f32,
    pub acc_diff_at_max_throttle_velocity_decelerating: f32,
    pub use_square_acc_diff_curve_dec: bool,
    pub min_throttle_velocity_decelerating: f32,
    pub max_throttle_velocity_decelerating: f32,
    pub use_p_i_d_regulator: bool,
    pub p: f32,
    pub i: f32,
    pub d: f32,
    pub max_error: f32,
    pub max_sum_error: f32,
    pub max_p_term: f32,
    pub max_i_term: f32,
    pub max_d_term: f32,
    pub max_yaw_to_apply_sprint: f32,
    pub max_angle_diff_to_apply_sprint: f32,
    pub max_angular_velocity_to_apply_sprint: f32,
    pub min_velocity_to_apply_sprint: f32,
    pub include_y_difference: bool,
    pub look_ahead_aim_time: f32,
    pub min_look_ahead_dist: f32,
}

pub trait DriverSettingsTrait: super::core::AssetTrait {
    fn use_corridor_to_limit_dynamic_radius(&self) -> &bool;
    fn use_corridor_to_limit_dynamic_radius_mut(&mut self) -> &mut bool;
    fn use_inverted_input_to_get_unstuck(&self) -> &bool;
    fn use_inverted_input_to_get_unstuck_mut(&mut self) -> &mut bool;
    fn use_inverted_input_for_points_within_turn_radius(&self) -> &bool;
    fn use_inverted_input_for_points_within_turn_radius_mut(&mut self) -> &mut bool;
    fn short_probe_distance(&self) -> &f32;
    fn short_probe_distance_mut(&mut self) -> &mut f32;
    fn long_probe_distance(&self) -> &f32;
    fn long_probe_distance_mut(&mut self) -> &mut f32;
    fn align_large_angle(&self) -> &f32;
    fn align_large_angle_mut(&mut self) -> &mut f32;
    fn align_small_angle(&self) -> &f32;
    fn align_small_angle_mut(&mut self) -> &mut f32;
    fn min_radius(&self) -> &f32;
    fn min_radius_mut(&mut self) -> &mut f32;
    fn radius_growth_speed(&self) -> &f32;
    fn radius_growth_speed_mut(&mut self) -> &mut f32;
    fn stopping_deceleration(&self) -> &f32;
    fn stopping_deceleration_mut(&mut self) -> &mut f32;
    fn steering_sensitivity(&self) -> &f32;
    fn steering_sensitivity_mut(&mut self) -> &mut f32;
    fn regulated_steering(&self) -> &Option<Arc<Mutex<dyn RegulatedSteeringTrait>>>;
    fn regulated_steering_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RegulatedSteeringTrait>>>;
    fn max_brake_output(&self) -> &f32;
    fn max_brake_output_mut(&mut self) -> &mut f32;
    fn min_brake_output(&self) -> &f32;
    fn min_brake_output_mut(&mut self) -> &mut f32;
    fn square_brake_output(&self) -> &bool;
    fn square_brake_output_mut(&mut self) -> &mut bool;
    fn look_ahead_time(&self) -> &f32;
    fn look_ahead_time_mut(&mut self) -> &mut f32;
    fn angle_diff_for_no_slowdown(&self) -> &f32;
    fn angle_diff_for_no_slowdown_mut(&mut self) -> &mut f32;
    fn angle_diff_for_full_slowdown(&self) -> &f32;
    fn angle_diff_for_full_slowdown_mut(&mut self) -> &mut f32;
    fn velocity_at_full_slowdown(&self) -> &f32;
    fn velocity_at_full_slowdown_mut(&mut self) -> &mut f32;
    fn vel_diff_at_min_acc(&self) -> &f32;
    fn vel_diff_at_min_acc_mut(&mut self) -> &mut f32;
    fn vel_diff_at_max_acc(&self) -> &f32;
    fn vel_diff_at_max_acc_mut(&mut self) -> &mut f32;
    fn use_square_vel_diff_curve_acc(&self) -> &bool;
    fn use_square_vel_diff_curve_acc_mut(&mut self) -> &mut bool;
    fn min_acc(&self) -> &f32;
    fn min_acc_mut(&mut self) -> &mut f32;
    fn max_acc(&self) -> &f32;
    fn max_acc_mut(&mut self) -> &mut f32;
    fn vel_diff_at_min_dec(&self) -> &f32;
    fn vel_diff_at_min_dec_mut(&mut self) -> &mut f32;
    fn vel_diff_at_max_dec(&self) -> &f32;
    fn vel_diff_at_max_dec_mut(&mut self) -> &mut f32;
    fn use_square_vel_diff_curve_dec(&self) -> &bool;
    fn use_square_vel_diff_curve_dec_mut(&mut self) -> &mut bool;
    fn min_dec(&self) -> &f32;
    fn min_dec_mut(&mut self) -> &mut f32;
    fn max_dec(&self) -> &f32;
    fn max_dec_mut(&mut self) -> &mut f32;
    fn acc_diff_at_min_throttle_velocity_accelerating(&self) -> &f32;
    fn acc_diff_at_min_throttle_velocity_accelerating_mut(&mut self) -> &mut f32;
    fn acc_diff_at_max_throttle_velocity_accelerating(&self) -> &f32;
    fn acc_diff_at_max_throttle_velocity_accelerating_mut(&mut self) -> &mut f32;
    fn use_square_acc_diff_curve_acc(&self) -> &bool;
    fn use_square_acc_diff_curve_acc_mut(&mut self) -> &mut bool;
    fn min_throttle_velocity_accelerating(&self) -> &f32;
    fn min_throttle_velocity_accelerating_mut(&mut self) -> &mut f32;
    fn max_throttle_velocity_accelerating(&self) -> &f32;
    fn max_throttle_velocity_accelerating_mut(&mut self) -> &mut f32;
    fn acc_diff_at_min_throttle_velocity_decelerating(&self) -> &f32;
    fn acc_diff_at_min_throttle_velocity_decelerating_mut(&mut self) -> &mut f32;
    fn acc_diff_at_max_throttle_velocity_decelerating(&self) -> &f32;
    fn acc_diff_at_max_throttle_velocity_decelerating_mut(&mut self) -> &mut f32;
    fn use_square_acc_diff_curve_dec(&self) -> &bool;
    fn use_square_acc_diff_curve_dec_mut(&mut self) -> &mut bool;
    fn min_throttle_velocity_decelerating(&self) -> &f32;
    fn min_throttle_velocity_decelerating_mut(&mut self) -> &mut f32;
    fn max_throttle_velocity_decelerating(&self) -> &f32;
    fn max_throttle_velocity_decelerating_mut(&mut self) -> &mut f32;
    fn use_p_i_d_regulator(&self) -> &bool;
    fn use_p_i_d_regulator_mut(&mut self) -> &mut bool;
    fn p(&self) -> &f32;
    fn p_mut(&mut self) -> &mut f32;
    fn i(&self) -> &f32;
    fn i_mut(&mut self) -> &mut f32;
    fn d(&self) -> &f32;
    fn d_mut(&mut self) -> &mut f32;
    fn max_error(&self) -> &f32;
    fn max_error_mut(&mut self) -> &mut f32;
    fn max_sum_error(&self) -> &f32;
    fn max_sum_error_mut(&mut self) -> &mut f32;
    fn max_p_term(&self) -> &f32;
    fn max_p_term_mut(&mut self) -> &mut f32;
    fn max_i_term(&self) -> &f32;
    fn max_i_term_mut(&mut self) -> &mut f32;
    fn max_d_term(&self) -> &f32;
    fn max_d_term_mut(&mut self) -> &mut f32;
    fn max_yaw_to_apply_sprint(&self) -> &f32;
    fn max_yaw_to_apply_sprint_mut(&mut self) -> &mut f32;
    fn max_angle_diff_to_apply_sprint(&self) -> &f32;
    fn max_angle_diff_to_apply_sprint_mut(&mut self) -> &mut f32;
    fn max_angular_velocity_to_apply_sprint(&self) -> &f32;
    fn max_angular_velocity_to_apply_sprint_mut(&mut self) -> &mut f32;
    fn min_velocity_to_apply_sprint(&self) -> &f32;
    fn min_velocity_to_apply_sprint_mut(&mut self) -> &mut f32;
    fn include_y_difference(&self) -> &bool;
    fn include_y_difference_mut(&mut self) -> &mut bool;
    fn look_ahead_aim_time(&self) -> &f32;
    fn look_ahead_aim_time_mut(&mut self) -> &mut f32;
    fn min_look_ahead_dist(&self) -> &f32;
    fn min_look_ahead_dist_mut(&mut self) -> &mut f32;
}

impl DriverSettingsTrait for DriverSettings {
    fn use_corridor_to_limit_dynamic_radius(&self) -> &bool {
        &self.use_corridor_to_limit_dynamic_radius
    }
    fn use_corridor_to_limit_dynamic_radius_mut(&mut self) -> &mut bool {
        &mut self.use_corridor_to_limit_dynamic_radius
    }
    fn use_inverted_input_to_get_unstuck(&self) -> &bool {
        &self.use_inverted_input_to_get_unstuck
    }
    fn use_inverted_input_to_get_unstuck_mut(&mut self) -> &mut bool {
        &mut self.use_inverted_input_to_get_unstuck
    }
    fn use_inverted_input_for_points_within_turn_radius(&self) -> &bool {
        &self.use_inverted_input_for_points_within_turn_radius
    }
    fn use_inverted_input_for_points_within_turn_radius_mut(&mut self) -> &mut bool {
        &mut self.use_inverted_input_for_points_within_turn_radius
    }
    fn short_probe_distance(&self) -> &f32 {
        &self.short_probe_distance
    }
    fn short_probe_distance_mut(&mut self) -> &mut f32 {
        &mut self.short_probe_distance
    }
    fn long_probe_distance(&self) -> &f32 {
        &self.long_probe_distance
    }
    fn long_probe_distance_mut(&mut self) -> &mut f32 {
        &mut self.long_probe_distance
    }
    fn align_large_angle(&self) -> &f32 {
        &self.align_large_angle
    }
    fn align_large_angle_mut(&mut self) -> &mut f32 {
        &mut self.align_large_angle
    }
    fn align_small_angle(&self) -> &f32 {
        &self.align_small_angle
    }
    fn align_small_angle_mut(&mut self) -> &mut f32 {
        &mut self.align_small_angle
    }
    fn min_radius(&self) -> &f32 {
        &self.min_radius
    }
    fn min_radius_mut(&mut self) -> &mut f32 {
        &mut self.min_radius
    }
    fn radius_growth_speed(&self) -> &f32 {
        &self.radius_growth_speed
    }
    fn radius_growth_speed_mut(&mut self) -> &mut f32 {
        &mut self.radius_growth_speed
    }
    fn stopping_deceleration(&self) -> &f32 {
        &self.stopping_deceleration
    }
    fn stopping_deceleration_mut(&mut self) -> &mut f32 {
        &mut self.stopping_deceleration
    }
    fn steering_sensitivity(&self) -> &f32 {
        &self.steering_sensitivity
    }
    fn steering_sensitivity_mut(&mut self) -> &mut f32 {
        &mut self.steering_sensitivity
    }
    fn regulated_steering(&self) -> &Option<Arc<Mutex<dyn RegulatedSteeringTrait>>> {
        &self.regulated_steering
    }
    fn regulated_steering_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RegulatedSteeringTrait>>> {
        &mut self.regulated_steering
    }
    fn max_brake_output(&self) -> &f32 {
        &self.max_brake_output
    }
    fn max_brake_output_mut(&mut self) -> &mut f32 {
        &mut self.max_brake_output
    }
    fn min_brake_output(&self) -> &f32 {
        &self.min_brake_output
    }
    fn min_brake_output_mut(&mut self) -> &mut f32 {
        &mut self.min_brake_output
    }
    fn square_brake_output(&self) -> &bool {
        &self.square_brake_output
    }
    fn square_brake_output_mut(&mut self) -> &mut bool {
        &mut self.square_brake_output
    }
    fn look_ahead_time(&self) -> &f32 {
        &self.look_ahead_time
    }
    fn look_ahead_time_mut(&mut self) -> &mut f32 {
        &mut self.look_ahead_time
    }
    fn angle_diff_for_no_slowdown(&self) -> &f32 {
        &self.angle_diff_for_no_slowdown
    }
    fn angle_diff_for_no_slowdown_mut(&mut self) -> &mut f32 {
        &mut self.angle_diff_for_no_slowdown
    }
    fn angle_diff_for_full_slowdown(&self) -> &f32 {
        &self.angle_diff_for_full_slowdown
    }
    fn angle_diff_for_full_slowdown_mut(&mut self) -> &mut f32 {
        &mut self.angle_diff_for_full_slowdown
    }
    fn velocity_at_full_slowdown(&self) -> &f32 {
        &self.velocity_at_full_slowdown
    }
    fn velocity_at_full_slowdown_mut(&mut self) -> &mut f32 {
        &mut self.velocity_at_full_slowdown
    }
    fn vel_diff_at_min_acc(&self) -> &f32 {
        &self.vel_diff_at_min_acc
    }
    fn vel_diff_at_min_acc_mut(&mut self) -> &mut f32 {
        &mut self.vel_diff_at_min_acc
    }
    fn vel_diff_at_max_acc(&self) -> &f32 {
        &self.vel_diff_at_max_acc
    }
    fn vel_diff_at_max_acc_mut(&mut self) -> &mut f32 {
        &mut self.vel_diff_at_max_acc
    }
    fn use_square_vel_diff_curve_acc(&self) -> &bool {
        &self.use_square_vel_diff_curve_acc
    }
    fn use_square_vel_diff_curve_acc_mut(&mut self) -> &mut bool {
        &mut self.use_square_vel_diff_curve_acc
    }
    fn min_acc(&self) -> &f32 {
        &self.min_acc
    }
    fn min_acc_mut(&mut self) -> &mut f32 {
        &mut self.min_acc
    }
    fn max_acc(&self) -> &f32 {
        &self.max_acc
    }
    fn max_acc_mut(&mut self) -> &mut f32 {
        &mut self.max_acc
    }
    fn vel_diff_at_min_dec(&self) -> &f32 {
        &self.vel_diff_at_min_dec
    }
    fn vel_diff_at_min_dec_mut(&mut self) -> &mut f32 {
        &mut self.vel_diff_at_min_dec
    }
    fn vel_diff_at_max_dec(&self) -> &f32 {
        &self.vel_diff_at_max_dec
    }
    fn vel_diff_at_max_dec_mut(&mut self) -> &mut f32 {
        &mut self.vel_diff_at_max_dec
    }
    fn use_square_vel_diff_curve_dec(&self) -> &bool {
        &self.use_square_vel_diff_curve_dec
    }
    fn use_square_vel_diff_curve_dec_mut(&mut self) -> &mut bool {
        &mut self.use_square_vel_diff_curve_dec
    }
    fn min_dec(&self) -> &f32 {
        &self.min_dec
    }
    fn min_dec_mut(&mut self) -> &mut f32 {
        &mut self.min_dec
    }
    fn max_dec(&self) -> &f32 {
        &self.max_dec
    }
    fn max_dec_mut(&mut self) -> &mut f32 {
        &mut self.max_dec
    }
    fn acc_diff_at_min_throttle_velocity_accelerating(&self) -> &f32 {
        &self.acc_diff_at_min_throttle_velocity_accelerating
    }
    fn acc_diff_at_min_throttle_velocity_accelerating_mut(&mut self) -> &mut f32 {
        &mut self.acc_diff_at_min_throttle_velocity_accelerating
    }
    fn acc_diff_at_max_throttle_velocity_accelerating(&self) -> &f32 {
        &self.acc_diff_at_max_throttle_velocity_accelerating
    }
    fn acc_diff_at_max_throttle_velocity_accelerating_mut(&mut self) -> &mut f32 {
        &mut self.acc_diff_at_max_throttle_velocity_accelerating
    }
    fn use_square_acc_diff_curve_acc(&self) -> &bool {
        &self.use_square_acc_diff_curve_acc
    }
    fn use_square_acc_diff_curve_acc_mut(&mut self) -> &mut bool {
        &mut self.use_square_acc_diff_curve_acc
    }
    fn min_throttle_velocity_accelerating(&self) -> &f32 {
        &self.min_throttle_velocity_accelerating
    }
    fn min_throttle_velocity_accelerating_mut(&mut self) -> &mut f32 {
        &mut self.min_throttle_velocity_accelerating
    }
    fn max_throttle_velocity_accelerating(&self) -> &f32 {
        &self.max_throttle_velocity_accelerating
    }
    fn max_throttle_velocity_accelerating_mut(&mut self) -> &mut f32 {
        &mut self.max_throttle_velocity_accelerating
    }
    fn acc_diff_at_min_throttle_velocity_decelerating(&self) -> &f32 {
        &self.acc_diff_at_min_throttle_velocity_decelerating
    }
    fn acc_diff_at_min_throttle_velocity_decelerating_mut(&mut self) -> &mut f32 {
        &mut self.acc_diff_at_min_throttle_velocity_decelerating
    }
    fn acc_diff_at_max_throttle_velocity_decelerating(&self) -> &f32 {
        &self.acc_diff_at_max_throttle_velocity_decelerating
    }
    fn acc_diff_at_max_throttle_velocity_decelerating_mut(&mut self) -> &mut f32 {
        &mut self.acc_diff_at_max_throttle_velocity_decelerating
    }
    fn use_square_acc_diff_curve_dec(&self) -> &bool {
        &self.use_square_acc_diff_curve_dec
    }
    fn use_square_acc_diff_curve_dec_mut(&mut self) -> &mut bool {
        &mut self.use_square_acc_diff_curve_dec
    }
    fn min_throttle_velocity_decelerating(&self) -> &f32 {
        &self.min_throttle_velocity_decelerating
    }
    fn min_throttle_velocity_decelerating_mut(&mut self) -> &mut f32 {
        &mut self.min_throttle_velocity_decelerating
    }
    fn max_throttle_velocity_decelerating(&self) -> &f32 {
        &self.max_throttle_velocity_decelerating
    }
    fn max_throttle_velocity_decelerating_mut(&mut self) -> &mut f32 {
        &mut self.max_throttle_velocity_decelerating
    }
    fn use_p_i_d_regulator(&self) -> &bool {
        &self.use_p_i_d_regulator
    }
    fn use_p_i_d_regulator_mut(&mut self) -> &mut bool {
        &mut self.use_p_i_d_regulator
    }
    fn p(&self) -> &f32 {
        &self.p
    }
    fn p_mut(&mut self) -> &mut f32 {
        &mut self.p
    }
    fn i(&self) -> &f32 {
        &self.i
    }
    fn i_mut(&mut self) -> &mut f32 {
        &mut self.i
    }
    fn d(&self) -> &f32 {
        &self.d
    }
    fn d_mut(&mut self) -> &mut f32 {
        &mut self.d
    }
    fn max_error(&self) -> &f32 {
        &self.max_error
    }
    fn max_error_mut(&mut self) -> &mut f32 {
        &mut self.max_error
    }
    fn max_sum_error(&self) -> &f32 {
        &self.max_sum_error
    }
    fn max_sum_error_mut(&mut self) -> &mut f32 {
        &mut self.max_sum_error
    }
    fn max_p_term(&self) -> &f32 {
        &self.max_p_term
    }
    fn max_p_term_mut(&mut self) -> &mut f32 {
        &mut self.max_p_term
    }
    fn max_i_term(&self) -> &f32 {
        &self.max_i_term
    }
    fn max_i_term_mut(&mut self) -> &mut f32 {
        &mut self.max_i_term
    }
    fn max_d_term(&self) -> &f32 {
        &self.max_d_term
    }
    fn max_d_term_mut(&mut self) -> &mut f32 {
        &mut self.max_d_term
    }
    fn max_yaw_to_apply_sprint(&self) -> &f32 {
        &self.max_yaw_to_apply_sprint
    }
    fn max_yaw_to_apply_sprint_mut(&mut self) -> &mut f32 {
        &mut self.max_yaw_to_apply_sprint
    }
    fn max_angle_diff_to_apply_sprint(&self) -> &f32 {
        &self.max_angle_diff_to_apply_sprint
    }
    fn max_angle_diff_to_apply_sprint_mut(&mut self) -> &mut f32 {
        &mut self.max_angle_diff_to_apply_sprint
    }
    fn max_angular_velocity_to_apply_sprint(&self) -> &f32 {
        &self.max_angular_velocity_to_apply_sprint
    }
    fn max_angular_velocity_to_apply_sprint_mut(&mut self) -> &mut f32 {
        &mut self.max_angular_velocity_to_apply_sprint
    }
    fn min_velocity_to_apply_sprint(&self) -> &f32 {
        &self.min_velocity_to_apply_sprint
    }
    fn min_velocity_to_apply_sprint_mut(&mut self) -> &mut f32 {
        &mut self.min_velocity_to_apply_sprint
    }
    fn include_y_difference(&self) -> &bool {
        &self.include_y_difference
    }
    fn include_y_difference_mut(&mut self) -> &mut bool {
        &mut self.include_y_difference
    }
    fn look_ahead_aim_time(&self) -> &f32 {
        &self.look_ahead_aim_time
    }
    fn look_ahead_aim_time_mut(&mut self) -> &mut f32 {
        &mut self.look_ahead_aim_time
    }
    fn min_look_ahead_dist(&self) -> &f32 {
        &self.min_look_ahead_dist
    }
    fn min_look_ahead_dist_mut(&mut self) -> &mut f32 {
        &mut self.min_look_ahead_dist
    }
}

impl super::core::AssetTrait for DriverSettings {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for DriverSettings {
}

pub static DRIVERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverSettings",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DriverSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseCorridorToLimitDynamicRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_corridor_to_limit_dynamic_radius),
            },
            FieldInfoData {
                name: "UseInvertedInputToGetUnstuck",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_inverted_input_to_get_unstuck),
            },
            FieldInfoData {
                name: "UseInvertedInputForPointsWithinTurnRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_inverted_input_for_points_within_turn_radius),
            },
            FieldInfoData {
                name: "ShortProbeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, short_probe_distance),
            },
            FieldInfoData {
                name: "LongProbeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, long_probe_distance),
            },
            FieldInfoData {
                name: "AlignLargeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, align_large_angle),
            },
            FieldInfoData {
                name: "AlignSmallAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, align_small_angle),
            },
            FieldInfoData {
                name: "MinRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_radius),
            },
            FieldInfoData {
                name: "RadiusGrowthSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, radius_growth_speed),
            },
            FieldInfoData {
                name: "StoppingDeceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, stopping_deceleration),
            },
            FieldInfoData {
                name: "SteeringSensitivity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, steering_sensitivity),
            },
            FieldInfoData {
                name: "RegulatedSteering",
                flags: MemberInfoFlags::new(0),
                field_type: "RegulatedSteering",
                rust_offset: offset_of!(DriverSettings, regulated_steering),
            },
            FieldInfoData {
                name: "MaxBrakeOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_brake_output),
            },
            FieldInfoData {
                name: "MinBrakeOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_brake_output),
            },
            FieldInfoData {
                name: "SquareBrakeOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, square_brake_output),
            },
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, look_ahead_time),
            },
            FieldInfoData {
                name: "AngleDiffForNoSlowdown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, angle_diff_for_no_slowdown),
            },
            FieldInfoData {
                name: "AngleDiffForFullSlowdown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, angle_diff_for_full_slowdown),
            },
            FieldInfoData {
                name: "VelocityAtFullSlowdown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, velocity_at_full_slowdown),
            },
            FieldInfoData {
                name: "VelDiffAtMinAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, vel_diff_at_min_acc),
            },
            FieldInfoData {
                name: "VelDiffAtMaxAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, vel_diff_at_max_acc),
            },
            FieldInfoData {
                name: "UseSquareVelDiffCurveAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_square_vel_diff_curve_acc),
            },
            FieldInfoData {
                name: "MinAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_acc),
            },
            FieldInfoData {
                name: "MaxAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_acc),
            },
            FieldInfoData {
                name: "VelDiffAtMinDec",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, vel_diff_at_min_dec),
            },
            FieldInfoData {
                name: "VelDiffAtMaxDec",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, vel_diff_at_max_dec),
            },
            FieldInfoData {
                name: "UseSquareVelDiffCurveDec",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_square_vel_diff_curve_dec),
            },
            FieldInfoData {
                name: "MinDec",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_dec),
            },
            FieldInfoData {
                name: "MaxDec",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_dec),
            },
            FieldInfoData {
                name: "AccDiffAtMinThrottleVelocityAccelerating",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, acc_diff_at_min_throttle_velocity_accelerating),
            },
            FieldInfoData {
                name: "AccDiffAtMaxThrottleVelocityAccelerating",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, acc_diff_at_max_throttle_velocity_accelerating),
            },
            FieldInfoData {
                name: "UseSquareAccDiffCurveAcc",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_square_acc_diff_curve_acc),
            },
            FieldInfoData {
                name: "MinThrottleVelocityAccelerating",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_throttle_velocity_accelerating),
            },
            FieldInfoData {
                name: "MaxThrottleVelocityAccelerating",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_throttle_velocity_accelerating),
            },
            FieldInfoData {
                name: "AccDiffAtMinThrottleVelocityDecelerating",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, acc_diff_at_min_throttle_velocity_decelerating),
            },
            FieldInfoData {
                name: "AccDiffAtMaxThrottleVelocityDecelerating",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, acc_diff_at_max_throttle_velocity_decelerating),
            },
            FieldInfoData {
                name: "UseSquareAccDiffCurveDec",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_square_acc_diff_curve_dec),
            },
            FieldInfoData {
                name: "MinThrottleVelocityDecelerating",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_throttle_velocity_decelerating),
            },
            FieldInfoData {
                name: "MaxThrottleVelocityDecelerating",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_throttle_velocity_decelerating),
            },
            FieldInfoData {
                name: "UsePIDRegulator",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, use_p_i_d_regulator),
            },
            FieldInfoData {
                name: "P",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, p),
            },
            FieldInfoData {
                name: "I",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, i),
            },
            FieldInfoData {
                name: "D",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, d),
            },
            FieldInfoData {
                name: "MaxError",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_error),
            },
            FieldInfoData {
                name: "MaxSumError",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_sum_error),
            },
            FieldInfoData {
                name: "MaxPTerm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_p_term),
            },
            FieldInfoData {
                name: "MaxITerm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_i_term),
            },
            FieldInfoData {
                name: "MaxDTerm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_d_term),
            },
            FieldInfoData {
                name: "MaxYawToApplySprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_yaw_to_apply_sprint),
            },
            FieldInfoData {
                name: "MaxAngleDiffToApplySprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_angle_diff_to_apply_sprint),
            },
            FieldInfoData {
                name: "MaxAngularVelocityToApplySprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, max_angular_velocity_to_apply_sprint),
            },
            FieldInfoData {
                name: "MinVelocityToApplySprint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_velocity_to_apply_sprint),
            },
            FieldInfoData {
                name: "IncludeYDifference",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DriverSettings, include_y_difference),
            },
            FieldInfoData {
                name: "LookAheadAimTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, look_ahead_aim_time),
            },
            FieldInfoData {
                name: "MinLookAheadDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DriverSettings, min_look_ahead_dist),
            },
        ],
    }),
    array_type: Some(DRIVERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DriverSettings {
    fn type_info(&self) -> &'static TypeInfo {
        DRIVERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DRIVERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DriverSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DriverSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RegulatedSteering {
    pub _glacier_base: super::core::DataContainer,
    pub p_i_d: PID,
}

pub trait RegulatedSteeringTrait: super::core::DataContainerTrait {
    fn p_i_d(&self) -> &PID;
    fn p_i_d_mut(&mut self) -> &mut PID;
}

impl RegulatedSteeringTrait for RegulatedSteering {
    fn p_i_d(&self) -> &PID {
        &self.p_i_d
    }
    fn p_i_d_mut(&mut self) -> &mut PID {
        &mut self.p_i_d
    }
}

impl super::core::DataContainerTrait for RegulatedSteering {
}

pub static REGULATEDSTEERING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RegulatedSteering",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RegulatedSteering as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PID",
                flags: MemberInfoFlags::new(0),
                field_type: "PID",
                rust_offset: offset_of!(RegulatedSteering, p_i_d),
            },
        ],
    }),
    array_type: Some(REGULATEDSTEERING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RegulatedSteering {
    fn type_info(&self) -> &'static TypeInfo {
        REGULATEDSTEERING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REGULATEDSTEERING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RegulatedSteering-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RegulatedSteering"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PID {
    pub p: f32,
    pub i: f32,
    pub d: f32,
    pub max_error: f32,
    pub max_p_term: f32,
    pub max_i_term: f32,
    pub max_d_term: f32,
    pub max_sum_error: f32,
}

pub trait PIDTrait: TypeObject {
    fn p(&self) -> &f32;
    fn p_mut(&mut self) -> &mut f32;
    fn i(&self) -> &f32;
    fn i_mut(&mut self) -> &mut f32;
    fn d(&self) -> &f32;
    fn d_mut(&mut self) -> &mut f32;
    fn max_error(&self) -> &f32;
    fn max_error_mut(&mut self) -> &mut f32;
    fn max_p_term(&self) -> &f32;
    fn max_p_term_mut(&mut self) -> &mut f32;
    fn max_i_term(&self) -> &f32;
    fn max_i_term_mut(&mut self) -> &mut f32;
    fn max_d_term(&self) -> &f32;
    fn max_d_term_mut(&mut self) -> &mut f32;
    fn max_sum_error(&self) -> &f32;
    fn max_sum_error_mut(&mut self) -> &mut f32;
}

impl PIDTrait for PID {
    fn p(&self) -> &f32 {
        &self.p
    }
    fn p_mut(&mut self) -> &mut f32 {
        &mut self.p
    }
    fn i(&self) -> &f32 {
        &self.i
    }
    fn i_mut(&mut self) -> &mut f32 {
        &mut self.i
    }
    fn d(&self) -> &f32 {
        &self.d
    }
    fn d_mut(&mut self) -> &mut f32 {
        &mut self.d
    }
    fn max_error(&self) -> &f32 {
        &self.max_error
    }
    fn max_error_mut(&mut self) -> &mut f32 {
        &mut self.max_error
    }
    fn max_p_term(&self) -> &f32 {
        &self.max_p_term
    }
    fn max_p_term_mut(&mut self) -> &mut f32 {
        &mut self.max_p_term
    }
    fn max_i_term(&self) -> &f32 {
        &self.max_i_term
    }
    fn max_i_term_mut(&mut self) -> &mut f32 {
        &mut self.max_i_term
    }
    fn max_d_term(&self) -> &f32 {
        &self.max_d_term
    }
    fn max_d_term_mut(&mut self) -> &mut f32 {
        &mut self.max_d_term
    }
    fn max_sum_error(&self) -> &f32 {
        &self.max_sum_error
    }
    fn max_sum_error_mut(&mut self) -> &mut f32 {
        &mut self.max_sum_error
    }
}

pub static PID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PID",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PID as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "P",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, p),
            },
            FieldInfoData {
                name: "I",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, i),
            },
            FieldInfoData {
                name: "D",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, d),
            },
            FieldInfoData {
                name: "MaxError",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_error),
            },
            FieldInfoData {
                name: "MaxPTerm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_p_term),
            },
            FieldInfoData {
                name: "MaxITerm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_i_term),
            },
            FieldInfoData {
                name: "MaxDTerm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_d_term),
            },
            FieldInfoData {
                name: "MaxSumError",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PID, max_sum_error),
            },
        ],
    }),
    array_type: Some(PID_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PID {
    fn type_info(&self) -> &'static TypeInfo {
        PID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PID-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PID"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DifficultyIndexEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait DifficultyIndexEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl DifficultyIndexEntityDataTrait for DifficultyIndexEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for DifficultyIndexEntityData {
}

impl super::entity::GameObjectDataTrait for DifficultyIndexEntityData {
}

impl super::core::DataBusPeerTrait for DifficultyIndexEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DifficultyIndexEntityData {
}

impl super::core::DataContainerTrait for DifficultyIndexEntityData {
}

pub static DIFFICULTYINDEXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyIndexEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DifficultyIndexEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DifficultyIndexEntityData, realm),
            },
        ],
    }),
    array_type: Some(DIFFICULTYINDEXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DifficultyIndexEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DIFFICULTYINDEXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIFFICULTYINDEXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyIndexEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DifficultyIndexEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DifficultyDatas {
    pub _glacier_base: super::gameplay_sim::DifficultyDatasBase,
    pub difficulties: Vec<Option<Arc<Mutex<dyn DifficultyDataTrait>>>>,
}

pub trait DifficultyDatasTrait: super::gameplay_sim::DifficultyDatasBaseTrait {
    fn difficulties(&self) -> &Vec<Option<Arc<Mutex<dyn DifficultyDataTrait>>>>;
    fn difficulties_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DifficultyDataTrait>>>>;
}

impl DifficultyDatasTrait for DifficultyDatas {
    fn difficulties(&self) -> &Vec<Option<Arc<Mutex<dyn DifficultyDataTrait>>>> {
        &self.difficulties
    }
    fn difficulties_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DifficultyDataTrait>>>> {
        &mut self.difficulties
    }
}

impl super::gameplay_sim::DifficultyDatasBaseTrait for DifficultyDatas {
}

impl super::core::AssetTrait for DifficultyDatas {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for DifficultyDatas {
}

pub static DIFFICULTYDATAS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyDatas",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::DIFFICULTYDATASBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DifficultyDatas as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Difficulties",
                flags: MemberInfoFlags::new(144),
                field_type: "DifficultyData-Array",
                rust_offset: offset_of!(DifficultyDatas, difficulties),
            },
        ],
    }),
    array_type: Some(DIFFICULTYDATAS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DifficultyDatas {
    fn type_info(&self) -> &'static TypeInfo {
        DIFFICULTYDATAS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIFFICULTYDATAS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyDatas-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DifficultyDatas"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DifficultyData {
    pub _glacier_base: super::core::DataContainer,
    pub difficulty: Difficulty,
    pub game_type: PersistenceGameType,
    pub readable_name: String,
    pub human_health_modifier: f32,
    pub friends_health_modifier: f32,
    pub enemies_health_modifier: f32,
    pub friendly_damage_modifier: f32,
    pub vehicle_damage_modifier: f32,
    pub human_in_critical_health: f32,
    pub human_in_critical_health_damage_modifier: f32,
    pub human_regeneration_rate_modifier: f32,
    pub critical_fake_immortal_modifier: f32,
    pub interactive_man_down_damage_modifier: f32,
    pub interactive_man_down_time_multiplier: f32,
    pub interactive_man_down_revive_time: f32,
    pub adrenaline_kill_limit: i32,
    pub attract_distance_fall_off_modifier: super::core::Vec2,
    pub attract_soft_zone_modifier: f32,
    pub attract_user_input_multiplier_modifier: f32,
    pub sticky_box_modifier: super::core::Vec3,
    pub snap_zoom_post_time_no_input_modifier: f32,
    pub snap_zoom_post_time_modifier: f32,
    pub snap_box_modifier: super::core::Vec3,
    pub suck_zoom_modifier: f32,
    pub use_pitch_zoom_snap: bool,
    pub ai_bullet_damage_human_cooldown: f32,
    pub a_i_data: Option<Arc<Mutex<dyn GameAIDifficultyDataTrait>>>,
}

pub trait DifficultyDataTrait: super::core::DataContainerTrait {
    fn difficulty(&self) -> &Difficulty;
    fn difficulty_mut(&mut self) -> &mut Difficulty;
    fn game_type(&self) -> &PersistenceGameType;
    fn game_type_mut(&mut self) -> &mut PersistenceGameType;
    fn readable_name(&self) -> &String;
    fn readable_name_mut(&mut self) -> &mut String;
    fn human_health_modifier(&self) -> &f32;
    fn human_health_modifier_mut(&mut self) -> &mut f32;
    fn friends_health_modifier(&self) -> &f32;
    fn friends_health_modifier_mut(&mut self) -> &mut f32;
    fn enemies_health_modifier(&self) -> &f32;
    fn enemies_health_modifier_mut(&mut self) -> &mut f32;
    fn friendly_damage_modifier(&self) -> &f32;
    fn friendly_damage_modifier_mut(&mut self) -> &mut f32;
    fn vehicle_damage_modifier(&self) -> &f32;
    fn vehicle_damage_modifier_mut(&mut self) -> &mut f32;
    fn human_in_critical_health(&self) -> &f32;
    fn human_in_critical_health_mut(&mut self) -> &mut f32;
    fn human_in_critical_health_damage_modifier(&self) -> &f32;
    fn human_in_critical_health_damage_modifier_mut(&mut self) -> &mut f32;
    fn human_regeneration_rate_modifier(&self) -> &f32;
    fn human_regeneration_rate_modifier_mut(&mut self) -> &mut f32;
    fn critical_fake_immortal_modifier(&self) -> &f32;
    fn critical_fake_immortal_modifier_mut(&mut self) -> &mut f32;
    fn interactive_man_down_damage_modifier(&self) -> &f32;
    fn interactive_man_down_damage_modifier_mut(&mut self) -> &mut f32;
    fn interactive_man_down_time_multiplier(&self) -> &f32;
    fn interactive_man_down_time_multiplier_mut(&mut self) -> &mut f32;
    fn interactive_man_down_revive_time(&self) -> &f32;
    fn interactive_man_down_revive_time_mut(&mut self) -> &mut f32;
    fn adrenaline_kill_limit(&self) -> &i32;
    fn adrenaline_kill_limit_mut(&mut self) -> &mut i32;
    fn attract_distance_fall_off_modifier(&self) -> &super::core::Vec2;
    fn attract_distance_fall_off_modifier_mut(&mut self) -> &mut super::core::Vec2;
    fn attract_soft_zone_modifier(&self) -> &f32;
    fn attract_soft_zone_modifier_mut(&mut self) -> &mut f32;
    fn attract_user_input_multiplier_modifier(&self) -> &f32;
    fn attract_user_input_multiplier_modifier_mut(&mut self) -> &mut f32;
    fn sticky_box_modifier(&self) -> &super::core::Vec3;
    fn sticky_box_modifier_mut(&mut self) -> &mut super::core::Vec3;
    fn snap_zoom_post_time_no_input_modifier(&self) -> &f32;
    fn snap_zoom_post_time_no_input_modifier_mut(&mut self) -> &mut f32;
    fn snap_zoom_post_time_modifier(&self) -> &f32;
    fn snap_zoom_post_time_modifier_mut(&mut self) -> &mut f32;
    fn snap_box_modifier(&self) -> &super::core::Vec3;
    fn snap_box_modifier_mut(&mut self) -> &mut super::core::Vec3;
    fn suck_zoom_modifier(&self) -> &f32;
    fn suck_zoom_modifier_mut(&mut self) -> &mut f32;
    fn use_pitch_zoom_snap(&self) -> &bool;
    fn use_pitch_zoom_snap_mut(&mut self) -> &mut bool;
    fn ai_bullet_damage_human_cooldown(&self) -> &f32;
    fn ai_bullet_damage_human_cooldown_mut(&mut self) -> &mut f32;
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn GameAIDifficultyDataTrait>>>;
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GameAIDifficultyDataTrait>>>;
}

impl DifficultyDataTrait for DifficultyData {
    fn difficulty(&self) -> &Difficulty {
        &self.difficulty
    }
    fn difficulty_mut(&mut self) -> &mut Difficulty {
        &mut self.difficulty
    }
    fn game_type(&self) -> &PersistenceGameType {
        &self.game_type
    }
    fn game_type_mut(&mut self) -> &mut PersistenceGameType {
        &mut self.game_type
    }
    fn readable_name(&self) -> &String {
        &self.readable_name
    }
    fn readable_name_mut(&mut self) -> &mut String {
        &mut self.readable_name
    }
    fn human_health_modifier(&self) -> &f32 {
        &self.human_health_modifier
    }
    fn human_health_modifier_mut(&mut self) -> &mut f32 {
        &mut self.human_health_modifier
    }
    fn friends_health_modifier(&self) -> &f32 {
        &self.friends_health_modifier
    }
    fn friends_health_modifier_mut(&mut self) -> &mut f32 {
        &mut self.friends_health_modifier
    }
    fn enemies_health_modifier(&self) -> &f32 {
        &self.enemies_health_modifier
    }
    fn enemies_health_modifier_mut(&mut self) -> &mut f32 {
        &mut self.enemies_health_modifier
    }
    fn friendly_damage_modifier(&self) -> &f32 {
        &self.friendly_damage_modifier
    }
    fn friendly_damage_modifier_mut(&mut self) -> &mut f32 {
        &mut self.friendly_damage_modifier
    }
    fn vehicle_damage_modifier(&self) -> &f32 {
        &self.vehicle_damage_modifier
    }
    fn vehicle_damage_modifier_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_damage_modifier
    }
    fn human_in_critical_health(&self) -> &f32 {
        &self.human_in_critical_health
    }
    fn human_in_critical_health_mut(&mut self) -> &mut f32 {
        &mut self.human_in_critical_health
    }
    fn human_in_critical_health_damage_modifier(&self) -> &f32 {
        &self.human_in_critical_health_damage_modifier
    }
    fn human_in_critical_health_damage_modifier_mut(&mut self) -> &mut f32 {
        &mut self.human_in_critical_health_damage_modifier
    }
    fn human_regeneration_rate_modifier(&self) -> &f32 {
        &self.human_regeneration_rate_modifier
    }
    fn human_regeneration_rate_modifier_mut(&mut self) -> &mut f32 {
        &mut self.human_regeneration_rate_modifier
    }
    fn critical_fake_immortal_modifier(&self) -> &f32 {
        &self.critical_fake_immortal_modifier
    }
    fn critical_fake_immortal_modifier_mut(&mut self) -> &mut f32 {
        &mut self.critical_fake_immortal_modifier
    }
    fn interactive_man_down_damage_modifier(&self) -> &f32 {
        &self.interactive_man_down_damage_modifier
    }
    fn interactive_man_down_damage_modifier_mut(&mut self) -> &mut f32 {
        &mut self.interactive_man_down_damage_modifier
    }
    fn interactive_man_down_time_multiplier(&self) -> &f32 {
        &self.interactive_man_down_time_multiplier
    }
    fn interactive_man_down_time_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.interactive_man_down_time_multiplier
    }
    fn interactive_man_down_revive_time(&self) -> &f32 {
        &self.interactive_man_down_revive_time
    }
    fn interactive_man_down_revive_time_mut(&mut self) -> &mut f32 {
        &mut self.interactive_man_down_revive_time
    }
    fn adrenaline_kill_limit(&self) -> &i32 {
        &self.adrenaline_kill_limit
    }
    fn adrenaline_kill_limit_mut(&mut self) -> &mut i32 {
        &mut self.adrenaline_kill_limit
    }
    fn attract_distance_fall_off_modifier(&self) -> &super::core::Vec2 {
        &self.attract_distance_fall_off_modifier
    }
    fn attract_distance_fall_off_modifier_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.attract_distance_fall_off_modifier
    }
    fn attract_soft_zone_modifier(&self) -> &f32 {
        &self.attract_soft_zone_modifier
    }
    fn attract_soft_zone_modifier_mut(&mut self) -> &mut f32 {
        &mut self.attract_soft_zone_modifier
    }
    fn attract_user_input_multiplier_modifier(&self) -> &f32 {
        &self.attract_user_input_multiplier_modifier
    }
    fn attract_user_input_multiplier_modifier_mut(&mut self) -> &mut f32 {
        &mut self.attract_user_input_multiplier_modifier
    }
    fn sticky_box_modifier(&self) -> &super::core::Vec3 {
        &self.sticky_box_modifier
    }
    fn sticky_box_modifier_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sticky_box_modifier
    }
    fn snap_zoom_post_time_no_input_modifier(&self) -> &f32 {
        &self.snap_zoom_post_time_no_input_modifier
    }
    fn snap_zoom_post_time_no_input_modifier_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_post_time_no_input_modifier
    }
    fn snap_zoom_post_time_modifier(&self) -> &f32 {
        &self.snap_zoom_post_time_modifier
    }
    fn snap_zoom_post_time_modifier_mut(&mut self) -> &mut f32 {
        &mut self.snap_zoom_post_time_modifier
    }
    fn snap_box_modifier(&self) -> &super::core::Vec3 {
        &self.snap_box_modifier
    }
    fn snap_box_modifier_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.snap_box_modifier
    }
    fn suck_zoom_modifier(&self) -> &f32 {
        &self.suck_zoom_modifier
    }
    fn suck_zoom_modifier_mut(&mut self) -> &mut f32 {
        &mut self.suck_zoom_modifier
    }
    fn use_pitch_zoom_snap(&self) -> &bool {
        &self.use_pitch_zoom_snap
    }
    fn use_pitch_zoom_snap_mut(&mut self) -> &mut bool {
        &mut self.use_pitch_zoom_snap
    }
    fn ai_bullet_damage_human_cooldown(&self) -> &f32 {
        &self.ai_bullet_damage_human_cooldown
    }
    fn ai_bullet_damage_human_cooldown_mut(&mut self) -> &mut f32 {
        &mut self.ai_bullet_damage_human_cooldown
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn GameAIDifficultyDataTrait>>> {
        &self.a_i_data
    }
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GameAIDifficultyDataTrait>>> {
        &mut self.a_i_data
    }
}

impl super::core::DataContainerTrait for DifficultyData {
}

pub static DIFFICULTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DifficultyData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Difficulty",
                flags: MemberInfoFlags::new(0),
                field_type: "Difficulty",
                rust_offset: offset_of!(DifficultyData, difficulty),
            },
            FieldInfoData {
                name: "GameType",
                flags: MemberInfoFlags::new(0),
                field_type: "PersistenceGameType",
                rust_offset: offset_of!(DifficultyData, game_type),
            },
            FieldInfoData {
                name: "ReadableName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DifficultyData, readable_name),
            },
            FieldInfoData {
                name: "HumanHealthModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, human_health_modifier),
            },
            FieldInfoData {
                name: "FriendsHealthModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, friends_health_modifier),
            },
            FieldInfoData {
                name: "EnemiesHealthModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, enemies_health_modifier),
            },
            FieldInfoData {
                name: "FriendlyDamageModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, friendly_damage_modifier),
            },
            FieldInfoData {
                name: "VehicleDamageModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, vehicle_damage_modifier),
            },
            FieldInfoData {
                name: "HumanInCriticalHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, human_in_critical_health),
            },
            FieldInfoData {
                name: "HumanInCriticalHealthDamageModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, human_in_critical_health_damage_modifier),
            },
            FieldInfoData {
                name: "HumanRegenerationRateModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, human_regeneration_rate_modifier),
            },
            FieldInfoData {
                name: "CriticalFakeImmortalModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, critical_fake_immortal_modifier),
            },
            FieldInfoData {
                name: "InteractiveManDownDamageModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, interactive_man_down_damage_modifier),
            },
            FieldInfoData {
                name: "InteractiveManDownTimeMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, interactive_man_down_time_multiplier),
            },
            FieldInfoData {
                name: "InteractiveManDownReviveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, interactive_man_down_revive_time),
            },
            FieldInfoData {
                name: "AdrenalineKillLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DifficultyData, adrenaline_kill_limit),
            },
            FieldInfoData {
                name: "AttractDistanceFallOffModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(DifficultyData, attract_distance_fall_off_modifier),
            },
            FieldInfoData {
                name: "AttractSoftZoneModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, attract_soft_zone_modifier),
            },
            FieldInfoData {
                name: "AttractUserInputMultiplierModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, attract_user_input_multiplier_modifier),
            },
            FieldInfoData {
                name: "StickyBoxModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DifficultyData, sticky_box_modifier),
            },
            FieldInfoData {
                name: "SnapZoomPostTimeNoInputModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, snap_zoom_post_time_no_input_modifier),
            },
            FieldInfoData {
                name: "SnapZoomPostTimeModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, snap_zoom_post_time_modifier),
            },
            FieldInfoData {
                name: "SnapBoxModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DifficultyData, snap_box_modifier),
            },
            FieldInfoData {
                name: "SuckZoomModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, suck_zoom_modifier),
            },
            FieldInfoData {
                name: "UsePitchZoomSnap",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DifficultyData, use_pitch_zoom_snap),
            },
            FieldInfoData {
                name: "AiBulletDamageHumanCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DifficultyData, ai_bullet_damage_human_cooldown),
            },
            FieldInfoData {
                name: "AIData",
                flags: MemberInfoFlags::new(0),
                field_type: "GameAIDifficultyData",
                rust_offset: offset_of!(DifficultyData, a_i_data),
            },
        ],
    }),
    array_type: Some(DIFFICULTYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DifficultyData {
    fn type_info(&self) -> &'static TypeInfo {
        DIFFICULTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIFFICULTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DifficultyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DifficultyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum Difficulty {
    #[default]
    Difficulty_Easy = 0,
    Difficulty_Medium = 1,
    Difficulty_Hard = 2,
    Difficulty_Hardcore = 3,
    Difficulty_None = 4,
}

pub static DIFFICULTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Difficulty",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DIFFICULTY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Difficulty {
    fn type_info(&self) -> &'static TypeInfo {
        DIFFICULTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DIFFICULTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Difficulty-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("Difficulty"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameAIDifficultyData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait GameAIDifficultyDataTrait: super::core::DataContainerTrait {
}

impl GameAIDifficultyDataTrait for GameAIDifficultyData {
}

impl super::core::DataContainerTrait for GameAIDifficultyData {
}

pub static GAMEAIDIFFICULTYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameAIDifficultyData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameAIDifficultyData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMEAIDIFFICULTYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameAIDifficultyData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEAIDIFFICULTYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEAIDIFFICULTYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameAIDifficultyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameAIDifficultyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetworkedUnlock {
    pub networked_compartment_id: u16,
    pub unlock_id: u32,
}

pub trait NetworkedUnlockTrait: TypeObject {
    fn networked_compartment_id(&self) -> &u16;
    fn networked_compartment_id_mut(&mut self) -> &mut u16;
    fn unlock_id(&self) -> &u32;
    fn unlock_id_mut(&mut self) -> &mut u32;
}

impl NetworkedUnlockTrait for NetworkedUnlock {
    fn networked_compartment_id(&self) -> &u16 {
        &self.networked_compartment_id
    }
    fn networked_compartment_id_mut(&mut self) -> &mut u16 {
        &mut self.networked_compartment_id
    }
    fn unlock_id(&self) -> &u32 {
        &self.unlock_id
    }
    fn unlock_id_mut(&mut self) -> &mut u32 {
        &mut self.unlock_id
    }
}

pub static NETWORKEDUNLOCK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedUnlock",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkedUnlock as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NetworkedCompartmentId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(NetworkedUnlock, networked_compartment_id),
            },
            FieldInfoData {
                name: "UnlockId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(NetworkedUnlock, unlock_id),
            },
        ],
    }),
    array_type: Some(NETWORKEDUNLOCK_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for NetworkedUnlock {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKEDUNLOCK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NETWORKEDUNLOCK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkedUnlock-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("NetworkedUnlock"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomizeCharacterData {
    pub _glacier_base: super::core::Asset,
    pub restore_to_original_visual_state: bool,
    pub clear_visual_state: bool,
    pub visual_groups: Vec<CustomizeVisual>,
    pub unlocks: Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>>,
    pub override_max_health: f32,
    pub override_critical_health_threshold: f32,
}

pub trait CustomizeCharacterDataTrait: super::core::AssetTrait {
    fn restore_to_original_visual_state(&self) -> &bool;
    fn restore_to_original_visual_state_mut(&mut self) -> &mut bool;
    fn clear_visual_state(&self) -> &bool;
    fn clear_visual_state_mut(&mut self) -> &mut bool;
    fn visual_groups(&self) -> &Vec<CustomizeVisual>;
    fn visual_groups_mut(&mut self) -> &mut Vec<CustomizeVisual>;
    fn unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>>;
    fn unlocks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>>;
    fn override_max_health(&self) -> &f32;
    fn override_max_health_mut(&mut self) -> &mut f32;
    fn override_critical_health_threshold(&self) -> &f32;
    fn override_critical_health_threshold_mut(&mut self) -> &mut f32;
}

impl CustomizeCharacterDataTrait for CustomizeCharacterData {
    fn restore_to_original_visual_state(&self) -> &bool {
        &self.restore_to_original_visual_state
    }
    fn restore_to_original_visual_state_mut(&mut self) -> &mut bool {
        &mut self.restore_to_original_visual_state
    }
    fn clear_visual_state(&self) -> &bool {
        &self.clear_visual_state
    }
    fn clear_visual_state_mut(&mut self) -> &mut bool {
        &mut self.clear_visual_state
    }
    fn visual_groups(&self) -> &Vec<CustomizeVisual> {
        &self.visual_groups
    }
    fn visual_groups_mut(&mut self) -> &mut Vec<CustomizeVisual> {
        &mut self.visual_groups
    }
    fn unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>> {
        &self.unlocks
    }
    fn unlocks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>> {
        &mut self.unlocks
    }
    fn override_max_health(&self) -> &f32 {
        &self.override_max_health
    }
    fn override_max_health_mut(&mut self) -> &mut f32 {
        &mut self.override_max_health
    }
    fn override_critical_health_threshold(&self) -> &f32 {
        &self.override_critical_health_threshold
    }
    fn override_critical_health_threshold_mut(&mut self) -> &mut f32 {
        &mut self.override_critical_health_threshold
    }
}

impl super::core::AssetTrait for CustomizeCharacterData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CustomizeCharacterData {
}

pub static CUSTOMIZECHARACTERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeCharacterData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeCharacterData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RestoreToOriginalVisualState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CustomizeCharacterData, restore_to_original_visual_state),
            },
            FieldInfoData {
                name: "ClearVisualState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CustomizeCharacterData, clear_visual_state),
            },
            FieldInfoData {
                name: "VisualGroups",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomizeVisual-Array",
                rust_offset: offset_of!(CustomizeCharacterData, visual_groups),
            },
            FieldInfoData {
                name: "Unlocks",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(CustomizeCharacterData, unlocks),
            },
            FieldInfoData {
                name: "OverrideMaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CustomizeCharacterData, override_max_health),
            },
            FieldInfoData {
                name: "OverrideCriticalHealthThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CustomizeCharacterData, override_critical_health_threshold),
            },
        ],
    }),
    array_type: Some(CUSTOMIZECHARACTERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizeCharacterData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZECHARACTERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZECHARACTERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeCharacterData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizeCharacterData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomizeVisual {
    pub visual: Vec<Option<Arc<Mutex<dyn UnlockAssetTrait>>>>,
}

pub trait CustomizeVisualTrait: TypeObject {
    fn visual(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockAssetTrait>>>>;
    fn visual_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockAssetTrait>>>>;
}

impl CustomizeVisualTrait for CustomizeVisual {
    fn visual(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockAssetTrait>>>> {
        &self.visual
    }
    fn visual_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockAssetTrait>>>> {
        &mut self.visual
    }
}

pub static CUSTOMIZEVISUAL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeVisual",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizeVisual as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Visual",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAsset-Array",
                rust_offset: offset_of!(CustomizeVisual, visual),
            },
        ],
    }),
    array_type: Some(CUSTOMIZEVISUAL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizeVisual {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZEVISUAL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUSTOMIZEVISUAL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizeVisual-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizeVisual"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetworkPlayerSelectedUnlockAssetsMessage {
}

pub trait NetworkPlayerSelectedUnlockAssetsMessageTrait: TypeObject {
}

impl NetworkPlayerSelectedUnlockAssetsMessageTrait for NetworkPlayerSelectedUnlockAssetsMessage {
}

pub static NETWORKPLAYERSELECTEDUNLOCKASSETSMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetworkPlayerSelectedUnlockAssetsMessage",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetworkPlayerSelectedUnlockAssetsMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for NetworkPlayerSelectedUnlockAssetsMessage {
    fn type_info(&self) -> &'static TypeInfo {
        NETWORKPLAYERSELECTEDUNLOCKASSETSMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct CamoUnlockSelection {
    pub category: i32,
    pub asset: Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>,
}

pub trait CamoUnlockSelectionTrait: TypeObject {
    fn category(&self) -> &i32;
    fn category_mut(&mut self) -> &mut i32;
    fn asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
}

impl CamoUnlockSelectionTrait for CamoUnlockSelection {
    fn category(&self) -> &i32 {
        &self.category
    }
    fn category_mut(&mut self) -> &mut i32 {
        &mut self.category
    }
    fn asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &mut self.asset
    }
}

pub static CAMOUNLOCKSELECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CamoUnlockSelection",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CamoUnlockSelection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Category",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CamoUnlockSelection, category),
            },
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(CamoUnlockSelection, asset),
            },
        ],
    }),
    array_type: Some(CAMOUNLOCKSELECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CamoUnlockSelection {
    fn type_info(&self) -> &'static TypeInfo {
        CAMOUNLOCKSELECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMOUNLOCKSELECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CamoUnlockSelection-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CamoUnlockSelection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleCustomizationAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub visual_table: Option<Arc<Mutex<dyn CustomizationTableTrait>>>,
    pub customization: Option<Arc<Mutex<dyn CustomizationTableTrait>>>,
}

pub trait VehicleCustomizationAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn visual_table(&self) -> &Option<Arc<Mutex<dyn CustomizationTableTrait>>>;
    fn visual_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizationTableTrait>>>;
    fn customization(&self) -> &Option<Arc<Mutex<dyn CustomizationTableTrait>>>;
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizationTableTrait>>>;
}

impl VehicleCustomizationAssetTrait for VehicleCustomizationAsset {
    fn visual_table(&self) -> &Option<Arc<Mutex<dyn CustomizationTableTrait>>> {
        &self.visual_table
    }
    fn visual_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizationTableTrait>>> {
        &mut self.visual_table
    }
    fn customization(&self) -> &Option<Arc<Mutex<dyn CustomizationTableTrait>>> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizationTableTrait>>> {
        &mut self.customization
    }
}

impl super::core::DataContainerPolicyAssetTrait for VehicleCustomizationAsset {
}

impl super::core::AssetTrait for VehicleCustomizationAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VehicleCustomizationAsset {
}

pub static VEHICLECUSTOMIZATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCustomizationAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleCustomizationAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VisualTable",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(VehicleCustomizationAsset, visual_table),
            },
            FieldInfoData {
                name: "Customization",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(VehicleCustomizationAsset, customization),
            },
        ],
    }),
    array_type: Some(VEHICLECUSTOMIZATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleCustomizationAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECUSTOMIZATIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLECUSTOMIZATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCustomizationAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleCustomizationAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterCustomizationAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub label_sid: String,
    pub visual_table: Option<Arc<Mutex<dyn CustomizationTableTrait>>>,
    pub specialization_table: Option<Arc<Mutex<dyn CustomizationTableTrait>>>,
}

pub trait CharacterCustomizationAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn label_sid(&self) -> &String;
    fn label_sid_mut(&mut self) -> &mut String;
    fn visual_table(&self) -> &Option<Arc<Mutex<dyn CustomizationTableTrait>>>;
    fn visual_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizationTableTrait>>>;
    fn specialization_table(&self) -> &Option<Arc<Mutex<dyn CustomizationTableTrait>>>;
    fn specialization_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizationTableTrait>>>;
}

impl CharacterCustomizationAssetTrait for CharacterCustomizationAsset {
    fn label_sid(&self) -> &String {
        &self.label_sid
    }
    fn label_sid_mut(&mut self) -> &mut String {
        &mut self.label_sid
    }
    fn visual_table(&self) -> &Option<Arc<Mutex<dyn CustomizationTableTrait>>> {
        &self.visual_table
    }
    fn visual_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizationTableTrait>>> {
        &mut self.visual_table
    }
    fn specialization_table(&self) -> &Option<Arc<Mutex<dyn CustomizationTableTrait>>> {
        &self.specialization_table
    }
    fn specialization_table_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizationTableTrait>>> {
        &mut self.specialization_table
    }
}

impl super::core::DataContainerPolicyAssetTrait for CharacterCustomizationAsset {
}

impl super::core::AssetTrait for CharacterCustomizationAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterCustomizationAsset {
}

pub static CHARACTERCUSTOMIZATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCustomizationAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterCustomizationAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LabelSid",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CharacterCustomizationAsset, label_sid),
            },
            FieldInfoData {
                name: "VisualTable",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(CharacterCustomizationAsset, visual_table),
            },
            FieldInfoData {
                name: "SpecializationTable",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizationTable",
                rust_offset: offset_of!(CharacterCustomizationAsset, specialization_table),
            },
        ],
    }),
    array_type: Some(CHARACTERCUSTOMIZATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterCustomizationAsset {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERCUSTOMIZATIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERCUSTOMIZATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCustomizationAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterCustomizationAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomizationUnlockParts {
    pub _glacier_base: super::core::DataContainer,
    pub u_i_category_sid: String,
    pub default_selection_index: u32,
    pub selectable_unlocks: Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>>,
}

pub trait CustomizationUnlockPartsTrait: super::core::DataContainerTrait {
    fn u_i_category_sid(&self) -> &String;
    fn u_i_category_sid_mut(&mut self) -> &mut String;
    fn default_selection_index(&self) -> &u32;
    fn default_selection_index_mut(&mut self) -> &mut u32;
    fn selectable_unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>>;
    fn selectable_unlocks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>>;
}

impl CustomizationUnlockPartsTrait for CustomizationUnlockParts {
    fn u_i_category_sid(&self) -> &String {
        &self.u_i_category_sid
    }
    fn u_i_category_sid_mut(&mut self) -> &mut String {
        &mut self.u_i_category_sid
    }
    fn default_selection_index(&self) -> &u32 {
        &self.default_selection_index
    }
    fn default_selection_index_mut(&mut self) -> &mut u32 {
        &mut self.default_selection_index
    }
    fn selectable_unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>> {
        &self.selectable_unlocks
    }
    fn selectable_unlocks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>> {
        &mut self.selectable_unlocks
    }
}

impl super::core::DataContainerTrait for CustomizationUnlockParts {
}

pub static CUSTOMIZATIONUNLOCKPARTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationUnlockParts",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizationUnlockParts as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UICategorySid",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CustomizationUnlockParts, u_i_category_sid),
            },
            FieldInfoData {
                name: "DefaultSelectionIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CustomizationUnlockParts, default_selection_index),
            },
            FieldInfoData {
                name: "SelectableUnlocks",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(CustomizationUnlockParts, selectable_unlocks),
            },
        ],
    }),
    array_type: Some(CUSTOMIZATIONUNLOCKPARTS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizationUnlockParts {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZATIONUNLOCKPARTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZATIONUNLOCKPARTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationUnlockParts-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizationUnlockParts"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomizationTable {
    pub _glacier_base: super::core::DataContainer,
    pub unlock_parts: Vec<Option<Arc<Mutex<dyn CustomizationUnlockPartsTrait>>>>,
}

pub trait CustomizationTableTrait: super::core::DataContainerTrait {
    fn unlock_parts(&self) -> &Vec<Option<Arc<Mutex<dyn CustomizationUnlockPartsTrait>>>>;
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CustomizationUnlockPartsTrait>>>>;
}

impl CustomizationTableTrait for CustomizationTable {
    fn unlock_parts(&self) -> &Vec<Option<Arc<Mutex<dyn CustomizationUnlockPartsTrait>>>> {
        &self.unlock_parts
    }
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CustomizationUnlockPartsTrait>>>> {
        &mut self.unlock_parts
    }
}

impl super::core::DataContainerTrait for CustomizationTable {
}

pub static CUSTOMIZATIONTABLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationTable",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizationTable as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockParts",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomizationUnlockParts-Array",
                rust_offset: offset_of!(CustomizationTable, unlock_parts),
            },
        ],
    }),
    array_type: Some(CUSTOMIZATIONTABLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizationTable {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZATIONTABLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CUSTOMIZATIONTABLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationTable-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizationTable"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleVisualCustomizationAsset {
    pub _glacier_base: super::core::Asset,
    pub texture_unlock_part_collections: Vec<Option<Arc<Mutex<dyn ShaderTextureUnlockPartCollectionTrait>>>>,
    pub text_unlock_parts: Vec<Option<Arc<Mutex<dyn TextUnlockPartDataTrait>>>>,
}

pub trait VehicleVisualCustomizationAssetTrait: super::core::AssetTrait {
    fn texture_unlock_part_collections(&self) -> &Vec<Option<Arc<Mutex<dyn ShaderTextureUnlockPartCollectionTrait>>>>;
    fn texture_unlock_part_collections_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ShaderTextureUnlockPartCollectionTrait>>>>;
    fn text_unlock_parts(&self) -> &Vec<Option<Arc<Mutex<dyn TextUnlockPartDataTrait>>>>;
    fn text_unlock_parts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TextUnlockPartDataTrait>>>>;
}

impl VehicleVisualCustomizationAssetTrait for VehicleVisualCustomizationAsset {
    fn texture_unlock_part_collections(&self) -> &Vec<Option<Arc<Mutex<dyn ShaderTextureUnlockPartCollectionTrait>>>> {
        &self.texture_unlock_part_collections
    }
    fn texture_unlock_part_collections_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ShaderTextureUnlockPartCollectionTrait>>>> {
        &mut self.texture_unlock_part_collections
    }
    fn text_unlock_parts(&self) -> &Vec<Option<Arc<Mutex<dyn TextUnlockPartDataTrait>>>> {
        &self.text_unlock_parts
    }
    fn text_unlock_parts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TextUnlockPartDataTrait>>>> {
        &mut self.text_unlock_parts
    }
}

impl super::core::AssetTrait for VehicleVisualCustomizationAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VehicleVisualCustomizationAsset {
}

pub static VEHICLEVISUALCUSTOMIZATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVisualCustomizationAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleVisualCustomizationAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TextureUnlockPartCollections",
                flags: MemberInfoFlags::new(144),
                field_type: "ShaderTextureUnlockPartCollection-Array",
                rust_offset: offset_of!(VehicleVisualCustomizationAsset, texture_unlock_part_collections),
            },
            FieldInfoData {
                name: "TextUnlockParts",
                flags: MemberInfoFlags::new(144),
                field_type: "TextUnlockPartData-Array",
                rust_offset: offset_of!(VehicleVisualCustomizationAsset, text_unlock_parts),
            },
        ],
    }),
    array_type: Some(VEHICLEVISUALCUSTOMIZATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleVisualCustomizationAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEVISUALCUSTOMIZATIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEVISUALCUSTOMIZATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVisualCustomizationAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleVisualCustomizationAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TextUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub shader_node_name: String,
    pub mesh_blueprint: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
}

pub trait TextUnlockPartDataTrait: super::core::DataContainerTrait {
    fn shader_node_name(&self) -> &String;
    fn shader_node_name_mut(&mut self) -> &mut String;
    fn mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
}

impl TextUnlockPartDataTrait for TextUnlockPartData {
    fn shader_node_name(&self) -> &String {
        &self.shader_node_name
    }
    fn shader_node_name_mut(&mut self) -> &mut String {
        &mut self.shader_node_name
    }
    fn mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.mesh_blueprint
    }
    fn mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.mesh_blueprint
    }
}

impl super::core::DataContainerTrait for TextUnlockPartData {
}

pub static TEXTUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextUnlockPartData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextUnlockPartData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ShaderNodeName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TextUnlockPartData, shader_node_name),
            },
            FieldInfoData {
                name: "MeshBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(TextUnlockPartData, mesh_blueprint),
            },
        ],
    }),
    array_type: Some(TEXTUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextUnlockPartData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShaderTextureUnlockPartCollection {
    pub _glacier_base: ShaderCustomizationUnlockPartCollection,
    pub default_texture_reference: Option<Arc<Mutex<dyn TextureReferenceTrait>>>,
    pub unlock_parts: Vec<Option<Arc<Mutex<dyn TextureUnlockPartDataTrait>>>>,
}

pub trait ShaderTextureUnlockPartCollectionTrait: ShaderCustomizationUnlockPartCollectionTrait {
    fn default_texture_reference(&self) -> &Option<Arc<Mutex<dyn TextureReferenceTrait>>>;
    fn default_texture_reference_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TextureReferenceTrait>>>;
    fn unlock_parts(&self) -> &Vec<Option<Arc<Mutex<dyn TextureUnlockPartDataTrait>>>>;
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TextureUnlockPartDataTrait>>>>;
}

impl ShaderTextureUnlockPartCollectionTrait for ShaderTextureUnlockPartCollection {
    fn default_texture_reference(&self) -> &Option<Arc<Mutex<dyn TextureReferenceTrait>>> {
        &self.default_texture_reference
    }
    fn default_texture_reference_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TextureReferenceTrait>>> {
        &mut self.default_texture_reference
    }
    fn unlock_parts(&self) -> &Vec<Option<Arc<Mutex<dyn TextureUnlockPartDataTrait>>>> {
        &self.unlock_parts
    }
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TextureUnlockPartDataTrait>>>> {
        &mut self.unlock_parts
    }
}

impl ShaderCustomizationUnlockPartCollectionTrait for ShaderTextureUnlockPartCollection {
    fn mesh_blueprints(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>> {
        self._glacier_base.mesh_blueprints()
    }
    fn mesh_blueprints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>> {
        self._glacier_base.mesh_blueprints_mut()
    }
    fn shader_node_name(&self) -> &String {
        self._glacier_base.shader_node_name()
    }
    fn shader_node_name_mut(&mut self) -> &mut String {
        self._glacier_base.shader_node_name_mut()
    }
    fn mesh_materials(&self) -> &Vec<CustomizedMeshMaterialsData> {
        self._glacier_base.mesh_materials()
    }
    fn mesh_materials_mut(&mut self) -> &mut Vec<CustomizedMeshMaterialsData> {
        self._glacier_base.mesh_materials_mut()
    }
}

impl super::core::DataContainerTrait for ShaderTextureUnlockPartCollection {
}

pub static SHADERTEXTUREUNLOCKPARTCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderTextureUnlockPartCollection",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShaderTextureUnlockPartCollection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultTextureReference",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureReference",
                rust_offset: offset_of!(ShaderTextureUnlockPartCollection, default_texture_reference),
            },
            FieldInfoData {
                name: "UnlockParts",
                flags: MemberInfoFlags::new(144),
                field_type: "TextureUnlockPartData-Array",
                rust_offset: offset_of!(ShaderTextureUnlockPartCollection, unlock_parts),
            },
        ],
    }),
    array_type: Some(SHADERTEXTUREUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ShaderTextureUnlockPartCollection {
    fn type_info(&self) -> &'static TypeInfo {
        SHADERTEXTUREUNLOCKPARTCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADERTEXTUREUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderTextureUnlockPartCollection-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ShaderTextureUnlockPartCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShaderColorUnlockPartCollection {
    pub _glacier_base: ShaderCustomizationUnlockPartCollection,
    pub default_color_reference: Option<Arc<Mutex<dyn ColorReferenceTrait>>>,
    pub unlock_parts: Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>>,
}

pub trait ShaderColorUnlockPartCollectionTrait: ShaderCustomizationUnlockPartCollectionTrait {
    fn default_color_reference(&self) -> &Option<Arc<Mutex<dyn ColorReferenceTrait>>>;
    fn default_color_reference_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ColorReferenceTrait>>>;
    fn unlock_parts(&self) -> &Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>>;
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>>;
}

impl ShaderColorUnlockPartCollectionTrait for ShaderColorUnlockPartCollection {
    fn default_color_reference(&self) -> &Option<Arc<Mutex<dyn ColorReferenceTrait>>> {
        &self.default_color_reference
    }
    fn default_color_reference_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ColorReferenceTrait>>> {
        &mut self.default_color_reference
    }
    fn unlock_parts(&self) -> &Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>> {
        &self.unlock_parts
    }
    fn unlock_parts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>> {
        &mut self.unlock_parts
    }
}

impl ShaderCustomizationUnlockPartCollectionTrait for ShaderColorUnlockPartCollection {
    fn mesh_blueprints(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>> {
        self._glacier_base.mesh_blueprints()
    }
    fn mesh_blueprints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>> {
        self._glacier_base.mesh_blueprints_mut()
    }
    fn shader_node_name(&self) -> &String {
        self._glacier_base.shader_node_name()
    }
    fn shader_node_name_mut(&mut self) -> &mut String {
        self._glacier_base.shader_node_name_mut()
    }
    fn mesh_materials(&self) -> &Vec<CustomizedMeshMaterialsData> {
        self._glacier_base.mesh_materials()
    }
    fn mesh_materials_mut(&mut self) -> &mut Vec<CustomizedMeshMaterialsData> {
        self._glacier_base.mesh_materials_mut()
    }
}

impl super::core::DataContainerTrait for ShaderColorUnlockPartCollection {
}

pub static SHADERCOLORUNLOCKPARTCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderColorUnlockPartCollection",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShaderColorUnlockPartCollection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultColorReference",
                flags: MemberInfoFlags::new(0),
                field_type: "ColorReference",
                rust_offset: offset_of!(ShaderColorUnlockPartCollection, default_color_reference),
            },
            FieldInfoData {
                name: "UnlockParts",
                flags: MemberInfoFlags::new(144),
                field_type: "ColorUnlockPartData-Array",
                rust_offset: offset_of!(ShaderColorUnlockPartCollection, unlock_parts),
            },
        ],
    }),
    array_type: Some(SHADERCOLORUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ShaderColorUnlockPartCollection {
    fn type_info(&self) -> &'static TypeInfo {
        SHADERCOLORUNLOCKPARTCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADERCOLORUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderColorUnlockPartCollection-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ShaderColorUnlockPartCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShaderCustomizationUnlockPartCollection {
    pub _glacier_base: super::core::DataContainer,
    pub mesh_blueprints: Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>>,
    pub shader_node_name: String,
    pub mesh_materials: Vec<CustomizedMeshMaterialsData>,
}

pub trait ShaderCustomizationUnlockPartCollectionTrait: super::core::DataContainerTrait {
    fn mesh_blueprints(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>>;
    fn mesh_blueprints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>>;
    fn shader_node_name(&self) -> &String;
    fn shader_node_name_mut(&mut self) -> &mut String;
    fn mesh_materials(&self) -> &Vec<CustomizedMeshMaterialsData>;
    fn mesh_materials_mut(&mut self) -> &mut Vec<CustomizedMeshMaterialsData>;
}

impl ShaderCustomizationUnlockPartCollectionTrait for ShaderCustomizationUnlockPartCollection {
    fn mesh_blueprints(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>> {
        &self.mesh_blueprints
    }
    fn mesh_blueprints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>> {
        &mut self.mesh_blueprints
    }
    fn shader_node_name(&self) -> &String {
        &self.shader_node_name
    }
    fn shader_node_name_mut(&mut self) -> &mut String {
        &mut self.shader_node_name
    }
    fn mesh_materials(&self) -> &Vec<CustomizedMeshMaterialsData> {
        &self.mesh_materials
    }
    fn mesh_materials_mut(&mut self) -> &mut Vec<CustomizedMeshMaterialsData> {
        &mut self.mesh_materials
    }
}

impl super::core::DataContainerTrait for ShaderCustomizationUnlockPartCollection {
}

pub static SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderCustomizationUnlockPartCollection",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShaderCustomizationUnlockPartCollection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MeshBlueprints",
                flags: MemberInfoFlags::new(144),
                field_type: "ObjectBlueprint-Array",
                rust_offset: offset_of!(ShaderCustomizationUnlockPartCollection, mesh_blueprints),
            },
            FieldInfoData {
                name: "ShaderNodeName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ShaderCustomizationUnlockPartCollection, shader_node_name),
            },
            FieldInfoData {
                name: "MeshMaterials",
                flags: MemberInfoFlags::new(144),
                field_type: "CustomizedMeshMaterialsData-Array",
                rust_offset: offset_of!(ShaderCustomizationUnlockPartCollection, mesh_materials),
            },
        ],
    }),
    array_type: Some(SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ShaderCustomizationUnlockPartCollection {
    fn type_info(&self) -> &'static TypeInfo {
        SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHADERCUSTOMIZATIONUNLOCKPARTCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShaderCustomizationUnlockPartCollection-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ShaderCustomizationUnlockPartCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CustomizedMeshMaterialsData {
    pub mesh_blueprint: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub material_names: Vec<String>,
}

pub trait CustomizedMeshMaterialsDataTrait: TypeObject {
    fn mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn material_names(&self) -> &Vec<String>;
    fn material_names_mut(&mut self) -> &mut Vec<String>;
}

impl CustomizedMeshMaterialsDataTrait for CustomizedMeshMaterialsData {
    fn mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.mesh_blueprint
    }
    fn mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.mesh_blueprint
    }
    fn material_names(&self) -> &Vec<String> {
        &self.material_names
    }
    fn material_names_mut(&mut self) -> &mut Vec<String> {
        &mut self.material_names
    }
}

pub static CUSTOMIZEDMESHMATERIALSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizedMeshMaterialsData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CustomizedMeshMaterialsData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MeshBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(CustomizedMeshMaterialsData, mesh_blueprint),
            },
            FieldInfoData {
                name: "MaterialNames",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(CustomizedMeshMaterialsData, material_names),
            },
        ],
    }),
    array_type: Some(CUSTOMIZEDMESHMATERIALSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CustomizedMeshMaterialsData {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZEDMESHMATERIALSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUSTOMIZEDMESHMATERIALSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizedMeshMaterialsData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizedMeshMaterialsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockableTextureSliceCollection {
    pub _glacier_base: super::core::DataContainer,
    pub default_value: i32,
    pub possible_values: Vec<Option<Arc<Mutex<dyn TextureSliceUnlockPartDataTrait>>>>,
}

pub trait UnlockableTextureSliceCollectionTrait: super::core::DataContainerTrait {
    fn default_value(&self) -> &i32;
    fn default_value_mut(&mut self) -> &mut i32;
    fn possible_values(&self) -> &Vec<Option<Arc<Mutex<dyn TextureSliceUnlockPartDataTrait>>>>;
    fn possible_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TextureSliceUnlockPartDataTrait>>>>;
}

impl UnlockableTextureSliceCollectionTrait for UnlockableTextureSliceCollection {
    fn default_value(&self) -> &i32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut i32 {
        &mut self.default_value
    }
    fn possible_values(&self) -> &Vec<Option<Arc<Mutex<dyn TextureSliceUnlockPartDataTrait>>>> {
        &self.possible_values
    }
    fn possible_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TextureSliceUnlockPartDataTrait>>>> {
        &mut self.possible_values
    }
}

impl super::core::DataContainerTrait for UnlockableTextureSliceCollection {
}

pub static UNLOCKABLETEXTURESLICECOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableTextureSliceCollection",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockableTextureSliceCollection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(UnlockableTextureSliceCollection, default_value),
            },
            FieldInfoData {
                name: "PossibleValues",
                flags: MemberInfoFlags::new(144),
                field_type: "TextureSliceUnlockPartData-Array",
                rust_offset: offset_of!(UnlockableTextureSliceCollection, possible_values),
            },
        ],
    }),
    array_type: Some(UNLOCKABLETEXTURESLICECOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockableTextureSliceCollection {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKABLETEXTURESLICECOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKABLETEXTURESLICECOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableTextureSliceCollection-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockableTextureSliceCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockableTextureCollection {
    pub _glacier_base: super::core::DataContainer,
    pub default_value: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
}

pub trait UnlockableTextureCollectionTrait: super::core::DataContainerTrait {
    fn default_value(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn default_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
}

impl UnlockableTextureCollectionTrait for UnlockableTextureCollection {
    fn default_value(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.default_value
    }
}

impl super::core::DataContainerTrait for UnlockableTextureCollection {
}

pub static UNLOCKABLETEXTURECOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableTextureCollection",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockableTextureCollection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(UnlockableTextureCollection, default_value),
            },
        ],
    }),
    array_type: Some(UNLOCKABLETEXTURECOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockableTextureCollection {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKABLETEXTURECOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKABLETEXTURECOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableTextureCollection-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockableTextureCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockableColorCollection {
    pub _glacier_base: super::core::DataContainer,
    pub default_value: Option<Arc<Mutex<dyn ColorReferenceTrait>>>,
    pub possible_values: Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>>,
}

pub trait UnlockableColorCollectionTrait: super::core::DataContainerTrait {
    fn default_value(&self) -> &Option<Arc<Mutex<dyn ColorReferenceTrait>>>;
    fn default_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ColorReferenceTrait>>>;
    fn possible_values(&self) -> &Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>>;
    fn possible_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>>;
}

impl UnlockableColorCollectionTrait for UnlockableColorCollection {
    fn default_value(&self) -> &Option<Arc<Mutex<dyn ColorReferenceTrait>>> {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ColorReferenceTrait>>> {
        &mut self.default_value
    }
    fn possible_values(&self) -> &Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>> {
        &self.possible_values
    }
    fn possible_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ColorUnlockPartDataTrait>>>> {
        &mut self.possible_values
    }
}

impl super::core::DataContainerTrait for UnlockableColorCollection {
}

pub static UNLOCKABLECOLORCOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableColorCollection",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockableColorCollection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "ColorReference",
                rust_offset: offset_of!(UnlockableColorCollection, default_value),
            },
            FieldInfoData {
                name: "PossibleValues",
                flags: MemberInfoFlags::new(144),
                field_type: "ColorUnlockPartData-Array",
                rust_offset: offset_of!(UnlockableColorCollection, possible_values),
            },
        ],
    }),
    array_type: Some(UNLOCKABLECOLORCOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockableColorCollection {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKABLECOLORCOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKABLECOLORCOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableColorCollection-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockableColorCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockableShaderParameterValueCollection {
    pub _glacier_base: super::core::DataContainer,
    pub shader_parameter_name: String,
}

pub trait UnlockableShaderParameterValueCollectionTrait: super::core::DataContainerTrait {
    fn shader_parameter_name(&self) -> &String;
    fn shader_parameter_name_mut(&mut self) -> &mut String;
}

impl UnlockableShaderParameterValueCollectionTrait for UnlockableShaderParameterValueCollection {
    fn shader_parameter_name(&self) -> &String {
        &self.shader_parameter_name
    }
    fn shader_parameter_name_mut(&mut self) -> &mut String {
        &mut self.shader_parameter_name
    }
}

impl super::core::DataContainerTrait for UnlockableShaderParameterValueCollection {
}

pub static UNLOCKABLESHADERPARAMETERVALUECOLLECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableShaderParameterValueCollection",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockableShaderParameterValueCollection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ShaderParameterName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(UnlockableShaderParameterValueCollection, shader_parameter_name),
            },
        ],
    }),
    array_type: Some(UNLOCKABLESHADERPARAMETERVALUECOLLECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockableShaderParameterValueCollection {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKABLESHADERPARAMETERVALUECOLLECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKABLESHADERPARAMETERVALUECOLLECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockableShaderParameterValueCollection-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockableShaderParameterValueCollection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TextureSliceUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub slice_index: i32,
}

pub trait TextureSliceUnlockPartDataTrait: super::core::DataContainerTrait {
    fn slice_index(&self) -> &i32;
    fn slice_index_mut(&mut self) -> &mut i32;
}

impl TextureSliceUnlockPartDataTrait for TextureSliceUnlockPartData {
    fn slice_index(&self) -> &i32 {
        &self.slice_index
    }
    fn slice_index_mut(&mut self) -> &mut i32 {
        &mut self.slice_index
    }
}

impl super::core::DataContainerTrait for TextureSliceUnlockPartData {
}

pub static TEXTURESLICEUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureSliceUnlockPartData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextureSliceUnlockPartData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SliceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TextureSliceUnlockPartData, slice_index),
            },
        ],
    }),
    array_type: Some(TEXTURESLICEUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextureSliceUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTURESLICEUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTURESLICEUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureSliceUnlockPartData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextureSliceUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TextureAssetUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
}

pub trait TextureAssetUnlockPartDataTrait: super::core::DataContainerTrait {
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
}

impl TextureAssetUnlockPartDataTrait for TextureAssetUnlockPartData {
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.texture
    }
}

impl super::core::DataContainerTrait for TextureAssetUnlockPartData {
}

pub static TEXTUREASSETUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureAssetUnlockPartData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextureAssetUnlockPartData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(TextureAssetUnlockPartData, texture),
            },
        ],
    }),
    array_type: Some(TEXTUREASSETUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextureAssetUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTUREASSETUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTUREASSETUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureAssetUnlockPartData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextureAssetUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TextureUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub texture_reference: Option<Arc<Mutex<dyn TextureReferenceTrait>>>,
}

pub trait TextureUnlockPartDataTrait: super::core::DataContainerTrait {
    fn texture_reference(&self) -> &Option<Arc<Mutex<dyn TextureReferenceTrait>>>;
    fn texture_reference_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TextureReferenceTrait>>>;
}

impl TextureUnlockPartDataTrait for TextureUnlockPartData {
    fn texture_reference(&self) -> &Option<Arc<Mutex<dyn TextureReferenceTrait>>> {
        &self.texture_reference
    }
    fn texture_reference_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TextureReferenceTrait>>> {
        &mut self.texture_reference
    }
}

impl super::core::DataContainerTrait for TextureUnlockPartData {
}

pub static TEXTUREUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureUnlockPartData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextureUnlockPartData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TextureReference",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureReference",
                rust_offset: offset_of!(TextureUnlockPartData, texture_reference),
            },
        ],
    }),
    array_type: Some(TEXTUREUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextureUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTUREUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTUREUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureUnlockPartData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextureUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TextureReference {
    pub _glacier_base: super::core::Asset,
    pub texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
}

pub trait TextureReferenceTrait: super::core::AssetTrait {
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
}

impl TextureReferenceTrait for TextureReference {
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.texture
    }
}

impl super::core::AssetTrait for TextureReference {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for TextureReference {
}

pub static TEXTUREREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureReference",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TextureReference as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(TextureReference, texture),
            },
        ],
    }),
    array_type: Some(TEXTUREREFERENCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TextureReference {
    fn type_info(&self) -> &'static TypeInfo {
        TEXTUREREFERENCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TEXTUREREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TextureReference-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TextureReference"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ColorUnlockPartData {
    pub _glacier_base: super::core::DataContainer,
    pub color_reference: Option<Arc<Mutex<dyn ColorReferenceTrait>>>,
}

pub trait ColorUnlockPartDataTrait: super::core::DataContainerTrait {
    fn color_reference(&self) -> &Option<Arc<Mutex<dyn ColorReferenceTrait>>>;
    fn color_reference_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ColorReferenceTrait>>>;
}

impl ColorUnlockPartDataTrait for ColorUnlockPartData {
    fn color_reference(&self) -> &Option<Arc<Mutex<dyn ColorReferenceTrait>>> {
        &self.color_reference
    }
    fn color_reference_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ColorReferenceTrait>>> {
        &mut self.color_reference
    }
}

impl super::core::DataContainerTrait for ColorUnlockPartData {
}

pub static COLORUNLOCKPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorUnlockPartData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ColorUnlockPartData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ColorReference",
                flags: MemberInfoFlags::new(0),
                field_type: "ColorReference",
                rust_offset: offset_of!(ColorUnlockPartData, color_reference),
            },
        ],
    }),
    array_type: Some(COLORUNLOCKPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ColorUnlockPartData {
    fn type_info(&self) -> &'static TypeInfo {
        COLORUNLOCKPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLORUNLOCKPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorUnlockPartData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ColorUnlockPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ColorReference {
    pub _glacier_base: super::core::Asset,
    pub color: super::core::Vec4,
}

pub trait ColorReferenceTrait: super::core::AssetTrait {
    fn color(&self) -> &super::core::Vec4;
    fn color_mut(&mut self) -> &mut super::core::Vec4;
}

impl ColorReferenceTrait for ColorReference {
    fn color(&self) -> &super::core::Vec4 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.color
    }
}

impl super::core::AssetTrait for ColorReference {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ColorReference {
}

pub static COLORREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorReference",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ColorReference as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(ColorReference, color),
            },
        ],
    }),
    array_type: Some(COLORREFERENCE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ColorReference {
    fn type_info(&self) -> &'static TypeInfo {
        COLORREFERENCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLORREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorReference-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ColorReference"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AreaImmunityComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub clear_area_immunity: bool,
}

pub trait AreaImmunityComponentDataTrait: super::entity::GameComponentDataTrait {
    fn clear_area_immunity(&self) -> &bool;
    fn clear_area_immunity_mut(&mut self) -> &mut bool;
}

impl AreaImmunityComponentDataTrait for AreaImmunityComponentData {
    fn clear_area_immunity(&self) -> &bool {
        &self.clear_area_immunity
    }
    fn clear_area_immunity_mut(&mut self) -> &mut bool {
        &mut self.clear_area_immunity
    }
}

impl super::entity::GameComponentDataTrait for AreaImmunityComponentData {
}

impl super::entity::ComponentDataTrait for AreaImmunityComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AreaImmunityComponentData {
}

impl super::core::DataBusPeerTrait for AreaImmunityComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AreaImmunityComponentData {
}

impl super::core::DataContainerTrait for AreaImmunityComponentData {
}

pub static AREAIMMUNITYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaImmunityComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AreaImmunityComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ClearAreaImmunity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaImmunityComponentData, clear_area_immunity),
            },
        ],
    }),
    array_type: Some(AREAIMMUNITYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AreaImmunityComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AREAIMMUNITYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AREAIMMUNITYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaImmunityComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaImmunityComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaterDepthComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub auto_start: bool,
    pub reset_on_stop: bool,
    pub player_only: bool,
    pub update_rate: u32,
    pub enabled: bool,
}

pub trait WaterDepthComponentDataTrait: super::entity::GameComponentDataTrait {
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn reset_on_stop(&self) -> &bool;
    fn reset_on_stop_mut(&mut self) -> &mut bool;
    fn player_only(&self) -> &bool;
    fn player_only_mut(&mut self) -> &mut bool;
    fn update_rate(&self) -> &u32;
    fn update_rate_mut(&mut self) -> &mut u32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl WaterDepthComponentDataTrait for WaterDepthComponentData {
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn reset_on_stop(&self) -> &bool {
        &self.reset_on_stop
    }
    fn reset_on_stop_mut(&mut self) -> &mut bool {
        &mut self.reset_on_stop
    }
    fn player_only(&self) -> &bool {
        &self.player_only
    }
    fn player_only_mut(&mut self) -> &mut bool {
        &mut self.player_only
    }
    fn update_rate(&self) -> &u32 {
        &self.update_rate
    }
    fn update_rate_mut(&mut self) -> &mut u32 {
        &mut self.update_rate
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::GameComponentDataTrait for WaterDepthComponentData {
}

impl super::entity::ComponentDataTrait for WaterDepthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WaterDepthComponentData {
}

impl super::core::DataBusPeerTrait for WaterDepthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WaterDepthComponentData {
}

impl super::core::DataContainerTrait for WaterDepthComponentData {
}

pub static WATERDEPTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterDepthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaterDepthComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AutoStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthComponentData, auto_start),
            },
            FieldInfoData {
                name: "ResetOnStop",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthComponentData, reset_on_stop),
            },
            FieldInfoData {
                name: "PlayerOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthComponentData, player_only),
            },
            FieldInfoData {
                name: "UpdateRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(WaterDepthComponentData, update_rate),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaterDepthComponentData, enabled),
            },
        ],
    }),
    array_type: Some(WATERDEPTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WaterDepthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WATERDEPTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WATERDEPTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaterDepthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WaterDepthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LadderComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait LadderComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl LadderComponentDataTrait for LadderComponentData {
}

impl super::entity::GameComponentDataTrait for LadderComponentData {
}

impl super::entity::ComponentDataTrait for LadderComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LadderComponentData {
}

impl super::core::DataBusPeerTrait for LadderComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LadderComponentData {
}

impl super::core::DataContainerTrait for LadderComponentData {
}

pub static LADDERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LadderComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LadderComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LADDERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LadderComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LADDERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LADDERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LadderComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LadderComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityToComponentsResetMessage {
}

pub trait EntityToComponentsResetMessageTrait: TypeObject {
}

impl EntityToComponentsResetMessageTrait for EntityToComponentsResetMessage {
}

pub static ENTITYTOCOMPONENTSRESETMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityToComponentsResetMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityToComponentsResetMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for EntityToComponentsResetMessage {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYTOCOMPONENTSRESETMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AlternateCameraViewData {
    pub _glacier_base: super::core::DataContainer,
    pub field_of_view: f32,
    pub allow_field_of_view_scaling: bool,
    pub fov_transition_time: f32,
    pub world_space_lock_efficiency: f32,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub mask_mesh_blueprint: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub lock_mesh_to_render_view: bool,
    pub mesh_offset: super::core::Vec3,
    pub hud: Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>>,
    pub fade_to_black: bool,
    pub fade_in_duration: f32,
    pub fade_out_duration: f32,
    pub black_duration: f32,
    pub input_suppression: InputSuppressionData,
    pub toggle_view_change: bool,
    pub use_profile_option_for_toggle_view_change: bool,
    pub f_l_i_r_enabled: bool,
    pub screen_exposure_area_scale: f32,
}

pub trait AlternateCameraViewDataTrait: super::core::DataContainerTrait {
    fn field_of_view(&self) -> &f32;
    fn field_of_view_mut(&mut self) -> &mut f32;
    fn allow_field_of_view_scaling(&self) -> &bool;
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool;
    fn fov_transition_time(&self) -> &f32;
    fn fov_transition_time_mut(&mut self) -> &mut f32;
    fn world_space_lock_efficiency(&self) -> &f32;
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32;
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mask_mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn mask_mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn lock_mesh_to_render_view(&self) -> &bool;
    fn lock_mesh_to_render_view_mut(&mut self) -> &mut bool;
    fn mesh_offset(&self) -> &super::core::Vec3;
    fn mesh_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn hud(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>>;
    fn hud_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>>;
    fn fade_to_black(&self) -> &bool;
    fn fade_to_black_mut(&mut self) -> &mut bool;
    fn fade_in_duration(&self) -> &f32;
    fn fade_in_duration_mut(&mut self) -> &mut f32;
    fn fade_out_duration(&self) -> &f32;
    fn fade_out_duration_mut(&mut self) -> &mut f32;
    fn black_duration(&self) -> &f32;
    fn black_duration_mut(&mut self) -> &mut f32;
    fn input_suppression(&self) -> &InputSuppressionData;
    fn input_suppression_mut(&mut self) -> &mut InputSuppressionData;
    fn toggle_view_change(&self) -> &bool;
    fn toggle_view_change_mut(&mut self) -> &mut bool;
    fn use_profile_option_for_toggle_view_change(&self) -> &bool;
    fn use_profile_option_for_toggle_view_change_mut(&mut self) -> &mut bool;
    fn f_l_i_r_enabled(&self) -> &bool;
    fn f_l_i_r_enabled_mut(&mut self) -> &mut bool;
    fn screen_exposure_area_scale(&self) -> &f32;
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32;
}

impl AlternateCameraViewDataTrait for AlternateCameraViewData {
    fn field_of_view(&self) -> &f32 {
        &self.field_of_view
    }
    fn field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view
    }
    fn allow_field_of_view_scaling(&self) -> &bool {
        &self.allow_field_of_view_scaling
    }
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool {
        &mut self.allow_field_of_view_scaling
    }
    fn fov_transition_time(&self) -> &f32 {
        &self.fov_transition_time
    }
    fn fov_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.fov_transition_time
    }
    fn world_space_lock_efficiency(&self) -> &f32 {
        &self.world_space_lock_efficiency
    }
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn mask_mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.mask_mesh_blueprint
    }
    fn mask_mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.mask_mesh_blueprint
    }
    fn lock_mesh_to_render_view(&self) -> &bool {
        &self.lock_mesh_to_render_view
    }
    fn lock_mesh_to_render_view_mut(&mut self) -> &mut bool {
        &mut self.lock_mesh_to_render_view
    }
    fn mesh_offset(&self) -> &super::core::Vec3 {
        &self.mesh_offset
    }
    fn mesh_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.mesh_offset
    }
    fn hud(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        &self.hud
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        &mut self.hud
    }
    fn fade_to_black(&self) -> &bool {
        &self.fade_to_black
    }
    fn fade_to_black_mut(&mut self) -> &mut bool {
        &mut self.fade_to_black
    }
    fn fade_in_duration(&self) -> &f32 {
        &self.fade_in_duration
    }
    fn fade_in_duration_mut(&mut self) -> &mut f32 {
        &mut self.fade_in_duration
    }
    fn fade_out_duration(&self) -> &f32 {
        &self.fade_out_duration
    }
    fn fade_out_duration_mut(&mut self) -> &mut f32 {
        &mut self.fade_out_duration
    }
    fn black_duration(&self) -> &f32 {
        &self.black_duration
    }
    fn black_duration_mut(&mut self) -> &mut f32 {
        &mut self.black_duration
    }
    fn input_suppression(&self) -> &InputSuppressionData {
        &self.input_suppression
    }
    fn input_suppression_mut(&mut self) -> &mut InputSuppressionData {
        &mut self.input_suppression
    }
    fn toggle_view_change(&self) -> &bool {
        &self.toggle_view_change
    }
    fn toggle_view_change_mut(&mut self) -> &mut bool {
        &mut self.toggle_view_change
    }
    fn use_profile_option_for_toggle_view_change(&self) -> &bool {
        &self.use_profile_option_for_toggle_view_change
    }
    fn use_profile_option_for_toggle_view_change_mut(&mut self) -> &mut bool {
        &mut self.use_profile_option_for_toggle_view_change
    }
    fn f_l_i_r_enabled(&self) -> &bool {
        &self.f_l_i_r_enabled
    }
    fn f_l_i_r_enabled_mut(&mut self) -> &mut bool {
        &mut self.f_l_i_r_enabled
    }
    fn screen_exposure_area_scale(&self) -> &f32 {
        &self.screen_exposure_area_scale
    }
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32 {
        &mut self.screen_exposure_area_scale
    }
}

impl super::core::DataContainerTrait for AlternateCameraViewData {
}

pub static ALTERNATECAMERAVIEWDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlternateCameraViewData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AlternateCameraViewData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FieldOfView",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, field_of_view),
            },
            FieldInfoData {
                name: "AllowFieldOfViewScaling",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, allow_field_of_view_scaling),
            },
            FieldInfoData {
                name: "FovTransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, fov_transition_time),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, world_space_lock_efficiency),
            },
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(AlternateCameraViewData, mesh),
            },
            FieldInfoData {
                name: "MaskMeshBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(AlternateCameraViewData, mask_mesh_blueprint),
            },
            FieldInfoData {
                name: "LockMeshToRenderView",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, lock_mesh_to_render_view),
            },
            FieldInfoData {
                name: "MeshOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AlternateCameraViewData, mesh_offset),
            },
            FieldInfoData {
                name: "Hud",
                flags: MemberInfoFlags::new(144),
                field_type: "HudData-Array",
                rust_offset: offset_of!(AlternateCameraViewData, hud),
            },
            FieldInfoData {
                name: "FadeToBlack",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, fade_to_black),
            },
            FieldInfoData {
                name: "FadeInDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, fade_in_duration),
            },
            FieldInfoData {
                name: "FadeOutDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, fade_out_duration),
            },
            FieldInfoData {
                name: "BlackDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, black_duration),
            },
            FieldInfoData {
                name: "InputSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "InputSuppressionData",
                rust_offset: offset_of!(AlternateCameraViewData, input_suppression),
            },
            FieldInfoData {
                name: "ToggleViewChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, toggle_view_change),
            },
            FieldInfoData {
                name: "UseProfileOptionForToggleViewChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, use_profile_option_for_toggle_view_change),
            },
            FieldInfoData {
                name: "FLIREnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateCameraViewData, f_l_i_r_enabled),
            },
            FieldInfoData {
                name: "ScreenExposureAreaScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateCameraViewData, screen_exposure_area_scale),
            },
        ],
    }),
    array_type: Some(ALTERNATECAMERAVIEWDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AlternateCameraViewData {
    fn type_info(&self) -> &'static TypeInfo {
        ALTERNATECAMERAVIEWDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ALTERNATECAMERAVIEWDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlternateCameraViewData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AlternateCameraViewData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CollisionEffectSpawnComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub effect_parameters: Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>>,
    pub speed_limit: f32,
}

pub trait CollisionEffectSpawnComponentDataTrait: super::entity::GameComponentDataTrait {
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>>;
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>>;
    fn speed_limit(&self) -> &f32;
    fn speed_limit_mut(&mut self) -> &mut f32;
}

impl CollisionEffectSpawnComponentDataTrait for CollisionEffectSpawnComponentData {
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        &self.effect_parameters
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        &mut self.effect_parameters
    }
    fn speed_limit(&self) -> &f32 {
        &self.speed_limit
    }
    fn speed_limit_mut(&mut self) -> &mut f32 {
        &mut self.speed_limit
    }
}

impl super::entity::GameComponentDataTrait for CollisionEffectSpawnComponentData {
}

impl super::entity::ComponentDataTrait for CollisionEffectSpawnComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CollisionEffectSpawnComponentData {
}

impl super::core::DataBusPeerTrait for CollisionEffectSpawnComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CollisionEffectSpawnComponentData {
}

impl super::core::DataContainerTrait for CollisionEffectSpawnComponentData {
}

pub static COLLISIONEFFECTSPAWNCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionEffectSpawnComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CollisionEffectSpawnComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EffectParameters",
                flags: MemberInfoFlags::new(144),
                field_type: "EffectParameter-Array",
                rust_offset: offset_of!(CollisionEffectSpawnComponentData, effect_parameters),
            },
            FieldInfoData {
                name: "SpeedLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionEffectSpawnComponentData, speed_limit),
            },
        ],
    }),
    array_type: Some(COLLISIONEFFECTSPAWNCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CollisionEffectSpawnComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        COLLISIONEFFECTSPAWNCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLLISIONEFFECTSPAWNCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionEffectSpawnComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CollisionEffectSpawnComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EffectComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub effect: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
    pub auto_start: bool,
    pub snap_to_water_surface: bool,
    pub emitter_parameter1: f32,
    pub emitter_parameter2: f32,
    pub emitter_parameter3: f32,
    pub override_height: f32,
    pub max_instances: i32,
    pub effect_parameters: Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>>,
    pub is_first_person: bool,
}

pub trait EffectComponentDataTrait: super::entity::GameComponentDataTrait {
    fn effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn snap_to_water_surface(&self) -> &bool;
    fn snap_to_water_surface_mut(&mut self) -> &mut bool;
    fn emitter_parameter1(&self) -> &f32;
    fn emitter_parameter1_mut(&mut self) -> &mut f32;
    fn emitter_parameter2(&self) -> &f32;
    fn emitter_parameter2_mut(&mut self) -> &mut f32;
    fn emitter_parameter3(&self) -> &f32;
    fn emitter_parameter3_mut(&mut self) -> &mut f32;
    fn override_height(&self) -> &f32;
    fn override_height_mut(&mut self) -> &mut f32;
    fn max_instances(&self) -> &i32;
    fn max_instances_mut(&mut self) -> &mut i32;
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>>;
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>>;
    fn is_first_person(&self) -> &bool;
    fn is_first_person_mut(&mut self) -> &mut bool;
}

impl EffectComponentDataTrait for EffectComponentData {
    fn effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.effect
    }
    fn effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &mut self.effect
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn snap_to_water_surface(&self) -> &bool {
        &self.snap_to_water_surface
    }
    fn snap_to_water_surface_mut(&mut self) -> &mut bool {
        &mut self.snap_to_water_surface
    }
    fn emitter_parameter1(&self) -> &f32 {
        &self.emitter_parameter1
    }
    fn emitter_parameter1_mut(&mut self) -> &mut f32 {
        &mut self.emitter_parameter1
    }
    fn emitter_parameter2(&self) -> &f32 {
        &self.emitter_parameter2
    }
    fn emitter_parameter2_mut(&mut self) -> &mut f32 {
        &mut self.emitter_parameter2
    }
    fn emitter_parameter3(&self) -> &f32 {
        &self.emitter_parameter3
    }
    fn emitter_parameter3_mut(&mut self) -> &mut f32 {
        &mut self.emitter_parameter3
    }
    fn override_height(&self) -> &f32 {
        &self.override_height
    }
    fn override_height_mut(&mut self) -> &mut f32 {
        &mut self.override_height
    }
    fn max_instances(&self) -> &i32 {
        &self.max_instances
    }
    fn max_instances_mut(&mut self) -> &mut i32 {
        &mut self.max_instances
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        &self.effect_parameters
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        &mut self.effect_parameters
    }
    fn is_first_person(&self) -> &bool {
        &self.is_first_person
    }
    fn is_first_person_mut(&mut self) -> &mut bool {
        &mut self.is_first_person
    }
}

impl super::entity::GameComponentDataTrait for EffectComponentData {
}

impl super::entity::ComponentDataTrait for EffectComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EffectComponentData {
}

impl super::core::DataBusPeerTrait for EffectComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EffectComponentData {
}

impl super::core::DataContainerTrait for EffectComponentData {
}

pub static EFFECTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EffectComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EffectComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Effect",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(EffectComponentData, effect),
            },
            FieldInfoData {
                name: "AutoStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EffectComponentData, auto_start),
            },
            FieldInfoData {
                name: "SnapToWaterSurface",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EffectComponentData, snap_to_water_surface),
            },
            FieldInfoData {
                name: "EmitterParameter1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EffectComponentData, emitter_parameter1),
            },
            FieldInfoData {
                name: "EmitterParameter2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EffectComponentData, emitter_parameter2),
            },
            FieldInfoData {
                name: "EmitterParameter3",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EffectComponentData, emitter_parameter3),
            },
            FieldInfoData {
                name: "OverrideHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EffectComponentData, override_height),
            },
            FieldInfoData {
                name: "MaxInstances",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EffectComponentData, max_instances),
            },
            FieldInfoData {
                name: "EffectParameters",
                flags: MemberInfoFlags::new(144),
                field_type: "EffectParameter-Array",
                rust_offset: offset_of!(EffectComponentData, effect_parameters),
            },
            FieldInfoData {
                name: "IsFirstPerson",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EffectComponentData, is_first_person),
            },
        ],
    }),
    array_type: Some(EFFECTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EffectComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        EFFECTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EFFECTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EffectComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EffectComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CustomizationConstants {
    #[default]
    MaxVisualSockets = 16,
    MaxAttachedSockets = 4,
}

pub static CUSTOMIZATIONCONSTANTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationConstants",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CUSTOMIZATIONCONSTANTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CustomizationConstants {
    fn type_info(&self) -> &'static TypeInfo {
        CUSTOMIZATIONCONSTANTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CUSTOMIZATIONCONSTANTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CustomizationConstants-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CustomizationConstants"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RegularCameraViewData {
    pub f_l_i_r_enabled: bool,
    pub input_suppression: InputSuppressionData,
    pub field_of_view: f32,
    pub allow_field_of_view_scaling: bool,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub mask_mesh_blueprint: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub lock_mesh_to_render_view: bool,
    pub mesh_offset: super::core::Vec3,
    pub screen_exposure_area_scale: f32,
}

pub trait RegularCameraViewDataTrait: TypeObject {
    fn f_l_i_r_enabled(&self) -> &bool;
    fn f_l_i_r_enabled_mut(&mut self) -> &mut bool;
    fn input_suppression(&self) -> &InputSuppressionData;
    fn input_suppression_mut(&mut self) -> &mut InputSuppressionData;
    fn field_of_view(&self) -> &f32;
    fn field_of_view_mut(&mut self) -> &mut f32;
    fn allow_field_of_view_scaling(&self) -> &bool;
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool;
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mask_mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn mask_mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn lock_mesh_to_render_view(&self) -> &bool;
    fn lock_mesh_to_render_view_mut(&mut self) -> &mut bool;
    fn mesh_offset(&self) -> &super::core::Vec3;
    fn mesh_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn screen_exposure_area_scale(&self) -> &f32;
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32;
}

impl RegularCameraViewDataTrait for RegularCameraViewData {
    fn f_l_i_r_enabled(&self) -> &bool {
        &self.f_l_i_r_enabled
    }
    fn f_l_i_r_enabled_mut(&mut self) -> &mut bool {
        &mut self.f_l_i_r_enabled
    }
    fn input_suppression(&self) -> &InputSuppressionData {
        &self.input_suppression
    }
    fn input_suppression_mut(&mut self) -> &mut InputSuppressionData {
        &mut self.input_suppression
    }
    fn field_of_view(&self) -> &f32 {
        &self.field_of_view
    }
    fn field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view
    }
    fn allow_field_of_view_scaling(&self) -> &bool {
        &self.allow_field_of_view_scaling
    }
    fn allow_field_of_view_scaling_mut(&mut self) -> &mut bool {
        &mut self.allow_field_of_view_scaling
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn mask_mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.mask_mesh_blueprint
    }
    fn mask_mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.mask_mesh_blueprint
    }
    fn lock_mesh_to_render_view(&self) -> &bool {
        &self.lock_mesh_to_render_view
    }
    fn lock_mesh_to_render_view_mut(&mut self) -> &mut bool {
        &mut self.lock_mesh_to_render_view
    }
    fn mesh_offset(&self) -> &super::core::Vec3 {
        &self.mesh_offset
    }
    fn mesh_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.mesh_offset
    }
    fn screen_exposure_area_scale(&self) -> &f32 {
        &self.screen_exposure_area_scale
    }
    fn screen_exposure_area_scale_mut(&mut self) -> &mut f32 {
        &mut self.screen_exposure_area_scale
    }
}

pub static REGULARCAMERAVIEWDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RegularCameraViewData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RegularCameraViewData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FLIREnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RegularCameraViewData, f_l_i_r_enabled),
            },
            FieldInfoData {
                name: "InputSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "InputSuppressionData",
                rust_offset: offset_of!(RegularCameraViewData, input_suppression),
            },
            FieldInfoData {
                name: "FieldOfView",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RegularCameraViewData, field_of_view),
            },
            FieldInfoData {
                name: "AllowFieldOfViewScaling",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RegularCameraViewData, allow_field_of_view_scaling),
            },
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(RegularCameraViewData, mesh),
            },
            FieldInfoData {
                name: "MaskMeshBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(RegularCameraViewData, mask_mesh_blueprint),
            },
            FieldInfoData {
                name: "LockMeshToRenderView",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RegularCameraViewData, lock_mesh_to_render_view),
            },
            FieldInfoData {
                name: "MeshOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(RegularCameraViewData, mesh_offset),
            },
            FieldInfoData {
                name: "ScreenExposureAreaScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RegularCameraViewData, screen_exposure_area_scale),
            },
        ],
    }),
    array_type: Some(REGULARCAMERAVIEWDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RegularCameraViewData {
    fn type_info(&self) -> &'static TypeInfo {
        REGULARCAMERAVIEWDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static REGULARCAMERAVIEWDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RegularCameraViewData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RegularCameraViewData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputSuppressionData {
    pub suppress_vehicle_input: Vec<ActionSuppressor>,
}

pub trait InputSuppressionDataTrait: TypeObject {
    fn suppress_vehicle_input(&self) -> &Vec<ActionSuppressor>;
    fn suppress_vehicle_input_mut(&mut self) -> &mut Vec<ActionSuppressor>;
}

impl InputSuppressionDataTrait for InputSuppressionData {
    fn suppress_vehicle_input(&self) -> &Vec<ActionSuppressor> {
        &self.suppress_vehicle_input
    }
    fn suppress_vehicle_input_mut(&mut self) -> &mut Vec<ActionSuppressor> {
        &mut self.suppress_vehicle_input
    }
}

pub static INPUTSUPPRESSIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputSuppressionData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputSuppressionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SuppressVehicleInput",
                flags: MemberInfoFlags::new(144),
                field_type: "ActionSuppressor-Array",
                rust_offset: offset_of!(InputSuppressionData, suppress_vehicle_input),
            },
        ],
    }),
    array_type: Some(INPUTSUPPRESSIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputSuppressionData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTSUPPRESSIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INPUTSUPPRESSIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputSuppressionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InputSuppressionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WeaponClassification {
    #[default]
    WCNone = 0,
    WCPrimary = 1,
    WCSecondary = 2,
}

pub static WEAPONCLASSIFICATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponClassification",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(WEAPONCLASSIFICATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WeaponClassification {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONCLASSIFICATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONCLASSIFICATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponClassification-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WeaponClassification"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BuoyantPartsData {
    pub part_name: BuoyantParts,
    pub buoyancy: f32,
}

pub trait BuoyantPartsDataTrait: TypeObject {
    fn part_name(&self) -> &BuoyantParts;
    fn part_name_mut(&mut self) -> &mut BuoyantParts;
    fn buoyancy(&self) -> &f32;
    fn buoyancy_mut(&mut self) -> &mut f32;
}

impl BuoyantPartsDataTrait for BuoyantPartsData {
    fn part_name(&self) -> &BuoyantParts {
        &self.part_name
    }
    fn part_name_mut(&mut self) -> &mut BuoyantParts {
        &mut self.part_name
    }
    fn buoyancy(&self) -> &f32 {
        &self.buoyancy
    }
    fn buoyancy_mut(&mut self) -> &mut f32 {
        &mut self.buoyancy
    }
}

pub static BUOYANTPARTSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuoyantPartsData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BuoyantPartsData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PartName",
                flags: MemberInfoFlags::new(0),
                field_type: "BuoyantParts",
                rust_offset: offset_of!(BuoyantPartsData, part_name),
            },
            FieldInfoData {
                name: "Buoyancy",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuoyantPartsData, buoyancy),
            },
        ],
    }),
    array_type: Some(BUOYANTPARTSDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BuoyantPartsData {
    fn type_info(&self) -> &'static TypeInfo {
        BUOYANTPARTSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUOYANTPARTSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuoyantPartsData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BuoyantPartsData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BuoyantParts {
    #[default]
    BuoyantPart_Hips = 0,
    BuoyantPart_Spine = 1,
    BuoyantPart_Spine1 = 2,
    BuoyantPart_Spine2 = 3,
    BuoyantPart_Head = 4,
    BuoyantPart_LeftArm = 5,
    BuoyantPart_LeftArmRoll = 6,
    BuoyantPart_LeftForeArm = 7,
    BuoyantPart_RightArm = 8,
    BuoyantPart_RightArmRoll = 9,
    BuoyantPart_RightForeArm = 10,
    BuoyantPart_RightUpLeg = 11,
    BuoyantPart_RightLeg = 12,
    BuoyantPart_LeftUpLeg = 13,
    BuoyantPart_LeftLeg = 14,
}

pub static BUOYANTPARTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuoyantParts",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BUOYANTPARTS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BuoyantParts {
    fn type_info(&self) -> &'static TypeInfo {
        BUOYANTPARTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUOYANTPARTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuoyantParts-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BuoyantParts"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SkeletonCollisionData {
    pub _glacier_base: super::core::DataContainer,
    pub skeleton_asset: Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>,
    pub bone_collision_data: Vec<BoneCollisionData>,
}

pub trait SkeletonCollisionDataTrait: super::core::DataContainerTrait {
    fn skeleton_asset(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn skeleton_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn bone_collision_data(&self) -> &Vec<BoneCollisionData>;
    fn bone_collision_data_mut(&mut self) -> &mut Vec<BoneCollisionData>;
}

impl SkeletonCollisionDataTrait for SkeletonCollisionData {
    fn skeleton_asset(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &self.skeleton_asset
    }
    fn skeleton_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &mut self.skeleton_asset
    }
    fn bone_collision_data(&self) -> &Vec<BoneCollisionData> {
        &self.bone_collision_data
    }
    fn bone_collision_data_mut(&mut self) -> &mut Vec<BoneCollisionData> {
        &mut self.bone_collision_data
    }
}

impl super::core::DataContainerTrait for SkeletonCollisionData {
}

pub static SKELETONCOLLISIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonCollisionData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SkeletonCollisionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SkeletonAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(SkeletonCollisionData, skeleton_asset),
            },
            FieldInfoData {
                name: "BoneCollisionData",
                flags: MemberInfoFlags::new(144),
                field_type: "BoneCollisionData-Array",
                rust_offset: offset_of!(SkeletonCollisionData, bone_collision_data),
            },
        ],
    }),
    array_type: Some(SKELETONCOLLISIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SkeletonCollisionData {
    fn type_info(&self) -> &'static TypeInfo {
        SKELETONCOLLISIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SKELETONCOLLISIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SkeletonCollisionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SkeletonCollisionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoneCollisionData {
    pub debug_draw_color: super::core::Vec4,
    pub capsule_offset: super::core::Vec3,
    pub bone_name: String,
    pub animation_hit_reaction_type: HitReactionType,
    pub material_pair: super::entity::MaterialDecl,
    pub bone_axis: i32,
    pub capsule_length: f32,
    pub capsule_radius: f32,
    pub valid_in_hi_lod: bool,
    pub valid_in_low_lod: bool,
    pub deactivate_if_behind_wall: bool,
    pub use_physics_rotation: bool,
    pub max_pitch: PitchModifier,
    pub min_pitch: PitchModifier,
    pub aim_assist_target: Option<Arc<Mutex<dyn AimAssistCollisionBoneDataTrait>>>,
}

pub trait BoneCollisionDataTrait: TypeObject {
    fn debug_draw_color(&self) -> &super::core::Vec4;
    fn debug_draw_color_mut(&mut self) -> &mut super::core::Vec4;
    fn capsule_offset(&self) -> &super::core::Vec3;
    fn capsule_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
    fn animation_hit_reaction_type(&self) -> &HitReactionType;
    fn animation_hit_reaction_type_mut(&mut self) -> &mut HitReactionType;
    fn material_pair(&self) -> &super::entity::MaterialDecl;
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn bone_axis(&self) -> &i32;
    fn bone_axis_mut(&mut self) -> &mut i32;
    fn capsule_length(&self) -> &f32;
    fn capsule_length_mut(&mut self) -> &mut f32;
    fn capsule_radius(&self) -> &f32;
    fn capsule_radius_mut(&mut self) -> &mut f32;
    fn valid_in_hi_lod(&self) -> &bool;
    fn valid_in_hi_lod_mut(&mut self) -> &mut bool;
    fn valid_in_low_lod(&self) -> &bool;
    fn valid_in_low_lod_mut(&mut self) -> &mut bool;
    fn deactivate_if_behind_wall(&self) -> &bool;
    fn deactivate_if_behind_wall_mut(&mut self) -> &mut bool;
    fn use_physics_rotation(&self) -> &bool;
    fn use_physics_rotation_mut(&mut self) -> &mut bool;
    fn max_pitch(&self) -> &PitchModifier;
    fn max_pitch_mut(&mut self) -> &mut PitchModifier;
    fn min_pitch(&self) -> &PitchModifier;
    fn min_pitch_mut(&mut self) -> &mut PitchModifier;
    fn aim_assist_target(&self) -> &Option<Arc<Mutex<dyn AimAssistCollisionBoneDataTrait>>>;
    fn aim_assist_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AimAssistCollisionBoneDataTrait>>>;
}

impl BoneCollisionDataTrait for BoneCollisionData {
    fn debug_draw_color(&self) -> &super::core::Vec4 {
        &self.debug_draw_color
    }
    fn debug_draw_color_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.debug_draw_color
    }
    fn capsule_offset(&self) -> &super::core::Vec3 {
        &self.capsule_offset
    }
    fn capsule_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.capsule_offset
    }
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
    fn animation_hit_reaction_type(&self) -> &HitReactionType {
        &self.animation_hit_reaction_type
    }
    fn animation_hit_reaction_type_mut(&mut self) -> &mut HitReactionType {
        &mut self.animation_hit_reaction_type
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        &self.material_pair
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material_pair
    }
    fn bone_axis(&self) -> &i32 {
        &self.bone_axis
    }
    fn bone_axis_mut(&mut self) -> &mut i32 {
        &mut self.bone_axis
    }
    fn capsule_length(&self) -> &f32 {
        &self.capsule_length
    }
    fn capsule_length_mut(&mut self) -> &mut f32 {
        &mut self.capsule_length
    }
    fn capsule_radius(&self) -> &f32 {
        &self.capsule_radius
    }
    fn capsule_radius_mut(&mut self) -> &mut f32 {
        &mut self.capsule_radius
    }
    fn valid_in_hi_lod(&self) -> &bool {
        &self.valid_in_hi_lod
    }
    fn valid_in_hi_lod_mut(&mut self) -> &mut bool {
        &mut self.valid_in_hi_lod
    }
    fn valid_in_low_lod(&self) -> &bool {
        &self.valid_in_low_lod
    }
    fn valid_in_low_lod_mut(&mut self) -> &mut bool {
        &mut self.valid_in_low_lod
    }
    fn deactivate_if_behind_wall(&self) -> &bool {
        &self.deactivate_if_behind_wall
    }
    fn deactivate_if_behind_wall_mut(&mut self) -> &mut bool {
        &mut self.deactivate_if_behind_wall
    }
    fn use_physics_rotation(&self) -> &bool {
        &self.use_physics_rotation
    }
    fn use_physics_rotation_mut(&mut self) -> &mut bool {
        &mut self.use_physics_rotation
    }
    fn max_pitch(&self) -> &PitchModifier {
        &self.max_pitch
    }
    fn max_pitch_mut(&mut self) -> &mut PitchModifier {
        &mut self.max_pitch
    }
    fn min_pitch(&self) -> &PitchModifier {
        &self.min_pitch
    }
    fn min_pitch_mut(&mut self) -> &mut PitchModifier {
        &mut self.min_pitch
    }
    fn aim_assist_target(&self) -> &Option<Arc<Mutex<dyn AimAssistCollisionBoneDataTrait>>> {
        &self.aim_assist_target
    }
    fn aim_assist_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AimAssistCollisionBoneDataTrait>>> {
        &mut self.aim_assist_target
    }
}

pub static BONECOLLISIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneCollisionData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoneCollisionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DebugDrawColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(BoneCollisionData, debug_draw_color),
            },
            FieldInfoData {
                name: "CapsuleOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(BoneCollisionData, capsule_offset),
            },
            FieldInfoData {
                name: "BoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BoneCollisionData, bone_name),
            },
            FieldInfoData {
                name: "AnimationHitReactionType",
                flags: MemberInfoFlags::new(0),
                field_type: "HitReactionType",
                rust_offset: offset_of!(BoneCollisionData, animation_hit_reaction_type),
            },
            FieldInfoData {
                name: "MaterialPair",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(BoneCollisionData, material_pair),
            },
            FieldInfoData {
                name: "BoneAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BoneCollisionData, bone_axis),
            },
            FieldInfoData {
                name: "CapsuleLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BoneCollisionData, capsule_length),
            },
            FieldInfoData {
                name: "CapsuleRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BoneCollisionData, capsule_radius),
            },
            FieldInfoData {
                name: "ValidInHiLod",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoneCollisionData, valid_in_hi_lod),
            },
            FieldInfoData {
                name: "ValidInLowLod",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoneCollisionData, valid_in_low_lod),
            },
            FieldInfoData {
                name: "DeactivateIfBehindWall",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoneCollisionData, deactivate_if_behind_wall),
            },
            FieldInfoData {
                name: "UsePhysicsRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoneCollisionData, use_physics_rotation),
            },
            FieldInfoData {
                name: "MaxPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "PitchModifier",
                rust_offset: offset_of!(BoneCollisionData, max_pitch),
            },
            FieldInfoData {
                name: "MinPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "PitchModifier",
                rust_offset: offset_of!(BoneCollisionData, min_pitch),
            },
            FieldInfoData {
                name: "AimAssistTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "AimAssistCollisionBoneData",
                rust_offset: offset_of!(BoneCollisionData, aim_assist_target),
            },
        ],
    }),
    array_type: Some(BONECOLLISIONDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BoneCollisionData {
    fn type_info(&self) -> &'static TypeInfo {
        BONECOLLISIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BONECOLLISIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoneCollisionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoneCollisionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimAssistCollisionBoneData {
    pub _glacier_base: super::core::DataContainer,
    pub length_scale: f32,
    pub snap_aim: AimAssistCollisionBoneSnapAimData,
}

pub trait AimAssistCollisionBoneDataTrait: super::core::DataContainerTrait {
    fn length_scale(&self) -> &f32;
    fn length_scale_mut(&mut self) -> &mut f32;
    fn snap_aim(&self) -> &AimAssistCollisionBoneSnapAimData;
    fn snap_aim_mut(&mut self) -> &mut AimAssistCollisionBoneSnapAimData;
}

impl AimAssistCollisionBoneDataTrait for AimAssistCollisionBoneData {
    fn length_scale(&self) -> &f32 {
        &self.length_scale
    }
    fn length_scale_mut(&mut self) -> &mut f32 {
        &mut self.length_scale
    }
    fn snap_aim(&self) -> &AimAssistCollisionBoneSnapAimData {
        &self.snap_aim
    }
    fn snap_aim_mut(&mut self) -> &mut AimAssistCollisionBoneSnapAimData {
        &mut self.snap_aim
    }
}

impl super::core::DataContainerTrait for AimAssistCollisionBoneData {
}

pub static AIMASSISTCOLLISIONBONEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBoneData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimAssistCollisionBoneData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LengthScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistCollisionBoneData, length_scale),
            },
            FieldInfoData {
                name: "SnapAim",
                flags: MemberInfoFlags::new(0),
                field_type: "AimAssistCollisionBoneSnapAimData",
                rust_offset: offset_of!(AimAssistCollisionBoneData, snap_aim),
            },
        ],
    }),
    array_type: Some(AIMASSISTCOLLISIONBONEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AimAssistCollisionBoneData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMASSISTCOLLISIONBONEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMASSISTCOLLISIONBONEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBoneData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AimAssistCollisionBoneData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimAssistCollisionBoneSnapAimData {
    pub bounding_length_scale: f32,
    pub bounding_radius_scale: f32,
    pub point_length_scale: f32,
    pub point_priorities: AimAssistCollisionBonePrioritiesData,
    pub point_priorities_bone_under_reticle: AimAssistCollisionBonePrioritiesData,
}

pub trait AimAssistCollisionBoneSnapAimDataTrait: TypeObject {
    fn bounding_length_scale(&self) -> &f32;
    fn bounding_length_scale_mut(&mut self) -> &mut f32;
    fn bounding_radius_scale(&self) -> &f32;
    fn bounding_radius_scale_mut(&mut self) -> &mut f32;
    fn point_length_scale(&self) -> &f32;
    fn point_length_scale_mut(&mut self) -> &mut f32;
    fn point_priorities(&self) -> &AimAssistCollisionBonePrioritiesData;
    fn point_priorities_mut(&mut self) -> &mut AimAssistCollisionBonePrioritiesData;
    fn point_priorities_bone_under_reticle(&self) -> &AimAssistCollisionBonePrioritiesData;
    fn point_priorities_bone_under_reticle_mut(&mut self) -> &mut AimAssistCollisionBonePrioritiesData;
}

impl AimAssistCollisionBoneSnapAimDataTrait for AimAssistCollisionBoneSnapAimData {
    fn bounding_length_scale(&self) -> &f32 {
        &self.bounding_length_scale
    }
    fn bounding_length_scale_mut(&mut self) -> &mut f32 {
        &mut self.bounding_length_scale
    }
    fn bounding_radius_scale(&self) -> &f32 {
        &self.bounding_radius_scale
    }
    fn bounding_radius_scale_mut(&mut self) -> &mut f32 {
        &mut self.bounding_radius_scale
    }
    fn point_length_scale(&self) -> &f32 {
        &self.point_length_scale
    }
    fn point_length_scale_mut(&mut self) -> &mut f32 {
        &mut self.point_length_scale
    }
    fn point_priorities(&self) -> &AimAssistCollisionBonePrioritiesData {
        &self.point_priorities
    }
    fn point_priorities_mut(&mut self) -> &mut AimAssistCollisionBonePrioritiesData {
        &mut self.point_priorities
    }
    fn point_priorities_bone_under_reticle(&self) -> &AimAssistCollisionBonePrioritiesData {
        &self.point_priorities_bone_under_reticle
    }
    fn point_priorities_bone_under_reticle_mut(&mut self) -> &mut AimAssistCollisionBonePrioritiesData {
        &mut self.point_priorities_bone_under_reticle
    }
}

pub static AIMASSISTCOLLISIONBONESNAPAIMDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBoneSnapAimData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimAssistCollisionBoneSnapAimData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Bounding_LengthScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, bounding_length_scale),
            },
            FieldInfoData {
                name: "Bounding_RadiusScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, bounding_radius_scale),
            },
            FieldInfoData {
                name: "Point_LengthScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, point_length_scale),
            },
            FieldInfoData {
                name: "Point_Priorities",
                flags: MemberInfoFlags::new(0),
                field_type: "AimAssistCollisionBonePrioritiesData",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, point_priorities),
            },
            FieldInfoData {
                name: "Point_Priorities_BoneUnderReticle",
                flags: MemberInfoFlags::new(0),
                field_type: "AimAssistCollisionBonePrioritiesData",
                rust_offset: offset_of!(AimAssistCollisionBoneSnapAimData, point_priorities_bone_under_reticle),
            },
        ],
    }),
    array_type: Some(AIMASSISTCOLLISIONBONESNAPAIMDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AimAssistCollisionBoneSnapAimData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMASSISTCOLLISIONBONESNAPAIMDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIMASSISTCOLLISIONBONESNAPAIMDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBoneSnapAimData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AimAssistCollisionBoneSnapAimData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AimAssistCollisionBonePrioritiesData {
    pub start_priority: i32,
    pub mid_priority: i32,
    pub end_priority: i32,
}

pub trait AimAssistCollisionBonePrioritiesDataTrait: TypeObject {
    fn start_priority(&self) -> &i32;
    fn start_priority_mut(&mut self) -> &mut i32;
    fn mid_priority(&self) -> &i32;
    fn mid_priority_mut(&mut self) -> &mut i32;
    fn end_priority(&self) -> &i32;
    fn end_priority_mut(&mut self) -> &mut i32;
}

impl AimAssistCollisionBonePrioritiesDataTrait for AimAssistCollisionBonePrioritiesData {
    fn start_priority(&self) -> &i32 {
        &self.start_priority
    }
    fn start_priority_mut(&mut self) -> &mut i32 {
        &mut self.start_priority
    }
    fn mid_priority(&self) -> &i32 {
        &self.mid_priority
    }
    fn mid_priority_mut(&mut self) -> &mut i32 {
        &mut self.mid_priority
    }
    fn end_priority(&self) -> &i32 {
        &self.end_priority
    }
    fn end_priority_mut(&mut self) -> &mut i32 {
        &mut self.end_priority
    }
}

pub static AIMASSISTCOLLISIONBONEPRIORITIESDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBonePrioritiesData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AimAssistCollisionBonePrioritiesData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimAssistCollisionBonePrioritiesData, start_priority),
            },
            FieldInfoData {
                name: "MidPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimAssistCollisionBonePrioritiesData, mid_priority),
            },
            FieldInfoData {
                name: "EndPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AimAssistCollisionBonePrioritiesData, end_priority),
            },
        ],
    }),
    array_type: Some(AIMASSISTCOLLISIONBONEPRIORITIESDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AimAssistCollisionBonePrioritiesData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMASSISTCOLLISIONBONEPRIORITIESDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIMASSISTCOLLISIONBONEPRIORITIESDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AimAssistCollisionBonePrioritiesData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AimAssistCollisionBonePrioritiesData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum HitReactionType {
    #[default]
    HRT_Body = 0,
    HRT_Head = 1,
    HRT_RightArm = 2,
    HRT_LeftArm = 3,
    HRT_RightLeg = 4,
    HRT_LeftLeg = 5,
    HRT_Count = 6,
}

pub static HITREACTIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(HITREACTIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for HitReactionType {
    fn type_info(&self) -> &'static TypeInfo {
        HITREACTIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static HITREACTIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HitReactionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HitReactionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PitchModifier {
    pub pitch_val: f32,
    pub offset: super::core::Vec3,
    pub pitch_angle: f32,
}

pub trait PitchModifierTrait: TypeObject {
    fn pitch_val(&self) -> &f32;
    fn pitch_val_mut(&mut self) -> &mut f32;
    fn offset(&self) -> &super::core::Vec3;
    fn offset_mut(&mut self) -> &mut super::core::Vec3;
    fn pitch_angle(&self) -> &f32;
    fn pitch_angle_mut(&mut self) -> &mut f32;
}

impl PitchModifierTrait for PitchModifier {
    fn pitch_val(&self) -> &f32 {
        &self.pitch_val
    }
    fn pitch_val_mut(&mut self) -> &mut f32 {
        &mut self.pitch_val
    }
    fn offset(&self) -> &super::core::Vec3 {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.offset
    }
    fn pitch_angle(&self) -> &f32 {
        &self.pitch_angle
    }
    fn pitch_angle_mut(&mut self) -> &mut f32 {
        &mut self.pitch_angle
    }
}

pub static PITCHMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PitchModifier",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PitchModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PitchVal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PitchModifier, pitch_val),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PitchModifier, offset),
            },
            FieldInfoData {
                name: "PitchAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PitchModifier, pitch_angle),
            },
        ],
    }),
    array_type: Some(PITCHMODIFIER_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PitchModifier {
    fn type_info(&self) -> &'static TypeInfo {
        PITCHMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PITCHMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PitchModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PitchModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ActionSuppressor {
    pub action_to_suppress: i32,
    pub suppressing_value: f32,
}

pub trait ActionSuppressorTrait: TypeObject {
    fn action_to_suppress(&self) -> &i32;
    fn action_to_suppress_mut(&mut self) -> &mut i32;
    fn suppressing_value(&self) -> &f32;
    fn suppressing_value_mut(&mut self) -> &mut f32;
}

impl ActionSuppressorTrait for ActionSuppressor {
    fn action_to_suppress(&self) -> &i32 {
        &self.action_to_suppress
    }
    fn action_to_suppress_mut(&mut self) -> &mut i32 {
        &mut self.action_to_suppress
    }
    fn suppressing_value(&self) -> &f32 {
        &self.suppressing_value
    }
    fn suppressing_value_mut(&mut self) -> &mut f32 {
        &mut self.suppressing_value
    }
}

pub static ACTIONSUPPRESSOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActionSuppressor",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ActionSuppressor as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActionToSuppress",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ActionSuppressor, action_to_suppress),
            },
            FieldInfoData {
                name: "SuppressingValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ActionSuppressor, suppressing_value),
            },
        ],
    }),
    array_type: Some(ACTIONSUPPRESSOR_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ActionSuppressor {
    fn type_info(&self) -> &'static TypeInfo {
        ACTIONSUPPRESSOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ACTIONSUPPRESSOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActionSuppressor-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ActionSuppressor"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GroupComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait GroupComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl GroupComponentDataTrait for GroupComponentData {
}

impl super::entity::GameComponentDataTrait for GroupComponentData {
}

impl super::entity::ComponentDataTrait for GroupComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for GroupComponentData {
}

impl super::core::DataBusPeerTrait for GroupComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GroupComponentData {
}

impl super::core::DataContainerTrait for GroupComponentData {
}

pub static GROUPCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroupComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GroupComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GROUPCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GroupComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        GROUPCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GROUPCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GroupComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GroupComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ColorPalette {
    pub _glacier_base: super::core::Asset,
    pub source_path: String,
    pub entries: Vec<super::core::Vec3>,
}

pub trait ColorPaletteTrait: super::core::AssetTrait {
    fn source_path(&self) -> &String;
    fn source_path_mut(&mut self) -> &mut String;
    fn entries(&self) -> &Vec<super::core::Vec3>;
    fn entries_mut(&mut self) -> &mut Vec<super::core::Vec3>;
}

impl ColorPaletteTrait for ColorPalette {
    fn source_path(&self) -> &String {
        &self.source_path
    }
    fn source_path_mut(&mut self) -> &mut String {
        &mut self.source_path
    }
    fn entries(&self) -> &Vec<super::core::Vec3> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.entries
    }
}

impl super::core::AssetTrait for ColorPalette {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ColorPalette {
}

pub static COLORPALETTE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorPalette",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ColorPalette as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SourcePath",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ColorPalette, source_path),
            },
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(ColorPalette, entries),
            },
        ],
    }),
    array_type: Some(COLORPALETTE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ColorPalette {
    fn type_info(&self) -> &'static TypeInfo {
        COLORPALETTE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLORPALETTE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ColorPalette-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ColorPalette"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OBBCollisionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub enabled: bool,
    pub half_extents: super::core::Vec3,
    pub physics_bodies: Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>>,
    pub collision_layer: super::physics::RigidBodyCollisionLayer,
    pub material: super::entity::MaterialDecl,
}

pub trait OBBCollisionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn half_extents(&self) -> &super::core::Vec3;
    fn half_extents_mut(&mut self) -> &mut super::core::Vec3;
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>>;
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>>;
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer;
    fn collision_layer_mut(&mut self) -> &mut super::physics::RigidBodyCollisionLayer;
    fn material(&self) -> &super::entity::MaterialDecl;
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl;
}

impl OBBCollisionEntityDataTrait for OBBCollisionEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn half_extents(&self) -> &super::core::Vec3 {
        &self.half_extents
    }
    fn half_extents_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.half_extents
    }
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>> {
        &self.physics_bodies
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>> {
        &mut self.physics_bodies
    }
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer {
        &self.collision_layer
    }
    fn collision_layer_mut(&mut self) -> &mut super::physics::RigidBodyCollisionLayer {
        &mut self.collision_layer
    }
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material
    }
}

impl super::entity::SpatialEntityDataTrait for OBBCollisionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for OBBCollisionEntityData {
}

impl super::entity::GameObjectDataTrait for OBBCollisionEntityData {
}

impl super::core::DataBusPeerTrait for OBBCollisionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for OBBCollisionEntityData {
}

impl super::core::DataContainerTrait for OBBCollisionEntityData {
}

pub static OBBCOLLISIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OBBCollisionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OBBCollisionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OBBCollisionEntityData, enabled),
            },
            FieldInfoData {
                name: "HalfExtents",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(OBBCollisionEntityData, half_extents),
            },
            FieldInfoData {
                name: "PhysicsBodies",
                flags: MemberInfoFlags::new(144),
                field_type: "EntityData-Array",
                rust_offset: offset_of!(OBBCollisionEntityData, physics_bodies),
            },
            FieldInfoData {
                name: "CollisionLayer",
                flags: MemberInfoFlags::new(0),
                field_type: "RigidBodyCollisionLayer",
                rust_offset: offset_of!(OBBCollisionEntityData, collision_layer),
            },
            FieldInfoData {
                name: "Material",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(OBBCollisionEntityData, material),
            },
        ],
    }),
    array_type: Some(OBBCOLLISIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for OBBCollisionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        OBBCOLLISIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBBCOLLISIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OBBCollisionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("OBBCollisionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SphereCollisionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub enabled: bool,
    pub position: super::core::Vec3,
    pub radius: f32,
    pub physics_bodies: Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>>,
    pub collision_layer: super::physics::RigidBodyCollisionLayer,
    pub material: super::entity::MaterialDecl,
}

pub trait SphereCollisionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>>;
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>>;
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer;
    fn collision_layer_mut(&mut self) -> &mut super::physics::RigidBodyCollisionLayer;
    fn material(&self) -> &super::entity::MaterialDecl;
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl;
}

impl SphereCollisionEntityDataTrait for SphereCollisionEntityData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>> {
        &self.physics_bodies
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>>> {
        &mut self.physics_bodies
    }
    fn collision_layer(&self) -> &super::physics::RigidBodyCollisionLayer {
        &self.collision_layer
    }
    fn collision_layer_mut(&mut self) -> &mut super::physics::RigidBodyCollisionLayer {
        &mut self.collision_layer
    }
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material
    }
}

impl super::entity::SpatialEntityDataTrait for SphereCollisionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for SphereCollisionEntityData {
}

impl super::entity::GameObjectDataTrait for SphereCollisionEntityData {
}

impl super::core::DataBusPeerTrait for SphereCollisionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SphereCollisionEntityData {
}

impl super::core::DataContainerTrait for SphereCollisionEntityData {
}

pub static SPHERECOLLISIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereCollisionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SphereCollisionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SphereCollisionEntityData, enabled),
            },
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SphereCollisionEntityData, position),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SphereCollisionEntityData, radius),
            },
            FieldInfoData {
                name: "PhysicsBodies",
                flags: MemberInfoFlags::new(144),
                field_type: "EntityData-Array",
                rust_offset: offset_of!(SphereCollisionEntityData, physics_bodies),
            },
            FieldInfoData {
                name: "CollisionLayer",
                flags: MemberInfoFlags::new(0),
                field_type: "RigidBodyCollisionLayer",
                rust_offset: offset_of!(SphereCollisionEntityData, collision_layer),
            },
            FieldInfoData {
                name: "Material",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(SphereCollisionEntityData, material),
            },
        ],
    }),
    array_type: Some(SPHERECOLLISIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SphereCollisionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPHERECOLLISIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPHERECOLLISIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereCollisionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SphereCollisionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientGameSettings {
    pub _glacier_base: super::core::SystemSettings,
    pub on_damage_spotting_enabled: bool,
    pub ignore_client_fire_rate_multiplier: bool,
    pub async_client_bullet_entity: bool,
    pub client_bullets_per_query: u32,
    pub debug_track_all_players_in_spawn_screen: bool,
    pub use_old_killer_camera: bool,
}

pub trait ClientGameSettingsTrait: super::core::SystemSettingsTrait {
    fn on_damage_spotting_enabled(&self) -> &bool;
    fn on_damage_spotting_enabled_mut(&mut self) -> &mut bool;
    fn ignore_client_fire_rate_multiplier(&self) -> &bool;
    fn ignore_client_fire_rate_multiplier_mut(&mut self) -> &mut bool;
    fn async_client_bullet_entity(&self) -> &bool;
    fn async_client_bullet_entity_mut(&mut self) -> &mut bool;
    fn client_bullets_per_query(&self) -> &u32;
    fn client_bullets_per_query_mut(&mut self) -> &mut u32;
    fn debug_track_all_players_in_spawn_screen(&self) -> &bool;
    fn debug_track_all_players_in_spawn_screen_mut(&mut self) -> &mut bool;
    fn use_old_killer_camera(&self) -> &bool;
    fn use_old_killer_camera_mut(&mut self) -> &mut bool;
}

impl ClientGameSettingsTrait for ClientGameSettings {
    fn on_damage_spotting_enabled(&self) -> &bool {
        &self.on_damage_spotting_enabled
    }
    fn on_damage_spotting_enabled_mut(&mut self) -> &mut bool {
        &mut self.on_damage_spotting_enabled
    }
    fn ignore_client_fire_rate_multiplier(&self) -> &bool {
        &self.ignore_client_fire_rate_multiplier
    }
    fn ignore_client_fire_rate_multiplier_mut(&mut self) -> &mut bool {
        &mut self.ignore_client_fire_rate_multiplier
    }
    fn async_client_bullet_entity(&self) -> &bool {
        &self.async_client_bullet_entity
    }
    fn async_client_bullet_entity_mut(&mut self) -> &mut bool {
        &mut self.async_client_bullet_entity
    }
    fn client_bullets_per_query(&self) -> &u32 {
        &self.client_bullets_per_query
    }
    fn client_bullets_per_query_mut(&mut self) -> &mut u32 {
        &mut self.client_bullets_per_query
    }
    fn debug_track_all_players_in_spawn_screen(&self) -> &bool {
        &self.debug_track_all_players_in_spawn_screen
    }
    fn debug_track_all_players_in_spawn_screen_mut(&mut self) -> &mut bool {
        &mut self.debug_track_all_players_in_spawn_screen
    }
    fn use_old_killer_camera(&self) -> &bool {
        &self.use_old_killer_camera
    }
    fn use_old_killer_camera_mut(&mut self) -> &mut bool {
        &mut self.use_old_killer_camera
    }
}

impl super::core::SystemSettingsTrait for ClientGameSettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        self._glacier_base.platform_mut()
    }
}

impl super::core::DataContainerTrait for ClientGameSettings {
}

pub static CLIENTGAMESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientGameSettings",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientGameSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OnDamageSpottingEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, on_damage_spotting_enabled),
            },
            FieldInfoData {
                name: "IgnoreClientFireRateMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, ignore_client_fire_rate_multiplier),
            },
            FieldInfoData {
                name: "AsyncClientBulletEntity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, async_client_bullet_entity),
            },
            FieldInfoData {
                name: "ClientBulletsPerQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ClientGameSettings, client_bullets_per_query),
            },
            FieldInfoData {
                name: "DebugTrackAllPlayersInSpawnScreen",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, debug_track_all_players_in_spawn_screen),
            },
            FieldInfoData {
                name: "UseOldKillerCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientGameSettings, use_old_killer_camera),
            },
        ],
    }),
    array_type: Some(CLIENTGAMESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientGameSettings {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTGAMESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTGAMESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientGameSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClientGameSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterToComponentsOnKilledMessage {
}

pub trait CharacterToComponentsOnKilledMessageTrait: TypeObject {
}

impl CharacterToComponentsOnKilledMessageTrait for CharacterToComponentsOnKilledMessage {
}

pub static CHARACTERTOCOMPONENTSONKILLEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterToComponentsOnKilledMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterToComponentsOnKilledMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for CharacterToComponentsOnKilledMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERTOCOMPONENTSONKILLEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct CharacterEntityData {
    pub _glacier_base: super::gameplay_sim::ControllableEntityData,
    pub max_health: f32,
    pub default_view_mode: PersonViewMode,
    pub player_spawn_type: PlayerSpawnType,
    pub character_lighting_enable: bool,
    pub voice_over_info: Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>>,
    pub sound: Option<Arc<Mutex<dyn CharacterSoundDataTrait>>>,
}

pub trait CharacterEntityDataTrait: super::gameplay_sim::ControllableEntityDataTrait {
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn default_view_mode(&self) -> &PersonViewMode;
    fn default_view_mode_mut(&mut self) -> &mut PersonViewMode;
    fn player_spawn_type(&self) -> &PlayerSpawnType;
    fn player_spawn_type_mut(&mut self) -> &mut PlayerSpawnType;
    fn character_lighting_enable(&self) -> &bool;
    fn character_lighting_enable_mut(&mut self) -> &mut bool;
    fn voice_over_info(&self) -> &Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>>;
    fn voice_over_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>>;
    fn sound(&self) -> &Option<Arc<Mutex<dyn CharacterSoundDataTrait>>>;
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterSoundDataTrait>>>;
}

impl CharacterEntityDataTrait for CharacterEntityData {
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn default_view_mode(&self) -> &PersonViewMode {
        &self.default_view_mode
    }
    fn default_view_mode_mut(&mut self) -> &mut PersonViewMode {
        &mut self.default_view_mode
    }
    fn player_spawn_type(&self) -> &PlayerSpawnType {
        &self.player_spawn_type
    }
    fn player_spawn_type_mut(&mut self) -> &mut PlayerSpawnType {
        &mut self.player_spawn_type
    }
    fn character_lighting_enable(&self) -> &bool {
        &self.character_lighting_enable
    }
    fn character_lighting_enable_mut(&mut self) -> &mut bool {
        &mut self.character_lighting_enable
    }
    fn voice_over_info(&self) -> &Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        &self.voice_over_info
    }
    fn voice_over_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        &mut self.voice_over_info
    }
    fn sound(&self) -> &Option<Arc<Mutex<dyn CharacterSoundDataTrait>>> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterSoundDataTrait>>> {
        &mut self.sound
    }
}

impl super::gameplay_sim::ControllableEntityDataTrait for CharacterEntityData {
    fn use_prediction(&self) -> &bool {
        self._glacier_base.use_prediction()
    }
    fn use_prediction_mut(&mut self) -> &mut bool {
        self._glacier_base.use_prediction_mut()
    }
    fn default_team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.default_team()
    }
    fn default_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.default_team_mut()
    }
    fn reset_team_on_last_player_exits(&self) -> &bool {
        self._glacier_base.reset_team_on_last_player_exits()
    }
    fn reset_team_on_last_player_exits_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_team_on_last_player_exits_mut()
    }
    fn immortal(&self) -> &bool {
        self._glacier_base.immortal()
    }
    fn immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.immortal_mut()
    }
    fn fake_immortal(&self) -> &bool {
        self._glacier_base.fake_immortal()
    }
    fn fake_immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.fake_immortal_mut()
    }
    fn low_health_threshold(&self) -> &f32 {
        self._glacier_base.low_health_threshold()
    }
    fn low_health_threshold_mut(&mut self) -> &mut f32 {
        self._glacier_base.low_health_threshold_mut()
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        self._glacier_base.material_pair()
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        self._glacier_base.material_pair_mut()
    }
    fn force_foreground_rendering(&self) -> &bool {
        self._glacier_base.force_foreground_rendering()
    }
    fn force_foreground_rendering_mut(&mut self) -> &mut bool {
        self._glacier_base.force_foreground_rendering_mut()
    }
    fn suppressed_inputs(&self) -> &Vec<i32> {
        self._glacier_base.suppressed_inputs()
    }
    fn suppressed_inputs_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.suppressed_inputs_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for CharacterEntityData {
}

impl super::entity::GameComponentEntityDataTrait for CharacterEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for CharacterEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for CharacterEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CharacterEntityData {
}

impl super::entity::GameObjectDataTrait for CharacterEntityData {
}

impl super::core::DataBusPeerTrait for CharacterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterEntityData {
}

impl super::core::DataContainerTrait for CharacterEntityData {
}

pub static CHARACTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterEntityData, max_health),
            },
            FieldInfoData {
                name: "DefaultViewMode",
                flags: MemberInfoFlags::new(0),
                field_type: "PersonViewMode",
                rust_offset: offset_of!(CharacterEntityData, default_view_mode),
            },
            FieldInfoData {
                name: "PlayerSpawnType",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayerSpawnType",
                rust_offset: offset_of!(CharacterEntityData, player_spawn_type),
            },
            FieldInfoData {
                name: "CharacterLightingEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterEntityData, character_lighting_enable),
            },
            FieldInfoData {
                name: "VoiceOverInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "EntityVoiceOverInfo",
                rust_offset: offset_of!(CharacterEntityData, voice_over_info),
            },
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterSoundData",
                rust_offset: offset_of!(CharacterEntityData, sound),
            },
        ],
    }),
    array_type: Some(CHARACTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterSoundData {
    pub _glacier_base: super::core::DataContainer,
    pub movement: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
}

pub trait CharacterSoundDataTrait: super::core::DataContainerTrait {
    fn movement(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn movement_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
}

impl CharacterSoundDataTrait for CharacterSoundData {
    fn movement(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.movement
    }
    fn movement_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.movement
    }
}

impl super::core::DataContainerTrait for CharacterSoundData {
}

pub static CHARACTERSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSoundData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterSoundData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Movement",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(CharacterSoundData, movement),
            },
        ],
    }),
    array_type: Some(CHARACTERSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSoundData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PersonViewMode {
    #[default]
    PersonViewMode_FirstPerson = 0,
    PersonViewMode_ThirdPerson = 1,
    PersonViewModeCount = 2,
}

pub static PERSONVIEWMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersonViewMode",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PERSONVIEWMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PersonViewMode {
    fn type_info(&self) -> &'static TypeInfo {
        PERSONVIEWMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PERSONVIEWMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PersonViewMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PersonViewMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterEntityDeathType {
    #[default]
    CharacterEntityDeathType_Shot = 0,
    CharacterEntityDeathType_ShotInVehicleEntry = 1,
    CharacterEntityDeathType_InsideExplodingVehicle = 2,
}

pub static CHARACTERENTITYDEATHTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityDeathType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERENTITYDEATHTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterEntityDeathType {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERENTITYDEATHTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHARACTERENTITYDEATHTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityDeathType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterEntityDeathType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterEntityHitDirection {
    #[default]
    CharacterEntityHitDirection_Front = 0,
    CharacterEntityHitDirection_Right = 1,
    CharacterEntityHitDirection_Left = 2,
    CharacterEntityHitDirection_Back = 3,
    CharacterEntityHitDirection_None = 4,
}

pub static CHARACTERENTITYHITDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityHitDirection",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERENTITYHITDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterEntityHitDirection {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERENTITYHITDIRECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHARACTERENTITYHITDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntityHitDirection-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterEntityHitDirection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterMeshComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub enable_updates: bool,
}

pub trait CharacterMeshComponentDataTrait: super::entity::GameComponentDataTrait {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn enable_updates(&self) -> &bool;
    fn enable_updates_mut(&mut self) -> &mut bool;
}

impl CharacterMeshComponentDataTrait for CharacterMeshComponentData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn enable_updates(&self) -> &bool {
        &self.enable_updates
    }
    fn enable_updates_mut(&mut self) -> &mut bool {
        &mut self.enable_updates
    }
}

impl super::entity::GameComponentDataTrait for CharacterMeshComponentData {
}

impl super::entity::ComponentDataTrait for CharacterMeshComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterMeshComponentData {
}

impl super::core::DataBusPeerTrait for CharacterMeshComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterMeshComponentData {
}

impl super::core::DataContainerTrait for CharacterMeshComponentData {
}

pub static CHARACTERMESHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterMeshComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterMeshComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(CharacterMeshComponentData, mesh),
            },
            FieldInfoData {
                name: "EnableUpdates",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterMeshComponentData, enable_updates),
            },
        ],
    }),
    array_type: Some(CHARACTERMESHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterMeshComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERMESHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERMESHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterMeshComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterMeshComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterCustomizationComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub customization: Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>>,
    pub visual_unlock: Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>,
    pub character_lighting_enable: bool,
}

pub trait CharacterCustomizationComponentDataTrait: super::entity::GameComponentDataTrait {
    fn customization(&self) -> &Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>>;
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>>;
    fn visual_unlock(&self) -> &Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>;
    fn visual_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>;
    fn character_lighting_enable(&self) -> &bool;
    fn character_lighting_enable_mut(&mut self) -> &mut bool;
}

impl CharacterCustomizationComponentDataTrait for CharacterCustomizationComponentData {
    fn customization(&self) -> &Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterCustomizationAssetTrait>>> {
        &mut self.customization
    }
    fn visual_unlock(&self) -> &Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>> {
        &self.visual_unlock
    }
    fn visual_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>> {
        &mut self.visual_unlock
    }
    fn character_lighting_enable(&self) -> &bool {
        &self.character_lighting_enable
    }
    fn character_lighting_enable_mut(&mut self) -> &mut bool {
        &mut self.character_lighting_enable
    }
}

impl super::entity::GameComponentDataTrait for CharacterCustomizationComponentData {
}

impl super::entity::ComponentDataTrait for CharacterCustomizationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterCustomizationComponentData {
}

impl super::core::DataBusPeerTrait for CharacterCustomizationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterCustomizationComponentData {
}

impl super::core::DataContainerTrait for CharacterCustomizationComponentData {
}

pub static CHARACTERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCustomizationComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterCustomizationComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Customization",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterCustomizationAsset",
                rust_offset: offset_of!(CharacterCustomizationComponentData, customization),
            },
            FieldInfoData {
                name: "VisualUnlock",
                flags: MemberInfoFlags::new(0),
                field_type: "VisualUnlockAsset",
                rust_offset: offset_of!(CharacterCustomizationComponentData, visual_unlock),
            },
            FieldInfoData {
                name: "CharacterLightingEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterCustomizationComponentData, character_lighting_enable),
            },
        ],
    }),
    array_type: Some(CHARACTERCUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterCustomizationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERCUSTOMIZATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERCUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCustomizationComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterCustomizationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterToComponentsOnActiveViewChangedMessage {
}

pub trait CharacterToComponentsOnActiveViewChangedMessageTrait: TypeObject {
}

impl CharacterToComponentsOnActiveViewChangedMessageTrait for CharacterToComponentsOnActiveViewChangedMessage {
}

pub static CHARACTERTOCOMPONENTSONACTIVEVIEWCHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterToComponentsOnActiveViewChangedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterToComponentsOnActiveViewChangedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for CharacterToComponentsOnActiveViewChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERTOCOMPONENTSONACTIVEVIEWCHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct CharacterMasterPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::ControllablePhysicsComponentData,
}

pub trait CharacterMasterPhysicsComponentDataTrait: super::gameplay_sim::ControllablePhysicsComponentDataTrait {
}

impl CharacterMasterPhysicsComponentDataTrait for CharacterMasterPhysicsComponentData {
}

impl super::gameplay_sim::ControllablePhysicsComponentDataTrait for CharacterMasterPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for CharacterMasterPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for CharacterMasterPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for CharacterMasterPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterMasterPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for CharacterMasterPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterMasterPhysicsComponentData {
}

impl super::core::DataContainerTrait for CharacterMasterPhysicsComponentData {
}

pub static CHARACTERMASTERPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterMasterPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterMasterPhysicsComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERMASTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterMasterPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERMASTERPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERMASTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterMasterPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterMasterPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraRelativeInputComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub enabled: bool,
    pub is_steering: bool,
}

pub trait CameraRelativeInputComponentDataTrait: super::entity::GameComponentDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn is_steering(&self) -> &bool;
    fn is_steering_mut(&mut self) -> &mut bool;
}

impl CameraRelativeInputComponentDataTrait for CameraRelativeInputComponentData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn is_steering(&self) -> &bool {
        &self.is_steering
    }
    fn is_steering_mut(&mut self) -> &mut bool {
        &mut self.is_steering
    }
}

impl super::entity::GameComponentDataTrait for CameraRelativeInputComponentData {
}

impl super::entity::ComponentDataTrait for CameraRelativeInputComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraRelativeInputComponentData {
}

impl super::core::DataBusPeerTrait for CameraRelativeInputComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraRelativeInputComponentData {
}

impl super::core::DataContainerTrait for CameraRelativeInputComponentData {
}

pub static CAMERARELATIVEINPUTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeInputComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraRelativeInputComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeInputComponentData, enabled),
            },
            FieldInfoData {
                name: "IsSteering",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeInputComponentData, is_steering),
            },
        ],
    }),
    array_type: Some(CAMERARELATIVEINPUTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraRelativeInputComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARELATIVEINPUTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERARELATIVEINPUTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeInputComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraRelativeInputComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterHealthComponentData {
    pub _glacier_base: super::gameplay_sim::ControllableHealthComponentData,
    pub max_health: f32,
    pub time_for_corpse: f32,
}

pub trait CharacterHealthComponentDataTrait: super::gameplay_sim::ControllableHealthComponentDataTrait {
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn time_for_corpse(&self) -> &f32;
    fn time_for_corpse_mut(&mut self) -> &mut f32;
}

impl CharacterHealthComponentDataTrait for CharacterHealthComponentData {
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn time_for_corpse(&self) -> &f32 {
        &self.time_for_corpse
    }
    fn time_for_corpse_mut(&mut self) -> &mut f32 {
        &mut self.time_for_corpse
    }
}

impl super::gameplay_sim::ControllableHealthComponentDataTrait for CharacterHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for CharacterHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for CharacterHealthComponentData {
}

impl super::entity::ComponentDataTrait for CharacterHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterHealthComponentData {
}

impl super::core::DataBusPeerTrait for CharacterHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterHealthComponentData {
}

impl super::core::DataContainerTrait for CharacterHealthComponentData {
}

pub static CHARACTERHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterHealthComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterHealthComponentData, max_health),
            },
            FieldInfoData {
                name: "TimeForCorpse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterHealthComponentData, time_for_corpse),
            },
        ],
    }),
    array_type: Some(CHARACTERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AntInputComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait AntInputComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl AntInputComponentDataTrait for AntInputComponentData {
}

impl super::entity::GameComponentDataTrait for AntInputComponentData {
}

impl super::entity::ComponentDataTrait for AntInputComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AntInputComponentData {
}

impl super::core::DataBusPeerTrait for AntInputComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AntInputComponentData {
}

impl super::core::DataContainerTrait for AntInputComponentData {
}

pub static ANTINPUTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntInputComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntInputComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ANTINPUTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AntInputComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTINPUTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTINPUTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntInputComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntInputComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AntDrivenComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub reset_controller_tree_on_teleport: bool,
    pub zero_trajectory_velocity_on_teleport: bool,
}

pub trait AntDrivenComponentDataTrait: super::entity::GameComponentDataTrait {
    fn reset_controller_tree_on_teleport(&self) -> &bool;
    fn reset_controller_tree_on_teleport_mut(&mut self) -> &mut bool;
    fn zero_trajectory_velocity_on_teleport(&self) -> &bool;
    fn zero_trajectory_velocity_on_teleport_mut(&mut self) -> &mut bool;
}

impl AntDrivenComponentDataTrait for AntDrivenComponentData {
    fn reset_controller_tree_on_teleport(&self) -> &bool {
        &self.reset_controller_tree_on_teleport
    }
    fn reset_controller_tree_on_teleport_mut(&mut self) -> &mut bool {
        &mut self.reset_controller_tree_on_teleport
    }
    fn zero_trajectory_velocity_on_teleport(&self) -> &bool {
        &self.zero_trajectory_velocity_on_teleport
    }
    fn zero_trajectory_velocity_on_teleport_mut(&mut self) -> &mut bool {
        &mut self.zero_trajectory_velocity_on_teleport
    }
}

impl super::entity::GameComponentDataTrait for AntDrivenComponentData {
}

impl super::entity::ComponentDataTrait for AntDrivenComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AntDrivenComponentData {
}

impl super::core::DataBusPeerTrait for AntDrivenComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AntDrivenComponentData {
}

impl super::core::DataContainerTrait for AntDrivenComponentData {
}

pub static ANTDRIVENCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntDrivenComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AntDrivenComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ResetControllerTreeOnTeleport",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntDrivenComponentData, reset_controller_tree_on_teleport),
            },
            FieldInfoData {
                name: "ZeroTrajectoryVelocityOnTeleport",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AntDrivenComponentData, zero_trajectory_velocity_on_teleport),
            },
        ],
    }),
    array_type: Some(ANTDRIVENCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AntDrivenComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ANTDRIVENCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANTDRIVENCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntDrivenComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntDrivenComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterPhysicsComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub character_physics: Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>>,
    pub enable_collision_on_spawn: bool,
}

pub trait CharacterPhysicsComponentDataTrait: super::entity::GameComponentDataTrait {
    fn character_physics(&self) -> &Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>>;
    fn character_physics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>>;
    fn enable_collision_on_spawn(&self) -> &bool;
    fn enable_collision_on_spawn_mut(&mut self) -> &mut bool;
}

impl CharacterPhysicsComponentDataTrait for CharacterPhysicsComponentData {
    fn character_physics(&self) -> &Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>> {
        &self.character_physics
    }
    fn character_physics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::CharacterPhysicsDataTrait>>> {
        &mut self.character_physics
    }
    fn enable_collision_on_spawn(&self) -> &bool {
        &self.enable_collision_on_spawn
    }
    fn enable_collision_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.enable_collision_on_spawn
    }
}

impl super::entity::GameComponentDataTrait for CharacterPhysicsComponentData {
}

impl super::entity::ComponentDataTrait for CharacterPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for CharacterPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterPhysicsComponentData {
}

impl super::core::DataContainerTrait for CharacterPhysicsComponentData {
}

pub static CHARACTERPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterPhysicsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CharacterPhysics",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterPhysicsData",
                rust_offset: offset_of!(CharacterPhysicsComponentData, character_physics),
            },
            FieldInfoData {
                name: "EnableCollisionOnSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterPhysicsComponentData, enable_collision_on_spawn),
            },
        ],
    }),
    array_type: Some(CHARACTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterCameraComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub cameras: Vec<Option<Arc<Mutex<dyn super::gameplay_sim::CameraDataTrait>>>>,
}

pub trait CharacterCameraComponentDataTrait: super::entity::GameComponentDataTrait {
    fn cameras(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::CameraDataTrait>>>>;
    fn cameras_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::CameraDataTrait>>>>;
}

impl CharacterCameraComponentDataTrait for CharacterCameraComponentData {
    fn cameras(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::CameraDataTrait>>>> {
        &self.cameras
    }
    fn cameras_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::CameraDataTrait>>>> {
        &mut self.cameras
    }
}

impl super::entity::GameComponentDataTrait for CharacterCameraComponentData {
}

impl super::entity::ComponentDataTrait for CharacterCameraComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterCameraComponentData {
}

impl super::core::DataBusPeerTrait for CharacterCameraComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterCameraComponentData {
}

impl super::core::DataContainerTrait for CharacterCameraComponentData {
}

pub static CHARACTERCAMERACOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCameraComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterCameraComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Cameras",
                flags: MemberInfoFlags::new(144),
                field_type: "CameraData-Array",
                rust_offset: offset_of!(CharacterCameraComponentData, cameras),
            },
        ],
    }),
    array_type: Some(CHARACTERCAMERACOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterCameraComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERCAMERACOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERCAMERACOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterCameraComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterCameraComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerCameraEntityData {
    pub _glacier_base: CameraEntityBaseData,
    pub soldier_target_mode: TargetMode,
    pub soldier_camera_index: u32,
    pub vehicle_target_mode: TargetMode,
    pub vehicle_camera_index: u32,
    pub release_control_if_target_lost: bool,
    pub should_target_controllable: bool,
    pub should_target_vehicle_driver_entry: bool,
    pub should_target_extra_player_in_double_player_event: bool,
    pub camera_smoothing_factor: f32,
}

pub trait PlayerCameraEntityDataTrait: CameraEntityBaseDataTrait {
    fn soldier_target_mode(&self) -> &TargetMode;
    fn soldier_target_mode_mut(&mut self) -> &mut TargetMode;
    fn soldier_camera_index(&self) -> &u32;
    fn soldier_camera_index_mut(&mut self) -> &mut u32;
    fn vehicle_target_mode(&self) -> &TargetMode;
    fn vehicle_target_mode_mut(&mut self) -> &mut TargetMode;
    fn vehicle_camera_index(&self) -> &u32;
    fn vehicle_camera_index_mut(&mut self) -> &mut u32;
    fn release_control_if_target_lost(&self) -> &bool;
    fn release_control_if_target_lost_mut(&mut self) -> &mut bool;
    fn should_target_controllable(&self) -> &bool;
    fn should_target_controllable_mut(&mut self) -> &mut bool;
    fn should_target_vehicle_driver_entry(&self) -> &bool;
    fn should_target_vehicle_driver_entry_mut(&mut self) -> &mut bool;
    fn should_target_extra_player_in_double_player_event(&self) -> &bool;
    fn should_target_extra_player_in_double_player_event_mut(&mut self) -> &mut bool;
    fn camera_smoothing_factor(&self) -> &f32;
    fn camera_smoothing_factor_mut(&mut self) -> &mut f32;
}

impl PlayerCameraEntityDataTrait for PlayerCameraEntityData {
    fn soldier_target_mode(&self) -> &TargetMode {
        &self.soldier_target_mode
    }
    fn soldier_target_mode_mut(&mut self) -> &mut TargetMode {
        &mut self.soldier_target_mode
    }
    fn soldier_camera_index(&self) -> &u32 {
        &self.soldier_camera_index
    }
    fn soldier_camera_index_mut(&mut self) -> &mut u32 {
        &mut self.soldier_camera_index
    }
    fn vehicle_target_mode(&self) -> &TargetMode {
        &self.vehicle_target_mode
    }
    fn vehicle_target_mode_mut(&mut self) -> &mut TargetMode {
        &mut self.vehicle_target_mode
    }
    fn vehicle_camera_index(&self) -> &u32 {
        &self.vehicle_camera_index
    }
    fn vehicle_camera_index_mut(&mut self) -> &mut u32 {
        &mut self.vehicle_camera_index
    }
    fn release_control_if_target_lost(&self) -> &bool {
        &self.release_control_if_target_lost
    }
    fn release_control_if_target_lost_mut(&mut self) -> &mut bool {
        &mut self.release_control_if_target_lost
    }
    fn should_target_controllable(&self) -> &bool {
        &self.should_target_controllable
    }
    fn should_target_controllable_mut(&mut self) -> &mut bool {
        &mut self.should_target_controllable
    }
    fn should_target_vehicle_driver_entry(&self) -> &bool {
        &self.should_target_vehicle_driver_entry
    }
    fn should_target_vehicle_driver_entry_mut(&mut self) -> &mut bool {
        &mut self.should_target_vehicle_driver_entry
    }
    fn should_target_extra_player_in_double_player_event(&self) -> &bool {
        &self.should_target_extra_player_in_double_player_event
    }
    fn should_target_extra_player_in_double_player_event_mut(&mut self) -> &mut bool {
        &mut self.should_target_extra_player_in_double_player_event
    }
    fn camera_smoothing_factor(&self) -> &f32 {
        &self.camera_smoothing_factor
    }
    fn camera_smoothing_factor_mut(&mut self) -> &mut f32 {
        &mut self.camera_smoothing_factor
    }
}

impl CameraEntityBaseDataTrait for PlayerCameraEntityData {
    fn name_id(&self) -> &String {
        self._glacier_base.name_id()
    }
    fn name_id_mut(&mut self) -> &mut String {
        self._glacier_base.name_id_mut()
    }
    fn priority(&self) -> &i32 {
        self._glacier_base.priority()
    }
    fn priority_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn object_layers_mask(&self) -> &i32 {
        self._glacier_base.object_layers_mask()
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        self._glacier_base.object_layers_mask_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn focal_length(&self) -> &f32 {
        self._glacier_base.focal_length()
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.focal_length_mut()
    }
    fn focus_distance(&self) -> &f32 {
        self._glacier_base.focus_distance()
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.focus_distance_mut()
    }
    fn exposure_compensation(&self) -> &f32 {
        self._glacier_base.exposure_compensation()
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        self._glacier_base.exposure_compensation_mut()
    }
    fn aperture(&self) -> &f32 {
        self._glacier_base.aperture()
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        self._glacier_base.aperture_mut()
    }
    fn shutter_speed(&self) -> &f32 {
        self._glacier_base.shutter_speed()
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.shutter_speed_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn e_v(&self) -> &f32 {
        self._glacier_base.e_v()
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        self._glacier_base.e_v_mut()
    }
    fn i_s_o(&self) -> &f32 {
        self._glacier_base.i_s_o()
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        self._glacier_base.i_s_o_mut()
    }
    fn spot_meter_scale(&self) -> &f32 {
        self._glacier_base.spot_meter_scale()
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_scale_mut()
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_x()
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_x_mut()
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_y()
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_y_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn render_target(&self) -> &Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        self._glacier_base.render_target()
    }
    fn render_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        self._glacier_base.render_target_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for PlayerCameraEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PlayerCameraEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerCameraEntityData {
}

impl super::core::DataBusPeerTrait for PlayerCameraEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerCameraEntityData {
}

impl super::core::DataContainerTrait for PlayerCameraEntityData {
}

pub static PLAYERCAMERAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerCameraEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERAENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerCameraEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoldierTargetMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetMode",
                rust_offset: offset_of!(PlayerCameraEntityData, soldier_target_mode),
            },
            FieldInfoData {
                name: "SoldierCameraIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerCameraEntityData, soldier_camera_index),
            },
            FieldInfoData {
                name: "VehicleTargetMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetMode",
                rust_offset: offset_of!(PlayerCameraEntityData, vehicle_target_mode),
            },
            FieldInfoData {
                name: "VehicleCameraIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PlayerCameraEntityData, vehicle_camera_index),
            },
            FieldInfoData {
                name: "ReleaseControlIfTargetLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerCameraEntityData, release_control_if_target_lost),
            },
            FieldInfoData {
                name: "ShouldTargetControllable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerCameraEntityData, should_target_controllable),
            },
            FieldInfoData {
                name: "ShouldTargetVehicleDriverEntry",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerCameraEntityData, should_target_vehicle_driver_entry),
            },
            FieldInfoData {
                name: "ShouldTargetExtraPlayerInDoublePlayerEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerCameraEntityData, should_target_extra_player_in_double_player_event),
            },
            FieldInfoData {
                name: "CameraSmoothingFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerCameraEntityData, camera_smoothing_factor),
            },
        ],
    }),
    array_type: Some(PLAYERCAMERAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerCameraEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERCAMERAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERCAMERAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerCameraEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerCameraEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TargetMode {
    #[default]
    TargetMode_FirstPerson = 0,
    TargetMode_ThirdPerson = 1,
    TargetMode_Index = 2,
}

pub static TARGETMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetMode",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(TARGETMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TargetMode {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TARGETMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TargetMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TargetCameraEntityData {
    pub _glacier_base: CameraEntityBaseData,
    pub camera: Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>>,
    pub offset_transform: super::core::LinearTransform,
    pub f_o_v: f32,
}

pub trait TargetCameraEntityDataTrait: CameraEntityBaseDataTrait {
    fn camera(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>>;
    fn camera_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>>;
    fn offset_transform(&self) -> &super::core::LinearTransform;
    fn offset_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn f_o_v(&self) -> &f32;
    fn f_o_v_mut(&mut self) -> &mut f32;
}

impl TargetCameraEntityDataTrait for TargetCameraEntityData {
    fn camera(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>> {
        &self.camera
    }
    fn camera_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>> {
        &mut self.camera
    }
    fn offset_transform(&self) -> &super::core::LinearTransform {
        &self.offset_transform
    }
    fn offset_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.offset_transform
    }
    fn f_o_v(&self) -> &f32 {
        &self.f_o_v
    }
    fn f_o_v_mut(&mut self) -> &mut f32 {
        &mut self.f_o_v
    }
}

impl CameraEntityBaseDataTrait for TargetCameraEntityData {
    fn name_id(&self) -> &String {
        self._glacier_base.name_id()
    }
    fn name_id_mut(&mut self) -> &mut String {
        self._glacier_base.name_id_mut()
    }
    fn priority(&self) -> &i32 {
        self._glacier_base.priority()
    }
    fn priority_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn object_layers_mask(&self) -> &i32 {
        self._glacier_base.object_layers_mask()
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        self._glacier_base.object_layers_mask_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn focal_length(&self) -> &f32 {
        self._glacier_base.focal_length()
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.focal_length_mut()
    }
    fn focus_distance(&self) -> &f32 {
        self._glacier_base.focus_distance()
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.focus_distance_mut()
    }
    fn exposure_compensation(&self) -> &f32 {
        self._glacier_base.exposure_compensation()
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        self._glacier_base.exposure_compensation_mut()
    }
    fn aperture(&self) -> &f32 {
        self._glacier_base.aperture()
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        self._glacier_base.aperture_mut()
    }
    fn shutter_speed(&self) -> &f32 {
        self._glacier_base.shutter_speed()
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.shutter_speed_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn e_v(&self) -> &f32 {
        self._glacier_base.e_v()
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        self._glacier_base.e_v_mut()
    }
    fn i_s_o(&self) -> &f32 {
        self._glacier_base.i_s_o()
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        self._glacier_base.i_s_o_mut()
    }
    fn spot_meter_scale(&self) -> &f32 {
        self._glacier_base.spot_meter_scale()
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_scale_mut()
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_x()
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_x_mut()
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_y()
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_y_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn render_target(&self) -> &Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        self._glacier_base.render_target()
    }
    fn render_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        self._glacier_base.render_target_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for TargetCameraEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TargetCameraEntityData {
}

impl super::entity::GameObjectDataTrait for TargetCameraEntityData {
}

impl super::core::DataBusPeerTrait for TargetCameraEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TargetCameraEntityData {
}

impl super::core::DataContainerTrait for TargetCameraEntityData {
}

pub static TARGETCAMERAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCameraEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERAENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TargetCameraEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Camera",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetCameraData",
                rust_offset: offset_of!(TargetCameraEntityData, camera),
            },
            FieldInfoData {
                name: "OffsetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(TargetCameraEntityData, offset_transform),
            },
            FieldInfoData {
                name: "FOV",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetCameraEntityData, f_o_v),
            },
        ],
    }),
    array_type: Some(TARGETCAMERAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TargetCameraEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETCAMERAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TARGETCAMERAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCameraEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TargetCameraEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LookAtCameraEntityData {
    pub _glacier_base: CameraEntityData,
}

pub trait LookAtCameraEntityDataTrait: CameraEntityDataTrait {
}

impl LookAtCameraEntityDataTrait for LookAtCameraEntityData {
}

impl CameraEntityDataTrait for LookAtCameraEntityData {
    fn fov(&self) -> &f32 {
        self._glacier_base.fov()
    }
    fn fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.fov_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn far_plane(&self) -> &f32 {
        self._glacier_base.far_plane()
    }
    fn far_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.far_plane_mut()
    }
}

impl CameraEntityBaseDataTrait for LookAtCameraEntityData {
    fn name_id(&self) -> &String {
        self._glacier_base.name_id()
    }
    fn name_id_mut(&mut self) -> &mut String {
        self._glacier_base.name_id_mut()
    }
    fn priority(&self) -> &i32 {
        self._glacier_base.priority()
    }
    fn priority_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn object_layers_mask(&self) -> &i32 {
        self._glacier_base.object_layers_mask()
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        self._glacier_base.object_layers_mask_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn focal_length(&self) -> &f32 {
        self._glacier_base.focal_length()
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.focal_length_mut()
    }
    fn focus_distance(&self) -> &f32 {
        self._glacier_base.focus_distance()
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.focus_distance_mut()
    }
    fn exposure_compensation(&self) -> &f32 {
        self._glacier_base.exposure_compensation()
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        self._glacier_base.exposure_compensation_mut()
    }
    fn aperture(&self) -> &f32 {
        self._glacier_base.aperture()
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        self._glacier_base.aperture_mut()
    }
    fn shutter_speed(&self) -> &f32 {
        self._glacier_base.shutter_speed()
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.shutter_speed_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn e_v(&self) -> &f32 {
        self._glacier_base.e_v()
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        self._glacier_base.e_v_mut()
    }
    fn i_s_o(&self) -> &f32 {
        self._glacier_base.i_s_o()
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        self._glacier_base.i_s_o_mut()
    }
    fn spot_meter_scale(&self) -> &f32 {
        self._glacier_base.spot_meter_scale()
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_scale_mut()
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_x()
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_x_mut()
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_y()
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_y_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn render_target(&self) -> &Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        self._glacier_base.render_target()
    }
    fn render_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        self._glacier_base.render_target_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for LookAtCameraEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LookAtCameraEntityData {
}

impl super::entity::GameObjectDataTrait for LookAtCameraEntityData {
}

impl super::core::DataBusPeerTrait for LookAtCameraEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LookAtCameraEntityData {
}

impl super::core::DataContainerTrait for LookAtCameraEntityData {
}

pub static LOOKATCAMERAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtCameraEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERAENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LookAtCameraEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOOKATCAMERAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LookAtCameraEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOOKATCAMERAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOOKATCAMERAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtCameraEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LookAtCameraEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraEntityData {
    pub _glacier_base: CameraEntityBaseData,
    pub fov: f32,
    pub near_plane: f32,
    pub far_plane: f32,
}

pub trait CameraEntityDataTrait: CameraEntityBaseDataTrait {
    fn fov(&self) -> &f32;
    fn fov_mut(&mut self) -> &mut f32;
    fn near_plane(&self) -> &f32;
    fn near_plane_mut(&mut self) -> &mut f32;
    fn far_plane(&self) -> &f32;
    fn far_plane_mut(&mut self) -> &mut f32;
}

impl CameraEntityDataTrait for CameraEntityData {
    fn fov(&self) -> &f32 {
        &self.fov
    }
    fn fov_mut(&mut self) -> &mut f32 {
        &mut self.fov
    }
    fn near_plane(&self) -> &f32 {
        &self.near_plane
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        &mut self.near_plane
    }
    fn far_plane(&self) -> &f32 {
        &self.far_plane
    }
    fn far_plane_mut(&mut self) -> &mut f32 {
        &mut self.far_plane
    }
}

impl CameraEntityBaseDataTrait for CameraEntityData {
    fn name_id(&self) -> &String {
        self._glacier_base.name_id()
    }
    fn name_id_mut(&mut self) -> &mut String {
        self._glacier_base.name_id_mut()
    }
    fn priority(&self) -> &i32 {
        self._glacier_base.priority()
    }
    fn priority_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn object_layers_mask(&self) -> &i32 {
        self._glacier_base.object_layers_mask()
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        self._glacier_base.object_layers_mask_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body()
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        self._glacier_base.physical_camera_body_mut()
    }
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens()
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        self._glacier_base.physical_camera_lens_mut()
    }
    fn focal_length(&self) -> &f32 {
        self._glacier_base.focal_length()
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.focal_length_mut()
    }
    fn focus_distance(&self) -> &f32 {
        self._glacier_base.focus_distance()
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.focus_distance_mut()
    }
    fn exposure_compensation(&self) -> &f32 {
        self._glacier_base.exposure_compensation()
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        self._glacier_base.exposure_compensation_mut()
    }
    fn aperture(&self) -> &f32 {
        self._glacier_base.aperture()
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        self._glacier_base.aperture_mut()
    }
    fn shutter_speed(&self) -> &f32 {
        self._glacier_base.shutter_speed()
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.shutter_speed_mut()
    }
    fn exposure_mode(&self) -> &ExposureMode {
        self._glacier_base.exposure_mode()
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        self._glacier_base.exposure_mode_mut()
    }
    fn e_v(&self) -> &f32 {
        self._glacier_base.e_v()
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        self._glacier_base.e_v_mut()
    }
    fn i_s_o(&self) -> &f32 {
        self._glacier_base.i_s_o()
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        self._glacier_base.i_s_o_mut()
    }
    fn spot_meter_scale(&self) -> &f32 {
        self._glacier_base.spot_meter_scale()
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_scale_mut()
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_x()
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_x_mut()
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        self._glacier_base.spot_meter_offset_y()
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        self._glacier_base.spot_meter_offset_y_mut()
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method()
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        self._glacier_base.auto_exposure_method_mut()
    }
    fn render_target(&self) -> &Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        self._glacier_base.render_target()
    }
    fn render_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        self._glacier_base.render_target_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for CameraEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CameraEntityData {
}

impl super::entity::GameObjectDataTrait for CameraEntityData {
}

impl super::core::DataBusPeerTrait for CameraEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraEntityData {
}

impl super::core::DataContainerTrait for CameraEntityData {
}

pub static CAMERAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CAMERAENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Fov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityData, fov),
            },
            FieldInfoData {
                name: "NearPlane",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityData, near_plane),
            },
            FieldInfoData {
                name: "FarPlane",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityData, far_plane),
            },
        ],
    }),
    array_type: Some(CAMERAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraEntityBaseData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub name_id: String,
    pub priority: i32,
    pub view_id: super::render_base::LocalPlayerViewId,
    pub object_layers_mask: i32,
    pub enabled: bool,
    pub physical_camera_body: Option<Arc<Mutex<dyn CameraBodyPresetTrait>>>,
    pub physical_camera_lens: Option<Arc<Mutex<dyn CameraLensPresetTrait>>>,
    pub focal_length: f32,
    pub focus_distance: f32,
    pub exposure_compensation: f32,
    pub aperture: f32,
    pub shutter_speed: f32,
    pub exposure_mode: ExposureMode,
    pub e_v: f32,
    pub i_s_o: f32,
    pub spot_meter_scale: f32,
    pub spot_meter_offset_x: f32,
    pub spot_meter_offset_y: f32,
    pub auto_exposure_method: super::render_base::AutoExposureMethod,
    pub render_target: Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>>,
    pub transition_data_pack: Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>>,
}

pub trait CameraEntityBaseDataTrait: super::entity::SpatialEntityDataTrait {
    fn name_id(&self) -> &String;
    fn name_id_mut(&mut self) -> &mut String;
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId;
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId;
    fn object_layers_mask(&self) -> &i32;
    fn object_layers_mask_mut(&mut self) -> &mut i32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>>;
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>>;
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>>;
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>>;
    fn focal_length(&self) -> &f32;
    fn focal_length_mut(&mut self) -> &mut f32;
    fn focus_distance(&self) -> &f32;
    fn focus_distance_mut(&mut self) -> &mut f32;
    fn exposure_compensation(&self) -> &f32;
    fn exposure_compensation_mut(&mut self) -> &mut f32;
    fn aperture(&self) -> &f32;
    fn aperture_mut(&mut self) -> &mut f32;
    fn shutter_speed(&self) -> &f32;
    fn shutter_speed_mut(&mut self) -> &mut f32;
    fn exposure_mode(&self) -> &ExposureMode;
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode;
    fn e_v(&self) -> &f32;
    fn e_v_mut(&mut self) -> &mut f32;
    fn i_s_o(&self) -> &f32;
    fn i_s_o_mut(&mut self) -> &mut f32;
    fn spot_meter_scale(&self) -> &f32;
    fn spot_meter_scale_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_x(&self) -> &f32;
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32;
    fn spot_meter_offset_y(&self) -> &f32;
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32;
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod;
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod;
    fn render_target(&self) -> &Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>>;
    fn render_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>>;
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>>;
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>>;
}

impl CameraEntityBaseDataTrait for CameraEntityBaseData {
    fn name_id(&self) -> &String {
        &self.name_id
    }
    fn name_id_mut(&mut self) -> &mut String {
        &mut self.name_id
    }
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        &self.view_id
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        &mut self.view_id
    }
    fn object_layers_mask(&self) -> &i32 {
        &self.object_layers_mask
    }
    fn object_layers_mask_mut(&mut self) -> &mut i32 {
        &mut self.object_layers_mask
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn physical_camera_body(&self) -> &Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        &self.physical_camera_body
    }
    fn physical_camera_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraBodyPresetTrait>>> {
        &mut self.physical_camera_body
    }
    fn physical_camera_lens(&self) -> &Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        &self.physical_camera_lens
    }
    fn physical_camera_lens_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraLensPresetTrait>>> {
        &mut self.physical_camera_lens
    }
    fn focal_length(&self) -> &f32 {
        &self.focal_length
    }
    fn focal_length_mut(&mut self) -> &mut f32 {
        &mut self.focal_length
    }
    fn focus_distance(&self) -> &f32 {
        &self.focus_distance
    }
    fn focus_distance_mut(&mut self) -> &mut f32 {
        &mut self.focus_distance
    }
    fn exposure_compensation(&self) -> &f32 {
        &self.exposure_compensation
    }
    fn exposure_compensation_mut(&mut self) -> &mut f32 {
        &mut self.exposure_compensation
    }
    fn aperture(&self) -> &f32 {
        &self.aperture
    }
    fn aperture_mut(&mut self) -> &mut f32 {
        &mut self.aperture
    }
    fn shutter_speed(&self) -> &f32 {
        &self.shutter_speed
    }
    fn shutter_speed_mut(&mut self) -> &mut f32 {
        &mut self.shutter_speed
    }
    fn exposure_mode(&self) -> &ExposureMode {
        &self.exposure_mode
    }
    fn exposure_mode_mut(&mut self) -> &mut ExposureMode {
        &mut self.exposure_mode
    }
    fn e_v(&self) -> &f32 {
        &self.e_v
    }
    fn e_v_mut(&mut self) -> &mut f32 {
        &mut self.e_v
    }
    fn i_s_o(&self) -> &f32 {
        &self.i_s_o
    }
    fn i_s_o_mut(&mut self) -> &mut f32 {
        &mut self.i_s_o
    }
    fn spot_meter_scale(&self) -> &f32 {
        &self.spot_meter_scale
    }
    fn spot_meter_scale_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_scale
    }
    fn spot_meter_offset_x(&self) -> &f32 {
        &self.spot_meter_offset_x
    }
    fn spot_meter_offset_x_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_x
    }
    fn spot_meter_offset_y(&self) -> &f32 {
        &self.spot_meter_offset_y
    }
    fn spot_meter_offset_y_mut(&mut self) -> &mut f32 {
        &mut self.spot_meter_offset_y
    }
    fn auto_exposure_method(&self) -> &super::render_base::AutoExposureMethod {
        &self.auto_exposure_method
    }
    fn auto_exposure_method_mut(&mut self) -> &mut super::render_base::AutoExposureMethod {
        &mut self.auto_exposure_method
    }
    fn render_target(&self) -> &Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        &self.render_target
    }
    fn render_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::RenderTextureBaseAssetTrait>>> {
        &mut self.render_target
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        &self.transition_data_pack
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        &mut self.transition_data_pack
    }
}

impl super::entity::SpatialEntityDataTrait for CameraEntityBaseData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CameraEntityBaseData {
}

impl super::entity::GameObjectDataTrait for CameraEntityBaseData {
}

impl super::core::DataBusPeerTrait for CameraEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraEntityBaseData {
}

impl super::core::DataContainerTrait for CameraEntityBaseData {
}

pub static CAMERAENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraEntityBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NameId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(CameraEntityBaseData, name_id),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraEntityBaseData, priority),
            },
            FieldInfoData {
                name: "ViewId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerViewId",
                rust_offset: offset_of!(CameraEntityBaseData, view_id),
            },
            FieldInfoData {
                name: "ObjectLayersMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraEntityBaseData, object_layers_mask),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraEntityBaseData, enabled),
            },
            FieldInfoData {
                name: "PhysicalCameraBody",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraBodyPreset",
                rust_offset: offset_of!(CameraEntityBaseData, physical_camera_body),
            },
            FieldInfoData {
                name: "PhysicalCameraLens",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraLensPreset",
                rust_offset: offset_of!(CameraEntityBaseData, physical_camera_lens),
            },
            FieldInfoData {
                name: "FocalLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, focal_length),
            },
            FieldInfoData {
                name: "FocusDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, focus_distance),
            },
            FieldInfoData {
                name: "ExposureCompensation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, exposure_compensation),
            },
            FieldInfoData {
                name: "Aperture",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, aperture),
            },
            FieldInfoData {
                name: "ShutterSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, shutter_speed),
            },
            FieldInfoData {
                name: "ExposureMode",
                flags: MemberInfoFlags::new(0),
                field_type: "ExposureMode",
                rust_offset: offset_of!(CameraEntityBaseData, exposure_mode),
            },
            FieldInfoData {
                name: "EV",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, e_v),
            },
            FieldInfoData {
                name: "ISO",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, i_s_o),
            },
            FieldInfoData {
                name: "SpotMeterScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, spot_meter_scale),
            },
            FieldInfoData {
                name: "SpotMeterOffsetX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, spot_meter_offset_x),
            },
            FieldInfoData {
                name: "SpotMeterOffsetY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEntityBaseData, spot_meter_offset_y),
            },
            FieldInfoData {
                name: "AutoExposureMethod",
                flags: MemberInfoFlags::new(0),
                field_type: "AutoExposureMethod",
                rust_offset: offset_of!(CameraEntityBaseData, auto_exposure_method),
            },
            FieldInfoData {
                name: "RenderTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "RenderTextureBaseAsset",
                rust_offset: offset_of!(CameraEntityBaseData, render_target),
            },
            FieldInfoData {
                name: "TransitionDataPack",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraTransitionEffectDataPack",
                rust_offset: offset_of!(CameraEntityBaseData, transition_data_pack),
            },
        ],
    }),
    array_type: Some(CAMERAENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CameraEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ExposureMode {
    #[default]
    ExposureMode_Manual = 0,
    ExposureMode_ManualEV = 1,
    ExposureMode_AutoExposure = 2,
    ExposureMode_UseVisualEnvironment = 3,
}

pub static EXPOSUREMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExposureMode",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(EXPOSUREMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ExposureMode {
    fn type_info(&self) -> &'static TypeInfo {
        EXPOSUREMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EXPOSUREMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExposureMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ExposureMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraLensPreset {
    pub _glacier_base: super::core::Asset,
    pub default_focal_length: f32,
    pub enable_lens_breathing: bool,
    pub visual_environment: Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>>,
}

pub trait CameraLensPresetTrait: super::core::AssetTrait {
    fn default_focal_length(&self) -> &f32;
    fn default_focal_length_mut(&mut self) -> &mut f32;
    fn enable_lens_breathing(&self) -> &bool;
    fn enable_lens_breathing_mut(&mut self) -> &mut bool;
    fn visual_environment(&self) -> &Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>>;
    fn visual_environment_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>>;
}

impl CameraLensPresetTrait for CameraLensPreset {
    fn default_focal_length(&self) -> &f32 {
        &self.default_focal_length
    }
    fn default_focal_length_mut(&mut self) -> &mut f32 {
        &mut self.default_focal_length
    }
    fn enable_lens_breathing(&self) -> &bool {
        &self.enable_lens_breathing
    }
    fn enable_lens_breathing_mut(&mut self) -> &mut bool {
        &mut self.enable_lens_breathing
    }
    fn visual_environment(&self) -> &Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>> {
        &self.visual_environment
    }
    fn visual_environment_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>> {
        &mut self.visual_environment
    }
}

impl super::core::AssetTrait for CameraLensPreset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CameraLensPreset {
}

pub static CAMERALENSPRESET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLensPreset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraLensPreset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultFocalLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraLensPreset, default_focal_length),
            },
            FieldInfoData {
                name: "EnableLensBreathing",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraLensPreset, enable_lens_breathing),
            },
            FieldInfoData {
                name: "VisualEnvironment",
                flags: MemberInfoFlags::new(0),
                field_type: "VisualEnvironmentBlueprint",
                rust_offset: offset_of!(CameraLensPreset, visual_environment),
            },
        ],
    }),
    array_type: Some(CAMERALENSPRESET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraLensPreset {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERALENSPRESET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERALENSPRESET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLensPreset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraLensPreset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraBodyPreset {
    pub _glacier_base: super::core::Asset,
    pub sensor_width: f32,
    pub sensor_height: f32,
    pub visual_environment: Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>>,
}

pub trait CameraBodyPresetTrait: super::core::AssetTrait {
    fn sensor_width(&self) -> &f32;
    fn sensor_width_mut(&mut self) -> &mut f32;
    fn sensor_height(&self) -> &f32;
    fn sensor_height_mut(&mut self) -> &mut f32;
    fn visual_environment(&self) -> &Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>>;
    fn visual_environment_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>>;
}

impl CameraBodyPresetTrait for CameraBodyPreset {
    fn sensor_width(&self) -> &f32 {
        &self.sensor_width
    }
    fn sensor_width_mut(&mut self) -> &mut f32 {
        &mut self.sensor_width
    }
    fn sensor_height(&self) -> &f32 {
        &self.sensor_height
    }
    fn sensor_height_mut(&mut self) -> &mut f32 {
        &mut self.sensor_height
    }
    fn visual_environment(&self) -> &Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>> {
        &self.visual_environment
    }
    fn visual_environment_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::VisualEnvironmentBlueprintTrait>>> {
        &mut self.visual_environment
    }
}

impl super::core::AssetTrait for CameraBodyPreset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CameraBodyPreset {
}

pub static CAMERABODYPRESET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraBodyPreset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraBodyPreset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SensorWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraBodyPreset, sensor_width),
            },
            FieldInfoData {
                name: "SensorHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraBodyPreset, sensor_height),
            },
            FieldInfoData {
                name: "VisualEnvironment",
                flags: MemberInfoFlags::new(0),
                field_type: "VisualEnvironmentBlueprint",
                rust_offset: offset_of!(CameraBodyPreset, visual_environment),
            },
        ],
    }),
    array_type: Some(CAMERABODYPRESET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraBodyPreset {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERABODYPRESET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERABODYPRESET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraBodyPreset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraBodyPreset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleCameraData {
    pub _glacier_base: super::gameplay_sim::TargetCameraData,
    pub move_to_position: super::core::Vec3,
    pub move_to_position_slope_factor: super::core::Vec3,
    pub target_offset: super::core::Vec3,
    pub target_offset_slope_factor: super::core::Vec3,
    pub rotation_factor: super::core::Vec3,
    pub position_factor: f32,
    pub reset_distance: f32,
    pub fixed_position: bool,
    pub fixed_angle_z: bool,
    pub use_terrain_adjustment: bool,
}

pub trait VehicleCameraDataTrait: super::gameplay_sim::TargetCameraDataTrait {
    fn move_to_position(&self) -> &super::core::Vec3;
    fn move_to_position_mut(&mut self) -> &mut super::core::Vec3;
    fn move_to_position_slope_factor(&self) -> &super::core::Vec3;
    fn move_to_position_slope_factor_mut(&mut self) -> &mut super::core::Vec3;
    fn target_offset(&self) -> &super::core::Vec3;
    fn target_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn target_offset_slope_factor(&self) -> &super::core::Vec3;
    fn target_offset_slope_factor_mut(&mut self) -> &mut super::core::Vec3;
    fn rotation_factor(&self) -> &super::core::Vec3;
    fn rotation_factor_mut(&mut self) -> &mut super::core::Vec3;
    fn position_factor(&self) -> &f32;
    fn position_factor_mut(&mut self) -> &mut f32;
    fn reset_distance(&self) -> &f32;
    fn reset_distance_mut(&mut self) -> &mut f32;
    fn fixed_position(&self) -> &bool;
    fn fixed_position_mut(&mut self) -> &mut bool;
    fn fixed_angle_z(&self) -> &bool;
    fn fixed_angle_z_mut(&mut self) -> &mut bool;
    fn use_terrain_adjustment(&self) -> &bool;
    fn use_terrain_adjustment_mut(&mut self) -> &mut bool;
}

impl VehicleCameraDataTrait for VehicleCameraData {
    fn move_to_position(&self) -> &super::core::Vec3 {
        &self.move_to_position
    }
    fn move_to_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.move_to_position
    }
    fn move_to_position_slope_factor(&self) -> &super::core::Vec3 {
        &self.move_to_position_slope_factor
    }
    fn move_to_position_slope_factor_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.move_to_position_slope_factor
    }
    fn target_offset(&self) -> &super::core::Vec3 {
        &self.target_offset
    }
    fn target_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_offset
    }
    fn target_offset_slope_factor(&self) -> &super::core::Vec3 {
        &self.target_offset_slope_factor
    }
    fn target_offset_slope_factor_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_offset_slope_factor
    }
    fn rotation_factor(&self) -> &super::core::Vec3 {
        &self.rotation_factor
    }
    fn rotation_factor_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.rotation_factor
    }
    fn position_factor(&self) -> &f32 {
        &self.position_factor
    }
    fn position_factor_mut(&mut self) -> &mut f32 {
        &mut self.position_factor
    }
    fn reset_distance(&self) -> &f32 {
        &self.reset_distance
    }
    fn reset_distance_mut(&mut self) -> &mut f32 {
        &mut self.reset_distance
    }
    fn fixed_position(&self) -> &bool {
        &self.fixed_position
    }
    fn fixed_position_mut(&mut self) -> &mut bool {
        &mut self.fixed_position
    }
    fn fixed_angle_z(&self) -> &bool {
        &self.fixed_angle_z
    }
    fn fixed_angle_z_mut(&mut self) -> &mut bool {
        &mut self.fixed_angle_z
    }
    fn use_terrain_adjustment(&self) -> &bool {
        &self.use_terrain_adjustment
    }
    fn use_terrain_adjustment_mut(&mut self) -> &mut bool {
        &mut self.use_terrain_adjustment
    }
}

impl super::gameplay_sim::TargetCameraDataTrait for VehicleCameraData {
    fn hud(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        self._glacier_base.hud()
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        self._glacier_base.hud_mut()
    }
    fn use_transform_space_hierarchy(&self) -> &bool {
        self._glacier_base.use_transform_space_hierarchy()
    }
    fn use_transform_space_hierarchy_mut(&mut self) -> &mut bool {
        self._glacier_base.use_transform_space_hierarchy_mut()
    }
}

impl super::gameplay_sim::CameraDataTrait for VehicleCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleCameraData {
}

impl super::core::DataBusPeerTrait for VehicleCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleCameraData {
}

impl super::core::DataContainerTrait for VehicleCameraData {
}

pub static VEHICLECAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCameraData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TARGETCAMERADATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleCameraData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, move_to_position),
            },
            FieldInfoData {
                name: "MoveToPositionSlopeFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, move_to_position_slope_factor),
            },
            FieldInfoData {
                name: "TargetOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, target_offset),
            },
            FieldInfoData {
                name: "TargetOffsetSlopeFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, target_offset_slope_factor),
            },
            FieldInfoData {
                name: "RotationFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleCameraData, rotation_factor),
            },
            FieldInfoData {
                name: "PositionFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCameraData, position_factor),
            },
            FieldInfoData {
                name: "ResetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCameraData, reset_distance),
            },
            FieldInfoData {
                name: "FixedPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCameraData, fixed_position),
            },
            FieldInfoData {
                name: "FixedAngleZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCameraData, fixed_angle_z),
            },
            FieldInfoData {
                name: "UseTerrainAdjustment",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCameraData, use_terrain_adjustment),
            },
        ],
    }),
    array_type: Some(VEHICLECAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLECAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCameraData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraLeapData {
    pub transform: super::core::LinearTransform,
    pub time: f32,
    pub fov_modifier: f32,
}

pub trait CameraLeapDataTrait: TypeObject {
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn fov_modifier(&self) -> &f32;
    fn fov_modifier_mut(&mut self) -> &mut f32;
}

impl CameraLeapDataTrait for CameraLeapData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn fov_modifier(&self) -> &f32 {
        &self.fov_modifier
    }
    fn fov_modifier_mut(&mut self) -> &mut f32 {
        &mut self.fov_modifier
    }
}

pub static CAMERALEAPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLeapData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraLeapData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CameraLeapData, transform),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraLeapData, time),
            },
            FieldInfoData {
                name: "FovModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraLeapData, fov_modifier),
            },
        ],
    }),
    array_type: Some(CAMERALEAPDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraLeapData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERALEAPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERALEAPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraLeapData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraLeapData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticCameraData {
    pub _glacier_base: super::gameplay_sim::TargetCameraData,
    pub left_curve: Vec<super::core::Vec3>,
    pub right_curve: Vec<super::core::Vec3>,
    pub up_curve: Vec<super::core::Vec3>,
    pub down_curve: Vec<super::core::Vec3>,
    pub merge_left_and_right_curves: bool,
    pub merge_up_and_down_curves: bool,
    pub mirror_horizontal_curves: bool,
    pub mirror_vertical_curves: bool,
    pub loose_part_physics: Vec<Option<Arc<Mutex<dyn super::physics::CameraLoosePartPhysicsDataTrait>>>>,
    pub left_yaw_angle: f32,
    pub right_yaw_angle: f32,
    pub up_pitch_angle: f32,
    pub down_pitch_angle: f32,
    pub average_filter_frames: i32,
    pub yaw_input_action: i32,
    pub pitch_input_action: i32,
    pub accumulate_input: bool,
    pub reset_accumulated_input_on_view_change: bool,
    pub world_space_lock_efficiency_yaw: f32,
    pub world_space_lock_efficiency_pitch: f32,
    pub yaw_sensitivity_non_zoomed: f32,
    pub yaw_sensitivity_zoomed: f32,
    pub pitch_sensitivity_non_zoomed: f32,
    pub pitch_sensitivity_zoomed: f32,
}

pub trait StaticCameraDataTrait: super::gameplay_sim::TargetCameraDataTrait {
    fn left_curve(&self) -> &Vec<super::core::Vec3>;
    fn left_curve_mut(&mut self) -> &mut Vec<super::core::Vec3>;
    fn right_curve(&self) -> &Vec<super::core::Vec3>;
    fn right_curve_mut(&mut self) -> &mut Vec<super::core::Vec3>;
    fn up_curve(&self) -> &Vec<super::core::Vec3>;
    fn up_curve_mut(&mut self) -> &mut Vec<super::core::Vec3>;
    fn down_curve(&self) -> &Vec<super::core::Vec3>;
    fn down_curve_mut(&mut self) -> &mut Vec<super::core::Vec3>;
    fn merge_left_and_right_curves(&self) -> &bool;
    fn merge_left_and_right_curves_mut(&mut self) -> &mut bool;
    fn merge_up_and_down_curves(&self) -> &bool;
    fn merge_up_and_down_curves_mut(&mut self) -> &mut bool;
    fn mirror_horizontal_curves(&self) -> &bool;
    fn mirror_horizontal_curves_mut(&mut self) -> &mut bool;
    fn mirror_vertical_curves(&self) -> &bool;
    fn mirror_vertical_curves_mut(&mut self) -> &mut bool;
    fn loose_part_physics(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::CameraLoosePartPhysicsDataTrait>>>>;
    fn loose_part_physics_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::CameraLoosePartPhysicsDataTrait>>>>;
    fn left_yaw_angle(&self) -> &f32;
    fn left_yaw_angle_mut(&mut self) -> &mut f32;
    fn right_yaw_angle(&self) -> &f32;
    fn right_yaw_angle_mut(&mut self) -> &mut f32;
    fn up_pitch_angle(&self) -> &f32;
    fn up_pitch_angle_mut(&mut self) -> &mut f32;
    fn down_pitch_angle(&self) -> &f32;
    fn down_pitch_angle_mut(&mut self) -> &mut f32;
    fn average_filter_frames(&self) -> &i32;
    fn average_filter_frames_mut(&mut self) -> &mut i32;
    fn yaw_input_action(&self) -> &i32;
    fn yaw_input_action_mut(&mut self) -> &mut i32;
    fn pitch_input_action(&self) -> &i32;
    fn pitch_input_action_mut(&mut self) -> &mut i32;
    fn accumulate_input(&self) -> &bool;
    fn accumulate_input_mut(&mut self) -> &mut bool;
    fn reset_accumulated_input_on_view_change(&self) -> &bool;
    fn reset_accumulated_input_on_view_change_mut(&mut self) -> &mut bool;
    fn world_space_lock_efficiency_yaw(&self) -> &f32;
    fn world_space_lock_efficiency_yaw_mut(&mut self) -> &mut f32;
    fn world_space_lock_efficiency_pitch(&self) -> &f32;
    fn world_space_lock_efficiency_pitch_mut(&mut self) -> &mut f32;
    fn yaw_sensitivity_non_zoomed(&self) -> &f32;
    fn yaw_sensitivity_non_zoomed_mut(&mut self) -> &mut f32;
    fn yaw_sensitivity_zoomed(&self) -> &f32;
    fn yaw_sensitivity_zoomed_mut(&mut self) -> &mut f32;
    fn pitch_sensitivity_non_zoomed(&self) -> &f32;
    fn pitch_sensitivity_non_zoomed_mut(&mut self) -> &mut f32;
    fn pitch_sensitivity_zoomed(&self) -> &f32;
    fn pitch_sensitivity_zoomed_mut(&mut self) -> &mut f32;
}

impl StaticCameraDataTrait for StaticCameraData {
    fn left_curve(&self) -> &Vec<super::core::Vec3> {
        &self.left_curve
    }
    fn left_curve_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.left_curve
    }
    fn right_curve(&self) -> &Vec<super::core::Vec3> {
        &self.right_curve
    }
    fn right_curve_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.right_curve
    }
    fn up_curve(&self) -> &Vec<super::core::Vec3> {
        &self.up_curve
    }
    fn up_curve_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.up_curve
    }
    fn down_curve(&self) -> &Vec<super::core::Vec3> {
        &self.down_curve
    }
    fn down_curve_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.down_curve
    }
    fn merge_left_and_right_curves(&self) -> &bool {
        &self.merge_left_and_right_curves
    }
    fn merge_left_and_right_curves_mut(&mut self) -> &mut bool {
        &mut self.merge_left_and_right_curves
    }
    fn merge_up_and_down_curves(&self) -> &bool {
        &self.merge_up_and_down_curves
    }
    fn merge_up_and_down_curves_mut(&mut self) -> &mut bool {
        &mut self.merge_up_and_down_curves
    }
    fn mirror_horizontal_curves(&self) -> &bool {
        &self.mirror_horizontal_curves
    }
    fn mirror_horizontal_curves_mut(&mut self) -> &mut bool {
        &mut self.mirror_horizontal_curves
    }
    fn mirror_vertical_curves(&self) -> &bool {
        &self.mirror_vertical_curves
    }
    fn mirror_vertical_curves_mut(&mut self) -> &mut bool {
        &mut self.mirror_vertical_curves
    }
    fn loose_part_physics(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::CameraLoosePartPhysicsDataTrait>>>> {
        &self.loose_part_physics
    }
    fn loose_part_physics_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::CameraLoosePartPhysicsDataTrait>>>> {
        &mut self.loose_part_physics
    }
    fn left_yaw_angle(&self) -> &f32 {
        &self.left_yaw_angle
    }
    fn left_yaw_angle_mut(&mut self) -> &mut f32 {
        &mut self.left_yaw_angle
    }
    fn right_yaw_angle(&self) -> &f32 {
        &self.right_yaw_angle
    }
    fn right_yaw_angle_mut(&mut self) -> &mut f32 {
        &mut self.right_yaw_angle
    }
    fn up_pitch_angle(&self) -> &f32 {
        &self.up_pitch_angle
    }
    fn up_pitch_angle_mut(&mut self) -> &mut f32 {
        &mut self.up_pitch_angle
    }
    fn down_pitch_angle(&self) -> &f32 {
        &self.down_pitch_angle
    }
    fn down_pitch_angle_mut(&mut self) -> &mut f32 {
        &mut self.down_pitch_angle
    }
    fn average_filter_frames(&self) -> &i32 {
        &self.average_filter_frames
    }
    fn average_filter_frames_mut(&mut self) -> &mut i32 {
        &mut self.average_filter_frames
    }
    fn yaw_input_action(&self) -> &i32 {
        &self.yaw_input_action
    }
    fn yaw_input_action_mut(&mut self) -> &mut i32 {
        &mut self.yaw_input_action
    }
    fn pitch_input_action(&self) -> &i32 {
        &self.pitch_input_action
    }
    fn pitch_input_action_mut(&mut self) -> &mut i32 {
        &mut self.pitch_input_action
    }
    fn accumulate_input(&self) -> &bool {
        &self.accumulate_input
    }
    fn accumulate_input_mut(&mut self) -> &mut bool {
        &mut self.accumulate_input
    }
    fn reset_accumulated_input_on_view_change(&self) -> &bool {
        &self.reset_accumulated_input_on_view_change
    }
    fn reset_accumulated_input_on_view_change_mut(&mut self) -> &mut bool {
        &mut self.reset_accumulated_input_on_view_change
    }
    fn world_space_lock_efficiency_yaw(&self) -> &f32 {
        &self.world_space_lock_efficiency_yaw
    }
    fn world_space_lock_efficiency_yaw_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency_yaw
    }
    fn world_space_lock_efficiency_pitch(&self) -> &f32 {
        &self.world_space_lock_efficiency_pitch
    }
    fn world_space_lock_efficiency_pitch_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency_pitch
    }
    fn yaw_sensitivity_non_zoomed(&self) -> &f32 {
        &self.yaw_sensitivity_non_zoomed
    }
    fn yaw_sensitivity_non_zoomed_mut(&mut self) -> &mut f32 {
        &mut self.yaw_sensitivity_non_zoomed
    }
    fn yaw_sensitivity_zoomed(&self) -> &f32 {
        &self.yaw_sensitivity_zoomed
    }
    fn yaw_sensitivity_zoomed_mut(&mut self) -> &mut f32 {
        &mut self.yaw_sensitivity_zoomed
    }
    fn pitch_sensitivity_non_zoomed(&self) -> &f32 {
        &self.pitch_sensitivity_non_zoomed
    }
    fn pitch_sensitivity_non_zoomed_mut(&mut self) -> &mut f32 {
        &mut self.pitch_sensitivity_non_zoomed
    }
    fn pitch_sensitivity_zoomed(&self) -> &f32 {
        &self.pitch_sensitivity_zoomed
    }
    fn pitch_sensitivity_zoomed_mut(&mut self) -> &mut f32 {
        &mut self.pitch_sensitivity_zoomed
    }
}

impl super::gameplay_sim::TargetCameraDataTrait for StaticCameraData {
    fn hud(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        self._glacier_base.hud()
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        self._glacier_base.hud_mut()
    }
    fn use_transform_space_hierarchy(&self) -> &bool {
        self._glacier_base.use_transform_space_hierarchy()
    }
    fn use_transform_space_hierarchy_mut(&mut self) -> &mut bool {
        self._glacier_base.use_transform_space_hierarchy_mut()
    }
}

impl super::gameplay_sim::CameraDataTrait for StaticCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticCameraData {
}

impl super::core::DataBusPeerTrait for StaticCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticCameraData {
}

impl super::core::DataContainerTrait for StaticCameraData {
}

pub static STATICCAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticCameraData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TARGETCAMERADATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticCameraData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LeftCurve",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(StaticCameraData, left_curve),
            },
            FieldInfoData {
                name: "RightCurve",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(StaticCameraData, right_curve),
            },
            FieldInfoData {
                name: "UpCurve",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(StaticCameraData, up_curve),
            },
            FieldInfoData {
                name: "DownCurve",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(StaticCameraData, down_curve),
            },
            FieldInfoData {
                name: "MergeLeftAndRightCurves",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, merge_left_and_right_curves),
            },
            FieldInfoData {
                name: "MergeUpAndDownCurves",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, merge_up_and_down_curves),
            },
            FieldInfoData {
                name: "MirrorHorizontalCurves",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, mirror_horizontal_curves),
            },
            FieldInfoData {
                name: "MirrorVerticalCurves",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, mirror_vertical_curves),
            },
            FieldInfoData {
                name: "LoosePartPhysics",
                flags: MemberInfoFlags::new(144),
                field_type: "CameraLoosePartPhysicsData-Array",
                rust_offset: offset_of!(StaticCameraData, loose_part_physics),
            },
            FieldInfoData {
                name: "LeftYawAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, left_yaw_angle),
            },
            FieldInfoData {
                name: "RightYawAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, right_yaw_angle),
            },
            FieldInfoData {
                name: "UpPitchAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, up_pitch_angle),
            },
            FieldInfoData {
                name: "DownPitchAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, down_pitch_angle),
            },
            FieldInfoData {
                name: "AverageFilterFrames",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StaticCameraData, average_filter_frames),
            },
            FieldInfoData {
                name: "YawInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StaticCameraData, yaw_input_action),
            },
            FieldInfoData {
                name: "PitchInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(StaticCameraData, pitch_input_action),
            },
            FieldInfoData {
                name: "AccumulateInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, accumulate_input),
            },
            FieldInfoData {
                name: "ResetAccumulatedInputOnViewChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticCameraData, reset_accumulated_input_on_view_change),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiencyYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, world_space_lock_efficiency_yaw),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiencyPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, world_space_lock_efficiency_pitch),
            },
            FieldInfoData {
                name: "YawSensitivityNonZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, yaw_sensitivity_non_zoomed),
            },
            FieldInfoData {
                name: "YawSensitivityZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, yaw_sensitivity_zoomed),
            },
            FieldInfoData {
                name: "PitchSensitivityNonZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, pitch_sensitivity_non_zoomed),
            },
            FieldInfoData {
                name: "PitchSensitivityZoomed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticCameraData, pitch_sensitivity_zoomed),
            },
        ],
    }),
    array_type: Some(STATICCAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICCAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICCAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticCameraData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChaseCameraData {
    pub _glacier_base: super::gameplay_sim::TargetCameraData,
    pub target_offset: super::core::Vec3,
    pub target_rotation_offset: f32,
    pub keep_target_pitch: bool,
    pub to_wanted_position_scale: super::core::Vec3,
    pub max_view_rotation_angle_deg: f32,
    pub wanted_angle_deg: f32,
    pub wanted_distance: f32,
    pub max_distance: f32,
    pub snap_distance: f32,
    pub reset_distance: f32,
    pub force_field_radius: f32,
    pub collision_radius: f32,
    pub force_field_force_scale: f32,
    pub away_from_target_force_scale: f32,
    pub velocity_drag: f32,
    pub max_velocity: f32,
    pub pill_minimum_collision_radius: f32,
    pub pill_maximum_collision_radius: f32,
    pub pill_minimum_collision_length: f32,
    pub pill_expand_size_speed_acceleration: f32,
    pub look_distance_scale: f32,
    pub look_distance_in_front_of_target: f32,
    pub should_roll_with_target: bool,
    pub inherit_target_velocity: bool,
    pub update_rate: u32,
    pub bypass_chase_calculations: bool,
    pub has_collision_against_target: bool,
    pub ignore_collision_in_chase_calculations: bool,
    pub has_collision: bool,
}

pub trait ChaseCameraDataTrait: super::gameplay_sim::TargetCameraDataTrait {
    fn target_offset(&self) -> &super::core::Vec3;
    fn target_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn target_rotation_offset(&self) -> &f32;
    fn target_rotation_offset_mut(&mut self) -> &mut f32;
    fn keep_target_pitch(&self) -> &bool;
    fn keep_target_pitch_mut(&mut self) -> &mut bool;
    fn to_wanted_position_scale(&self) -> &super::core::Vec3;
    fn to_wanted_position_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn max_view_rotation_angle_deg(&self) -> &f32;
    fn max_view_rotation_angle_deg_mut(&mut self) -> &mut f32;
    fn wanted_angle_deg(&self) -> &f32;
    fn wanted_angle_deg_mut(&mut self) -> &mut f32;
    fn wanted_distance(&self) -> &f32;
    fn wanted_distance_mut(&mut self) -> &mut f32;
    fn max_distance(&self) -> &f32;
    fn max_distance_mut(&mut self) -> &mut f32;
    fn snap_distance(&self) -> &f32;
    fn snap_distance_mut(&mut self) -> &mut f32;
    fn reset_distance(&self) -> &f32;
    fn reset_distance_mut(&mut self) -> &mut f32;
    fn force_field_radius(&self) -> &f32;
    fn force_field_radius_mut(&mut self) -> &mut f32;
    fn collision_radius(&self) -> &f32;
    fn collision_radius_mut(&mut self) -> &mut f32;
    fn force_field_force_scale(&self) -> &f32;
    fn force_field_force_scale_mut(&mut self) -> &mut f32;
    fn away_from_target_force_scale(&self) -> &f32;
    fn away_from_target_force_scale_mut(&mut self) -> &mut f32;
    fn velocity_drag(&self) -> &f32;
    fn velocity_drag_mut(&mut self) -> &mut f32;
    fn max_velocity(&self) -> &f32;
    fn max_velocity_mut(&mut self) -> &mut f32;
    fn pill_minimum_collision_radius(&self) -> &f32;
    fn pill_minimum_collision_radius_mut(&mut self) -> &mut f32;
    fn pill_maximum_collision_radius(&self) -> &f32;
    fn pill_maximum_collision_radius_mut(&mut self) -> &mut f32;
    fn pill_minimum_collision_length(&self) -> &f32;
    fn pill_minimum_collision_length_mut(&mut self) -> &mut f32;
    fn pill_expand_size_speed_acceleration(&self) -> &f32;
    fn pill_expand_size_speed_acceleration_mut(&mut self) -> &mut f32;
    fn look_distance_scale(&self) -> &f32;
    fn look_distance_scale_mut(&mut self) -> &mut f32;
    fn look_distance_in_front_of_target(&self) -> &f32;
    fn look_distance_in_front_of_target_mut(&mut self) -> &mut f32;
    fn should_roll_with_target(&self) -> &bool;
    fn should_roll_with_target_mut(&mut self) -> &mut bool;
    fn inherit_target_velocity(&self) -> &bool;
    fn inherit_target_velocity_mut(&mut self) -> &mut bool;
    fn update_rate(&self) -> &u32;
    fn update_rate_mut(&mut self) -> &mut u32;
    fn bypass_chase_calculations(&self) -> &bool;
    fn bypass_chase_calculations_mut(&mut self) -> &mut bool;
    fn has_collision_against_target(&self) -> &bool;
    fn has_collision_against_target_mut(&mut self) -> &mut bool;
    fn ignore_collision_in_chase_calculations(&self) -> &bool;
    fn ignore_collision_in_chase_calculations_mut(&mut self) -> &mut bool;
    fn has_collision(&self) -> &bool;
    fn has_collision_mut(&mut self) -> &mut bool;
}

impl ChaseCameraDataTrait for ChaseCameraData {
    fn target_offset(&self) -> &super::core::Vec3 {
        &self.target_offset
    }
    fn target_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_offset
    }
    fn target_rotation_offset(&self) -> &f32 {
        &self.target_rotation_offset
    }
    fn target_rotation_offset_mut(&mut self) -> &mut f32 {
        &mut self.target_rotation_offset
    }
    fn keep_target_pitch(&self) -> &bool {
        &self.keep_target_pitch
    }
    fn keep_target_pitch_mut(&mut self) -> &mut bool {
        &mut self.keep_target_pitch
    }
    fn to_wanted_position_scale(&self) -> &super::core::Vec3 {
        &self.to_wanted_position_scale
    }
    fn to_wanted_position_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.to_wanted_position_scale
    }
    fn max_view_rotation_angle_deg(&self) -> &f32 {
        &self.max_view_rotation_angle_deg
    }
    fn max_view_rotation_angle_deg_mut(&mut self) -> &mut f32 {
        &mut self.max_view_rotation_angle_deg
    }
    fn wanted_angle_deg(&self) -> &f32 {
        &self.wanted_angle_deg
    }
    fn wanted_angle_deg_mut(&mut self) -> &mut f32 {
        &mut self.wanted_angle_deg
    }
    fn wanted_distance(&self) -> &f32 {
        &self.wanted_distance
    }
    fn wanted_distance_mut(&mut self) -> &mut f32 {
        &mut self.wanted_distance
    }
    fn max_distance(&self) -> &f32 {
        &self.max_distance
    }
    fn max_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_distance
    }
    fn snap_distance(&self) -> &f32 {
        &self.snap_distance
    }
    fn snap_distance_mut(&mut self) -> &mut f32 {
        &mut self.snap_distance
    }
    fn reset_distance(&self) -> &f32 {
        &self.reset_distance
    }
    fn reset_distance_mut(&mut self) -> &mut f32 {
        &mut self.reset_distance
    }
    fn force_field_radius(&self) -> &f32 {
        &self.force_field_radius
    }
    fn force_field_radius_mut(&mut self) -> &mut f32 {
        &mut self.force_field_radius
    }
    fn collision_radius(&self) -> &f32 {
        &self.collision_radius
    }
    fn collision_radius_mut(&mut self) -> &mut f32 {
        &mut self.collision_radius
    }
    fn force_field_force_scale(&self) -> &f32 {
        &self.force_field_force_scale
    }
    fn force_field_force_scale_mut(&mut self) -> &mut f32 {
        &mut self.force_field_force_scale
    }
    fn away_from_target_force_scale(&self) -> &f32 {
        &self.away_from_target_force_scale
    }
    fn away_from_target_force_scale_mut(&mut self) -> &mut f32 {
        &mut self.away_from_target_force_scale
    }
    fn velocity_drag(&self) -> &f32 {
        &self.velocity_drag
    }
    fn velocity_drag_mut(&mut self) -> &mut f32 {
        &mut self.velocity_drag
    }
    fn max_velocity(&self) -> &f32 {
        &self.max_velocity
    }
    fn max_velocity_mut(&mut self) -> &mut f32 {
        &mut self.max_velocity
    }
    fn pill_minimum_collision_radius(&self) -> &f32 {
        &self.pill_minimum_collision_radius
    }
    fn pill_minimum_collision_radius_mut(&mut self) -> &mut f32 {
        &mut self.pill_minimum_collision_radius
    }
    fn pill_maximum_collision_radius(&self) -> &f32 {
        &self.pill_maximum_collision_radius
    }
    fn pill_maximum_collision_radius_mut(&mut self) -> &mut f32 {
        &mut self.pill_maximum_collision_radius
    }
    fn pill_minimum_collision_length(&self) -> &f32 {
        &self.pill_minimum_collision_length
    }
    fn pill_minimum_collision_length_mut(&mut self) -> &mut f32 {
        &mut self.pill_minimum_collision_length
    }
    fn pill_expand_size_speed_acceleration(&self) -> &f32 {
        &self.pill_expand_size_speed_acceleration
    }
    fn pill_expand_size_speed_acceleration_mut(&mut self) -> &mut f32 {
        &mut self.pill_expand_size_speed_acceleration
    }
    fn look_distance_scale(&self) -> &f32 {
        &self.look_distance_scale
    }
    fn look_distance_scale_mut(&mut self) -> &mut f32 {
        &mut self.look_distance_scale
    }
    fn look_distance_in_front_of_target(&self) -> &f32 {
        &self.look_distance_in_front_of_target
    }
    fn look_distance_in_front_of_target_mut(&mut self) -> &mut f32 {
        &mut self.look_distance_in_front_of_target
    }
    fn should_roll_with_target(&self) -> &bool {
        &self.should_roll_with_target
    }
    fn should_roll_with_target_mut(&mut self) -> &mut bool {
        &mut self.should_roll_with_target
    }
    fn inherit_target_velocity(&self) -> &bool {
        &self.inherit_target_velocity
    }
    fn inherit_target_velocity_mut(&mut self) -> &mut bool {
        &mut self.inherit_target_velocity
    }
    fn update_rate(&self) -> &u32 {
        &self.update_rate
    }
    fn update_rate_mut(&mut self) -> &mut u32 {
        &mut self.update_rate
    }
    fn bypass_chase_calculations(&self) -> &bool {
        &self.bypass_chase_calculations
    }
    fn bypass_chase_calculations_mut(&mut self) -> &mut bool {
        &mut self.bypass_chase_calculations
    }
    fn has_collision_against_target(&self) -> &bool {
        &self.has_collision_against_target
    }
    fn has_collision_against_target_mut(&mut self) -> &mut bool {
        &mut self.has_collision_against_target
    }
    fn ignore_collision_in_chase_calculations(&self) -> &bool {
        &self.ignore_collision_in_chase_calculations
    }
    fn ignore_collision_in_chase_calculations_mut(&mut self) -> &mut bool {
        &mut self.ignore_collision_in_chase_calculations
    }
    fn has_collision(&self) -> &bool {
        &self.has_collision
    }
    fn has_collision_mut(&mut self) -> &mut bool {
        &mut self.has_collision
    }
}

impl super::gameplay_sim::TargetCameraDataTrait for ChaseCameraData {
    fn hud(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        self._glacier_base.hud()
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        self._glacier_base.hud_mut()
    }
    fn use_transform_space_hierarchy(&self) -> &bool {
        self._glacier_base.use_transform_space_hierarchy()
    }
    fn use_transform_space_hierarchy_mut(&mut self) -> &mut bool {
        self._glacier_base.use_transform_space_hierarchy_mut()
    }
}

impl super::gameplay_sim::CameraDataTrait for ChaseCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for ChaseCameraData {
}

impl super::core::DataBusPeerTrait for ChaseCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ChaseCameraData {
}

impl super::core::DataContainerTrait for ChaseCameraData {
}

pub static CHASECAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChaseCameraData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TARGETCAMERADATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChaseCameraData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ChaseCameraData, target_offset),
            },
            FieldInfoData {
                name: "TargetRotationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, target_rotation_offset),
            },
            FieldInfoData {
                name: "KeepTargetPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, keep_target_pitch),
            },
            FieldInfoData {
                name: "ToWantedPositionScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ChaseCameraData, to_wanted_position_scale),
            },
            FieldInfoData {
                name: "MaxViewRotationAngleDeg",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, max_view_rotation_angle_deg),
            },
            FieldInfoData {
                name: "WantedAngleDeg",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, wanted_angle_deg),
            },
            FieldInfoData {
                name: "WantedDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, wanted_distance),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, max_distance),
            },
            FieldInfoData {
                name: "SnapDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, snap_distance),
            },
            FieldInfoData {
                name: "ResetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, reset_distance),
            },
            FieldInfoData {
                name: "ForceFieldRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, force_field_radius),
            },
            FieldInfoData {
                name: "CollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, collision_radius),
            },
            FieldInfoData {
                name: "ForceFieldForceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, force_field_force_scale),
            },
            FieldInfoData {
                name: "AwayFromTargetForceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, away_from_target_force_scale),
            },
            FieldInfoData {
                name: "VelocityDrag",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, velocity_drag),
            },
            FieldInfoData {
                name: "MaxVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, max_velocity),
            },
            FieldInfoData {
                name: "PillMinimumCollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, pill_minimum_collision_radius),
            },
            FieldInfoData {
                name: "PillMaximumCollisionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, pill_maximum_collision_radius),
            },
            FieldInfoData {
                name: "PillMinimumCollisionLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, pill_minimum_collision_length),
            },
            FieldInfoData {
                name: "PillExpandSizeSpeedAcceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, pill_expand_size_speed_acceleration),
            },
            FieldInfoData {
                name: "LookDistanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, look_distance_scale),
            },
            FieldInfoData {
                name: "LookDistanceInFrontOfTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChaseCameraData, look_distance_in_front_of_target),
            },
            FieldInfoData {
                name: "ShouldRollWithTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, should_roll_with_target),
            },
            FieldInfoData {
                name: "InheritTargetVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, inherit_target_velocity),
            },
            FieldInfoData {
                name: "UpdateRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ChaseCameraData, update_rate),
            },
            FieldInfoData {
                name: "BypassChaseCalculations",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, bypass_chase_calculations),
            },
            FieldInfoData {
                name: "HasCollisionAgainstTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, has_collision_against_target),
            },
            FieldInfoData {
                name: "IgnoreCollisionInChaseCalculations",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, ignore_collision_in_chase_calculations),
            },
            FieldInfoData {
                name: "HasCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChaseCameraData, has_collision),
            },
        ],
    }),
    array_type: Some(CHASECAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChaseCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        CHASECAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHASECAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChaseCameraData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChaseCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FPSCameraData {
    pub _glacier_base: super::gameplay_sim::TargetCameraData,
    pub turn_effect_settings: TurnEffectData,
    pub blur_effect_settings: BlurEffectData,
    pub f_o_v: f32,
}

pub trait FPSCameraDataTrait: super::gameplay_sim::TargetCameraDataTrait {
    fn turn_effect_settings(&self) -> &TurnEffectData;
    fn turn_effect_settings_mut(&mut self) -> &mut TurnEffectData;
    fn blur_effect_settings(&self) -> &BlurEffectData;
    fn blur_effect_settings_mut(&mut self) -> &mut BlurEffectData;
    fn f_o_v(&self) -> &f32;
    fn f_o_v_mut(&mut self) -> &mut f32;
}

impl FPSCameraDataTrait for FPSCameraData {
    fn turn_effect_settings(&self) -> &TurnEffectData {
        &self.turn_effect_settings
    }
    fn turn_effect_settings_mut(&mut self) -> &mut TurnEffectData {
        &mut self.turn_effect_settings
    }
    fn blur_effect_settings(&self) -> &BlurEffectData {
        &self.blur_effect_settings
    }
    fn blur_effect_settings_mut(&mut self) -> &mut BlurEffectData {
        &mut self.blur_effect_settings
    }
    fn f_o_v(&self) -> &f32 {
        &self.f_o_v
    }
    fn f_o_v_mut(&mut self) -> &mut f32 {
        &mut self.f_o_v
    }
}

impl super::gameplay_sim::TargetCameraDataTrait for FPSCameraData {
    fn hud(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        self._glacier_base.hud()
    }
    fn hud_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HudDataTrait>>>> {
        self._glacier_base.hud_mut()
    }
    fn use_transform_space_hierarchy(&self) -> &bool {
        self._glacier_base.use_transform_space_hierarchy()
    }
    fn use_transform_space_hierarchy_mut(&mut self) -> &mut bool {
        self._glacier_base.use_transform_space_hierarchy_mut()
    }
}

impl super::gameplay_sim::CameraDataTrait for FPSCameraData {
    fn occlusion_ray_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset()
    }
    fn occlusion_ray_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.occlusion_ray_offset_mut()
    }
    fn pre_fade_time(&self) -> &f32 {
        self._glacier_base.pre_fade_time()
    }
    fn pre_fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.pre_fade_time_mut()
    }
    fn fade_time(&self) -> &f32 {
        self._glacier_base.fade_time()
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_time_mut()
    }
    fn fade_wait_time(&self) -> &f32 {
        self._glacier_base.fade_wait_time()
    }
    fn fade_wait_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_wait_time_mut()
    }
    fn stay_faded_while_streaming(&self) -> &bool {
        self._glacier_base.stay_faded_while_streaming()
    }
    fn stay_faded_while_streaming_mut(&mut self) -> &mut bool {
        self._glacier_base.stay_faded_while_streaming_mut()
    }
    fn near_plane(&self) -> &f32 {
        self._glacier_base.near_plane()
    }
    fn near_plane_mut(&mut self) -> &mut f32 {
        self._glacier_base.near_plane_mut()
    }
    fn shadow_view_distance_scale(&self) -> &f32 {
        self._glacier_base.shadow_view_distance_scale()
    }
    fn shadow_view_distance_scale_mut(&mut self) -> &mut f32 {
        self._glacier_base.shadow_view_distance_scale_mut()
    }
    fn sound_occlusion(&self) -> &f32 {
        self._glacier_base.sound_occlusion()
    }
    fn sound_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_occlusion_mut()
    }
    fn sound_listener_radius(&self) -> &f32 {
        self._glacier_base.sound_listener_radius()
    }
    fn sound_listener_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_radius_mut()
    }
    fn sound_listener_fov(&self) -> &f32 {
        self._glacier_base.sound_listener_fov()
    }
    fn sound_listener_fov_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_listener_fov_mut()
    }
    fn shake_factor(&self) -> &f32 {
        self._glacier_base.shake_factor()
    }
    fn shake_factor_mut(&mut self) -> &mut f32 {
        self._glacier_base.shake_factor_mut()
    }
    fn view_id(&self) -> &super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id()
    }
    fn view_id_mut(&mut self) -> &mut super::render_base::LocalPlayerViewId {
        self._glacier_base.view_id_mut()
    }
    fn transition_data_pack(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack()
    }
    fn transition_data_pack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::CameraTransitionEffectDataPackTrait>>> {
        self._glacier_base.transition_data_pack_mut()
    }
}

impl super::entity::GameObjectDataTrait for FPSCameraData {
}

impl super::core::DataBusPeerTrait for FPSCameraData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FPSCameraData {
}

impl super::core::DataContainerTrait for FPSCameraData {
}

pub static FPSCAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FPSCameraData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TARGETCAMERADATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FPSCameraData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TurnEffectSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "TurnEffectData",
                rust_offset: offset_of!(FPSCameraData, turn_effect_settings),
            },
            FieldInfoData {
                name: "BlurEffectSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "BlurEffectData",
                rust_offset: offset_of!(FPSCameraData, blur_effect_settings),
            },
            FieldInfoData {
                name: "FOV",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FPSCameraData, f_o_v),
            },
        ],
    }),
    array_type: Some(FPSCAMERADATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FPSCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        FPSCAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FPSCAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FPSCameraData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FPSCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HudImpactData {
    pub enable: bool,
    pub min_health: f32,
    pub max_health: f32,
    pub min_time_visible: f32,
    pub max_time_visible: f32,
}

pub trait HudImpactDataTrait: TypeObject {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn min_health(&self) -> &f32;
    fn min_health_mut(&mut self) -> &mut f32;
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn min_time_visible(&self) -> &f32;
    fn min_time_visible_mut(&mut self) -> &mut f32;
    fn max_time_visible(&self) -> &f32;
    fn max_time_visible_mut(&mut self) -> &mut f32;
}

impl HudImpactDataTrait for HudImpactData {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn min_health(&self) -> &f32 {
        &self.min_health
    }
    fn min_health_mut(&mut self) -> &mut f32 {
        &mut self.min_health
    }
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn min_time_visible(&self) -> &f32 {
        &self.min_time_visible
    }
    fn min_time_visible_mut(&mut self) -> &mut f32 {
        &mut self.min_time_visible
    }
    fn max_time_visible(&self) -> &f32 {
        &self.max_time_visible
    }
    fn max_time_visible_mut(&mut self) -> &mut f32 {
        &mut self.max_time_visible
    }
}

pub static HUDIMPACTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HudImpactData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HudImpactData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HudImpactData, enable),
            },
            FieldInfoData {
                name: "MinHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HudImpactData, min_health),
            },
            FieldInfoData {
                name: "MaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HudImpactData, max_health),
            },
            FieldInfoData {
                name: "MinTimeVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HudImpactData, min_time_visible),
            },
            FieldInfoData {
                name: "MaxTimeVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HudImpactData, max_time_visible),
            },
        ],
    }),
    array_type: Some(HUDIMPACTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for HudImpactData {
    fn type_info(&self) -> &'static TypeInfo {
        HUDIMPACTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static HUDIMPACTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HudImpactData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HudImpactData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BlurEffectData {
    pub dispersion_strength: f32,
    pub dispersion_threshhold: f32,
    pub explosion_strength: f32,
    pub bullet_strength: f32,
    pub explosion_falloff_speed: f32,
    pub bullet_falloff_speed: f32,
}

pub trait BlurEffectDataTrait: TypeObject {
    fn dispersion_strength(&self) -> &f32;
    fn dispersion_strength_mut(&mut self) -> &mut f32;
    fn dispersion_threshhold(&self) -> &f32;
    fn dispersion_threshhold_mut(&mut self) -> &mut f32;
    fn explosion_strength(&self) -> &f32;
    fn explosion_strength_mut(&mut self) -> &mut f32;
    fn bullet_strength(&self) -> &f32;
    fn bullet_strength_mut(&mut self) -> &mut f32;
    fn explosion_falloff_speed(&self) -> &f32;
    fn explosion_falloff_speed_mut(&mut self) -> &mut f32;
    fn bullet_falloff_speed(&self) -> &f32;
    fn bullet_falloff_speed_mut(&mut self) -> &mut f32;
}

impl BlurEffectDataTrait for BlurEffectData {
    fn dispersion_strength(&self) -> &f32 {
        &self.dispersion_strength
    }
    fn dispersion_strength_mut(&mut self) -> &mut f32 {
        &mut self.dispersion_strength
    }
    fn dispersion_threshhold(&self) -> &f32 {
        &self.dispersion_threshhold
    }
    fn dispersion_threshhold_mut(&mut self) -> &mut f32 {
        &mut self.dispersion_threshhold
    }
    fn explosion_strength(&self) -> &f32 {
        &self.explosion_strength
    }
    fn explosion_strength_mut(&mut self) -> &mut f32 {
        &mut self.explosion_strength
    }
    fn bullet_strength(&self) -> &f32 {
        &self.bullet_strength
    }
    fn bullet_strength_mut(&mut self) -> &mut f32 {
        &mut self.bullet_strength
    }
    fn explosion_falloff_speed(&self) -> &f32 {
        &self.explosion_falloff_speed
    }
    fn explosion_falloff_speed_mut(&mut self) -> &mut f32 {
        &mut self.explosion_falloff_speed
    }
    fn bullet_falloff_speed(&self) -> &f32 {
        &self.bullet_falloff_speed
    }
    fn bullet_falloff_speed_mut(&mut self) -> &mut f32 {
        &mut self.bullet_falloff_speed
    }
}

pub static BLUREFFECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlurEffectData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BlurEffectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DispersionStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, dispersion_strength),
            },
            FieldInfoData {
                name: "DispersionThreshhold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, dispersion_threshhold),
            },
            FieldInfoData {
                name: "ExplosionStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, explosion_strength),
            },
            FieldInfoData {
                name: "BulletStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, bullet_strength),
            },
            FieldInfoData {
                name: "ExplosionFalloffSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, explosion_falloff_speed),
            },
            FieldInfoData {
                name: "BulletFalloffSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BlurEffectData, bullet_falloff_speed),
            },
        ],
    }),
    array_type: Some(BLUREFFECTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BlurEffectData {
    fn type_info(&self) -> &'static TypeInfo {
        BLUREFFECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BLUREFFECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlurEffectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BlurEffectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TurnEffectData {
    pub max_roll_angle: f32,
    pub max_pitch_angle: f32,
    pub yaw_velocity_threshhold: f32,
    pub velocity_threshhold: f32,
    pub safe_time: f32,
    pub begin_time: f32,
    pub hold_time: f32,
    pub end_time: f32,
}

pub trait TurnEffectDataTrait: TypeObject {
    fn max_roll_angle(&self) -> &f32;
    fn max_roll_angle_mut(&mut self) -> &mut f32;
    fn max_pitch_angle(&self) -> &f32;
    fn max_pitch_angle_mut(&mut self) -> &mut f32;
    fn yaw_velocity_threshhold(&self) -> &f32;
    fn yaw_velocity_threshhold_mut(&mut self) -> &mut f32;
    fn velocity_threshhold(&self) -> &f32;
    fn velocity_threshhold_mut(&mut self) -> &mut f32;
    fn safe_time(&self) -> &f32;
    fn safe_time_mut(&mut self) -> &mut f32;
    fn begin_time(&self) -> &f32;
    fn begin_time_mut(&mut self) -> &mut f32;
    fn hold_time(&self) -> &f32;
    fn hold_time_mut(&mut self) -> &mut f32;
    fn end_time(&self) -> &f32;
    fn end_time_mut(&mut self) -> &mut f32;
}

impl TurnEffectDataTrait for TurnEffectData {
    fn max_roll_angle(&self) -> &f32 {
        &self.max_roll_angle
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_roll_angle
    }
    fn max_pitch_angle(&self) -> &f32 {
        &self.max_pitch_angle
    }
    fn max_pitch_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_pitch_angle
    }
    fn yaw_velocity_threshhold(&self) -> &f32 {
        &self.yaw_velocity_threshhold
    }
    fn yaw_velocity_threshhold_mut(&mut self) -> &mut f32 {
        &mut self.yaw_velocity_threshhold
    }
    fn velocity_threshhold(&self) -> &f32 {
        &self.velocity_threshhold
    }
    fn velocity_threshhold_mut(&mut self) -> &mut f32 {
        &mut self.velocity_threshhold
    }
    fn safe_time(&self) -> &f32 {
        &self.safe_time
    }
    fn safe_time_mut(&mut self) -> &mut f32 {
        &mut self.safe_time
    }
    fn begin_time(&self) -> &f32 {
        &self.begin_time
    }
    fn begin_time_mut(&mut self) -> &mut f32 {
        &mut self.begin_time
    }
    fn hold_time(&self) -> &f32 {
        &self.hold_time
    }
    fn hold_time_mut(&mut self) -> &mut f32 {
        &mut self.hold_time
    }
    fn end_time(&self) -> &f32 {
        &self.end_time
    }
    fn end_time_mut(&mut self) -> &mut f32 {
        &mut self.end_time
    }
}

pub static TURNEFFECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TurnEffectData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TurnEffectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxRollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, max_roll_angle),
            },
            FieldInfoData {
                name: "MaxPitchAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, max_pitch_angle),
            },
            FieldInfoData {
                name: "YawVelocityThreshhold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, yaw_velocity_threshhold),
            },
            FieldInfoData {
                name: "VelocityThreshhold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, velocity_threshhold),
            },
            FieldInfoData {
                name: "SafeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, safe_time),
            },
            FieldInfoData {
                name: "BeginTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, begin_time),
            },
            FieldInfoData {
                name: "HoldTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, hold_time),
            },
            FieldInfoData {
                name: "EndTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurnEffectData, end_time),
            },
        ],
    }),
    array_type: Some(TURNEFFECTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TurnEffectData {
    fn type_info(&self) -> &'static TypeInfo {
        TURNEFFECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TURNEFFECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TurnEffectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TurnEffectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraSineCurveData {
    pub frequency: f32,
    pub amplitude: f32,
    pub phase_shift: f32,
}

pub trait CameraSineCurveDataTrait: TypeObject {
    fn frequency(&self) -> &f32;
    fn frequency_mut(&mut self) -> &mut f32;
    fn amplitude(&self) -> &f32;
    fn amplitude_mut(&mut self) -> &mut f32;
    fn phase_shift(&self) -> &f32;
    fn phase_shift_mut(&mut self) -> &mut f32;
}

impl CameraSineCurveDataTrait for CameraSineCurveData {
    fn frequency(&self) -> &f32 {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut f32 {
        &mut self.frequency
    }
    fn amplitude(&self) -> &f32 {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut f32 {
        &mut self.amplitude
    }
    fn phase_shift(&self) -> &f32 {
        &self.phase_shift
    }
    fn phase_shift_mut(&mut self) -> &mut f32 {
        &mut self.phase_shift
    }
}

pub static CAMERASINECURVEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraSineCurveData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraSineCurveData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSineCurveData, frequency),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSineCurveData, amplitude),
            },
            FieldInfoData {
                name: "PhaseShift",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraSineCurveData, phase_shift),
            },
        ],
    }),
    array_type: Some(CAMERASINECURVEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CameraSineCurveData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERASINECURVEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERASINECURVEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraSineCurveData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraSineCurveData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BuildConfigFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait BuildConfigFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl BuildConfigFilterEntityDataTrait for BuildConfigFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for BuildConfigFilterEntityData {
}

impl super::entity::GameObjectDataTrait for BuildConfigFilterEntityData {
}

impl super::core::DataBusPeerTrait for BuildConfigFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BuildConfigFilterEntityData {
}

impl super::core::DataContainerTrait for BuildConfigFilterEntityData {
}

pub static BUILDCONFIGFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuildConfigFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BuildConfigFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(BuildConfigFilterEntityData, realm),
            },
        ],
    }),
    array_type: Some(BUILDCONFIGFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BuildConfigFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BUILDCONFIGFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BUILDCONFIGFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuildConfigFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BuildConfigFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterAsset {
    pub _glacier_base: CharacterBlueprint,
}

pub trait CharacterAssetTrait: CharacterBlueprintTrait {
}

impl CharacterAssetTrait for CharacterAsset {
}

impl CharacterBlueprintTrait for CharacterAsset {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl super::entity::ObjectBlueprintTrait for CharacterAsset {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for CharacterAsset {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for CharacterAsset {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for CharacterAsset {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for CharacterAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterAsset {
}

pub static CHARACTERASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHARACTERASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterAsset {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleAsset {
    pub _glacier_base: VehicleBlueprint,
}

pub trait VehicleAssetTrait: VehicleBlueprintTrait {
}

impl VehicleAssetTrait for VehicleAsset {
}

impl VehicleBlueprintTrait for VehicleAsset {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
}

impl super::entity::ObjectBlueprintTrait for VehicleAsset {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for VehicleAsset {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for VehicleAsset {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for VehicleAsset {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for VehicleAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VehicleAsset {
}

pub static VEHICLEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VEHICLEBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEHICLEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
    pub time_delta_type: super::entity::TimeDeltaType,
}

pub trait CharacterBlueprintTrait: super::entity::ObjectBlueprintTrait {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType;
}

impl CharacterBlueprintTrait for CharacterBlueprint {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl super::entity::ObjectBlueprintTrait for CharacterBlueprint {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for CharacterBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for CharacterBlueprint {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for CharacterBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for CharacterBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterBlueprint {
}

pub static CHARACTERBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterBlueprint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TimeDeltaType",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(CharacterBlueprint, time_delta_type),
            },
        ],
    }),
    array_type: Some(CHARACTERBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
    pub time_delta_type: super::entity::TimeDeltaType,
}

pub trait VehicleBlueprintTrait: super::entity::ObjectBlueprintTrait {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType;
}

impl VehicleBlueprintTrait for VehicleBlueprint {
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        &mut self.time_delta_type
    }
}

impl super::entity::ObjectBlueprintTrait for VehicleBlueprint {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for VehicleBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for VehicleBlueprint {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for VehicleBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for VehicleBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VehicleBlueprint {
}

pub static VEHICLEBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleBlueprint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TimeDeltaType",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(VehicleBlueprint, time_delta_type),
            },
        ],
    }),
    array_type: Some(VEHICLEBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BlueprintBundleAnimationStatusEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub stream_realm: super::entity::StreamRealm,
    pub bundle_name: String,
}

pub trait BlueprintBundleAnimationStatusEntityDataTrait: super::entity::EntityDataTrait {
    fn stream_realm(&self) -> &super::entity::StreamRealm;
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm;
    fn bundle_name(&self) -> &String;
    fn bundle_name_mut(&mut self) -> &mut String;
}

impl BlueprintBundleAnimationStatusEntityDataTrait for BlueprintBundleAnimationStatusEntityData {
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        &self.stream_realm
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        &mut self.stream_realm
    }
    fn bundle_name(&self) -> &String {
        &self.bundle_name
    }
    fn bundle_name_mut(&mut self) -> &mut String {
        &mut self.bundle_name
    }
}

impl super::entity::EntityDataTrait for BlueprintBundleAnimationStatusEntityData {
}

impl super::entity::GameObjectDataTrait for BlueprintBundleAnimationStatusEntityData {
}

impl super::core::DataBusPeerTrait for BlueprintBundleAnimationStatusEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BlueprintBundleAnimationStatusEntityData {
}

impl super::core::DataContainerTrait for BlueprintBundleAnimationStatusEntityData {
}

pub static BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlueprintBundleAnimationStatusEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BlueprintBundleAnimationStatusEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StreamRealm",
                flags: MemberInfoFlags::new(0),
                field_type: "StreamRealm",
                rust_offset: offset_of!(BlueprintBundleAnimationStatusEntityData, stream_realm),
            },
            FieldInfoData {
                name: "BundleName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BlueprintBundleAnimationStatusEntityData, bundle_name),
            },
        ],
    }),
    array_type: Some(BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BlueprintBundleAnimationStatusEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BLUEPRINTBUNDLEANIMATIONSTATUSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BlueprintBundleAnimationStatusEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BlueprintBundleAnimationStatusEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BangerHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait BangerHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl BangerHealthComponentDataTrait for BangerHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for BangerHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for BangerHealthComponentData {
}

impl super::entity::ComponentDataTrait for BangerHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BangerHealthComponentData {
}

impl super::core::DataBusPeerTrait for BangerHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BangerHealthComponentData {
}

impl super::core::DataContainerTrait for BangerHealthComponentData {
}

pub static BANGERHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BangerHealthComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BANGERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BangerHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BANGERHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BANGERHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BangerHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BangerPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
    pub impulse_input: super::core::Vec3,
}

pub trait BangerPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
    fn impulse_input(&self) -> &super::core::Vec3;
    fn impulse_input_mut(&mut self) -> &mut super::core::Vec3;
}

impl BangerPhysicsComponentDataTrait for BangerPhysicsComponentData {
    fn impulse_input(&self) -> &super::core::Vec3 {
        &self.impulse_input
    }
    fn impulse_input_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.impulse_input
    }
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for BangerPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for BangerPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for BangerPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BangerPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for BangerPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BangerPhysicsComponentData {
}

impl super::core::DataContainerTrait for BangerPhysicsComponentData {
}

pub static BANGERPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BangerPhysicsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ImpulseInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(BangerPhysicsComponentData, impulse_input),
            },
        ],
    }),
    array_type: Some(BANGERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BangerPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BANGERPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BANGERPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BangerPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BangerEntityData {
    pub _glacier_base: DynamicGamePhysicsEntityData,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub explosion: Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>>,
    pub time_to_live: f32,
    pub use_variable_network_frequency: bool,
    pub destructible_part_count: u32,
}

pub trait BangerEntityDataTrait: DynamicGamePhysicsEntityDataTrait {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn explosion(&self) -> &Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>>;
    fn explosion_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>>;
    fn time_to_live(&self) -> &f32;
    fn time_to_live_mut(&mut self) -> &mut f32;
    fn use_variable_network_frequency(&self) -> &bool;
    fn use_variable_network_frequency_mut(&mut self) -> &mut bool;
    fn destructible_part_count(&self) -> &u32;
    fn destructible_part_count_mut(&mut self) -> &mut u32;
}

impl BangerEntityDataTrait for BangerEntityData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn explosion(&self) -> &Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>> {
        &self.explosion
    }
    fn explosion_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>> {
        &mut self.explosion
    }
    fn time_to_live(&self) -> &f32 {
        &self.time_to_live
    }
    fn time_to_live_mut(&mut self) -> &mut f32 {
        &mut self.time_to_live
    }
    fn use_variable_network_frequency(&self) -> &bool {
        &self.use_variable_network_frequency
    }
    fn use_variable_network_frequency_mut(&mut self) -> &mut bool {
        &mut self.use_variable_network_frequency
    }
    fn destructible_part_count(&self) -> &u32 {
        &self.destructible_part_count
    }
    fn destructible_part_count_mut(&mut self) -> &mut u32 {
        &mut self.destructible_part_count
    }
}

impl DynamicGamePhysicsEntityDataTrait for BangerEntityData {
}

impl super::physics::GamePhysicsEntityDataTrait for BangerEntityData {
}

impl super::entity::GameComponentEntityDataTrait for BangerEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for BangerEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for BangerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for BangerEntityData {
}

impl super::entity::GameObjectDataTrait for BangerEntityData {
}

impl super::core::DataBusPeerTrait for BangerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BangerEntityData {
}

impl super::core::DataContainerTrait for BangerEntityData {
}

pub static BANGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BangerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(BangerEntityData, mesh),
            },
            FieldInfoData {
                name: "Explosion",
                flags: MemberInfoFlags::new(0),
                field_type: "ExplosionEntityData",
                rust_offset: offset_of!(BangerEntityData, explosion),
            },
            FieldInfoData {
                name: "TimeToLive",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BangerEntityData, time_to_live),
            },
            FieldInfoData {
                name: "UseVariableNetworkFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BangerEntityData, use_variable_network_frequency),
            },
            FieldInfoData {
                name: "DestructiblePartCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BangerEntityData, destructible_part_count),
            },
        ],
    }),
    array_type: Some(BANGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BangerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BANGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BANGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BangerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BangerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WorldRendererSwitchEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait WorldRendererSwitchEntityDataTrait: super::entity::EntityDataTrait {
}

impl WorldRendererSwitchEntityDataTrait for WorldRendererSwitchEntityData {
}

impl super::entity::EntityDataTrait for WorldRendererSwitchEntityData {
}

impl super::entity::GameObjectDataTrait for WorldRendererSwitchEntityData {
}

impl super::core::DataBusPeerTrait for WorldRendererSwitchEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WorldRendererSwitchEntityData {
}

impl super::core::DataContainerTrait for WorldRendererSwitchEntityData {
}

pub static WORLDRENDERERSWITCHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldRendererSwitchEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WorldRendererSwitchEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WORLDRENDERERSWITCHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WorldRendererSwitchEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WORLDRENDERERSWITCHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WORLDRENDERERSWITCHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WorldRendererSwitchEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WorldRendererSwitchEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CannedScenarioEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub canned_anim_binding: CannedAnimationBinding,
    pub animation_entity_space_priority: i32,
    pub always_clear_entity_space_when_in_scenario: bool,
}

pub trait CannedScenarioEntityDataTrait: super::entity::EntityDataTrait {
    fn canned_anim_binding(&self) -> &CannedAnimationBinding;
    fn canned_anim_binding_mut(&mut self) -> &mut CannedAnimationBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn always_clear_entity_space_when_in_scenario(&self) -> &bool;
    fn always_clear_entity_space_when_in_scenario_mut(&mut self) -> &mut bool;
}

impl CannedScenarioEntityDataTrait for CannedScenarioEntityData {
    fn canned_anim_binding(&self) -> &CannedAnimationBinding {
        &self.canned_anim_binding
    }
    fn canned_anim_binding_mut(&mut self) -> &mut CannedAnimationBinding {
        &mut self.canned_anim_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn always_clear_entity_space_when_in_scenario(&self) -> &bool {
        &self.always_clear_entity_space_when_in_scenario
    }
    fn always_clear_entity_space_when_in_scenario_mut(&mut self) -> &mut bool {
        &mut self.always_clear_entity_space_when_in_scenario
    }
}

impl super::entity::EntityDataTrait for CannedScenarioEntityData {
}

impl super::entity::GameObjectDataTrait for CannedScenarioEntityData {
}

impl super::core::DataBusPeerTrait for CannedScenarioEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CannedScenarioEntityData {
}

impl super::core::DataContainerTrait for CannedScenarioEntityData {
}

pub static CANNEDSCENARIOENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CannedScenarioEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CannedScenarioEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CannedAnimBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "CannedAnimationBinding",
                rust_offset: offset_of!(CannedScenarioEntityData, canned_anim_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CannedScenarioEntityData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "AlwaysClearEntitySpaceWhenInScenario",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CannedScenarioEntityData, always_clear_entity_space_when_in_scenario),
            },
        ],
    }),
    array_type: Some(CANNEDSCENARIOENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CannedScenarioEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CANNEDSCENARIOENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CANNEDSCENARIOENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CannedScenarioEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CannedScenarioEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WarpAnimationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub warp_binding: WarpAnimationBinding,
    pub animation_entity_space_priority: i32,
    pub bone_to_align: super::entity::GameplayBones,
    pub require_animation_weight: bool,
    pub force_animation_transform: bool,
    pub connect_transform: super::core::LinearTransform,
    pub external_connect_transform: bool,
}

pub trait WarpAnimationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn warp_binding(&self) -> &WarpAnimationBinding;
    fn warp_binding_mut(&mut self) -> &mut WarpAnimationBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn bone_to_align(&self) -> &super::entity::GameplayBones;
    fn bone_to_align_mut(&mut self) -> &mut super::entity::GameplayBones;
    fn require_animation_weight(&self) -> &bool;
    fn require_animation_weight_mut(&mut self) -> &mut bool;
    fn force_animation_transform(&self) -> &bool;
    fn force_animation_transform_mut(&mut self) -> &mut bool;
    fn connect_transform(&self) -> &super::core::LinearTransform;
    fn connect_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn external_connect_transform(&self) -> &bool;
    fn external_connect_transform_mut(&mut self) -> &mut bool;
}

impl WarpAnimationEntityDataTrait for WarpAnimationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn warp_binding(&self) -> &WarpAnimationBinding {
        &self.warp_binding
    }
    fn warp_binding_mut(&mut self) -> &mut WarpAnimationBinding {
        &mut self.warp_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn bone_to_align(&self) -> &super::entity::GameplayBones {
        &self.bone_to_align
    }
    fn bone_to_align_mut(&mut self) -> &mut super::entity::GameplayBones {
        &mut self.bone_to_align
    }
    fn require_animation_weight(&self) -> &bool {
        &self.require_animation_weight
    }
    fn require_animation_weight_mut(&mut self) -> &mut bool {
        &mut self.require_animation_weight
    }
    fn force_animation_transform(&self) -> &bool {
        &self.force_animation_transform
    }
    fn force_animation_transform_mut(&mut self) -> &mut bool {
        &mut self.force_animation_transform
    }
    fn connect_transform(&self) -> &super::core::LinearTransform {
        &self.connect_transform
    }
    fn connect_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.connect_transform
    }
    fn external_connect_transform(&self) -> &bool {
        &self.external_connect_transform
    }
    fn external_connect_transform_mut(&mut self) -> &mut bool {
        &mut self.external_connect_transform
    }
}

impl super::entity::EntityDataTrait for WarpAnimationEntityData {
}

impl super::entity::GameObjectDataTrait for WarpAnimationEntityData {
}

impl super::core::DataBusPeerTrait for WarpAnimationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WarpAnimationEntityData {
}

impl super::core::DataContainerTrait for WarpAnimationEntityData {
}

pub static WARPANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarpAnimationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WarpAnimationEntityData, realm),
            },
            FieldInfoData {
                name: "WarpBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "WarpAnimationBinding",
                rust_offset: offset_of!(WarpAnimationEntityData, warp_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WarpAnimationEntityData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "BoneToAlign",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(WarpAnimationEntityData, bone_to_align),
            },
            FieldInfoData {
                name: "RequireAnimationWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationEntityData, require_animation_weight),
            },
            FieldInfoData {
                name: "ForceAnimationTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationEntityData, force_animation_transform),
            },
            FieldInfoData {
                name: "ConnectTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WarpAnimationEntityData, connect_transform),
            },
            FieldInfoData {
                name: "ExternalConnectTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationEntityData, external_connect_transform),
            },
        ],
    }),
    array_type: Some(WARPANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WarpAnimationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WARPANIMATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WARPANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarpAnimationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WarpAnimationComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub warp_binding: WarpAnimationBinding,
    pub canned_anim_binding: CannedAnimationBinding,
    pub animation_entity_space_priority: i32,
    pub bone_to_align: super::entity::GameplayBones,
    pub require_animation_weight: bool,
    pub force_animation_transform: bool,
    pub connect_transform: super::core::LinearTransform,
    pub external_connect_transform: bool,
}

pub trait WarpAnimationComponentDataTrait: super::entity::GameComponentDataTrait {
    fn warp_binding(&self) -> &WarpAnimationBinding;
    fn warp_binding_mut(&mut self) -> &mut WarpAnimationBinding;
    fn canned_anim_binding(&self) -> &CannedAnimationBinding;
    fn canned_anim_binding_mut(&mut self) -> &mut CannedAnimationBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn bone_to_align(&self) -> &super::entity::GameplayBones;
    fn bone_to_align_mut(&mut self) -> &mut super::entity::GameplayBones;
    fn require_animation_weight(&self) -> &bool;
    fn require_animation_weight_mut(&mut self) -> &mut bool;
    fn force_animation_transform(&self) -> &bool;
    fn force_animation_transform_mut(&mut self) -> &mut bool;
    fn connect_transform(&self) -> &super::core::LinearTransform;
    fn connect_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn external_connect_transform(&self) -> &bool;
    fn external_connect_transform_mut(&mut self) -> &mut bool;
}

impl WarpAnimationComponentDataTrait for WarpAnimationComponentData {
    fn warp_binding(&self) -> &WarpAnimationBinding {
        &self.warp_binding
    }
    fn warp_binding_mut(&mut self) -> &mut WarpAnimationBinding {
        &mut self.warp_binding
    }
    fn canned_anim_binding(&self) -> &CannedAnimationBinding {
        &self.canned_anim_binding
    }
    fn canned_anim_binding_mut(&mut self) -> &mut CannedAnimationBinding {
        &mut self.canned_anim_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn bone_to_align(&self) -> &super::entity::GameplayBones {
        &self.bone_to_align
    }
    fn bone_to_align_mut(&mut self) -> &mut super::entity::GameplayBones {
        &mut self.bone_to_align
    }
    fn require_animation_weight(&self) -> &bool {
        &self.require_animation_weight
    }
    fn require_animation_weight_mut(&mut self) -> &mut bool {
        &mut self.require_animation_weight
    }
    fn force_animation_transform(&self) -> &bool {
        &self.force_animation_transform
    }
    fn force_animation_transform_mut(&mut self) -> &mut bool {
        &mut self.force_animation_transform
    }
    fn connect_transform(&self) -> &super::core::LinearTransform {
        &self.connect_transform
    }
    fn connect_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.connect_transform
    }
    fn external_connect_transform(&self) -> &bool {
        &self.external_connect_transform
    }
    fn external_connect_transform_mut(&mut self) -> &mut bool {
        &mut self.external_connect_transform
    }
}

impl super::entity::GameComponentDataTrait for WarpAnimationComponentData {
}

impl super::entity::ComponentDataTrait for WarpAnimationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WarpAnimationComponentData {
}

impl super::core::DataBusPeerTrait for WarpAnimationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WarpAnimationComponentData {
}

impl super::core::DataContainerTrait for WarpAnimationComponentData {
}

pub static WARPANIMATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarpAnimationComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WarpBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "WarpAnimationBinding",
                rust_offset: offset_of!(WarpAnimationComponentData, warp_binding),
            },
            FieldInfoData {
                name: "CannedAnimBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "CannedAnimationBinding",
                rust_offset: offset_of!(WarpAnimationComponentData, canned_anim_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(WarpAnimationComponentData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "BoneToAlign",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(WarpAnimationComponentData, bone_to_align),
            },
            FieldInfoData {
                name: "RequireAnimationWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationComponentData, require_animation_weight),
            },
            FieldInfoData {
                name: "ForceAnimationTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationComponentData, force_animation_transform),
            },
            FieldInfoData {
                name: "ConnectTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(WarpAnimationComponentData, connect_transform),
            },
            FieldInfoData {
                name: "ExternalConnectTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WarpAnimationComponentData, external_connect_transform),
            },
        ],
    }),
    array_type: Some(WARPANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WarpAnimationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WARPANIMATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WARPANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarpAnimationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CannedAnimationBinding {
    pub level_index: super::ant::AntRef,
    pub scenario_index: super::ant::AntRef,
    pub actor_index: super::ant::AntRef,
    pub part_index: super::ant::AntRef,
    pub trigger_canned_animation: super::ant::AntRef,
    pub exit_canned_animation: super::ant::AntRef,
    pub external_time: super::ant::AntRef,
    pub blend_value: super::ant::AntRef,
    pub advance_scenario: super::ant::AntRef,
    pub entered_loop: super::ant::AntRef,
    pub almost_finished: super::ant::AntRef,
}

pub trait CannedAnimationBindingTrait: TypeObject {
    fn level_index(&self) -> &super::ant::AntRef;
    fn level_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn scenario_index(&self) -> &super::ant::AntRef;
    fn scenario_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn actor_index(&self) -> &super::ant::AntRef;
    fn actor_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn part_index(&self) -> &super::ant::AntRef;
    fn part_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn trigger_canned_animation(&self) -> &super::ant::AntRef;
    fn trigger_canned_animation_mut(&mut self) -> &mut super::ant::AntRef;
    fn exit_canned_animation(&self) -> &super::ant::AntRef;
    fn exit_canned_animation_mut(&mut self) -> &mut super::ant::AntRef;
    fn external_time(&self) -> &super::ant::AntRef;
    fn external_time_mut(&mut self) -> &mut super::ant::AntRef;
    fn blend_value(&self) -> &super::ant::AntRef;
    fn blend_value_mut(&mut self) -> &mut super::ant::AntRef;
    fn advance_scenario(&self) -> &super::ant::AntRef;
    fn advance_scenario_mut(&mut self) -> &mut super::ant::AntRef;
    fn entered_loop(&self) -> &super::ant::AntRef;
    fn entered_loop_mut(&mut self) -> &mut super::ant::AntRef;
    fn almost_finished(&self) -> &super::ant::AntRef;
    fn almost_finished_mut(&mut self) -> &mut super::ant::AntRef;
}

impl CannedAnimationBindingTrait for CannedAnimationBinding {
    fn level_index(&self) -> &super::ant::AntRef {
        &self.level_index
    }
    fn level_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.level_index
    }
    fn scenario_index(&self) -> &super::ant::AntRef {
        &self.scenario_index
    }
    fn scenario_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.scenario_index
    }
    fn actor_index(&self) -> &super::ant::AntRef {
        &self.actor_index
    }
    fn actor_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.actor_index
    }
    fn part_index(&self) -> &super::ant::AntRef {
        &self.part_index
    }
    fn part_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.part_index
    }
    fn trigger_canned_animation(&self) -> &super::ant::AntRef {
        &self.trigger_canned_animation
    }
    fn trigger_canned_animation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.trigger_canned_animation
    }
    fn exit_canned_animation(&self) -> &super::ant::AntRef {
        &self.exit_canned_animation
    }
    fn exit_canned_animation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.exit_canned_animation
    }
    fn external_time(&self) -> &super::ant::AntRef {
        &self.external_time
    }
    fn external_time_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.external_time
    }
    fn blend_value(&self) -> &super::ant::AntRef {
        &self.blend_value
    }
    fn blend_value_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.blend_value
    }
    fn advance_scenario(&self) -> &super::ant::AntRef {
        &self.advance_scenario
    }
    fn advance_scenario_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.advance_scenario
    }
    fn entered_loop(&self) -> &super::ant::AntRef {
        &self.entered_loop
    }
    fn entered_loop_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.entered_loop
    }
    fn almost_finished(&self) -> &super::ant::AntRef {
        &self.almost_finished
    }
    fn almost_finished_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.almost_finished
    }
}

pub static CANNEDANIMATIONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CannedAnimationBinding",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CannedAnimationBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LevelIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, level_index),
            },
            FieldInfoData {
                name: "ScenarioIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, scenario_index),
            },
            FieldInfoData {
                name: "ActorIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, actor_index),
            },
            FieldInfoData {
                name: "PartIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, part_index),
            },
            FieldInfoData {
                name: "TriggerCannedAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, trigger_canned_animation),
            },
            FieldInfoData {
                name: "ExitCannedAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, exit_canned_animation),
            },
            FieldInfoData {
                name: "ExternalTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, external_time),
            },
            FieldInfoData {
                name: "BlendValue",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, blend_value),
            },
            FieldInfoData {
                name: "AdvanceScenario",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, advance_scenario),
            },
            FieldInfoData {
                name: "EnteredLoop",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, entered_loop),
            },
            FieldInfoData {
                name: "AlmostFinished",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(CannedAnimationBinding, almost_finished),
            },
        ],
    }),
    array_type: Some(CANNEDANIMATIONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CannedAnimationBinding {
    fn type_info(&self) -> &'static TypeInfo {
        CANNEDANIMATIONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CANNEDANIMATIONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CannedAnimationBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CannedAnimationBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WarpAnimationBinding {
    pub connect_joint_group: super::ant::AntRef,
    pub connect_joint_weight: super::ant::AntRef,
    pub enable_align: super::ant::AntRef,
    pub disable_culling: super::ant::AntRef,
    pub translation_y_warp_tolerance: super::ant::AntRef,
}

pub trait WarpAnimationBindingTrait: TypeObject {
    fn connect_joint_group(&self) -> &super::ant::AntRef;
    fn connect_joint_group_mut(&mut self) -> &mut super::ant::AntRef;
    fn connect_joint_weight(&self) -> &super::ant::AntRef;
    fn connect_joint_weight_mut(&mut self) -> &mut super::ant::AntRef;
    fn enable_align(&self) -> &super::ant::AntRef;
    fn enable_align_mut(&mut self) -> &mut super::ant::AntRef;
    fn disable_culling(&self) -> &super::ant::AntRef;
    fn disable_culling_mut(&mut self) -> &mut super::ant::AntRef;
    fn translation_y_warp_tolerance(&self) -> &super::ant::AntRef;
    fn translation_y_warp_tolerance_mut(&mut self) -> &mut super::ant::AntRef;
}

impl WarpAnimationBindingTrait for WarpAnimationBinding {
    fn connect_joint_group(&self) -> &super::ant::AntRef {
        &self.connect_joint_group
    }
    fn connect_joint_group_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.connect_joint_group
    }
    fn connect_joint_weight(&self) -> &super::ant::AntRef {
        &self.connect_joint_weight
    }
    fn connect_joint_weight_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.connect_joint_weight
    }
    fn enable_align(&self) -> &super::ant::AntRef {
        &self.enable_align
    }
    fn enable_align_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enable_align
    }
    fn disable_culling(&self) -> &super::ant::AntRef {
        &self.disable_culling
    }
    fn disable_culling_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.disable_culling
    }
    fn translation_y_warp_tolerance(&self) -> &super::ant::AntRef {
        &self.translation_y_warp_tolerance
    }
    fn translation_y_warp_tolerance_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.translation_y_warp_tolerance
    }
}

pub static WARPANIMATIONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationBinding",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarpAnimationBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ConnectJointGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, connect_joint_group),
            },
            FieldInfoData {
                name: "ConnectJointWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, connect_joint_weight),
            },
            FieldInfoData {
                name: "EnableAlign",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, enable_align),
            },
            FieldInfoData {
                name: "DisableCulling",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, disable_culling),
            },
            FieldInfoData {
                name: "TranslationYWarpTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(WarpAnimationBinding, translation_y_warp_tolerance),
            },
        ],
    }),
    array_type: Some(WARPANIMATIONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WarpAnimationBinding {
    fn type_info(&self) -> &'static TypeInfo {
        WARPANIMATIONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WARPANIMATIONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarpAnimationBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarpAnimationBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WarningSystemComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub aim_warn_sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub missile_warn_sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub low_health_warn_sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub locking_warn_sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub locked_warn_sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub player_type: WarningPlayerType,
}

pub trait WarningSystemComponentDataTrait: super::entity::GameComponentDataTrait {
    fn aim_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn aim_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn missile_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn missile_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn low_health_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn low_health_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn locking_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn locking_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn locked_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn locked_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn player_type(&self) -> &WarningPlayerType;
    fn player_type_mut(&mut self) -> &mut WarningPlayerType;
}

impl WarningSystemComponentDataTrait for WarningSystemComponentData {
    fn aim_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.aim_warn_sound_effect
    }
    fn aim_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.aim_warn_sound_effect
    }
    fn missile_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.missile_warn_sound_effect
    }
    fn missile_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.missile_warn_sound_effect
    }
    fn low_health_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.low_health_warn_sound_effect
    }
    fn low_health_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.low_health_warn_sound_effect
    }
    fn locking_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.locking_warn_sound_effect
    }
    fn locking_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.locking_warn_sound_effect
    }
    fn locked_warn_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.locked_warn_sound_effect
    }
    fn locked_warn_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.locked_warn_sound_effect
    }
    fn player_type(&self) -> &WarningPlayerType {
        &self.player_type
    }
    fn player_type_mut(&mut self) -> &mut WarningPlayerType {
        &mut self.player_type
    }
}

impl super::entity::GameComponentDataTrait for WarningSystemComponentData {
}

impl super::entity::ComponentDataTrait for WarningSystemComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WarningSystemComponentData {
}

impl super::core::DataBusPeerTrait for WarningSystemComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WarningSystemComponentData {
}

impl super::core::DataContainerTrait for WarningSystemComponentData {
}

pub static WARNINGSYSTEMCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarningSystemComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WarningSystemComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AimWarnSoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, aim_warn_sound_effect),
            },
            FieldInfoData {
                name: "MissileWarnSoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, missile_warn_sound_effect),
            },
            FieldInfoData {
                name: "LowHealthWarnSoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, low_health_warn_sound_effect),
            },
            FieldInfoData {
                name: "LockingWarnSoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, locking_warn_sound_effect),
            },
            FieldInfoData {
                name: "LockedWarnSoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(WarningSystemComponentData, locked_warn_sound_effect),
            },
            FieldInfoData {
                name: "PlayerType",
                flags: MemberInfoFlags::new(0),
                field_type: "WarningPlayerType",
                rust_offset: offset_of!(WarningSystemComponentData, player_type),
            },
        ],
    }),
    array_type: Some(WARNINGSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WarningSystemComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WARNINGSYSTEMCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WARNINGSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarningSystemComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarningSystemComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WarningPlayerType {
    #[default]
    WPTInflictor = 0,
    WPTVictim = 1,
}

pub static WARNINGPLAYERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarningPlayerType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(WARNINGPLAYERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WarningPlayerType {
    fn type_info(&self) -> &'static TypeInfo {
        WARNINGPLAYERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WARNINGPLAYERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WarningPlayerType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WarningPlayerType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LensFlareComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub lens_flare: Option<Arc<Mutex<dyn super::world_sim::LensFlareEntityDataTrait>>>,
}

pub trait LensFlareComponentDataTrait: super::entity::GameComponentDataTrait {
    fn lens_flare(&self) -> &Option<Arc<Mutex<dyn super::world_sim::LensFlareEntityDataTrait>>>;
    fn lens_flare_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::LensFlareEntityDataTrait>>>;
}

impl LensFlareComponentDataTrait for LensFlareComponentData {
    fn lens_flare(&self) -> &Option<Arc<Mutex<dyn super::world_sim::LensFlareEntityDataTrait>>> {
        &self.lens_flare
    }
    fn lens_flare_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::LensFlareEntityDataTrait>>> {
        &mut self.lens_flare
    }
}

impl super::entity::GameComponentDataTrait for LensFlareComponentData {
}

impl super::entity::ComponentDataTrait for LensFlareComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LensFlareComponentData {
}

impl super::core::DataBusPeerTrait for LensFlareComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LensFlareComponentData {
}

impl super::core::DataContainerTrait for LensFlareComponentData {
}

pub static LENSFLARECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LensFlareComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LensFlare",
                flags: MemberInfoFlags::new(0),
                field_type: "LensFlareEntityData",
                rust_offset: offset_of!(LensFlareComponentData, lens_flare),
            },
        ],
    }),
    array_type: Some(LENSFLARECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LensFlareComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LENSFLARECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LENSFLARECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LensFlareComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LensFlareComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SphereReflectionVolumeComponentData {
    pub _glacier_base: ReflectionVolumeComponentData,
    pub reflection_volume: Option<Arc<Mutex<dyn super::world_sim::PbrSphereReflectionVolumeEntityDataTrait>>>,
}

pub trait SphereReflectionVolumeComponentDataTrait: ReflectionVolumeComponentDataTrait {
    fn reflection_volume(&self) -> &Option<Arc<Mutex<dyn super::world_sim::PbrSphereReflectionVolumeEntityDataTrait>>>;
    fn reflection_volume_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::PbrSphereReflectionVolumeEntityDataTrait>>>;
}

impl SphereReflectionVolumeComponentDataTrait for SphereReflectionVolumeComponentData {
    fn reflection_volume(&self) -> &Option<Arc<Mutex<dyn super::world_sim::PbrSphereReflectionVolumeEntityDataTrait>>> {
        &self.reflection_volume
    }
    fn reflection_volume_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::PbrSphereReflectionVolumeEntityDataTrait>>> {
        &mut self.reflection_volume
    }
}

impl ReflectionVolumeComponentDataTrait for SphereReflectionVolumeComponentData {
}

impl super::entity::GameComponentDataTrait for SphereReflectionVolumeComponentData {
}

impl super::entity::ComponentDataTrait for SphereReflectionVolumeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SphereReflectionVolumeComponentData {
}

impl super::core::DataBusPeerTrait for SphereReflectionVolumeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SphereReflectionVolumeComponentData {
}

impl super::core::DataContainerTrait for SphereReflectionVolumeComponentData {
}

pub static SPHEREREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereReflectionVolumeComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SphereReflectionVolumeComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ReflectionVolume",
                flags: MemberInfoFlags::new(0),
                field_type: "PbrSphereReflectionVolumeEntityData",
                rust_offset: offset_of!(SphereReflectionVolumeComponentData, reflection_volume),
            },
        ],
    }),
    array_type: Some(SPHEREREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SphereReflectionVolumeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SPHEREREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPHEREREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SphereReflectionVolumeComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SphereReflectionVolumeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoxReflectionVolumeComponentData {
    pub _glacier_base: ReflectionVolumeComponentData,
    pub reflection_volume: Option<Arc<Mutex<dyn super::world_sim::PbrBoxReflectionVolumeEntityDataTrait>>>,
}

pub trait BoxReflectionVolumeComponentDataTrait: ReflectionVolumeComponentDataTrait {
    fn reflection_volume(&self) -> &Option<Arc<Mutex<dyn super::world_sim::PbrBoxReflectionVolumeEntityDataTrait>>>;
    fn reflection_volume_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::PbrBoxReflectionVolumeEntityDataTrait>>>;
}

impl BoxReflectionVolumeComponentDataTrait for BoxReflectionVolumeComponentData {
    fn reflection_volume(&self) -> &Option<Arc<Mutex<dyn super::world_sim::PbrBoxReflectionVolumeEntityDataTrait>>> {
        &self.reflection_volume
    }
    fn reflection_volume_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::PbrBoxReflectionVolumeEntityDataTrait>>> {
        &mut self.reflection_volume
    }
}

impl ReflectionVolumeComponentDataTrait for BoxReflectionVolumeComponentData {
}

impl super::entity::GameComponentDataTrait for BoxReflectionVolumeComponentData {
}

impl super::entity::ComponentDataTrait for BoxReflectionVolumeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BoxReflectionVolumeComponentData {
}

impl super::core::DataBusPeerTrait for BoxReflectionVolumeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoxReflectionVolumeComponentData {
}

impl super::core::DataContainerTrait for BoxReflectionVolumeComponentData {
}

pub static BOXREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoxReflectionVolumeComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoxReflectionVolumeComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ReflectionVolume",
                flags: MemberInfoFlags::new(0),
                field_type: "PbrBoxReflectionVolumeEntityData",
                rust_offset: offset_of!(BoxReflectionVolumeComponentData, reflection_volume),
            },
        ],
    }),
    array_type: Some(BOXREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BoxReflectionVolumeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BOXREFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOXREFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoxReflectionVolumeComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoxReflectionVolumeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReflectionVolumeComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait ReflectionVolumeComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl ReflectionVolumeComponentDataTrait for ReflectionVolumeComponentData {
}

impl super::entity::GameComponentDataTrait for ReflectionVolumeComponentData {
}

impl super::entity::ComponentDataTrait for ReflectionVolumeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ReflectionVolumeComponentData {
}

impl super::core::DataBusPeerTrait for ReflectionVolumeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ReflectionVolumeComponentData {
}

impl super::core::DataContainerTrait for ReflectionVolumeComponentData {
}

pub static REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReflectionVolumeComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReflectionVolumeComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(REFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ReflectionVolumeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        REFLECTIONVOLUMECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static REFLECTIONVOLUMECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReflectionVolumeComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ReflectionVolumeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LightComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub light: Option<Arc<Mutex<dyn super::world_sim::LocalLightEntityDataTrait>>>,
}

pub trait LightComponentDataTrait: super::entity::GameComponentDataTrait {
    fn light(&self) -> &Option<Arc<Mutex<dyn super::world_sim::LocalLightEntityDataTrait>>>;
    fn light_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::LocalLightEntityDataTrait>>>;
}

impl LightComponentDataTrait for LightComponentData {
    fn light(&self) -> &Option<Arc<Mutex<dyn super::world_sim::LocalLightEntityDataTrait>>> {
        &self.light
    }
    fn light_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_sim::LocalLightEntityDataTrait>>> {
        &mut self.light
    }
}

impl super::entity::GameComponentDataTrait for LightComponentData {
}

impl super::entity::ComponentDataTrait for LightComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for LightComponentData {
}

impl super::core::DataBusPeerTrait for LightComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LightComponentData {
}

impl super::core::DataContainerTrait for LightComponentData {
}

pub static LIGHTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LightComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Light",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalLightEntityData",
                rust_offset: offset_of!(LightComponentData, light),
            },
        ],
    }),
    array_type: Some(LIGHTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LightComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        LIGHTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LIGHTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LightComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleInputSettings {
    pub _glacier_base: super::input_shared::BaseInputSettings,
    pub vehicle_boost_is_toggle: bool,
    pub vehicle_boost_is_toggle_min_input: f32,
}

pub trait VehicleInputSettingsTrait: super::input_shared::BaseInputSettingsTrait {
    fn vehicle_boost_is_toggle(&self) -> &bool;
    fn vehicle_boost_is_toggle_mut(&mut self) -> &mut bool;
    fn vehicle_boost_is_toggle_min_input(&self) -> &f32;
    fn vehicle_boost_is_toggle_min_input_mut(&mut self) -> &mut f32;
}

impl VehicleInputSettingsTrait for VehicleInputSettings {
    fn vehicle_boost_is_toggle(&self) -> &bool {
        &self.vehicle_boost_is_toggle
    }
    fn vehicle_boost_is_toggle_mut(&mut self) -> &mut bool {
        &mut self.vehicle_boost_is_toggle
    }
    fn vehicle_boost_is_toggle_min_input(&self) -> &f32 {
        &self.vehicle_boost_is_toggle_min_input
    }
    fn vehicle_boost_is_toggle_min_input_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_boost_is_toggle_min_input
    }
}

impl super::input_shared::BaseInputSettingsTrait for VehicleInputSettings {
}

impl super::core::DataContainerTrait for VehicleInputSettings {
}

pub static VEHICLEINPUTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleInputSettings",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::input_shared::BASEINPUTSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleInputSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VehicleBoostIsToggle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleInputSettings, vehicle_boost_is_toggle),
            },
            FieldInfoData {
                name: "VehicleBoostIsToggleMinInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleInputSettings, vehicle_boost_is_toggle_min_input),
            },
        ],
    }),
    array_type: Some(VEHICLEINPUTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleInputSettings {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEINPUTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEINPUTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleInputSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleInputSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HealthZoneInfo {
    pub health_is_valid: bool,
    pub health: u32,
    pub is_protected_shield_active: bool,
}

pub trait HealthZoneInfoTrait: TypeObject {
    fn health_is_valid(&self) -> &bool;
    fn health_is_valid_mut(&mut self) -> &mut bool;
    fn health(&self) -> &u32;
    fn health_mut(&mut self) -> &mut u32;
    fn is_protected_shield_active(&self) -> &bool;
    fn is_protected_shield_active_mut(&mut self) -> &mut bool;
}

impl HealthZoneInfoTrait for HealthZoneInfo {
    fn health_is_valid(&self) -> &bool {
        &self.health_is_valid
    }
    fn health_is_valid_mut(&mut self) -> &mut bool {
        &mut self.health_is_valid
    }
    fn health(&self) -> &u32 {
        &self.health
    }
    fn health_mut(&mut self) -> &mut u32 {
        &mut self.health
    }
    fn is_protected_shield_active(&self) -> &bool {
        &self.is_protected_shield_active
    }
    fn is_protected_shield_active_mut(&mut self) -> &mut bool {
        &mut self.is_protected_shield_active
    }
}

pub static HEALTHZONEINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HealthZoneInfo",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HealthZoneInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HealthIsValid",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HealthZoneInfo, health_is_valid),
            },
            FieldInfoData {
                name: "Health",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(HealthZoneInfo, health),
            },
            FieldInfoData {
                name: "IsProtectedShieldActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HealthZoneInfo, is_protected_shield_active),
            },
        ],
    }),
    array_type: Some(HEALTHZONEINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for HealthZoneInfo {
    fn type_info(&self) -> &'static TypeInfo {
        HEALTHZONEINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static HEALTHZONEINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HealthZoneInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("HealthZoneInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleEntryListenerComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub vehicle_entry_listener: VehicleEntryListenerBinding,
    pub vehicle_camera_control: VehicleCameraControlBinding,
    pub read_binding: VehicleEntryListenerReadBinding,
    pub animation_entity_space_priority: i32,
    pub animation_wheel_transform_delay: f32,
}

pub trait VehicleEntryListenerComponentDataTrait: super::entity::GameComponentDataTrait {
    fn vehicle_entry_listener(&self) -> &VehicleEntryListenerBinding;
    fn vehicle_entry_listener_mut(&mut self) -> &mut VehicleEntryListenerBinding;
    fn vehicle_camera_control(&self) -> &VehicleCameraControlBinding;
    fn vehicle_camera_control_mut(&mut self) -> &mut VehicleCameraControlBinding;
    fn read_binding(&self) -> &VehicleEntryListenerReadBinding;
    fn read_binding_mut(&mut self) -> &mut VehicleEntryListenerReadBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn animation_wheel_transform_delay(&self) -> &f32;
    fn animation_wheel_transform_delay_mut(&mut self) -> &mut f32;
}

impl VehicleEntryListenerComponentDataTrait for VehicleEntryListenerComponentData {
    fn vehicle_entry_listener(&self) -> &VehicleEntryListenerBinding {
        &self.vehicle_entry_listener
    }
    fn vehicle_entry_listener_mut(&mut self) -> &mut VehicleEntryListenerBinding {
        &mut self.vehicle_entry_listener
    }
    fn vehicle_camera_control(&self) -> &VehicleCameraControlBinding {
        &self.vehicle_camera_control
    }
    fn vehicle_camera_control_mut(&mut self) -> &mut VehicleCameraControlBinding {
        &mut self.vehicle_camera_control
    }
    fn read_binding(&self) -> &VehicleEntryListenerReadBinding {
        &self.read_binding
    }
    fn read_binding_mut(&mut self) -> &mut VehicleEntryListenerReadBinding {
        &mut self.read_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn animation_wheel_transform_delay(&self) -> &f32 {
        &self.animation_wheel_transform_delay
    }
    fn animation_wheel_transform_delay_mut(&mut self) -> &mut f32 {
        &mut self.animation_wheel_transform_delay
    }
}

impl super::entity::GameComponentDataTrait for VehicleEntryListenerComponentData {
}

impl super::entity::ComponentDataTrait for VehicleEntryListenerComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleEntryListenerComponentData {
}

impl super::core::DataBusPeerTrait for VehicleEntryListenerComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleEntryListenerComponentData {
}

impl super::core::DataContainerTrait for VehicleEntryListenerComponentData {
}

pub static VEHICLEENTRYLISTENERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntryListenerComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VehicleEntryListener",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleEntryListenerBinding",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, vehicle_entry_listener),
            },
            FieldInfoData {
                name: "VehicleCameraControl",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleCameraControlBinding",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, vehicle_camera_control),
            },
            FieldInfoData {
                name: "ReadBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleEntryListenerReadBinding",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, read_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "AnimationWheelTransformDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntryListenerComponentData, animation_wheel_transform_delay),
            },
        ],
    }),
    array_type: Some(VEHICLEENTRYLISTENERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleEntryListenerComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTRYLISTENERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEENTRYLISTENERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntryListenerComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleCameraControlBinding {
    pub enable_animated_vehicle_camera: super::ant::AntRef,
}

pub trait VehicleCameraControlBindingTrait: TypeObject {
    fn enable_animated_vehicle_camera(&self) -> &super::ant::AntRef;
    fn enable_animated_vehicle_camera_mut(&mut self) -> &mut super::ant::AntRef;
}

impl VehicleCameraControlBindingTrait for VehicleCameraControlBinding {
    fn enable_animated_vehicle_camera(&self) -> &super::ant::AntRef {
        &self.enable_animated_vehicle_camera
    }
    fn enable_animated_vehicle_camera_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enable_animated_vehicle_camera
    }
}

pub static VEHICLECAMERACONTROLBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCameraControlBinding",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleCameraControlBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnableAnimatedVehicleCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleCameraControlBinding, enable_animated_vehicle_camera),
            },
        ],
    }),
    array_type: Some(VEHICLECAMERACONTROLBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleCameraControlBinding {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECAMERACONTROLBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLECAMERACONTROLBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCameraControlBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleCameraControlBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleEntryListenerReadBinding {
    pub in_vehicle_node: super::ant::AntRef,
    pub vehicle_align_index: super::ant::AntRef,
    pub vehicle_entry_index_updated: super::ant::AntRef,
    pub vehicle_allowed_to_switch_seat: super::ant::AntRef,
}

pub trait VehicleEntryListenerReadBindingTrait: TypeObject {
    fn in_vehicle_node(&self) -> &super::ant::AntRef;
    fn in_vehicle_node_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_align_index(&self) -> &super::ant::AntRef;
    fn vehicle_align_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_index_updated(&self) -> &super::ant::AntRef;
    fn vehicle_entry_index_updated_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_allowed_to_switch_seat(&self) -> &super::ant::AntRef;
    fn vehicle_allowed_to_switch_seat_mut(&mut self) -> &mut super::ant::AntRef;
}

impl VehicleEntryListenerReadBindingTrait for VehicleEntryListenerReadBinding {
    fn in_vehicle_node(&self) -> &super::ant::AntRef {
        &self.in_vehicle_node
    }
    fn in_vehicle_node_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_vehicle_node
    }
    fn vehicle_align_index(&self) -> &super::ant::AntRef {
        &self.vehicle_align_index
    }
    fn vehicle_align_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_align_index
    }
    fn vehicle_entry_index_updated(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_index_updated
    }
    fn vehicle_entry_index_updated_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_index_updated
    }
    fn vehicle_allowed_to_switch_seat(&self) -> &super::ant::AntRef {
        &self.vehicle_allowed_to_switch_seat
    }
    fn vehicle_allowed_to_switch_seat_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_allowed_to_switch_seat
    }
}

pub static VEHICLEENTRYLISTENERREADBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerReadBinding",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntryListenerReadBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InVehicleNode",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerReadBinding, in_vehicle_node),
            },
            FieldInfoData {
                name: "VehicleAlignIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerReadBinding, vehicle_align_index),
            },
            FieldInfoData {
                name: "VehicleEntryIndexUpdated",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerReadBinding, vehicle_entry_index_updated),
            },
            FieldInfoData {
                name: "VehicleAllowedToSwitchSeat",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerReadBinding, vehicle_allowed_to_switch_seat),
            },
        ],
    }),
    array_type: Some(VEHICLEENTRYLISTENERREADBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleEntryListenerReadBinding {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTRYLISTENERREADBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEENTRYLISTENERREADBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerReadBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntryListenerReadBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleEntryListenerBinding {
    pub in_vehicle: super::ant::AntRef,
    pub in_open_entry: super::ant::AntRef,
    pub vehicle_enter_direction: super::ant::AntRef,
    pub vehicle_speed: super::ant::AntRef,
    pub vehicle_entry_fire: super::ant::AntRef,
    pub vehicle_entry_yaw: super::ant::AntRef,
    pub vehicle_entry_relative_yaw: super::ant::AntRef,
    pub vehicle_entry_pitch: super::ant::AntRef,
    pub vehicle_entry_roll: super::ant::AntRef,
    pub vehicle_entry_rotation: super::ant::AntRef,
    pub vehicle_entry_force_x: super::ant::AntRef,
    pub vehicle_entry_force_y: super::ant::AntRef,
    pub vehicle_entry_force_z: super::ant::AntRef,
    pub vehicle_previous_entry_index: super::ant::AntRef,
    pub vehicle_entry_index: super::ant::AntRef,
    pub vehicle_open_entry_index: super::ant::AntRef,
    pub in_vehicle_retrigger: super::ant::AntRef,
    pub vehicle_entry_chooser_index: super::ant::AntRef,
}

pub trait VehicleEntryListenerBindingTrait: TypeObject {
    fn in_vehicle(&self) -> &super::ant::AntRef;
    fn in_vehicle_mut(&mut self) -> &mut super::ant::AntRef;
    fn in_open_entry(&self) -> &super::ant::AntRef;
    fn in_open_entry_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_enter_direction(&self) -> &super::ant::AntRef;
    fn vehicle_enter_direction_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_speed(&self) -> &super::ant::AntRef;
    fn vehicle_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_fire(&self) -> &super::ant::AntRef;
    fn vehicle_entry_fire_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_yaw(&self) -> &super::ant::AntRef;
    fn vehicle_entry_yaw_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_relative_yaw(&self) -> &super::ant::AntRef;
    fn vehicle_entry_relative_yaw_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_pitch(&self) -> &super::ant::AntRef;
    fn vehicle_entry_pitch_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_roll(&self) -> &super::ant::AntRef;
    fn vehicle_entry_roll_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_rotation(&self) -> &super::ant::AntRef;
    fn vehicle_entry_rotation_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_force_x(&self) -> &super::ant::AntRef;
    fn vehicle_entry_force_x_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_force_y(&self) -> &super::ant::AntRef;
    fn vehicle_entry_force_y_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_force_z(&self) -> &super::ant::AntRef;
    fn vehicle_entry_force_z_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_previous_entry_index(&self) -> &super::ant::AntRef;
    fn vehicle_previous_entry_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_index(&self) -> &super::ant::AntRef;
    fn vehicle_entry_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_open_entry_index(&self) -> &super::ant::AntRef;
    fn vehicle_open_entry_index_mut(&mut self) -> &mut super::ant::AntRef;
    fn in_vehicle_retrigger(&self) -> &super::ant::AntRef;
    fn in_vehicle_retrigger_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_entry_chooser_index(&self) -> &super::ant::AntRef;
    fn vehicle_entry_chooser_index_mut(&mut self) -> &mut super::ant::AntRef;
}

impl VehicleEntryListenerBindingTrait for VehicleEntryListenerBinding {
    fn in_vehicle(&self) -> &super::ant::AntRef {
        &self.in_vehicle
    }
    fn in_vehicle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_vehicle
    }
    fn in_open_entry(&self) -> &super::ant::AntRef {
        &self.in_open_entry
    }
    fn in_open_entry_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_open_entry
    }
    fn vehicle_enter_direction(&self) -> &super::ant::AntRef {
        &self.vehicle_enter_direction
    }
    fn vehicle_enter_direction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_enter_direction
    }
    fn vehicle_speed(&self) -> &super::ant::AntRef {
        &self.vehicle_speed
    }
    fn vehicle_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_speed
    }
    fn vehicle_entry_fire(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_fire
    }
    fn vehicle_entry_fire_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_fire
    }
    fn vehicle_entry_yaw(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_yaw
    }
    fn vehicle_entry_yaw_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_yaw
    }
    fn vehicle_entry_relative_yaw(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_relative_yaw
    }
    fn vehicle_entry_relative_yaw_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_relative_yaw
    }
    fn vehicle_entry_pitch(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_pitch
    }
    fn vehicle_entry_pitch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_pitch
    }
    fn vehicle_entry_roll(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_roll
    }
    fn vehicle_entry_roll_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_roll
    }
    fn vehicle_entry_rotation(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_rotation
    }
    fn vehicle_entry_rotation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_rotation
    }
    fn vehicle_entry_force_x(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_force_x
    }
    fn vehicle_entry_force_x_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_force_x
    }
    fn vehicle_entry_force_y(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_force_y
    }
    fn vehicle_entry_force_y_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_force_y
    }
    fn vehicle_entry_force_z(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_force_z
    }
    fn vehicle_entry_force_z_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_force_z
    }
    fn vehicle_previous_entry_index(&self) -> &super::ant::AntRef {
        &self.vehicle_previous_entry_index
    }
    fn vehicle_previous_entry_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_previous_entry_index
    }
    fn vehicle_entry_index(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_index
    }
    fn vehicle_entry_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_index
    }
    fn vehicle_open_entry_index(&self) -> &super::ant::AntRef {
        &self.vehicle_open_entry_index
    }
    fn vehicle_open_entry_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_open_entry_index
    }
    fn in_vehicle_retrigger(&self) -> &super::ant::AntRef {
        &self.in_vehicle_retrigger
    }
    fn in_vehicle_retrigger_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.in_vehicle_retrigger
    }
    fn vehicle_entry_chooser_index(&self) -> &super::ant::AntRef {
        &self.vehicle_entry_chooser_index
    }
    fn vehicle_entry_chooser_index_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_entry_chooser_index
    }
}

pub static VEHICLEENTRYLISTENERBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerBinding",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntryListenerBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, in_vehicle),
            },
            FieldInfoData {
                name: "InOpenEntry",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, in_open_entry),
            },
            FieldInfoData {
                name: "VehicleEnterDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_enter_direction),
            },
            FieldInfoData {
                name: "VehicleSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_speed),
            },
            FieldInfoData {
                name: "VehicleEntryFire",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_fire),
            },
            FieldInfoData {
                name: "VehicleEntryYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_yaw),
            },
            FieldInfoData {
                name: "VehicleEntryRelativeYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_relative_yaw),
            },
            FieldInfoData {
                name: "VehicleEntryPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_pitch),
            },
            FieldInfoData {
                name: "VehicleEntryRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_roll),
            },
            FieldInfoData {
                name: "VehicleEntryRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_rotation),
            },
            FieldInfoData {
                name: "VehicleEntryForceX",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_force_x),
            },
            FieldInfoData {
                name: "VehicleEntryForceY",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_force_y),
            },
            FieldInfoData {
                name: "VehicleEntryForceZ",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_force_z),
            },
            FieldInfoData {
                name: "VehiclePreviousEntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_previous_entry_index),
            },
            FieldInfoData {
                name: "VehicleEntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_index),
            },
            FieldInfoData {
                name: "VehicleOpenEntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_open_entry_index),
            },
            FieldInfoData {
                name: "InVehicleRetrigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, in_vehicle_retrigger),
            },
            FieldInfoData {
                name: "VehicleEntryChooserIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VehicleEntryListenerBinding, vehicle_entry_chooser_index),
            },
        ],
    }),
    array_type: Some(VEHICLEENTRYLISTENERBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleEntryListenerBinding {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTRYLISTENERBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEENTRYLISTENERBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryListenerBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntryListenerBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientCameraToComponentsInitMessage {
}

pub trait ClientCameraToComponentsInitMessageTrait: TypeObject {
}

impl ClientCameraToComponentsInitMessageTrait for ClientCameraToComponentsInitMessage {
}

pub static CLIENTCAMERATOCOMPONENTSINITMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientCameraToComponentsInitMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientCameraToComponentsInitMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientCameraToComponentsInitMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTCAMERATOCOMPONENTSINITMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct VehicleToComponentsStartDisabledDamagedMessage {
}

pub trait VehicleToComponentsStartDisabledDamagedMessageTrait: TypeObject {
}

impl VehicleToComponentsStartDisabledDamagedMessageTrait for VehicleToComponentsStartDisabledDamagedMessage {
}

pub static VEHICLETOCOMPONENTSSTARTDISABLEDDAMAGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleToComponentsStartDisabledDamagedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleToComponentsStartDisabledDamagedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for VehicleToComponentsStartDisabledDamagedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLETOCOMPONENTSSTARTDISABLEDDAMAGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct ClientVehicleToComponentsHealthChangedMessage {
}

pub trait ClientVehicleToComponentsHealthChangedMessageTrait: TypeObject {
}

impl ClientVehicleToComponentsHealthChangedMessageTrait for ClientVehicleToComponentsHealthChangedMessage {
}

pub static CLIENTVEHICLETOCOMPONENTSHEALTHCHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientVehicleToComponentsHealthChangedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientVehicleToComponentsHealthChangedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientVehicleToComponentsHealthChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTVEHICLETOCOMPONENTSHEALTHCHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct VehicleEntityData {
    pub _glacier_base: super::gameplay_sim::ControllableEntityData,
    pub controllable_type: String,
    pub allow_vehicle_outside_combat_areas: bool,
    pub disabled_damage_threshold: f32,
    pub pre_destruction_damage_threshold: f32,
    pub front_health_zone: VehicleHealthZoneData,
    pub rear_health_zone: VehicleHealthZoneData,
    pub left_health_zone: VehicleHealthZoneData,
    pub right_health_zone: VehicleHealthZoneData,
    pub top_health_zone: VehicleHealthZoneData,
    pub use_top_zone: bool,
    pub top_hit_height: f32,
    pub top_hit_angle: f32,
    pub health_zones_share_damage: bool,
    pub regeneration_delay: f32,
    pub regeneration_rate: f32,
    pub use_protected_shields: bool,
    pub armor_multiplier: f32,
    pub regeneration_delay_multiplier: f32,
    pub regeneration_rate_multiplier: f32,
    pub emergency_repair_health: f32,
    pub decay_delay: f32,
    pub decay_rate: f32,
    pub show_player_health: bool,
    pub use_self_for_self_destruct: bool,
    pub critically_damaged_effect: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
    pub critically_damaged_effect_position: super::core::Vec3,
    pub critical_damage_time: f32,
    pub pre_explosion_effect: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
    pub pre_explosion_effect_position: super::core::Vec3,
    pub pre_explosion_time: f32,
    pub bypass_pre_destruction: bool,
    pub random_pre_destruction: bool,
    pub explosion: Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>>,
    pub abandoned_explosion_damage_multiplier: f32,
    pub mesh_type: super::render_base::MeshType,
    pub mesh_part_count: u32,
    pub foreground_render_cockpit_mesh: bool,
    pub motion_blur_mask: bool,
    pub suppress_damage_by_passengers: bool,
    pub hud_data: VehicleHudData,
    pub name_sid: String,
    pub max_players_in_vehicle: i32,
    pub min_speed_for_mine_activation: f32,
    pub trigger_vehicle_detonation: bool,
    pub upside_down_damage: f32,
    pub upside_down_damage_delay: f32,
    pub upside_down_angle: f32,
    pub water_damage: f32,
    pub below_water_damage_delay: f32,
    pub water_damage_offset: f32,
    pub is_affected_by_e_m_p: bool,
    pub velocity_damage_threshold: f32,
    pub velocity_damage_magnifier: f32,
    pub can_take_dynamic_fire_damage: bool,
    pub always_deal_collision_damage: bool,
    pub has_exclusive_entries: bool,
    pub prohibit_entry_switching: bool,
    pub throw_out_soldier_inside_on_water_damage: bool,
    pub kill_soldier_collision_speed_threshold: f32,
    pub kill_soldier_collision_speed_threshold_block_time: f32,
    pub ignore_soldier_collision_normal: bool,
    pub chose_exit_point_by_direction: bool,
    pub exit_speed_threshold: f32,
    pub exit_direction_speed_threshold: f32,
    pub enter_allowed: bool,
    pub exit_allowed: bool,
    pub enable_groundmap_lighting: bool,
    pub use_as_team_spawner: bool,
    pub f_l_i_r_value: f32,
    pub f_l_i_r_key_color: super::core::Vec3,
    pub m_p_mode: MPModeData,
    pub exit_camera_switch_delay: f32,
    pub angle_of_impact: AngleOfImpactData,
    pub is_lockable: bool,
    pub locking_time_multiplier: f32,
    pub vehicle_lockable_info: VehicleLockableInfoData,
    pub never_report_vehicle_as_empty: bool,
    pub a_i_target: bool,
    pub high_altitude_lock_height: f32,
    pub use_low_altitude_heat_signature: bool,
    pub sound: Option<Arc<Mutex<dyn VehicleSoundDataTrait>>>,
    pub voice_over_info: Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>>,
    pub nametag_height_scale: f32,
    pub spotting_fov_scale: f32,
    pub use_spotting_target_component_for_raycast: bool,
    pub interaction_offset: super::core::Vec3,
    pub equipment_fake_vehicle: bool,
    pub explosion_packs_attachable: bool,
    pub character_blueprint_override: Option<Arc<Mutex<dyn CharacterBlueprintTrait>>>,
    pub damage_giver_override_owner_vehicle: bool,
    pub enable_sub_realm: bool,
    pub causes_a_i_to_flee: bool,
    pub a_i_flee_radius: f32,
    pub a_i_sound_category: AIVehicleSoundCategory,
    pub victim_offset_override: super::core::Vec3,
}

pub trait VehicleEntityDataTrait: super::gameplay_sim::ControllableEntityDataTrait {
    fn controllable_type(&self) -> &String;
    fn controllable_type_mut(&mut self) -> &mut String;
    fn allow_vehicle_outside_combat_areas(&self) -> &bool;
    fn allow_vehicle_outside_combat_areas_mut(&mut self) -> &mut bool;
    fn disabled_damage_threshold(&self) -> &f32;
    fn disabled_damage_threshold_mut(&mut self) -> &mut f32;
    fn pre_destruction_damage_threshold(&self) -> &f32;
    fn pre_destruction_damage_threshold_mut(&mut self) -> &mut f32;
    fn front_health_zone(&self) -> &VehicleHealthZoneData;
    fn front_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn rear_health_zone(&self) -> &VehicleHealthZoneData;
    fn rear_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn left_health_zone(&self) -> &VehicleHealthZoneData;
    fn left_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn right_health_zone(&self) -> &VehicleHealthZoneData;
    fn right_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn top_health_zone(&self) -> &VehicleHealthZoneData;
    fn top_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn use_top_zone(&self) -> &bool;
    fn use_top_zone_mut(&mut self) -> &mut bool;
    fn top_hit_height(&self) -> &f32;
    fn top_hit_height_mut(&mut self) -> &mut f32;
    fn top_hit_angle(&self) -> &f32;
    fn top_hit_angle_mut(&mut self) -> &mut f32;
    fn health_zones_share_damage(&self) -> &bool;
    fn health_zones_share_damage_mut(&mut self) -> &mut bool;
    fn regeneration_delay(&self) -> &f32;
    fn regeneration_delay_mut(&mut self) -> &mut f32;
    fn regeneration_rate(&self) -> &f32;
    fn regeneration_rate_mut(&mut self) -> &mut f32;
    fn use_protected_shields(&self) -> &bool;
    fn use_protected_shields_mut(&mut self) -> &mut bool;
    fn armor_multiplier(&self) -> &f32;
    fn armor_multiplier_mut(&mut self) -> &mut f32;
    fn regeneration_delay_multiplier(&self) -> &f32;
    fn regeneration_delay_multiplier_mut(&mut self) -> &mut f32;
    fn regeneration_rate_multiplier(&self) -> &f32;
    fn regeneration_rate_multiplier_mut(&mut self) -> &mut f32;
    fn emergency_repair_health(&self) -> &f32;
    fn emergency_repair_health_mut(&mut self) -> &mut f32;
    fn decay_delay(&self) -> &f32;
    fn decay_delay_mut(&mut self) -> &mut f32;
    fn decay_rate(&self) -> &f32;
    fn decay_rate_mut(&mut self) -> &mut f32;
    fn show_player_health(&self) -> &bool;
    fn show_player_health_mut(&mut self) -> &mut bool;
    fn use_self_for_self_destruct(&self) -> &bool;
    fn use_self_for_self_destruct_mut(&mut self) -> &mut bool;
    fn critically_damaged_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn critically_damaged_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn critically_damaged_effect_position(&self) -> &super::core::Vec3;
    fn critically_damaged_effect_position_mut(&mut self) -> &mut super::core::Vec3;
    fn critical_damage_time(&self) -> &f32;
    fn critical_damage_time_mut(&mut self) -> &mut f32;
    fn pre_explosion_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn pre_explosion_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn pre_explosion_effect_position(&self) -> &super::core::Vec3;
    fn pre_explosion_effect_position_mut(&mut self) -> &mut super::core::Vec3;
    fn pre_explosion_time(&self) -> &f32;
    fn pre_explosion_time_mut(&mut self) -> &mut f32;
    fn bypass_pre_destruction(&self) -> &bool;
    fn bypass_pre_destruction_mut(&mut self) -> &mut bool;
    fn random_pre_destruction(&self) -> &bool;
    fn random_pre_destruction_mut(&mut self) -> &mut bool;
    fn explosion(&self) -> &Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>>;
    fn explosion_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>>;
    fn abandoned_explosion_damage_multiplier(&self) -> &f32;
    fn abandoned_explosion_damage_multiplier_mut(&mut self) -> &mut f32;
    fn mesh_type(&self) -> &super::render_base::MeshType;
    fn mesh_type_mut(&mut self) -> &mut super::render_base::MeshType;
    fn mesh_part_count(&self) -> &u32;
    fn mesh_part_count_mut(&mut self) -> &mut u32;
    fn foreground_render_cockpit_mesh(&self) -> &bool;
    fn foreground_render_cockpit_mesh_mut(&mut self) -> &mut bool;
    fn motion_blur_mask(&self) -> &bool;
    fn motion_blur_mask_mut(&mut self) -> &mut bool;
    fn suppress_damage_by_passengers(&self) -> &bool;
    fn suppress_damage_by_passengers_mut(&mut self) -> &mut bool;
    fn hud_data(&self) -> &VehicleHudData;
    fn hud_data_mut(&mut self) -> &mut VehicleHudData;
    fn name_sid(&self) -> &String;
    fn name_sid_mut(&mut self) -> &mut String;
    fn max_players_in_vehicle(&self) -> &i32;
    fn max_players_in_vehicle_mut(&mut self) -> &mut i32;
    fn min_speed_for_mine_activation(&self) -> &f32;
    fn min_speed_for_mine_activation_mut(&mut self) -> &mut f32;
    fn trigger_vehicle_detonation(&self) -> &bool;
    fn trigger_vehicle_detonation_mut(&mut self) -> &mut bool;
    fn upside_down_damage(&self) -> &f32;
    fn upside_down_damage_mut(&mut self) -> &mut f32;
    fn upside_down_damage_delay(&self) -> &f32;
    fn upside_down_damage_delay_mut(&mut self) -> &mut f32;
    fn upside_down_angle(&self) -> &f32;
    fn upside_down_angle_mut(&mut self) -> &mut f32;
    fn water_damage(&self) -> &f32;
    fn water_damage_mut(&mut self) -> &mut f32;
    fn below_water_damage_delay(&self) -> &f32;
    fn below_water_damage_delay_mut(&mut self) -> &mut f32;
    fn water_damage_offset(&self) -> &f32;
    fn water_damage_offset_mut(&mut self) -> &mut f32;
    fn is_affected_by_e_m_p(&self) -> &bool;
    fn is_affected_by_e_m_p_mut(&mut self) -> &mut bool;
    fn velocity_damage_threshold(&self) -> &f32;
    fn velocity_damage_threshold_mut(&mut self) -> &mut f32;
    fn velocity_damage_magnifier(&self) -> &f32;
    fn velocity_damage_magnifier_mut(&mut self) -> &mut f32;
    fn can_take_dynamic_fire_damage(&self) -> &bool;
    fn can_take_dynamic_fire_damage_mut(&mut self) -> &mut bool;
    fn always_deal_collision_damage(&self) -> &bool;
    fn always_deal_collision_damage_mut(&mut self) -> &mut bool;
    fn has_exclusive_entries(&self) -> &bool;
    fn has_exclusive_entries_mut(&mut self) -> &mut bool;
    fn prohibit_entry_switching(&self) -> &bool;
    fn prohibit_entry_switching_mut(&mut self) -> &mut bool;
    fn throw_out_soldier_inside_on_water_damage(&self) -> &bool;
    fn throw_out_soldier_inside_on_water_damage_mut(&mut self) -> &mut bool;
    fn kill_soldier_collision_speed_threshold(&self) -> &f32;
    fn kill_soldier_collision_speed_threshold_mut(&mut self) -> &mut f32;
    fn kill_soldier_collision_speed_threshold_block_time(&self) -> &f32;
    fn kill_soldier_collision_speed_threshold_block_time_mut(&mut self) -> &mut f32;
    fn ignore_soldier_collision_normal(&self) -> &bool;
    fn ignore_soldier_collision_normal_mut(&mut self) -> &mut bool;
    fn chose_exit_point_by_direction(&self) -> &bool;
    fn chose_exit_point_by_direction_mut(&mut self) -> &mut bool;
    fn exit_speed_threshold(&self) -> &f32;
    fn exit_speed_threshold_mut(&mut self) -> &mut f32;
    fn exit_direction_speed_threshold(&self) -> &f32;
    fn exit_direction_speed_threshold_mut(&mut self) -> &mut f32;
    fn enter_allowed(&self) -> &bool;
    fn enter_allowed_mut(&mut self) -> &mut bool;
    fn exit_allowed(&self) -> &bool;
    fn exit_allowed_mut(&mut self) -> &mut bool;
    fn enable_groundmap_lighting(&self) -> &bool;
    fn enable_groundmap_lighting_mut(&mut self) -> &mut bool;
    fn use_as_team_spawner(&self) -> &bool;
    fn use_as_team_spawner_mut(&mut self) -> &mut bool;
    fn f_l_i_r_value(&self) -> &f32;
    fn f_l_i_r_value_mut(&mut self) -> &mut f32;
    fn f_l_i_r_key_color(&self) -> &super::core::Vec3;
    fn f_l_i_r_key_color_mut(&mut self) -> &mut super::core::Vec3;
    fn m_p_mode(&self) -> &MPModeData;
    fn m_p_mode_mut(&mut self) -> &mut MPModeData;
    fn exit_camera_switch_delay(&self) -> &f32;
    fn exit_camera_switch_delay_mut(&mut self) -> &mut f32;
    fn angle_of_impact(&self) -> &AngleOfImpactData;
    fn angle_of_impact_mut(&mut self) -> &mut AngleOfImpactData;
    fn is_lockable(&self) -> &bool;
    fn is_lockable_mut(&mut self) -> &mut bool;
    fn locking_time_multiplier(&self) -> &f32;
    fn locking_time_multiplier_mut(&mut self) -> &mut f32;
    fn vehicle_lockable_info(&self) -> &VehicleLockableInfoData;
    fn vehicle_lockable_info_mut(&mut self) -> &mut VehicleLockableInfoData;
    fn never_report_vehicle_as_empty(&self) -> &bool;
    fn never_report_vehicle_as_empty_mut(&mut self) -> &mut bool;
    fn a_i_target(&self) -> &bool;
    fn a_i_target_mut(&mut self) -> &mut bool;
    fn high_altitude_lock_height(&self) -> &f32;
    fn high_altitude_lock_height_mut(&mut self) -> &mut f32;
    fn use_low_altitude_heat_signature(&self) -> &bool;
    fn use_low_altitude_heat_signature_mut(&mut self) -> &mut bool;
    fn sound(&self) -> &Option<Arc<Mutex<dyn VehicleSoundDataTrait>>>;
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleSoundDataTrait>>>;
    fn voice_over_info(&self) -> &Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>>;
    fn voice_over_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>>;
    fn nametag_height_scale(&self) -> &f32;
    fn nametag_height_scale_mut(&mut self) -> &mut f32;
    fn spotting_fov_scale(&self) -> &f32;
    fn spotting_fov_scale_mut(&mut self) -> &mut f32;
    fn use_spotting_target_component_for_raycast(&self) -> &bool;
    fn use_spotting_target_component_for_raycast_mut(&mut self) -> &mut bool;
    fn interaction_offset(&self) -> &super::core::Vec3;
    fn interaction_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn equipment_fake_vehicle(&self) -> &bool;
    fn equipment_fake_vehicle_mut(&mut self) -> &mut bool;
    fn explosion_packs_attachable(&self) -> &bool;
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool;
    fn character_blueprint_override(&self) -> &Option<Arc<Mutex<dyn CharacterBlueprintTrait>>>;
    fn character_blueprint_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterBlueprintTrait>>>;
    fn damage_giver_override_owner_vehicle(&self) -> &bool;
    fn damage_giver_override_owner_vehicle_mut(&mut self) -> &mut bool;
    fn enable_sub_realm(&self) -> &bool;
    fn enable_sub_realm_mut(&mut self) -> &mut bool;
    fn causes_a_i_to_flee(&self) -> &bool;
    fn causes_a_i_to_flee_mut(&mut self) -> &mut bool;
    fn a_i_flee_radius(&self) -> &f32;
    fn a_i_flee_radius_mut(&mut self) -> &mut f32;
    fn a_i_sound_category(&self) -> &AIVehicleSoundCategory;
    fn a_i_sound_category_mut(&mut self) -> &mut AIVehicleSoundCategory;
    fn victim_offset_override(&self) -> &super::core::Vec3;
    fn victim_offset_override_mut(&mut self) -> &mut super::core::Vec3;
}

impl VehicleEntityDataTrait for VehicleEntityData {
    fn controllable_type(&self) -> &String {
        &self.controllable_type
    }
    fn controllable_type_mut(&mut self) -> &mut String {
        &mut self.controllable_type
    }
    fn allow_vehicle_outside_combat_areas(&self) -> &bool {
        &self.allow_vehicle_outside_combat_areas
    }
    fn allow_vehicle_outside_combat_areas_mut(&mut self) -> &mut bool {
        &mut self.allow_vehicle_outside_combat_areas
    }
    fn disabled_damage_threshold(&self) -> &f32 {
        &self.disabled_damage_threshold
    }
    fn disabled_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.disabled_damage_threshold
    }
    fn pre_destruction_damage_threshold(&self) -> &f32 {
        &self.pre_destruction_damage_threshold
    }
    fn pre_destruction_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.pre_destruction_damage_threshold
    }
    fn front_health_zone(&self) -> &VehicleHealthZoneData {
        &self.front_health_zone
    }
    fn front_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.front_health_zone
    }
    fn rear_health_zone(&self) -> &VehicleHealthZoneData {
        &self.rear_health_zone
    }
    fn rear_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.rear_health_zone
    }
    fn left_health_zone(&self) -> &VehicleHealthZoneData {
        &self.left_health_zone
    }
    fn left_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.left_health_zone
    }
    fn right_health_zone(&self) -> &VehicleHealthZoneData {
        &self.right_health_zone
    }
    fn right_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.right_health_zone
    }
    fn top_health_zone(&self) -> &VehicleHealthZoneData {
        &self.top_health_zone
    }
    fn top_health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.top_health_zone
    }
    fn use_top_zone(&self) -> &bool {
        &self.use_top_zone
    }
    fn use_top_zone_mut(&mut self) -> &mut bool {
        &mut self.use_top_zone
    }
    fn top_hit_height(&self) -> &f32 {
        &self.top_hit_height
    }
    fn top_hit_height_mut(&mut self) -> &mut f32 {
        &mut self.top_hit_height
    }
    fn top_hit_angle(&self) -> &f32 {
        &self.top_hit_angle
    }
    fn top_hit_angle_mut(&mut self) -> &mut f32 {
        &mut self.top_hit_angle
    }
    fn health_zones_share_damage(&self) -> &bool {
        &self.health_zones_share_damage
    }
    fn health_zones_share_damage_mut(&mut self) -> &mut bool {
        &mut self.health_zones_share_damage
    }
    fn regeneration_delay(&self) -> &f32 {
        &self.regeneration_delay
    }
    fn regeneration_delay_mut(&mut self) -> &mut f32 {
        &mut self.regeneration_delay
    }
    fn regeneration_rate(&self) -> &f32 {
        &self.regeneration_rate
    }
    fn regeneration_rate_mut(&mut self) -> &mut f32 {
        &mut self.regeneration_rate
    }
    fn use_protected_shields(&self) -> &bool {
        &self.use_protected_shields
    }
    fn use_protected_shields_mut(&mut self) -> &mut bool {
        &mut self.use_protected_shields
    }
    fn armor_multiplier(&self) -> &f32 {
        &self.armor_multiplier
    }
    fn armor_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.armor_multiplier
    }
    fn regeneration_delay_multiplier(&self) -> &f32 {
        &self.regeneration_delay_multiplier
    }
    fn regeneration_delay_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.regeneration_delay_multiplier
    }
    fn regeneration_rate_multiplier(&self) -> &f32 {
        &self.regeneration_rate_multiplier
    }
    fn regeneration_rate_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.regeneration_rate_multiplier
    }
    fn emergency_repair_health(&self) -> &f32 {
        &self.emergency_repair_health
    }
    fn emergency_repair_health_mut(&mut self) -> &mut f32 {
        &mut self.emergency_repair_health
    }
    fn decay_delay(&self) -> &f32 {
        &self.decay_delay
    }
    fn decay_delay_mut(&mut self) -> &mut f32 {
        &mut self.decay_delay
    }
    fn decay_rate(&self) -> &f32 {
        &self.decay_rate
    }
    fn decay_rate_mut(&mut self) -> &mut f32 {
        &mut self.decay_rate
    }
    fn show_player_health(&self) -> &bool {
        &self.show_player_health
    }
    fn show_player_health_mut(&mut self) -> &mut bool {
        &mut self.show_player_health
    }
    fn use_self_for_self_destruct(&self) -> &bool {
        &self.use_self_for_self_destruct
    }
    fn use_self_for_self_destruct_mut(&mut self) -> &mut bool {
        &mut self.use_self_for_self_destruct
    }
    fn critically_damaged_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.critically_damaged_effect
    }
    fn critically_damaged_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &mut self.critically_damaged_effect
    }
    fn critically_damaged_effect_position(&self) -> &super::core::Vec3 {
        &self.critically_damaged_effect_position
    }
    fn critically_damaged_effect_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.critically_damaged_effect_position
    }
    fn critical_damage_time(&self) -> &f32 {
        &self.critical_damage_time
    }
    fn critical_damage_time_mut(&mut self) -> &mut f32 {
        &mut self.critical_damage_time
    }
    fn pre_explosion_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.pre_explosion_effect
    }
    fn pre_explosion_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &mut self.pre_explosion_effect
    }
    fn pre_explosion_effect_position(&self) -> &super::core::Vec3 {
        &self.pre_explosion_effect_position
    }
    fn pre_explosion_effect_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.pre_explosion_effect_position
    }
    fn pre_explosion_time(&self) -> &f32 {
        &self.pre_explosion_time
    }
    fn pre_explosion_time_mut(&mut self) -> &mut f32 {
        &mut self.pre_explosion_time
    }
    fn bypass_pre_destruction(&self) -> &bool {
        &self.bypass_pre_destruction
    }
    fn bypass_pre_destruction_mut(&mut self) -> &mut bool {
        &mut self.bypass_pre_destruction
    }
    fn random_pre_destruction(&self) -> &bool {
        &self.random_pre_destruction
    }
    fn random_pre_destruction_mut(&mut self) -> &mut bool {
        &mut self.random_pre_destruction
    }
    fn explosion(&self) -> &Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>> {
        &self.explosion
    }
    fn explosion_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExplosionEntityDataTrait>>> {
        &mut self.explosion
    }
    fn abandoned_explosion_damage_multiplier(&self) -> &f32 {
        &self.abandoned_explosion_damage_multiplier
    }
    fn abandoned_explosion_damage_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.abandoned_explosion_damage_multiplier
    }
    fn mesh_type(&self) -> &super::render_base::MeshType {
        &self.mesh_type
    }
    fn mesh_type_mut(&mut self) -> &mut super::render_base::MeshType {
        &mut self.mesh_type
    }
    fn mesh_part_count(&self) -> &u32 {
        &self.mesh_part_count
    }
    fn mesh_part_count_mut(&mut self) -> &mut u32 {
        &mut self.mesh_part_count
    }
    fn foreground_render_cockpit_mesh(&self) -> &bool {
        &self.foreground_render_cockpit_mesh
    }
    fn foreground_render_cockpit_mesh_mut(&mut self) -> &mut bool {
        &mut self.foreground_render_cockpit_mesh
    }
    fn motion_blur_mask(&self) -> &bool {
        &self.motion_blur_mask
    }
    fn motion_blur_mask_mut(&mut self) -> &mut bool {
        &mut self.motion_blur_mask
    }
    fn suppress_damage_by_passengers(&self) -> &bool {
        &self.suppress_damage_by_passengers
    }
    fn suppress_damage_by_passengers_mut(&mut self) -> &mut bool {
        &mut self.suppress_damage_by_passengers
    }
    fn hud_data(&self) -> &VehicleHudData {
        &self.hud_data
    }
    fn hud_data_mut(&mut self) -> &mut VehicleHudData {
        &mut self.hud_data
    }
    fn name_sid(&self) -> &String {
        &self.name_sid
    }
    fn name_sid_mut(&mut self) -> &mut String {
        &mut self.name_sid
    }
    fn max_players_in_vehicle(&self) -> &i32 {
        &self.max_players_in_vehicle
    }
    fn max_players_in_vehicle_mut(&mut self) -> &mut i32 {
        &mut self.max_players_in_vehicle
    }
    fn min_speed_for_mine_activation(&self) -> &f32 {
        &self.min_speed_for_mine_activation
    }
    fn min_speed_for_mine_activation_mut(&mut self) -> &mut f32 {
        &mut self.min_speed_for_mine_activation
    }
    fn trigger_vehicle_detonation(&self) -> &bool {
        &self.trigger_vehicle_detonation
    }
    fn trigger_vehicle_detonation_mut(&mut self) -> &mut bool {
        &mut self.trigger_vehicle_detonation
    }
    fn upside_down_damage(&self) -> &f32 {
        &self.upside_down_damage
    }
    fn upside_down_damage_mut(&mut self) -> &mut f32 {
        &mut self.upside_down_damage
    }
    fn upside_down_damage_delay(&self) -> &f32 {
        &self.upside_down_damage_delay
    }
    fn upside_down_damage_delay_mut(&mut self) -> &mut f32 {
        &mut self.upside_down_damage_delay
    }
    fn upside_down_angle(&self) -> &f32 {
        &self.upside_down_angle
    }
    fn upside_down_angle_mut(&mut self) -> &mut f32 {
        &mut self.upside_down_angle
    }
    fn water_damage(&self) -> &f32 {
        &self.water_damage
    }
    fn water_damage_mut(&mut self) -> &mut f32 {
        &mut self.water_damage
    }
    fn below_water_damage_delay(&self) -> &f32 {
        &self.below_water_damage_delay
    }
    fn below_water_damage_delay_mut(&mut self) -> &mut f32 {
        &mut self.below_water_damage_delay
    }
    fn water_damage_offset(&self) -> &f32 {
        &self.water_damage_offset
    }
    fn water_damage_offset_mut(&mut self) -> &mut f32 {
        &mut self.water_damage_offset
    }
    fn is_affected_by_e_m_p(&self) -> &bool {
        &self.is_affected_by_e_m_p
    }
    fn is_affected_by_e_m_p_mut(&mut self) -> &mut bool {
        &mut self.is_affected_by_e_m_p
    }
    fn velocity_damage_threshold(&self) -> &f32 {
        &self.velocity_damage_threshold
    }
    fn velocity_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.velocity_damage_threshold
    }
    fn velocity_damage_magnifier(&self) -> &f32 {
        &self.velocity_damage_magnifier
    }
    fn velocity_damage_magnifier_mut(&mut self) -> &mut f32 {
        &mut self.velocity_damage_magnifier
    }
    fn can_take_dynamic_fire_damage(&self) -> &bool {
        &self.can_take_dynamic_fire_damage
    }
    fn can_take_dynamic_fire_damage_mut(&mut self) -> &mut bool {
        &mut self.can_take_dynamic_fire_damage
    }
    fn always_deal_collision_damage(&self) -> &bool {
        &self.always_deal_collision_damage
    }
    fn always_deal_collision_damage_mut(&mut self) -> &mut bool {
        &mut self.always_deal_collision_damage
    }
    fn has_exclusive_entries(&self) -> &bool {
        &self.has_exclusive_entries
    }
    fn has_exclusive_entries_mut(&mut self) -> &mut bool {
        &mut self.has_exclusive_entries
    }
    fn prohibit_entry_switching(&self) -> &bool {
        &self.prohibit_entry_switching
    }
    fn prohibit_entry_switching_mut(&mut self) -> &mut bool {
        &mut self.prohibit_entry_switching
    }
    fn throw_out_soldier_inside_on_water_damage(&self) -> &bool {
        &self.throw_out_soldier_inside_on_water_damage
    }
    fn throw_out_soldier_inside_on_water_damage_mut(&mut self) -> &mut bool {
        &mut self.throw_out_soldier_inside_on_water_damage
    }
    fn kill_soldier_collision_speed_threshold(&self) -> &f32 {
        &self.kill_soldier_collision_speed_threshold
    }
    fn kill_soldier_collision_speed_threshold_mut(&mut self) -> &mut f32 {
        &mut self.kill_soldier_collision_speed_threshold
    }
    fn kill_soldier_collision_speed_threshold_block_time(&self) -> &f32 {
        &self.kill_soldier_collision_speed_threshold_block_time
    }
    fn kill_soldier_collision_speed_threshold_block_time_mut(&mut self) -> &mut f32 {
        &mut self.kill_soldier_collision_speed_threshold_block_time
    }
    fn ignore_soldier_collision_normal(&self) -> &bool {
        &self.ignore_soldier_collision_normal
    }
    fn ignore_soldier_collision_normal_mut(&mut self) -> &mut bool {
        &mut self.ignore_soldier_collision_normal
    }
    fn chose_exit_point_by_direction(&self) -> &bool {
        &self.chose_exit_point_by_direction
    }
    fn chose_exit_point_by_direction_mut(&mut self) -> &mut bool {
        &mut self.chose_exit_point_by_direction
    }
    fn exit_speed_threshold(&self) -> &f32 {
        &self.exit_speed_threshold
    }
    fn exit_speed_threshold_mut(&mut self) -> &mut f32 {
        &mut self.exit_speed_threshold
    }
    fn exit_direction_speed_threshold(&self) -> &f32 {
        &self.exit_direction_speed_threshold
    }
    fn exit_direction_speed_threshold_mut(&mut self) -> &mut f32 {
        &mut self.exit_direction_speed_threshold
    }
    fn enter_allowed(&self) -> &bool {
        &self.enter_allowed
    }
    fn enter_allowed_mut(&mut self) -> &mut bool {
        &mut self.enter_allowed
    }
    fn exit_allowed(&self) -> &bool {
        &self.exit_allowed
    }
    fn exit_allowed_mut(&mut self) -> &mut bool {
        &mut self.exit_allowed
    }
    fn enable_groundmap_lighting(&self) -> &bool {
        &self.enable_groundmap_lighting
    }
    fn enable_groundmap_lighting_mut(&mut self) -> &mut bool {
        &mut self.enable_groundmap_lighting
    }
    fn use_as_team_spawner(&self) -> &bool {
        &self.use_as_team_spawner
    }
    fn use_as_team_spawner_mut(&mut self) -> &mut bool {
        &mut self.use_as_team_spawner
    }
    fn f_l_i_r_value(&self) -> &f32 {
        &self.f_l_i_r_value
    }
    fn f_l_i_r_value_mut(&mut self) -> &mut f32 {
        &mut self.f_l_i_r_value
    }
    fn f_l_i_r_key_color(&self) -> &super::core::Vec3 {
        &self.f_l_i_r_key_color
    }
    fn f_l_i_r_key_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.f_l_i_r_key_color
    }
    fn m_p_mode(&self) -> &MPModeData {
        &self.m_p_mode
    }
    fn m_p_mode_mut(&mut self) -> &mut MPModeData {
        &mut self.m_p_mode
    }
    fn exit_camera_switch_delay(&self) -> &f32 {
        &self.exit_camera_switch_delay
    }
    fn exit_camera_switch_delay_mut(&mut self) -> &mut f32 {
        &mut self.exit_camera_switch_delay
    }
    fn angle_of_impact(&self) -> &AngleOfImpactData {
        &self.angle_of_impact
    }
    fn angle_of_impact_mut(&mut self) -> &mut AngleOfImpactData {
        &mut self.angle_of_impact
    }
    fn is_lockable(&self) -> &bool {
        &self.is_lockable
    }
    fn is_lockable_mut(&mut self) -> &mut bool {
        &mut self.is_lockable
    }
    fn locking_time_multiplier(&self) -> &f32 {
        &self.locking_time_multiplier
    }
    fn locking_time_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.locking_time_multiplier
    }
    fn vehicle_lockable_info(&self) -> &VehicleLockableInfoData {
        &self.vehicle_lockable_info
    }
    fn vehicle_lockable_info_mut(&mut self) -> &mut VehicleLockableInfoData {
        &mut self.vehicle_lockable_info
    }
    fn never_report_vehicle_as_empty(&self) -> &bool {
        &self.never_report_vehicle_as_empty
    }
    fn never_report_vehicle_as_empty_mut(&mut self) -> &mut bool {
        &mut self.never_report_vehicle_as_empty
    }
    fn a_i_target(&self) -> &bool {
        &self.a_i_target
    }
    fn a_i_target_mut(&mut self) -> &mut bool {
        &mut self.a_i_target
    }
    fn high_altitude_lock_height(&self) -> &f32 {
        &self.high_altitude_lock_height
    }
    fn high_altitude_lock_height_mut(&mut self) -> &mut f32 {
        &mut self.high_altitude_lock_height
    }
    fn use_low_altitude_heat_signature(&self) -> &bool {
        &self.use_low_altitude_heat_signature
    }
    fn use_low_altitude_heat_signature_mut(&mut self) -> &mut bool {
        &mut self.use_low_altitude_heat_signature
    }
    fn sound(&self) -> &Option<Arc<Mutex<dyn VehicleSoundDataTrait>>> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleSoundDataTrait>>> {
        &mut self.sound
    }
    fn voice_over_info(&self) -> &Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        &self.voice_over_info
    }
    fn voice_over_info_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::EntityVoiceOverInfoTrait>>> {
        &mut self.voice_over_info
    }
    fn nametag_height_scale(&self) -> &f32 {
        &self.nametag_height_scale
    }
    fn nametag_height_scale_mut(&mut self) -> &mut f32 {
        &mut self.nametag_height_scale
    }
    fn spotting_fov_scale(&self) -> &f32 {
        &self.spotting_fov_scale
    }
    fn spotting_fov_scale_mut(&mut self) -> &mut f32 {
        &mut self.spotting_fov_scale
    }
    fn use_spotting_target_component_for_raycast(&self) -> &bool {
        &self.use_spotting_target_component_for_raycast
    }
    fn use_spotting_target_component_for_raycast_mut(&mut self) -> &mut bool {
        &mut self.use_spotting_target_component_for_raycast
    }
    fn interaction_offset(&self) -> &super::core::Vec3 {
        &self.interaction_offset
    }
    fn interaction_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.interaction_offset
    }
    fn equipment_fake_vehicle(&self) -> &bool {
        &self.equipment_fake_vehicle
    }
    fn equipment_fake_vehicle_mut(&mut self) -> &mut bool {
        &mut self.equipment_fake_vehicle
    }
    fn explosion_packs_attachable(&self) -> &bool {
        &self.explosion_packs_attachable
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        &mut self.explosion_packs_attachable
    }
    fn character_blueprint_override(&self) -> &Option<Arc<Mutex<dyn CharacterBlueprintTrait>>> {
        &self.character_blueprint_override
    }
    fn character_blueprint_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterBlueprintTrait>>> {
        &mut self.character_blueprint_override
    }
    fn damage_giver_override_owner_vehicle(&self) -> &bool {
        &self.damage_giver_override_owner_vehicle
    }
    fn damage_giver_override_owner_vehicle_mut(&mut self) -> &mut bool {
        &mut self.damage_giver_override_owner_vehicle
    }
    fn enable_sub_realm(&self) -> &bool {
        &self.enable_sub_realm
    }
    fn enable_sub_realm_mut(&mut self) -> &mut bool {
        &mut self.enable_sub_realm
    }
    fn causes_a_i_to_flee(&self) -> &bool {
        &self.causes_a_i_to_flee
    }
    fn causes_a_i_to_flee_mut(&mut self) -> &mut bool {
        &mut self.causes_a_i_to_flee
    }
    fn a_i_flee_radius(&self) -> &f32 {
        &self.a_i_flee_radius
    }
    fn a_i_flee_radius_mut(&mut self) -> &mut f32 {
        &mut self.a_i_flee_radius
    }
    fn a_i_sound_category(&self) -> &AIVehicleSoundCategory {
        &self.a_i_sound_category
    }
    fn a_i_sound_category_mut(&mut self) -> &mut AIVehicleSoundCategory {
        &mut self.a_i_sound_category
    }
    fn victim_offset_override(&self) -> &super::core::Vec3 {
        &self.victim_offset_override
    }
    fn victim_offset_override_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.victim_offset_override
    }
}

impl super::gameplay_sim::ControllableEntityDataTrait for VehicleEntityData {
    fn use_prediction(&self) -> &bool {
        self._glacier_base.use_prediction()
    }
    fn use_prediction_mut(&mut self) -> &mut bool {
        self._glacier_base.use_prediction_mut()
    }
    fn default_team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.default_team()
    }
    fn default_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.default_team_mut()
    }
    fn reset_team_on_last_player_exits(&self) -> &bool {
        self._glacier_base.reset_team_on_last_player_exits()
    }
    fn reset_team_on_last_player_exits_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_team_on_last_player_exits_mut()
    }
    fn immortal(&self) -> &bool {
        self._glacier_base.immortal()
    }
    fn immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.immortal_mut()
    }
    fn fake_immortal(&self) -> &bool {
        self._glacier_base.fake_immortal()
    }
    fn fake_immortal_mut(&mut self) -> &mut bool {
        self._glacier_base.fake_immortal_mut()
    }
    fn low_health_threshold(&self) -> &f32 {
        self._glacier_base.low_health_threshold()
    }
    fn low_health_threshold_mut(&mut self) -> &mut f32 {
        self._glacier_base.low_health_threshold_mut()
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        self._glacier_base.material_pair()
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        self._glacier_base.material_pair_mut()
    }
    fn force_foreground_rendering(&self) -> &bool {
        self._glacier_base.force_foreground_rendering()
    }
    fn force_foreground_rendering_mut(&mut self) -> &mut bool {
        self._glacier_base.force_foreground_rendering_mut()
    }
    fn suppressed_inputs(&self) -> &Vec<i32> {
        self._glacier_base.suppressed_inputs()
    }
    fn suppressed_inputs_mut(&mut self) -> &mut Vec<i32> {
        self._glacier_base.suppressed_inputs_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for VehicleEntityData {
}

impl super::entity::GameComponentEntityDataTrait for VehicleEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for VehicleEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for VehicleEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for VehicleEntityData {
}

impl super::entity::GameObjectDataTrait for VehicleEntityData {
}

impl super::core::DataBusPeerTrait for VehicleEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleEntityData {
}

impl super::core::DataContainerTrait for VehicleEntityData {
}

pub static VEHICLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ControllableType",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VehicleEntityData, controllable_type),
            },
            FieldInfoData {
                name: "AllowVehicleOutsideCombatAreas",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, allow_vehicle_outside_combat_areas),
            },
            FieldInfoData {
                name: "DisabledDamageThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, disabled_damage_threshold),
            },
            FieldInfoData {
                name: "PreDestructionDamageThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, pre_destruction_damage_threshold),
            },
            FieldInfoData {
                name: "FrontHealthZone",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, front_health_zone),
            },
            FieldInfoData {
                name: "RearHealthZone",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, rear_health_zone),
            },
            FieldInfoData {
                name: "LeftHealthZone",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, left_health_zone),
            },
            FieldInfoData {
                name: "RightHealthZone",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, right_health_zone),
            },
            FieldInfoData {
                name: "TopHealthZone",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(VehicleEntityData, top_health_zone),
            },
            FieldInfoData {
                name: "UseTopZone",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_top_zone),
            },
            FieldInfoData {
                name: "TopHitHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, top_hit_height),
            },
            FieldInfoData {
                name: "TopHitAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, top_hit_angle),
            },
            FieldInfoData {
                name: "HealthZonesShareDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, health_zones_share_damage),
            },
            FieldInfoData {
                name: "RegenerationDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, regeneration_delay),
            },
            FieldInfoData {
                name: "RegenerationRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, regeneration_rate),
            },
            FieldInfoData {
                name: "UseProtectedShields",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_protected_shields),
            },
            FieldInfoData {
                name: "ArmorMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, armor_multiplier),
            },
            FieldInfoData {
                name: "RegenerationDelayMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, regeneration_delay_multiplier),
            },
            FieldInfoData {
                name: "RegenerationRateMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, regeneration_rate_multiplier),
            },
            FieldInfoData {
                name: "EmergencyRepairHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, emergency_repair_health),
            },
            FieldInfoData {
                name: "DecayDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, decay_delay),
            },
            FieldInfoData {
                name: "DecayRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, decay_rate),
            },
            FieldInfoData {
                name: "ShowPlayerHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, show_player_health),
            },
            FieldInfoData {
                name: "UseSelfForSelfDestruct",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_self_for_self_destruct),
            },
            FieldInfoData {
                name: "CriticallyDamagedEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(VehicleEntityData, critically_damaged_effect),
            },
            FieldInfoData {
                name: "CriticallyDamagedEffectPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, critically_damaged_effect_position),
            },
            FieldInfoData {
                name: "CriticalDamageTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, critical_damage_time),
            },
            FieldInfoData {
                name: "PreExplosionEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(VehicleEntityData, pre_explosion_effect),
            },
            FieldInfoData {
                name: "PreExplosionEffectPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, pre_explosion_effect_position),
            },
            FieldInfoData {
                name: "PreExplosionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, pre_explosion_time),
            },
            FieldInfoData {
                name: "BypassPreDestruction",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, bypass_pre_destruction),
            },
            FieldInfoData {
                name: "RandomPreDestruction",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, random_pre_destruction),
            },
            FieldInfoData {
                name: "Explosion",
                flags: MemberInfoFlags::new(0),
                field_type: "ExplosionEntityData",
                rust_offset: offset_of!(VehicleEntityData, explosion),
            },
            FieldInfoData {
                name: "AbandonedExplosionDamageMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, abandoned_explosion_damage_multiplier),
            },
            FieldInfoData {
                name: "MeshType",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshType",
                rust_offset: offset_of!(VehicleEntityData, mesh_type),
            },
            FieldInfoData {
                name: "MeshPartCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleEntityData, mesh_part_count),
            },
            FieldInfoData {
                name: "ForegroundRenderCockpitMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, foreground_render_cockpit_mesh),
            },
            FieldInfoData {
                name: "MotionBlurMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, motion_blur_mask),
            },
            FieldInfoData {
                name: "SuppressDamageByPassengers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, suppress_damage_by_passengers),
            },
            FieldInfoData {
                name: "HudData",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHudData",
                rust_offset: offset_of!(VehicleEntityData, hud_data),
            },
            FieldInfoData {
                name: "NameSid",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VehicleEntityData, name_sid),
            },
            FieldInfoData {
                name: "MaxPlayersInVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleEntityData, max_players_in_vehicle),
            },
            FieldInfoData {
                name: "MinSpeedForMineActivation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, min_speed_for_mine_activation),
            },
            FieldInfoData {
                name: "TriggerVehicleDetonation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, trigger_vehicle_detonation),
            },
            FieldInfoData {
                name: "UpsideDownDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, upside_down_damage),
            },
            FieldInfoData {
                name: "UpsideDownDamageDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, upside_down_damage_delay),
            },
            FieldInfoData {
                name: "UpsideDownAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, upside_down_angle),
            },
            FieldInfoData {
                name: "WaterDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, water_damage),
            },
            FieldInfoData {
                name: "BelowWaterDamageDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, below_water_damage_delay),
            },
            FieldInfoData {
                name: "WaterDamageOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, water_damage_offset),
            },
            FieldInfoData {
                name: "IsAffectedByEMP",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, is_affected_by_e_m_p),
            },
            FieldInfoData {
                name: "VelocityDamageThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, velocity_damage_threshold),
            },
            FieldInfoData {
                name: "VelocityDamageMagnifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, velocity_damage_magnifier),
            },
            FieldInfoData {
                name: "CanTakeDynamicFireDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, can_take_dynamic_fire_damage),
            },
            FieldInfoData {
                name: "AlwaysDealCollisionDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, always_deal_collision_damage),
            },
            FieldInfoData {
                name: "HasExclusiveEntries",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, has_exclusive_entries),
            },
            FieldInfoData {
                name: "ProhibitEntrySwitching",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, prohibit_entry_switching),
            },
            FieldInfoData {
                name: "ThrowOutSoldierInsideOnWaterDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, throw_out_soldier_inside_on_water_damage),
            },
            FieldInfoData {
                name: "KillSoldierCollisionSpeedThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, kill_soldier_collision_speed_threshold),
            },
            FieldInfoData {
                name: "KillSoldierCollisionSpeedThresholdBlockTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, kill_soldier_collision_speed_threshold_block_time),
            },
            FieldInfoData {
                name: "IgnoreSoldierCollisionNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, ignore_soldier_collision_normal),
            },
            FieldInfoData {
                name: "ChoseExitPointByDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, chose_exit_point_by_direction),
            },
            FieldInfoData {
                name: "ExitSpeedThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, exit_speed_threshold),
            },
            FieldInfoData {
                name: "ExitDirectionSpeedThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, exit_direction_speed_threshold),
            },
            FieldInfoData {
                name: "EnterAllowed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, enter_allowed),
            },
            FieldInfoData {
                name: "ExitAllowed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, exit_allowed),
            },
            FieldInfoData {
                name: "EnableGroundmapLighting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, enable_groundmap_lighting),
            },
            FieldInfoData {
                name: "UseAsTeamSpawner",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_as_team_spawner),
            },
            FieldInfoData {
                name: "FLIRValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, f_l_i_r_value),
            },
            FieldInfoData {
                name: "FLIRKeyColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, f_l_i_r_key_color),
            },
            FieldInfoData {
                name: "MPMode",
                flags: MemberInfoFlags::new(0),
                field_type: "MPModeData",
                rust_offset: offset_of!(VehicleEntityData, m_p_mode),
            },
            FieldInfoData {
                name: "ExitCameraSwitchDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, exit_camera_switch_delay),
            },
            FieldInfoData {
                name: "AngleOfImpact",
                flags: MemberInfoFlags::new(0),
                field_type: "AngleOfImpactData",
                rust_offset: offset_of!(VehicleEntityData, angle_of_impact),
            },
            FieldInfoData {
                name: "IsLockable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, is_lockable),
            },
            FieldInfoData {
                name: "LockingTimeMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, locking_time_multiplier),
            },
            FieldInfoData {
                name: "VehicleLockableInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleLockableInfoData",
                rust_offset: offset_of!(VehicleEntityData, vehicle_lockable_info),
            },
            FieldInfoData {
                name: "NeverReportVehicleAsEmpty",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, never_report_vehicle_as_empty),
            },
            FieldInfoData {
                name: "AITarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, a_i_target),
            },
            FieldInfoData {
                name: "HighAltitudeLockHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, high_altitude_lock_height),
            },
            FieldInfoData {
                name: "UseLowAltitudeHeatSignature",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_low_altitude_heat_signature),
            },
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleSoundData",
                rust_offset: offset_of!(VehicleEntityData, sound),
            },
            FieldInfoData {
                name: "VoiceOverInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "EntityVoiceOverInfo",
                rust_offset: offset_of!(VehicleEntityData, voice_over_info),
            },
            FieldInfoData {
                name: "NametagHeightScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, nametag_height_scale),
            },
            FieldInfoData {
                name: "SpottingFovScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, spotting_fov_scale),
            },
            FieldInfoData {
                name: "UseSpottingTargetComponentForRaycast",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, use_spotting_target_component_for_raycast),
            },
            FieldInfoData {
                name: "InteractionOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, interaction_offset),
            },
            FieldInfoData {
                name: "EquipmentFakeVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, equipment_fake_vehicle),
            },
            FieldInfoData {
                name: "ExplosionPacksAttachable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, explosion_packs_attachable),
            },
            FieldInfoData {
                name: "CharacterBlueprintOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterBlueprint",
                rust_offset: offset_of!(VehicleEntityData, character_blueprint_override),
            },
            FieldInfoData {
                name: "DamageGiverOverrideOwnerVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, damage_giver_override_owner_vehicle),
            },
            FieldInfoData {
                name: "EnableSubRealm",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, enable_sub_realm),
            },
            FieldInfoData {
                name: "CausesAIToFlee",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntityData, causes_a_i_to_flee),
            },
            FieldInfoData {
                name: "AIFleeRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleEntityData, a_i_flee_radius),
            },
            FieldInfoData {
                name: "AISoundCategory",
                flags: MemberInfoFlags::new(0),
                field_type: "AIVehicleSoundCategory",
                rust_offset: offset_of!(VehicleEntityData, a_i_sound_category),
            },
            FieldInfoData {
                name: "VictimOffsetOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntityData, victim_offset_override),
            },
        ],
    }),
    array_type: Some(VEHICLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIVehicleSoundCategory {
    #[default]
    AIVehicleSoundCategory_Normal = 0,
    AIVehicleSoundCategory_Quiet = 1,
}

pub static AIVEHICLESOUNDCATEGORY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleSoundCategory",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIVEHICLESOUNDCATEGORY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIVehicleSoundCategory {
    fn type_info(&self) -> &'static TypeInfo {
        AIVEHICLESOUNDCATEGORY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIVEHICLESOUNDCATEGORY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleSoundCategory-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AIVehicleSoundCategory"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimatedDriverEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub input_transform: super::core::LinearTransform,
    pub delay_animation_wheel_transform: bool,
    pub vehicle_speed: super::ant::AntRef,
    pub vehicle_movement_state: super::ant::AntRef,
    pub vehicle_boost: super::ant::AntRef,
    pub vehicle_brake: super::ant::AntRef,
    pub movement_state_stand_threshold: f32,
    pub yaw: NormalizeSettings,
    pub pitch: NormalizeSettings,
    pub roll: NormalizeSettings,
}

pub trait AnimatedDriverEntityDataTrait: super::entity::EntityDataTrait {
    fn input_transform(&self) -> &super::core::LinearTransform;
    fn input_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn delay_animation_wheel_transform(&self) -> &bool;
    fn delay_animation_wheel_transform_mut(&mut self) -> &mut bool;
    fn vehicle_speed(&self) -> &super::ant::AntRef;
    fn vehicle_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_movement_state(&self) -> &super::ant::AntRef;
    fn vehicle_movement_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_boost(&self) -> &super::ant::AntRef;
    fn vehicle_boost_mut(&mut self) -> &mut super::ant::AntRef;
    fn vehicle_brake(&self) -> &super::ant::AntRef;
    fn vehicle_brake_mut(&mut self) -> &mut super::ant::AntRef;
    fn movement_state_stand_threshold(&self) -> &f32;
    fn movement_state_stand_threshold_mut(&mut self) -> &mut f32;
    fn yaw(&self) -> &NormalizeSettings;
    fn yaw_mut(&mut self) -> &mut NormalizeSettings;
    fn pitch(&self) -> &NormalizeSettings;
    fn pitch_mut(&mut self) -> &mut NormalizeSettings;
    fn roll(&self) -> &NormalizeSettings;
    fn roll_mut(&mut self) -> &mut NormalizeSettings;
}

impl AnimatedDriverEntityDataTrait for AnimatedDriverEntityData {
    fn input_transform(&self) -> &super::core::LinearTransform {
        &self.input_transform
    }
    fn input_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.input_transform
    }
    fn delay_animation_wheel_transform(&self) -> &bool {
        &self.delay_animation_wheel_transform
    }
    fn delay_animation_wheel_transform_mut(&mut self) -> &mut bool {
        &mut self.delay_animation_wheel_transform
    }
    fn vehicle_speed(&self) -> &super::ant::AntRef {
        &self.vehicle_speed
    }
    fn vehicle_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_speed
    }
    fn vehicle_movement_state(&self) -> &super::ant::AntRef {
        &self.vehicle_movement_state
    }
    fn vehicle_movement_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_movement_state
    }
    fn vehicle_boost(&self) -> &super::ant::AntRef {
        &self.vehicle_boost
    }
    fn vehicle_boost_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_boost
    }
    fn vehicle_brake(&self) -> &super::ant::AntRef {
        &self.vehicle_brake
    }
    fn vehicle_brake_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vehicle_brake
    }
    fn movement_state_stand_threshold(&self) -> &f32 {
        &self.movement_state_stand_threshold
    }
    fn movement_state_stand_threshold_mut(&mut self) -> &mut f32 {
        &mut self.movement_state_stand_threshold
    }
    fn yaw(&self) -> &NormalizeSettings {
        &self.yaw
    }
    fn yaw_mut(&mut self) -> &mut NormalizeSettings {
        &mut self.yaw
    }
    fn pitch(&self) -> &NormalizeSettings {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut NormalizeSettings {
        &mut self.pitch
    }
    fn roll(&self) -> &NormalizeSettings {
        &self.roll
    }
    fn roll_mut(&mut self) -> &mut NormalizeSettings {
        &mut self.roll
    }
}

impl super::entity::EntityDataTrait for AnimatedDriverEntityData {
}

impl super::entity::GameObjectDataTrait for AnimatedDriverEntityData {
}

impl super::core::DataBusPeerTrait for AnimatedDriverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimatedDriverEntityData {
}

impl super::core::DataContainerTrait for AnimatedDriverEntityData {
}

pub static ANIMATEDDRIVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedDriverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimatedDriverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AnimatedDriverEntityData, input_transform),
            },
            FieldInfoData {
                name: "DelayAnimationWheelTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimatedDriverEntityData, delay_animation_wheel_transform),
            },
            FieldInfoData {
                name: "VehicleSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedDriverEntityData, vehicle_speed),
            },
            FieldInfoData {
                name: "VehicleMovementState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedDriverEntityData, vehicle_movement_state),
            },
            FieldInfoData {
                name: "VehicleBoost",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedDriverEntityData, vehicle_boost),
            },
            FieldInfoData {
                name: "VehicleBrake",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimatedDriverEntityData, vehicle_brake),
            },
            FieldInfoData {
                name: "MovementStateStandThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AnimatedDriverEntityData, movement_state_stand_threshold),
            },
            FieldInfoData {
                name: "Yaw",
                flags: MemberInfoFlags::new(0),
                field_type: "NormalizeSettings",
                rust_offset: offset_of!(AnimatedDriverEntityData, yaw),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "NormalizeSettings",
                rust_offset: offset_of!(AnimatedDriverEntityData, pitch),
            },
            FieldInfoData {
                name: "Roll",
                flags: MemberInfoFlags::new(0),
                field_type: "NormalizeSettings",
                rust_offset: offset_of!(AnimatedDriverEntityData, roll),
            },
        ],
    }),
    array_type: Some(ANIMATEDDRIVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AnimatedDriverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATEDDRIVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATEDDRIVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimatedDriverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimatedDriverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NormalizeSettings {
    pub normalize: bool,
    pub minimum: f32,
    pub maximum: f32,
    pub lower: f32,
    pub upper: f32,
    pub velocity: f32,
}

pub trait NormalizeSettingsTrait: TypeObject {
    fn normalize(&self) -> &bool;
    fn normalize_mut(&mut self) -> &mut bool;
    fn minimum(&self) -> &f32;
    fn minimum_mut(&mut self) -> &mut f32;
    fn maximum(&self) -> &f32;
    fn maximum_mut(&mut self) -> &mut f32;
    fn lower(&self) -> &f32;
    fn lower_mut(&mut self) -> &mut f32;
    fn upper(&self) -> &f32;
    fn upper_mut(&mut self) -> &mut f32;
    fn velocity(&self) -> &f32;
    fn velocity_mut(&mut self) -> &mut f32;
}

impl NormalizeSettingsTrait for NormalizeSettings {
    fn normalize(&self) -> &bool {
        &self.normalize
    }
    fn normalize_mut(&mut self) -> &mut bool {
        &mut self.normalize
    }
    fn minimum(&self) -> &f32 {
        &self.minimum
    }
    fn minimum_mut(&mut self) -> &mut f32 {
        &mut self.minimum
    }
    fn maximum(&self) -> &f32 {
        &self.maximum
    }
    fn maximum_mut(&mut self) -> &mut f32 {
        &mut self.maximum
    }
    fn lower(&self) -> &f32 {
        &self.lower
    }
    fn lower_mut(&mut self) -> &mut f32 {
        &mut self.lower
    }
    fn upper(&self) -> &f32 {
        &self.upper
    }
    fn upper_mut(&mut self) -> &mut f32 {
        &mut self.upper
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut f32 {
        &mut self.velocity
    }
}

pub static NORMALIZESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NormalizeSettings",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NormalizeSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Normalize",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NormalizeSettings, normalize),
            },
            FieldInfoData {
                name: "Minimum",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, minimum),
            },
            FieldInfoData {
                name: "Maximum",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, maximum),
            },
            FieldInfoData {
                name: "Lower",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, lower),
            },
            FieldInfoData {
                name: "Upper",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, upper),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NormalizeSettings, velocity),
            },
        ],
    }),
    array_type: Some(NORMALIZESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for NormalizeSettings {
    fn type_info(&self) -> &'static TypeInfo {
        NORMALIZESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NORMALIZESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NormalizeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("NormalizeSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleSoundData {
    pub _glacier_base: super::core::DataContainer,
    pub bullet_impact: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
}

pub trait VehicleSoundDataTrait: super::core::DataContainerTrait {
    fn bullet_impact(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn bullet_impact_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
}

impl VehicleSoundDataTrait for VehicleSoundData {
    fn bullet_impact(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.bullet_impact
    }
    fn bullet_impact_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.bullet_impact
    }
}

impl super::core::DataContainerTrait for VehicleSoundData {
}

pub static VEHICLESOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSoundData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleSoundData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BulletImpact",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(VehicleSoundData, bullet_impact),
            },
        ],
    }),
    array_type: Some(VEHICLESOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLESOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLESOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSoundData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleLockableInfoData {
    pub heat_signature: f32,
    pub radar_signature: f32,
    pub low_altitude_height: f32,
    pub low_altitude_heat_signature: f32,
}

pub trait VehicleLockableInfoDataTrait: TypeObject {
    fn heat_signature(&self) -> &f32;
    fn heat_signature_mut(&mut self) -> &mut f32;
    fn radar_signature(&self) -> &f32;
    fn radar_signature_mut(&mut self) -> &mut f32;
    fn low_altitude_height(&self) -> &f32;
    fn low_altitude_height_mut(&mut self) -> &mut f32;
    fn low_altitude_heat_signature(&self) -> &f32;
    fn low_altitude_heat_signature_mut(&mut self) -> &mut f32;
}

impl VehicleLockableInfoDataTrait for VehicleLockableInfoData {
    fn heat_signature(&self) -> &f32 {
        &self.heat_signature
    }
    fn heat_signature_mut(&mut self) -> &mut f32 {
        &mut self.heat_signature
    }
    fn radar_signature(&self) -> &f32 {
        &self.radar_signature
    }
    fn radar_signature_mut(&mut self) -> &mut f32 {
        &mut self.radar_signature
    }
    fn low_altitude_height(&self) -> &f32 {
        &self.low_altitude_height
    }
    fn low_altitude_height_mut(&mut self) -> &mut f32 {
        &mut self.low_altitude_height
    }
    fn low_altitude_heat_signature(&self) -> &f32 {
        &self.low_altitude_heat_signature
    }
    fn low_altitude_heat_signature_mut(&mut self) -> &mut f32 {
        &mut self.low_altitude_heat_signature
    }
}

pub static VEHICLELOCKABLEINFODATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleLockableInfoData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleLockableInfoData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HeatSignature",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleLockableInfoData, heat_signature),
            },
            FieldInfoData {
                name: "RadarSignature",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleLockableInfoData, radar_signature),
            },
            FieldInfoData {
                name: "LowAltitudeHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleLockableInfoData, low_altitude_height),
            },
            FieldInfoData {
                name: "LowAltitudeHeatSignature",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleLockableInfoData, low_altitude_heat_signature),
            },
        ],
    }),
    array_type: Some(VEHICLELOCKABLEINFODATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleLockableInfoData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLELOCKABLEINFODATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLELOCKABLEINFODATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleLockableInfoData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleLockableInfoData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AngleOfImpactData {
    pub zone12_delimiter: f32,
    pub zone23_delimiter: f32,
    pub zone1_multiplier: f32,
    pub zone2_multiplier: f32,
    pub zone3_multiplier: f32,
    pub enabled: bool,
}

pub trait AngleOfImpactDataTrait: TypeObject {
    fn zone12_delimiter(&self) -> &f32;
    fn zone12_delimiter_mut(&mut self) -> &mut f32;
    fn zone23_delimiter(&self) -> &f32;
    fn zone23_delimiter_mut(&mut self) -> &mut f32;
    fn zone1_multiplier(&self) -> &f32;
    fn zone1_multiplier_mut(&mut self) -> &mut f32;
    fn zone2_multiplier(&self) -> &f32;
    fn zone2_multiplier_mut(&mut self) -> &mut f32;
    fn zone3_multiplier(&self) -> &f32;
    fn zone3_multiplier_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl AngleOfImpactDataTrait for AngleOfImpactData {
    fn zone12_delimiter(&self) -> &f32 {
        &self.zone12_delimiter
    }
    fn zone12_delimiter_mut(&mut self) -> &mut f32 {
        &mut self.zone12_delimiter
    }
    fn zone23_delimiter(&self) -> &f32 {
        &self.zone23_delimiter
    }
    fn zone23_delimiter_mut(&mut self) -> &mut f32 {
        &mut self.zone23_delimiter
    }
    fn zone1_multiplier(&self) -> &f32 {
        &self.zone1_multiplier
    }
    fn zone1_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.zone1_multiplier
    }
    fn zone2_multiplier(&self) -> &f32 {
        &self.zone2_multiplier
    }
    fn zone2_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.zone2_multiplier
    }
    fn zone3_multiplier(&self) -> &f32 {
        &self.zone3_multiplier
    }
    fn zone3_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.zone3_multiplier
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

pub static ANGLEOFIMPACTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleOfImpactData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AngleOfImpactData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Zone12Delimiter",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone12_delimiter),
            },
            FieldInfoData {
                name: "Zone23Delimiter",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone23_delimiter),
            },
            FieldInfoData {
                name: "Zone1Multiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone1_multiplier),
            },
            FieldInfoData {
                name: "Zone2Multiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone2_multiplier),
            },
            FieldInfoData {
                name: "Zone3Multiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AngleOfImpactData, zone3_multiplier),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AngleOfImpactData, enabled),
            },
        ],
    }),
    array_type: Some(ANGLEOFIMPACTDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AngleOfImpactData {
    fn type_info(&self) -> &'static TypeInfo {
        ANGLEOFIMPACTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANGLEOFIMPACTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleOfImpactData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AngleOfImpactData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MPModeData {
    pub vehicle_points: i32,
}

pub trait MPModeDataTrait: TypeObject {
    fn vehicle_points(&self) -> &i32;
    fn vehicle_points_mut(&mut self) -> &mut i32;
}

impl MPModeDataTrait for MPModeData {
    fn vehicle_points(&self) -> &i32 {
        &self.vehicle_points
    }
    fn vehicle_points_mut(&mut self) -> &mut i32 {
        &mut self.vehicle_points
    }
}

pub static MPMODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MPModeData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MPModeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VehiclePoints",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MPModeData, vehicle_points),
            },
        ],
    }),
    array_type: Some(MPMODEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MPModeData {
    fn type_info(&self) -> &'static TypeInfo {
        MPMODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MPMODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MPModeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MPModeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleHealthZoneData {
    pub max_health: f32,
    pub max_shield_health: f32,
    pub use_damage_angle_calculation: bool,
    pub min_damage_angle: f32,
    pub damage_angle_multiplier: f32,
    pub damage_angle_multiplier_curve: Option<Arc<Mutex<dyn super::physics::Curve2DTrait>>>,
    pub vertical_factor: f32,
}

pub trait VehicleHealthZoneDataTrait: TypeObject {
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn max_shield_health(&self) -> &f32;
    fn max_shield_health_mut(&mut self) -> &mut f32;
    fn use_damage_angle_calculation(&self) -> &bool;
    fn use_damage_angle_calculation_mut(&mut self) -> &mut bool;
    fn min_damage_angle(&self) -> &f32;
    fn min_damage_angle_mut(&mut self) -> &mut f32;
    fn damage_angle_multiplier(&self) -> &f32;
    fn damage_angle_multiplier_mut(&mut self) -> &mut f32;
    fn damage_angle_multiplier_curve(&self) -> &Option<Arc<Mutex<dyn super::physics::Curve2DTrait>>>;
    fn damage_angle_multiplier_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::Curve2DTrait>>>;
    fn vertical_factor(&self) -> &f32;
    fn vertical_factor_mut(&mut self) -> &mut f32;
}

impl VehicleHealthZoneDataTrait for VehicleHealthZoneData {
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn max_shield_health(&self) -> &f32 {
        &self.max_shield_health
    }
    fn max_shield_health_mut(&mut self) -> &mut f32 {
        &mut self.max_shield_health
    }
    fn use_damage_angle_calculation(&self) -> &bool {
        &self.use_damage_angle_calculation
    }
    fn use_damage_angle_calculation_mut(&mut self) -> &mut bool {
        &mut self.use_damage_angle_calculation
    }
    fn min_damage_angle(&self) -> &f32 {
        &self.min_damage_angle
    }
    fn min_damage_angle_mut(&mut self) -> &mut f32 {
        &mut self.min_damage_angle
    }
    fn damage_angle_multiplier(&self) -> &f32 {
        &self.damage_angle_multiplier
    }
    fn damage_angle_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.damage_angle_multiplier
    }
    fn damage_angle_multiplier_curve(&self) -> &Option<Arc<Mutex<dyn super::physics::Curve2DTrait>>> {
        &self.damage_angle_multiplier_curve
    }
    fn damage_angle_multiplier_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::Curve2DTrait>>> {
        &mut self.damage_angle_multiplier_curve
    }
    fn vertical_factor(&self) -> &f32 {
        &self.vertical_factor
    }
    fn vertical_factor_mut(&mut self) -> &mut f32 {
        &mut self.vertical_factor
    }
}

pub static VEHICLEHEALTHZONEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHealthZoneData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleHealthZoneData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, max_health),
            },
            FieldInfoData {
                name: "MaxShieldHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, max_shield_health),
            },
            FieldInfoData {
                name: "UseDamageAngleCalculation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleHealthZoneData, use_damage_angle_calculation),
            },
            FieldInfoData {
                name: "MinDamageAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, min_damage_angle),
            },
            FieldInfoData {
                name: "DamageAngleMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, damage_angle_multiplier),
            },
            FieldInfoData {
                name: "DamageAngleMultiplierCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Curve2D",
                rust_offset: offset_of!(VehicleHealthZoneData, damage_angle_multiplier_curve),
            },
            FieldInfoData {
                name: "VerticalFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthZoneData, vertical_factor),
            },
        ],
    }),
    array_type: Some(VEHICLEHEALTHZONEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleHealthZoneData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEHEALTHZONEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEHEALTHZONEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHealthZoneData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleHealthZoneData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleHudData {
    pub customization: Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>,
    pub customization_offset: super::core::Vec3,
    pub minimap_icon: UIHudIcon,
    pub icon_name: String,
    pub rotate_in_map: bool,
    pub show_health: bool,
    pub texture: Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>,
    pub vehicle_item_hash: u32,
}

pub trait VehicleHudDataTrait: TypeObject {
    fn customization(&self) -> &Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>;
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>;
    fn customization_offset(&self) -> &super::core::Vec3;
    fn customization_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn minimap_icon(&self) -> &UIHudIcon;
    fn minimap_icon_mut(&mut self) -> &mut UIHudIcon;
    fn icon_name(&self) -> &String;
    fn icon_name_mut(&mut self) -> &mut String;
    fn rotate_in_map(&self) -> &bool;
    fn rotate_in_map_mut(&mut self) -> &mut bool;
    fn show_health(&self) -> &bool;
    fn show_health_mut(&mut self) -> &mut bool;
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>>;
    fn vehicle_item_hash(&self) -> &u32;
    fn vehicle_item_hash_mut(&mut self) -> &mut u32;
}

impl VehicleHudDataTrait for VehicleHudData {
    fn customization(&self) -> &Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>> {
        &mut self.customization
    }
    fn customization_offset(&self) -> &super::core::Vec3 {
        &self.customization_offset
    }
    fn customization_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.customization_offset
    }
    fn minimap_icon(&self) -> &UIHudIcon {
        &self.minimap_icon
    }
    fn minimap_icon_mut(&mut self) -> &mut UIHudIcon {
        &mut self.minimap_icon
    }
    fn icon_name(&self) -> &String {
        &self.icon_name
    }
    fn icon_name_mut(&mut self) -> &mut String {
        &mut self.icon_name
    }
    fn rotate_in_map(&self) -> &bool {
        &self.rotate_in_map
    }
    fn rotate_in_map_mut(&mut self) -> &mut bool {
        &mut self.rotate_in_map
    }
    fn show_health(&self) -> &bool {
        &self.show_health
    }
    fn show_health_mut(&mut self) -> &mut bool {
        &mut self.show_health
    }
    fn texture(&self) -> &Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &self.texture
    }
    fn texture_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::TextureBaseAssetTrait>>> {
        &mut self.texture
    }
    fn vehicle_item_hash(&self) -> &u32 {
        &self.vehicle_item_hash
    }
    fn vehicle_item_hash_mut(&mut self) -> &mut u32 {
        &mut self.vehicle_item_hash
    }
}

pub static VEHICLEHUDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHudData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleHudData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Customization",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleCustomizationAsset",
                rust_offset: offset_of!(VehicleHudData, customization),
            },
            FieldInfoData {
                name: "CustomizationOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleHudData, customization_offset),
            },
            FieldInfoData {
                name: "MinimapIcon",
                flags: MemberInfoFlags::new(0),
                field_type: "UIHudIcon",
                rust_offset: offset_of!(VehicleHudData, minimap_icon),
            },
            FieldInfoData {
                name: "IconName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VehicleHudData, icon_name),
            },
            FieldInfoData {
                name: "RotateInMap",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleHudData, rotate_in_map),
            },
            FieldInfoData {
                name: "ShowHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleHudData, show_health),
            },
            FieldInfoData {
                name: "Texture",
                flags: MemberInfoFlags::new(0),
                field_type: "TextureBaseAsset",
                rust_offset: offset_of!(VehicleHudData, texture),
            },
            FieldInfoData {
                name: "VehicleItemHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleHudData, vehicle_item_hash),
            },
        ],
    }),
    array_type: Some(VEHICLEHUDDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleHudData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEHUDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEHUDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHudData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleHudData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChildMovingBodyData {
    pub _glacier_base: super::physics::LinearMovingBodyData,
    pub input_delay: f32,
    pub speed: f32,
    pub input_action: i32,
    pub is_one_shot_input: bool,
    pub trigger_impulse: f32,
}

pub trait ChildMovingBodyDataTrait: super::physics::LinearMovingBodyDataTrait {
    fn input_delay(&self) -> &f32;
    fn input_delay_mut(&mut self) -> &mut f32;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
    fn input_action(&self) -> &i32;
    fn input_action_mut(&mut self) -> &mut i32;
    fn is_one_shot_input(&self) -> &bool;
    fn is_one_shot_input_mut(&mut self) -> &mut bool;
    fn trigger_impulse(&self) -> &f32;
    fn trigger_impulse_mut(&mut self) -> &mut f32;
}

impl ChildMovingBodyDataTrait for ChildMovingBodyData {
    fn input_delay(&self) -> &f32 {
        &self.input_delay
    }
    fn input_delay_mut(&mut self) -> &mut f32 {
        &mut self.input_delay
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn input_action_mut(&mut self) -> &mut i32 {
        &mut self.input_action
    }
    fn is_one_shot_input(&self) -> &bool {
        &self.is_one_shot_input
    }
    fn is_one_shot_input_mut(&mut self) -> &mut bool {
        &mut self.is_one_shot_input
    }
    fn trigger_impulse(&self) -> &f32 {
        &self.trigger_impulse
    }
    fn trigger_impulse_mut(&mut self) -> &mut f32 {
        &mut self.trigger_impulse
    }
}

impl super::physics::LinearMovingBodyDataTrait for ChildMovingBodyData {
    fn axis(&self) -> &super::core::Vec3 {
        self._glacier_base.axis()
    }
    fn axis_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.axis_mut()
    }
    fn start(&self) -> &super::physics::EndPointData {
        self._glacier_base.start()
    }
    fn start_mut(&mut self) -> &mut super::physics::EndPointData {
        self._glacier_base.start_mut()
    }
    fn end(&self) -> &super::physics::EndPointData {
        self._glacier_base.end()
    }
    fn end_mut(&mut self) -> &mut super::physics::EndPointData {
        self._glacier_base.end_mut()
    }
}

impl super::physics::MovingBodyDataTrait for ChildMovingBodyData {
    fn mass(&self) -> &f32 {
        self._glacier_base.mass()
    }
    fn mass_mut(&mut self) -> &mut f32 {
        self._glacier_base.mass_mut()
    }
    fn inertia(&self) -> &f32 {
        self._glacier_base.inertia()
    }
    fn inertia_mut(&mut self) -> &mut f32 {
        self._glacier_base.inertia_mut()
    }
}

impl super::core::DataContainerTrait for ChildMovingBodyData {
}

pub static CHILDMOVINGBODYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildMovingBodyData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::LINEARMOVINGBODYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildMovingBodyData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InputDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildMovingBodyData, input_delay),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildMovingBodyData, speed),
            },
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ChildMovingBodyData, input_action),
            },
            FieldInfoData {
                name: "IsOneShotInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildMovingBodyData, is_one_shot_input),
            },
            FieldInfoData {
                name: "TriggerImpulse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildMovingBodyData, trigger_impulse),
            },
        ],
    }),
    array_type: Some(CHILDMOVINGBODYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChildMovingBodyData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDMOVINGBODYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHILDMOVINGBODYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildMovingBodyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildMovingBodyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChildRotationBodyData {
    pub _glacier_base: super::physics::RotationBodyData,
    pub force_modifier: f32,
    pub reset_force_modifier: f32,
    pub reset_force_input_threshold: f32,
    pub use_linear_input: bool,
    pub rotation_input: i32,
    pub world_space_lock_efficiency: f32,
}

pub trait ChildRotationBodyDataTrait: super::physics::RotationBodyDataTrait {
    fn force_modifier(&self) -> &f32;
    fn force_modifier_mut(&mut self) -> &mut f32;
    fn reset_force_modifier(&self) -> &f32;
    fn reset_force_modifier_mut(&mut self) -> &mut f32;
    fn reset_force_input_threshold(&self) -> &f32;
    fn reset_force_input_threshold_mut(&mut self) -> &mut f32;
    fn use_linear_input(&self) -> &bool;
    fn use_linear_input_mut(&mut self) -> &mut bool;
    fn rotation_input(&self) -> &i32;
    fn rotation_input_mut(&mut self) -> &mut i32;
    fn world_space_lock_efficiency(&self) -> &f32;
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32;
}

impl ChildRotationBodyDataTrait for ChildRotationBodyData {
    fn force_modifier(&self) -> &f32 {
        &self.force_modifier
    }
    fn force_modifier_mut(&mut self) -> &mut f32 {
        &mut self.force_modifier
    }
    fn reset_force_modifier(&self) -> &f32 {
        &self.reset_force_modifier
    }
    fn reset_force_modifier_mut(&mut self) -> &mut f32 {
        &mut self.reset_force_modifier
    }
    fn reset_force_input_threshold(&self) -> &f32 {
        &self.reset_force_input_threshold
    }
    fn reset_force_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.reset_force_input_threshold
    }
    fn use_linear_input(&self) -> &bool {
        &self.use_linear_input
    }
    fn use_linear_input_mut(&mut self) -> &mut bool {
        &mut self.use_linear_input
    }
    fn rotation_input(&self) -> &i32 {
        &self.rotation_input
    }
    fn rotation_input_mut(&mut self) -> &mut i32 {
        &mut self.rotation_input
    }
    fn world_space_lock_efficiency(&self) -> &f32 {
        &self.world_space_lock_efficiency
    }
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency
    }
}

impl super::physics::RotationBodyDataTrait for ChildRotationBodyData {
    fn angular_momentum_multiplier(&self) -> &f32 {
        self._glacier_base.angular_momentum_multiplier()
    }
    fn angular_momentum_multiplier_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_multiplier_mut()
    }
    fn angular_momentum_threshold(&self) -> &f32 {
        self._glacier_base.angular_momentum_threshold()
    }
    fn angular_momentum_threshold_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_threshold_mut()
    }
    fn angular_momentum_damping(&self) -> &f32 {
        self._glacier_base.angular_momentum_damping()
    }
    fn angular_momentum_damping_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_damping_mut()
    }
    fn angular_momentum_damping_acc(&self) -> &f32 {
        self._glacier_base.angular_momentum_damping_acc()
    }
    fn angular_momentum_damping_acc_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_damping_acc_mut()
    }
    fn angular_momentum_damping_deacc(&self) -> &f32 {
        self._glacier_base.angular_momentum_damping_deacc()
    }
    fn angular_momentum_damping_deacc_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_momentum_damping_deacc_mut()
    }
    fn use_post_satisfy_constraints(&self) -> &bool {
        self._glacier_base.use_post_satisfy_constraints()
    }
    fn use_post_satisfy_constraints_mut(&mut self) -> &mut bool {
        self._glacier_base.use_post_satisfy_constraints_mut()
    }
    fn angular_constraint_min(&self) -> &f32 {
        self._glacier_base.angular_constraint_min()
    }
    fn angular_constraint_min_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_constraint_min_mut()
    }
    fn angular_constraint_max(&self) -> &f32 {
        self._glacier_base.angular_constraint_max()
    }
    fn angular_constraint_max_mut(&mut self) -> &mut f32 {
        self._glacier_base.angular_constraint_max_mut()
    }
    fn rotation_axis(&self) -> &i32 {
        self._glacier_base.rotation_axis()
    }
    fn rotation_axis_mut(&mut self) -> &mut i32 {
        self._glacier_base.rotation_axis_mut()
    }
    fn extended_constraints(&self) -> &Option<Arc<Mutex<dyn super::physics::ExtendedConstraintsDataTrait>>> {
        self._glacier_base.extended_constraints()
    }
    fn extended_constraints_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::ExtendedConstraintsDataTrait>>> {
        self._glacier_base.extended_constraints_mut()
    }
    fn use_angular_momentum_threshold(&self) -> &bool {
        self._glacier_base.use_angular_momentum_threshold()
    }
    fn use_angular_momentum_threshold_mut(&mut self) -> &mut bool {
        self._glacier_base.use_angular_momentum_threshold_mut()
    }
    fn use_angular_momentum_damping(&self) -> &bool {
        self._glacier_base.use_angular_momentum_damping()
    }
    fn use_angular_momentum_damping_mut(&mut self) -> &mut bool {
        self._glacier_base.use_angular_momentum_damping_mut()
    }
    fn use_angular_constraint(&self) -> &bool {
        self._glacier_base.use_angular_constraint()
    }
    fn use_angular_constraint_mut(&mut self) -> &mut bool {
        self._glacier_base.use_angular_constraint_mut()
    }
}

impl super::physics::MovingBodyDataTrait for ChildRotationBodyData {
    fn mass(&self) -> &f32 {
        self._glacier_base.mass()
    }
    fn mass_mut(&mut self) -> &mut f32 {
        self._glacier_base.mass_mut()
    }
    fn inertia(&self) -> &f32 {
        self._glacier_base.inertia()
    }
    fn inertia_mut(&mut self) -> &mut f32 {
        self._glacier_base.inertia_mut()
    }
}

impl super::core::DataContainerTrait for ChildRotationBodyData {
}

pub static CHILDROTATIONBODYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildRotationBodyData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::ROTATIONBODYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildRotationBodyData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForceModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildRotationBodyData, force_modifier),
            },
            FieldInfoData {
                name: "ResetForceModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildRotationBodyData, reset_force_modifier),
            },
            FieldInfoData {
                name: "ResetForceInputThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildRotationBodyData, reset_force_input_threshold),
            },
            FieldInfoData {
                name: "UseLinearInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildRotationBodyData, use_linear_input),
            },
            FieldInfoData {
                name: "RotationInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ChildRotationBodyData, rotation_input),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildRotationBodyData, world_space_lock_efficiency),
            },
        ],
    }),
    array_type: Some(CHILDROTATIONBODYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChildRotationBodyData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDROTATIONBODYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHILDROTATIONBODYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildRotationBodyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildRotationBodyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleHealthComponentData {
    pub _glacier_base: super::gameplay_sim::ControllableHealthComponentData,
    pub force_min_damage_angle_radius: f32,
}

pub trait VehicleHealthComponentDataTrait: super::gameplay_sim::ControllableHealthComponentDataTrait {
    fn force_min_damage_angle_radius(&self) -> &f32;
    fn force_min_damage_angle_radius_mut(&mut self) -> &mut f32;
}

impl VehicleHealthComponentDataTrait for VehicleHealthComponentData {
    fn force_min_damage_angle_radius(&self) -> &f32 {
        &self.force_min_damage_angle_radius
    }
    fn force_min_damage_angle_radius_mut(&mut self) -> &mut f32 {
        &mut self.force_min_damage_angle_radius
    }
}

impl super::gameplay_sim::ControllableHealthComponentDataTrait for VehicleHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for VehicleHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for VehicleHealthComponentData {
}

impl super::entity::ComponentDataTrait for VehicleHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleHealthComponentData {
}

impl super::core::DataBusPeerTrait for VehicleHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleHealthComponentData {
}

impl super::core::DataContainerTrait for VehicleHealthComponentData {
}

pub static VEHICLEHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleHealthComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ForceMinDamageAngleRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleHealthComponentData, force_min_damage_angle_radius),
            },
        ],
    }),
    array_type: Some(VEHICLEHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehiclePhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::ControllablePhysicsComponentData,
    pub vehicle_physics_action: Option<Arc<Mutex<dyn super::physics::VehiclePhysicsActionDataTrait>>>,
    pub proximity_tracker_data: Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>>,
}

pub trait VehiclePhysicsComponentDataTrait: super::gameplay_sim::ControllablePhysicsComponentDataTrait {
    fn vehicle_physics_action(&self) -> &Option<Arc<Mutex<dyn super::physics::VehiclePhysicsActionDataTrait>>>;
    fn vehicle_physics_action_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::VehiclePhysicsActionDataTrait>>>;
    fn proximity_tracker_data(&self) -> &Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>>;
    fn proximity_tracker_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>>;
}

impl VehiclePhysicsComponentDataTrait for VehiclePhysicsComponentData {
    fn vehicle_physics_action(&self) -> &Option<Arc<Mutex<dyn super::physics::VehiclePhysicsActionDataTrait>>> {
        &self.vehicle_physics_action
    }
    fn vehicle_physics_action_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::VehiclePhysicsActionDataTrait>>> {
        &mut self.vehicle_physics_action
    }
    fn proximity_tracker_data(&self) -> &Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>> {
        &self.proximity_tracker_data
    }
    fn proximity_tracker_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::ProximityTrackerDataTrait>>> {
        &mut self.proximity_tracker_data
    }
}

impl super::gameplay_sim::ControllablePhysicsComponentDataTrait for VehiclePhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for VehiclePhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for VehiclePhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for VehiclePhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehiclePhysicsComponentData {
}

impl super::core::DataBusPeerTrait for VehiclePhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehiclePhysicsComponentData {
}

impl super::core::DataContainerTrait for VehiclePhysicsComponentData {
}

pub static VEHICLEPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehiclePhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::CONTROLLABLEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehiclePhysicsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VehiclePhysicsAction",
                flags: MemberInfoFlags::new(0),
                field_type: "VehiclePhysicsActionData",
                rust_offset: offset_of!(VehiclePhysicsComponentData, vehicle_physics_action),
            },
            FieldInfoData {
                name: "ProximityTrackerData",
                flags: MemberInfoFlags::new(0),
                field_type: "ProximityTrackerData",
                rust_offset: offset_of!(VehiclePhysicsComponentData, proximity_tracker_data),
            },
        ],
    }),
    array_type: Some(VEHICLEPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehiclePhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehiclePhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehiclePhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IKComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub i_k_effector: super::gameplay_sim::IKEffectorEnum,
    pub i_k_data: super::gameplay_sim::HIKData,
}

pub trait IKComponentDataTrait: super::entity::GameComponentDataTrait {
    fn i_k_effector(&self) -> &super::gameplay_sim::IKEffectorEnum;
    fn i_k_effector_mut(&mut self) -> &mut super::gameplay_sim::IKEffectorEnum;
    fn i_k_data(&self) -> &super::gameplay_sim::HIKData;
    fn i_k_data_mut(&mut self) -> &mut super::gameplay_sim::HIKData;
}

impl IKComponentDataTrait for IKComponentData {
    fn i_k_effector(&self) -> &super::gameplay_sim::IKEffectorEnum {
        &self.i_k_effector
    }
    fn i_k_effector_mut(&mut self) -> &mut super::gameplay_sim::IKEffectorEnum {
        &mut self.i_k_effector
    }
    fn i_k_data(&self) -> &super::gameplay_sim::HIKData {
        &self.i_k_data
    }
    fn i_k_data_mut(&mut self) -> &mut super::gameplay_sim::HIKData {
        &mut self.i_k_data
    }
}

impl super::entity::GameComponentDataTrait for IKComponentData {
}

impl super::entity::ComponentDataTrait for IKComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for IKComponentData {
}

impl super::core::DataBusPeerTrait for IKComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IKComponentData {
}

impl super::core::DataContainerTrait for IKComponentData {
}

pub static IKCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IKComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IKComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IKEffector",
                flags: MemberInfoFlags::new(0),
                field_type: "IKEffectorEnum",
                rust_offset: offset_of!(IKComponentData, i_k_effector),
            },
            FieldInfoData {
                name: "IKData",
                flags: MemberInfoFlags::new(0),
                field_type: "HIKData",
                rust_offset: offset_of!(IKComponentData, i_k_data),
            },
        ],
    }),
    array_type: Some(IKCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for IKComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        IKCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IKCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IKComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IKComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleComponentData {
    pub _glacier_base: ChassisComponentData,
}

pub trait VehicleComponentDataTrait: ChassisComponentDataTrait {
}

impl VehicleComponentDataTrait for VehicleComponentData {
}

impl ChassisComponentDataTrait for VehicleComponentData {
    fn vehicle_config(&self) -> &Option<Arc<Mutex<dyn super::physics::VehicleConfigDataTrait>>> {
        self._glacier_base.vehicle_config()
    }
    fn vehicle_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::VehicleConfigDataTrait>>> {
        self._glacier_base.vehicle_config_mut()
    }
    fn gearbox_config(&self) -> &Option<Arc<Mutex<dyn super::physics::GearboxConfigDataTrait>>> {
        self._glacier_base.gearbox_config()
    }
    fn gearbox_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::GearboxConfigDataTrait>>> {
        self._glacier_base.gearbox_config_mut()
    }
    fn camera_relative_control_config(&self) -> &Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>> {
        self._glacier_base.camera_relative_control_config()
    }
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>> {
        self._glacier_base.camera_relative_control_config_mut()
    }
    fn always_full_throttle(&self) -> &bool {
        self._glacier_base.always_full_throttle()
    }
    fn always_full_throttle_mut(&mut self) -> &mut bool {
        self._glacier_base.always_full_throttle_mut()
    }
    fn water_effects(&self) -> &Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>> {
        self._glacier_base.water_effects()
    }
    fn water_effects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>> {
        self._glacier_base.water_effects_mut()
    }
    fn water_streak_effects(&self) -> &Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>> {
        self._glacier_base.water_streak_effects()
    }
    fn water_streak_effects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>> {
        self._glacier_base.water_streak_effects_mut()
    }
    fn trigger_ground_effect_impulse(&self) -> &f32 {
        self._glacier_base.trigger_ground_effect_impulse()
    }
    fn trigger_ground_effect_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.trigger_ground_effect_impulse_mut()
    }
    fn trigger_ground_effect_height(&self) -> &f32 {
        self._glacier_base.trigger_ground_effect_height()
    }
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32 {
        self._glacier_base.trigger_ground_effect_height_mut()
    }
    fn ground_effect_on_terrain_only(&self) -> &bool {
        self._glacier_base.ground_effect_on_terrain_only()
    }
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool {
        self._glacier_base.ground_effect_on_terrain_only_mut()
    }
    fn ground_effect_fade_param(&self) -> &f32 {
        self._glacier_base.ground_effect_fade_param()
    }
    fn ground_effect_fade_param_mut(&mut self) -> &mut f32 {
        self._glacier_base.ground_effect_fade_param_mut()
    }
    fn landing_gear_logic(&self) -> &Option<Arc<Mutex<dyn LandingGearLogicDataTrait>>> {
        self._glacier_base.landing_gear_logic()
    }
    fn landing_gear_logic_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LandingGearLogicDataTrait>>> {
        self._glacier_base.landing_gear_logic_mut()
    }
    fn allow_negative_throttle(&self) -> &bool {
        self._glacier_base.allow_negative_throttle()
    }
    fn allow_negative_throttle_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_negative_throttle_mut()
    }
    fn override_server_bounding_box(&self) -> &bool {
        self._glacier_base.override_server_bounding_box()
    }
    fn override_server_bounding_box_mut(&mut self) -> &mut bool {
        self._glacier_base.override_server_bounding_box_mut()
    }
    fn override_client_bounding_box(&self) -> &bool {
        self._glacier_base.override_client_bounding_box()
    }
    fn override_client_bounding_box_mut(&mut self) -> &mut bool {
        self._glacier_base.override_client_bounding_box_mut()
    }
    fn override_bounding_box_min(&self) -> &super::core::Vec3 {
        self._glacier_base.override_bounding_box_min()
    }
    fn override_bounding_box_min_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.override_bounding_box_min_mut()
    }
    fn override_bounding_box_max(&self) -> &super::core::Vec3 {
        self._glacier_base.override_bounding_box_max()
    }
    fn override_bounding_box_max_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.override_bounding_box_max_mut()
    }
}

impl super::gameplay_sim::PartComponentDataTrait for VehicleComponentData {
    fn health_states(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HealthStateDataTrait>>>> {
        self._glacier_base.health_states()
    }
    fn health_states_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HealthStateDataTrait>>>> {
        self._glacier_base.health_states_mut()
    }
    fn part_links(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links_mut()
    }
    fn is_supported(&self) -> &bool {
        self._glacier_base.is_supported()
    }
    fn is_supported_mut(&mut self) -> &mut bool {
        self._glacier_base.is_supported_mut()
    }
    fn is_fragile(&self) -> &bool {
        self._glacier_base.is_fragile()
    }
    fn is_fragile_mut(&mut self) -> &mut bool {
        self._glacier_base.is_fragile_mut()
    }
    fn is_networkable(&self) -> &bool {
        self._glacier_base.is_networkable()
    }
    fn is_networkable_mut(&mut self) -> &mut bool {
        self._glacier_base.is_networkable_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
}

impl super::entity::GameComponentDataTrait for VehicleComponentData {
}

impl super::entity::ComponentDataTrait for VehicleComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleComponentData {
}

impl super::core::DataBusPeerTrait for VehicleComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleComponentData {
}

impl super::core::DataContainerTrait for VehicleComponentData {
}

pub static VEHICLECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHASSISCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VEHICLECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChassisComponentData {
    pub _glacier_base: super::gameplay_sim::PartComponentData,
    pub vehicle_config: Option<Arc<Mutex<dyn super::physics::VehicleConfigDataTrait>>>,
    pub gearbox_config: Option<Arc<Mutex<dyn super::physics::GearboxConfigDataTrait>>>,
    pub camera_relative_control_config: Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>>,
    pub always_full_throttle: bool,
    pub water_effects: Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>>,
    pub water_streak_effects: Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>>,
    pub trigger_ground_effect_impulse: f32,
    pub trigger_ground_effect_height: f32,
    pub ground_effect_on_terrain_only: bool,
    pub ground_effect_fade_param: f32,
    pub landing_gear_logic: Option<Arc<Mutex<dyn LandingGearLogicDataTrait>>>,
    pub allow_negative_throttle: bool,
    pub override_server_bounding_box: bool,
    pub override_client_bounding_box: bool,
    pub override_bounding_box_min: super::core::Vec3,
    pub override_bounding_box_max: super::core::Vec3,
}

pub trait ChassisComponentDataTrait: super::gameplay_sim::PartComponentDataTrait {
    fn vehicle_config(&self) -> &Option<Arc<Mutex<dyn super::physics::VehicleConfigDataTrait>>>;
    fn vehicle_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::VehicleConfigDataTrait>>>;
    fn gearbox_config(&self) -> &Option<Arc<Mutex<dyn super::physics::GearboxConfigDataTrait>>>;
    fn gearbox_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::GearboxConfigDataTrait>>>;
    fn camera_relative_control_config(&self) -> &Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>>;
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>>;
    fn always_full_throttle(&self) -> &bool;
    fn always_full_throttle_mut(&mut self) -> &mut bool;
    fn water_effects(&self) -> &Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>>;
    fn water_effects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>>;
    fn water_streak_effects(&self) -> &Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>>;
    fn water_streak_effects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>>;
    fn trigger_ground_effect_impulse(&self) -> &f32;
    fn trigger_ground_effect_impulse_mut(&mut self) -> &mut f32;
    fn trigger_ground_effect_height(&self) -> &f32;
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32;
    fn ground_effect_on_terrain_only(&self) -> &bool;
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool;
    fn ground_effect_fade_param(&self) -> &f32;
    fn ground_effect_fade_param_mut(&mut self) -> &mut f32;
    fn landing_gear_logic(&self) -> &Option<Arc<Mutex<dyn LandingGearLogicDataTrait>>>;
    fn landing_gear_logic_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LandingGearLogicDataTrait>>>;
    fn allow_negative_throttle(&self) -> &bool;
    fn allow_negative_throttle_mut(&mut self) -> &mut bool;
    fn override_server_bounding_box(&self) -> &bool;
    fn override_server_bounding_box_mut(&mut self) -> &mut bool;
    fn override_client_bounding_box(&self) -> &bool;
    fn override_client_bounding_box_mut(&mut self) -> &mut bool;
    fn override_bounding_box_min(&self) -> &super::core::Vec3;
    fn override_bounding_box_min_mut(&mut self) -> &mut super::core::Vec3;
    fn override_bounding_box_max(&self) -> &super::core::Vec3;
    fn override_bounding_box_max_mut(&mut self) -> &mut super::core::Vec3;
}

impl ChassisComponentDataTrait for ChassisComponentData {
    fn vehicle_config(&self) -> &Option<Arc<Mutex<dyn super::physics::VehicleConfigDataTrait>>> {
        &self.vehicle_config
    }
    fn vehicle_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::VehicleConfigDataTrait>>> {
        &mut self.vehicle_config
    }
    fn gearbox_config(&self) -> &Option<Arc<Mutex<dyn super::physics::GearboxConfigDataTrait>>> {
        &self.gearbox_config
    }
    fn gearbox_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::GearboxConfigDataTrait>>> {
        &mut self.gearbox_config
    }
    fn camera_relative_control_config(&self) -> &Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>> {
        &self.camera_relative_control_config
    }
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>> {
        &mut self.camera_relative_control_config
    }
    fn always_full_throttle(&self) -> &bool {
        &self.always_full_throttle
    }
    fn always_full_throttle_mut(&mut self) -> &mut bool {
        &mut self.always_full_throttle
    }
    fn water_effects(&self) -> &Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>> {
        &self.water_effects
    }
    fn water_effects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>> {
        &mut self.water_effects
    }
    fn water_streak_effects(&self) -> &Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>> {
        &self.water_streak_effects
    }
    fn water_streak_effects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VehicleWaterEffectDataTrait>>>> {
        &mut self.water_streak_effects
    }
    fn trigger_ground_effect_impulse(&self) -> &f32 {
        &self.trigger_ground_effect_impulse
    }
    fn trigger_ground_effect_impulse_mut(&mut self) -> &mut f32 {
        &mut self.trigger_ground_effect_impulse
    }
    fn trigger_ground_effect_height(&self) -> &f32 {
        &self.trigger_ground_effect_height
    }
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32 {
        &mut self.trigger_ground_effect_height
    }
    fn ground_effect_on_terrain_only(&self) -> &bool {
        &self.ground_effect_on_terrain_only
    }
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool {
        &mut self.ground_effect_on_terrain_only
    }
    fn ground_effect_fade_param(&self) -> &f32 {
        &self.ground_effect_fade_param
    }
    fn ground_effect_fade_param_mut(&mut self) -> &mut f32 {
        &mut self.ground_effect_fade_param
    }
    fn landing_gear_logic(&self) -> &Option<Arc<Mutex<dyn LandingGearLogicDataTrait>>> {
        &self.landing_gear_logic
    }
    fn landing_gear_logic_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LandingGearLogicDataTrait>>> {
        &mut self.landing_gear_logic
    }
    fn allow_negative_throttle(&self) -> &bool {
        &self.allow_negative_throttle
    }
    fn allow_negative_throttle_mut(&mut self) -> &mut bool {
        &mut self.allow_negative_throttle
    }
    fn override_server_bounding_box(&self) -> &bool {
        &self.override_server_bounding_box
    }
    fn override_server_bounding_box_mut(&mut self) -> &mut bool {
        &mut self.override_server_bounding_box
    }
    fn override_client_bounding_box(&self) -> &bool {
        &self.override_client_bounding_box
    }
    fn override_client_bounding_box_mut(&mut self) -> &mut bool {
        &mut self.override_client_bounding_box
    }
    fn override_bounding_box_min(&self) -> &super::core::Vec3 {
        &self.override_bounding_box_min
    }
    fn override_bounding_box_min_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.override_bounding_box_min
    }
    fn override_bounding_box_max(&self) -> &super::core::Vec3 {
        &self.override_bounding_box_max
    }
    fn override_bounding_box_max_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.override_bounding_box_max
    }
}

impl super::gameplay_sim::PartComponentDataTrait for ChassisComponentData {
    fn health_states(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HealthStateDataTrait>>>> {
        self._glacier_base.health_states()
    }
    fn health_states_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::HealthStateDataTrait>>>> {
        self._glacier_base.health_states_mut()
    }
    fn part_links(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links_mut()
    }
    fn is_supported(&self) -> &bool {
        self._glacier_base.is_supported()
    }
    fn is_supported_mut(&mut self) -> &mut bool {
        self._glacier_base.is_supported_mut()
    }
    fn is_fragile(&self) -> &bool {
        self._glacier_base.is_fragile()
    }
    fn is_fragile_mut(&mut self) -> &mut bool {
        self._glacier_base.is_fragile_mut()
    }
    fn is_networkable(&self) -> &bool {
        self._glacier_base.is_networkable()
    }
    fn is_networkable_mut(&mut self) -> &mut bool {
        self._glacier_base.is_networkable_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
}

impl super::entity::GameComponentDataTrait for ChassisComponentData {
}

impl super::entity::ComponentDataTrait for ChassisComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ChassisComponentData {
}

impl super::core::DataBusPeerTrait for ChassisComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ChassisComponentData {
}

impl super::core::DataContainerTrait for ChassisComponentData {
}

pub static CHASSISCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChassisComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::PARTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChassisComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VehicleConfig",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleConfigData",
                rust_offset: offset_of!(ChassisComponentData, vehicle_config),
            },
            FieldInfoData {
                name: "GearboxConfig",
                flags: MemberInfoFlags::new(0),
                field_type: "GearboxConfigData",
                rust_offset: offset_of!(ChassisComponentData, gearbox_config),
            },
            FieldInfoData {
                name: "CameraRelativeControlConfig",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraRelativeControlData",
                rust_offset: offset_of!(ChassisComponentData, camera_relative_control_config),
            },
            FieldInfoData {
                name: "AlwaysFullThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, always_full_throttle),
            },
            FieldInfoData {
                name: "WaterEffects",
                flags: MemberInfoFlags::new(144),
                field_type: "VehicleWaterEffectData-Array",
                rust_offset: offset_of!(ChassisComponentData, water_effects),
            },
            FieldInfoData {
                name: "WaterStreakEffects",
                flags: MemberInfoFlags::new(144),
                field_type: "VehicleWaterEffectData-Array",
                rust_offset: offset_of!(ChassisComponentData, water_streak_effects),
            },
            FieldInfoData {
                name: "TriggerGroundEffectImpulse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChassisComponentData, trigger_ground_effect_impulse),
            },
            FieldInfoData {
                name: "TriggerGroundEffectHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChassisComponentData, trigger_ground_effect_height),
            },
            FieldInfoData {
                name: "GroundEffectOnTerrainOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, ground_effect_on_terrain_only),
            },
            FieldInfoData {
                name: "GroundEffectFadeParam",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChassisComponentData, ground_effect_fade_param),
            },
            FieldInfoData {
                name: "LandingGearLogic",
                flags: MemberInfoFlags::new(0),
                field_type: "LandingGearLogicData",
                rust_offset: offset_of!(ChassisComponentData, landing_gear_logic),
            },
            FieldInfoData {
                name: "AllowNegativeThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, allow_negative_throttle),
            },
            FieldInfoData {
                name: "OverrideServerBoundingBox",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, override_server_bounding_box),
            },
            FieldInfoData {
                name: "OverrideClientBoundingBox",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChassisComponentData, override_client_bounding_box),
            },
            FieldInfoData {
                name: "OverrideBoundingBoxMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ChassisComponentData, override_bounding_box_min),
            },
            FieldInfoData {
                name: "OverrideBoundingBoxMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ChassisComponentData, override_bounding_box_max),
            },
        ],
    }),
    array_type: Some(CHASSISCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChassisComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHASSISCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHASSISCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChassisComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChassisComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraRelativeControlData {
    pub _glacier_base: super::core::DataContainer,
    pub camera_relative_control: CameraRelativeControlEnum,
    pub combine_with_non_relative_controls: bool,
    pub use_camera_component_transform: bool,
    pub vehicle_relative_forward: bool,
    pub camera_relative_control_forward: i32,
    pub camera_relative_control_back: i32,
    pub vehicle_relative_strafe: bool,
    pub camera_relative_control_strafe: i32,
    pub forced_moving_body_world_space_lock: i32,
    pub speed_relative_data: Vec<CameraRelativeControlPerSpeedData>,
    pub throttle_output: i32,
    pub brake_output: i32,
    pub yaw_output: i32,
    pub inverted_yaw_in_reverse: bool,
    pub pitch_output: i32,
    pub force_align_yaw_with_camera: bool,
    pub force_align_yaw_input_hint: i32,
    pub force_align_yaw_input_threshold: f32,
    pub force_align_yaw_no_input_threshold: f32,
    pub force_align_yaw_threshold_pow: f32,
    pub force_align_yaw_angle_offset: f32,
    pub force_align_pitch_with_camera: bool,
    pub force_align_pitch_input_hint: i32,
    pub force_align_pitch_input_threshold: f32,
    pub force_align_pitch_no_input_threshold: f32,
    pub force_align_pitch_threshold_pow: f32,
    pub force_align_pitch_angle_offset: f32,
}

pub trait CameraRelativeControlDataTrait: super::core::DataContainerTrait {
    fn camera_relative_control(&self) -> &CameraRelativeControlEnum;
    fn camera_relative_control_mut(&mut self) -> &mut CameraRelativeControlEnum;
    fn combine_with_non_relative_controls(&self) -> &bool;
    fn combine_with_non_relative_controls_mut(&mut self) -> &mut bool;
    fn use_camera_component_transform(&self) -> &bool;
    fn use_camera_component_transform_mut(&mut self) -> &mut bool;
    fn vehicle_relative_forward(&self) -> &bool;
    fn vehicle_relative_forward_mut(&mut self) -> &mut bool;
    fn camera_relative_control_forward(&self) -> &i32;
    fn camera_relative_control_forward_mut(&mut self) -> &mut i32;
    fn camera_relative_control_back(&self) -> &i32;
    fn camera_relative_control_back_mut(&mut self) -> &mut i32;
    fn vehicle_relative_strafe(&self) -> &bool;
    fn vehicle_relative_strafe_mut(&mut self) -> &mut bool;
    fn camera_relative_control_strafe(&self) -> &i32;
    fn camera_relative_control_strafe_mut(&mut self) -> &mut i32;
    fn forced_moving_body_world_space_lock(&self) -> &i32;
    fn forced_moving_body_world_space_lock_mut(&mut self) -> &mut i32;
    fn speed_relative_data(&self) -> &Vec<CameraRelativeControlPerSpeedData>;
    fn speed_relative_data_mut(&mut self) -> &mut Vec<CameraRelativeControlPerSpeedData>;
    fn throttle_output(&self) -> &i32;
    fn throttle_output_mut(&mut self) -> &mut i32;
    fn brake_output(&self) -> &i32;
    fn brake_output_mut(&mut self) -> &mut i32;
    fn yaw_output(&self) -> &i32;
    fn yaw_output_mut(&mut self) -> &mut i32;
    fn inverted_yaw_in_reverse(&self) -> &bool;
    fn inverted_yaw_in_reverse_mut(&mut self) -> &mut bool;
    fn pitch_output(&self) -> &i32;
    fn pitch_output_mut(&mut self) -> &mut i32;
    fn force_align_yaw_with_camera(&self) -> &bool;
    fn force_align_yaw_with_camera_mut(&mut self) -> &mut bool;
    fn force_align_yaw_input_hint(&self) -> &i32;
    fn force_align_yaw_input_hint_mut(&mut self) -> &mut i32;
    fn force_align_yaw_input_threshold(&self) -> &f32;
    fn force_align_yaw_input_threshold_mut(&mut self) -> &mut f32;
    fn force_align_yaw_no_input_threshold(&self) -> &f32;
    fn force_align_yaw_no_input_threshold_mut(&mut self) -> &mut f32;
    fn force_align_yaw_threshold_pow(&self) -> &f32;
    fn force_align_yaw_threshold_pow_mut(&mut self) -> &mut f32;
    fn force_align_yaw_angle_offset(&self) -> &f32;
    fn force_align_yaw_angle_offset_mut(&mut self) -> &mut f32;
    fn force_align_pitch_with_camera(&self) -> &bool;
    fn force_align_pitch_with_camera_mut(&mut self) -> &mut bool;
    fn force_align_pitch_input_hint(&self) -> &i32;
    fn force_align_pitch_input_hint_mut(&mut self) -> &mut i32;
    fn force_align_pitch_input_threshold(&self) -> &f32;
    fn force_align_pitch_input_threshold_mut(&mut self) -> &mut f32;
    fn force_align_pitch_no_input_threshold(&self) -> &f32;
    fn force_align_pitch_no_input_threshold_mut(&mut self) -> &mut f32;
    fn force_align_pitch_threshold_pow(&self) -> &f32;
    fn force_align_pitch_threshold_pow_mut(&mut self) -> &mut f32;
    fn force_align_pitch_angle_offset(&self) -> &f32;
    fn force_align_pitch_angle_offset_mut(&mut self) -> &mut f32;
}

impl CameraRelativeControlDataTrait for CameraRelativeControlData {
    fn camera_relative_control(&self) -> &CameraRelativeControlEnum {
        &self.camera_relative_control
    }
    fn camera_relative_control_mut(&mut self) -> &mut CameraRelativeControlEnum {
        &mut self.camera_relative_control
    }
    fn combine_with_non_relative_controls(&self) -> &bool {
        &self.combine_with_non_relative_controls
    }
    fn combine_with_non_relative_controls_mut(&mut self) -> &mut bool {
        &mut self.combine_with_non_relative_controls
    }
    fn use_camera_component_transform(&self) -> &bool {
        &self.use_camera_component_transform
    }
    fn use_camera_component_transform_mut(&mut self) -> &mut bool {
        &mut self.use_camera_component_transform
    }
    fn vehicle_relative_forward(&self) -> &bool {
        &self.vehicle_relative_forward
    }
    fn vehicle_relative_forward_mut(&mut self) -> &mut bool {
        &mut self.vehicle_relative_forward
    }
    fn camera_relative_control_forward(&self) -> &i32 {
        &self.camera_relative_control_forward
    }
    fn camera_relative_control_forward_mut(&mut self) -> &mut i32 {
        &mut self.camera_relative_control_forward
    }
    fn camera_relative_control_back(&self) -> &i32 {
        &self.camera_relative_control_back
    }
    fn camera_relative_control_back_mut(&mut self) -> &mut i32 {
        &mut self.camera_relative_control_back
    }
    fn vehicle_relative_strafe(&self) -> &bool {
        &self.vehicle_relative_strafe
    }
    fn vehicle_relative_strafe_mut(&mut self) -> &mut bool {
        &mut self.vehicle_relative_strafe
    }
    fn camera_relative_control_strafe(&self) -> &i32 {
        &self.camera_relative_control_strafe
    }
    fn camera_relative_control_strafe_mut(&mut self) -> &mut i32 {
        &mut self.camera_relative_control_strafe
    }
    fn forced_moving_body_world_space_lock(&self) -> &i32 {
        &self.forced_moving_body_world_space_lock
    }
    fn forced_moving_body_world_space_lock_mut(&mut self) -> &mut i32 {
        &mut self.forced_moving_body_world_space_lock
    }
    fn speed_relative_data(&self) -> &Vec<CameraRelativeControlPerSpeedData> {
        &self.speed_relative_data
    }
    fn speed_relative_data_mut(&mut self) -> &mut Vec<CameraRelativeControlPerSpeedData> {
        &mut self.speed_relative_data
    }
    fn throttle_output(&self) -> &i32 {
        &self.throttle_output
    }
    fn throttle_output_mut(&mut self) -> &mut i32 {
        &mut self.throttle_output
    }
    fn brake_output(&self) -> &i32 {
        &self.brake_output
    }
    fn brake_output_mut(&mut self) -> &mut i32 {
        &mut self.brake_output
    }
    fn yaw_output(&self) -> &i32 {
        &self.yaw_output
    }
    fn yaw_output_mut(&mut self) -> &mut i32 {
        &mut self.yaw_output
    }
    fn inverted_yaw_in_reverse(&self) -> &bool {
        &self.inverted_yaw_in_reverse
    }
    fn inverted_yaw_in_reverse_mut(&mut self) -> &mut bool {
        &mut self.inverted_yaw_in_reverse
    }
    fn pitch_output(&self) -> &i32 {
        &self.pitch_output
    }
    fn pitch_output_mut(&mut self) -> &mut i32 {
        &mut self.pitch_output
    }
    fn force_align_yaw_with_camera(&self) -> &bool {
        &self.force_align_yaw_with_camera
    }
    fn force_align_yaw_with_camera_mut(&mut self) -> &mut bool {
        &mut self.force_align_yaw_with_camera
    }
    fn force_align_yaw_input_hint(&self) -> &i32 {
        &self.force_align_yaw_input_hint
    }
    fn force_align_yaw_input_hint_mut(&mut self) -> &mut i32 {
        &mut self.force_align_yaw_input_hint
    }
    fn force_align_yaw_input_threshold(&self) -> &f32 {
        &self.force_align_yaw_input_threshold
    }
    fn force_align_yaw_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.force_align_yaw_input_threshold
    }
    fn force_align_yaw_no_input_threshold(&self) -> &f32 {
        &self.force_align_yaw_no_input_threshold
    }
    fn force_align_yaw_no_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.force_align_yaw_no_input_threshold
    }
    fn force_align_yaw_threshold_pow(&self) -> &f32 {
        &self.force_align_yaw_threshold_pow
    }
    fn force_align_yaw_threshold_pow_mut(&mut self) -> &mut f32 {
        &mut self.force_align_yaw_threshold_pow
    }
    fn force_align_yaw_angle_offset(&self) -> &f32 {
        &self.force_align_yaw_angle_offset
    }
    fn force_align_yaw_angle_offset_mut(&mut self) -> &mut f32 {
        &mut self.force_align_yaw_angle_offset
    }
    fn force_align_pitch_with_camera(&self) -> &bool {
        &self.force_align_pitch_with_camera
    }
    fn force_align_pitch_with_camera_mut(&mut self) -> &mut bool {
        &mut self.force_align_pitch_with_camera
    }
    fn force_align_pitch_input_hint(&self) -> &i32 {
        &self.force_align_pitch_input_hint
    }
    fn force_align_pitch_input_hint_mut(&mut self) -> &mut i32 {
        &mut self.force_align_pitch_input_hint
    }
    fn force_align_pitch_input_threshold(&self) -> &f32 {
        &self.force_align_pitch_input_threshold
    }
    fn force_align_pitch_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.force_align_pitch_input_threshold
    }
    fn force_align_pitch_no_input_threshold(&self) -> &f32 {
        &self.force_align_pitch_no_input_threshold
    }
    fn force_align_pitch_no_input_threshold_mut(&mut self) -> &mut f32 {
        &mut self.force_align_pitch_no_input_threshold
    }
    fn force_align_pitch_threshold_pow(&self) -> &f32 {
        &self.force_align_pitch_threshold_pow
    }
    fn force_align_pitch_threshold_pow_mut(&mut self) -> &mut f32 {
        &mut self.force_align_pitch_threshold_pow
    }
    fn force_align_pitch_angle_offset(&self) -> &f32 {
        &self.force_align_pitch_angle_offset
    }
    fn force_align_pitch_angle_offset_mut(&mut self) -> &mut f32 {
        &mut self.force_align_pitch_angle_offset
    }
}

impl super::core::DataContainerTrait for CameraRelativeControlData {
}

pub static CAMERARELATIVECONTROLDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraRelativeControlData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CameraRelativeControl",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraRelativeControlEnum",
                rust_offset: offset_of!(CameraRelativeControlData, camera_relative_control),
            },
            FieldInfoData {
                name: "CombineWithNonRelativeControls",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, combine_with_non_relative_controls),
            },
            FieldInfoData {
                name: "UseCameraComponentTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, use_camera_component_transform),
            },
            FieldInfoData {
                name: "VehicleRelativeForward",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, vehicle_relative_forward),
            },
            FieldInfoData {
                name: "CameraRelativeControl_Forward",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, camera_relative_control_forward),
            },
            FieldInfoData {
                name: "CameraRelativeControl_Back",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, camera_relative_control_back),
            },
            FieldInfoData {
                name: "VehicleRelativeStrafe",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, vehicle_relative_strafe),
            },
            FieldInfoData {
                name: "CameraRelativeControl_Strafe",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, camera_relative_control_strafe),
            },
            FieldInfoData {
                name: "ForcedMovingBodyWorldSpaceLock",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, forced_moving_body_world_space_lock),
            },
            FieldInfoData {
                name: "SpeedRelativeData",
                flags: MemberInfoFlags::new(144),
                field_type: "CameraRelativeControlPerSpeedData-Array",
                rust_offset: offset_of!(CameraRelativeControlData, speed_relative_data),
            },
            FieldInfoData {
                name: "ThrottleOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, throttle_output),
            },
            FieldInfoData {
                name: "BrakeOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, brake_output),
            },
            FieldInfoData {
                name: "YawOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, yaw_output),
            },
            FieldInfoData {
                name: "InvertedYawInReverse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, inverted_yaw_in_reverse),
            },
            FieldInfoData {
                name: "PitchOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, pitch_output),
            },
            FieldInfoData {
                name: "ForceAlignYawWithCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_with_camera),
            },
            FieldInfoData {
                name: "ForceAlignYawInputHint",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_input_hint),
            },
            FieldInfoData {
                name: "ForceAlignYawInputThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_input_threshold),
            },
            FieldInfoData {
                name: "ForceAlignYawNoInputThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_no_input_threshold),
            },
            FieldInfoData {
                name: "ForceAlignYawThresholdPow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_threshold_pow),
            },
            FieldInfoData {
                name: "ForceAlignYawAngleOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_yaw_angle_offset),
            },
            FieldInfoData {
                name: "ForceAlignPitchWithCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_with_camera),
            },
            FieldInfoData {
                name: "ForceAlignPitchInputHint",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_input_hint),
            },
            FieldInfoData {
                name: "ForceAlignPitchInputThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_input_threshold),
            },
            FieldInfoData {
                name: "ForceAlignPitchNoInputThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_no_input_threshold),
            },
            FieldInfoData {
                name: "ForceAlignPitchThresholdPow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_threshold_pow),
            },
            FieldInfoData {
                name: "ForceAlignPitchAngleOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlData, force_align_pitch_angle_offset),
            },
        ],
    }),
    array_type: Some(CAMERARELATIVECONTROLDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraRelativeControlData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARELATIVECONTROLDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERARELATIVECONTROLDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraRelativeControlData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraRelativeControlPerSpeedData {
    pub speed_threshold: f32,
    pub use_in_forward_and_neutral_gears: bool,
    pub use_in_reverse_gear: bool,
    pub use_in_boost: bool,
    pub use_not_in_boost: bool,
    pub world_space_lock_efficiency: f32,
    pub world_space_lock_efficiency_away: f32,
    pub throttle_for_steering_help: f32,
    pub throttle_for_steering_help_strength: f32,
    pub throttle_hold: f32,
    pub min_input_magnitude: f32,
    pub throttle_exponent: f32,
    pub turning_exponent: f32,
    pub full_turning_threshold: f32,
    pub full_turning_blending: f32,
    pub extra_forward_zone_angle: f32,
    pub invert_extra_forward_zone_if_backwards: bool,
    pub invert_extra_forward_zone_on_side_facing_camera: bool,
    pub angular_yaw_constraint: f32,
}

pub trait CameraRelativeControlPerSpeedDataTrait: TypeObject {
    fn speed_threshold(&self) -> &f32;
    fn speed_threshold_mut(&mut self) -> &mut f32;
    fn use_in_forward_and_neutral_gears(&self) -> &bool;
    fn use_in_forward_and_neutral_gears_mut(&mut self) -> &mut bool;
    fn use_in_reverse_gear(&self) -> &bool;
    fn use_in_reverse_gear_mut(&mut self) -> &mut bool;
    fn use_in_boost(&self) -> &bool;
    fn use_in_boost_mut(&mut self) -> &mut bool;
    fn use_not_in_boost(&self) -> &bool;
    fn use_not_in_boost_mut(&mut self) -> &mut bool;
    fn world_space_lock_efficiency(&self) -> &f32;
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32;
    fn world_space_lock_efficiency_away(&self) -> &f32;
    fn world_space_lock_efficiency_away_mut(&mut self) -> &mut f32;
    fn throttle_for_steering_help(&self) -> &f32;
    fn throttle_for_steering_help_mut(&mut self) -> &mut f32;
    fn throttle_for_steering_help_strength(&self) -> &f32;
    fn throttle_for_steering_help_strength_mut(&mut self) -> &mut f32;
    fn throttle_hold(&self) -> &f32;
    fn throttle_hold_mut(&mut self) -> &mut f32;
    fn min_input_magnitude(&self) -> &f32;
    fn min_input_magnitude_mut(&mut self) -> &mut f32;
    fn throttle_exponent(&self) -> &f32;
    fn throttle_exponent_mut(&mut self) -> &mut f32;
    fn turning_exponent(&self) -> &f32;
    fn turning_exponent_mut(&mut self) -> &mut f32;
    fn full_turning_threshold(&self) -> &f32;
    fn full_turning_threshold_mut(&mut self) -> &mut f32;
    fn full_turning_blending(&self) -> &f32;
    fn full_turning_blending_mut(&mut self) -> &mut f32;
    fn extra_forward_zone_angle(&self) -> &f32;
    fn extra_forward_zone_angle_mut(&mut self) -> &mut f32;
    fn invert_extra_forward_zone_if_backwards(&self) -> &bool;
    fn invert_extra_forward_zone_if_backwards_mut(&mut self) -> &mut bool;
    fn invert_extra_forward_zone_on_side_facing_camera(&self) -> &bool;
    fn invert_extra_forward_zone_on_side_facing_camera_mut(&mut self) -> &mut bool;
    fn angular_yaw_constraint(&self) -> &f32;
    fn angular_yaw_constraint_mut(&mut self) -> &mut f32;
}

impl CameraRelativeControlPerSpeedDataTrait for CameraRelativeControlPerSpeedData {
    fn speed_threshold(&self) -> &f32 {
        &self.speed_threshold
    }
    fn speed_threshold_mut(&mut self) -> &mut f32 {
        &mut self.speed_threshold
    }
    fn use_in_forward_and_neutral_gears(&self) -> &bool {
        &self.use_in_forward_and_neutral_gears
    }
    fn use_in_forward_and_neutral_gears_mut(&mut self) -> &mut bool {
        &mut self.use_in_forward_and_neutral_gears
    }
    fn use_in_reverse_gear(&self) -> &bool {
        &self.use_in_reverse_gear
    }
    fn use_in_reverse_gear_mut(&mut self) -> &mut bool {
        &mut self.use_in_reverse_gear
    }
    fn use_in_boost(&self) -> &bool {
        &self.use_in_boost
    }
    fn use_in_boost_mut(&mut self) -> &mut bool {
        &mut self.use_in_boost
    }
    fn use_not_in_boost(&self) -> &bool {
        &self.use_not_in_boost
    }
    fn use_not_in_boost_mut(&mut self) -> &mut bool {
        &mut self.use_not_in_boost
    }
    fn world_space_lock_efficiency(&self) -> &f32 {
        &self.world_space_lock_efficiency
    }
    fn world_space_lock_efficiency_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency
    }
    fn world_space_lock_efficiency_away(&self) -> &f32 {
        &self.world_space_lock_efficiency_away
    }
    fn world_space_lock_efficiency_away_mut(&mut self) -> &mut f32 {
        &mut self.world_space_lock_efficiency_away
    }
    fn throttle_for_steering_help(&self) -> &f32 {
        &self.throttle_for_steering_help
    }
    fn throttle_for_steering_help_mut(&mut self) -> &mut f32 {
        &mut self.throttle_for_steering_help
    }
    fn throttle_for_steering_help_strength(&self) -> &f32 {
        &self.throttle_for_steering_help_strength
    }
    fn throttle_for_steering_help_strength_mut(&mut self) -> &mut f32 {
        &mut self.throttle_for_steering_help_strength
    }
    fn throttle_hold(&self) -> &f32 {
        &self.throttle_hold
    }
    fn throttle_hold_mut(&mut self) -> &mut f32 {
        &mut self.throttle_hold
    }
    fn min_input_magnitude(&self) -> &f32 {
        &self.min_input_magnitude
    }
    fn min_input_magnitude_mut(&mut self) -> &mut f32 {
        &mut self.min_input_magnitude
    }
    fn throttle_exponent(&self) -> &f32 {
        &self.throttle_exponent
    }
    fn throttle_exponent_mut(&mut self) -> &mut f32 {
        &mut self.throttle_exponent
    }
    fn turning_exponent(&self) -> &f32 {
        &self.turning_exponent
    }
    fn turning_exponent_mut(&mut self) -> &mut f32 {
        &mut self.turning_exponent
    }
    fn full_turning_threshold(&self) -> &f32 {
        &self.full_turning_threshold
    }
    fn full_turning_threshold_mut(&mut self) -> &mut f32 {
        &mut self.full_turning_threshold
    }
    fn full_turning_blending(&self) -> &f32 {
        &self.full_turning_blending
    }
    fn full_turning_blending_mut(&mut self) -> &mut f32 {
        &mut self.full_turning_blending
    }
    fn extra_forward_zone_angle(&self) -> &f32 {
        &self.extra_forward_zone_angle
    }
    fn extra_forward_zone_angle_mut(&mut self) -> &mut f32 {
        &mut self.extra_forward_zone_angle
    }
    fn invert_extra_forward_zone_if_backwards(&self) -> &bool {
        &self.invert_extra_forward_zone_if_backwards
    }
    fn invert_extra_forward_zone_if_backwards_mut(&mut self) -> &mut bool {
        &mut self.invert_extra_forward_zone_if_backwards
    }
    fn invert_extra_forward_zone_on_side_facing_camera(&self) -> &bool {
        &self.invert_extra_forward_zone_on_side_facing_camera
    }
    fn invert_extra_forward_zone_on_side_facing_camera_mut(&mut self) -> &mut bool {
        &mut self.invert_extra_forward_zone_on_side_facing_camera
    }
    fn angular_yaw_constraint(&self) -> &f32 {
        &self.angular_yaw_constraint
    }
    fn angular_yaw_constraint_mut(&mut self) -> &mut f32 {
        &mut self.angular_yaw_constraint
    }
}

pub static CAMERARELATIVECONTROLPERSPEEDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlPerSpeedData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraRelativeControlPerSpeedData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SpeedThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, speed_threshold),
            },
            FieldInfoData {
                name: "UseInForwardAndNeutralGears",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, use_in_forward_and_neutral_gears),
            },
            FieldInfoData {
                name: "UseInReverseGear",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, use_in_reverse_gear),
            },
            FieldInfoData {
                name: "UseInBoost",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, use_in_boost),
            },
            FieldInfoData {
                name: "UseNotInBoost",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, use_not_in_boost),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, world_space_lock_efficiency),
            },
            FieldInfoData {
                name: "WorldSpaceLockEfficiencyAway",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, world_space_lock_efficiency_away),
            },
            FieldInfoData {
                name: "ThrottleForSteeringHelp",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, throttle_for_steering_help),
            },
            FieldInfoData {
                name: "ThrottleForSteeringHelpStrength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, throttle_for_steering_help_strength),
            },
            FieldInfoData {
                name: "ThrottleHold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, throttle_hold),
            },
            FieldInfoData {
                name: "MinInputMagnitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, min_input_magnitude),
            },
            FieldInfoData {
                name: "ThrottleExponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, throttle_exponent),
            },
            FieldInfoData {
                name: "TurningExponent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, turning_exponent),
            },
            FieldInfoData {
                name: "FullTurningThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, full_turning_threshold),
            },
            FieldInfoData {
                name: "FullTurningBlending",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, full_turning_blending),
            },
            FieldInfoData {
                name: "ExtraForwardZoneAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, extra_forward_zone_angle),
            },
            FieldInfoData {
                name: "InvertExtraForwardZoneIfBackwards",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, invert_extra_forward_zone_if_backwards),
            },
            FieldInfoData {
                name: "InvertExtraForwardZoneOnSideFacingCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, invert_extra_forward_zone_on_side_facing_camera),
            },
            FieldInfoData {
                name: "AngularYawConstraint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraRelativeControlPerSpeedData, angular_yaw_constraint),
            },
        ],
    }),
    array_type: Some(CAMERARELATIVECONTROLPERSPEEDDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CameraRelativeControlPerSpeedData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARELATIVECONTROLPERSPEEDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERARELATIVECONTROLPERSPEEDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlPerSpeedData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraRelativeControlPerSpeedData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CameraRelativeControlEnum {
    #[default]
    UseProfileOptions = 0,
    ForceCameraRelative = 1,
}

pub static CAMERARELATIVECONTROLENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlEnum",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CAMERARELATIVECONTROLENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CameraRelativeControlEnum {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERARELATIVECONTROLENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERARELATIVECONTROLENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraRelativeControlEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraRelativeControlEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LandingGearLogicData {
    pub _glacier_base: super::core::DataContainer,
    pub retract_condition: LandingGearConditionData,
    pub deploy_condition: LandingGearConditionData,
}

pub trait LandingGearLogicDataTrait: super::core::DataContainerTrait {
    fn retract_condition(&self) -> &LandingGearConditionData;
    fn retract_condition_mut(&mut self) -> &mut LandingGearConditionData;
    fn deploy_condition(&self) -> &LandingGearConditionData;
    fn deploy_condition_mut(&mut self) -> &mut LandingGearConditionData;
}

impl LandingGearLogicDataTrait for LandingGearLogicData {
    fn retract_condition(&self) -> &LandingGearConditionData {
        &self.retract_condition
    }
    fn retract_condition_mut(&mut self) -> &mut LandingGearConditionData {
        &mut self.retract_condition
    }
    fn deploy_condition(&self) -> &LandingGearConditionData {
        &self.deploy_condition
    }
    fn deploy_condition_mut(&mut self) -> &mut LandingGearConditionData {
        &mut self.deploy_condition
    }
}

impl super::core::DataContainerTrait for LandingGearLogicData {
}

pub static LANDINGGEARLOGICDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LandingGearLogicData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LandingGearLogicData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RetractCondition",
                flags: MemberInfoFlags::new(0),
                field_type: "LandingGearConditionData",
                rust_offset: offset_of!(LandingGearLogicData, retract_condition),
            },
            FieldInfoData {
                name: "DeployCondition",
                flags: MemberInfoFlags::new(0),
                field_type: "LandingGearConditionData",
                rust_offset: offset_of!(LandingGearLogicData, deploy_condition),
            },
        ],
    }),
    array_type: Some(LANDINGGEARLOGICDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LandingGearLogicData {
    fn type_info(&self) -> &'static TypeInfo {
        LANDINGGEARLOGICDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LANDINGGEARLOGICDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LandingGearLogicData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LandingGearLogicData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LandingGearConditionData {
    pub height: f32,
    pub velocity: f32,
    pub angle: f32,
}

pub trait LandingGearConditionDataTrait: TypeObject {
    fn height(&self) -> &f32;
    fn height_mut(&mut self) -> &mut f32;
    fn velocity(&self) -> &f32;
    fn velocity_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
}

impl LandingGearConditionDataTrait for LandingGearConditionData {
    fn height(&self) -> &f32 {
        &self.height
    }
    fn height_mut(&mut self) -> &mut f32 {
        &mut self.height
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut f32 {
        &mut self.velocity
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
}

pub static LANDINGGEARCONDITIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LandingGearConditionData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LandingGearConditionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Height",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LandingGearConditionData, height),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LandingGearConditionData, velocity),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LandingGearConditionData, angle),
            },
        ],
    }),
    array_type: Some(LANDINGGEARCONDITIONDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LandingGearConditionData {
    fn type_info(&self) -> &'static TypeInfo {
        LANDINGGEARCONDITIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LANDINGGEARCONDITIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LandingGearConditionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LandingGearConditionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleWaterEffectData {
    pub _glacier_base: super::core::DataContainer,
    pub position: super::core::Vec3,
    pub effect: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
}

pub trait VehicleWaterEffectDataTrait: super::core::DataContainerTrait {
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
}

impl VehicleWaterEffectDataTrait for VehicleWaterEffectData {
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.effect
    }
    fn effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &mut self.effect
    }
}

impl super::core::DataContainerTrait for VehicleWaterEffectData {
}

pub static VEHICLEWATEREFFECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleWaterEffectData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleWaterEffectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleWaterEffectData, position),
            },
            FieldInfoData {
                name: "Effect",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(VehicleWaterEffectData, effect),
            },
        ],
    }),
    array_type: Some(VEHICLEWATEREFFECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleWaterEffectData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEWATEREFFECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEWATEREFFECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleWaterEffectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleWaterEffectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleExitPointComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub ordinal: i32,
    pub terrain_height: f32,
    pub velocity: f32,
    pub inherit_camera_direction: bool,
    pub impulse: super::core::Vec3,
    pub check_for_vehicle_overrun: bool,
}

pub trait VehicleExitPointComponentDataTrait: super::entity::GameComponentDataTrait {
    fn ordinal(&self) -> &i32;
    fn ordinal_mut(&mut self) -> &mut i32;
    fn terrain_height(&self) -> &f32;
    fn terrain_height_mut(&mut self) -> &mut f32;
    fn velocity(&self) -> &f32;
    fn velocity_mut(&mut self) -> &mut f32;
    fn inherit_camera_direction(&self) -> &bool;
    fn inherit_camera_direction_mut(&mut self) -> &mut bool;
    fn impulse(&self) -> &super::core::Vec3;
    fn impulse_mut(&mut self) -> &mut super::core::Vec3;
    fn check_for_vehicle_overrun(&self) -> &bool;
    fn check_for_vehicle_overrun_mut(&mut self) -> &mut bool;
}

impl VehicleExitPointComponentDataTrait for VehicleExitPointComponentData {
    fn ordinal(&self) -> &i32 {
        &self.ordinal
    }
    fn ordinal_mut(&mut self) -> &mut i32 {
        &mut self.ordinal
    }
    fn terrain_height(&self) -> &f32 {
        &self.terrain_height
    }
    fn terrain_height_mut(&mut self) -> &mut f32 {
        &mut self.terrain_height
    }
    fn velocity(&self) -> &f32 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut f32 {
        &mut self.velocity
    }
    fn inherit_camera_direction(&self) -> &bool {
        &self.inherit_camera_direction
    }
    fn inherit_camera_direction_mut(&mut self) -> &mut bool {
        &mut self.inherit_camera_direction
    }
    fn impulse(&self) -> &super::core::Vec3 {
        &self.impulse
    }
    fn impulse_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.impulse
    }
    fn check_for_vehicle_overrun(&self) -> &bool {
        &self.check_for_vehicle_overrun
    }
    fn check_for_vehicle_overrun_mut(&mut self) -> &mut bool {
        &mut self.check_for_vehicle_overrun
    }
}

impl super::entity::GameComponentDataTrait for VehicleExitPointComponentData {
}

impl super::entity::ComponentDataTrait for VehicleExitPointComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleExitPointComponentData {
}

impl super::core::DataBusPeerTrait for VehicleExitPointComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleExitPointComponentData {
}

impl super::core::DataContainerTrait for VehicleExitPointComponentData {
}

pub static VEHICLEEXITPOINTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleExitPointComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleExitPointComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Ordinal",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleExitPointComponentData, ordinal),
            },
            FieldInfoData {
                name: "TerrainHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleExitPointComponentData, terrain_height),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleExitPointComponentData, velocity),
            },
            FieldInfoData {
                name: "InheritCameraDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleExitPointComponentData, inherit_camera_direction),
            },
            FieldInfoData {
                name: "Impulse",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleExitPointComponentData, impulse),
            },
            FieldInfoData {
                name: "CheckForVehicleOverrun",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleExitPointComponentData, check_for_vehicle_overrun),
            },
        ],
    }),
    array_type: Some(VEHICLEEXITPOINTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleExitPointComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEEXITPOINTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEEXITPOINTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleExitPointComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleExitPointComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub camera: Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>>,
    pub field_of_view: f32,
    pub force_field_of_view: f32,
    pub enable_camera_mesh: bool,
    pub alternate_view: Option<Arc<Mutex<dyn AlternateCameraViewDataTrait>>>,
    pub regular_view: RegularCameraViewData,
    pub override_freelook_pitch: f32,
    pub override_freelook_yaw: f32,
    pub override_freelook_enable: bool,
    pub alternate_view_enabled: bool,
    pub camera_relative_control_config: Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>>,
    pub freeze_height: f32,
    pub is_first_person: bool,
    pub receive_impulses_as_third_person: bool,
    pub use_camera_transition: bool,
    pub camera_transition_pos: super::core::Vec3,
    pub camera_transition_time: f32,
    pub mesh_parent_component_number: u32,
    pub stance_data: StanceCameraData,
    pub camera_sound_data: Option<Arc<Mutex<dyn CameraComponentSoundDataTrait>>>,
    pub override_transform: super::core::LinearTransform,
}

pub trait CameraComponentDataTrait: super::entity::GameComponentDataTrait {
    fn camera(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>>;
    fn camera_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>>;
    fn field_of_view(&self) -> &f32;
    fn field_of_view_mut(&mut self) -> &mut f32;
    fn force_field_of_view(&self) -> &f32;
    fn force_field_of_view_mut(&mut self) -> &mut f32;
    fn enable_camera_mesh(&self) -> &bool;
    fn enable_camera_mesh_mut(&mut self) -> &mut bool;
    fn alternate_view(&self) -> &Option<Arc<Mutex<dyn AlternateCameraViewDataTrait>>>;
    fn alternate_view_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AlternateCameraViewDataTrait>>>;
    fn regular_view(&self) -> &RegularCameraViewData;
    fn regular_view_mut(&mut self) -> &mut RegularCameraViewData;
    fn override_freelook_pitch(&self) -> &f32;
    fn override_freelook_pitch_mut(&mut self) -> &mut f32;
    fn override_freelook_yaw(&self) -> &f32;
    fn override_freelook_yaw_mut(&mut self) -> &mut f32;
    fn override_freelook_enable(&self) -> &bool;
    fn override_freelook_enable_mut(&mut self) -> &mut bool;
    fn alternate_view_enabled(&self) -> &bool;
    fn alternate_view_enabled_mut(&mut self) -> &mut bool;
    fn camera_relative_control_config(&self) -> &Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>>;
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>>;
    fn freeze_height(&self) -> &f32;
    fn freeze_height_mut(&mut self) -> &mut f32;
    fn is_first_person(&self) -> &bool;
    fn is_first_person_mut(&mut self) -> &mut bool;
    fn receive_impulses_as_third_person(&self) -> &bool;
    fn receive_impulses_as_third_person_mut(&mut self) -> &mut bool;
    fn use_camera_transition(&self) -> &bool;
    fn use_camera_transition_mut(&mut self) -> &mut bool;
    fn camera_transition_pos(&self) -> &super::core::Vec3;
    fn camera_transition_pos_mut(&mut self) -> &mut super::core::Vec3;
    fn camera_transition_time(&self) -> &f32;
    fn camera_transition_time_mut(&mut self) -> &mut f32;
    fn mesh_parent_component_number(&self) -> &u32;
    fn mesh_parent_component_number_mut(&mut self) -> &mut u32;
    fn stance_data(&self) -> &StanceCameraData;
    fn stance_data_mut(&mut self) -> &mut StanceCameraData;
    fn camera_sound_data(&self) -> &Option<Arc<Mutex<dyn CameraComponentSoundDataTrait>>>;
    fn camera_sound_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraComponentSoundDataTrait>>>;
    fn override_transform(&self) -> &super::core::LinearTransform;
    fn override_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl CameraComponentDataTrait for CameraComponentData {
    fn camera(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>> {
        &self.camera
    }
    fn camera_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::TargetCameraDataTrait>>> {
        &mut self.camera
    }
    fn field_of_view(&self) -> &f32 {
        &self.field_of_view
    }
    fn field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.field_of_view
    }
    fn force_field_of_view(&self) -> &f32 {
        &self.force_field_of_view
    }
    fn force_field_of_view_mut(&mut self) -> &mut f32 {
        &mut self.force_field_of_view
    }
    fn enable_camera_mesh(&self) -> &bool {
        &self.enable_camera_mesh
    }
    fn enable_camera_mesh_mut(&mut self) -> &mut bool {
        &mut self.enable_camera_mesh
    }
    fn alternate_view(&self) -> &Option<Arc<Mutex<dyn AlternateCameraViewDataTrait>>> {
        &self.alternate_view
    }
    fn alternate_view_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AlternateCameraViewDataTrait>>> {
        &mut self.alternate_view
    }
    fn regular_view(&self) -> &RegularCameraViewData {
        &self.regular_view
    }
    fn regular_view_mut(&mut self) -> &mut RegularCameraViewData {
        &mut self.regular_view
    }
    fn override_freelook_pitch(&self) -> &f32 {
        &self.override_freelook_pitch
    }
    fn override_freelook_pitch_mut(&mut self) -> &mut f32 {
        &mut self.override_freelook_pitch
    }
    fn override_freelook_yaw(&self) -> &f32 {
        &self.override_freelook_yaw
    }
    fn override_freelook_yaw_mut(&mut self) -> &mut f32 {
        &mut self.override_freelook_yaw
    }
    fn override_freelook_enable(&self) -> &bool {
        &self.override_freelook_enable
    }
    fn override_freelook_enable_mut(&mut self) -> &mut bool {
        &mut self.override_freelook_enable
    }
    fn alternate_view_enabled(&self) -> &bool {
        &self.alternate_view_enabled
    }
    fn alternate_view_enabled_mut(&mut self) -> &mut bool {
        &mut self.alternate_view_enabled
    }
    fn camera_relative_control_config(&self) -> &Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>> {
        &self.camera_relative_control_config
    }
    fn camera_relative_control_config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraRelativeControlDataTrait>>> {
        &mut self.camera_relative_control_config
    }
    fn freeze_height(&self) -> &f32 {
        &self.freeze_height
    }
    fn freeze_height_mut(&mut self) -> &mut f32 {
        &mut self.freeze_height
    }
    fn is_first_person(&self) -> &bool {
        &self.is_first_person
    }
    fn is_first_person_mut(&mut self) -> &mut bool {
        &mut self.is_first_person
    }
    fn receive_impulses_as_third_person(&self) -> &bool {
        &self.receive_impulses_as_third_person
    }
    fn receive_impulses_as_third_person_mut(&mut self) -> &mut bool {
        &mut self.receive_impulses_as_third_person
    }
    fn use_camera_transition(&self) -> &bool {
        &self.use_camera_transition
    }
    fn use_camera_transition_mut(&mut self) -> &mut bool {
        &mut self.use_camera_transition
    }
    fn camera_transition_pos(&self) -> &super::core::Vec3 {
        &self.camera_transition_pos
    }
    fn camera_transition_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.camera_transition_pos
    }
    fn camera_transition_time(&self) -> &f32 {
        &self.camera_transition_time
    }
    fn camera_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.camera_transition_time
    }
    fn mesh_parent_component_number(&self) -> &u32 {
        &self.mesh_parent_component_number
    }
    fn mesh_parent_component_number_mut(&mut self) -> &mut u32 {
        &mut self.mesh_parent_component_number
    }
    fn stance_data(&self) -> &StanceCameraData {
        &self.stance_data
    }
    fn stance_data_mut(&mut self) -> &mut StanceCameraData {
        &mut self.stance_data
    }
    fn camera_sound_data(&self) -> &Option<Arc<Mutex<dyn CameraComponentSoundDataTrait>>> {
        &self.camera_sound_data
    }
    fn camera_sound_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CameraComponentSoundDataTrait>>> {
        &mut self.camera_sound_data
    }
    fn override_transform(&self) -> &super::core::LinearTransform {
        &self.override_transform
    }
    fn override_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.override_transform
    }
}

impl super::entity::GameComponentDataTrait for CameraComponentData {
}

impl super::entity::ComponentDataTrait for CameraComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CameraComponentData {
}

impl super::core::DataBusPeerTrait for CameraComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraComponentData {
}

impl super::core::DataContainerTrait for CameraComponentData {
}

pub static CAMERACOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Camera",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetCameraData",
                rust_offset: offset_of!(CameraComponentData, camera),
            },
            FieldInfoData {
                name: "FieldOfView",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, field_of_view),
            },
            FieldInfoData {
                name: "ForceFieldOfView",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, force_field_of_view),
            },
            FieldInfoData {
                name: "EnableCameraMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, enable_camera_mesh),
            },
            FieldInfoData {
                name: "AlternateView",
                flags: MemberInfoFlags::new(0),
                field_type: "AlternateCameraViewData",
                rust_offset: offset_of!(CameraComponentData, alternate_view),
            },
            FieldInfoData {
                name: "RegularView",
                flags: MemberInfoFlags::new(0),
                field_type: "RegularCameraViewData",
                rust_offset: offset_of!(CameraComponentData, regular_view),
            },
            FieldInfoData {
                name: "OverrideFreelookPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, override_freelook_pitch),
            },
            FieldInfoData {
                name: "OverrideFreelookYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, override_freelook_yaw),
            },
            FieldInfoData {
                name: "OverrideFreelookEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, override_freelook_enable),
            },
            FieldInfoData {
                name: "AlternateViewEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, alternate_view_enabled),
            },
            FieldInfoData {
                name: "CameraRelativeControlConfig",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraRelativeControlData",
                rust_offset: offset_of!(CameraComponentData, camera_relative_control_config),
            },
            FieldInfoData {
                name: "FreezeHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, freeze_height),
            },
            FieldInfoData {
                name: "IsFirstPerson",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, is_first_person),
            },
            FieldInfoData {
                name: "ReceiveImpulsesAsThirdPerson",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, receive_impulses_as_third_person),
            },
            FieldInfoData {
                name: "UseCameraTransition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraComponentData, use_camera_transition),
            },
            FieldInfoData {
                name: "CameraTransitionPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CameraComponentData, camera_transition_pos),
            },
            FieldInfoData {
                name: "CameraTransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraComponentData, camera_transition_time),
            },
            FieldInfoData {
                name: "MeshParentComponentNumber",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CameraComponentData, mesh_parent_component_number),
            },
            FieldInfoData {
                name: "StanceData",
                flags: MemberInfoFlags::new(0),
                field_type: "StanceCameraData",
                rust_offset: offset_of!(CameraComponentData, stance_data),
            },
            FieldInfoData {
                name: "CameraSoundData",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraComponentSoundData",
                rust_offset: offset_of!(CameraComponentData, camera_sound_data),
            },
            FieldInfoData {
                name: "OverrideTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(CameraComponentData, override_transform),
            },
        ],
    }),
    array_type: Some(CAMERACOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CameraComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERACOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StanceCameraData {
    pub valid_stances: Vec<i32>,
    pub default_camera_for_stances: Vec<i32>,
}

pub trait StanceCameraDataTrait: TypeObject {
    fn valid_stances(&self) -> &Vec<i32>;
    fn valid_stances_mut(&mut self) -> &mut Vec<i32>;
    fn default_camera_for_stances(&self) -> &Vec<i32>;
    fn default_camera_for_stances_mut(&mut self) -> &mut Vec<i32>;
}

impl StanceCameraDataTrait for StanceCameraData {
    fn valid_stances(&self) -> &Vec<i32> {
        &self.valid_stances
    }
    fn valid_stances_mut(&mut self) -> &mut Vec<i32> {
        &mut self.valid_stances
    }
    fn default_camera_for_stances(&self) -> &Vec<i32> {
        &self.default_camera_for_stances
    }
    fn default_camera_for_stances_mut(&mut self) -> &mut Vec<i32> {
        &mut self.default_camera_for_stances
    }
}

pub static STANCECAMERADATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceCameraData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StanceCameraData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ValidStances",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StanceCameraData, valid_stances),
            },
            FieldInfoData {
                name: "DefaultCameraForStances",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StanceCameraData, default_camera_for_stances),
            },
        ],
    }),
    array_type: Some(STANCECAMERADATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StanceCameraData {
    fn type_info(&self) -> &'static TypeInfo {
        STANCECAMERADATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STANCECAMERADATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceCameraData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StanceCameraData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TurretRotationInfo {
    pub rotation_axis: super::gameplay_sim::RotationAxis,
    pub channel: RotationChannel,
    pub normalize_rotation: bool,
    pub max_rotation: f32,
    pub min_rotation: f32,
    pub phase_offset: f32,
    pub invert_rotation: bool,
}

pub trait TurretRotationInfoTrait: TypeObject {
    fn rotation_axis(&self) -> &super::gameplay_sim::RotationAxis;
    fn rotation_axis_mut(&mut self) -> &mut super::gameplay_sim::RotationAxis;
    fn channel(&self) -> &RotationChannel;
    fn channel_mut(&mut self) -> &mut RotationChannel;
    fn normalize_rotation(&self) -> &bool;
    fn normalize_rotation_mut(&mut self) -> &mut bool;
    fn max_rotation(&self) -> &f32;
    fn max_rotation_mut(&mut self) -> &mut f32;
    fn min_rotation(&self) -> &f32;
    fn min_rotation_mut(&mut self) -> &mut f32;
    fn phase_offset(&self) -> &f32;
    fn phase_offset_mut(&mut self) -> &mut f32;
    fn invert_rotation(&self) -> &bool;
    fn invert_rotation_mut(&mut self) -> &mut bool;
}

impl TurretRotationInfoTrait for TurretRotationInfo {
    fn rotation_axis(&self) -> &super::gameplay_sim::RotationAxis {
        &self.rotation_axis
    }
    fn rotation_axis_mut(&mut self) -> &mut super::gameplay_sim::RotationAxis {
        &mut self.rotation_axis
    }
    fn channel(&self) -> &RotationChannel {
        &self.channel
    }
    fn channel_mut(&mut self) -> &mut RotationChannel {
        &mut self.channel
    }
    fn normalize_rotation(&self) -> &bool {
        &self.normalize_rotation
    }
    fn normalize_rotation_mut(&mut self) -> &mut bool {
        &mut self.normalize_rotation
    }
    fn max_rotation(&self) -> &f32 {
        &self.max_rotation
    }
    fn max_rotation_mut(&mut self) -> &mut f32 {
        &mut self.max_rotation
    }
    fn min_rotation(&self) -> &f32 {
        &self.min_rotation
    }
    fn min_rotation_mut(&mut self) -> &mut f32 {
        &mut self.min_rotation
    }
    fn phase_offset(&self) -> &f32 {
        &self.phase_offset
    }
    fn phase_offset_mut(&mut self) -> &mut f32 {
        &mut self.phase_offset
    }
    fn invert_rotation(&self) -> &bool {
        &self.invert_rotation
    }
    fn invert_rotation_mut(&mut self) -> &mut bool {
        &mut self.invert_rotation
    }
}

pub static TURRETROTATIONINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TurretRotationInfo",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TurretRotationInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RotationAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "RotationAxis",
                rust_offset: offset_of!(TurretRotationInfo, rotation_axis),
            },
            FieldInfoData {
                name: "Channel",
                flags: MemberInfoFlags::new(0),
                field_type: "RotationChannel",
                rust_offset: offset_of!(TurretRotationInfo, channel),
            },
            FieldInfoData {
                name: "NormalizeRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TurretRotationInfo, normalize_rotation),
            },
            FieldInfoData {
                name: "MaxRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurretRotationInfo, max_rotation),
            },
            FieldInfoData {
                name: "MinRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurretRotationInfo, min_rotation),
            },
            FieldInfoData {
                name: "PhaseOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TurretRotationInfo, phase_offset),
            },
            FieldInfoData {
                name: "InvertRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TurretRotationInfo, invert_rotation),
            },
        ],
    }),
    array_type: Some(TURRETROTATIONINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TurretRotationInfo {
    fn type_info(&self) -> &'static TypeInfo {
        TURRETROTATIONINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TURRETROTATIONINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TurretRotationInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TurretRotationInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RotationChannel {
    #[default]
    RotationChannel_Pitch = 0,
    RotationChannel_Yaw = 1,
    RotationChannel_Roll = 2,
}

pub static ROTATIONCHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationChannel",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ROTATIONCHANNEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RotationChannel {
    fn type_info(&self) -> &'static TypeInfo {
        ROTATIONCHANNEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ROTATIONCHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationChannel-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RotationChannel"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChildBarrelComponentData {
    pub _glacier_base: ChildComponentData,
}

pub trait ChildBarrelComponentDataTrait: ChildComponentDataTrait {
}

impl ChildBarrelComponentDataTrait for ChildBarrelComponentData {
}

impl ChildComponentDataTrait for ChildBarrelComponentData {
    fn sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.sound_effect()
    }
    fn sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        self._glacier_base.sound_effect_mut()
    }
    fn moving_body(&self) -> &Option<Arc<Mutex<dyn super::physics::MovingBodyDataTrait>>> {
        self._glacier_base.moving_body()
    }
    fn moving_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::MovingBodyDataTrait>>> {
        self._glacier_base.moving_body_mut()
    }
    fn health_zone(&self) -> &VehicleHealthZoneData {
        self._glacier_base.health_zone()
    }
    fn health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        self._glacier_base.health_zone_mut()
    }
    fn sound_effect_start_rpm(&self) -> &f32 {
        self._glacier_base.sound_effect_start_rpm()
    }
    fn sound_effect_start_rpm_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_effect_start_rpm_mut()
    }
    fn sound_effect_stop_rpm(&self) -> &f32 {
        self._glacier_base.sound_effect_stop_rpm()
    }
    fn sound_effect_stop_rpm_mut(&mut self) -> &mut f32 {
        self._glacier_base.sound_effect_stop_rpm_mut()
    }
    fn alignment_settings(&self) -> &Option<Arc<Mutex<dyn AlignmentDataTrait>>> {
        self._glacier_base.alignment_settings()
    }
    fn alignment_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AlignmentDataTrait>>> {
        self._glacier_base.alignment_settings_mut()
    }
    fn world_space_position_lock(&self) -> &bool {
        self._glacier_base.world_space_position_lock()
    }
    fn world_space_position_lock_mut(&mut self) -> &mut bool {
        self._glacier_base.world_space_position_lock_mut()
    }
    fn enable_align_to_camera(&self) -> &bool {
        self._glacier_base.enable_align_to_camera()
    }
    fn enable_align_to_camera_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_align_to_camera_mut()
    }
    fn align_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.align_transform()
    }
    fn align_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.align_transform_mut()
    }
}

impl super::entity::BoneComponentDataTrait for ChildBarrelComponentData {
}

impl super::entity::GameComponentDataTrait for ChildBarrelComponentData {
}

impl super::entity::ComponentDataTrait for ChildBarrelComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ChildBarrelComponentData {
}

impl super::core::DataBusPeerTrait for ChildBarrelComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ChildBarrelComponentData {
}

impl super::core::DataContainerTrait for ChildBarrelComponentData {
}

pub static CHILDBARRELCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildBarrelComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHILDCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildBarrelComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CHILDBARRELCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChildBarrelComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDBARRELCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHILDBARRELCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildBarrelComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildBarrelComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AlignmentData {
    pub _glacier_base: super::core::DataContainer,
    pub align_action: i32,
    pub stop_tolerance: f32,
    pub speed: f32,
}

pub trait AlignmentDataTrait: super::core::DataContainerTrait {
    fn align_action(&self) -> &i32;
    fn align_action_mut(&mut self) -> &mut i32;
    fn stop_tolerance(&self) -> &f32;
    fn stop_tolerance_mut(&mut self) -> &mut f32;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
}

impl AlignmentDataTrait for AlignmentData {
    fn align_action(&self) -> &i32 {
        &self.align_action
    }
    fn align_action_mut(&mut self) -> &mut i32 {
        &mut self.align_action
    }
    fn stop_tolerance(&self) -> &f32 {
        &self.stop_tolerance
    }
    fn stop_tolerance_mut(&mut self) -> &mut f32 {
        &mut self.stop_tolerance
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
}

impl super::core::DataContainerTrait for AlignmentData {
}

pub static ALIGNMENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlignmentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AlignmentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AlignAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AlignmentData, align_action),
            },
            FieldInfoData {
                name: "StopTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlignmentData, stop_tolerance),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlignmentData, speed),
            },
        ],
    }),
    array_type: Some(ALIGNMENTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AlignmentData {
    fn type_info(&self) -> &'static TypeInfo {
        ALIGNMENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ALIGNMENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlignmentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AlignmentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RotorComponentData {
    pub _glacier_base: super::gameplay_sim::TwoPartComponentData,
    pub low_rpm_model: RotorModelData,
    pub high_rpm_model: RotorModelData,
    pub rotation_axis: super::gameplay_sim::RotationAxis,
    pub rotation_multiplier: f32,
    pub change_model_rpm: f32,
    pub blow_effect: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
    pub only_trigger_blow_effect_in_water: bool,
    pub trigger_ground_effect_height: f32,
    pub ground_effect_on_terrain_only: bool,
    pub critically_damaged_rotation_force: f32,
    pub critical_damage: bool,
}

pub trait RotorComponentDataTrait: super::gameplay_sim::TwoPartComponentDataTrait {
    fn low_rpm_model(&self) -> &RotorModelData;
    fn low_rpm_model_mut(&mut self) -> &mut RotorModelData;
    fn high_rpm_model(&self) -> &RotorModelData;
    fn high_rpm_model_mut(&mut self) -> &mut RotorModelData;
    fn rotation_axis(&self) -> &super::gameplay_sim::RotationAxis;
    fn rotation_axis_mut(&mut self) -> &mut super::gameplay_sim::RotationAxis;
    fn rotation_multiplier(&self) -> &f32;
    fn rotation_multiplier_mut(&mut self) -> &mut f32;
    fn change_model_rpm(&self) -> &f32;
    fn change_model_rpm_mut(&mut self) -> &mut f32;
    fn blow_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn blow_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn only_trigger_blow_effect_in_water(&self) -> &bool;
    fn only_trigger_blow_effect_in_water_mut(&mut self) -> &mut bool;
    fn trigger_ground_effect_height(&self) -> &f32;
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32;
    fn ground_effect_on_terrain_only(&self) -> &bool;
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool;
    fn critically_damaged_rotation_force(&self) -> &f32;
    fn critically_damaged_rotation_force_mut(&mut self) -> &mut f32;
    fn critical_damage(&self) -> &bool;
    fn critical_damage_mut(&mut self) -> &mut bool;
}

impl RotorComponentDataTrait for RotorComponentData {
    fn low_rpm_model(&self) -> &RotorModelData {
        &self.low_rpm_model
    }
    fn low_rpm_model_mut(&mut self) -> &mut RotorModelData {
        &mut self.low_rpm_model
    }
    fn high_rpm_model(&self) -> &RotorModelData {
        &self.high_rpm_model
    }
    fn high_rpm_model_mut(&mut self) -> &mut RotorModelData {
        &mut self.high_rpm_model
    }
    fn rotation_axis(&self) -> &super::gameplay_sim::RotationAxis {
        &self.rotation_axis
    }
    fn rotation_axis_mut(&mut self) -> &mut super::gameplay_sim::RotationAxis {
        &mut self.rotation_axis
    }
    fn rotation_multiplier(&self) -> &f32 {
        &self.rotation_multiplier
    }
    fn rotation_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.rotation_multiplier
    }
    fn change_model_rpm(&self) -> &f32 {
        &self.change_model_rpm
    }
    fn change_model_rpm_mut(&mut self) -> &mut f32 {
        &mut self.change_model_rpm
    }
    fn blow_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.blow_effect
    }
    fn blow_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &mut self.blow_effect
    }
    fn only_trigger_blow_effect_in_water(&self) -> &bool {
        &self.only_trigger_blow_effect_in_water
    }
    fn only_trigger_blow_effect_in_water_mut(&mut self) -> &mut bool {
        &mut self.only_trigger_blow_effect_in_water
    }
    fn trigger_ground_effect_height(&self) -> &f32 {
        &self.trigger_ground_effect_height
    }
    fn trigger_ground_effect_height_mut(&mut self) -> &mut f32 {
        &mut self.trigger_ground_effect_height
    }
    fn ground_effect_on_terrain_only(&self) -> &bool {
        &self.ground_effect_on_terrain_only
    }
    fn ground_effect_on_terrain_only_mut(&mut self) -> &mut bool {
        &mut self.ground_effect_on_terrain_only
    }
    fn critically_damaged_rotation_force(&self) -> &f32 {
        &self.critically_damaged_rotation_force
    }
    fn critically_damaged_rotation_force_mut(&mut self) -> &mut f32 {
        &mut self.critically_damaged_rotation_force
    }
    fn critical_damage(&self) -> &bool {
        &self.critical_damage
    }
    fn critical_damage_mut(&mut self) -> &mut bool {
        &mut self.critical_damage
    }
}

impl super::gameplay_sim::TwoPartComponentDataTrait for RotorComponentData {
}

impl super::entity::GameComponentDataTrait for RotorComponentData {
}

impl super::entity::ComponentDataTrait for RotorComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for RotorComponentData {
}

impl super::core::DataBusPeerTrait for RotorComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for RotorComponentData {
}

impl super::core::DataContainerTrait for RotorComponentData {
}

pub static ROTORCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotorComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::TWOPARTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RotorComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LowRpmModel",
                flags: MemberInfoFlags::new(0),
                field_type: "RotorModelData",
                rust_offset: offset_of!(RotorComponentData, low_rpm_model),
            },
            FieldInfoData {
                name: "HighRpmModel",
                flags: MemberInfoFlags::new(0),
                field_type: "RotorModelData",
                rust_offset: offset_of!(RotorComponentData, high_rpm_model),
            },
            FieldInfoData {
                name: "RotationAxis",
                flags: MemberInfoFlags::new(0),
                field_type: "RotationAxis",
                rust_offset: offset_of!(RotorComponentData, rotation_axis),
            },
            FieldInfoData {
                name: "RotationMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorComponentData, rotation_multiplier),
            },
            FieldInfoData {
                name: "ChangeModelRpm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorComponentData, change_model_rpm),
            },
            FieldInfoData {
                name: "BlowEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(RotorComponentData, blow_effect),
            },
            FieldInfoData {
                name: "OnlyTriggerBlowEffectInWater",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RotorComponentData, only_trigger_blow_effect_in_water),
            },
            FieldInfoData {
                name: "TriggerGroundEffectHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorComponentData, trigger_ground_effect_height),
            },
            FieldInfoData {
                name: "GroundEffectOnTerrainOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RotorComponentData, ground_effect_on_terrain_only),
            },
            FieldInfoData {
                name: "CriticallyDamagedRotationForce",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorComponentData, critically_damaged_rotation_force),
            },
            FieldInfoData {
                name: "CriticalDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RotorComponentData, critical_damage),
            },
        ],
    }),
    array_type: Some(ROTORCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for RotorComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ROTORCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ROTORCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotorComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RotorComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RotorModelData {
    pub rotation_rpm: f32,
    pub part_index: u32,
}

pub trait RotorModelDataTrait: TypeObject {
    fn rotation_rpm(&self) -> &f32;
    fn rotation_rpm_mut(&mut self) -> &mut f32;
    fn part_index(&self) -> &u32;
    fn part_index_mut(&mut self) -> &mut u32;
}

impl RotorModelDataTrait for RotorModelData {
    fn rotation_rpm(&self) -> &f32 {
        &self.rotation_rpm
    }
    fn rotation_rpm_mut(&mut self) -> &mut f32 {
        &mut self.rotation_rpm
    }
    fn part_index(&self) -> &u32 {
        &self.part_index
    }
    fn part_index_mut(&mut self) -> &mut u32 {
        &mut self.part_index
    }
}

pub static ROTORMODELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotorModelData",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RotorModelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RotationRpm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RotorModelData, rotation_rpm),
            },
            FieldInfoData {
                name: "PartIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(RotorModelData, part_index),
            },
        ],
    }),
    array_type: Some(ROTORMODELDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RotorModelData {
    fn type_info(&self) -> &'static TypeInfo {
        ROTORMODELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ROTORMODELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotorModelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RotorModelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TrackComponentData {
    pub _glacier_base: MeshComponentData,
    pub skeleton: Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>,
    pub scroll_factor: f32,
}

pub trait TrackComponentDataTrait: MeshComponentDataTrait {
    fn skeleton(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn skeleton_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn scroll_factor(&self) -> &f32;
    fn scroll_factor_mut(&mut self) -> &mut f32;
}

impl TrackComponentDataTrait for TrackComponentData {
    fn skeleton(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &self.skeleton
    }
    fn skeleton_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &mut self.skeleton
    }
    fn scroll_factor(&self) -> &f32 {
        &self.scroll_factor
    }
    fn scroll_factor_mut(&mut self) -> &mut f32 {
        &mut self.scroll_factor
    }
}

impl MeshComponentDataTrait for TrackComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
}

impl super::entity::GameComponentDataTrait for TrackComponentData {
}

impl super::entity::ComponentDataTrait for TrackComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for TrackComponentData {
}

impl super::core::DataBusPeerTrait for TrackComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TrackComponentData {
}

impl super::core::DataContainerTrait for TrackComponentData {
}

pub static TRACKCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MESHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrackComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Skeleton",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(TrackComponentData, skeleton),
            },
            FieldInfoData {
                name: "ScrollFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrackComponentData, scroll_factor),
            },
        ],
    }),
    array_type: Some(TRACKCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TrackComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRACKCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrackComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FakePhysicsMeshComponentData {
    pub _glacier_base: MeshComponentData,
    pub bone_fake_physics: Vec<Option<Arc<Mutex<dyn BoneFakePhysicsDataTrait>>>>,
    pub skeleton: Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>,
    pub extract_mesh_transforms: bool,
    pub mesh_transforms: Vec<super::core::LinearTransform>,
}

pub trait FakePhysicsMeshComponentDataTrait: MeshComponentDataTrait {
    fn bone_fake_physics(&self) -> &Vec<Option<Arc<Mutex<dyn BoneFakePhysicsDataTrait>>>>;
    fn bone_fake_physics_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn BoneFakePhysicsDataTrait>>>>;
    fn skeleton(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn skeleton_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>>;
    fn extract_mesh_transforms(&self) -> &bool;
    fn extract_mesh_transforms_mut(&mut self) -> &mut bool;
    fn mesh_transforms(&self) -> &Vec<super::core::LinearTransform>;
    fn mesh_transforms_mut(&mut self) -> &mut Vec<super::core::LinearTransform>;
}

impl FakePhysicsMeshComponentDataTrait for FakePhysicsMeshComponentData {
    fn bone_fake_physics(&self) -> &Vec<Option<Arc<Mutex<dyn BoneFakePhysicsDataTrait>>>> {
        &self.bone_fake_physics
    }
    fn bone_fake_physics_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn BoneFakePhysicsDataTrait>>>> {
        &mut self.bone_fake_physics
    }
    fn skeleton(&self) -> &Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &self.skeleton
    }
    fn skeleton_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::SkeletonAssetTrait>>> {
        &mut self.skeleton
    }
    fn extract_mesh_transforms(&self) -> &bool {
        &self.extract_mesh_transforms
    }
    fn extract_mesh_transforms_mut(&mut self) -> &mut bool {
        &mut self.extract_mesh_transforms
    }
    fn mesh_transforms(&self) -> &Vec<super::core::LinearTransform> {
        &self.mesh_transforms
    }
    fn mesh_transforms_mut(&mut self) -> &mut Vec<super::core::LinearTransform> {
        &mut self.mesh_transforms
    }
}

impl MeshComponentDataTrait for FakePhysicsMeshComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
}

impl super::entity::GameComponentDataTrait for FakePhysicsMeshComponentData {
}

impl super::entity::ComponentDataTrait for FakePhysicsMeshComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for FakePhysicsMeshComponentData {
}

impl super::core::DataBusPeerTrait for FakePhysicsMeshComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FakePhysicsMeshComponentData {
}

impl super::core::DataContainerTrait for FakePhysicsMeshComponentData {
}

pub static FAKEPHYSICSMESHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FakePhysicsMeshComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MESHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FakePhysicsMeshComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoneFakePhysics",
                flags: MemberInfoFlags::new(144),
                field_type: "BoneFakePhysicsData-Array",
                rust_offset: offset_of!(FakePhysicsMeshComponentData, bone_fake_physics),
            },
            FieldInfoData {
                name: "Skeleton",
                flags: MemberInfoFlags::new(0),
                field_type: "SkeletonAsset",
                rust_offset: offset_of!(FakePhysicsMeshComponentData, skeleton),
            },
            FieldInfoData {
                name: "ExtractMeshTransforms",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FakePhysicsMeshComponentData, extract_mesh_transforms),
            },
            FieldInfoData {
                name: "MeshTransforms",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(FakePhysicsMeshComponentData, mesh_transforms),
            },
        ],
    }),
    array_type: Some(FAKEPHYSICSMESHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FakePhysicsMeshComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        FAKEPHYSICSMESHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FAKEPHYSICSMESHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FakePhysicsMeshComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FakePhysicsMeshComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
}

pub trait MeshComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
}

impl MeshComponentDataTrait for MeshComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
}

impl super::entity::GameComponentDataTrait for MeshComponentData {
}

impl super::entity::ComponentDataTrait for MeshComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for MeshComponentData {
}

impl super::core::DataBusPeerTrait for MeshComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MeshComponentData {
}

impl super::core::DataContainerTrait for MeshComponentData {
}

pub static MESHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(MeshComponentData, realm),
            },
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(MeshComponentData, mesh),
            },
        ],
    }),
    array_type: Some(MESHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MeshComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MESHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleCustomizationComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub always_load_cockpitmesh: bool,
    pub visual_unlock: Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>,
    pub customization: Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>,
}

pub trait VehicleCustomizationComponentDataTrait: super::entity::GameComponentDataTrait {
    fn always_load_cockpitmesh(&self) -> &bool;
    fn always_load_cockpitmesh_mut(&mut self) -> &mut bool;
    fn visual_unlock(&self) -> &Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>;
    fn visual_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>;
    fn customization(&self) -> &Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>;
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>>;
}

impl VehicleCustomizationComponentDataTrait for VehicleCustomizationComponentData {
    fn always_load_cockpitmesh(&self) -> &bool {
        &self.always_load_cockpitmesh
    }
    fn always_load_cockpitmesh_mut(&mut self) -> &mut bool {
        &mut self.always_load_cockpitmesh
    }
    fn visual_unlock(&self) -> &Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>> {
        &self.visual_unlock
    }
    fn visual_unlock_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>> {
        &mut self.visual_unlock
    }
    fn customization(&self) -> &Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>> {
        &self.customization
    }
    fn customization_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleCustomizationAssetTrait>>> {
        &mut self.customization
    }
}

impl super::entity::GameComponentDataTrait for VehicleCustomizationComponentData {
}

impl super::entity::ComponentDataTrait for VehicleCustomizationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleCustomizationComponentData {
}

impl super::core::DataBusPeerTrait for VehicleCustomizationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleCustomizationComponentData {
}

impl super::core::DataContainerTrait for VehicleCustomizationComponentData {
}

pub static VEHICLECUSTOMIZATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCustomizationComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleCustomizationComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AlwaysLoadCockpitmesh",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCustomizationComponentData, always_load_cockpitmesh),
            },
            FieldInfoData {
                name: "VisualUnlock",
                flags: MemberInfoFlags::new(0),
                field_type: "VisualUnlockAsset",
                rust_offset: offset_of!(VehicleCustomizationComponentData, visual_unlock),
            },
            FieldInfoData {
                name: "Customization",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleCustomizationAsset",
                rust_offset: offset_of!(VehicleCustomizationComponentData, customization),
            },
        ],
    }),
    array_type: Some(VEHICLECUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleCustomizationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECUSTOMIZATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLECUSTOMIZATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCustomizationComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleCustomizationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleMeshComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub cockpit_mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
}

pub trait VehicleMeshComponentDataTrait: super::entity::GameComponentDataTrait {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn cockpit_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn cockpit_mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
}

impl VehicleMeshComponentDataTrait for VehicleMeshComponentData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn cockpit_mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.cockpit_mesh
    }
    fn cockpit_mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.cockpit_mesh
    }
}

impl super::entity::GameComponentDataTrait for VehicleMeshComponentData {
}

impl super::entity::ComponentDataTrait for VehicleMeshComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleMeshComponentData {
}

impl super::core::DataBusPeerTrait for VehicleMeshComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleMeshComponentData {
}

impl super::core::DataContainerTrait for VehicleMeshComponentData {
}

pub static VEHICLEMESHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleMeshComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleMeshComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(VehicleMeshComponentData, mesh),
            },
            FieldInfoData {
                name: "CockpitMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(VehicleMeshComponentData, cockpit_mesh),
            },
        ],
    }),
    array_type: Some(VEHICLEMESHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleMeshComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEMESHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEMESHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleMeshComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleMeshComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RotationAxisEnum {
    #[default]
    RALeft = 0,
    RAUp = 1,
    RADof = 2,
}

pub static ROTATIONAXISENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationAxisEnum",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ROTATIONAXISENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RotationAxisEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ROTATIONAXISENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ROTATIONAXISENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RotationAxisEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RotationAxisEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TrackWheelComponentData {
    pub _glacier_base: WheelComponentData,
    pub bone_name: String,
}

pub trait TrackWheelComponentDataTrait: WheelComponentDataTrait {
    fn bone_name(&self) -> &String;
    fn bone_name_mut(&mut self) -> &mut String;
}

impl TrackWheelComponentDataTrait for TrackWheelComponentData {
    fn bone_name(&self) -> &String {
        &self.bone_name
    }
    fn bone_name_mut(&mut self) -> &mut String {
        &mut self.bone_name
    }
}

impl WheelComponentDataTrait for TrackWheelComponentData {
    fn config(&self) -> &Option<Arc<Mutex<dyn super::physics::WheelConfigDataTrait>>> {
        self._glacier_base.config()
    }
    fn config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::WheelConfigDataTrait>>> {
        self._glacier_base.config_mut()
    }
    fn physics_type(&self) -> &super::gameplay_sim::WheelPhysicsType {
        self._glacier_base.physics_type()
    }
    fn physics_type_mut(&mut self) -> &mut super::gameplay_sim::WheelPhysicsType {
        self._glacier_base.physics_type_mut()
    }
    fn effect_clamp_velocity(&self) -> &f32 {
        self._glacier_base.effect_clamp_velocity()
    }
    fn effect_clamp_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.effect_clamp_velocity_mut()
    }
}

impl super::entity::BoneComponentDataTrait for TrackWheelComponentData {
}

impl super::entity::GameComponentDataTrait for TrackWheelComponentData {
}

impl super::entity::ComponentDataTrait for TrackWheelComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for TrackWheelComponentData {
}

impl super::core::DataBusPeerTrait for TrackWheelComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TrackWheelComponentData {
}

impl super::core::DataContainerTrait for TrackWheelComponentData {
}

pub static TRACKWHEELCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackWheelComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WHEELCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrackWheelComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TrackWheelComponentData, bone_name),
            },
        ],
    }),
    array_type: Some(TRACKWHEELCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TrackWheelComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKWHEELCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRACKWHEELCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackWheelComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TrackWheelComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WheelComponentData {
    pub _glacier_base: super::entity::BoneComponentData,
    pub config: Option<Arc<Mutex<dyn super::physics::WheelConfigDataTrait>>>,
    pub physics_type: super::gameplay_sim::WheelPhysicsType,
    pub effect_clamp_velocity: f32,
}

pub trait WheelComponentDataTrait: super::entity::BoneComponentDataTrait {
    fn config(&self) -> &Option<Arc<Mutex<dyn super::physics::WheelConfigDataTrait>>>;
    fn config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::WheelConfigDataTrait>>>;
    fn physics_type(&self) -> &super::gameplay_sim::WheelPhysicsType;
    fn physics_type_mut(&mut self) -> &mut super::gameplay_sim::WheelPhysicsType;
    fn effect_clamp_velocity(&self) -> &f32;
    fn effect_clamp_velocity_mut(&mut self) -> &mut f32;
}

impl WheelComponentDataTrait for WheelComponentData {
    fn config(&self) -> &Option<Arc<Mutex<dyn super::physics::WheelConfigDataTrait>>> {
        &self.config
    }
    fn config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::WheelConfigDataTrait>>> {
        &mut self.config
    }
    fn physics_type(&self) -> &super::gameplay_sim::WheelPhysicsType {
        &self.physics_type
    }
    fn physics_type_mut(&mut self) -> &mut super::gameplay_sim::WheelPhysicsType {
        &mut self.physics_type
    }
    fn effect_clamp_velocity(&self) -> &f32 {
        &self.effect_clamp_velocity
    }
    fn effect_clamp_velocity_mut(&mut self) -> &mut f32 {
        &mut self.effect_clamp_velocity
    }
}

impl super::entity::BoneComponentDataTrait for WheelComponentData {
}

impl super::entity::GameComponentDataTrait for WheelComponentData {
}

impl super::entity::ComponentDataTrait for WheelComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for WheelComponentData {
}

impl super::core::DataBusPeerTrait for WheelComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WheelComponentData {
}

impl super::core::DataContainerTrait for WheelComponentData {
}

pub static WHEELCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WheelComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::BONECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WheelComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Config",
                flags: MemberInfoFlags::new(0),
                field_type: "WheelConfigData",
                rust_offset: offset_of!(WheelComponentData, config),
            },
            FieldInfoData {
                name: "PhysicsType",
                flags: MemberInfoFlags::new(0),
                field_type: "WheelPhysicsType",
                rust_offset: offset_of!(WheelComponentData, physics_type),
            },
            FieldInfoData {
                name: "EffectClampVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WheelComponentData, effect_clamp_velocity),
            },
        ],
    }),
    array_type: Some(WHEELCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for WheelComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        WHEELCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WHEELCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WheelComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("WheelComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StanceFilterComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub valid_stances: Vec<i32>,
    pub stance_change_time: f32,
    pub undo_parent_stance_filter: bool,
    pub filter_specific_actions: bool,
    pub actions_to_filter: Vec<ActionSuppressor>,
}

pub trait StanceFilterComponentDataTrait: super::entity::GameComponentDataTrait {
    fn valid_stances(&self) -> &Vec<i32>;
    fn valid_stances_mut(&mut self) -> &mut Vec<i32>;
    fn stance_change_time(&self) -> &f32;
    fn stance_change_time_mut(&mut self) -> &mut f32;
    fn undo_parent_stance_filter(&self) -> &bool;
    fn undo_parent_stance_filter_mut(&mut self) -> &mut bool;
    fn filter_specific_actions(&self) -> &bool;
    fn filter_specific_actions_mut(&mut self) -> &mut bool;
    fn actions_to_filter(&self) -> &Vec<ActionSuppressor>;
    fn actions_to_filter_mut(&mut self) -> &mut Vec<ActionSuppressor>;
}

impl StanceFilterComponentDataTrait for StanceFilterComponentData {
    fn valid_stances(&self) -> &Vec<i32> {
        &self.valid_stances
    }
    fn valid_stances_mut(&mut self) -> &mut Vec<i32> {
        &mut self.valid_stances
    }
    fn stance_change_time(&self) -> &f32 {
        &self.stance_change_time
    }
    fn stance_change_time_mut(&mut self) -> &mut f32 {
        &mut self.stance_change_time
    }
    fn undo_parent_stance_filter(&self) -> &bool {
        &self.undo_parent_stance_filter
    }
    fn undo_parent_stance_filter_mut(&mut self) -> &mut bool {
        &mut self.undo_parent_stance_filter
    }
    fn filter_specific_actions(&self) -> &bool {
        &self.filter_specific_actions
    }
    fn filter_specific_actions_mut(&mut self) -> &mut bool {
        &mut self.filter_specific_actions
    }
    fn actions_to_filter(&self) -> &Vec<ActionSuppressor> {
        &self.actions_to_filter
    }
    fn actions_to_filter_mut(&mut self) -> &mut Vec<ActionSuppressor> {
        &mut self.actions_to_filter
    }
}

impl super::entity::GameComponentDataTrait for StanceFilterComponentData {
}

impl super::entity::ComponentDataTrait for StanceFilterComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StanceFilterComponentData {
}

impl super::core::DataBusPeerTrait for StanceFilterComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StanceFilterComponentData {
}

impl super::core::DataContainerTrait for StanceFilterComponentData {
}

pub static STANCEFILTERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceFilterComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StanceFilterComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ValidStances",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StanceFilterComponentData, valid_stances),
            },
            FieldInfoData {
                name: "StanceChangeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StanceFilterComponentData, stance_change_time),
            },
            FieldInfoData {
                name: "UndoParentStanceFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StanceFilterComponentData, undo_parent_stance_filter),
            },
            FieldInfoData {
                name: "FilterSpecificActions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StanceFilterComponentData, filter_specific_actions),
            },
            FieldInfoData {
                name: "ActionsToFilter",
                flags: MemberInfoFlags::new(144),
                field_type: "ActionSuppressor-Array",
                rust_offset: offset_of!(StanceFilterComponentData, actions_to_filter),
            },
        ],
    }),
    array_type: Some(STANCEFILTERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StanceFilterComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STANCEFILTERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STANCEFILTERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceFilterComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StanceFilterComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EngineComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub config: Option<Arc<Mutex<dyn super::physics::EngineConfigDataTrait>>>,
    pub sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub surface_sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub use_first_person_sounds: bool,
}

pub trait EngineComponentDataTrait: super::entity::GameComponentDataTrait {
    fn config(&self) -> &Option<Arc<Mutex<dyn super::physics::EngineConfigDataTrait>>>;
    fn config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::EngineConfigDataTrait>>>;
    fn sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn surface_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn surface_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn use_first_person_sounds(&self) -> &bool;
    fn use_first_person_sounds_mut(&mut self) -> &mut bool;
}

impl EngineComponentDataTrait for EngineComponentData {
    fn config(&self) -> &Option<Arc<Mutex<dyn super::physics::EngineConfigDataTrait>>> {
        &self.config
    }
    fn config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::EngineConfigDataTrait>>> {
        &mut self.config
    }
    fn sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.sound_effect
    }
    fn sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.sound_effect
    }
    fn surface_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.surface_sound_effect
    }
    fn surface_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.surface_sound_effect
    }
    fn use_first_person_sounds(&self) -> &bool {
        &self.use_first_person_sounds
    }
    fn use_first_person_sounds_mut(&mut self) -> &mut bool {
        &mut self.use_first_person_sounds
    }
}

impl super::entity::GameComponentDataTrait for EngineComponentData {
}

impl super::entity::ComponentDataTrait for EngineComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EngineComponentData {
}

impl super::core::DataBusPeerTrait for EngineComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EngineComponentData {
}

impl super::core::DataContainerTrait for EngineComponentData {
}

pub static ENGINECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EngineComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EngineComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Config",
                flags: MemberInfoFlags::new(0),
                field_type: "EngineConfigData",
                rust_offset: offset_of!(EngineComponentData, config),
            },
            FieldInfoData {
                name: "SoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(EngineComponentData, sound_effect),
            },
            FieldInfoData {
                name: "SurfaceSoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(EngineComponentData, surface_sound_effect),
            },
            FieldInfoData {
                name: "UseFirstPersonSounds",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EngineComponentData, use_first_person_sounds),
            },
        ],
    }),
    array_type: Some(ENGINECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EngineComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        ENGINECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENGINECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EngineComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EngineComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChildComponentData {
    pub _glacier_base: super::entity::BoneComponentData,
    pub sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub moving_body: Option<Arc<Mutex<dyn super::physics::MovingBodyDataTrait>>>,
    pub health_zone: VehicleHealthZoneData,
    pub sound_effect_start_rpm: f32,
    pub sound_effect_stop_rpm: f32,
    pub alignment_settings: Option<Arc<Mutex<dyn AlignmentDataTrait>>>,
    pub world_space_position_lock: bool,
    pub enable_align_to_camera: bool,
    pub align_transform: super::core::LinearTransform,
}

pub trait ChildComponentDataTrait: super::entity::BoneComponentDataTrait {
    fn sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn moving_body(&self) -> &Option<Arc<Mutex<dyn super::physics::MovingBodyDataTrait>>>;
    fn moving_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::MovingBodyDataTrait>>>;
    fn health_zone(&self) -> &VehicleHealthZoneData;
    fn health_zone_mut(&mut self) -> &mut VehicleHealthZoneData;
    fn sound_effect_start_rpm(&self) -> &f32;
    fn sound_effect_start_rpm_mut(&mut self) -> &mut f32;
    fn sound_effect_stop_rpm(&self) -> &f32;
    fn sound_effect_stop_rpm_mut(&mut self) -> &mut f32;
    fn alignment_settings(&self) -> &Option<Arc<Mutex<dyn AlignmentDataTrait>>>;
    fn alignment_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AlignmentDataTrait>>>;
    fn world_space_position_lock(&self) -> &bool;
    fn world_space_position_lock_mut(&mut self) -> &mut bool;
    fn enable_align_to_camera(&self) -> &bool;
    fn enable_align_to_camera_mut(&mut self) -> &mut bool;
    fn align_transform(&self) -> &super::core::LinearTransform;
    fn align_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl ChildComponentDataTrait for ChildComponentData {
    fn sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.sound_effect
    }
    fn sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.sound_effect
    }
    fn moving_body(&self) -> &Option<Arc<Mutex<dyn super::physics::MovingBodyDataTrait>>> {
        &self.moving_body
    }
    fn moving_body_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::MovingBodyDataTrait>>> {
        &mut self.moving_body
    }
    fn health_zone(&self) -> &VehicleHealthZoneData {
        &self.health_zone
    }
    fn health_zone_mut(&mut self) -> &mut VehicleHealthZoneData {
        &mut self.health_zone
    }
    fn sound_effect_start_rpm(&self) -> &f32 {
        &self.sound_effect_start_rpm
    }
    fn sound_effect_start_rpm_mut(&mut self) -> &mut f32 {
        &mut self.sound_effect_start_rpm
    }
    fn sound_effect_stop_rpm(&self) -> &f32 {
        &self.sound_effect_stop_rpm
    }
    fn sound_effect_stop_rpm_mut(&mut self) -> &mut f32 {
        &mut self.sound_effect_stop_rpm
    }
    fn alignment_settings(&self) -> &Option<Arc<Mutex<dyn AlignmentDataTrait>>> {
        &self.alignment_settings
    }
    fn alignment_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AlignmentDataTrait>>> {
        &mut self.alignment_settings
    }
    fn world_space_position_lock(&self) -> &bool {
        &self.world_space_position_lock
    }
    fn world_space_position_lock_mut(&mut self) -> &mut bool {
        &mut self.world_space_position_lock
    }
    fn enable_align_to_camera(&self) -> &bool {
        &self.enable_align_to_camera
    }
    fn enable_align_to_camera_mut(&mut self) -> &mut bool {
        &mut self.enable_align_to_camera
    }
    fn align_transform(&self) -> &super::core::LinearTransform {
        &self.align_transform
    }
    fn align_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.align_transform
    }
}

impl super::entity::BoneComponentDataTrait for ChildComponentData {
}

impl super::entity::GameComponentDataTrait for ChildComponentData {
}

impl super::entity::ComponentDataTrait for ChildComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for ChildComponentData {
}

impl super::core::DataBusPeerTrait for ChildComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ChildComponentData {
}

impl super::core::DataContainerTrait for ChildComponentData {
}

pub static CHILDCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::BONECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(ChildComponentData, sound_effect),
            },
            FieldInfoData {
                name: "MovingBody",
                flags: MemberInfoFlags::new(0),
                field_type: "MovingBodyData",
                rust_offset: offset_of!(ChildComponentData, moving_body),
            },
            FieldInfoData {
                name: "HealthZone",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleHealthZoneData",
                rust_offset: offset_of!(ChildComponentData, health_zone),
            },
            FieldInfoData {
                name: "SoundEffectStartRpm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildComponentData, sound_effect_start_rpm),
            },
            FieldInfoData {
                name: "SoundEffectStopRpm",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChildComponentData, sound_effect_stop_rpm),
            },
            FieldInfoData {
                name: "AlignmentSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "AlignmentData",
                rust_offset: offset_of!(ChildComponentData, alignment_settings),
            },
            FieldInfoData {
                name: "WorldSpacePositionLock",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildComponentData, world_space_position_lock),
            },
            FieldInfoData {
                name: "EnableAlignToCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ChildComponentData, enable_align_to_camera),
            },
            FieldInfoData {
                name: "AlignTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ChildComponentData, align_transform),
            },
        ],
    }),
    array_type: Some(CHILDCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ChildComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHILDCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleEntryComponentData {
    pub _glacier_base: PlayerEntryComponentData,
    pub number_of_stances: i32,
    pub stances_enabled: bool,
    pub entry_component_sound: Option<Arc<Mutex<dyn EntryComponentSoundDataTrait>>>,
    pub character_collision_offset: super::core::Vec3,
    pub character_collision_offset_realm: super::core::Realm,
}

pub trait VehicleEntryComponentDataTrait: PlayerEntryComponentDataTrait {
    fn number_of_stances(&self) -> &i32;
    fn number_of_stances_mut(&mut self) -> &mut i32;
    fn stances_enabled(&self) -> &bool;
    fn stances_enabled_mut(&mut self) -> &mut bool;
    fn entry_component_sound(&self) -> &Option<Arc<Mutex<dyn EntryComponentSoundDataTrait>>>;
    fn entry_component_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn EntryComponentSoundDataTrait>>>;
    fn character_collision_offset(&self) -> &super::core::Vec3;
    fn character_collision_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn character_collision_offset_realm(&self) -> &super::core::Realm;
    fn character_collision_offset_realm_mut(&mut self) -> &mut super::core::Realm;
}

impl VehicleEntryComponentDataTrait for VehicleEntryComponentData {
    fn number_of_stances(&self) -> &i32 {
        &self.number_of_stances
    }
    fn number_of_stances_mut(&mut self) -> &mut i32 {
        &mut self.number_of_stances
    }
    fn stances_enabled(&self) -> &bool {
        &self.stances_enabled
    }
    fn stances_enabled_mut(&mut self) -> &mut bool {
        &mut self.stances_enabled
    }
    fn entry_component_sound(&self) -> &Option<Arc<Mutex<dyn EntryComponentSoundDataTrait>>> {
        &self.entry_component_sound
    }
    fn entry_component_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn EntryComponentSoundDataTrait>>> {
        &mut self.entry_component_sound
    }
    fn character_collision_offset(&self) -> &super::core::Vec3 {
        &self.character_collision_offset
    }
    fn character_collision_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.character_collision_offset
    }
    fn character_collision_offset_realm(&self) -> &super::core::Realm {
        &self.character_collision_offset_realm
    }
    fn character_collision_offset_realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.character_collision_offset_realm
    }
}

impl PlayerEntryComponentDataTrait for VehicleEntryComponentData {
    fn ant_entry_i_d(&self) -> &String {
        self._glacier_base.ant_entry_i_d()
    }
    fn ant_entry_i_d_mut(&mut self) -> &mut String {
        self._glacier_base.ant_entry_i_d_mut()
    }
    fn ant_entry_id(&self) -> &AntEntryIdEnum {
        self._glacier_base.ant_entry_id()
    }
    fn ant_entry_id_mut(&mut self) -> &mut AntEntryIdEnum {
        self._glacier_base.ant_entry_id_mut()
    }
    fn ant_entry_enumeration(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        self._glacier_base.ant_entry_enumeration()
    }
    fn ant_entry_enumeration_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        self._glacier_base.ant_entry_enumeration_mut()
    }
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3 {
        self._glacier_base.animation_acceleration_multiplier()
    }
    fn animation_acceleration_multiplier_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.animation_acceleration_multiplier_mut()
    }
}

impl GameEntryComponentDataTrait for VehicleEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        self._glacier_base.lock_soldier_aiming_to_entry()
    }
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.lock_soldier_aiming_to_entry_mut()
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.soldier_offset()
    }
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.soldier_offset_mut()
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for VehicleEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn entry_class_mut(&mut self) -> &mut super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class_mut()
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data_mut()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn forbidden_for_human_mut(&mut self) -> &mut bool {
        self._glacier_base.forbidden_for_human_mut()
    }
    fn input_graph(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph()
    }
    fn input_graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph_mut()
    }
    fn input_concept_definition(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition()
    }
    fn input_concept_definition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition_mut()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn action_map_settings_flip_y_scheme_override_mut(&mut self) -> &mut i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override_mut()
    }
    fn input_mapping(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping()
    }
    fn input_mapping_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping_mut()
    }
    fn input_curves(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves()
    }
    fn input_curves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves_mut()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn hud_data_mut(&mut self) -> &mut super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data_mut()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn entry_order_number_mut(&mut self) -> &mut i32 {
        self._glacier_base.entry_order_number_mut()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn enter_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.enter_impulse_mut()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn entry_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.entry_radius_mut()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn is_allowed_to_exit_in_air_mut(&mut self) -> &mut bool {
        self._glacier_base.is_allowed_to_exit_in_air_mut()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn clear_path_to_exit_point_start_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset_mut()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn is_shielded_mut(&mut self) -> &mut bool {
        self._glacier_base.is_shielded_mut()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_in_entry_mut()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn show1p_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_mut()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn soldier_transition_invisble_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.soldier_transition_invisble_time_mut()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn entry_spotting_settings_mut(&mut self) -> &mut super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings_mut()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_weapon_in_entry_mut()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show1p_soldier_in_entry_for_player_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only_mut()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show3p_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show3p_soldier_weapon_in_entry_mut()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn show_soldier_gear_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_gear_in_entry_mut()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn pose_constraints_mut(&mut self) -> &mut super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints_mut()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn use_local_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_local_transform_mut()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn trigger_event_on_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.trigger_event_on_key_mut()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn allow_ragdoll_from_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_ragdoll_from_entry_mut()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
    fn camera_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.camera_index_mut()
    }
}

impl super::entity::GameComponentDataTrait for VehicleEntryComponentData {
}

impl super::entity::ComponentDataTrait for VehicleEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleEntryComponentData {
}

impl super::core::DataBusPeerTrait for VehicleEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleEntryComponentData {
}

impl super::core::DataContainerTrait for VehicleEntryComponentData {
}

pub static VEHICLEENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PLAYERENTRYCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleEntryComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NumberOfStances",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleEntryComponentData, number_of_stances),
            },
            FieldInfoData {
                name: "StancesEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleEntryComponentData, stances_enabled),
            },
            FieldInfoData {
                name: "EntryComponentSound",
                flags: MemberInfoFlags::new(0),
                field_type: "EntryComponentSoundData",
                rust_offset: offset_of!(VehicleEntryComponentData, entry_component_sound),
            },
            FieldInfoData {
                name: "CharacterCollisionOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VehicleEntryComponentData, character_collision_offset),
            },
            FieldInfoData {
                name: "CharacterCollisionOffsetRealm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(VehicleEntryComponentData, character_collision_offset_realm),
            },
        ],
    }),
    array_type: Some(VEHICLEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleEntryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntryComponentSoundData {
    pub _glacier_base: super::core::DataContainer,
    pub stance_sounds: Vec<StanceSwitchSoundData>,
    pub stance_switch_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
}

pub trait EntryComponentSoundDataTrait: super::core::DataContainerTrait {
    fn stance_sounds(&self) -> &Vec<StanceSwitchSoundData>;
    fn stance_sounds_mut(&mut self) -> &mut Vec<StanceSwitchSoundData>;
    fn stance_switch_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn stance_switch_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
}

impl EntryComponentSoundDataTrait for EntryComponentSoundData {
    fn stance_sounds(&self) -> &Vec<StanceSwitchSoundData> {
        &self.stance_sounds
    }
    fn stance_sounds_mut(&mut self) -> &mut Vec<StanceSwitchSoundData> {
        &mut self.stance_sounds
    }
    fn stance_switch_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.stance_switch_sound
    }
    fn stance_switch_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.stance_switch_sound
    }
}

impl super::core::DataContainerTrait for EntryComponentSoundData {
}

pub static ENTRYCOMPONENTSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryComponentSoundData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntryComponentSoundData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StanceSounds",
                flags: MemberInfoFlags::new(144),
                field_type: "StanceSwitchSoundData-Array",
                rust_offset: offset_of!(EntryComponentSoundData, stance_sounds),
            },
            FieldInfoData {
                name: "StanceSwitchSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(EntryComponentSoundData, stance_switch_sound),
            },
        ],
    }),
    array_type: Some(ENTRYCOMPONENTSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntryComponentSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTRYCOMPONENTSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTRYCOMPONENTSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryComponentSoundData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntryComponentSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StanceSwitchSoundData {
    pub stance_switch_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub valid_stances: Vec<i32>,
}

pub trait StanceSwitchSoundDataTrait: TypeObject {
    fn stance_switch_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn stance_switch_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn valid_stances(&self) -> &Vec<i32>;
    fn valid_stances_mut(&mut self) -> &mut Vec<i32>;
}

impl StanceSwitchSoundDataTrait for StanceSwitchSoundData {
    fn stance_switch_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.stance_switch_sound
    }
    fn stance_switch_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.stance_switch_sound
    }
    fn valid_stances(&self) -> &Vec<i32> {
        &self.valid_stances
    }
    fn valid_stances_mut(&mut self) -> &mut Vec<i32> {
        &mut self.valid_stances
    }
}

pub static STANCESWITCHSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceSwitchSoundData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StanceSwitchSoundData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StanceSwitchSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(StanceSwitchSoundData, stance_switch_sound),
            },
            FieldInfoData {
                name: "ValidStances",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(StanceSwitchSoundData, valid_stances),
            },
        ],
    }),
    array_type: Some(STANCESWITCHSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StanceSwitchSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        STANCESWITCHSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STANCESWITCHSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StanceSwitchSoundData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StanceSwitchSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraComponentSoundData {
    pub _glacier_base: super::core::DataContainer,
    pub switch_to_alternate_view_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub switch_to_normal_view_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
}

pub trait CameraComponentSoundDataTrait: super::core::DataContainerTrait {
    fn switch_to_alternate_view_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn switch_to_alternate_view_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn switch_to_normal_view_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn switch_to_normal_view_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
}

impl CameraComponentSoundDataTrait for CameraComponentSoundData {
    fn switch_to_alternate_view_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.switch_to_alternate_view_sound
    }
    fn switch_to_alternate_view_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.switch_to_alternate_view_sound
    }
    fn switch_to_normal_view_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.switch_to_normal_view_sound
    }
    fn switch_to_normal_view_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.switch_to_normal_view_sound
    }
}

impl super::core::DataContainerTrait for CameraComponentSoundData {
}

pub static CAMERACOMPONENTSOUNDDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraComponentSoundData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraComponentSoundData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SwitchToAlternateViewSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(CameraComponentSoundData, switch_to_alternate_view_sound),
            },
            FieldInfoData {
                name: "SwitchToNormalViewSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(CameraComponentSoundData, switch_to_normal_view_sound),
            },
        ],
    }),
    array_type: Some(CAMERACOMPONENTSOUNDDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraComponentSoundData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERACOMPONENTSOUNDDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERACOMPONENTSOUNDDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraComponentSoundData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraComponentSoundData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BasicUnlockInfo {
    pub unlock_guid: glacier_util::guid::Guid,
    pub identifier: u32,
    pub unlock_score: u32,
    pub licenses: Vec<String>,
    pub additional_licenses: Vec<String>,
    pub string_id: String,
}

pub trait BasicUnlockInfoTrait: TypeObject {
    fn unlock_guid(&self) -> &glacier_util::guid::Guid;
    fn unlock_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn identifier(&self) -> &u32;
    fn identifier_mut(&mut self) -> &mut u32;
    fn unlock_score(&self) -> &u32;
    fn unlock_score_mut(&mut self) -> &mut u32;
    fn licenses(&self) -> &Vec<String>;
    fn licenses_mut(&mut self) -> &mut Vec<String>;
    fn additional_licenses(&self) -> &Vec<String>;
    fn additional_licenses_mut(&mut self) -> &mut Vec<String>;
    fn string_id(&self) -> &String;
    fn string_id_mut(&mut self) -> &mut String;
}

impl BasicUnlockInfoTrait for BasicUnlockInfo {
    fn unlock_guid(&self) -> &glacier_util::guid::Guid {
        &self.unlock_guid
    }
    fn unlock_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.unlock_guid
    }
    fn identifier(&self) -> &u32 {
        &self.identifier
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        &mut self.identifier
    }
    fn unlock_score(&self) -> &u32 {
        &self.unlock_score
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        &mut self.unlock_score
    }
    fn licenses(&self) -> &Vec<String> {
        &self.licenses
    }
    fn licenses_mut(&mut self) -> &mut Vec<String> {
        &mut self.licenses
    }
    fn additional_licenses(&self) -> &Vec<String> {
        &self.additional_licenses
    }
    fn additional_licenses_mut(&mut self) -> &mut Vec<String> {
        &mut self.additional_licenses
    }
    fn string_id(&self) -> &String {
        &self.string_id
    }
    fn string_id_mut(&mut self) -> &mut String {
        &mut self.string_id
    }
}

pub static BASICUNLOCKINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicUnlockInfo",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BasicUnlockInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(BasicUnlockInfo, unlock_guid),
            },
            FieldInfoData {
                name: "Identifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BasicUnlockInfo, identifier),
            },
            FieldInfoData {
                name: "UnlockScore",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BasicUnlockInfo, unlock_score),
            },
            FieldInfoData {
                name: "Licenses",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(BasicUnlockInfo, licenses),
            },
            FieldInfoData {
                name: "AdditionalLicenses",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(BasicUnlockInfo, additional_licenses),
            },
            FieldInfoData {
                name: "StringId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(BasicUnlockInfo, string_id),
            },
        ],
    }),
    array_type: Some(BASICUNLOCKINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicUnlockInfo {
    fn type_info(&self) -> &'static TypeInfo {
        BASICUNLOCKINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BASICUNLOCKINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicUnlockInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BasicUnlockInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValueUnlockAsset {
    pub _glacier_base: UnlockAssetBase,
    pub unlock_values: Vec<Option<Arc<Mutex<dyn UnlockValuePairTrait>>>>,
}

pub trait ValueUnlockAssetTrait: UnlockAssetBaseTrait {
    fn unlock_values(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockValuePairTrait>>>>;
    fn unlock_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockValuePairTrait>>>>;
}

impl ValueUnlockAssetTrait for ValueUnlockAsset {
    fn unlock_values(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockValuePairTrait>>>> {
        &self.unlock_values
    }
    fn unlock_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockValuePairTrait>>>> {
        &mut self.unlock_values
    }
}

impl UnlockAssetBaseTrait for ValueUnlockAsset {
    fn unlock_user_data(&self) -> &Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data()
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data_mut()
    }
    fn debug_unlock_id(&self) -> &String {
        self._glacier_base.debug_unlock_id()
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        self._glacier_base.debug_unlock_id_mut()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        self._glacier_base.identifier_mut()
    }
    fn unlock_score(&self) -> &u32 {
        self._glacier_base.unlock_score()
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        self._glacier_base.unlock_score_mut()
    }
    fn auto_available(&self) -> &bool {
        self._glacier_base.auto_available()
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_available_mut()
    }
    fn next_level_unlock_asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset()
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset_mut()
    }
    fn hidden_in_progression(&self) -> &bool {
        self._glacier_base.hidden_in_progression()
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        self._glacier_base.hidden_in_progression_mut()
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        self._glacier_base.available_for_player()
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        self._glacier_base.available_for_player_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for ValueUnlockAsset {
}

impl super::core::AssetTrait for ValueUnlockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ValueUnlockAsset {
}

pub static VALUEUNLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueUnlockAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKASSETBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValueUnlockAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockValues",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockValuePair-Array",
                rust_offset: offset_of!(ValueUnlockAsset, unlock_values),
            },
        ],
    }),
    array_type: Some(VALUEUNLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueUnlockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VALUEUNLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALUEUNLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueUnlockAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ValueUnlockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolUnlockValuePair {
    pub _glacier_base: UnlockValuePair,
    pub default_value: bool,
    pub unlocked_value: bool,
}

pub trait BoolUnlockValuePairTrait: UnlockValuePairTrait {
    fn default_value(&self) -> &bool;
    fn default_value_mut(&mut self) -> &mut bool;
    fn unlocked_value(&self) -> &bool;
    fn unlocked_value_mut(&mut self) -> &mut bool;
}

impl BoolUnlockValuePairTrait for BoolUnlockValuePair {
    fn default_value(&self) -> &bool {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut bool {
        &mut self.default_value
    }
    fn unlocked_value(&self) -> &bool {
        &self.unlocked_value
    }
    fn unlocked_value_mut(&mut self) -> &mut bool {
        &mut self.unlocked_value
    }
}

impl UnlockValuePairTrait for BoolUnlockValuePair {
    fn id(&self) -> &String {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut String {
        self._glacier_base.id_mut()
    }
}

impl super::core::DataContainerTrait for BoolUnlockValuePair {
}

pub static BOOLUNLOCKVALUEPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolUnlockValuePair",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKVALUEPAIR_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolUnlockValuePair as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolUnlockValuePair, default_value),
            },
            FieldInfoData {
                name: "UnlockedValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BoolUnlockValuePair, unlocked_value),
            },
        ],
    }),
    array_type: Some(BOOLUNLOCKVALUEPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolUnlockValuePair {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLUNLOCKVALUEPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLUNLOCKVALUEPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolUnlockValuePair-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoolUnlockValuePair"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntUnlockValuePair {
    pub _glacier_base: UnlockValuePair,
    pub default_value: i32,
    pub unlocked_value: i32,
}

pub trait IntUnlockValuePairTrait: UnlockValuePairTrait {
    fn default_value(&self) -> &i32;
    fn default_value_mut(&mut self) -> &mut i32;
    fn unlocked_value(&self) -> &i32;
    fn unlocked_value_mut(&mut self) -> &mut i32;
}

impl IntUnlockValuePairTrait for IntUnlockValuePair {
    fn default_value(&self) -> &i32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut i32 {
        &mut self.default_value
    }
    fn unlocked_value(&self) -> &i32 {
        &self.unlocked_value
    }
    fn unlocked_value_mut(&mut self) -> &mut i32 {
        &mut self.unlocked_value
    }
}

impl UnlockValuePairTrait for IntUnlockValuePair {
    fn id(&self) -> &String {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut String {
        self._glacier_base.id_mut()
    }
}

impl super::core::DataContainerTrait for IntUnlockValuePair {
}

pub static INTUNLOCKVALUEPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntUnlockValuePair",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKVALUEPAIR_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntUnlockValuePair as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntUnlockValuePair, default_value),
            },
            FieldInfoData {
                name: "UnlockedValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(IntUnlockValuePair, unlocked_value),
            },
        ],
    }),
    array_type: Some(INTUNLOCKVALUEPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntUnlockValuePair {
    fn type_info(&self) -> &'static TypeInfo {
        INTUNLOCKVALUEPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTUNLOCKVALUEPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntUnlockValuePair-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntUnlockValuePair"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatUnlockValuePair {
    pub _glacier_base: UnlockValuePair,
    pub default_value: f32,
    pub unlocked_value: f32,
}

pub trait FloatUnlockValuePairTrait: UnlockValuePairTrait {
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
    fn unlocked_value(&self) -> &f32;
    fn unlocked_value_mut(&mut self) -> &mut f32;
}

impl FloatUnlockValuePairTrait for FloatUnlockValuePair {
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
    fn unlocked_value(&self) -> &f32 {
        &self.unlocked_value
    }
    fn unlocked_value_mut(&mut self) -> &mut f32 {
        &mut self.unlocked_value
    }
}

impl UnlockValuePairTrait for FloatUnlockValuePair {
    fn id(&self) -> &String {
        self._glacier_base.id()
    }
    fn id_mut(&mut self) -> &mut String {
        self._glacier_base.id_mut()
    }
}

impl super::core::DataContainerTrait for FloatUnlockValuePair {
}

pub static FLOATUNLOCKVALUEPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatUnlockValuePair",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKVALUEPAIR_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatUnlockValuePair as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatUnlockValuePair, default_value),
            },
            FieldInfoData {
                name: "UnlockedValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FloatUnlockValuePair, unlocked_value),
            },
        ],
    }),
    array_type: Some(FLOATUNLOCKVALUEPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatUnlockValuePair {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATUNLOCKVALUEPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATUNLOCKVALUEPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatUnlockValuePair-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FloatUnlockValuePair"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockValuePair {
    pub _glacier_base: super::core::DataContainer,
    pub id: String,
}

pub trait UnlockValuePairTrait: super::core::DataContainerTrait {
    fn id(&self) -> &String;
    fn id_mut(&mut self) -> &mut String;
}

impl UnlockValuePairTrait for UnlockValuePair {
    fn id(&self) -> &String {
        &self.id
    }
    fn id_mut(&mut self) -> &mut String {
        &mut self.id
    }
}

impl super::core::DataContainerTrait for UnlockValuePair {
}

pub static UNLOCKVALUEPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockValuePair",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockValuePair as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(UnlockValuePair, id),
            },
        ],
    }),
    array_type: Some(UNLOCKVALUEPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockValuePair {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKVALUEPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKVALUEPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockValuePair-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockValuePair"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockAssetPair {
    pub second: Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>,
    pub result: Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>,
}

pub trait UnlockAssetPairTrait: TypeObject {
    fn second(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
    fn second_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
    fn result(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
    fn result_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
}

impl UnlockAssetPairTrait for UnlockAssetPair {
    fn second(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &self.second
    }
    fn second_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &mut self.second
    }
    fn result(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &self.result
    }
    fn result_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &mut self.result
    }
}

pub static UNLOCKASSETPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAssetPair",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockAssetPair as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Second",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(UnlockAssetPair, second),
            },
            FieldInfoData {
                name: "Result",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(UnlockAssetPair, result),
            },
        ],
    }),
    array_type: Some(UNLOCKASSETPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockAssetPair {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKASSETPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UNLOCKASSETPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAssetPair-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockAssetPair"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisualUnlockAsset {
    pub _glacier_base: UnlockAsset,
    pub out_object_blueprint: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
    pub third_person_bundles: Vec<super::gameplay_sim::BlueprintBundleReference>,
    pub first_person_bundles: Vec<super::gameplay_sim::BlueprintBundleReference>,
    pub render_in1p: bool,
    pub disable_render1p_in_foreground: bool,
    pub entry_index: i32,
    pub on_demand_loaded: bool,
    pub face_poser_library: super::ant::AntRef,
    pub morph_dof_set: super::ant::AntRef,
    pub morph_texture_blend_dof_set: super::ant::AntRef,
    pub visual_ant_game_states: Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>>,
    pub rig_scale: Option<Arc<Mutex<dyn WriteFloatGameStateTrait>>>,
    pub visual_unlock_assets: Vec<Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>>,
}

pub trait VisualUnlockAssetTrait: UnlockAssetTrait {
    fn out_object_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn out_object_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn third_person_bundles(&self) -> &Vec<super::gameplay_sim::BlueprintBundleReference>;
    fn third_person_bundles_mut(&mut self) -> &mut Vec<super::gameplay_sim::BlueprintBundleReference>;
    fn first_person_bundles(&self) -> &Vec<super::gameplay_sim::BlueprintBundleReference>;
    fn first_person_bundles_mut(&mut self) -> &mut Vec<super::gameplay_sim::BlueprintBundleReference>;
    fn render_in1p(&self) -> &bool;
    fn render_in1p_mut(&mut self) -> &mut bool;
    fn disable_render1p_in_foreground(&self) -> &bool;
    fn disable_render1p_in_foreground_mut(&mut self) -> &mut bool;
    fn entry_index(&self) -> &i32;
    fn entry_index_mut(&mut self) -> &mut i32;
    fn on_demand_loaded(&self) -> &bool;
    fn on_demand_loaded_mut(&mut self) -> &mut bool;
    fn face_poser_library(&self) -> &super::ant::AntRef;
    fn face_poser_library_mut(&mut self) -> &mut super::ant::AntRef;
    fn morph_dof_set(&self) -> &super::ant::AntRef;
    fn morph_dof_set_mut(&mut self) -> &mut super::ant::AntRef;
    fn morph_texture_blend_dof_set(&self) -> &super::ant::AntRef;
    fn morph_texture_blend_dof_set_mut(&mut self) -> &mut super::ant::AntRef;
    fn visual_ant_game_states(&self) -> &Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>>;
    fn visual_ant_game_states_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>>;
    fn rig_scale(&self) -> &Option<Arc<Mutex<dyn WriteFloatGameStateTrait>>>;
    fn rig_scale_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WriteFloatGameStateTrait>>>;
    fn visual_unlock_assets(&self) -> &Vec<Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>>;
    fn visual_unlock_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>>;
}

impl VisualUnlockAssetTrait for VisualUnlockAsset {
    fn out_object_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.out_object_blueprint
    }
    fn out_object_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.out_object_blueprint
    }
    fn third_person_bundles(&self) -> &Vec<super::gameplay_sim::BlueprintBundleReference> {
        &self.third_person_bundles
    }
    fn third_person_bundles_mut(&mut self) -> &mut Vec<super::gameplay_sim::BlueprintBundleReference> {
        &mut self.third_person_bundles
    }
    fn first_person_bundles(&self) -> &Vec<super::gameplay_sim::BlueprintBundleReference> {
        &self.first_person_bundles
    }
    fn first_person_bundles_mut(&mut self) -> &mut Vec<super::gameplay_sim::BlueprintBundleReference> {
        &mut self.first_person_bundles
    }
    fn render_in1p(&self) -> &bool {
        &self.render_in1p
    }
    fn render_in1p_mut(&mut self) -> &mut bool {
        &mut self.render_in1p
    }
    fn disable_render1p_in_foreground(&self) -> &bool {
        &self.disable_render1p_in_foreground
    }
    fn disable_render1p_in_foreground_mut(&mut self) -> &mut bool {
        &mut self.disable_render1p_in_foreground
    }
    fn entry_index(&self) -> &i32 {
        &self.entry_index
    }
    fn entry_index_mut(&mut self) -> &mut i32 {
        &mut self.entry_index
    }
    fn on_demand_loaded(&self) -> &bool {
        &self.on_demand_loaded
    }
    fn on_demand_loaded_mut(&mut self) -> &mut bool {
        &mut self.on_demand_loaded
    }
    fn face_poser_library(&self) -> &super::ant::AntRef {
        &self.face_poser_library
    }
    fn face_poser_library_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.face_poser_library
    }
    fn morph_dof_set(&self) -> &super::ant::AntRef {
        &self.morph_dof_set
    }
    fn morph_dof_set_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.morph_dof_set
    }
    fn morph_texture_blend_dof_set(&self) -> &super::ant::AntRef {
        &self.morph_texture_blend_dof_set
    }
    fn morph_texture_blend_dof_set_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.morph_texture_blend_dof_set
    }
    fn visual_ant_game_states(&self) -> &Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>> {
        &self.visual_ant_game_states
    }
    fn visual_ant_game_states_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WriteAntGameStateDataTrait>>>> {
        &mut self.visual_ant_game_states
    }
    fn rig_scale(&self) -> &Option<Arc<Mutex<dyn WriteFloatGameStateTrait>>> {
        &self.rig_scale
    }
    fn rig_scale_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WriteFloatGameStateTrait>>> {
        &mut self.rig_scale
    }
    fn visual_unlock_assets(&self) -> &Vec<Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>> {
        &self.visual_unlock_assets
    }
    fn visual_unlock_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VisualUnlockAssetTrait>>>> {
        &mut self.visual_unlock_assets
    }
}

impl UnlockAssetTrait for VisualUnlockAsset {
}

impl UnlockAssetBaseTrait for VisualUnlockAsset {
    fn unlock_user_data(&self) -> &Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data()
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data_mut()
    }
    fn debug_unlock_id(&self) -> &String {
        self._glacier_base.debug_unlock_id()
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        self._glacier_base.debug_unlock_id_mut()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        self._glacier_base.identifier_mut()
    }
    fn unlock_score(&self) -> &u32 {
        self._glacier_base.unlock_score()
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        self._glacier_base.unlock_score_mut()
    }
    fn auto_available(&self) -> &bool {
        self._glacier_base.auto_available()
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_available_mut()
    }
    fn next_level_unlock_asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset()
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset_mut()
    }
    fn hidden_in_progression(&self) -> &bool {
        self._glacier_base.hidden_in_progression()
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        self._glacier_base.hidden_in_progression_mut()
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        self._glacier_base.available_for_player()
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        self._glacier_base.available_for_player_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for VisualUnlockAsset {
}

impl super::core::AssetTrait for VisualUnlockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VisualUnlockAsset {
}

pub static VISUALUNLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualUnlockAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OutObjectBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(VisualUnlockAsset, out_object_blueprint),
            },
            FieldInfoData {
                name: "ThirdPersonBundles",
                flags: MemberInfoFlags::new(144),
                field_type: "BlueprintBundleReference-Array",
                rust_offset: offset_of!(VisualUnlockAsset, third_person_bundles),
            },
            FieldInfoData {
                name: "FirstPersonBundles",
                flags: MemberInfoFlags::new(144),
                field_type: "BlueprintBundleReference-Array",
                rust_offset: offset_of!(VisualUnlockAsset, first_person_bundles),
            },
            FieldInfoData {
                name: "RenderIn1p",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisualUnlockAsset, render_in1p),
            },
            FieldInfoData {
                name: "DisableRender1pInForeground",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisualUnlockAsset, disable_render1p_in_foreground),
            },
            FieldInfoData {
                name: "EntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VisualUnlockAsset, entry_index),
            },
            FieldInfoData {
                name: "OnDemandLoaded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisualUnlockAsset, on_demand_loaded),
            },
            FieldInfoData {
                name: "FacePoserLibrary",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VisualUnlockAsset, face_poser_library),
            },
            FieldInfoData {
                name: "MorphDofSet",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VisualUnlockAsset, morph_dof_set),
            },
            FieldInfoData {
                name: "MorphTextureBlendDofSet",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(VisualUnlockAsset, morph_texture_blend_dof_set),
            },
            FieldInfoData {
                name: "VisualAntGameStates",
                flags: MemberInfoFlags::new(144),
                field_type: "WriteAntGameStateData-Array",
                rust_offset: offset_of!(VisualUnlockAsset, visual_ant_game_states),
            },
            FieldInfoData {
                name: "RigScale",
                flags: MemberInfoFlags::new(0),
                field_type: "WriteFloatGameState",
                rust_offset: offset_of!(VisualUnlockAsset, rig_scale),
            },
            FieldInfoData {
                name: "VisualUnlockAssets",
                flags: MemberInfoFlags::new(144),
                field_type: "VisualUnlockAsset-Array",
                rust_offset: offset_of!(VisualUnlockAsset, visual_unlock_assets),
            },
        ],
    }),
    array_type: Some(VISUALUNLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VisualUnlockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALUNLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALUNLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VisualUnlockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisualUnlockBlueprintBundle {
    pub _glacier_base: super::gameplay_sim::BlueprintBundle,
}

pub trait VisualUnlockBlueprintBundleTrait: super::gameplay_sim::BlueprintBundleTrait {
}

impl VisualUnlockBlueprintBundleTrait for VisualUnlockBlueprintBundle {
}

impl super::gameplay_sim::BlueprintBundleTrait for VisualUnlockBlueprintBundle {
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint_mut()
    }
}

impl super::entity::SharedBundleBaseAssetTrait for VisualUnlockBlueprintBundle {
}

impl super::core::AssetTrait for VisualUnlockBlueprintBundle {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VisualUnlockBlueprintBundle {
}

pub static VISUALUNLOCKBLUEPRINTBUNDLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBlueprintBundle",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::BLUEPRINTBUNDLE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualUnlockBlueprintBundle as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VISUALUNLOCKBLUEPRINTBUNDLE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VisualUnlockBlueprintBundle {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALUNLOCKBLUEPRINTBUNDLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALUNLOCKBLUEPRINTBUNDLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBlueprintBundle-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VisualUnlockBlueprintBundle"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisualUnlockBundleAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub bundle_mode: VisualUnlockBundleMode,
}

pub trait VisualUnlockBundleAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn bundle_mode(&self) -> &VisualUnlockBundleMode;
    fn bundle_mode_mut(&mut self) -> &mut VisualUnlockBundleMode;
}

impl VisualUnlockBundleAssetTrait for VisualUnlockBundleAsset {
    fn bundle_mode(&self) -> &VisualUnlockBundleMode {
        &self.bundle_mode
    }
    fn bundle_mode_mut(&mut self) -> &mut VisualUnlockBundleMode {
        &mut self.bundle_mode
    }
}

impl super::core::DataContainerPolicyAssetTrait for VisualUnlockBundleAsset {
}

impl super::core::AssetTrait for VisualUnlockBundleAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VisualUnlockBundleAsset {
}

pub static VISUALUNLOCKBUNDLEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBundleAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisualUnlockBundleAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BundleMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VisualUnlockBundleMode",
                rust_offset: offset_of!(VisualUnlockBundleAsset, bundle_mode),
            },
        ],
    }),
    array_type: Some(VISUALUNLOCKBUNDLEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VisualUnlockBundleAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALUNLOCKBUNDLEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISUALUNLOCKBUNDLEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBundleAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VisualUnlockBundleAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VisualUnlockBundleMode {
    #[default]
    BundleMode_Both1pAnd3p = 0,
    BundleMode_Only1p = 1,
}

pub static VISUALUNLOCKBUNDLEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBundleMode",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(VISUALUNLOCKBUNDLEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VisualUnlockBundleMode {
    fn type_info(&self) -> &'static TypeInfo {
        VISUALUNLOCKBUNDLEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VISUALUNLOCKBUNDLEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisualUnlockBundleMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VisualUnlockBundleMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultiUnlockAsset {
    pub _glacier_base: UnlockAssetBase,
    pub unlocks: Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>>,
}

pub trait MultiUnlockAssetTrait: UnlockAssetBaseTrait {
    fn unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>>;
    fn unlocks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>>;
}

impl MultiUnlockAssetTrait for MultiUnlockAsset {
    fn unlocks(&self) -> &Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>> {
        &self.unlocks
    }
    fn unlocks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>> {
        &mut self.unlocks
    }
}

impl UnlockAssetBaseTrait for MultiUnlockAsset {
    fn unlock_user_data(&self) -> &Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data()
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data_mut()
    }
    fn debug_unlock_id(&self) -> &String {
        self._glacier_base.debug_unlock_id()
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        self._glacier_base.debug_unlock_id_mut()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        self._glacier_base.identifier_mut()
    }
    fn unlock_score(&self) -> &u32 {
        self._glacier_base.unlock_score()
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        self._glacier_base.unlock_score_mut()
    }
    fn auto_available(&self) -> &bool {
        self._glacier_base.auto_available()
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_available_mut()
    }
    fn next_level_unlock_asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset()
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset_mut()
    }
    fn hidden_in_progression(&self) -> &bool {
        self._glacier_base.hidden_in_progression()
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        self._glacier_base.hidden_in_progression_mut()
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        self._glacier_base.available_for_player()
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        self._glacier_base.available_for_player_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for MultiUnlockAsset {
}

impl super::core::AssetTrait for MultiUnlockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MultiUnlockAsset {
}

pub static MULTIUNLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiUnlockAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKASSETBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultiUnlockAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Unlocks",
                flags: MemberInfoFlags::new(144),
                field_type: "UnlockAssetBase-Array",
                rust_offset: offset_of!(MultiUnlockAsset, unlocks),
            },
        ],
    }),
    array_type: Some(MULTIUNLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultiUnlockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MULTIUNLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTIUNLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiUnlockAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MultiUnlockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockAsset {
    pub _glacier_base: UnlockAssetBase,
}

pub trait UnlockAssetTrait: UnlockAssetBaseTrait {
}

impl UnlockAssetTrait for UnlockAsset {
}

impl UnlockAssetBaseTrait for UnlockAsset {
    fn unlock_user_data(&self) -> &Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data()
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        self._glacier_base.unlock_user_data_mut()
    }
    fn debug_unlock_id(&self) -> &String {
        self._glacier_base.debug_unlock_id()
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        self._glacier_base.debug_unlock_id_mut()
    }
    fn identifier(&self) -> &u32 {
        self._glacier_base.identifier()
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        self._glacier_base.identifier_mut()
    }
    fn unlock_score(&self) -> &u32 {
        self._glacier_base.unlock_score()
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        self._glacier_base.unlock_score_mut()
    }
    fn auto_available(&self) -> &bool {
        self._glacier_base.auto_available()
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_available_mut()
    }
    fn next_level_unlock_asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset()
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        self._glacier_base.next_level_unlock_asset_mut()
    }
    fn hidden_in_progression(&self) -> &bool {
        self._glacier_base.hidden_in_progression()
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        self._glacier_base.hidden_in_progression_mut()
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        self._glacier_base.available_for_player()
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        self._glacier_base.available_for_player_mut()
    }
}

impl super::core::DataContainerPolicyAssetTrait for UnlockAsset {
}

impl super::core::AssetTrait for UnlockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UnlockAsset {
}

pub static UNLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(UNLOCKASSETBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(UNLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeshAndVariationPair {
    pub _glacier_base: super::entity::ObjectBlueprint,
    pub mesh_asset: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub variation: Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>>,
}

pub trait MeshAndVariationPairTrait: super::entity::ObjectBlueprintTrait {
    fn mesh_asset(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>>;
    fn variation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>>;
}

impl MeshAndVariationPairTrait for MeshAndVariationPair {
    fn mesh_asset(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh_asset
    }
    fn mesh_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh_asset
    }
    fn variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        &self.variation
    }
    fn variation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        &mut self.variation
    }
}

impl super::entity::ObjectBlueprintTrait for MeshAndVariationPair {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for MeshAndVariationPair {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for MeshAndVariationPair {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for MeshAndVariationPair {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for MeshAndVariationPair {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MeshAndVariationPair {
}

pub static MESHANDVARIATIONPAIR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshAndVariationPair",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeshAndVariationPair as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MeshAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(MeshAndVariationPair, mesh_asset),
            },
            FieldInfoData {
                name: "Variation",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectVariation",
                rust_offset: offset_of!(MeshAndVariationPair, variation),
            },
        ],
    }),
    array_type: Some(MESHANDVARIATIONPAIR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeshAndVariationPair {
    fn type_info(&self) -> &'static TypeInfo {
        MESHANDVARIATIONPAIR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MESHANDVARIATIONPAIR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeshAndVariationPair-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MeshAndVariationPair"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockAssetBase {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub unlock_user_data: Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>>,
    pub debug_unlock_id: String,
    pub identifier: u32,
    pub unlock_score: u32,
    pub auto_available: bool,
    pub next_level_unlock_asset: Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>,
    pub hidden_in_progression: bool,
    pub available_for_player: UnlockAvailability,
}

pub trait UnlockAssetBaseTrait: super::core::DataContainerPolicyAssetTrait {
    fn unlock_user_data(&self) -> &Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>>;
    fn unlock_user_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>>;
    fn debug_unlock_id(&self) -> &String;
    fn debug_unlock_id_mut(&mut self) -> &mut String;
    fn identifier(&self) -> &u32;
    fn identifier_mut(&mut self) -> &mut u32;
    fn unlock_score(&self) -> &u32;
    fn unlock_score_mut(&mut self) -> &mut u32;
    fn auto_available(&self) -> &bool;
    fn auto_available_mut(&mut self) -> &mut bool;
    fn next_level_unlock_asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
    fn hidden_in_progression(&self) -> &bool;
    fn hidden_in_progression_mut(&mut self) -> &mut bool;
    fn available_for_player(&self) -> &UnlockAvailability;
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability;
}

impl UnlockAssetBaseTrait for UnlockAssetBase {
    fn unlock_user_data(&self) -> &Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        &self.unlock_user_data
    }
    fn unlock_user_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockUserDataBaseTrait>>> {
        &mut self.unlock_user_data
    }
    fn debug_unlock_id(&self) -> &String {
        &self.debug_unlock_id
    }
    fn debug_unlock_id_mut(&mut self) -> &mut String {
        &mut self.debug_unlock_id
    }
    fn identifier(&self) -> &u32 {
        &self.identifier
    }
    fn identifier_mut(&mut self) -> &mut u32 {
        &mut self.identifier
    }
    fn unlock_score(&self) -> &u32 {
        &self.unlock_score
    }
    fn unlock_score_mut(&mut self) -> &mut u32 {
        &mut self.unlock_score
    }
    fn auto_available(&self) -> &bool {
        &self.auto_available
    }
    fn auto_available_mut(&mut self) -> &mut bool {
        &mut self.auto_available
    }
    fn next_level_unlock_asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &self.next_level_unlock_asset
    }
    fn next_level_unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &mut self.next_level_unlock_asset
    }
    fn hidden_in_progression(&self) -> &bool {
        &self.hidden_in_progression
    }
    fn hidden_in_progression_mut(&mut self) -> &mut bool {
        &mut self.hidden_in_progression
    }
    fn available_for_player(&self) -> &UnlockAvailability {
        &self.available_for_player
    }
    fn available_for_player_mut(&mut self) -> &mut UnlockAvailability {
        &mut self.available_for_player
    }
}

impl super::core::DataContainerPolicyAssetTrait for UnlockAssetBase {
}

impl super::core::AssetTrait for UnlockAssetBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UnlockAssetBase {
}

pub static UNLOCKASSETBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAssetBase",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockAssetBase as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockUserData",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockUserDataBase",
                rust_offset: offset_of!(UnlockAssetBase, unlock_user_data),
            },
            FieldInfoData {
                name: "DebugUnlockId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(UnlockAssetBase, debug_unlock_id),
            },
            FieldInfoData {
                name: "Identifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UnlockAssetBase, identifier),
            },
            FieldInfoData {
                name: "UnlockScore",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UnlockAssetBase, unlock_score),
            },
            FieldInfoData {
                name: "AutoAvailable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockAssetBase, auto_available),
            },
            FieldInfoData {
                name: "NextLevelUnlockAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(UnlockAssetBase, next_level_unlock_asset),
            },
            FieldInfoData {
                name: "HiddenInProgression",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockAssetBase, hidden_in_progression),
            },
            FieldInfoData {
                name: "AvailableForPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAvailability",
                rust_offset: offset_of!(UnlockAssetBase, available_for_player),
            },
        ],
    }),
    array_type: Some(UNLOCKASSETBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockAssetBase {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKASSETBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKASSETBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAssetBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockAssetBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UnlockAvailability {
    #[default]
    UnlockAvailability_All = 0,
    UnlockAvailability_HumanPlayerOnly = 1,
    UnlockAvailability_AIOnly = 2,
}

pub static UNLOCKAVAILABILITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAvailability",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UNLOCKAVAILABILITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UnlockAvailability {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKAVAILABILITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UNLOCKAVAILABILITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockAvailability-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockAvailability"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockUserDataBase {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
}

pub trait UnlockUserDataBaseTrait: super::core::DataContainerPolicyAssetTrait {
}

impl UnlockUserDataBaseTrait for UnlockUserDataBase {
}

impl super::core::DataContainerPolicyAssetTrait for UnlockUserDataBase {
}

impl super::core::AssetTrait for UnlockUserDataBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UnlockUserDataBase {
}

pub static UNLOCKUSERDATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockUserDataBase",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockUserDataBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(UNLOCKUSERDATABASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UnlockUserDataBase {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKUSERDATABASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKUSERDATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockUserDataBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockUserDataBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnlockComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub unlock_asset: Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>,
    pub unlock_asset_guid: glacier_util::guid::Guid,
    pub unlock_identifier: u32,
    pub invert_unlock_test: bool,
    pub unlockable_from_all_entries: bool,
    pub evaluate_once: bool,
    pub unlock_on_spawn: UnlockSpawnType,
    pub deactivate_check_on_entering_entry: bool,
}

pub trait UnlockComponentDataTrait: super::entity::GameComponentDataTrait {
    fn unlock_asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
    fn unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>>;
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid;
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn unlock_identifier(&self) -> &u32;
    fn unlock_identifier_mut(&mut self) -> &mut u32;
    fn invert_unlock_test(&self) -> &bool;
    fn invert_unlock_test_mut(&mut self) -> &mut bool;
    fn unlockable_from_all_entries(&self) -> &bool;
    fn unlockable_from_all_entries_mut(&mut self) -> &mut bool;
    fn evaluate_once(&self) -> &bool;
    fn evaluate_once_mut(&mut self) -> &mut bool;
    fn unlock_on_spawn(&self) -> &UnlockSpawnType;
    fn unlock_on_spawn_mut(&mut self) -> &mut UnlockSpawnType;
    fn deactivate_check_on_entering_entry(&self) -> &bool;
    fn deactivate_check_on_entering_entry_mut(&mut self) -> &mut bool;
}

impl UnlockComponentDataTrait for UnlockComponentData {
    fn unlock_asset(&self) -> &Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &self.unlock_asset
    }
    fn unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn UnlockAssetBaseTrait>>> {
        &mut self.unlock_asset
    }
    fn unlock_asset_guid(&self) -> &glacier_util::guid::Guid {
        &self.unlock_asset_guid
    }
    fn unlock_asset_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.unlock_asset_guid
    }
    fn unlock_identifier(&self) -> &u32 {
        &self.unlock_identifier
    }
    fn unlock_identifier_mut(&mut self) -> &mut u32 {
        &mut self.unlock_identifier
    }
    fn invert_unlock_test(&self) -> &bool {
        &self.invert_unlock_test
    }
    fn invert_unlock_test_mut(&mut self) -> &mut bool {
        &mut self.invert_unlock_test
    }
    fn unlockable_from_all_entries(&self) -> &bool {
        &self.unlockable_from_all_entries
    }
    fn unlockable_from_all_entries_mut(&mut self) -> &mut bool {
        &mut self.unlockable_from_all_entries
    }
    fn evaluate_once(&self) -> &bool {
        &self.evaluate_once
    }
    fn evaluate_once_mut(&mut self) -> &mut bool {
        &mut self.evaluate_once
    }
    fn unlock_on_spawn(&self) -> &UnlockSpawnType {
        &self.unlock_on_spawn
    }
    fn unlock_on_spawn_mut(&mut self) -> &mut UnlockSpawnType {
        &mut self.unlock_on_spawn
    }
    fn deactivate_check_on_entering_entry(&self) -> &bool {
        &self.deactivate_check_on_entering_entry
    }
    fn deactivate_check_on_entering_entry_mut(&mut self) -> &mut bool {
        &mut self.deactivate_check_on_entering_entry
    }
}

impl super::entity::GameComponentDataTrait for UnlockComponentData {
}

impl super::entity::ComponentDataTrait for UnlockComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for UnlockComponentData {
}

impl super::core::DataBusPeerTrait for UnlockComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for UnlockComponentData {
}

impl super::core::DataContainerTrait for UnlockComponentData {
}

pub static UNLOCKCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnlockComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnlockAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockAssetBase",
                rust_offset: offset_of!(UnlockComponentData, unlock_asset),
            },
            FieldInfoData {
                name: "UnlockAssetGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(UnlockComponentData, unlock_asset_guid),
            },
            FieldInfoData {
                name: "UnlockIdentifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(UnlockComponentData, unlock_identifier),
            },
            FieldInfoData {
                name: "InvertUnlockTest",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockComponentData, invert_unlock_test),
            },
            FieldInfoData {
                name: "UnlockableFromAllEntries",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockComponentData, unlockable_from_all_entries),
            },
            FieldInfoData {
                name: "EvaluateOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockComponentData, evaluate_once),
            },
            FieldInfoData {
                name: "UnlockOnSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "UnlockSpawnType",
                rust_offset: offset_of!(UnlockComponentData, unlock_on_spawn),
            },
            FieldInfoData {
                name: "DeactivateCheckOnEnteringEntry",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnlockComponentData, deactivate_check_on_entering_entry),
            },
        ],
    }),
    array_type: Some(UNLOCKCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for UnlockComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNLOCKCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UnlockSpawnType {
    #[default]
    SpawnLock_Ignore = 0,
    SpawnLock_Locked = 1,
    SpawnLock_Unlocked = 2,
}

pub static UNLOCKSPAWNTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockSpawnType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UNLOCKSPAWNTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UnlockSpawnType {
    fn type_info(&self) -> &'static TypeInfo {
        UNLOCKSPAWNTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UNLOCKSPAWNTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnlockSpawnType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnlockSpawnType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UIMessageType {
    #[default]
    UIMessageType_Text = 0,
    UIMessageType_EnemyTank = 1,
    UIMessageType_EnemyCar = 2,
    UIMessageType_EnemyBoat = 3,
    UIMessageType_EnemyHelicopter = 4,
    UIMessageType_EnemyInfantry = 5,
    UIMessageType_EnemyActivity = 6,
    UIMessageType_EnemyC4 = 7,
    UIMessageType_EnemyATMine = 8,
    UIMessageType_ChatGo = 9,
    UIMessageType_ChatFollowMe = 10,
    UIMessageType_ChatNeedBackup = 11,
    UIMessageType_ChatNeedPickup = 12,
    UIMessageType_ChatNeedAmmo = 13,
    UIMessageType_ChatNeedMedic = 14,
    UIMessageType_ChatYes = 15,
    UIMessageType_ChatNo = 16,
    UIMessageType_ChatThanks = 17,
    UIMessageType_ChatSorry = 18,
    UIMessageType_ChatNeedRepair = 19,
    UIMessageType_ChatGetIn = 20,
    UIMessageType_ChatGetOut = 21,
    UIMessageType_ChatDropMeOff = 22,
    UIMessageType_OrderDefendBase = 23,
    UIMessageType_OrderAttackBase = 24,
    UIMessageType_OrderMoveToPos = 25,
    UIMessageType_JoinedSquad = 26,
    UIMessageType_LeftSquad = 27,
    UIMessageType_RequestSquad = 28,
    UIMessageType_InviteSquad = 29,
    UIMessageType_KickSquad = 30,
    UIMessageType_LeaderPromoted = 31,
    UIMessageType_Connected = 32,
    UIMessageType_Disconnected = 33,
    UIMessageType_Killed = 34,
    UIMessageType_Died = 35,
}

pub static UIMESSAGETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIMessageType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UIMESSAGETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UIMessageType {
    fn type_info(&self) -> &'static TypeInfo {
        UIMESSAGETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UIMESSAGETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIMessageType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIMessageType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LightDimmerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub distance_to_fade: f32,
    pub distance_to_cull: f32,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait LightDimmerEntityDataTrait: super::entity::EntityDataTrait {
    fn distance_to_fade(&self) -> &f32;
    fn distance_to_fade_mut(&mut self) -> &mut f32;
    fn distance_to_cull(&self) -> &f32;
    fn distance_to_cull_mut(&mut self) -> &mut f32;
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl LightDimmerEntityDataTrait for LightDimmerEntityData {
    fn distance_to_fade(&self) -> &f32 {
        &self.distance_to_fade
    }
    fn distance_to_fade_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_fade
    }
    fn distance_to_cull(&self) -> &f32 {
        &self.distance_to_cull
    }
    fn distance_to_cull_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_cull
    }
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for LightDimmerEntityData {
}

impl super::entity::GameObjectDataTrait for LightDimmerEntityData {
}

impl super::core::DataBusPeerTrait for LightDimmerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LightDimmerEntityData {
}

impl super::core::DataContainerTrait for LightDimmerEntityData {
}

pub static LIGHTDIMMERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightDimmerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LightDimmerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DistanceToFade",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LightDimmerEntityData, distance_to_fade),
            },
            FieldInfoData {
                name: "DistanceToCull",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LightDimmerEntityData, distance_to_cull),
            },
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(LightDimmerEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(LIGHTDIMMERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LightDimmerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LIGHTDIMMERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LIGHTDIMMERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LightDimmerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LightDimmerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct KinectServiceData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait KinectServiceDataTrait: super::entity::EntityDataTrait {
}

impl KinectServiceDataTrait for KinectServiceData {
}

impl super::entity::EntityDataTrait for KinectServiceData {
}

impl super::entity::GameObjectDataTrait for KinectServiceData {
}

impl super::core::DataBusPeerTrait for KinectServiceData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for KinectServiceData {
}

impl super::core::DataContainerTrait for KinectServiceData {
}

pub static KINECTSERVICEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KinectServiceData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<KinectServiceData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(KINECTSERVICEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for KinectServiceData {
    fn type_info(&self) -> &'static TypeInfo {
        KINECTSERVICEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static KINECTSERVICEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KinectServiceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("KinectServiceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UIWorldIconBehavior {
    pub _glacier_base: super::core::Asset,
}

pub trait UIWorldIconBehaviorTrait: super::core::AssetTrait {
}

impl UIWorldIconBehaviorTrait for UIWorldIconBehavior {
}

impl super::core::AssetTrait for UIWorldIconBehavior {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UIWorldIconBehavior {
}

pub static UIWORLDICONBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIWorldIconBehavior",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIWorldIconBehavior as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(UIWORLDICONBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UIWorldIconBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        UIWORLDICONBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UIWORLDICONBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIWorldIconBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIWorldIconBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UICombatAreaAsset {
    pub _glacier_base: super::core::Asset,
    pub prefix: String,
}

pub trait UICombatAreaAssetTrait: super::core::AssetTrait {
    fn prefix(&self) -> &String;
    fn prefix_mut(&mut self) -> &mut String;
}

impl UICombatAreaAssetTrait for UICombatAreaAsset {
    fn prefix(&self) -> &String {
        &self.prefix
    }
    fn prefix_mut(&mut self) -> &mut String {
        &mut self.prefix
    }
}

impl super::core::AssetTrait for UICombatAreaAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for UICombatAreaAsset {
}

pub static UICOMBATAREAASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UICombatAreaAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UICombatAreaAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Prefix",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(UICombatAreaAsset, prefix),
            },
        ],
    }),
    array_type: Some(UICOMBATAREAASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UICombatAreaAsset {
    fn type_info(&self) -> &'static TypeInfo {
        UICOMBATAREAASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UICOMBATAREAASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UICombatAreaAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UICombatAreaAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SpottingType {
    #[default]
    STGunner = 0,
    STSquadLeader = 1,
    STDefault = 2,
    STPersonal = 3,
    STSnapshot = 4,
    STSquadUav = 5,
    STTypesCount = 6,
}

pub static SPOTTINGTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpottingType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(SPOTTINGTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SpottingType {
    fn type_info(&self) -> &'static TypeInfo {
        SPOTTINGTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SPOTTINGTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpottingType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SpottingType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UIPartData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait UIPartDataTrait: super::core::DataContainerTrait {
}

impl UIPartDataTrait for UIPartData {
}

impl super::core::DataContainerTrait for UIPartData {
}

pub static UIPARTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIPartData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(UIPARTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UIPartData {
    fn type_info(&self) -> &'static TypeInfo {
        UIPARTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UIPARTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIPartData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LockingTypeAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait LockingTypeAssetTrait: super::core::AssetTrait {
}

impl LockingTypeAssetTrait for LockingTypeAsset {
}

impl super::core::AssetTrait for LockingTypeAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for LockingTypeAsset {
}

pub static LOCKINGTYPEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LockingTypeAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LockingTypeAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCKINGTYPEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LockingTypeAsset {
    fn type_info(&self) -> &'static TypeInfo {
        LOCKINGTYPEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCKINGTYPEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LockingTypeAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LockingTypeAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CrosshairTypeAsset {
    pub _glacier_base: super::core::Asset,
}

pub trait CrosshairTypeAssetTrait: super::core::AssetTrait {
}

impl CrosshairTypeAssetTrait for CrosshairTypeAsset {
}

impl super::core::AssetTrait for CrosshairTypeAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CrosshairTypeAsset {
}

pub static CROSSHAIRTYPEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CrosshairTypeAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CrosshairTypeAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(CROSSHAIRTYPEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CrosshairTypeAsset {
    fn type_info(&self) -> &'static TypeInfo {
        CROSSHAIRTYPEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CROSSHAIRTYPEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CrosshairTypeAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CrosshairTypeAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UIPartPropertyList {
    pub _glacier_base: super::core::DataContainer,
    pub hud_property_list: Vec<UIPartProperties>,
}

pub trait UIPartPropertyListTrait: super::core::DataContainerTrait {
    fn hud_property_list(&self) -> &Vec<UIPartProperties>;
    fn hud_property_list_mut(&mut self) -> &mut Vec<UIPartProperties>;
}

impl UIPartPropertyListTrait for UIPartPropertyList {
    fn hud_property_list(&self) -> &Vec<UIPartProperties> {
        &self.hud_property_list
    }
    fn hud_property_list_mut(&mut self) -> &mut Vec<UIPartProperties> {
        &mut self.hud_property_list
    }
}

impl super::core::DataContainerTrait for UIPartPropertyList {
}

pub static UIPARTPROPERTYLIST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartPropertyList",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIPartPropertyList as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HudPropertyList",
                flags: MemberInfoFlags::new(144),
                field_type: "UIPartProperties-Array",
                rust_offset: offset_of!(UIPartPropertyList, hud_property_list),
            },
        ],
    }),
    array_type: Some(UIPARTPROPERTYLIST_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UIPartPropertyList {
    fn type_info(&self) -> &'static TypeInfo {
        UIPARTPROPERTYLIST_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UIPARTPROPERTYLIST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartPropertyList-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIPartPropertyList"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UIPartProperties {
    pub identifier: UIPartIdentifier,
    pub range: f32,
    pub frequency: f32,
    pub compensate_freelook: bool,
}

pub trait UIPartPropertiesTrait: TypeObject {
    fn identifier(&self) -> &UIPartIdentifier;
    fn identifier_mut(&mut self) -> &mut UIPartIdentifier;
    fn range(&self) -> &f32;
    fn range_mut(&mut self) -> &mut f32;
    fn frequency(&self) -> &f32;
    fn frequency_mut(&mut self) -> &mut f32;
    fn compensate_freelook(&self) -> &bool;
    fn compensate_freelook_mut(&mut self) -> &mut bool;
}

impl UIPartPropertiesTrait for UIPartProperties {
    fn identifier(&self) -> &UIPartIdentifier {
        &self.identifier
    }
    fn identifier_mut(&mut self) -> &mut UIPartIdentifier {
        &mut self.identifier
    }
    fn range(&self) -> &f32 {
        &self.range
    }
    fn range_mut(&mut self) -> &mut f32 {
        &mut self.range
    }
    fn frequency(&self) -> &f32 {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut f32 {
        &mut self.frequency
    }
    fn compensate_freelook(&self) -> &bool {
        &self.compensate_freelook
    }
    fn compensate_freelook_mut(&mut self) -> &mut bool {
        &mut self.compensate_freelook
    }
}

pub static UIPARTPROPERTIES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartProperties",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UIPartProperties as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Identifier",
                flags: MemberInfoFlags::new(0),
                field_type: "UIPartIdentifier",
                rust_offset: offset_of!(UIPartProperties, identifier),
            },
            FieldInfoData {
                name: "Range",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(UIPartProperties, range),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(UIPartProperties, frequency),
            },
            FieldInfoData {
                name: "CompensateFreelook",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UIPartProperties, compensate_freelook),
            },
        ],
    }),
    array_type: Some(UIPARTPROPERTIES_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for UIPartProperties {
    fn type_info(&self) -> &'static TypeInfo {
        UIPARTPROPERTIES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UIPARTPROPERTIES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartProperties-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIPartProperties"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UIHudIcon {
    #[default]
    UIHudIcon_Unused = 0,
    UIHudIcon_LocalPlayer = 1,
    UIHudIcon_LocalDirection = 2,
    UIHudIcon_FriendlyPlayer = 3,
    UIHudIcon_EnemyPlayer = 4,
    UIHudIcon_NeutralPlayer = 5,
    UIHudIcon_SquadMember = 6,
    UIHudIcon_SquadLeader = 7,
    UIHudIcon_SquadLeaderTargeted = 8,
    UIHudIcon_Vehicle = 9,
    UIHudIcon_PrimaryObjective = 10,
    UIHudIcon_PrimaryObjectiveBlink = 11,
    UIHudIcon_SecondaryObjective = 12,
    UIHudIcon_AreaMapMarker = 13,
    UIHudIcon_ObjectiveDestroy = 14,
    UIHudIcon_ObjectiveScout = 15,
    UIHudIcon_ObjectiveDefend = 16,
    UIHudIcon_ObjectiveMoveTo = 17,
    UIHudIcon_ObjectiveAttack = 18,
    UIHudIcon_ObjectiveFollow = 19,
    UIHudIcon_ObjectiveGeneral = 20,
    UIHudICon_UAV = 21,
    UIHudIcon_AmmoCrate = 22,
    UIHudIcon_MedicBag = 23,
    UIHudIcon_C4 = 24,
    UIHudIcon_ATMine = 25,
    UIHudIcon_StationaryWeapon = 26,
    UIHudIcon_North = 27,
    UIHudIcon_South = 28,
    UIHudIcon_West = 29,
    UIHudIcon_East = 30,
    UIHudIcon_NeutralFlag = 31,
    UIHudIcon_FriendlyFlag = 32,
    UIHudIcon_EnemyFlag = 33,
    UIHudIcon_FriendlyBase = 34,
    UIHudIcon_EnemyBase = 35,
    UIHudIcon_Team1Flag = 36,
    UIHudIcon_Team2Flag = 37,
    UIHudIcon_NeutralFlagLit = 38,
    UIHudIcon_FriendlyFlagLit = 39,
    UIHudIcon_EnemyFlagLit = 40,
    UIHudIcon_SelectableSpawnPoint = 41,
    UIHudIcon_SelectedSpawnPoint = 42,
    UIHudIcon_NonSelectableSpawnPoint = 43,
    UIHudIcon_FriendlyFlagUnderAttack = 44,
    UIHudIcon_EnemyFlagUnderAttack = 45,
    UIHudIcon_OrderAttack = 46,
    UIHudIcon_OrderDefend = 47,
    UIHudIcon_OrderAttackObserved = 48,
    UIHudIcon_OrderDefendObserved = 49,
    UIHudIcon_Boat = 50,
    UIHudIcon_Car = 51,
    UIHudIcon_Jeep = 52,
    UIHudIcon_HeliAttack = 53,
    UIHudIcon_HeliScout = 54,
    UIHudIcon_Tank = 55,
    UIHudIcon_TankIFV = 56,
    UIHudIcon_TankArty = 57,
    UIHudIcon_TankAA = 58,
    UIHudIcon_TankAT = 59,
    UIHudIcon_Jet = 60,
    UIHudIcon_JetBomber = 61,
    UIHudIcon_Stationary = 62,
    UIHudIcon_Strategic = 63,
    UIHudIcon_MotionRadarSweep = 64,
    UIHudIcon_NeedBackup = 65,
    UIHudIcon_NeedAmmo = 66,
    UIHudIcon_NeedMedic = 67,
    UIHudIcon_NeedPickup = 68,
    UIHudIcon_NeedRepair = 69,
    UIHudIcon_KitAssault = 70,
    UIHudIcon_KitDemolition = 71,
    UIHudIcon_KitRecon = 72,
    UIHudIcon_KitSpecialist = 73,
    UIHudIcon_KitSupport = 74,
    UIHudIcon_KitMedic = 75,
    UIHudIcon_KitEngineer = 76,
    UIHudIcon_KitPickupAssault = 77,
    UIHudIcon_KitPickupDemolition = 78,
    UIHudIcon_KitPickupRecon = 79,
    UIHudIcon_KitPickupSpecialist = 80,
    UIHudIcon_KitPickupSupport = 81,
    UIHudIcon_KitPickupMedic = 82,
    UIHudIcon_KitPickupEngineer = 83,
    UIHudIcon_Pickup = 84,
    UIHudIcon_TaggedVehicle = 85,
    UIHudIcon_LaserPaintedVehicle = 86,
    UIHudIcon_HeliTargetEnemy = 87,
    UIHudIcon_HeliTargetFriendly = 88,
    UIHudIcon_ArtilleryTarget = 89,
    UIHudIcon_NeutralFlagAttacker = 90,
    UIHudIcon_FriendlyFlagAttacker = 91,
    UIHudIcon_EnemyFlagAttacker = 92,
    UIHudIcon_LaserTarget = 93,
    UIHudIcon_ObjectiveAttacker = 94,
    UIHudIcon_ObjectiveDefender = 95,
    UIHudIcon_HealthbarBackground = 96,
    UIHudIcon_Healthbar = 97,
    UIHudIcon_RadarSweepComponent = 98,
    UIHudIcon_Blank = 99,
    UIHudIcon_LocalPlayerBigIcon = 100,
    UIHudIcon_LocalPlayerOutOfMap = 101,
    UIHudIcon_PrimaryObjectiveLarge = 102,
    UIHudIcon_TargetUnlocked = 103,
    UIHudIcon_TargetLocked = 104,
    UIHudIcon_TargetLocking = 105,
    UIHudIcon_ArtilleryStrikeNametag = 106,
    UIHudIcon_ArtilleryStrikeMinimap = 107,
    UIHudIcon_CapturePointContested = 108,
    UIHudIcon_CapturePointDefended = 109,
    UIHudIcon_RoundBar = 110,
    UIHudIcon_RoundBarBg = 111,
    UIHudIcon_RoundBarBgPlate = 112,
    UIHudIcon_SnapOvalArrow = 113,
    UIHudIcon_SquadleaderBg = 114,
    UIHudIcon_VehicleBg = 115,
    UIHudIcon_NonTakeableControlPoint = 116,
    UIHudIcon_SpottedPosition = 117,
    UIHudIcon_Grenade = 118,
    UIHudIcon_Revive = 119,
    UIHudIcon_Repair = 120,
    UIHudIcon_Interact = 121,
    UIHudIcon_Voip = 122,
    UIHudIcon_Claymore = 123,
    UIHudIcon_EodBot = 124,
    UIHudIcon_Explosive = 125,
    UIHudIcon_LaserDesignator = 126,
    UIHudIcon_Mav = 127,
    UIHudIcon_Mortar = 128,
    UIHudIcon_RadioBeacon = 129,
    UIHudIcon_Ugs = 130,
    UIHudIcon_PercetageBarMiddle = 131,
    UIHudIcon_PercetageBarEdge = 132,
    UIHudIcon_PercentageBarBackground = 133,
    UIHudIcon_TankLC = 134,
    UIHudIcon_HeliTrans = 135,
    UIHudIcon_StaticAT = 136,
    UIHudIcon_StaticAA = 137,
    UIHudIcon_SprintBoost = 138,
    UIHudIcon_AmmoBoost = 139,
    UIHudIcon_ExplosiveBoost = 140,
    UIHudIcon_ExplosiveResistBoost = 141,
    UIHudIcon_SuppressionBoost = 142,
    UIHudIcon_SuppressionResistBoost = 143,
    UIHudIcon_GrenadeBoost = 144,
    UIHudIcon_HealSpeedBoost = 145,
    UIHudIcon_NeedAmmoHighlight = 146,
    UIHudIcon_NeedMedicHighlight = 147,
    UIHudIcon_NeedRepairHighlight = 148,
    UIHudIcon_NeedPickupHighlight = 149,
    UIHudIcon_PlayerDead = 150,
    UIHudIcon_Player = 151,
    UIHudIcon_Flag = 152,
    UIHudIcon_Base = 153,
    UIHudIcon_ObjectiveNeutralBomb = 154,
    UIHudIcon_ObjectiveFriendlyBomb = 155,
    UIHudIcon_ObjectiveEnemyBomb = 156,
    UIHudIcon_ObjectiveEnemyHVT = 157,
    UIHudIcon_ObjectiveFriendlyHVT = 158,
    UIHudIcon_Count = 159,
}

pub static UIHUDICON_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIHudIcon",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UIHUDICON_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UIHudIcon {
    fn type_info(&self) -> &'static TypeInfo {
        UIHUDICON_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UIHUDICON_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIHudIcon-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIHudIcon"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum UIPartIdentifier {
    #[default]
    HCI_None = 0,
    HCI_RangeMeter = 1,
    HCI_PredictedSight = 2,
    HCI_VelocityVector = 3,
    HCI_RadioAltitude = 4,
}

pub static UIPARTIDENTIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartIdentifier",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(UIPARTIDENTIFIER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for UIPartIdentifier {
    fn type_info(&self) -> &'static TypeInfo {
        UIPARTIDENTIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static UIPARTIDENTIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UIPartIdentifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UIPartIdentifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CollisionMethodEnum {
    #[default]
    CMESimple = 0,
    CMEDetailed = 1,
}

pub static COLLISIONMETHODENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionMethodEnum",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(COLLISIONMETHODENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CollisionMethodEnum {
    fn type_info(&self) -> &'static TypeInfo {
        COLLISIONMETHODENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COLLISIONMETHODENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionMethodEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CollisionMethodEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticModelGroupHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait StaticModelGroupHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl StaticModelGroupHealthComponentDataTrait for StaticModelGroupHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for StaticModelGroupHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for StaticModelGroupHealthComponentData {
}

impl super::entity::ComponentDataTrait for StaticModelGroupHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelGroupHealthComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelGroupHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelGroupHealthComponentData {
}

impl super::core::DataContainerTrait for StaticModelGroupHealthComponentData {
}

pub static STATICMODELGROUPHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelGroupHealthComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICMODELGROUPHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelGroupHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELGROUPHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELGROUPHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelGroupHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticModelGroupPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
}

pub trait StaticModelGroupPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
}

impl StaticModelGroupPhysicsComponentDataTrait for StaticModelGroupPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for StaticModelGroupPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for StaticModelGroupPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for StaticModelGroupPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelGroupPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelGroupPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelGroupPhysicsComponentData {
}

impl super::core::DataContainerTrait for StaticModelGroupPhysicsComponentData {
}

pub static STATICMODELGROUPPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelGroupPhysicsComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICMODELGROUPPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelGroupPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELGROUPPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELGROUPPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelGroupPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticModelGroupEntityData {
    pub _glacier_base: super::physics::GamePhysicsEntityData,
    pub member_datas: Vec<StaticModelGroupMemberData>,
    pub network_id_count: u32,
    pub hack_to_solve_real_time_tweaking_issue: glacier_util::guid::Guid,
}

pub trait StaticModelGroupEntityDataTrait: super::physics::GamePhysicsEntityDataTrait {
    fn member_datas(&self) -> &Vec<StaticModelGroupMemberData>;
    fn member_datas_mut(&mut self) -> &mut Vec<StaticModelGroupMemberData>;
    fn network_id_count(&self) -> &u32;
    fn network_id_count_mut(&mut self) -> &mut u32;
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid;
    fn hack_to_solve_real_time_tweaking_issue_mut(&mut self) -> &mut glacier_util::guid::Guid;
}

impl StaticModelGroupEntityDataTrait for StaticModelGroupEntityData {
    fn member_datas(&self) -> &Vec<StaticModelGroupMemberData> {
        &self.member_datas
    }
    fn member_datas_mut(&mut self) -> &mut Vec<StaticModelGroupMemberData> {
        &mut self.member_datas
    }
    fn network_id_count(&self) -> &u32 {
        &self.network_id_count
    }
    fn network_id_count_mut(&mut self) -> &mut u32 {
        &mut self.network_id_count
    }
    fn hack_to_solve_real_time_tweaking_issue(&self) -> &glacier_util::guid::Guid {
        &self.hack_to_solve_real_time_tweaking_issue
    }
    fn hack_to_solve_real_time_tweaking_issue_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.hack_to_solve_real_time_tweaking_issue
    }
}

impl super::physics::GamePhysicsEntityDataTrait for StaticModelGroupEntityData {
}

impl super::entity::GameComponentEntityDataTrait for StaticModelGroupEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for StaticModelGroupEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for StaticModelGroupEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for StaticModelGroupEntityData {
}

impl super::entity::GameObjectDataTrait for StaticModelGroupEntityData {
}

impl super::core::DataBusPeerTrait for StaticModelGroupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelGroupEntityData {
}

impl super::core::DataContainerTrait for StaticModelGroupEntityData {
}

pub static STATICMODELGROUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::GAMEPHYSICSENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelGroupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MemberDatas",
                flags: MemberInfoFlags::new(144),
                field_type: "StaticModelGroupMemberData-Array",
                rust_offset: offset_of!(StaticModelGroupEntityData, member_datas),
            },
            FieldInfoData {
                name: "NetworkIdCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupEntityData, network_id_count),
            },
            FieldInfoData {
                name: "HackToSolveRealTimeTweakingIssue",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(StaticModelGroupEntityData, hack_to_solve_real_time_tweaking_issue),
            },
        ],
    }),
    array_type: Some(STATICMODELGROUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelGroupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELGROUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELGROUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelGroupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticModelGroupMemberData {
    pub instance_transforms: Vec<super::core::LinearTransform>,
    pub instance_object_variation: Vec<u32>,
    pub instance_rendering_overrides: Vec<super::core::RenderingOverrides>,
    pub instance_radiosity_type_override: Vec<super::core::RadiosityTypeOverride>,
    pub instance_terrain_shader_nodes_enable: Vec<bool>,
    pub member_type: Option<Arc<Mutex<dyn super::physics::GamePhysicsEntityDataTrait>>>,
    pub mesh_asset: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub instance_count: u32,
    pub health_state_entity_manager_id: u32,
    pub physics_part_range: IndexRange,
    pub physics_part_count_per_instance: u32,
    pub network_id_range: IndexRange,
    pub network_id_count_per_instance: u32,
    pub part_component_count: u32,
}

pub trait StaticModelGroupMemberDataTrait: TypeObject {
    fn instance_transforms(&self) -> &Vec<super::core::LinearTransform>;
    fn instance_transforms_mut(&mut self) -> &mut Vec<super::core::LinearTransform>;
    fn instance_object_variation(&self) -> &Vec<u32>;
    fn instance_object_variation_mut(&mut self) -> &mut Vec<u32>;
    fn instance_rendering_overrides(&self) -> &Vec<super::core::RenderingOverrides>;
    fn instance_rendering_overrides_mut(&mut self) -> &mut Vec<super::core::RenderingOverrides>;
    fn instance_radiosity_type_override(&self) -> &Vec<super::core::RadiosityTypeOverride>;
    fn instance_radiosity_type_override_mut(&mut self) -> &mut Vec<super::core::RadiosityTypeOverride>;
    fn instance_terrain_shader_nodes_enable(&self) -> &Vec<bool>;
    fn instance_terrain_shader_nodes_enable_mut(&mut self) -> &mut Vec<bool>;
    fn member_type(&self) -> &Option<Arc<Mutex<dyn super::physics::GamePhysicsEntityDataTrait>>>;
    fn member_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::GamePhysicsEntityDataTrait>>>;
    fn mesh_asset(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn instance_count(&self) -> &u32;
    fn instance_count_mut(&mut self) -> &mut u32;
    fn health_state_entity_manager_id(&self) -> &u32;
    fn health_state_entity_manager_id_mut(&mut self) -> &mut u32;
    fn physics_part_range(&self) -> &IndexRange;
    fn physics_part_range_mut(&mut self) -> &mut IndexRange;
    fn physics_part_count_per_instance(&self) -> &u32;
    fn physics_part_count_per_instance_mut(&mut self) -> &mut u32;
    fn network_id_range(&self) -> &IndexRange;
    fn network_id_range_mut(&mut self) -> &mut IndexRange;
    fn network_id_count_per_instance(&self) -> &u32;
    fn network_id_count_per_instance_mut(&mut self) -> &mut u32;
    fn part_component_count(&self) -> &u32;
    fn part_component_count_mut(&mut self) -> &mut u32;
}

impl StaticModelGroupMemberDataTrait for StaticModelGroupMemberData {
    fn instance_transforms(&self) -> &Vec<super::core::LinearTransform> {
        &self.instance_transforms
    }
    fn instance_transforms_mut(&mut self) -> &mut Vec<super::core::LinearTransform> {
        &mut self.instance_transforms
    }
    fn instance_object_variation(&self) -> &Vec<u32> {
        &self.instance_object_variation
    }
    fn instance_object_variation_mut(&mut self) -> &mut Vec<u32> {
        &mut self.instance_object_variation
    }
    fn instance_rendering_overrides(&self) -> &Vec<super::core::RenderingOverrides> {
        &self.instance_rendering_overrides
    }
    fn instance_rendering_overrides_mut(&mut self) -> &mut Vec<super::core::RenderingOverrides> {
        &mut self.instance_rendering_overrides
    }
    fn instance_radiosity_type_override(&self) -> &Vec<super::core::RadiosityTypeOverride> {
        &self.instance_radiosity_type_override
    }
    fn instance_radiosity_type_override_mut(&mut self) -> &mut Vec<super::core::RadiosityTypeOverride> {
        &mut self.instance_radiosity_type_override
    }
    fn instance_terrain_shader_nodes_enable(&self) -> &Vec<bool> {
        &self.instance_terrain_shader_nodes_enable
    }
    fn instance_terrain_shader_nodes_enable_mut(&mut self) -> &mut Vec<bool> {
        &mut self.instance_terrain_shader_nodes_enable
    }
    fn member_type(&self) -> &Option<Arc<Mutex<dyn super::physics::GamePhysicsEntityDataTrait>>> {
        &self.member_type
    }
    fn member_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::physics::GamePhysicsEntityDataTrait>>> {
        &mut self.member_type
    }
    fn mesh_asset(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh_asset
    }
    fn mesh_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh_asset
    }
    fn instance_count(&self) -> &u32 {
        &self.instance_count
    }
    fn instance_count_mut(&mut self) -> &mut u32 {
        &mut self.instance_count
    }
    fn health_state_entity_manager_id(&self) -> &u32 {
        &self.health_state_entity_manager_id
    }
    fn health_state_entity_manager_id_mut(&mut self) -> &mut u32 {
        &mut self.health_state_entity_manager_id
    }
    fn physics_part_range(&self) -> &IndexRange {
        &self.physics_part_range
    }
    fn physics_part_range_mut(&mut self) -> &mut IndexRange {
        &mut self.physics_part_range
    }
    fn physics_part_count_per_instance(&self) -> &u32 {
        &self.physics_part_count_per_instance
    }
    fn physics_part_count_per_instance_mut(&mut self) -> &mut u32 {
        &mut self.physics_part_count_per_instance
    }
    fn network_id_range(&self) -> &IndexRange {
        &self.network_id_range
    }
    fn network_id_range_mut(&mut self) -> &mut IndexRange {
        &mut self.network_id_range
    }
    fn network_id_count_per_instance(&self) -> &u32 {
        &self.network_id_count_per_instance
    }
    fn network_id_count_per_instance_mut(&mut self) -> &mut u32 {
        &mut self.network_id_count_per_instance
    }
    fn part_component_count(&self) -> &u32 {
        &self.part_component_count
    }
    fn part_component_count_mut(&mut self) -> &mut u32 {
        &mut self.part_component_count
    }
}

pub static STATICMODELGROUPMEMBERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupMemberData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelGroupMemberData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InstanceTransforms",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_transforms),
            },
            FieldInfoData {
                name: "InstanceObjectVariation",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_object_variation),
            },
            FieldInfoData {
                name: "InstanceRenderingOverrides",
                flags: MemberInfoFlags::new(144),
                field_type: "RenderingOverrides-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_rendering_overrides),
            },
            FieldInfoData {
                name: "InstanceRadiosityTypeOverride",
                flags: MemberInfoFlags::new(144),
                field_type: "RadiosityTypeOverride-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_radiosity_type_override),
            },
            FieldInfoData {
                name: "InstanceTerrainShaderNodesEnable",
                flags: MemberInfoFlags::new(144),
                field_type: "Boolean-Array",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_terrain_shader_nodes_enable),
            },
            FieldInfoData {
                name: "MemberType",
                flags: MemberInfoFlags::new(0),
                field_type: "GamePhysicsEntityData",
                rust_offset: offset_of!(StaticModelGroupMemberData, member_type),
            },
            FieldInfoData {
                name: "MeshAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(StaticModelGroupMemberData, mesh_asset),
            },
            FieldInfoData {
                name: "InstanceCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, instance_count),
            },
            FieldInfoData {
                name: "HealthStateEntityManagerId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, health_state_entity_manager_id),
            },
            FieldInfoData {
                name: "PhysicsPartRange",
                flags: MemberInfoFlags::new(0),
                field_type: "IndexRange",
                rust_offset: offset_of!(StaticModelGroupMemberData, physics_part_range),
            },
            FieldInfoData {
                name: "PhysicsPartCountPerInstance",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, physics_part_count_per_instance),
            },
            FieldInfoData {
                name: "NetworkIdRange",
                flags: MemberInfoFlags::new(0),
                field_type: "IndexRange",
                rust_offset: offset_of!(StaticModelGroupMemberData, network_id_range),
            },
            FieldInfoData {
                name: "NetworkIdCountPerInstance",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, network_id_count_per_instance),
            },
            FieldInfoData {
                name: "PartComponentCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelGroupMemberData, part_component_count),
            },
        ],
    }),
    array_type: Some(STATICMODELGROUPMEMBERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StaticModelGroupMemberData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELGROUPMEMBERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STATICMODELGROUPMEMBERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelGroupMemberData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelGroupMemberData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameSplineEntityData {
    pub _glacier_base: super::entity::GameComponentEntityData,
    pub realm: super::core::Realm,
    pub game_spline_data_guid: glacier_util::guid::Guid,
    pub length: f32,
    pub discrete_local_points: Vec<super::core::Vec3>,
    pub discrete_normals: Vec<super::core::Vec3>,
    pub discrete_normalized_lengths: Vec<f32>,
}

pub trait GameSplineEntityDataTrait: super::entity::GameComponentEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn game_spline_data_guid(&self) -> &glacier_util::guid::Guid;
    fn game_spline_data_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
    fn discrete_local_points(&self) -> &Vec<super::core::Vec3>;
    fn discrete_local_points_mut(&mut self) -> &mut Vec<super::core::Vec3>;
    fn discrete_normals(&self) -> &Vec<super::core::Vec3>;
    fn discrete_normals_mut(&mut self) -> &mut Vec<super::core::Vec3>;
    fn discrete_normalized_lengths(&self) -> &Vec<f32>;
    fn discrete_normalized_lengths_mut(&mut self) -> &mut Vec<f32>;
}

impl GameSplineEntityDataTrait for GameSplineEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn game_spline_data_guid(&self) -> &glacier_util::guid::Guid {
        &self.game_spline_data_guid
    }
    fn game_spline_data_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.game_spline_data_guid
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
    fn discrete_local_points(&self) -> &Vec<super::core::Vec3> {
        &self.discrete_local_points
    }
    fn discrete_local_points_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.discrete_local_points
    }
    fn discrete_normals(&self) -> &Vec<super::core::Vec3> {
        &self.discrete_normals
    }
    fn discrete_normals_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.discrete_normals
    }
    fn discrete_normalized_lengths(&self) -> &Vec<f32> {
        &self.discrete_normalized_lengths
    }
    fn discrete_normalized_lengths_mut(&mut self) -> &mut Vec<f32> {
        &mut self.discrete_normalized_lengths
    }
}

impl super::entity::GameComponentEntityDataTrait for GameSplineEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for GameSplineEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for GameSplineEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for GameSplineEntityData {
}

impl super::entity::GameObjectDataTrait for GameSplineEntityData {
}

impl super::core::DataBusPeerTrait for GameSplineEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameSplineEntityData {
}

impl super::core::DataContainerTrait for GameSplineEntityData {
}

pub static GAMESPLINEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSplineEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameSplineEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(GameSplineEntityData, realm),
            },
            FieldInfoData {
                name: "GameSplineDataGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(GameSplineEntityData, game_spline_data_guid),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameSplineEntityData, length),
            },
            FieldInfoData {
                name: "DiscreteLocalPoints",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(GameSplineEntityData, discrete_local_points),
            },
            FieldInfoData {
                name: "DiscreteNormals",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(GameSplineEntityData, discrete_normals),
            },
            FieldInfoData {
                name: "DiscreteNormalizedLengths",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(GameSplineEntityData, discrete_normalized_lengths),
            },
        ],
    }),
    array_type: Some(GAMESPLINEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GameSplineEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMESPLINEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMESPLINEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSplineEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameSplineEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameSplineData {
    pub _glacier_base: super::entity::CustomSplineData,
}

pub trait GameSplineDataTrait: super::entity::CustomSplineDataTrait {
}

impl GameSplineDataTrait for GameSplineData {
}

impl super::entity::CustomSplineDataTrait for GameSplineData {
}

impl super::entity::VectorShapeDataTrait for GameSplineData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        self._glacier_base.points()
    }
    fn points_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        self._glacier_base.points_mut()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn tension_mut(&mut self) -> &mut f32 {
        self._glacier_base.tension_mut()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_closed_mut()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_roll_mut()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_yaw_pitch_mut()
    }
}

impl super::entity::BaseShapeDataTrait for GameSplineData {
}

impl super::entity::BaseShapeDataBaseTrait for GameSplineData {
}

impl super::entity::GameObjectDataTrait for GameSplineData {
}

impl super::core::DataBusPeerTrait for GameSplineData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameSplineData {
}

impl super::core::DataContainerTrait for GameSplineData {
}

pub static GAMESPLINEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSplineData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::CUSTOMSPLINEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameSplineData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMESPLINEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameSplineData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMESPLINEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMESPLINEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSplineData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameSplineData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LicenseeGameSettings {
    pub _glacier_base: super::core::SystemSettings,
    pub min_player_count_elimination: u32,
    pub use_speed_based_detailed_collision: bool,
    pub use_single_weapon_selector: bool,
    pub auto_aim_enabled: bool,
    pub p_s3_content_rating_age: u32,
    pub has_unlimited_ammo: bool,
    pub has_unlimited_mags: bool,
    pub rotate_logs: bool,
    pub log_history: u32,
    pub adjust_vehicle_center_of_mass: bool,
    pub time_before_spawn_is_allowed: f32,
    pub level_warm_up_time: f32,
    pub difficulty_settings: Option<Arc<Mutex<dyn DifficultyDatasTrait>>>,
    pub aim_assist_enabled: bool,
    pub aim_assist_use_polynomials: bool,
    pub is_god_mode: bool,
    pub is_jesus_mode: bool,
    pub is_jesus_mode_ai: bool,
    pub current_s_k_u: SKU,
    pub game_administration_enabled: bool,
    pub allow_destruction_outside_combat_area: bool,
    pub controllable_significance_settings: SignificanceSettings,
}

pub trait LicenseeGameSettingsTrait: super::core::SystemSettingsTrait {
    fn min_player_count_elimination(&self) -> &u32;
    fn min_player_count_elimination_mut(&mut self) -> &mut u32;
    fn use_speed_based_detailed_collision(&self) -> &bool;
    fn use_speed_based_detailed_collision_mut(&mut self) -> &mut bool;
    fn use_single_weapon_selector(&self) -> &bool;
    fn use_single_weapon_selector_mut(&mut self) -> &mut bool;
    fn auto_aim_enabled(&self) -> &bool;
    fn auto_aim_enabled_mut(&mut self) -> &mut bool;
    fn p_s3_content_rating_age(&self) -> &u32;
    fn p_s3_content_rating_age_mut(&mut self) -> &mut u32;
    fn has_unlimited_ammo(&self) -> &bool;
    fn has_unlimited_ammo_mut(&mut self) -> &mut bool;
    fn has_unlimited_mags(&self) -> &bool;
    fn has_unlimited_mags_mut(&mut self) -> &mut bool;
    fn rotate_logs(&self) -> &bool;
    fn rotate_logs_mut(&mut self) -> &mut bool;
    fn log_history(&self) -> &u32;
    fn log_history_mut(&mut self) -> &mut u32;
    fn adjust_vehicle_center_of_mass(&self) -> &bool;
    fn adjust_vehicle_center_of_mass_mut(&mut self) -> &mut bool;
    fn time_before_spawn_is_allowed(&self) -> &f32;
    fn time_before_spawn_is_allowed_mut(&mut self) -> &mut f32;
    fn level_warm_up_time(&self) -> &f32;
    fn level_warm_up_time_mut(&mut self) -> &mut f32;
    fn difficulty_settings(&self) -> &Option<Arc<Mutex<dyn DifficultyDatasTrait>>>;
    fn difficulty_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DifficultyDatasTrait>>>;
    fn aim_assist_enabled(&self) -> &bool;
    fn aim_assist_enabled_mut(&mut self) -> &mut bool;
    fn aim_assist_use_polynomials(&self) -> &bool;
    fn aim_assist_use_polynomials_mut(&mut self) -> &mut bool;
    fn is_god_mode(&self) -> &bool;
    fn is_god_mode_mut(&mut self) -> &mut bool;
    fn is_jesus_mode(&self) -> &bool;
    fn is_jesus_mode_mut(&mut self) -> &mut bool;
    fn is_jesus_mode_ai(&self) -> &bool;
    fn is_jesus_mode_ai_mut(&mut self) -> &mut bool;
    fn current_s_k_u(&self) -> &SKU;
    fn current_s_k_u_mut(&mut self) -> &mut SKU;
    fn game_administration_enabled(&self) -> &bool;
    fn game_administration_enabled_mut(&mut self) -> &mut bool;
    fn allow_destruction_outside_combat_area(&self) -> &bool;
    fn allow_destruction_outside_combat_area_mut(&mut self) -> &mut bool;
    fn controllable_significance_settings(&self) -> &SignificanceSettings;
    fn controllable_significance_settings_mut(&mut self) -> &mut SignificanceSettings;
}

impl LicenseeGameSettingsTrait for LicenseeGameSettings {
    fn min_player_count_elimination(&self) -> &u32 {
        &self.min_player_count_elimination
    }
    fn min_player_count_elimination_mut(&mut self) -> &mut u32 {
        &mut self.min_player_count_elimination
    }
    fn use_speed_based_detailed_collision(&self) -> &bool {
        &self.use_speed_based_detailed_collision
    }
    fn use_speed_based_detailed_collision_mut(&mut self) -> &mut bool {
        &mut self.use_speed_based_detailed_collision
    }
    fn use_single_weapon_selector(&self) -> &bool {
        &self.use_single_weapon_selector
    }
    fn use_single_weapon_selector_mut(&mut self) -> &mut bool {
        &mut self.use_single_weapon_selector
    }
    fn auto_aim_enabled(&self) -> &bool {
        &self.auto_aim_enabled
    }
    fn auto_aim_enabled_mut(&mut self) -> &mut bool {
        &mut self.auto_aim_enabled
    }
    fn p_s3_content_rating_age(&self) -> &u32 {
        &self.p_s3_content_rating_age
    }
    fn p_s3_content_rating_age_mut(&mut self) -> &mut u32 {
        &mut self.p_s3_content_rating_age
    }
    fn has_unlimited_ammo(&self) -> &bool {
        &self.has_unlimited_ammo
    }
    fn has_unlimited_ammo_mut(&mut self) -> &mut bool {
        &mut self.has_unlimited_ammo
    }
    fn has_unlimited_mags(&self) -> &bool {
        &self.has_unlimited_mags
    }
    fn has_unlimited_mags_mut(&mut self) -> &mut bool {
        &mut self.has_unlimited_mags
    }
    fn rotate_logs(&self) -> &bool {
        &self.rotate_logs
    }
    fn rotate_logs_mut(&mut self) -> &mut bool {
        &mut self.rotate_logs
    }
    fn log_history(&self) -> &u32 {
        &self.log_history
    }
    fn log_history_mut(&mut self) -> &mut u32 {
        &mut self.log_history
    }
    fn adjust_vehicle_center_of_mass(&self) -> &bool {
        &self.adjust_vehicle_center_of_mass
    }
    fn adjust_vehicle_center_of_mass_mut(&mut self) -> &mut bool {
        &mut self.adjust_vehicle_center_of_mass
    }
    fn time_before_spawn_is_allowed(&self) -> &f32 {
        &self.time_before_spawn_is_allowed
    }
    fn time_before_spawn_is_allowed_mut(&mut self) -> &mut f32 {
        &mut self.time_before_spawn_is_allowed
    }
    fn level_warm_up_time(&self) -> &f32 {
        &self.level_warm_up_time
    }
    fn level_warm_up_time_mut(&mut self) -> &mut f32 {
        &mut self.level_warm_up_time
    }
    fn difficulty_settings(&self) -> &Option<Arc<Mutex<dyn DifficultyDatasTrait>>> {
        &self.difficulty_settings
    }
    fn difficulty_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DifficultyDatasTrait>>> {
        &mut self.difficulty_settings
    }
    fn aim_assist_enabled(&self) -> &bool {
        &self.aim_assist_enabled
    }
    fn aim_assist_enabled_mut(&mut self) -> &mut bool {
        &mut self.aim_assist_enabled
    }
    fn aim_assist_use_polynomials(&self) -> &bool {
        &self.aim_assist_use_polynomials
    }
    fn aim_assist_use_polynomials_mut(&mut self) -> &mut bool {
        &mut self.aim_assist_use_polynomials
    }
    fn is_god_mode(&self) -> &bool {
        &self.is_god_mode
    }
    fn is_god_mode_mut(&mut self) -> &mut bool {
        &mut self.is_god_mode
    }
    fn is_jesus_mode(&self) -> &bool {
        &self.is_jesus_mode
    }
    fn is_jesus_mode_mut(&mut self) -> &mut bool {
        &mut self.is_jesus_mode
    }
    fn is_jesus_mode_ai(&self) -> &bool {
        &self.is_jesus_mode_ai
    }
    fn is_jesus_mode_ai_mut(&mut self) -> &mut bool {
        &mut self.is_jesus_mode_ai
    }
    fn current_s_k_u(&self) -> &SKU {
        &self.current_s_k_u
    }
    fn current_s_k_u_mut(&mut self) -> &mut SKU {
        &mut self.current_s_k_u
    }
    fn game_administration_enabled(&self) -> &bool {
        &self.game_administration_enabled
    }
    fn game_administration_enabled_mut(&mut self) -> &mut bool {
        &mut self.game_administration_enabled
    }
    fn allow_destruction_outside_combat_area(&self) -> &bool {
        &self.allow_destruction_outside_combat_area
    }
    fn allow_destruction_outside_combat_area_mut(&mut self) -> &mut bool {
        &mut self.allow_destruction_outside_combat_area
    }
    fn controllable_significance_settings(&self) -> &SignificanceSettings {
        &self.controllable_significance_settings
    }
    fn controllable_significance_settings_mut(&mut self) -> &mut SignificanceSettings {
        &mut self.controllable_significance_settings
    }
}

impl super::core::SystemSettingsTrait for LicenseeGameSettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        self._glacier_base.platform_mut()
    }
}

impl super::core::DataContainerTrait for LicenseeGameSettings {
}

pub static LICENSEEGAMESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LicenseeGameSettings",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LicenseeGameSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinPlayerCountElimination",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LicenseeGameSettings, min_player_count_elimination),
            },
            FieldInfoData {
                name: "UseSpeedBasedDetailedCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, use_speed_based_detailed_collision),
            },
            FieldInfoData {
                name: "UseSingleWeaponSelector",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, use_single_weapon_selector),
            },
            FieldInfoData {
                name: "AutoAimEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, auto_aim_enabled),
            },
            FieldInfoData {
                name: "PS3ContentRatingAge",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LicenseeGameSettings, p_s3_content_rating_age),
            },
            FieldInfoData {
                name: "HasUnlimitedAmmo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, has_unlimited_ammo),
            },
            FieldInfoData {
                name: "HasUnlimitedMags",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, has_unlimited_mags),
            },
            FieldInfoData {
                name: "RotateLogs",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, rotate_logs),
            },
            FieldInfoData {
                name: "LogHistory",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LicenseeGameSettings, log_history),
            },
            FieldInfoData {
                name: "AdjustVehicleCenterOfMass",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, adjust_vehicle_center_of_mass),
            },
            FieldInfoData {
                name: "TimeBeforeSpawnIsAllowed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LicenseeGameSettings, time_before_spawn_is_allowed),
            },
            FieldInfoData {
                name: "LevelWarmUpTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LicenseeGameSettings, level_warm_up_time),
            },
            FieldInfoData {
                name: "DifficultySettings",
                flags: MemberInfoFlags::new(0),
                field_type: "DifficultyDatas",
                rust_offset: offset_of!(LicenseeGameSettings, difficulty_settings),
            },
            FieldInfoData {
                name: "AimAssistEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, aim_assist_enabled),
            },
            FieldInfoData {
                name: "AimAssistUsePolynomials",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, aim_assist_use_polynomials),
            },
            FieldInfoData {
                name: "IsGodMode",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, is_god_mode),
            },
            FieldInfoData {
                name: "IsJesusMode",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, is_jesus_mode),
            },
            FieldInfoData {
                name: "IsJesusModeAi",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, is_jesus_mode_ai),
            },
            FieldInfoData {
                name: "CurrentSKU",
                flags: MemberInfoFlags::new(0),
                field_type: "SKU",
                rust_offset: offset_of!(LicenseeGameSettings, current_s_k_u),
            },
            FieldInfoData {
                name: "GameAdministrationEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, game_administration_enabled),
            },
            FieldInfoData {
                name: "AllowDestructionOutsideCombatArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LicenseeGameSettings, allow_destruction_outside_combat_area),
            },
            FieldInfoData {
                name: "ControllableSignificanceSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "SignificanceSettings",
                rust_offset: offset_of!(LicenseeGameSettings, controllable_significance_settings),
            },
        ],
    }),
    array_type: Some(LICENSEEGAMESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LicenseeGameSettings {
    fn type_info(&self) -> &'static TypeInfo {
        LICENSEEGAMESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LICENSEEGAMESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LicenseeGameSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LicenseeGameSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SignificanceSettings {
    pub high: u32,
    pub medium: u32,
    pub is_enabled: bool,
    pub primary_radius: f32,
    pub primary_length: f32,
    pub secondary_radius: f32,
    pub secondary_length: f32,
}

pub trait SignificanceSettingsTrait: TypeObject {
    fn high(&self) -> &u32;
    fn high_mut(&mut self) -> &mut u32;
    fn medium(&self) -> &u32;
    fn medium_mut(&mut self) -> &mut u32;
    fn is_enabled(&self) -> &bool;
    fn is_enabled_mut(&mut self) -> &mut bool;
    fn primary_radius(&self) -> &f32;
    fn primary_radius_mut(&mut self) -> &mut f32;
    fn primary_length(&self) -> &f32;
    fn primary_length_mut(&mut self) -> &mut f32;
    fn secondary_radius(&self) -> &f32;
    fn secondary_radius_mut(&mut self) -> &mut f32;
    fn secondary_length(&self) -> &f32;
    fn secondary_length_mut(&mut self) -> &mut f32;
}

impl SignificanceSettingsTrait for SignificanceSettings {
    fn high(&self) -> &u32 {
        &self.high
    }
    fn high_mut(&mut self) -> &mut u32 {
        &mut self.high
    }
    fn medium(&self) -> &u32 {
        &self.medium
    }
    fn medium_mut(&mut self) -> &mut u32 {
        &mut self.medium
    }
    fn is_enabled(&self) -> &bool {
        &self.is_enabled
    }
    fn is_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_enabled
    }
    fn primary_radius(&self) -> &f32 {
        &self.primary_radius
    }
    fn primary_radius_mut(&mut self) -> &mut f32 {
        &mut self.primary_radius
    }
    fn primary_length(&self) -> &f32 {
        &self.primary_length
    }
    fn primary_length_mut(&mut self) -> &mut f32 {
        &mut self.primary_length
    }
    fn secondary_radius(&self) -> &f32 {
        &self.secondary_radius
    }
    fn secondary_radius_mut(&mut self) -> &mut f32 {
        &mut self.secondary_radius
    }
    fn secondary_length(&self) -> &f32 {
        &self.secondary_length
    }
    fn secondary_length_mut(&mut self) -> &mut f32 {
        &mut self.secondary_length
    }
}

pub static SIGNIFICANCESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SignificanceSettings",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SignificanceSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "High",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SignificanceSettings, high),
            },
            FieldInfoData {
                name: "Medium",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SignificanceSettings, medium),
            },
            FieldInfoData {
                name: "IsEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SignificanceSettings, is_enabled),
            },
            FieldInfoData {
                name: "PrimaryRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SignificanceSettings, primary_radius),
            },
            FieldInfoData {
                name: "PrimaryLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SignificanceSettings, primary_length),
            },
            FieldInfoData {
                name: "SecondaryRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SignificanceSettings, secondary_radius),
            },
            FieldInfoData {
                name: "SecondaryLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SignificanceSettings, secondary_length),
            },
        ],
    }),
    array_type: Some(SIGNIFICANCESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SignificanceSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SIGNIFICANCESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SIGNIFICANCESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SignificanceSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SignificanceSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SKU {
    #[default]
    WW = 0,
    EU = 1,
    US = 2,
    JPN = 3,
    ROA = 4,
    RU = 5,
    EN = 6,
}

pub static SKU_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SKU",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(SKU_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SKU {
    fn type_info(&self) -> &'static TypeInfo {
        SKU_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SKU_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SKU-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SKU"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InteractionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub use_within_radius: f32,
    pub use_within_angle: f32,
    pub test_if_occluded: bool,
    pub max_uses: u32,
    pub allow_interaction_via_remote_entry: bool,
    pub display_within_radius: f32,
    pub use_display_within_radius: bool,
    pub pre_interaction_sound_effect: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub enabled: bool,
}

pub trait InteractionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn use_within_radius(&self) -> &f32;
    fn use_within_radius_mut(&mut self) -> &mut f32;
    fn use_within_angle(&self) -> &f32;
    fn use_within_angle_mut(&mut self) -> &mut f32;
    fn test_if_occluded(&self) -> &bool;
    fn test_if_occluded_mut(&mut self) -> &mut bool;
    fn max_uses(&self) -> &u32;
    fn max_uses_mut(&mut self) -> &mut u32;
    fn allow_interaction_via_remote_entry(&self) -> &bool;
    fn allow_interaction_via_remote_entry_mut(&mut self) -> &mut bool;
    fn display_within_radius(&self) -> &f32;
    fn display_within_radius_mut(&mut self) -> &mut f32;
    fn use_display_within_radius(&self) -> &bool;
    fn use_display_within_radius_mut(&mut self) -> &mut bool;
    fn pre_interaction_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn pre_interaction_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl InteractionEntityDataTrait for InteractionEntityData {
    fn use_within_radius(&self) -> &f32 {
        &self.use_within_radius
    }
    fn use_within_radius_mut(&mut self) -> &mut f32 {
        &mut self.use_within_radius
    }
    fn use_within_angle(&self) -> &f32 {
        &self.use_within_angle
    }
    fn use_within_angle_mut(&mut self) -> &mut f32 {
        &mut self.use_within_angle
    }
    fn test_if_occluded(&self) -> &bool {
        &self.test_if_occluded
    }
    fn test_if_occluded_mut(&mut self) -> &mut bool {
        &mut self.test_if_occluded
    }
    fn max_uses(&self) -> &u32 {
        &self.max_uses
    }
    fn max_uses_mut(&mut self) -> &mut u32 {
        &mut self.max_uses
    }
    fn allow_interaction_via_remote_entry(&self) -> &bool {
        &self.allow_interaction_via_remote_entry
    }
    fn allow_interaction_via_remote_entry_mut(&mut self) -> &mut bool {
        &mut self.allow_interaction_via_remote_entry
    }
    fn display_within_radius(&self) -> &f32 {
        &self.display_within_radius
    }
    fn display_within_radius_mut(&mut self) -> &mut f32 {
        &mut self.display_within_radius
    }
    fn use_display_within_radius(&self) -> &bool {
        &self.use_display_within_radius
    }
    fn use_display_within_radius_mut(&mut self) -> &mut bool {
        &mut self.use_display_within_radius
    }
    fn pre_interaction_sound_effect(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.pre_interaction_sound_effect
    }
    fn pre_interaction_sound_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.pre_interaction_sound_effect
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for InteractionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for InteractionEntityData {
}

impl super::entity::GameObjectDataTrait for InteractionEntityData {
}

impl super::core::DataBusPeerTrait for InteractionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for InteractionEntityData {
}

impl super::core::DataContainerTrait for InteractionEntityData {
}

pub static INTERACTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InteractionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InteractionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseWithinRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InteractionEntityData, use_within_radius),
            },
            FieldInfoData {
                name: "UseWithinAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InteractionEntityData, use_within_angle),
            },
            FieldInfoData {
                name: "TestIfOccluded",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InteractionEntityData, test_if_occluded),
            },
            FieldInfoData {
                name: "MaxUses",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(InteractionEntityData, max_uses),
            },
            FieldInfoData {
                name: "AllowInteractionViaRemoteEntry",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InteractionEntityData, allow_interaction_via_remote_entry),
            },
            FieldInfoData {
                name: "DisplayWithinRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InteractionEntityData, display_within_radius),
            },
            FieldInfoData {
                name: "UseDisplayWithinRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InteractionEntityData, use_display_within_radius),
            },
            FieldInfoData {
                name: "PreInteractionSoundEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(InteractionEntityData, pre_interaction_sound_effect),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InteractionEntityData, enabled),
            },
        ],
    }),
    array_type: Some(INTERACTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for InteractionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTERACTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTERACTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InteractionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InteractionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PredestructionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub radius: f32,
    pub enabled: bool,
}

pub trait PredestructionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl PredestructionEntityDataTrait for PredestructionEntityData {
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for PredestructionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PredestructionEntityData {
}

impl super::entity::GameObjectDataTrait for PredestructionEntityData {
}

impl super::core::DataBusPeerTrait for PredestructionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PredestructionEntityData {
}

impl super::core::DataContainerTrait for PredestructionEntityData {
}

pub static PREDESTRUCTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PredestructionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PredestructionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PredestructionEntityData, radius),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PredestructionEntityData, enabled),
            },
        ],
    }),
    array_type: Some(PREDESTRUCTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PredestructionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PREDESTRUCTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PREDESTRUCTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PredestructionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PredestructionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub detonation_effect: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
    pub detonation_effect_for_friendlies: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
    pub no_friendlies_effect_on_enabled_friendly_fire: bool,
    pub use_entity_transform_for_detonation_effect: bool,
    pub material_pair: super::entity::MaterialDecl,
    pub secondary_materials_active: bool,
    pub secondary_material_pair: super::entity::MaterialDecl,
    pub damage_indication_type: DamageIndicationType,
    pub emp_time: f32,
    pub max_occlusion_raycast_radius: f32,
    pub inner_blast_radius: f32,
    pub blast_damage: f32,
    pub blast_radius: f32,
    pub blast_impulse: f32,
    pub has_stun_effect: bool,
    pub shockwave_damage: f32,
    pub shockwave_radius: f32,
    pub shockwave_impulse: f32,
    pub allow_damage_to_owner: bool,
    pub shockwave_time: f32,
    pub apply_blast_damage_to_vehicles_and_characters_instantly: bool,
    pub force_serverside_ai_damage: bool,
    pub disable_occlusion: bool,
    pub disable_static_entity_occlusion: bool,
    pub disable_occlusion_outside_blast_radius: bool,
    pub camera_shockwave_radius: f32,
    pub spawn_delay: f32,
    pub trigger_impaired_hearing: bool,
    pub shockwave_wind_force: Option<Arc<Mutex<dyn ExplosionWindForceDataTrait>>>,
    pub enabled: bool,
}

pub trait ExplosionEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn detonation_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn detonation_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn detonation_effect_for_friendlies(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn detonation_effect_for_friendlies_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn no_friendlies_effect_on_enabled_friendly_fire(&self) -> &bool;
    fn no_friendlies_effect_on_enabled_friendly_fire_mut(&mut self) -> &mut bool;
    fn use_entity_transform_for_detonation_effect(&self) -> &bool;
    fn use_entity_transform_for_detonation_effect_mut(&mut self) -> &mut bool;
    fn material_pair(&self) -> &super::entity::MaterialDecl;
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn secondary_materials_active(&self) -> &bool;
    fn secondary_materials_active_mut(&mut self) -> &mut bool;
    fn secondary_material_pair(&self) -> &super::entity::MaterialDecl;
    fn secondary_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn damage_indication_type(&self) -> &DamageIndicationType;
    fn damage_indication_type_mut(&mut self) -> &mut DamageIndicationType;
    fn emp_time(&self) -> &f32;
    fn emp_time_mut(&mut self) -> &mut f32;
    fn max_occlusion_raycast_radius(&self) -> &f32;
    fn max_occlusion_raycast_radius_mut(&mut self) -> &mut f32;
    fn inner_blast_radius(&self) -> &f32;
    fn inner_blast_radius_mut(&mut self) -> &mut f32;
    fn blast_damage(&self) -> &f32;
    fn blast_damage_mut(&mut self) -> &mut f32;
    fn blast_radius(&self) -> &f32;
    fn blast_radius_mut(&mut self) -> &mut f32;
    fn blast_impulse(&self) -> &f32;
    fn blast_impulse_mut(&mut self) -> &mut f32;
    fn has_stun_effect(&self) -> &bool;
    fn has_stun_effect_mut(&mut self) -> &mut bool;
    fn shockwave_damage(&self) -> &f32;
    fn shockwave_damage_mut(&mut self) -> &mut f32;
    fn shockwave_radius(&self) -> &f32;
    fn shockwave_radius_mut(&mut self) -> &mut f32;
    fn shockwave_impulse(&self) -> &f32;
    fn shockwave_impulse_mut(&mut self) -> &mut f32;
    fn allow_damage_to_owner(&self) -> &bool;
    fn allow_damage_to_owner_mut(&mut self) -> &mut bool;
    fn shockwave_time(&self) -> &f32;
    fn shockwave_time_mut(&mut self) -> &mut f32;
    fn apply_blast_damage_to_vehicles_and_characters_instantly(&self) -> &bool;
    fn apply_blast_damage_to_vehicles_and_characters_instantly_mut(&mut self) -> &mut bool;
    fn force_serverside_ai_damage(&self) -> &bool;
    fn force_serverside_ai_damage_mut(&mut self) -> &mut bool;
    fn disable_occlusion(&self) -> &bool;
    fn disable_occlusion_mut(&mut self) -> &mut bool;
    fn disable_static_entity_occlusion(&self) -> &bool;
    fn disable_static_entity_occlusion_mut(&mut self) -> &mut bool;
    fn disable_occlusion_outside_blast_radius(&self) -> &bool;
    fn disable_occlusion_outside_blast_radius_mut(&mut self) -> &mut bool;
    fn camera_shockwave_radius(&self) -> &f32;
    fn camera_shockwave_radius_mut(&mut self) -> &mut f32;
    fn spawn_delay(&self) -> &f32;
    fn spawn_delay_mut(&mut self) -> &mut f32;
    fn trigger_impaired_hearing(&self) -> &bool;
    fn trigger_impaired_hearing_mut(&mut self) -> &mut bool;
    fn shockwave_wind_force(&self) -> &Option<Arc<Mutex<dyn ExplosionWindForceDataTrait>>>;
    fn shockwave_wind_force_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExplosionWindForceDataTrait>>>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl ExplosionEntityDataTrait for ExplosionEntityData {
    fn detonation_effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.detonation_effect
    }
    fn detonation_effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &mut self.detonation_effect
    }
    fn detonation_effect_for_friendlies(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.detonation_effect_for_friendlies
    }
    fn detonation_effect_for_friendlies_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &mut self.detonation_effect_for_friendlies
    }
    fn no_friendlies_effect_on_enabled_friendly_fire(&self) -> &bool {
        &self.no_friendlies_effect_on_enabled_friendly_fire
    }
    fn no_friendlies_effect_on_enabled_friendly_fire_mut(&mut self) -> &mut bool {
        &mut self.no_friendlies_effect_on_enabled_friendly_fire
    }
    fn use_entity_transform_for_detonation_effect(&self) -> &bool {
        &self.use_entity_transform_for_detonation_effect
    }
    fn use_entity_transform_for_detonation_effect_mut(&mut self) -> &mut bool {
        &mut self.use_entity_transform_for_detonation_effect
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        &self.material_pair
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material_pair
    }
    fn secondary_materials_active(&self) -> &bool {
        &self.secondary_materials_active
    }
    fn secondary_materials_active_mut(&mut self) -> &mut bool {
        &mut self.secondary_materials_active
    }
    fn secondary_material_pair(&self) -> &super::entity::MaterialDecl {
        &self.secondary_material_pair
    }
    fn secondary_material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.secondary_material_pair
    }
    fn damage_indication_type(&self) -> &DamageIndicationType {
        &self.damage_indication_type
    }
    fn damage_indication_type_mut(&mut self) -> &mut DamageIndicationType {
        &mut self.damage_indication_type
    }
    fn emp_time(&self) -> &f32 {
        &self.emp_time
    }
    fn emp_time_mut(&mut self) -> &mut f32 {
        &mut self.emp_time
    }
    fn max_occlusion_raycast_radius(&self) -> &f32 {
        &self.max_occlusion_raycast_radius
    }
    fn max_occlusion_raycast_radius_mut(&mut self) -> &mut f32 {
        &mut self.max_occlusion_raycast_radius
    }
    fn inner_blast_radius(&self) -> &f32 {
        &self.inner_blast_radius
    }
    fn inner_blast_radius_mut(&mut self) -> &mut f32 {
        &mut self.inner_blast_radius
    }
    fn blast_damage(&self) -> &f32 {
        &self.blast_damage
    }
    fn blast_damage_mut(&mut self) -> &mut f32 {
        &mut self.blast_damage
    }
    fn blast_radius(&self) -> &f32 {
        &self.blast_radius
    }
    fn blast_radius_mut(&mut self) -> &mut f32 {
        &mut self.blast_radius
    }
    fn blast_impulse(&self) -> &f32 {
        &self.blast_impulse
    }
    fn blast_impulse_mut(&mut self) -> &mut f32 {
        &mut self.blast_impulse
    }
    fn has_stun_effect(&self) -> &bool {
        &self.has_stun_effect
    }
    fn has_stun_effect_mut(&mut self) -> &mut bool {
        &mut self.has_stun_effect
    }
    fn shockwave_damage(&self) -> &f32 {
        &self.shockwave_damage
    }
    fn shockwave_damage_mut(&mut self) -> &mut f32 {
        &mut self.shockwave_damage
    }
    fn shockwave_radius(&self) -> &f32 {
        &self.shockwave_radius
    }
    fn shockwave_radius_mut(&mut self) -> &mut f32 {
        &mut self.shockwave_radius
    }
    fn shockwave_impulse(&self) -> &f32 {
        &self.shockwave_impulse
    }
    fn shockwave_impulse_mut(&mut self) -> &mut f32 {
        &mut self.shockwave_impulse
    }
    fn allow_damage_to_owner(&self) -> &bool {
        &self.allow_damage_to_owner
    }
    fn allow_damage_to_owner_mut(&mut self) -> &mut bool {
        &mut self.allow_damage_to_owner
    }
    fn shockwave_time(&self) -> &f32 {
        &self.shockwave_time
    }
    fn shockwave_time_mut(&mut self) -> &mut f32 {
        &mut self.shockwave_time
    }
    fn apply_blast_damage_to_vehicles_and_characters_instantly(&self) -> &bool {
        &self.apply_blast_damage_to_vehicles_and_characters_instantly
    }
    fn apply_blast_damage_to_vehicles_and_characters_instantly_mut(&mut self) -> &mut bool {
        &mut self.apply_blast_damage_to_vehicles_and_characters_instantly
    }
    fn force_serverside_ai_damage(&self) -> &bool {
        &self.force_serverside_ai_damage
    }
    fn force_serverside_ai_damage_mut(&mut self) -> &mut bool {
        &mut self.force_serverside_ai_damage
    }
    fn disable_occlusion(&self) -> &bool {
        &self.disable_occlusion
    }
    fn disable_occlusion_mut(&mut self) -> &mut bool {
        &mut self.disable_occlusion
    }
    fn disable_static_entity_occlusion(&self) -> &bool {
        &self.disable_static_entity_occlusion
    }
    fn disable_static_entity_occlusion_mut(&mut self) -> &mut bool {
        &mut self.disable_static_entity_occlusion
    }
    fn disable_occlusion_outside_blast_radius(&self) -> &bool {
        &self.disable_occlusion_outside_blast_radius
    }
    fn disable_occlusion_outside_blast_radius_mut(&mut self) -> &mut bool {
        &mut self.disable_occlusion_outside_blast_radius
    }
    fn camera_shockwave_radius(&self) -> &f32 {
        &self.camera_shockwave_radius
    }
    fn camera_shockwave_radius_mut(&mut self) -> &mut f32 {
        &mut self.camera_shockwave_radius
    }
    fn spawn_delay(&self) -> &f32 {
        &self.spawn_delay
    }
    fn spawn_delay_mut(&mut self) -> &mut f32 {
        &mut self.spawn_delay
    }
    fn trigger_impaired_hearing(&self) -> &bool {
        &self.trigger_impaired_hearing
    }
    fn trigger_impaired_hearing_mut(&mut self) -> &mut bool {
        &mut self.trigger_impaired_hearing
    }
    fn shockwave_wind_force(&self) -> &Option<Arc<Mutex<dyn ExplosionWindForceDataTrait>>> {
        &self.shockwave_wind_force
    }
    fn shockwave_wind_force_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExplosionWindForceDataTrait>>> {
        &mut self.shockwave_wind_force
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for ExplosionEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for ExplosionEntityData {
}

impl super::entity::GameObjectDataTrait for ExplosionEntityData {
}

impl super::core::DataBusPeerTrait for ExplosionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ExplosionEntityData {
}

impl super::core::DataContainerTrait for ExplosionEntityData {
}

pub static EXPLOSIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DetonationEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(ExplosionEntityData, detonation_effect),
            },
            FieldInfoData {
                name: "DetonationEffectForFriendlies",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(ExplosionEntityData, detonation_effect_for_friendlies),
            },
            FieldInfoData {
                name: "NoFriendliesEffectOnEnabledFriendlyFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, no_friendlies_effect_on_enabled_friendly_fire),
            },
            FieldInfoData {
                name: "UseEntityTransformForDetonationEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, use_entity_transform_for_detonation_effect),
            },
            FieldInfoData {
                name: "MaterialPair",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(ExplosionEntityData, material_pair),
            },
            FieldInfoData {
                name: "SecondaryMaterialsActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, secondary_materials_active),
            },
            FieldInfoData {
                name: "SecondaryMaterialPair",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(ExplosionEntityData, secondary_material_pair),
            },
            FieldInfoData {
                name: "DamageIndicationType",
                flags: MemberInfoFlags::new(0),
                field_type: "DamageIndicationType",
                rust_offset: offset_of!(ExplosionEntityData, damage_indication_type),
            },
            FieldInfoData {
                name: "EmpTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, emp_time),
            },
            FieldInfoData {
                name: "MaxOcclusionRaycastRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, max_occlusion_raycast_radius),
            },
            FieldInfoData {
                name: "InnerBlastRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, inner_blast_radius),
            },
            FieldInfoData {
                name: "BlastDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, blast_damage),
            },
            FieldInfoData {
                name: "BlastRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, blast_radius),
            },
            FieldInfoData {
                name: "BlastImpulse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, blast_impulse),
            },
            FieldInfoData {
                name: "HasStunEffect",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, has_stun_effect),
            },
            FieldInfoData {
                name: "ShockwaveDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_damage),
            },
            FieldInfoData {
                name: "ShockwaveRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_radius),
            },
            FieldInfoData {
                name: "ShockwaveImpulse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_impulse),
            },
            FieldInfoData {
                name: "AllowDamageToOwner",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, allow_damage_to_owner),
            },
            FieldInfoData {
                name: "ShockwaveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_time),
            },
            FieldInfoData {
                name: "ApplyBlastDamageToVehiclesAndCharactersInstantly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, apply_blast_damage_to_vehicles_and_characters_instantly),
            },
            FieldInfoData {
                name: "ForceServersideAiDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, force_serverside_ai_damage),
            },
            FieldInfoData {
                name: "DisableOcclusion",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, disable_occlusion),
            },
            FieldInfoData {
                name: "DisableStaticEntityOcclusion",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, disable_static_entity_occlusion),
            },
            FieldInfoData {
                name: "DisableOcclusionOutsideBlastRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, disable_occlusion_outside_blast_radius),
            },
            FieldInfoData {
                name: "CameraShockwaveRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, camera_shockwave_radius),
            },
            FieldInfoData {
                name: "SpawnDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionEntityData, spawn_delay),
            },
            FieldInfoData {
                name: "TriggerImpairedHearing",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, trigger_impaired_hearing),
            },
            FieldInfoData {
                name: "ShockwaveWindForce",
                flags: MemberInfoFlags::new(0),
                field_type: "ExplosionWindForceData",
                rust_offset: offset_of!(ExplosionEntityData, shockwave_wind_force),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionEntityData, enabled),
            },
        ],
    }),
    array_type: Some(EXPLOSIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ExplosionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ExplosionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExplosionWindForceData {
    pub _glacier_base: super::core::DataContainer,
    pub strength: f32,
    pub variation: f32,
    pub variation_rate: f32,
    pub micro_variation: f32,
    pub hardness: f32,
    pub force_as_instant_velocity: f32,
    pub should_affect_vegetation: bool,
    pub should_affect_mesh_scattering: bool,
    pub should_affect_effects: bool,
    pub should_affect_cloth: bool,
    pub should_affect_physics: bool,
}

pub trait ExplosionWindForceDataTrait: super::core::DataContainerTrait {
    fn strength(&self) -> &f32;
    fn strength_mut(&mut self) -> &mut f32;
    fn variation(&self) -> &f32;
    fn variation_mut(&mut self) -> &mut f32;
    fn variation_rate(&self) -> &f32;
    fn variation_rate_mut(&mut self) -> &mut f32;
    fn micro_variation(&self) -> &f32;
    fn micro_variation_mut(&mut self) -> &mut f32;
    fn hardness(&self) -> &f32;
    fn hardness_mut(&mut self) -> &mut f32;
    fn force_as_instant_velocity(&self) -> &f32;
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32;
    fn should_affect_vegetation(&self) -> &bool;
    fn should_affect_vegetation_mut(&mut self) -> &mut bool;
    fn should_affect_mesh_scattering(&self) -> &bool;
    fn should_affect_mesh_scattering_mut(&mut self) -> &mut bool;
    fn should_affect_effects(&self) -> &bool;
    fn should_affect_effects_mut(&mut self) -> &mut bool;
    fn should_affect_cloth(&self) -> &bool;
    fn should_affect_cloth_mut(&mut self) -> &mut bool;
    fn should_affect_physics(&self) -> &bool;
    fn should_affect_physics_mut(&mut self) -> &mut bool;
}

impl ExplosionWindForceDataTrait for ExplosionWindForceData {
    fn strength(&self) -> &f32 {
        &self.strength
    }
    fn strength_mut(&mut self) -> &mut f32 {
        &mut self.strength
    }
    fn variation(&self) -> &f32 {
        &self.variation
    }
    fn variation_mut(&mut self) -> &mut f32 {
        &mut self.variation
    }
    fn variation_rate(&self) -> &f32 {
        &self.variation_rate
    }
    fn variation_rate_mut(&mut self) -> &mut f32 {
        &mut self.variation_rate
    }
    fn micro_variation(&self) -> &f32 {
        &self.micro_variation
    }
    fn micro_variation_mut(&mut self) -> &mut f32 {
        &mut self.micro_variation
    }
    fn hardness(&self) -> &f32 {
        &self.hardness
    }
    fn hardness_mut(&mut self) -> &mut f32 {
        &mut self.hardness
    }
    fn force_as_instant_velocity(&self) -> &f32 {
        &self.force_as_instant_velocity
    }
    fn force_as_instant_velocity_mut(&mut self) -> &mut f32 {
        &mut self.force_as_instant_velocity
    }
    fn should_affect_vegetation(&self) -> &bool {
        &self.should_affect_vegetation
    }
    fn should_affect_vegetation_mut(&mut self) -> &mut bool {
        &mut self.should_affect_vegetation
    }
    fn should_affect_mesh_scattering(&self) -> &bool {
        &self.should_affect_mesh_scattering
    }
    fn should_affect_mesh_scattering_mut(&mut self) -> &mut bool {
        &mut self.should_affect_mesh_scattering
    }
    fn should_affect_effects(&self) -> &bool {
        &self.should_affect_effects
    }
    fn should_affect_effects_mut(&mut self) -> &mut bool {
        &mut self.should_affect_effects
    }
    fn should_affect_cloth(&self) -> &bool {
        &self.should_affect_cloth
    }
    fn should_affect_cloth_mut(&mut self) -> &mut bool {
        &mut self.should_affect_cloth
    }
    fn should_affect_physics(&self) -> &bool {
        &self.should_affect_physics
    }
    fn should_affect_physics_mut(&mut self) -> &mut bool {
        &mut self.should_affect_physics
    }
}

impl super::core::DataContainerTrait for ExplosionWindForceData {
}

pub static EXPLOSIONWINDFORCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionWindForceData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExplosionWindForceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Strength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, strength),
            },
            FieldInfoData {
                name: "Variation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, variation),
            },
            FieldInfoData {
                name: "VariationRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, variation_rate),
            },
            FieldInfoData {
                name: "MicroVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, micro_variation),
            },
            FieldInfoData {
                name: "Hardness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, hardness),
            },
            FieldInfoData {
                name: "ForceAsInstantVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExplosionWindForceData, force_as_instant_velocity),
            },
            FieldInfoData {
                name: "ShouldAffectVegetation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_vegetation),
            },
            FieldInfoData {
                name: "ShouldAffectMeshScattering",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_mesh_scattering),
            },
            FieldInfoData {
                name: "ShouldAffectEffects",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_effects),
            },
            FieldInfoData {
                name: "ShouldAffectCloth",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_cloth),
            },
            FieldInfoData {
                name: "ShouldAffectPhysics",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExplosionWindForceData, should_affect_physics),
            },
        ],
    }),
    array_type: Some(EXPLOSIONWINDFORCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExplosionWindForceData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPLOSIONWINDFORCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPLOSIONWINDFORCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExplosionWindForceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ExplosionWindForceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DamageIndicationType {
    #[default]
    DamageIndicationType_GiverPlayer = 0,
    DamageIndicationType_ExplosionCenter = 1,
}

pub static DAMAGEINDICATIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageIndicationType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DAMAGEINDICATIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DamageIndicationType {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEINDICATIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DAMAGEINDICATIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageIndicationType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DamageIndicationType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicGamePhysicsEntityData {
    pub _glacier_base: super::physics::GamePhysicsEntityData,
}

pub trait DynamicGamePhysicsEntityDataTrait: super::physics::GamePhysicsEntityDataTrait {
}

impl DynamicGamePhysicsEntityDataTrait for DynamicGamePhysicsEntityData {
}

impl super::physics::GamePhysicsEntityDataTrait for DynamicGamePhysicsEntityData {
}

impl super::entity::GameComponentEntityDataTrait for DynamicGamePhysicsEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for DynamicGamePhysicsEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DynamicGamePhysicsEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DynamicGamePhysicsEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicGamePhysicsEntityData {
}

impl super::core::DataBusPeerTrait for DynamicGamePhysicsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicGamePhysicsEntityData {
}

impl super::core::DataContainerTrait for DynamicGamePhysicsEntityData {
}

pub static DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicGamePhysicsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::GAMEPHYSICSENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicGamePhysicsEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DYNAMICGAMEPHYSICSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicGamePhysicsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICGAMEPHYSICSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicGamePhysicsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicGamePhysicsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverAnimationComponentData {
    pub _glacier_base: super::entity::GameComponentData,
}

pub trait VoiceOverAnimationComponentDataTrait: super::entity::GameComponentDataTrait {
}

impl VoiceOverAnimationComponentDataTrait for VoiceOverAnimationComponentData {
}

impl super::entity::GameComponentDataTrait for VoiceOverAnimationComponentData {
}

impl super::entity::ComponentDataTrait for VoiceOverAnimationComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for VoiceOverAnimationComponentData {
}

impl super::core::DataBusPeerTrait for VoiceOverAnimationComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverAnimationComponentData {
}

impl super::core::DataContainerTrait for VoiceOverAnimationComponentData {
}

pub static VOICEOVERANIMATIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverAnimationComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverAnimationComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverAnimationComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERANIMATIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERANIMATIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverAnimationComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverAnimationComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverManagerControlEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait VoiceOverManagerControlEntityDataTrait: super::entity::EntityDataTrait {
}

impl VoiceOverManagerControlEntityDataTrait for VoiceOverManagerControlEntityData {
}

impl super::entity::EntityDataTrait for VoiceOverManagerControlEntityData {
}

impl super::entity::GameObjectDataTrait for VoiceOverManagerControlEntityData {
}

impl super::core::DataBusPeerTrait for VoiceOverManagerControlEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverManagerControlEntityData {
}

impl super::core::DataContainerTrait for VoiceOverManagerControlEntityData {
}

pub static VOICEOVERMANAGERCONTROLENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManagerControlEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverManagerControlEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERMANAGERCONTROLENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverManagerControlEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERMANAGERCONTROLENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERMANAGERCONTROLENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManagerControlEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverManagerControlEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DetachedSoundListenerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub fov: f32,
    pub radius: f32,
    pub transform: super::core::LinearTransform,
    pub velocity: super::core::Vec3,
    pub panning_position: super::core::Vec3,
}

pub trait DetachedSoundListenerEntityDataTrait: super::entity::EntityDataTrait {
    fn fov(&self) -> &f32;
    fn fov_mut(&mut self) -> &mut f32;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn velocity(&self) -> &super::core::Vec3;
    fn velocity_mut(&mut self) -> &mut super::core::Vec3;
    fn panning_position(&self) -> &super::core::Vec3;
    fn panning_position_mut(&mut self) -> &mut super::core::Vec3;
}

impl DetachedSoundListenerEntityDataTrait for DetachedSoundListenerEntityData {
    fn fov(&self) -> &f32 {
        &self.fov
    }
    fn fov_mut(&mut self) -> &mut f32 {
        &mut self.fov
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn velocity(&self) -> &super::core::Vec3 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.velocity
    }
    fn panning_position(&self) -> &super::core::Vec3 {
        &self.panning_position
    }
    fn panning_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.panning_position
    }
}

impl super::entity::EntityDataTrait for DetachedSoundListenerEntityData {
}

impl super::entity::GameObjectDataTrait for DetachedSoundListenerEntityData {
}

impl super::core::DataBusPeerTrait for DetachedSoundListenerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DetachedSoundListenerEntityData {
}

impl super::core::DataContainerTrait for DetachedSoundListenerEntityData {
}

pub static DETACHEDSOUNDLISTENERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetachedSoundListenerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DetachedSoundListenerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Fov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, fov),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, radius),
            },
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, transform),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, velocity),
            },
            FieldInfoData {
                name: "PanningPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DetachedSoundListenerEntityData, panning_position),
            },
        ],
    }),
    array_type: Some(DETACHEDSOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DetachedSoundListenerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DETACHEDSOUNDLISTENERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DETACHEDSOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DetachedSoundListenerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DetachedSoundListenerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundListenerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub local_player_id: super::core::LocalPlayerId,
    pub preserve_velocity: bool,
    pub fov: f32,
    pub radius: f32,
    pub transform: super::core::LinearTransform,
    pub velocity: super::core::Vec3,
    pub panning_position: super::core::Vec3,
}

pub trait SoundListenerEntityDataTrait: super::entity::EntityDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
    fn preserve_velocity(&self) -> &bool;
    fn preserve_velocity_mut(&mut self) -> &mut bool;
    fn fov(&self) -> &f32;
    fn fov_mut(&mut self) -> &mut f32;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn velocity(&self) -> &super::core::Vec3;
    fn velocity_mut(&mut self) -> &mut super::core::Vec3;
    fn panning_position(&self) -> &super::core::Vec3;
    fn panning_position_mut(&mut self) -> &mut super::core::Vec3;
}

impl SoundListenerEntityDataTrait for SoundListenerEntityData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
    fn preserve_velocity(&self) -> &bool {
        &self.preserve_velocity
    }
    fn preserve_velocity_mut(&mut self) -> &mut bool {
        &mut self.preserve_velocity
    }
    fn fov(&self) -> &f32 {
        &self.fov
    }
    fn fov_mut(&mut self) -> &mut f32 {
        &mut self.fov
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn velocity(&self) -> &super::core::Vec3 {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.velocity
    }
    fn panning_position(&self) -> &super::core::Vec3 {
        &self.panning_position
    }
    fn panning_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.panning_position
    }
}

impl super::entity::EntityDataTrait for SoundListenerEntityData {
}

impl super::entity::GameObjectDataTrait for SoundListenerEntityData {
}

impl super::core::DataBusPeerTrait for SoundListenerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundListenerEntityData {
}

impl super::core::DataContainerTrait for SoundListenerEntityData {
}

pub static SOUNDLISTENERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundListenerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundListenerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(SoundListenerEntityData, local_player_id),
            },
            FieldInfoData {
                name: "PreserveVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundListenerEntityData, preserve_velocity),
            },
            FieldInfoData {
                name: "Fov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundListenerEntityData, fov),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundListenerEntityData, radius),
            },
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SoundListenerEntityData, transform),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoundListenerEntityData, velocity),
            },
            FieldInfoData {
                name: "PanningPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SoundListenerEntityData, panning_position),
            },
        ],
    }),
    array_type: Some(SOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoundListenerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDLISTENERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDLISTENERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundListenerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SoundListenerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundAreaEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub big_world: Option<Arc<Mutex<dyn super::gameplay_sim::BigWorldSettingsAssetTrait>>>,
    pub perimeter_size: f32,
    pub relevance_multiplier: f32,
    pub min_relevance_budget: f32,
    pub relevance_falloff: super::audio::FadeCurveType,
    pub enable_on_creation: bool,
    pub priority: f32,
    pub use_legacy_behavior: bool,
    pub face_listener: bool,
    pub ignore_vertical_perimeter: bool,
}

pub trait SoundAreaEntityDataTrait: super::entity::EntityDataTrait {
    fn sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn big_world(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::BigWorldSettingsAssetTrait>>>;
    fn big_world_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::BigWorldSettingsAssetTrait>>>;
    fn perimeter_size(&self) -> &f32;
    fn perimeter_size_mut(&mut self) -> &mut f32;
    fn relevance_multiplier(&self) -> &f32;
    fn relevance_multiplier_mut(&mut self) -> &mut f32;
    fn min_relevance_budget(&self) -> &f32;
    fn min_relevance_budget_mut(&mut self) -> &mut f32;
    fn relevance_falloff(&self) -> &super::audio::FadeCurveType;
    fn relevance_falloff_mut(&mut self) -> &mut super::audio::FadeCurveType;
    fn enable_on_creation(&self) -> &bool;
    fn enable_on_creation_mut(&mut self) -> &mut bool;
    fn priority(&self) -> &f32;
    fn priority_mut(&mut self) -> &mut f32;
    fn use_legacy_behavior(&self) -> &bool;
    fn use_legacy_behavior_mut(&mut self) -> &mut bool;
    fn face_listener(&self) -> &bool;
    fn face_listener_mut(&mut self) -> &mut bool;
    fn ignore_vertical_perimeter(&self) -> &bool;
    fn ignore_vertical_perimeter_mut(&mut self) -> &mut bool;
}

impl SoundAreaEntityDataTrait for SoundAreaEntityData {
    fn sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.sound
    }
    fn big_world(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::BigWorldSettingsAssetTrait>>> {
        &self.big_world
    }
    fn big_world_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::BigWorldSettingsAssetTrait>>> {
        &mut self.big_world
    }
    fn perimeter_size(&self) -> &f32 {
        &self.perimeter_size
    }
    fn perimeter_size_mut(&mut self) -> &mut f32 {
        &mut self.perimeter_size
    }
    fn relevance_multiplier(&self) -> &f32 {
        &self.relevance_multiplier
    }
    fn relevance_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.relevance_multiplier
    }
    fn min_relevance_budget(&self) -> &f32 {
        &self.min_relevance_budget
    }
    fn min_relevance_budget_mut(&mut self) -> &mut f32 {
        &mut self.min_relevance_budget
    }
    fn relevance_falloff(&self) -> &super::audio::FadeCurveType {
        &self.relevance_falloff
    }
    fn relevance_falloff_mut(&mut self) -> &mut super::audio::FadeCurveType {
        &mut self.relevance_falloff
    }
    fn enable_on_creation(&self) -> &bool {
        &self.enable_on_creation
    }
    fn enable_on_creation_mut(&mut self) -> &mut bool {
        &mut self.enable_on_creation
    }
    fn priority(&self) -> &f32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut f32 {
        &mut self.priority
    }
    fn use_legacy_behavior(&self) -> &bool {
        &self.use_legacy_behavior
    }
    fn use_legacy_behavior_mut(&mut self) -> &mut bool {
        &mut self.use_legacy_behavior
    }
    fn face_listener(&self) -> &bool {
        &self.face_listener
    }
    fn face_listener_mut(&mut self) -> &mut bool {
        &mut self.face_listener
    }
    fn ignore_vertical_perimeter(&self) -> &bool {
        &self.ignore_vertical_perimeter
    }
    fn ignore_vertical_perimeter_mut(&mut self) -> &mut bool {
        &mut self.ignore_vertical_perimeter
    }
}

impl super::entity::EntityDataTrait for SoundAreaEntityData {
}

impl super::entity::GameObjectDataTrait for SoundAreaEntityData {
}

impl super::core::DataBusPeerTrait for SoundAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundAreaEntityData {
}

impl super::core::DataContainerTrait for SoundAreaEntityData {
}

pub static SOUNDAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundAreaEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoundAreaEntityData, sound),
            },
            FieldInfoData {
                name: "BigWorld",
                flags: MemberInfoFlags::new(0),
                field_type: "BigWorldSettingsAsset",
                rust_offset: offset_of!(SoundAreaEntityData, big_world),
            },
            FieldInfoData {
                name: "PerimeterSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundAreaEntityData, perimeter_size),
            },
            FieldInfoData {
                name: "RelevanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundAreaEntityData, relevance_multiplier),
            },
            FieldInfoData {
                name: "MinRelevanceBudget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundAreaEntityData, min_relevance_budget),
            },
            FieldInfoData {
                name: "RelevanceFalloff",
                flags: MemberInfoFlags::new(0),
                field_type: "FadeCurveType",
                rust_offset: offset_of!(SoundAreaEntityData, relevance_falloff),
            },
            FieldInfoData {
                name: "EnableOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundAreaEntityData, enable_on_creation),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundAreaEntityData, priority),
            },
            FieldInfoData {
                name: "UseLegacyBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundAreaEntityData, use_legacy_behavior),
            },
            FieldInfoData {
                name: "FaceListener",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundAreaEntityData, face_listener),
            },
            FieldInfoData {
                name: "IgnoreVerticalPerimeter",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundAreaEntityData, ignore_vertical_perimeter),
            },
        ],
    }),
    array_type: Some(SOUNDAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SoundAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConversationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub conversation: super::audio::VoiceOverConversationInfo,
    pub track_infos: Vec<VoiceOverConversationEntityTrackInfo>,
    pub trigger_delay: f32,
    pub finished_delay: f32,
    pub run_once: bool,
    pub needs_trigger_result: bool,
    pub pronunciation_index: i32,
    pub cancel_on_deinit: bool,
    pub referenced_wave_files: Vec<String>,
}

pub trait VoiceOverConversationEntityDataTrait: super::entity::EntityDataTrait {
    fn conversation(&self) -> &super::audio::VoiceOverConversationInfo;
    fn conversation_mut(&mut self) -> &mut super::audio::VoiceOverConversationInfo;
    fn track_infos(&self) -> &Vec<VoiceOverConversationEntityTrackInfo>;
    fn track_infos_mut(&mut self) -> &mut Vec<VoiceOverConversationEntityTrackInfo>;
    fn trigger_delay(&self) -> &f32;
    fn trigger_delay_mut(&mut self) -> &mut f32;
    fn finished_delay(&self) -> &f32;
    fn finished_delay_mut(&mut self) -> &mut f32;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn needs_trigger_result(&self) -> &bool;
    fn needs_trigger_result_mut(&mut self) -> &mut bool;
    fn pronunciation_index(&self) -> &i32;
    fn pronunciation_index_mut(&mut self) -> &mut i32;
    fn cancel_on_deinit(&self) -> &bool;
    fn cancel_on_deinit_mut(&mut self) -> &mut bool;
    fn referenced_wave_files(&self) -> &Vec<String>;
    fn referenced_wave_files_mut(&mut self) -> &mut Vec<String>;
}

impl VoiceOverConversationEntityDataTrait for VoiceOverConversationEntityData {
    fn conversation(&self) -> &super::audio::VoiceOverConversationInfo {
        &self.conversation
    }
    fn conversation_mut(&mut self) -> &mut super::audio::VoiceOverConversationInfo {
        &mut self.conversation
    }
    fn track_infos(&self) -> &Vec<VoiceOverConversationEntityTrackInfo> {
        &self.track_infos
    }
    fn track_infos_mut(&mut self) -> &mut Vec<VoiceOverConversationEntityTrackInfo> {
        &mut self.track_infos
    }
    fn trigger_delay(&self) -> &f32 {
        &self.trigger_delay
    }
    fn trigger_delay_mut(&mut self) -> &mut f32 {
        &mut self.trigger_delay
    }
    fn finished_delay(&self) -> &f32 {
        &self.finished_delay
    }
    fn finished_delay_mut(&mut self) -> &mut f32 {
        &mut self.finished_delay
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn needs_trigger_result(&self) -> &bool {
        &self.needs_trigger_result
    }
    fn needs_trigger_result_mut(&mut self) -> &mut bool {
        &mut self.needs_trigger_result
    }
    fn pronunciation_index(&self) -> &i32 {
        &self.pronunciation_index
    }
    fn pronunciation_index_mut(&mut self) -> &mut i32 {
        &mut self.pronunciation_index
    }
    fn cancel_on_deinit(&self) -> &bool {
        &self.cancel_on_deinit
    }
    fn cancel_on_deinit_mut(&mut self) -> &mut bool {
        &mut self.cancel_on_deinit
    }
    fn referenced_wave_files(&self) -> &Vec<String> {
        &self.referenced_wave_files
    }
    fn referenced_wave_files_mut(&mut self) -> &mut Vec<String> {
        &mut self.referenced_wave_files
    }
}

impl super::entity::EntityDataTrait for VoiceOverConversationEntityData {
}

impl super::entity::GameObjectDataTrait for VoiceOverConversationEntityData {
}

impl super::core::DataBusPeerTrait for VoiceOverConversationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverConversationEntityData {
}

impl super::core::DataContainerTrait for VoiceOverConversationEntityData {
}

pub static VOICEOVERCONVERSATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Conversation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationInfo",
                rust_offset: offset_of!(VoiceOverConversationEntityData, conversation),
            },
            FieldInfoData {
                name: "TrackInfos",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverConversationEntityTrackInfo-Array",
                rust_offset: offset_of!(VoiceOverConversationEntityData, track_infos),
            },
            FieldInfoData {
                name: "TriggerDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverConversationEntityData, trigger_delay),
            },
            FieldInfoData {
                name: "FinishedDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverConversationEntityData, finished_delay),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverConversationEntityData, run_once),
            },
            FieldInfoData {
                name: "NeedsTriggerResult",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverConversationEntityData, needs_trigger_result),
            },
            FieldInfoData {
                name: "PronunciationIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VoiceOverConversationEntityData, pronunciation_index),
            },
            FieldInfoData {
                name: "CancelOnDeinit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverConversationEntityData, cancel_on_deinit),
            },
            FieldInfoData {
                name: "ReferencedWaveFiles",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(VoiceOverConversationEntityData, referenced_wave_files),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONVERSATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverConversationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConversationEntityTrackInfo {
    pub take_control_id: u32,
    pub source_id: u32,
}

pub trait VoiceOverConversationEntityTrackInfoTrait: TypeObject {
    fn take_control_id(&self) -> &u32;
    fn take_control_id_mut(&mut self) -> &mut u32;
    fn source_id(&self) -> &u32;
    fn source_id_mut(&mut self) -> &mut u32;
}

impl VoiceOverConversationEntityTrackInfoTrait for VoiceOverConversationEntityTrackInfo {
    fn take_control_id(&self) -> &u32 {
        &self.take_control_id
    }
    fn take_control_id_mut(&mut self) -> &mut u32 {
        &mut self.take_control_id
    }
    fn source_id(&self) -> &u32 {
        &self.source_id
    }
    fn source_id_mut(&mut self) -> &mut u32 {
        &mut self.source_id
    }
}

pub static VOICEOVERCONVERSATIONENTITYTRACKINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationEntityTrackInfo",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationEntityTrackInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TakeControlId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverConversationEntityTrackInfo, take_control_id),
            },
            FieldInfoData {
                name: "SourceId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverConversationEntityTrackInfo, source_id),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONENTITYTRACKINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VoiceOverConversationEntityTrackInfo {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONENTITYTRACKINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERCONVERSATIONENTITYTRACKINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationEntityTrackInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverConversationEntityTrackInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub vo_event: Option<Arc<Mutex<dyn super::audio::VoiceOverEventTrait>>>,
    pub event_player: Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>>,
    pub extra_event_player: Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>>,
    pub trigger_delay: f32,
    pub finished_delay: f32,
    pub run_once: bool,
    pub cancel_on_deinit: bool,
}

pub trait VoiceOverEventEntityDataTrait: super::entity::EntityDataTrait {
    fn vo_event(&self) -> &Option<Arc<Mutex<dyn super::audio::VoiceOverEventTrait>>>;
    fn vo_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::VoiceOverEventTrait>>>;
    fn event_player(&self) -> &Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>>;
    fn event_player_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>>;
    fn extra_event_player(&self) -> &Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>>;
    fn extra_event_player_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>>;
    fn trigger_delay(&self) -> &f32;
    fn trigger_delay_mut(&mut self) -> &mut f32;
    fn finished_delay(&self) -> &f32;
    fn finished_delay_mut(&mut self) -> &mut f32;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn cancel_on_deinit(&self) -> &bool;
    fn cancel_on_deinit_mut(&mut self) -> &mut bool;
}

impl VoiceOverEventEntityDataTrait for VoiceOverEventEntityData {
    fn vo_event(&self) -> &Option<Arc<Mutex<dyn super::audio::VoiceOverEventTrait>>> {
        &self.vo_event
    }
    fn vo_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::VoiceOverEventTrait>>> {
        &mut self.vo_event
    }
    fn event_player(&self) -> &Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>> {
        &self.event_player
    }
    fn event_player_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>> {
        &mut self.event_player
    }
    fn extra_event_player(&self) -> &Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>> {
        &self.extra_event_player
    }
    fn extra_event_player_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::VoiceOverNamedValueTrait>>> {
        &mut self.extra_event_player
    }
    fn trigger_delay(&self) -> &f32 {
        &self.trigger_delay
    }
    fn trigger_delay_mut(&mut self) -> &mut f32 {
        &mut self.trigger_delay
    }
    fn finished_delay(&self) -> &f32 {
        &self.finished_delay
    }
    fn finished_delay_mut(&mut self) -> &mut f32 {
        &mut self.finished_delay
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn cancel_on_deinit(&self) -> &bool {
        &self.cancel_on_deinit
    }
    fn cancel_on_deinit_mut(&mut self) -> &mut bool {
        &mut self.cancel_on_deinit
    }
}

impl super::entity::EntityDataTrait for VoiceOverEventEntityData {
}

impl super::entity::GameObjectDataTrait for VoiceOverEventEntityData {
}

impl super::core::DataBusPeerTrait for VoiceOverEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverEventEntityData {
}

impl super::core::DataContainerTrait for VoiceOverEventEntityData {
}

pub static VOICEOVEREVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VoEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverEvent",
                rust_offset: offset_of!(VoiceOverEventEntityData, vo_event),
            },
            FieldInfoData {
                name: "EventPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverEventEntityData, event_player),
            },
            FieldInfoData {
                name: "ExtraEventPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverEventEntityData, extra_event_player),
            },
            FieldInfoData {
                name: "TriggerDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverEventEntityData, trigger_delay),
            },
            FieldInfoData {
                name: "FinishedDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverEventEntityData, finished_delay),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverEventEntityData, run_once),
            },
            FieldInfoData {
                name: "CancelOnDeinit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverEventEntityData, cancel_on_deinit),
            },
        ],
    }),
    array_type: Some(VOICEOVEREVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEREVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVEREVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VoiceOverEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayAnimationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub animation: Option<Arc<Mutex<dyn PlayAnimationDataTrait>>>,
    pub animation_blend_in_time: f32,
    pub animation_blend_out_time: f32,
    pub replicated: bool,
    pub trigger_if_culled: bool,
    pub external_time: f32,
    pub life_time: f32,
    pub entity_space0: super::core::LinearTransform,
    pub entity_space1: super::core::LinearTransform,
    pub entity_space2: super::core::LinearTransform,
    pub entity_space3: super::core::LinearTransform,
    pub entity_space4: super::core::LinearTransform,
    pub align_value: f32,
}

pub trait PlayAnimationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn animation(&self) -> &Option<Arc<Mutex<dyn PlayAnimationDataTrait>>>;
    fn animation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PlayAnimationDataTrait>>>;
    fn animation_blend_in_time(&self) -> &f32;
    fn animation_blend_in_time_mut(&mut self) -> &mut f32;
    fn animation_blend_out_time(&self) -> &f32;
    fn animation_blend_out_time_mut(&mut self) -> &mut f32;
    fn replicated(&self) -> &bool;
    fn replicated_mut(&mut self) -> &mut bool;
    fn trigger_if_culled(&self) -> &bool;
    fn trigger_if_culled_mut(&mut self) -> &mut bool;
    fn external_time(&self) -> &f32;
    fn external_time_mut(&mut self) -> &mut f32;
    fn life_time(&self) -> &f32;
    fn life_time_mut(&mut self) -> &mut f32;
    fn entity_space0(&self) -> &super::core::LinearTransform;
    fn entity_space0_mut(&mut self) -> &mut super::core::LinearTransform;
    fn entity_space1(&self) -> &super::core::LinearTransform;
    fn entity_space1_mut(&mut self) -> &mut super::core::LinearTransform;
    fn entity_space2(&self) -> &super::core::LinearTransform;
    fn entity_space2_mut(&mut self) -> &mut super::core::LinearTransform;
    fn entity_space3(&self) -> &super::core::LinearTransform;
    fn entity_space3_mut(&mut self) -> &mut super::core::LinearTransform;
    fn entity_space4(&self) -> &super::core::LinearTransform;
    fn entity_space4_mut(&mut self) -> &mut super::core::LinearTransform;
    fn align_value(&self) -> &f32;
    fn align_value_mut(&mut self) -> &mut f32;
}

impl PlayAnimationEntityDataTrait for PlayAnimationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn animation(&self) -> &Option<Arc<Mutex<dyn PlayAnimationDataTrait>>> {
        &self.animation
    }
    fn animation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PlayAnimationDataTrait>>> {
        &mut self.animation
    }
    fn animation_blend_in_time(&self) -> &f32 {
        &self.animation_blend_in_time
    }
    fn animation_blend_in_time_mut(&mut self) -> &mut f32 {
        &mut self.animation_blend_in_time
    }
    fn animation_blend_out_time(&self) -> &f32 {
        &self.animation_blend_out_time
    }
    fn animation_blend_out_time_mut(&mut self) -> &mut f32 {
        &mut self.animation_blend_out_time
    }
    fn replicated(&self) -> &bool {
        &self.replicated
    }
    fn replicated_mut(&mut self) -> &mut bool {
        &mut self.replicated
    }
    fn trigger_if_culled(&self) -> &bool {
        &self.trigger_if_culled
    }
    fn trigger_if_culled_mut(&mut self) -> &mut bool {
        &mut self.trigger_if_culled
    }
    fn external_time(&self) -> &f32 {
        &self.external_time
    }
    fn external_time_mut(&mut self) -> &mut f32 {
        &mut self.external_time
    }
    fn life_time(&self) -> &f32 {
        &self.life_time
    }
    fn life_time_mut(&mut self) -> &mut f32 {
        &mut self.life_time
    }
    fn entity_space0(&self) -> &super::core::LinearTransform {
        &self.entity_space0
    }
    fn entity_space0_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space0
    }
    fn entity_space1(&self) -> &super::core::LinearTransform {
        &self.entity_space1
    }
    fn entity_space1_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space1
    }
    fn entity_space2(&self) -> &super::core::LinearTransform {
        &self.entity_space2
    }
    fn entity_space2_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space2
    }
    fn entity_space3(&self) -> &super::core::LinearTransform {
        &self.entity_space3
    }
    fn entity_space3_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space3
    }
    fn entity_space4(&self) -> &super::core::LinearTransform {
        &self.entity_space4
    }
    fn entity_space4_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity_space4
    }
    fn align_value(&self) -> &f32 {
        &self.align_value
    }
    fn align_value_mut(&mut self) -> &mut f32 {
        &mut self.align_value
    }
}

impl super::entity::EntityDataTrait for PlayAnimationEntityData {
}

impl super::entity::GameObjectDataTrait for PlayAnimationEntityData {
}

impl super::core::DataBusPeerTrait for PlayAnimationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayAnimationEntityData {
}

impl super::core::DataContainerTrait for PlayAnimationEntityData {
}

pub static PLAYANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayAnimationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayAnimationEntityData, realm),
            },
            FieldInfoData {
                name: "Animation",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayAnimationData",
                rust_offset: offset_of!(PlayAnimationEntityData, animation),
            },
            FieldInfoData {
                name: "AnimationBlendInTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, animation_blend_in_time),
            },
            FieldInfoData {
                name: "AnimationBlendOutTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, animation_blend_out_time),
            },
            FieldInfoData {
                name: "Replicated",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayAnimationEntityData, replicated),
            },
            FieldInfoData {
                name: "TriggerIfCulled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayAnimationEntityData, trigger_if_culled),
            },
            FieldInfoData {
                name: "ExternalTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, external_time),
            },
            FieldInfoData {
                name: "LifeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, life_time),
            },
            FieldInfoData {
                name: "EntitySpace0",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space0),
            },
            FieldInfoData {
                name: "EntitySpace1",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space1),
            },
            FieldInfoData {
                name: "EntitySpace2",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space2),
            },
            FieldInfoData {
                name: "EntitySpace3",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space3),
            },
            FieldInfoData {
                name: "EntitySpace4",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PlayAnimationEntityData, entity_space4),
            },
            FieldInfoData {
                name: "AlignValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayAnimationEntityData, align_value),
            },
        ],
    }),
    array_type: Some(PLAYANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayAnimationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYANIMATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayAnimationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ServerPlayAnimationStartedMessage {
}

pub trait ServerPlayAnimationStartedMessageTrait: TypeObject {
}

impl ServerPlayAnimationStartedMessageTrait for ServerPlayAnimationStartedMessage {
}

pub static SERVERPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerPlayAnimationStartedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerPlayAnimationStartedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ServerPlayAnimationStartedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct ClientPlayAnimationStartedMessage {
}

pub trait ClientPlayAnimationStartedMessageTrait: TypeObject {
}

impl ClientPlayAnimationStartedMessageTrait for ClientPlayAnimationStartedMessage {
}

pub static CLIENTPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayAnimationStartedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientPlayAnimationStartedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ClientPlayAnimationStartedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPLAYANIMATIONSTARTEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct PlayAnimationData {
    pub _glacier_base: super::core::DataContainer,
    pub controller: super::ant::AntRef,
    pub looping: bool,
}

pub trait PlayAnimationDataTrait: super::core::DataContainerTrait {
    fn controller(&self) -> &super::ant::AntRef;
    fn controller_mut(&mut self) -> &mut super::ant::AntRef;
    fn looping(&self) -> &bool;
    fn looping_mut(&mut self) -> &mut bool;
}

impl PlayAnimationDataTrait for PlayAnimationData {
    fn controller(&self) -> &super::ant::AntRef {
        &self.controller
    }
    fn controller_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.controller
    }
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn looping_mut(&mut self) -> &mut bool {
        &mut self.looping
    }
}

impl super::core::DataContainerTrait for PlayAnimationData {
}

pub static PLAYANIMATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayAnimationData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Controller",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(PlayAnimationData, controller),
            },
            FieldInfoData {
                name: "Looping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayAnimationData, looping),
            },
        ],
    }),
    array_type: Some(PLAYANIMATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayAnimationData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYANIMATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYANIMATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayAnimationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayAnimationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FbProxyControllerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub canned_anim_binding: FbProxyControllerEntityBinding,
    pub animation_entity_space_priority: i32,
    pub always_clear_entity_space_when_in_scenario: bool,
    pub pointer_game_state: super::ant::AntRef,
}

pub trait FbProxyControllerEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn canned_anim_binding(&self) -> &FbProxyControllerEntityBinding;
    fn canned_anim_binding_mut(&mut self) -> &mut FbProxyControllerEntityBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn always_clear_entity_space_when_in_scenario(&self) -> &bool;
    fn always_clear_entity_space_when_in_scenario_mut(&mut self) -> &mut bool;
    fn pointer_game_state(&self) -> &super::ant::AntRef;
    fn pointer_game_state_mut(&mut self) -> &mut super::ant::AntRef;
}

impl FbProxyControllerEntityDataTrait for FbProxyControllerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn canned_anim_binding(&self) -> &FbProxyControllerEntityBinding {
        &self.canned_anim_binding
    }
    fn canned_anim_binding_mut(&mut self) -> &mut FbProxyControllerEntityBinding {
        &mut self.canned_anim_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn always_clear_entity_space_when_in_scenario(&self) -> &bool {
        &self.always_clear_entity_space_when_in_scenario
    }
    fn always_clear_entity_space_when_in_scenario_mut(&mut self) -> &mut bool {
        &mut self.always_clear_entity_space_when_in_scenario
    }
    fn pointer_game_state(&self) -> &super::ant::AntRef {
        &self.pointer_game_state
    }
    fn pointer_game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.pointer_game_state
    }
}

impl super::entity::EntityDataTrait for FbProxyControllerEntityData {
}

impl super::entity::GameObjectDataTrait for FbProxyControllerEntityData {
}

impl super::core::DataBusPeerTrait for FbProxyControllerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FbProxyControllerEntityData {
}

impl super::core::DataContainerTrait for FbProxyControllerEntityData {
}

pub static FBPROXYCONTROLLERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FbProxyControllerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FbProxyControllerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(FbProxyControllerEntityData, realm),
            },
            FieldInfoData {
                name: "CannedAnimBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "FbProxyControllerEntityBinding",
                rust_offset: offset_of!(FbProxyControllerEntityData, canned_anim_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FbProxyControllerEntityData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "AlwaysClearEntitySpaceWhenInScenario",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FbProxyControllerEntityData, always_clear_entity_space_when_in_scenario),
            },
            FieldInfoData {
                name: "PointerGameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityData, pointer_game_state),
            },
        ],
    }),
    array_type: Some(FBPROXYCONTROLLERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FbProxyControllerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FBPROXYCONTROLLERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FBPROXYCONTROLLERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FbProxyControllerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FbProxyControllerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FbProxyControllerEntityBinding {
    pub trigger: super::ant::AntRef,
    pub stop: super::ant::AntRef,
    pub blend_in_time: super::ant::AntRef,
    pub blend_out_time: super::ant::AntRef,
}

pub trait FbProxyControllerEntityBindingTrait: TypeObject {
    fn trigger(&self) -> &super::ant::AntRef;
    fn trigger_mut(&mut self) -> &mut super::ant::AntRef;
    fn stop(&self) -> &super::ant::AntRef;
    fn stop_mut(&mut self) -> &mut super::ant::AntRef;
    fn blend_in_time(&self) -> &super::ant::AntRef;
    fn blend_in_time_mut(&mut self) -> &mut super::ant::AntRef;
    fn blend_out_time(&self) -> &super::ant::AntRef;
    fn blend_out_time_mut(&mut self) -> &mut super::ant::AntRef;
}

impl FbProxyControllerEntityBindingTrait for FbProxyControllerEntityBinding {
    fn trigger(&self) -> &super::ant::AntRef {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.trigger
    }
    fn stop(&self) -> &super::ant::AntRef {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.stop
    }
    fn blend_in_time(&self) -> &super::ant::AntRef {
        &self.blend_in_time
    }
    fn blend_in_time_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.blend_in_time
    }
    fn blend_out_time(&self) -> &super::ant::AntRef {
        &self.blend_out_time
    }
    fn blend_out_time_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.blend_out_time
    }
}

pub static FBPROXYCONTROLLERENTITYBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FbProxyControllerEntityBinding",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FbProxyControllerEntityBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityBinding, trigger),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityBinding, stop),
            },
            FieldInfoData {
                name: "BlendInTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityBinding, blend_in_time),
            },
            FieldInfoData {
                name: "BlendOutTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FbProxyControllerEntityBinding, blend_out_time),
            },
        ],
    }),
    array_type: Some(FBPROXYCONTROLLERENTITYBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FbProxyControllerEntityBinding {
    fn type_info(&self) -> &'static TypeInfo {
        FBPROXYCONTROLLERENTITYBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FBPROXYCONTROLLERENTITYBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FbProxyControllerEntityBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FbProxyControllerEntityBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FaceposerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub face_poser_library: super::ant::AntRef,
    pub set_face_poser_library_on_spawn: bool,
}

pub trait FaceposerEntityDataTrait: super::entity::EntityDataTrait {
    fn face_poser_library(&self) -> &super::ant::AntRef;
    fn face_poser_library_mut(&mut self) -> &mut super::ant::AntRef;
    fn set_face_poser_library_on_spawn(&self) -> &bool;
    fn set_face_poser_library_on_spawn_mut(&mut self) -> &mut bool;
}

impl FaceposerEntityDataTrait for FaceposerEntityData {
    fn face_poser_library(&self) -> &super::ant::AntRef {
        &self.face_poser_library
    }
    fn face_poser_library_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.face_poser_library
    }
    fn set_face_poser_library_on_spawn(&self) -> &bool {
        &self.set_face_poser_library_on_spawn
    }
    fn set_face_poser_library_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.set_face_poser_library_on_spawn
    }
}

impl super::entity::EntityDataTrait for FaceposerEntityData {
}

impl super::entity::GameObjectDataTrait for FaceposerEntityData {
}

impl super::core::DataBusPeerTrait for FaceposerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FaceposerEntityData {
}

impl super::core::DataContainerTrait for FaceposerEntityData {
}

pub static FACEPOSERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaceposerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FaceposerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FacePoserLibrary",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(FaceposerEntityData, face_poser_library),
            },
            FieldInfoData {
                name: "SetFacePoserLibraryOnSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FaceposerEntityData, set_face_poser_library_on_spawn),
            },
        ],
    }),
    array_type: Some(FACEPOSERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FaceposerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FACEPOSERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FACEPOSERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaceposerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FaceposerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSyncReachedClientMessage {
}

pub trait EventSyncReachedClientMessageTrait: TypeObject {
}

impl EventSyncReachedClientMessageTrait for EventSyncReachedClientMessage {
}

pub static EVENTSYNCREACHEDCLIENTMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSyncReachedClientMessage",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSyncReachedClientMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for EventSyncReachedClientMessage {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSYNCREACHEDCLIENTMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct EventSyncEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub local_player_id: super::core::LocalPlayerId,
}

pub trait EventSyncEntityDataTrait: super::entity::EntityDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
}

impl EventSyncEntityDataTrait for EventSyncEntityData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
}

impl super::entity::EntityDataTrait for EventSyncEntityData {
}

impl super::entity::GameObjectDataTrait for EventSyncEntityData {
}

impl super::core::DataBusPeerTrait for EventSyncEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EventSyncEntityData {
}

impl super::core::DataContainerTrait for EventSyncEntityData {
}

pub static EVENTSYNCENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSyncEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSyncEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(EventSyncEntityData, local_player_id),
            },
        ],
    }),
    array_type: Some(EVENTSYNCENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSyncEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSYNCENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSYNCENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSyncEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EventSyncEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterEntryComponentData {
    pub _glacier_base: GameEntryComponentData,
    pub aiming_constraints: super::gameplay_sim::AimingConstraintsData,
}

pub trait CharacterEntryComponentDataTrait: GameEntryComponentDataTrait {
    fn aiming_constraints(&self) -> &super::gameplay_sim::AimingConstraintsData;
    fn aiming_constraints_mut(&mut self) -> &mut super::gameplay_sim::AimingConstraintsData;
}

impl CharacterEntryComponentDataTrait for CharacterEntryComponentData {
    fn aiming_constraints(&self) -> &super::gameplay_sim::AimingConstraintsData {
        &self.aiming_constraints
    }
    fn aiming_constraints_mut(&mut self) -> &mut super::gameplay_sim::AimingConstraintsData {
        &mut self.aiming_constraints
    }
}

impl GameEntryComponentDataTrait for CharacterEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        self._glacier_base.lock_soldier_aiming_to_entry()
    }
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.lock_soldier_aiming_to_entry_mut()
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.soldier_offset()
    }
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.soldier_offset_mut()
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for CharacterEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn entry_class_mut(&mut self) -> &mut super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class_mut()
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data_mut()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn forbidden_for_human_mut(&mut self) -> &mut bool {
        self._glacier_base.forbidden_for_human_mut()
    }
    fn input_graph(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph()
    }
    fn input_graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph_mut()
    }
    fn input_concept_definition(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition()
    }
    fn input_concept_definition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition_mut()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn action_map_settings_flip_y_scheme_override_mut(&mut self) -> &mut i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override_mut()
    }
    fn input_mapping(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping()
    }
    fn input_mapping_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping_mut()
    }
    fn input_curves(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves()
    }
    fn input_curves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves_mut()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn hud_data_mut(&mut self) -> &mut super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data_mut()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn entry_order_number_mut(&mut self) -> &mut i32 {
        self._glacier_base.entry_order_number_mut()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn enter_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.enter_impulse_mut()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn entry_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.entry_radius_mut()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn is_allowed_to_exit_in_air_mut(&mut self) -> &mut bool {
        self._glacier_base.is_allowed_to_exit_in_air_mut()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn clear_path_to_exit_point_start_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset_mut()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn is_shielded_mut(&mut self) -> &mut bool {
        self._glacier_base.is_shielded_mut()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_in_entry_mut()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn show1p_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_mut()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn soldier_transition_invisble_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.soldier_transition_invisble_time_mut()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn entry_spotting_settings_mut(&mut self) -> &mut super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings_mut()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_weapon_in_entry_mut()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show1p_soldier_in_entry_for_player_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only_mut()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show3p_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show3p_soldier_weapon_in_entry_mut()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn show_soldier_gear_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_gear_in_entry_mut()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn pose_constraints_mut(&mut self) -> &mut super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints_mut()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn use_local_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_local_transform_mut()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn trigger_event_on_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.trigger_event_on_key_mut()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn allow_ragdoll_from_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_ragdoll_from_entry_mut()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
    fn camera_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.camera_index_mut()
    }
}

impl super::entity::GameComponentDataTrait for CharacterEntryComponentData {
}

impl super::entity::ComponentDataTrait for CharacterEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterEntryComponentData {
}

impl super::core::DataBusPeerTrait for CharacterEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterEntryComponentData {
}

impl super::core::DataContainerTrait for CharacterEntryComponentData {
}

pub static CHARACTERENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEENTRYCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterEntryComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AimingConstraints",
                flags: MemberInfoFlags::new(0),
                field_type: "AimingConstraintsData",
                rust_offset: offset_of!(CharacterEntryComponentData, aiming_constraints),
            },
        ],
    }),
    array_type: Some(CHARACTERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterEntryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerEntryComponentData {
    pub _glacier_base: GameEntryComponentData,
    pub ant_entry_i_d: String,
    pub ant_entry_id: AntEntryIdEnum,
    pub ant_entry_enumeration: Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>,
    pub animation_acceleration_multiplier: super::core::Vec3,
}

pub trait PlayerEntryComponentDataTrait: GameEntryComponentDataTrait {
    fn ant_entry_i_d(&self) -> &String;
    fn ant_entry_i_d_mut(&mut self) -> &mut String;
    fn ant_entry_id(&self) -> &AntEntryIdEnum;
    fn ant_entry_id_mut(&mut self) -> &mut AntEntryIdEnum;
    fn ant_entry_enumeration(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn ant_entry_enumeration_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3;
    fn animation_acceleration_multiplier_mut(&mut self) -> &mut super::core::Vec3;
}

impl PlayerEntryComponentDataTrait for PlayerEntryComponentData {
    fn ant_entry_i_d(&self) -> &String {
        &self.ant_entry_i_d
    }
    fn ant_entry_i_d_mut(&mut self) -> &mut String {
        &mut self.ant_entry_i_d
    }
    fn ant_entry_id(&self) -> &AntEntryIdEnum {
        &self.ant_entry_id
    }
    fn ant_entry_id_mut(&mut self) -> &mut AntEntryIdEnum {
        &mut self.ant_entry_id
    }
    fn ant_entry_enumeration(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &self.ant_entry_enumeration
    }
    fn ant_entry_enumeration_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &mut self.ant_entry_enumeration
    }
    fn animation_acceleration_multiplier(&self) -> &super::core::Vec3 {
        &self.animation_acceleration_multiplier
    }
    fn animation_acceleration_multiplier_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.animation_acceleration_multiplier
    }
}

impl GameEntryComponentDataTrait for PlayerEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        self._glacier_base.lock_soldier_aiming_to_entry()
    }
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.lock_soldier_aiming_to_entry_mut()
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.soldier_offset()
    }
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.soldier_offset_mut()
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for PlayerEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn entry_class_mut(&mut self) -> &mut super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class_mut()
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data_mut()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn forbidden_for_human_mut(&mut self) -> &mut bool {
        self._glacier_base.forbidden_for_human_mut()
    }
    fn input_graph(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph()
    }
    fn input_graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph_mut()
    }
    fn input_concept_definition(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition()
    }
    fn input_concept_definition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition_mut()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn action_map_settings_flip_y_scheme_override_mut(&mut self) -> &mut i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override_mut()
    }
    fn input_mapping(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping()
    }
    fn input_mapping_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping_mut()
    }
    fn input_curves(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves()
    }
    fn input_curves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves_mut()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn hud_data_mut(&mut self) -> &mut super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data_mut()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn entry_order_number_mut(&mut self) -> &mut i32 {
        self._glacier_base.entry_order_number_mut()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn enter_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.enter_impulse_mut()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn entry_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.entry_radius_mut()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn is_allowed_to_exit_in_air_mut(&mut self) -> &mut bool {
        self._glacier_base.is_allowed_to_exit_in_air_mut()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn clear_path_to_exit_point_start_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset_mut()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn is_shielded_mut(&mut self) -> &mut bool {
        self._glacier_base.is_shielded_mut()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_in_entry_mut()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn show1p_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_mut()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn soldier_transition_invisble_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.soldier_transition_invisble_time_mut()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn entry_spotting_settings_mut(&mut self) -> &mut super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings_mut()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_weapon_in_entry_mut()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show1p_soldier_in_entry_for_player_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only_mut()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show3p_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show3p_soldier_weapon_in_entry_mut()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn show_soldier_gear_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_gear_in_entry_mut()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn pose_constraints_mut(&mut self) -> &mut super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints_mut()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn use_local_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_local_transform_mut()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn trigger_event_on_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.trigger_event_on_key_mut()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn allow_ragdoll_from_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_ragdoll_from_entry_mut()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
    fn camera_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.camera_index_mut()
    }
}

impl super::entity::GameComponentDataTrait for PlayerEntryComponentData {
}

impl super::entity::ComponentDataTrait for PlayerEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for PlayerEntryComponentData {
}

impl super::core::DataBusPeerTrait for PlayerEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerEntryComponentData {
}

impl super::core::DataContainerTrait for PlayerEntryComponentData {
}

pub static PLAYERENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerEntryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEENTRYCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerEntryComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AntEntryID",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PlayerEntryComponentData, ant_entry_i_d),
            },
            FieldInfoData {
                name: "AntEntryId",
                flags: MemberInfoFlags::new(0),
                field_type: "AntEntryIdEnum",
                rust_offset: offset_of!(PlayerEntryComponentData, ant_entry_id),
            },
            FieldInfoData {
                name: "AntEntryEnumeration",
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(PlayerEntryComponentData, ant_entry_enumeration),
            },
            FieldInfoData {
                name: "AnimationAccelerationMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PlayerEntryComponentData, animation_acceleration_multiplier),
            },
        ],
    }),
    array_type: Some(PLAYERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerEntryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameEntryComponentData {
    pub _glacier_base: super::gameplay_sim::EntryComponentData,
    pub lock_soldier_aiming_to_entry: bool,
    pub soldier_offset: super::core::Vec3,
}

pub trait GameEntryComponentDataTrait: super::gameplay_sim::EntryComponentDataTrait {
    fn lock_soldier_aiming_to_entry(&self) -> &bool;
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool;
    fn soldier_offset(&self) -> &super::core::Vec3;
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3;
}

impl GameEntryComponentDataTrait for GameEntryComponentData {
    fn lock_soldier_aiming_to_entry(&self) -> &bool {
        &self.lock_soldier_aiming_to_entry
    }
    fn lock_soldier_aiming_to_entry_mut(&mut self) -> &mut bool {
        &mut self.lock_soldier_aiming_to_entry
    }
    fn soldier_offset(&self) -> &super::core::Vec3 {
        &self.soldier_offset
    }
    fn soldier_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.soldier_offset
    }
}

impl super::gameplay_sim::EntryComponentDataTrait for GameEntryComponentData {
    fn entry_class(&self) -> &super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class()
    }
    fn entry_class_mut(&mut self) -> &mut super::gameplay_sim::EntryClass {
        self._glacier_base.entry_class_mut()
    }
    fn a_i_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data()
    }
    fn a_i_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIEntryDataTrait>>> {
        self._glacier_base.a_i_data_mut()
    }
    fn forbidden_for_human(&self) -> &bool {
        self._glacier_base.forbidden_for_human()
    }
    fn forbidden_for_human_mut(&mut self) -> &mut bool {
        self._glacier_base.forbidden_for_human_mut()
    }
    fn input_graph(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph()
    }
    fn input_graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputGraphTrait>>> {
        self._glacier_base.input_graph_mut()
    }
    fn input_concept_definition(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition()
    }
    fn input_concept_definition_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputActionMapsDataTrait>>> {
        self._glacier_base.input_concept_definition_mut()
    }
    fn action_map_settings_flip_y_scheme_override(&self) -> &i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override()
    }
    fn action_map_settings_flip_y_scheme_override_mut(&mut self) -> &mut i32 {
        self._glacier_base.action_map_settings_flip_y_scheme_override_mut()
    }
    fn input_mapping(&self) -> &Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping()
    }
    fn input_mapping_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::input_shared::InputConceptToEntryInputActionMappingsTrait>>> {
        self._glacier_base.input_mapping_mut()
    }
    fn input_curves(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves()
    }
    fn input_curves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::InputCurveDataTrait>>>> {
        self._glacier_base.input_curves_mut()
    }
    fn hud_data(&self) -> &super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data()
    }
    fn hud_data_mut(&mut self) -> &mut super::gameplay_sim::EntryComponentHudData {
        self._glacier_base.hud_data_mut()
    }
    fn entry_order_number(&self) -> &i32 {
        self._glacier_base.entry_order_number()
    }
    fn entry_order_number_mut(&mut self) -> &mut i32 {
        self._glacier_base.entry_order_number_mut()
    }
    fn enter_impulse(&self) -> &f32 {
        self._glacier_base.enter_impulse()
    }
    fn enter_impulse_mut(&mut self) -> &mut f32 {
        self._glacier_base.enter_impulse_mut()
    }
    fn entry_radius(&self) -> &f32 {
        self._glacier_base.entry_radius()
    }
    fn entry_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.entry_radius_mut()
    }
    fn is_allowed_to_exit_in_air(&self) -> &bool {
        self._glacier_base.is_allowed_to_exit_in_air()
    }
    fn is_allowed_to_exit_in_air_mut(&mut self) -> &mut bool {
        self._glacier_base.is_allowed_to_exit_in_air_mut()
    }
    fn clear_path_to_exit_point_start_offset(&self) -> &super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset()
    }
    fn clear_path_to_exit_point_start_offset_mut(&mut self) -> &mut super::core::Vec3 {
        self._glacier_base.clear_path_to_exit_point_start_offset_mut()
    }
    fn is_shielded(&self) -> &bool {
        self._glacier_base.is_shielded()
    }
    fn is_shielded_mut(&mut self) -> &mut bool {
        self._glacier_base.is_shielded_mut()
    }
    fn show_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_in_entry()
    }
    fn show_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_in_entry_mut()
    }
    fn show1p_soldier_in_entry(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry()
    }
    fn show1p_soldier_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_mut()
    }
    fn soldier_transition_invisble_time(&self) -> &f32 {
        self._glacier_base.soldier_transition_invisble_time()
    }
    fn soldier_transition_invisble_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.soldier_transition_invisble_time_mut()
    }
    fn entry_spotting_settings(&self) -> &super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings()
    }
    fn entry_spotting_settings_mut(&mut self) -> &mut super::gameplay_sim::EntrySpottingSettings {
        self._glacier_base.entry_spotting_settings_mut()
    }
    fn show_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_weapon_in_entry()
    }
    fn show_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_weapon_in_entry_mut()
    }
    fn show1p_soldier_in_entry_for_player_only(&self) -> &bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only()
    }
    fn show1p_soldier_in_entry_for_player_only_mut(&mut self) -> &mut bool {
        self._glacier_base.show1p_soldier_in_entry_for_player_only_mut()
    }
    fn show3p_soldier_weapon_in_entry(&self) -> &bool {
        self._glacier_base.show3p_soldier_weapon_in_entry()
    }
    fn show3p_soldier_weapon_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show3p_soldier_weapon_in_entry_mut()
    }
    fn show_soldier_gear_in_entry(&self) -> &bool {
        self._glacier_base.show_soldier_gear_in_entry()
    }
    fn show_soldier_gear_in_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.show_soldier_gear_in_entry_mut()
    }
    fn pose_constraints(&self) -> &super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints()
    }
    fn pose_constraints_mut(&mut self) -> &mut super::gameplay_sim::PoseConstraintsData {
        self._glacier_base.pose_constraints_mut()
    }
    fn use_local_transform(&self) -> &bool {
        self._glacier_base.use_local_transform()
    }
    fn use_local_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_local_transform_mut()
    }
    fn trigger_event_on_key(&self) -> &i32 {
        self._glacier_base.trigger_event_on_key()
    }
    fn trigger_event_on_key_mut(&mut self) -> &mut i32 {
        self._glacier_base.trigger_event_on_key_mut()
    }
    fn allow_ragdoll_from_entry(&self) -> &bool {
        self._glacier_base.allow_ragdoll_from_entry()
    }
    fn allow_ragdoll_from_entry_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_ragdoll_from_entry_mut()
    }
    fn camera_index(&self) -> &i32 {
        self._glacier_base.camera_index()
    }
    fn camera_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.camera_index_mut()
    }
}

impl super::entity::GameComponentDataTrait for GameEntryComponentData {
}

impl super::entity::ComponentDataTrait for GameEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for GameEntryComponentData {
}

impl super::core::DataBusPeerTrait for GameEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GameEntryComponentData {
}

impl super::core::DataContainerTrait for GameEntryComponentData {
}

pub static GAMEENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameEntryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::ENTRYCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameEntryComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LockSoldierAimingToEntry",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameEntryComponentData, lock_soldier_aiming_to_entry),
            },
            FieldInfoData {
                name: "SoldierOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(GameEntryComponentData, soldier_offset),
            },
        ],
    }),
    array_type: Some(GAMEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for GameEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameEntryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AntEntryIdEnum {
    #[default]
    AntEntryIdEnum_Humvee_Driver = 0,
    AntEntryIdEnum_Humvee_Gunner = 1,
    AntEntryIdEnum_Humvee_PassengerRearLeft = 2,
    AntEntryIdEnum_Humvee_PassengerRearRight = 3,
    AntEntryIdEnum_F16_Pilot = 4,
    AntEntryIdEnum_SU37_Pilot = 5,
    AntEntryIdEnum_AH6_Pilot = 6,
    AntEntryIdEnum_AH64_Pilot = 7,
    AntEntryIdEnum_AH64_Gunner = 8,
    AntEntryIdEnum_Vodnik_Driver = 9,
    AntEntryIdEnum_Vodnik_Gunner = 10,
    AntEntryIdEnum_Humvee_PassengerFrontRight = 11,
    AntEntryIdEnum_Vodnik_PassengerFrontRight = 12,
    AntEntryIdEnum_Vodnik_PassengerRearRight = 13,
    AntEntryIdEnum_Vodnik_PassengerRearLeft = 14,
    AntEntryIdEnum_VadsGunner = 15,
    AntEntryIdEnum_F18F_Pilot = 16,
    AntEntryIdEnum_F18F_Navigator = 17,
    AntEntryIdEnum_M1A2_Gunner = 18,
    AntEntryIdEnum_M1A2_Driver = 19,
}

pub static ANTENTRYIDENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEntryIdEnum",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTENTRYIDENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntEntryIdEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ANTENTRYIDENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTENTRYIDENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntEntryIdEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AntEntryIdEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntitlementQuery {
    pub _glacier_base: super::core::Asset,
    pub entitlements_data: Vec<EntitlementData>,
    pub group_names: Vec<String>,
    pub platform: super::core::GamePlatform,
    pub entitlement_tag: String,
    pub product_id: String,
    pub project_id: String,
}

pub trait EntitlementQueryTrait: super::core::AssetTrait {
    fn entitlements_data(&self) -> &Vec<EntitlementData>;
    fn entitlements_data_mut(&mut self) -> &mut Vec<EntitlementData>;
    fn group_names(&self) -> &Vec<String>;
    fn group_names_mut(&mut self) -> &mut Vec<String>;
    fn platform(&self) -> &super::core::GamePlatform;
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform;
    fn entitlement_tag(&self) -> &String;
    fn entitlement_tag_mut(&mut self) -> &mut String;
    fn product_id(&self) -> &String;
    fn product_id_mut(&mut self) -> &mut String;
    fn project_id(&self) -> &String;
    fn project_id_mut(&mut self) -> &mut String;
}

impl EntitlementQueryTrait for EntitlementQuery {
    fn entitlements_data(&self) -> &Vec<EntitlementData> {
        &self.entitlements_data
    }
    fn entitlements_data_mut(&mut self) -> &mut Vec<EntitlementData> {
        &mut self.entitlements_data
    }
    fn group_names(&self) -> &Vec<String> {
        &self.group_names
    }
    fn group_names_mut(&mut self) -> &mut Vec<String> {
        &mut self.group_names
    }
    fn platform(&self) -> &super::core::GamePlatform {
        &self.platform
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        &mut self.platform
    }
    fn entitlement_tag(&self) -> &String {
        &self.entitlement_tag
    }
    fn entitlement_tag_mut(&mut self) -> &mut String {
        &mut self.entitlement_tag
    }
    fn product_id(&self) -> &String {
        &self.product_id
    }
    fn product_id_mut(&mut self) -> &mut String {
        &mut self.product_id
    }
    fn project_id(&self) -> &String {
        &self.project_id
    }
    fn project_id_mut(&mut self) -> &mut String {
        &mut self.project_id
    }
}

impl super::core::AssetTrait for EntitlementQuery {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for EntitlementQuery {
}

pub static ENTITLEMENTQUERY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementQuery",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntitlementQuery as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EntitlementsData",
                flags: MemberInfoFlags::new(144),
                field_type: "EntitlementData-Array",
                rust_offset: offset_of!(EntitlementQuery, entitlements_data),
            },
            FieldInfoData {
                name: "GroupNames",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(EntitlementQuery, group_names),
            },
            FieldInfoData {
                name: "Platform",
                flags: MemberInfoFlags::new(0),
                field_type: "GamePlatform",
                rust_offset: offset_of!(EntitlementQuery, platform),
            },
            FieldInfoData {
                name: "EntitlementTag",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementQuery, entitlement_tag),
            },
            FieldInfoData {
                name: "ProductId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementQuery, product_id),
            },
            FieldInfoData {
                name: "ProjectId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementQuery, project_id),
            },
        ],
    }),
    array_type: Some(ENTITLEMENTQUERY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntitlementQuery {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITLEMENTQUERY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTITLEMENTQUERY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementQuery-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntitlementQuery"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntitlementData {
    pub license: String,
    pub entitlement_tag: String,
    pub group_name: String,
    pub product_id: String,
    pub project_id: String,
    pub verify_ownership: bool,
    pub usage_type: EntitlementType,
}

pub trait EntitlementDataTrait: TypeObject {
    fn license(&self) -> &String;
    fn license_mut(&mut self) -> &mut String;
    fn entitlement_tag(&self) -> &String;
    fn entitlement_tag_mut(&mut self) -> &mut String;
    fn group_name(&self) -> &String;
    fn group_name_mut(&mut self) -> &mut String;
    fn product_id(&self) -> &String;
    fn product_id_mut(&mut self) -> &mut String;
    fn project_id(&self) -> &String;
    fn project_id_mut(&mut self) -> &mut String;
    fn verify_ownership(&self) -> &bool;
    fn verify_ownership_mut(&mut self) -> &mut bool;
    fn usage_type(&self) -> &EntitlementType;
    fn usage_type_mut(&mut self) -> &mut EntitlementType;
}

impl EntitlementDataTrait for EntitlementData {
    fn license(&self) -> &String {
        &self.license
    }
    fn license_mut(&mut self) -> &mut String {
        &mut self.license
    }
    fn entitlement_tag(&self) -> &String {
        &self.entitlement_tag
    }
    fn entitlement_tag_mut(&mut self) -> &mut String {
        &mut self.entitlement_tag
    }
    fn group_name(&self) -> &String {
        &self.group_name
    }
    fn group_name_mut(&mut self) -> &mut String {
        &mut self.group_name
    }
    fn product_id(&self) -> &String {
        &self.product_id
    }
    fn product_id_mut(&mut self) -> &mut String {
        &mut self.product_id
    }
    fn project_id(&self) -> &String {
        &self.project_id
    }
    fn project_id_mut(&mut self) -> &mut String {
        &mut self.project_id
    }
    fn verify_ownership(&self) -> &bool {
        &self.verify_ownership
    }
    fn verify_ownership_mut(&mut self) -> &mut bool {
        &mut self.verify_ownership
    }
    fn usage_type(&self) -> &EntitlementType {
        &self.usage_type
    }
    fn usage_type_mut(&mut self) -> &mut EntitlementType {
        &mut self.usage_type
    }
}

pub static ENTITLEMENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntitlementData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "License",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, license),
            },
            FieldInfoData {
                name: "EntitlementTag",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, entitlement_tag),
            },
            FieldInfoData {
                name: "GroupName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, group_name),
            },
            FieldInfoData {
                name: "ProductId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, product_id),
            },
            FieldInfoData {
                name: "ProjectId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EntitlementData, project_id),
            },
            FieldInfoData {
                name: "VerifyOwnership",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EntitlementData, verify_ownership),
            },
            FieldInfoData {
                name: "UsageType",
                flags: MemberInfoFlags::new(0),
                field_type: "EntitlementType",
                rust_offset: offset_of!(EntitlementData, usage_type),
            },
        ],
    }),
    array_type: Some(ENTITLEMENTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntitlementData {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITLEMENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITLEMENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntitlementData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlatformProjectId {
    pub platform: super::core::GamePlatform,
    pub project_id: String,
}

pub trait PlatformProjectIdTrait: TypeObject {
    fn platform(&self) -> &super::core::GamePlatform;
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform;
    fn project_id(&self) -> &String;
    fn project_id_mut(&mut self) -> &mut String;
}

impl PlatformProjectIdTrait for PlatformProjectId {
    fn platform(&self) -> &super::core::GamePlatform {
        &self.platform
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        &mut self.platform
    }
    fn project_id(&self) -> &String {
        &self.project_id
    }
    fn project_id_mut(&mut self) -> &mut String {
        &mut self.project_id
    }
}

pub static PLATFORMPROJECTID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformProjectId",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlatformProjectId as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Platform",
                flags: MemberInfoFlags::new(0),
                field_type: "GamePlatform",
                rust_offset: offset_of!(PlatformProjectId, platform),
            },
            FieldInfoData {
                name: "ProjectId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PlatformProjectId, project_id),
            },
        ],
    }),
    array_type: Some(PLATFORMPROJECTID_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlatformProjectId {
    fn type_info(&self) -> &'static TypeInfo {
        PLATFORMPROJECTID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PLATFORMPROJECTID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformProjectId-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlatformProjectId"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntitlementPlatformType {
    pub platform: super::core::GamePlatform,
    pub entitlement_type: EntitlementType,
}

pub trait EntitlementPlatformTypeTrait: TypeObject {
    fn platform(&self) -> &super::core::GamePlatform;
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform;
    fn entitlement_type(&self) -> &EntitlementType;
    fn entitlement_type_mut(&mut self) -> &mut EntitlementType;
}

impl EntitlementPlatformTypeTrait for EntitlementPlatformType {
    fn platform(&self) -> &super::core::GamePlatform {
        &self.platform
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        &mut self.platform
    }
    fn entitlement_type(&self) -> &EntitlementType {
        &self.entitlement_type
    }
    fn entitlement_type_mut(&mut self) -> &mut EntitlementType {
        &mut self.entitlement_type
    }
}

pub static ENTITLEMENTPLATFORMTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementPlatformType",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntitlementPlatformType as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Platform",
                flags: MemberInfoFlags::new(0),
                field_type: "GamePlatform",
                rust_offset: offset_of!(EntitlementPlatformType, platform),
            },
            FieldInfoData {
                name: "EntitlementType",
                flags: MemberInfoFlags::new(0),
                field_type: "EntitlementType",
                rust_offset: offset_of!(EntitlementPlatformType, entitlement_type),
            },
        ],
    }),
    array_type: Some(ENTITLEMENTPLATFORMTYPE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EntitlementPlatformType {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITLEMENTPLATFORMTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITLEMENTPLATFORMTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementPlatformType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntitlementPlatformType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EntitlementType {
    #[default]
    EntitlementType_Ignored = 0,
    EntitlementType_Write = 1,
    EntitlementType_Read = 2,
}

pub static ENTITLEMENTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ENTITLEMENTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EntitlementType {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITLEMENTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTITLEMENTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntitlementType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntitlementType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnsemblePublisherEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub event_name: String,
    pub event_data: String,
}

pub trait EnsemblePublisherEntityDataTrait: super::entity::EntityDataTrait {
    fn event_name(&self) -> &String;
    fn event_name_mut(&mut self) -> &mut String;
    fn event_data(&self) -> &String;
    fn event_data_mut(&mut self) -> &mut String;
}

impl EnsemblePublisherEntityDataTrait for EnsemblePublisherEntityData {
    fn event_name(&self) -> &String {
        &self.event_name
    }
    fn event_name_mut(&mut self) -> &mut String {
        &mut self.event_name
    }
    fn event_data(&self) -> &String {
        &self.event_data
    }
    fn event_data_mut(&mut self) -> &mut String {
        &mut self.event_data
    }
}

impl super::entity::EntityDataTrait for EnsemblePublisherEntityData {
}

impl super::entity::GameObjectDataTrait for EnsemblePublisherEntityData {
}

impl super::core::DataBusPeerTrait for EnsemblePublisherEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnsemblePublisherEntityData {
}

impl super::core::DataContainerTrait for EnsemblePublisherEntityData {
}

pub static ENSEMBLEPUBLISHERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnsemblePublisherEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnsemblePublisherEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EventName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EnsemblePublisherEntityData, event_name),
            },
            FieldInfoData {
                name: "EventData",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(EnsemblePublisherEntityData, event_data),
            },
        ],
    }),
    array_type: Some(ENSEMBLEPUBLISHERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnsemblePublisherEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENSEMBLEPUBLISHERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENSEMBLEPUBLISHERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnsemblePublisherEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EnsemblePublisherEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicModelHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait DynamicModelHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl DynamicModelHealthComponentDataTrait for DynamicModelHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for DynamicModelHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for DynamicModelHealthComponentData {
}

impl super::entity::ComponentDataTrait for DynamicModelHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DynamicModelHealthComponentData {
}

impl super::core::DataBusPeerTrait for DynamicModelHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicModelHealthComponentData {
}

impl super::core::DataContainerTrait for DynamicModelHealthComponentData {
}

pub static DYNAMICMODELHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicModelHealthComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DYNAMICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicModelHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICMODELHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicModelHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicModelPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
    pub impulse_input: super::core::Vec3,
}

pub trait DynamicModelPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
    fn impulse_input(&self) -> &super::core::Vec3;
    fn impulse_input_mut(&mut self) -> &mut super::core::Vec3;
}

impl DynamicModelPhysicsComponentDataTrait for DynamicModelPhysicsComponentData {
    fn impulse_input(&self) -> &super::core::Vec3 {
        &self.impulse_input
    }
    fn impulse_input_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.impulse_input
    }
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for DynamicModelPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for DynamicModelPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for DynamicModelPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for DynamicModelPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for DynamicModelPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicModelPhysicsComponentData {
}

impl super::core::DataContainerTrait for DynamicModelPhysicsComponentData {
}

pub static DYNAMICMODELPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicModelPhysicsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ImpulseInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DynamicModelPhysicsComponentData, impulse_input),
            },
        ],
    }),
    array_type: Some(DYNAMICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicModelPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICMODELPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicModelPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicModelEntityData {
    pub _glacier_base: DynamicGamePhysicsEntityData,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub destructible_part_count: u32,
    pub no_collision: bool,
}

pub trait DynamicModelEntityDataTrait: DynamicGamePhysicsEntityDataTrait {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn destructible_part_count(&self) -> &u32;
    fn destructible_part_count_mut(&mut self) -> &mut u32;
    fn no_collision(&self) -> &bool;
    fn no_collision_mut(&mut self) -> &mut bool;
}

impl DynamicModelEntityDataTrait for DynamicModelEntityData {
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn destructible_part_count(&self) -> &u32 {
        &self.destructible_part_count
    }
    fn destructible_part_count_mut(&mut self) -> &mut u32 {
        &mut self.destructible_part_count
    }
    fn no_collision(&self) -> &bool {
        &self.no_collision
    }
    fn no_collision_mut(&mut self) -> &mut bool {
        &mut self.no_collision
    }
}

impl DynamicGamePhysicsEntityDataTrait for DynamicModelEntityData {
}

impl super::physics::GamePhysicsEntityDataTrait for DynamicModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for DynamicModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for DynamicModelEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DynamicModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DynamicModelEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicModelEntityData {
}

impl super::core::DataBusPeerTrait for DynamicModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicModelEntityData {
}

impl super::core::DataContainerTrait for DynamicModelEntityData {
}

pub static DYNAMICMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DYNAMICGAMEPHYSICSENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicModelEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(DynamicModelEntityData, mesh),
            },
            FieldInfoData {
                name: "DestructiblePartCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicModelEntityData, destructible_part_count),
            },
            FieldInfoData {
                name: "NoCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DynamicModelEntityData, no_collision),
            },
        ],
    }),
    array_type: Some(DYNAMICMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicModelEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NetFireStarterCell {
    pub x: u8,
    pub y: u8,
    pub start_tick: u32,
    pub radius: u8,
}

pub trait NetFireStarterCellTrait: TypeObject {
    fn x(&self) -> &u8;
    fn x_mut(&mut self) -> &mut u8;
    fn y(&self) -> &u8;
    fn y_mut(&mut self) -> &mut u8;
    fn start_tick(&self) -> &u32;
    fn start_tick_mut(&mut self) -> &mut u32;
    fn radius(&self) -> &u8;
    fn radius_mut(&mut self) -> &mut u8;
}

impl NetFireStarterCellTrait for NetFireStarterCell {
    fn x(&self) -> &u8 {
        &self.x
    }
    fn x_mut(&mut self) -> &mut u8 {
        &mut self.x
    }
    fn y(&self) -> &u8 {
        &self.y
    }
    fn y_mut(&mut self) -> &mut u8 {
        &mut self.y
    }
    fn start_tick(&self) -> &u32 {
        &self.start_tick
    }
    fn start_tick_mut(&mut self) -> &mut u32 {
        &mut self.start_tick
    }
    fn radius(&self) -> &u8 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut u8 {
        &mut self.radius
    }
}

pub static NETFIRESTARTERCELL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetFireStarterCell",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NetFireStarterCell as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(NetFireStarterCell, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(NetFireStarterCell, y),
            },
            FieldInfoData {
                name: "StartTick",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(NetFireStarterCell, start_tick),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(NetFireStarterCell, radius),
            },
        ],
    }),
    array_type: Some(NETFIRESTARTERCELL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for NetFireStarterCell {
    fn type_info(&self) -> &'static TypeInfo {
        NETFIRESTARTERCELL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NETFIRESTARTERCELL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NetFireStarterCell-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("NetFireStarterCell"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicFireEntityData {
    pub _glacier_base: super::entity::GameComponentEntityData,
    pub width: f32,
    pub length: f32,
    pub height: f32,
    pub fire_tile_size: f32,
    pub max_burn_time: f32,
    pub max_health: f32,
    pub damage_per_second: f32,
    pub cell_f_x_asset: Option<Arc<Mutex<dyn DynamicFireCellFXAssetTrait>>>,
    pub fire_cell_damage_radius: u32,
    pub fire_cell_damage_per_second: f32,
    pub max_damaging_cells: u32,
    pub start_damage_threshold: f32,
    pub end_damage_threshold: f32,
    pub max_fire_starters: u32,
    pub min_fire_starter_radius: f32,
    pub max_fires_per_frame: u32,
    pub max_burning_cells: u32,
    pub quadrant_cell_size: u32,
    pub material_pair: super::entity::MaterialDecl,
    pub mask_shader: super::render_base::SurfaceShaderInstanceDataStruct,
    pub max_quadrant_sounds: u32,
    pub large_fire_threshold: u32,
    pub large_fire_sort_factor: f32,
    pub large_fire_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub medium_fire_threshold: u32,
    pub medium_fire_sort_factor: f32,
    pub medium_fire_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub small_fire_sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub medium_in_threshold: f32,
    pub large_in_threshold: f32,
    pub large_out_threshold: f32,
    pub medium_out_threshold: f32,
    pub small_fire_weight: f32,
    pub medium_fire_weight: f32,
    pub large_fire_weight: f32,
}

pub trait DynamicFireEntityDataTrait: super::entity::GameComponentEntityDataTrait {
    fn width(&self) -> &f32;
    fn width_mut(&mut self) -> &mut f32;
    fn length(&self) -> &f32;
    fn length_mut(&mut self) -> &mut f32;
    fn height(&self) -> &f32;
    fn height_mut(&mut self) -> &mut f32;
    fn fire_tile_size(&self) -> &f32;
    fn fire_tile_size_mut(&mut self) -> &mut f32;
    fn max_burn_time(&self) -> &f32;
    fn max_burn_time_mut(&mut self) -> &mut f32;
    fn max_health(&self) -> &f32;
    fn max_health_mut(&mut self) -> &mut f32;
    fn damage_per_second(&self) -> &f32;
    fn damage_per_second_mut(&mut self) -> &mut f32;
    fn cell_f_x_asset(&self) -> &Option<Arc<Mutex<dyn DynamicFireCellFXAssetTrait>>>;
    fn cell_f_x_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DynamicFireCellFXAssetTrait>>>;
    fn fire_cell_damage_radius(&self) -> &u32;
    fn fire_cell_damage_radius_mut(&mut self) -> &mut u32;
    fn fire_cell_damage_per_second(&self) -> &f32;
    fn fire_cell_damage_per_second_mut(&mut self) -> &mut f32;
    fn max_damaging_cells(&self) -> &u32;
    fn max_damaging_cells_mut(&mut self) -> &mut u32;
    fn start_damage_threshold(&self) -> &f32;
    fn start_damage_threshold_mut(&mut self) -> &mut f32;
    fn end_damage_threshold(&self) -> &f32;
    fn end_damage_threshold_mut(&mut self) -> &mut f32;
    fn max_fire_starters(&self) -> &u32;
    fn max_fire_starters_mut(&mut self) -> &mut u32;
    fn min_fire_starter_radius(&self) -> &f32;
    fn min_fire_starter_radius_mut(&mut self) -> &mut f32;
    fn max_fires_per_frame(&self) -> &u32;
    fn max_fires_per_frame_mut(&mut self) -> &mut u32;
    fn max_burning_cells(&self) -> &u32;
    fn max_burning_cells_mut(&mut self) -> &mut u32;
    fn quadrant_cell_size(&self) -> &u32;
    fn quadrant_cell_size_mut(&mut self) -> &mut u32;
    fn material_pair(&self) -> &super::entity::MaterialDecl;
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn mask_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct;
    fn mask_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct;
    fn max_quadrant_sounds(&self) -> &u32;
    fn max_quadrant_sounds_mut(&mut self) -> &mut u32;
    fn large_fire_threshold(&self) -> &u32;
    fn large_fire_threshold_mut(&mut self) -> &mut u32;
    fn large_fire_sort_factor(&self) -> &f32;
    fn large_fire_sort_factor_mut(&mut self) -> &mut f32;
    fn large_fire_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn large_fire_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn medium_fire_threshold(&self) -> &u32;
    fn medium_fire_threshold_mut(&mut self) -> &mut u32;
    fn medium_fire_sort_factor(&self) -> &f32;
    fn medium_fire_sort_factor_mut(&mut self) -> &mut f32;
    fn medium_fire_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn medium_fire_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn small_fire_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn small_fire_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn medium_in_threshold(&self) -> &f32;
    fn medium_in_threshold_mut(&mut self) -> &mut f32;
    fn large_in_threshold(&self) -> &f32;
    fn large_in_threshold_mut(&mut self) -> &mut f32;
    fn large_out_threshold(&self) -> &f32;
    fn large_out_threshold_mut(&mut self) -> &mut f32;
    fn medium_out_threshold(&self) -> &f32;
    fn medium_out_threshold_mut(&mut self) -> &mut f32;
    fn small_fire_weight(&self) -> &f32;
    fn small_fire_weight_mut(&mut self) -> &mut f32;
    fn medium_fire_weight(&self) -> &f32;
    fn medium_fire_weight_mut(&mut self) -> &mut f32;
    fn large_fire_weight(&self) -> &f32;
    fn large_fire_weight_mut(&mut self) -> &mut f32;
}

impl DynamicFireEntityDataTrait for DynamicFireEntityData {
    fn width(&self) -> &f32 {
        &self.width
    }
    fn width_mut(&mut self) -> &mut f32 {
        &mut self.width
    }
    fn length(&self) -> &f32 {
        &self.length
    }
    fn length_mut(&mut self) -> &mut f32 {
        &mut self.length
    }
    fn height(&self) -> &f32 {
        &self.height
    }
    fn height_mut(&mut self) -> &mut f32 {
        &mut self.height
    }
    fn fire_tile_size(&self) -> &f32 {
        &self.fire_tile_size
    }
    fn fire_tile_size_mut(&mut self) -> &mut f32 {
        &mut self.fire_tile_size
    }
    fn max_burn_time(&self) -> &f32 {
        &self.max_burn_time
    }
    fn max_burn_time_mut(&mut self) -> &mut f32 {
        &mut self.max_burn_time
    }
    fn max_health(&self) -> &f32 {
        &self.max_health
    }
    fn max_health_mut(&mut self) -> &mut f32 {
        &mut self.max_health
    }
    fn damage_per_second(&self) -> &f32 {
        &self.damage_per_second
    }
    fn damage_per_second_mut(&mut self) -> &mut f32 {
        &mut self.damage_per_second
    }
    fn cell_f_x_asset(&self) -> &Option<Arc<Mutex<dyn DynamicFireCellFXAssetTrait>>> {
        &self.cell_f_x_asset
    }
    fn cell_f_x_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DynamicFireCellFXAssetTrait>>> {
        &mut self.cell_f_x_asset
    }
    fn fire_cell_damage_radius(&self) -> &u32 {
        &self.fire_cell_damage_radius
    }
    fn fire_cell_damage_radius_mut(&mut self) -> &mut u32 {
        &mut self.fire_cell_damage_radius
    }
    fn fire_cell_damage_per_second(&self) -> &f32 {
        &self.fire_cell_damage_per_second
    }
    fn fire_cell_damage_per_second_mut(&mut self) -> &mut f32 {
        &mut self.fire_cell_damage_per_second
    }
    fn max_damaging_cells(&self) -> &u32 {
        &self.max_damaging_cells
    }
    fn max_damaging_cells_mut(&mut self) -> &mut u32 {
        &mut self.max_damaging_cells
    }
    fn start_damage_threshold(&self) -> &f32 {
        &self.start_damage_threshold
    }
    fn start_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.start_damage_threshold
    }
    fn end_damage_threshold(&self) -> &f32 {
        &self.end_damage_threshold
    }
    fn end_damage_threshold_mut(&mut self) -> &mut f32 {
        &mut self.end_damage_threshold
    }
    fn max_fire_starters(&self) -> &u32 {
        &self.max_fire_starters
    }
    fn max_fire_starters_mut(&mut self) -> &mut u32 {
        &mut self.max_fire_starters
    }
    fn min_fire_starter_radius(&self) -> &f32 {
        &self.min_fire_starter_radius
    }
    fn min_fire_starter_radius_mut(&mut self) -> &mut f32 {
        &mut self.min_fire_starter_radius
    }
    fn max_fires_per_frame(&self) -> &u32 {
        &self.max_fires_per_frame
    }
    fn max_fires_per_frame_mut(&mut self) -> &mut u32 {
        &mut self.max_fires_per_frame
    }
    fn max_burning_cells(&self) -> &u32 {
        &self.max_burning_cells
    }
    fn max_burning_cells_mut(&mut self) -> &mut u32 {
        &mut self.max_burning_cells
    }
    fn quadrant_cell_size(&self) -> &u32 {
        &self.quadrant_cell_size
    }
    fn quadrant_cell_size_mut(&mut self) -> &mut u32 {
        &mut self.quadrant_cell_size
    }
    fn material_pair(&self) -> &super::entity::MaterialDecl {
        &self.material_pair
    }
    fn material_pair_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material_pair
    }
    fn mask_shader(&self) -> &super::render_base::SurfaceShaderInstanceDataStruct {
        &self.mask_shader
    }
    fn mask_shader_mut(&mut self) -> &mut super::render_base::SurfaceShaderInstanceDataStruct {
        &mut self.mask_shader
    }
    fn max_quadrant_sounds(&self) -> &u32 {
        &self.max_quadrant_sounds
    }
    fn max_quadrant_sounds_mut(&mut self) -> &mut u32 {
        &mut self.max_quadrant_sounds
    }
    fn large_fire_threshold(&self) -> &u32 {
        &self.large_fire_threshold
    }
    fn large_fire_threshold_mut(&mut self) -> &mut u32 {
        &mut self.large_fire_threshold
    }
    fn large_fire_sort_factor(&self) -> &f32 {
        &self.large_fire_sort_factor
    }
    fn large_fire_sort_factor_mut(&mut self) -> &mut f32 {
        &mut self.large_fire_sort_factor
    }
    fn large_fire_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.large_fire_sound
    }
    fn large_fire_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.large_fire_sound
    }
    fn medium_fire_threshold(&self) -> &u32 {
        &self.medium_fire_threshold
    }
    fn medium_fire_threshold_mut(&mut self) -> &mut u32 {
        &mut self.medium_fire_threshold
    }
    fn medium_fire_sort_factor(&self) -> &f32 {
        &self.medium_fire_sort_factor
    }
    fn medium_fire_sort_factor_mut(&mut self) -> &mut f32 {
        &mut self.medium_fire_sort_factor
    }
    fn medium_fire_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.medium_fire_sound
    }
    fn medium_fire_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.medium_fire_sound
    }
    fn small_fire_sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.small_fire_sound
    }
    fn small_fire_sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.small_fire_sound
    }
    fn medium_in_threshold(&self) -> &f32 {
        &self.medium_in_threshold
    }
    fn medium_in_threshold_mut(&mut self) -> &mut f32 {
        &mut self.medium_in_threshold
    }
    fn large_in_threshold(&self) -> &f32 {
        &self.large_in_threshold
    }
    fn large_in_threshold_mut(&mut self) -> &mut f32 {
        &mut self.large_in_threshold
    }
    fn large_out_threshold(&self) -> &f32 {
        &self.large_out_threshold
    }
    fn large_out_threshold_mut(&mut self) -> &mut f32 {
        &mut self.large_out_threshold
    }
    fn medium_out_threshold(&self) -> &f32 {
        &self.medium_out_threshold
    }
    fn medium_out_threshold_mut(&mut self) -> &mut f32 {
        &mut self.medium_out_threshold
    }
    fn small_fire_weight(&self) -> &f32 {
        &self.small_fire_weight
    }
    fn small_fire_weight_mut(&mut self) -> &mut f32 {
        &mut self.small_fire_weight
    }
    fn medium_fire_weight(&self) -> &f32 {
        &self.medium_fire_weight
    }
    fn medium_fire_weight_mut(&mut self) -> &mut f32 {
        &mut self.medium_fire_weight
    }
    fn large_fire_weight(&self) -> &f32 {
        &self.large_fire_weight
    }
    fn large_fire_weight_mut(&mut self) -> &mut f32 {
        &mut self.large_fire_weight
    }
}

impl super::entity::GameComponentEntityDataTrait for DynamicFireEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for DynamicFireEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DynamicFireEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DynamicFireEntityData {
}

impl super::entity::GameObjectDataTrait for DynamicFireEntityData {
}

impl super::core::DataBusPeerTrait for DynamicFireEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DynamicFireEntityData {
}

impl super::core::DataContainerTrait for DynamicFireEntityData {
}

pub static DYNAMICFIREENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicFireEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicFireEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Width",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, width),
            },
            FieldInfoData {
                name: "Length",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, length),
            },
            FieldInfoData {
                name: "Height",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, height),
            },
            FieldInfoData {
                name: "FireTileSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, fire_tile_size),
            },
            FieldInfoData {
                name: "MaxBurnTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, max_burn_time),
            },
            FieldInfoData {
                name: "MaxHealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, max_health),
            },
            FieldInfoData {
                name: "DamagePerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, damage_per_second),
            },
            FieldInfoData {
                name: "CellFXAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "DynamicFireCellFXAsset",
                rust_offset: offset_of!(DynamicFireEntityData, cell_f_x_asset),
            },
            FieldInfoData {
                name: "FireCellDamageRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, fire_cell_damage_radius),
            },
            FieldInfoData {
                name: "FireCellDamagePerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, fire_cell_damage_per_second),
            },
            FieldInfoData {
                name: "MaxDamagingCells",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_damaging_cells),
            },
            FieldInfoData {
                name: "StartDamageThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, start_damage_threshold),
            },
            FieldInfoData {
                name: "EndDamageThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, end_damage_threshold),
            },
            FieldInfoData {
                name: "MaxFireStarters",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_fire_starters),
            },
            FieldInfoData {
                name: "MinFireStarterRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, min_fire_starter_radius),
            },
            FieldInfoData {
                name: "MaxFiresPerFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_fires_per_frame),
            },
            FieldInfoData {
                name: "MaxBurningCells",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_burning_cells),
            },
            FieldInfoData {
                name: "QuadrantCellSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, quadrant_cell_size),
            },
            FieldInfoData {
                name: "MaterialPair",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(DynamicFireEntityData, material_pair),
            },
            FieldInfoData {
                name: "MaskShader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderInstanceDataStruct",
                rust_offset: offset_of!(DynamicFireEntityData, mask_shader),
            },
            FieldInfoData {
                name: "MaxQuadrantSounds",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, max_quadrant_sounds),
            },
            FieldInfoData {
                name: "LargeFireThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, large_fire_threshold),
            },
            FieldInfoData {
                name: "LargeFireSortFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, large_fire_sort_factor),
            },
            FieldInfoData {
                name: "LargeFireSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(DynamicFireEntityData, large_fire_sound),
            },
            FieldInfoData {
                name: "MediumFireThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_fire_threshold),
            },
            FieldInfoData {
                name: "MediumFireSortFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_fire_sort_factor),
            },
            FieldInfoData {
                name: "MediumFireSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(DynamicFireEntityData, medium_fire_sound),
            },
            FieldInfoData {
                name: "SmallFireSound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(DynamicFireEntityData, small_fire_sound),
            },
            FieldInfoData {
                name: "MediumInThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_in_threshold),
            },
            FieldInfoData {
                name: "LargeInThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, large_in_threshold),
            },
            FieldInfoData {
                name: "LargeOutThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, large_out_threshold),
            },
            FieldInfoData {
                name: "MediumOutThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_out_threshold),
            },
            FieldInfoData {
                name: "SmallFireWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, small_fire_weight),
            },
            FieldInfoData {
                name: "MediumFireWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, medium_fire_weight),
            },
            FieldInfoData {
                name: "LargeFireWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicFireEntityData, large_fire_weight),
            },
        ],
    }),
    array_type: Some(DYNAMICFIREENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DynamicFireEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICFIREENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICFIREENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicFireEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicFireEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicFireCellFXAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub cell_f_x_list: Vec<Option<Arc<Mutex<dyn CellFXTrait>>>>,
    pub min_smoke_separation_distance: super::core::QualityScalableFloat,
    pub smoke_effect: Vec<Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>>,
}

pub trait DynamicFireCellFXAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn cell_f_x_list(&self) -> &Vec<Option<Arc<Mutex<dyn CellFXTrait>>>>;
    fn cell_f_x_list_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CellFXTrait>>>>;
    fn min_smoke_separation_distance(&self) -> &super::core::QualityScalableFloat;
    fn min_smoke_separation_distance_mut(&mut self) -> &mut super::core::QualityScalableFloat;
    fn smoke_effect(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>>;
    fn smoke_effect_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>>;
}

impl DynamicFireCellFXAssetTrait for DynamicFireCellFXAsset {
    fn cell_f_x_list(&self) -> &Vec<Option<Arc<Mutex<dyn CellFXTrait>>>> {
        &self.cell_f_x_list
    }
    fn cell_f_x_list_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CellFXTrait>>>> {
        &mut self.cell_f_x_list
    }
    fn min_smoke_separation_distance(&self) -> &super::core::QualityScalableFloat {
        &self.min_smoke_separation_distance
    }
    fn min_smoke_separation_distance_mut(&mut self) -> &mut super::core::QualityScalableFloat {
        &mut self.min_smoke_separation_distance
    }
    fn smoke_effect(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>> {
        &self.smoke_effect
    }
    fn smoke_effect_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>> {
        &mut self.smoke_effect
    }
}

impl super::core::DataContainerPolicyAssetTrait for DynamicFireCellFXAsset {
}

impl super::core::AssetTrait for DynamicFireCellFXAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for DynamicFireCellFXAsset {
}

pub static DYNAMICFIRECELLFXASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicFireCellFXAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicFireCellFXAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CellFXList",
                flags: MemberInfoFlags::new(144),
                field_type: "CellFX-Array",
                rust_offset: offset_of!(DynamicFireCellFXAsset, cell_f_x_list),
            },
            FieldInfoData {
                name: "MinSmokeSeparationDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableFloat",
                rust_offset: offset_of!(DynamicFireCellFXAsset, min_smoke_separation_distance),
            },
            FieldInfoData {
                name: "SmokeEffect",
                flags: MemberInfoFlags::new(144),
                field_type: "EffectBlueprint-Array",
                rust_offset: offset_of!(DynamicFireCellFXAsset, smoke_effect),
            },
        ],
    }),
    array_type: Some(DYNAMICFIRECELLFXASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DynamicFireCellFXAsset {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICFIRECELLFXASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICFIRECELLFXASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicFireCellFXAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DynamicFireCellFXAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CellFX {
    pub _glacier_base: super::core::DataContainer,
    pub enabled: super::core::QualityScalableBool,
    pub min_spawn_scale: super::core::Vec3,
    pub max_spawn_scale: super::core::Vec3,
    pub spawn_probability: super::core::QualityScalableFloat,
    pub min_spawn_count: super::core::QualityScalableInt,
    pub max_spawn_count: super::core::QualityScalableInt,
    pub peak_burn_percent: f32,
    pub min_peak_flicker_percent: f32,
    pub max_peak_flicker_percent: f32,
    pub min_flicker_amplitude: f32,
    pub max_flicker_amplitude: f32,
    pub min_flicker_freq: f32,
    pub max_flicker_freq: f32,
    pub spawn_scale_multiplier_x: f32,
    pub spawn_scale_multiplier_y: f32,
    pub spawn_scale_multiplier_z: f32,
    pub align_to_terrain_normal: bool,
    pub peak_growth_percent: f32,
    pub growth_offset: f32,
    pub burn_time_multiplier: f32,
    pub effect_mesh: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
}

pub trait CellFXTrait: super::core::DataContainerTrait {
    fn enabled(&self) -> &super::core::QualityScalableBool;
    fn enabled_mut(&mut self) -> &mut super::core::QualityScalableBool;
    fn min_spawn_scale(&self) -> &super::core::Vec3;
    fn min_spawn_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn max_spawn_scale(&self) -> &super::core::Vec3;
    fn max_spawn_scale_mut(&mut self) -> &mut super::core::Vec3;
    fn spawn_probability(&self) -> &super::core::QualityScalableFloat;
    fn spawn_probability_mut(&mut self) -> &mut super::core::QualityScalableFloat;
    fn min_spawn_count(&self) -> &super::core::QualityScalableInt;
    fn min_spawn_count_mut(&mut self) -> &mut super::core::QualityScalableInt;
    fn max_spawn_count(&self) -> &super::core::QualityScalableInt;
    fn max_spawn_count_mut(&mut self) -> &mut super::core::QualityScalableInt;
    fn peak_burn_percent(&self) -> &f32;
    fn peak_burn_percent_mut(&mut self) -> &mut f32;
    fn min_peak_flicker_percent(&self) -> &f32;
    fn min_peak_flicker_percent_mut(&mut self) -> &mut f32;
    fn max_peak_flicker_percent(&self) -> &f32;
    fn max_peak_flicker_percent_mut(&mut self) -> &mut f32;
    fn min_flicker_amplitude(&self) -> &f32;
    fn min_flicker_amplitude_mut(&mut self) -> &mut f32;
    fn max_flicker_amplitude(&self) -> &f32;
    fn max_flicker_amplitude_mut(&mut self) -> &mut f32;
    fn min_flicker_freq(&self) -> &f32;
    fn min_flicker_freq_mut(&mut self) -> &mut f32;
    fn max_flicker_freq(&self) -> &f32;
    fn max_flicker_freq_mut(&mut self) -> &mut f32;
    fn spawn_scale_multiplier_x(&self) -> &f32;
    fn spawn_scale_multiplier_x_mut(&mut self) -> &mut f32;
    fn spawn_scale_multiplier_y(&self) -> &f32;
    fn spawn_scale_multiplier_y_mut(&mut self) -> &mut f32;
    fn spawn_scale_multiplier_z(&self) -> &f32;
    fn spawn_scale_multiplier_z_mut(&mut self) -> &mut f32;
    fn align_to_terrain_normal(&self) -> &bool;
    fn align_to_terrain_normal_mut(&mut self) -> &mut bool;
    fn peak_growth_percent(&self) -> &f32;
    fn peak_growth_percent_mut(&mut self) -> &mut f32;
    fn growth_offset(&self) -> &f32;
    fn growth_offset_mut(&mut self) -> &mut f32;
    fn burn_time_multiplier(&self) -> &f32;
    fn burn_time_multiplier_mut(&mut self) -> &mut f32;
    fn effect_mesh(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn effect_mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
}

impl CellFXTrait for CellFX {
    fn enabled(&self) -> &super::core::QualityScalableBool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut super::core::QualityScalableBool {
        &mut self.enabled
    }
    fn min_spawn_scale(&self) -> &super::core::Vec3 {
        &self.min_spawn_scale
    }
    fn min_spawn_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.min_spawn_scale
    }
    fn max_spawn_scale(&self) -> &super::core::Vec3 {
        &self.max_spawn_scale
    }
    fn max_spawn_scale_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.max_spawn_scale
    }
    fn spawn_probability(&self) -> &super::core::QualityScalableFloat {
        &self.spawn_probability
    }
    fn spawn_probability_mut(&mut self) -> &mut super::core::QualityScalableFloat {
        &mut self.spawn_probability
    }
    fn min_spawn_count(&self) -> &super::core::QualityScalableInt {
        &self.min_spawn_count
    }
    fn min_spawn_count_mut(&mut self) -> &mut super::core::QualityScalableInt {
        &mut self.min_spawn_count
    }
    fn max_spawn_count(&self) -> &super::core::QualityScalableInt {
        &self.max_spawn_count
    }
    fn max_spawn_count_mut(&mut self) -> &mut super::core::QualityScalableInt {
        &mut self.max_spawn_count
    }
    fn peak_burn_percent(&self) -> &f32 {
        &self.peak_burn_percent
    }
    fn peak_burn_percent_mut(&mut self) -> &mut f32 {
        &mut self.peak_burn_percent
    }
    fn min_peak_flicker_percent(&self) -> &f32 {
        &self.min_peak_flicker_percent
    }
    fn min_peak_flicker_percent_mut(&mut self) -> &mut f32 {
        &mut self.min_peak_flicker_percent
    }
    fn max_peak_flicker_percent(&self) -> &f32 {
        &self.max_peak_flicker_percent
    }
    fn max_peak_flicker_percent_mut(&mut self) -> &mut f32 {
        &mut self.max_peak_flicker_percent
    }
    fn min_flicker_amplitude(&self) -> &f32 {
        &self.min_flicker_amplitude
    }
    fn min_flicker_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.min_flicker_amplitude
    }
    fn max_flicker_amplitude(&self) -> &f32 {
        &self.max_flicker_amplitude
    }
    fn max_flicker_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.max_flicker_amplitude
    }
    fn min_flicker_freq(&self) -> &f32 {
        &self.min_flicker_freq
    }
    fn min_flicker_freq_mut(&mut self) -> &mut f32 {
        &mut self.min_flicker_freq
    }
    fn max_flicker_freq(&self) -> &f32 {
        &self.max_flicker_freq
    }
    fn max_flicker_freq_mut(&mut self) -> &mut f32 {
        &mut self.max_flicker_freq
    }
    fn spawn_scale_multiplier_x(&self) -> &f32 {
        &self.spawn_scale_multiplier_x
    }
    fn spawn_scale_multiplier_x_mut(&mut self) -> &mut f32 {
        &mut self.spawn_scale_multiplier_x
    }
    fn spawn_scale_multiplier_y(&self) -> &f32 {
        &self.spawn_scale_multiplier_y
    }
    fn spawn_scale_multiplier_y_mut(&mut self) -> &mut f32 {
        &mut self.spawn_scale_multiplier_y
    }
    fn spawn_scale_multiplier_z(&self) -> &f32 {
        &self.spawn_scale_multiplier_z
    }
    fn spawn_scale_multiplier_z_mut(&mut self) -> &mut f32 {
        &mut self.spawn_scale_multiplier_z
    }
    fn align_to_terrain_normal(&self) -> &bool {
        &self.align_to_terrain_normal
    }
    fn align_to_terrain_normal_mut(&mut self) -> &mut bool {
        &mut self.align_to_terrain_normal
    }
    fn peak_growth_percent(&self) -> &f32 {
        &self.peak_growth_percent
    }
    fn peak_growth_percent_mut(&mut self) -> &mut f32 {
        &mut self.peak_growth_percent
    }
    fn growth_offset(&self) -> &f32 {
        &self.growth_offset
    }
    fn growth_offset_mut(&mut self) -> &mut f32 {
        &mut self.growth_offset
    }
    fn burn_time_multiplier(&self) -> &f32 {
        &self.burn_time_multiplier
    }
    fn burn_time_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.burn_time_multiplier
    }
    fn effect_mesh(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.effect_mesh
    }
    fn effect_mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.effect_mesh
    }
}

impl super::core::DataContainerTrait for CellFX {
}

pub static CELLFX_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CellFX",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CellFX as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableBool",
                rust_offset: offset_of!(CellFX, enabled),
            },
            FieldInfoData {
                name: "MinSpawnScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CellFX, min_spawn_scale),
            },
            FieldInfoData {
                name: "MaxSpawnScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CellFX, max_spawn_scale),
            },
            FieldInfoData {
                name: "SpawnProbability",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableFloat",
                rust_offset: offset_of!(CellFX, spawn_probability),
            },
            FieldInfoData {
                name: "MinSpawnCount",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableInt",
                rust_offset: offset_of!(CellFX, min_spawn_count),
            },
            FieldInfoData {
                name: "MaxSpawnCount",
                flags: MemberInfoFlags::new(0),
                field_type: "QualityScalableInt",
                rust_offset: offset_of!(CellFX, max_spawn_count),
            },
            FieldInfoData {
                name: "PeakBurnPercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, peak_burn_percent),
            },
            FieldInfoData {
                name: "MinPeakFlickerPercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, min_peak_flicker_percent),
            },
            FieldInfoData {
                name: "MaxPeakFlickerPercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, max_peak_flicker_percent),
            },
            FieldInfoData {
                name: "MinFlickerAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, min_flicker_amplitude),
            },
            FieldInfoData {
                name: "MaxFlickerAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, max_flicker_amplitude),
            },
            FieldInfoData {
                name: "MinFlickerFreq",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, min_flicker_freq),
            },
            FieldInfoData {
                name: "MaxFlickerFreq",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, max_flicker_freq),
            },
            FieldInfoData {
                name: "SpawnScaleMultiplierX",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, spawn_scale_multiplier_x),
            },
            FieldInfoData {
                name: "SpawnScaleMultiplierY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, spawn_scale_multiplier_y),
            },
            FieldInfoData {
                name: "SpawnScaleMultiplierZ",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, spawn_scale_multiplier_z),
            },
            FieldInfoData {
                name: "AlignToTerrainNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CellFX, align_to_terrain_normal),
            },
            FieldInfoData {
                name: "PeakGrowthPercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, peak_growth_percent),
            },
            FieldInfoData {
                name: "GrowthOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, growth_offset),
            },
            FieldInfoData {
                name: "BurnTimeMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CellFX, burn_time_multiplier),
            },
            FieldInfoData {
                name: "EffectMesh",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(CellFX, effect_mesh),
            },
        ],
    }),
    array_type: Some(CELLFX_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CellFX {
    fn type_info(&self) -> &'static TypeInfo {
        CELLFX_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CELLFX_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CellFX-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CellFX"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterLookAtTriggerEntityData {
    pub _glacier_base: TriggerEventEntityData,
    pub f_o_v: f32,
    pub min_distance_to_object: f32,
    pub max_distance_to_object: f32,
    pub start_trigger_looking_at: bool,
    pub check_occlusion: bool,
    pub use_entity_direction: bool,
}

pub trait CharacterLookAtTriggerEntityDataTrait: TriggerEventEntityDataTrait {
    fn f_o_v(&self) -> &f32;
    fn f_o_v_mut(&mut self) -> &mut f32;
    fn min_distance_to_object(&self) -> &f32;
    fn min_distance_to_object_mut(&mut self) -> &mut f32;
    fn max_distance_to_object(&self) -> &f32;
    fn max_distance_to_object_mut(&mut self) -> &mut f32;
    fn start_trigger_looking_at(&self) -> &bool;
    fn start_trigger_looking_at_mut(&mut self) -> &mut bool;
    fn check_occlusion(&self) -> &bool;
    fn check_occlusion_mut(&mut self) -> &mut bool;
    fn use_entity_direction(&self) -> &bool;
    fn use_entity_direction_mut(&mut self) -> &mut bool;
}

impl CharacterLookAtTriggerEntityDataTrait for CharacterLookAtTriggerEntityData {
    fn f_o_v(&self) -> &f32 {
        &self.f_o_v
    }
    fn f_o_v_mut(&mut self) -> &mut f32 {
        &mut self.f_o_v
    }
    fn min_distance_to_object(&self) -> &f32 {
        &self.min_distance_to_object
    }
    fn min_distance_to_object_mut(&mut self) -> &mut f32 {
        &mut self.min_distance_to_object
    }
    fn max_distance_to_object(&self) -> &f32 {
        &self.max_distance_to_object
    }
    fn max_distance_to_object_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_to_object
    }
    fn start_trigger_looking_at(&self) -> &bool {
        &self.start_trigger_looking_at
    }
    fn start_trigger_looking_at_mut(&mut self) -> &mut bool {
        &mut self.start_trigger_looking_at
    }
    fn check_occlusion(&self) -> &bool {
        &self.check_occlusion
    }
    fn check_occlusion_mut(&mut self) -> &mut bool {
        &mut self.check_occlusion
    }
    fn use_entity_direction(&self) -> &bool {
        &self.use_entity_direction
    }
    fn use_entity_direction_mut(&mut self) -> &mut bool {
        &mut self.use_entity_direction
    }
}

impl TriggerEventEntityDataTrait for CharacterLookAtTriggerEntityData {
}

impl TriggerEntityDataTrait for CharacterLookAtTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for CharacterLookAtTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CharacterLookAtTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for CharacterLookAtTriggerEntityData {
}

impl super::core::DataBusPeerTrait for CharacterLookAtTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterLookAtTriggerEntityData {
}

impl super::core::DataContainerTrait for CharacterLookAtTriggerEntityData {
}

pub static CHARACTERLOOKATTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterLookAtTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGEREVENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterLookAtTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FOV",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, f_o_v),
            },
            FieldInfoData {
                name: "MinDistanceToObject",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, min_distance_to_object),
            },
            FieldInfoData {
                name: "MaxDistanceToObject",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, max_distance_to_object),
            },
            FieldInfoData {
                name: "StartTriggerLookingAt",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, start_trigger_looking_at),
            },
            FieldInfoData {
                name: "CheckOcclusion",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, check_occlusion),
            },
            FieldInfoData {
                name: "UseEntityDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterLookAtTriggerEntityData, use_entity_direction),
            },
        ],
    }),
    array_type: Some(CHARACTERLOOKATTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterLookAtTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERLOOKATTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERLOOKATTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterLookAtTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterLookAtTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UnderFireTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub radius: f32,
    pub cool_down_time: f32,
    pub use_trigger_on_material_only: bool,
    pub trigger_on_material_only: super::entity::MaterialDecl,
    pub geometries_follow_object: bool,
    pub disable_if_track_entity_is_lost: bool,
    pub triggered_by: AreaTriggerInclude,
    pub random_yaw: bool,
    pub indicate_hit: bool,
    pub team_of_allies: super::gameplay_sim::TeamId,
}

pub trait UnderFireTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn cool_down_time(&self) -> &f32;
    fn cool_down_time_mut(&mut self) -> &mut f32;
    fn use_trigger_on_material_only(&self) -> &bool;
    fn use_trigger_on_material_only_mut(&mut self) -> &mut bool;
    fn trigger_on_material_only(&self) -> &super::entity::MaterialDecl;
    fn trigger_on_material_only_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn geometries_follow_object(&self) -> &bool;
    fn geometries_follow_object_mut(&mut self) -> &mut bool;
    fn disable_if_track_entity_is_lost(&self) -> &bool;
    fn disable_if_track_entity_is_lost_mut(&mut self) -> &mut bool;
    fn triggered_by(&self) -> &AreaTriggerInclude;
    fn triggered_by_mut(&mut self) -> &mut AreaTriggerInclude;
    fn random_yaw(&self) -> &bool;
    fn random_yaw_mut(&mut self) -> &mut bool;
    fn indicate_hit(&self) -> &bool;
    fn indicate_hit_mut(&mut self) -> &mut bool;
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId;
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
}

impl UnderFireTriggerEntityDataTrait for UnderFireTriggerEntityData {
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn cool_down_time(&self) -> &f32 {
        &self.cool_down_time
    }
    fn cool_down_time_mut(&mut self) -> &mut f32 {
        &mut self.cool_down_time
    }
    fn use_trigger_on_material_only(&self) -> &bool {
        &self.use_trigger_on_material_only
    }
    fn use_trigger_on_material_only_mut(&mut self) -> &mut bool {
        &mut self.use_trigger_on_material_only
    }
    fn trigger_on_material_only(&self) -> &super::entity::MaterialDecl {
        &self.trigger_on_material_only
    }
    fn trigger_on_material_only_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.trigger_on_material_only
    }
    fn geometries_follow_object(&self) -> &bool {
        &self.geometries_follow_object
    }
    fn geometries_follow_object_mut(&mut self) -> &mut bool {
        &mut self.geometries_follow_object
    }
    fn disable_if_track_entity_is_lost(&self) -> &bool {
        &self.disable_if_track_entity_is_lost
    }
    fn disable_if_track_entity_is_lost_mut(&mut self) -> &mut bool {
        &mut self.disable_if_track_entity_is_lost
    }
    fn triggered_by(&self) -> &AreaTriggerInclude {
        &self.triggered_by
    }
    fn triggered_by_mut(&mut self) -> &mut AreaTriggerInclude {
        &mut self.triggered_by
    }
    fn random_yaw(&self) -> &bool {
        &self.random_yaw
    }
    fn random_yaw_mut(&mut self) -> &mut bool {
        &mut self.random_yaw
    }
    fn indicate_hit(&self) -> &bool {
        &self.indicate_hit
    }
    fn indicate_hit_mut(&mut self) -> &mut bool {
        &mut self.indicate_hit
    }
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId {
        &self.team_of_allies
    }
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_of_allies
    }
}

impl TriggerEntityDataTrait for UnderFireTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for UnderFireTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for UnderFireTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for UnderFireTriggerEntityData {
}

impl super::core::DataBusPeerTrait for UnderFireTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for UnderFireTriggerEntityData {
}

impl super::core::DataContainerTrait for UnderFireTriggerEntityData {
}

pub static UNDERFIRETRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnderFireTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UnderFireTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(UnderFireTriggerEntityData, radius),
            },
            FieldInfoData {
                name: "CoolDownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(UnderFireTriggerEntityData, cool_down_time),
            },
            FieldInfoData {
                name: "UseTriggerOnMaterialOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, use_trigger_on_material_only),
            },
            FieldInfoData {
                name: "TriggerOnMaterialOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(UnderFireTriggerEntityData, trigger_on_material_only),
            },
            FieldInfoData {
                name: "GeometriesFollowObject",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, geometries_follow_object),
            },
            FieldInfoData {
                name: "DisableIfTrackEntityIsLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, disable_if_track_entity_is_lost),
            },
            FieldInfoData {
                name: "TriggeredBy",
                flags: MemberInfoFlags::new(0),
                field_type: "AreaTriggerInclude",
                rust_offset: offset_of!(UnderFireTriggerEntityData, triggered_by),
            },
            FieldInfoData {
                name: "RandomYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, random_yaw),
            },
            FieldInfoData {
                name: "IndicateHit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UnderFireTriggerEntityData, indicate_hit),
            },
            FieldInfoData {
                name: "TeamOfAllies",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(UnderFireTriggerEntityData, team_of_allies),
            },
        ],
    }),
    array_type: Some(UNDERFIRETRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for UnderFireTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        UNDERFIRETRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static UNDERFIRETRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UnderFireTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("UnderFireTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerInputTriggerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub entry_input_actions: i32,
    pub value_modifier: f32,
    pub value_modifier_for_mouse: f32,
    pub clamp_value_after_mouse_modifier: bool,
    pub enabled_from_start: bool,
    pub send_trigger_events: bool,
    pub hold_down_time: f32,
    pub accumulated_value_at_start: f32,
    pub trailing_value_at_start: f32,
}

pub trait PlayerInputTriggerEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn entry_input_actions(&self) -> &i32;
    fn entry_input_actions_mut(&mut self) -> &mut i32;
    fn value_modifier(&self) -> &f32;
    fn value_modifier_mut(&mut self) -> &mut f32;
    fn value_modifier_for_mouse(&self) -> &f32;
    fn value_modifier_for_mouse_mut(&mut self) -> &mut f32;
    fn clamp_value_after_mouse_modifier(&self) -> &bool;
    fn clamp_value_after_mouse_modifier_mut(&mut self) -> &mut bool;
    fn enabled_from_start(&self) -> &bool;
    fn enabled_from_start_mut(&mut self) -> &mut bool;
    fn send_trigger_events(&self) -> &bool;
    fn send_trigger_events_mut(&mut self) -> &mut bool;
    fn hold_down_time(&self) -> &f32;
    fn hold_down_time_mut(&mut self) -> &mut f32;
    fn accumulated_value_at_start(&self) -> &f32;
    fn accumulated_value_at_start_mut(&mut self) -> &mut f32;
    fn trailing_value_at_start(&self) -> &f32;
    fn trailing_value_at_start_mut(&mut self) -> &mut f32;
}

impl PlayerInputTriggerEntityDataTrait for PlayerInputTriggerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn entry_input_actions(&self) -> &i32 {
        &self.entry_input_actions
    }
    fn entry_input_actions_mut(&mut self) -> &mut i32 {
        &mut self.entry_input_actions
    }
    fn value_modifier(&self) -> &f32 {
        &self.value_modifier
    }
    fn value_modifier_mut(&mut self) -> &mut f32 {
        &mut self.value_modifier
    }
    fn value_modifier_for_mouse(&self) -> &f32 {
        &self.value_modifier_for_mouse
    }
    fn value_modifier_for_mouse_mut(&mut self) -> &mut f32 {
        &mut self.value_modifier_for_mouse
    }
    fn clamp_value_after_mouse_modifier(&self) -> &bool {
        &self.clamp_value_after_mouse_modifier
    }
    fn clamp_value_after_mouse_modifier_mut(&mut self) -> &mut bool {
        &mut self.clamp_value_after_mouse_modifier
    }
    fn enabled_from_start(&self) -> &bool {
        &self.enabled_from_start
    }
    fn enabled_from_start_mut(&mut self) -> &mut bool {
        &mut self.enabled_from_start
    }
    fn send_trigger_events(&self) -> &bool {
        &self.send_trigger_events
    }
    fn send_trigger_events_mut(&mut self) -> &mut bool {
        &mut self.send_trigger_events
    }
    fn hold_down_time(&self) -> &f32 {
        &self.hold_down_time
    }
    fn hold_down_time_mut(&mut self) -> &mut f32 {
        &mut self.hold_down_time
    }
    fn accumulated_value_at_start(&self) -> &f32 {
        &self.accumulated_value_at_start
    }
    fn accumulated_value_at_start_mut(&mut self) -> &mut f32 {
        &mut self.accumulated_value_at_start
    }
    fn trailing_value_at_start(&self) -> &f32 {
        &self.trailing_value_at_start
    }
    fn trailing_value_at_start_mut(&mut self) -> &mut f32 {
        &mut self.trailing_value_at_start
    }
}

impl super::entity::EntityDataTrait for PlayerInputTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerInputTriggerEntityData {
}

impl super::core::DataBusPeerTrait for PlayerInputTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerInputTriggerEntityData {
}

impl super::core::DataContainerTrait for PlayerInputTriggerEntityData {
}

pub static PLAYERINPUTTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerInputTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerInputTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, realm),
            },
            FieldInfoData {
                name: "EntryInputActions",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, entry_input_actions),
            },
            FieldInfoData {
                name: "ValueModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, value_modifier),
            },
            FieldInfoData {
                name: "ValueModifierForMouse",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, value_modifier_for_mouse),
            },
            FieldInfoData {
                name: "ClampValueAfterMouseModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, clamp_value_after_mouse_modifier),
            },
            FieldInfoData {
                name: "EnabledFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, enabled_from_start),
            },
            FieldInfoData {
                name: "SendTriggerEvents",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, send_trigger_events),
            },
            FieldInfoData {
                name: "HoldDownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, hold_down_time),
            },
            FieldInfoData {
                name: "AccumulatedValueAtStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, accumulated_value_at_start),
            },
            FieldInfoData {
                name: "TrailingValueAtStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerInputTriggerEntityData, trailing_value_at_start),
            },
        ],
    }),
    array_type: Some(PLAYERINPUTTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerInputTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERINPUTTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERINPUTTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerInputTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerInputTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraEnterAreaTriggerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub local_player_id: super::core::LocalPlayerId,
    pub trigger_for_all_players: bool,
    pub auto_start: bool,
    pub update_pass: super::entity::UpdatePass,
    pub time_treshold: f32,
}

pub trait CameraEnterAreaTriggerEntityDataTrait: super::entity::EntityDataTrait {
    fn local_player_id(&self) -> &super::core::LocalPlayerId;
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId;
    fn trigger_for_all_players(&self) -> &bool;
    fn trigger_for_all_players_mut(&mut self) -> &mut bool;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn update_pass(&self) -> &super::entity::UpdatePass;
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass;
    fn time_treshold(&self) -> &f32;
    fn time_treshold_mut(&mut self) -> &mut f32;
}

impl CameraEnterAreaTriggerEntityDataTrait for CameraEnterAreaTriggerEntityData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        &self.local_player_id
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        &mut self.local_player_id
    }
    fn trigger_for_all_players(&self) -> &bool {
        &self.trigger_for_all_players
    }
    fn trigger_for_all_players_mut(&mut self) -> &mut bool {
        &mut self.trigger_for_all_players
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn update_pass(&self) -> &super::entity::UpdatePass {
        &self.update_pass
    }
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        &mut self.update_pass
    }
    fn time_treshold(&self) -> &f32 {
        &self.time_treshold
    }
    fn time_treshold_mut(&mut self) -> &mut f32 {
        &mut self.time_treshold
    }
}

impl super::entity::EntityDataTrait for CameraEnterAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for CameraEnterAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for CameraEnterAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CameraEnterAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for CameraEnterAreaTriggerEntityData {
}

pub static CAMERAENTERAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEnterAreaTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraEnterAreaTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LocalPlayerId",
                flags: MemberInfoFlags::new(0),
                field_type: "LocalPlayerId",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, local_player_id),
            },
            FieldInfoData {
                name: "TriggerForAllPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, trigger_for_all_players),
            },
            FieldInfoData {
                name: "AutoStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, auto_start),
            },
            FieldInfoData {
                name: "UpdatePass",
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, update_pass),
            },
            FieldInfoData {
                name: "TimeTreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CameraEnterAreaTriggerEntityData, time_treshold),
            },
        ],
    }),
    array_type: Some(CAMERAENTERAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraEnterAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAENTERAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAENTERAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraEnterAreaTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraEnterAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IntersectionTriggerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub update_pass: super::entity::UpdatePass,
    pub condition: IntersectionTriggerCondition,
    pub run_once: bool,
    pub enabled: bool,
}

pub trait IntersectionTriggerEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn update_pass(&self) -> &super::entity::UpdatePass;
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass;
    fn condition(&self) -> &IntersectionTriggerCondition;
    fn condition_mut(&mut self) -> &mut IntersectionTriggerCondition;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl IntersectionTriggerEntityDataTrait for IntersectionTriggerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn update_pass(&self) -> &super::entity::UpdatePass {
        &self.update_pass
    }
    fn update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        &mut self.update_pass
    }
    fn condition(&self) -> &IntersectionTriggerCondition {
        &self.condition
    }
    fn condition_mut(&mut self) -> &mut IntersectionTriggerCondition {
        &mut self.condition
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for IntersectionTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for IntersectionTriggerEntityData {
}

impl super::core::DataBusPeerTrait for IntersectionTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IntersectionTriggerEntityData {
}

impl super::core::DataContainerTrait for IntersectionTriggerEntityData {
}

pub static INTERSECTIONTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntersectionTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IntersectionTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(IntersectionTriggerEntityData, realm),
            },
            FieldInfoData {
                name: "UpdatePass",
                flags: MemberInfoFlags::new(0),
                field_type: "UpdatePass",
                rust_offset: offset_of!(IntersectionTriggerEntityData, update_pass),
            },
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(0),
                field_type: "IntersectionTriggerCondition",
                rust_offset: offset_of!(IntersectionTriggerEntityData, condition),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IntersectionTriggerEntityData, run_once),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IntersectionTriggerEntityData, enabled),
            },
        ],
    }),
    array_type: Some(INTERSECTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IntersectionTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTERSECTIONTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTERSECTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntersectionTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntersectionTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum IntersectionTriggerCondition {
    #[default]
    IntersectionTriggerCondition_OneObjectIntersects = 0,
    IntersectionTriggerCondition_AllObjectsIntersect = 1,
}

pub static INTERSECTIONTRIGGERCONDITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntersectionTriggerCondition",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(INTERSECTIONTRIGGERCONDITION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for IntersectionTriggerCondition {
    fn type_info(&self) -> &'static TypeInfo {
        INTERSECTIONTRIGGERCONDITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INTERSECTIONTRIGGERCONDITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntersectionTriggerCondition-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IntersectionTriggerCondition"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerTakeOverTriggerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub team_id: super::gameplay_sim::TeamId,
    pub time_to_lose_control: f32,
}

pub trait PlayerTakeOverTriggerEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn team_id(&self) -> &super::gameplay_sim::TeamId;
    fn team_id_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn time_to_lose_control(&self) -> &f32;
    fn time_to_lose_control_mut(&mut self) -> &mut f32;
}

impl PlayerTakeOverTriggerEntityDataTrait for PlayerTakeOverTriggerEntityData {
    fn team_id(&self) -> &super::gameplay_sim::TeamId {
        &self.team_id
    }
    fn team_id_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_id
    }
    fn time_to_lose_control(&self) -> &f32 {
        &self.time_to_lose_control
    }
    fn time_to_lose_control_mut(&mut self) -> &mut f32 {
        &mut self.time_to_lose_control
    }
}

impl super::entity::SpatialEntityDataTrait for PlayerTakeOverTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for PlayerTakeOverTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerTakeOverTriggerEntityData {
}

impl super::core::DataBusPeerTrait for PlayerTakeOverTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerTakeOverTriggerEntityData {
}

impl super::core::DataContainerTrait for PlayerTakeOverTriggerEntityData {
}

pub static PLAYERTAKEOVERTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerTakeOverTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerTakeOverTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TeamId",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(PlayerTakeOverTriggerEntityData, team_id),
            },
            FieldInfoData {
                name: "TimeToLoseControl",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerTakeOverTriggerEntityData, time_to_lose_control),
            },
        ],
    }),
    array_type: Some(PLAYERTAKEOVERTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PlayerTakeOverTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERTAKEOVERTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERTAKEOVERTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerTakeOverTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerTakeOverTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DamageAreaTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub damage_characters: bool,
    pub damage_vehicles: bool,
    pub damage_characters_in_vehicles: bool,
    pub damage_bangers: bool,
    pub damage_per_second: f32,
    pub damage_time: f32,
    pub exclude_immortal_characters_in_team: bool,
    pub team_of_immortal_characters: super::gameplay_sim::TeamId,
    pub exclude_shielded_soldiers: bool,
    pub is_never_triggered_by_player: bool,
}

pub trait DamageAreaTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn damage_characters(&self) -> &bool;
    fn damage_characters_mut(&mut self) -> &mut bool;
    fn damage_vehicles(&self) -> &bool;
    fn damage_vehicles_mut(&mut self) -> &mut bool;
    fn damage_characters_in_vehicles(&self) -> &bool;
    fn damage_characters_in_vehicles_mut(&mut self) -> &mut bool;
    fn damage_bangers(&self) -> &bool;
    fn damage_bangers_mut(&mut self) -> &mut bool;
    fn damage_per_second(&self) -> &f32;
    fn damage_per_second_mut(&mut self) -> &mut f32;
    fn damage_time(&self) -> &f32;
    fn damage_time_mut(&mut self) -> &mut f32;
    fn exclude_immortal_characters_in_team(&self) -> &bool;
    fn exclude_immortal_characters_in_team_mut(&mut self) -> &mut bool;
    fn team_of_immortal_characters(&self) -> &super::gameplay_sim::TeamId;
    fn team_of_immortal_characters_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn exclude_shielded_soldiers(&self) -> &bool;
    fn exclude_shielded_soldiers_mut(&mut self) -> &mut bool;
    fn is_never_triggered_by_player(&self) -> &bool;
    fn is_never_triggered_by_player_mut(&mut self) -> &mut bool;
}

impl DamageAreaTriggerEntityDataTrait for DamageAreaTriggerEntityData {
    fn damage_characters(&self) -> &bool {
        &self.damage_characters
    }
    fn damage_characters_mut(&mut self) -> &mut bool {
        &mut self.damage_characters
    }
    fn damage_vehicles(&self) -> &bool {
        &self.damage_vehicles
    }
    fn damage_vehicles_mut(&mut self) -> &mut bool {
        &mut self.damage_vehicles
    }
    fn damage_characters_in_vehicles(&self) -> &bool {
        &self.damage_characters_in_vehicles
    }
    fn damage_characters_in_vehicles_mut(&mut self) -> &mut bool {
        &mut self.damage_characters_in_vehicles
    }
    fn damage_bangers(&self) -> &bool {
        &self.damage_bangers
    }
    fn damage_bangers_mut(&mut self) -> &mut bool {
        &mut self.damage_bangers
    }
    fn damage_per_second(&self) -> &f32 {
        &self.damage_per_second
    }
    fn damage_per_second_mut(&mut self) -> &mut f32 {
        &mut self.damage_per_second
    }
    fn damage_time(&self) -> &f32 {
        &self.damage_time
    }
    fn damage_time_mut(&mut self) -> &mut f32 {
        &mut self.damage_time
    }
    fn exclude_immortal_characters_in_team(&self) -> &bool {
        &self.exclude_immortal_characters_in_team
    }
    fn exclude_immortal_characters_in_team_mut(&mut self) -> &mut bool {
        &mut self.exclude_immortal_characters_in_team
    }
    fn team_of_immortal_characters(&self) -> &super::gameplay_sim::TeamId {
        &self.team_of_immortal_characters
    }
    fn team_of_immortal_characters_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_of_immortal_characters
    }
    fn exclude_shielded_soldiers(&self) -> &bool {
        &self.exclude_shielded_soldiers
    }
    fn exclude_shielded_soldiers_mut(&mut self) -> &mut bool {
        &mut self.exclude_shielded_soldiers
    }
    fn is_never_triggered_by_player(&self) -> &bool {
        &self.is_never_triggered_by_player
    }
    fn is_never_triggered_by_player_mut(&mut self) -> &mut bool {
        &mut self.is_never_triggered_by_player
    }
}

impl TriggerEntityDataTrait for DamageAreaTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DamageAreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DamageAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for DamageAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for DamageAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DamageAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for DamageAreaTriggerEntityData {
}

pub static DAMAGEAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageAreaTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DamageAreaTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DamageCharacters",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_characters),
            },
            FieldInfoData {
                name: "DamageVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_vehicles),
            },
            FieldInfoData {
                name: "DamageCharactersInVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_characters_in_vehicles),
            },
            FieldInfoData {
                name: "DamageBangers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_bangers),
            },
            FieldInfoData {
                name: "DamagePerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_per_second),
            },
            FieldInfoData {
                name: "DamageTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, damage_time),
            },
            FieldInfoData {
                name: "ExcludeImmortalCharactersInTeam",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, exclude_immortal_characters_in_team),
            },
            FieldInfoData {
                name: "TeamOfImmortalCharacters",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, team_of_immortal_characters),
            },
            FieldInfoData {
                name: "ExcludeShieldedSoldiers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, exclude_shielded_soldiers),
            },
            FieldInfoData {
                name: "IsNeverTriggeredByPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageAreaTriggerEntityData, is_never_triggered_by_player),
            },
        ],
    }),
    array_type: Some(DAMAGEAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DamageAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DAMAGEAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageAreaTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DamageAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClearAreaTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub remove_soldiers: bool,
    pub remove_vehicles: bool,
    pub remove_bangers: bool,
    pub remove_effects: bool,
    pub remove_mesh_proxies: bool,
    pub remove_static_models: bool,
    pub remove_debris_clusters: bool,
    pub exclude_immortal_soldiers_in_team: bool,
    pub team_of_immortal_soldiers: super::gameplay_sim::TeamId,
}

pub trait ClearAreaTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn remove_soldiers(&self) -> &bool;
    fn remove_soldiers_mut(&mut self) -> &mut bool;
    fn remove_vehicles(&self) -> &bool;
    fn remove_vehicles_mut(&mut self) -> &mut bool;
    fn remove_bangers(&self) -> &bool;
    fn remove_bangers_mut(&mut self) -> &mut bool;
    fn remove_effects(&self) -> &bool;
    fn remove_effects_mut(&mut self) -> &mut bool;
    fn remove_mesh_proxies(&self) -> &bool;
    fn remove_mesh_proxies_mut(&mut self) -> &mut bool;
    fn remove_static_models(&self) -> &bool;
    fn remove_static_models_mut(&mut self) -> &mut bool;
    fn remove_debris_clusters(&self) -> &bool;
    fn remove_debris_clusters_mut(&mut self) -> &mut bool;
    fn exclude_immortal_soldiers_in_team(&self) -> &bool;
    fn exclude_immortal_soldiers_in_team_mut(&mut self) -> &mut bool;
    fn team_of_immortal_soldiers(&self) -> &super::gameplay_sim::TeamId;
    fn team_of_immortal_soldiers_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
}

impl ClearAreaTriggerEntityDataTrait for ClearAreaTriggerEntityData {
    fn remove_soldiers(&self) -> &bool {
        &self.remove_soldiers
    }
    fn remove_soldiers_mut(&mut self) -> &mut bool {
        &mut self.remove_soldiers
    }
    fn remove_vehicles(&self) -> &bool {
        &self.remove_vehicles
    }
    fn remove_vehicles_mut(&mut self) -> &mut bool {
        &mut self.remove_vehicles
    }
    fn remove_bangers(&self) -> &bool {
        &self.remove_bangers
    }
    fn remove_bangers_mut(&mut self) -> &mut bool {
        &mut self.remove_bangers
    }
    fn remove_effects(&self) -> &bool {
        &self.remove_effects
    }
    fn remove_effects_mut(&mut self) -> &mut bool {
        &mut self.remove_effects
    }
    fn remove_mesh_proxies(&self) -> &bool {
        &self.remove_mesh_proxies
    }
    fn remove_mesh_proxies_mut(&mut self) -> &mut bool {
        &mut self.remove_mesh_proxies
    }
    fn remove_static_models(&self) -> &bool {
        &self.remove_static_models
    }
    fn remove_static_models_mut(&mut self) -> &mut bool {
        &mut self.remove_static_models
    }
    fn remove_debris_clusters(&self) -> &bool {
        &self.remove_debris_clusters
    }
    fn remove_debris_clusters_mut(&mut self) -> &mut bool {
        &mut self.remove_debris_clusters
    }
    fn exclude_immortal_soldiers_in_team(&self) -> &bool {
        &self.exclude_immortal_soldiers_in_team
    }
    fn exclude_immortal_soldiers_in_team_mut(&mut self) -> &mut bool {
        &mut self.exclude_immortal_soldiers_in_team
    }
    fn team_of_immortal_soldiers(&self) -> &super::gameplay_sim::TeamId {
        &self.team_of_immortal_soldiers
    }
    fn team_of_immortal_soldiers_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_of_immortal_soldiers
    }
}

impl TriggerEntityDataTrait for ClearAreaTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for ClearAreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for ClearAreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for ClearAreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for ClearAreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClearAreaTriggerEntityData {
}

impl super::core::DataContainerTrait for ClearAreaTriggerEntityData {
}

pub static CLEARAREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearAreaTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClearAreaTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RemoveSoldiers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_soldiers),
            },
            FieldInfoData {
                name: "RemoveVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_vehicles),
            },
            FieldInfoData {
                name: "RemoveBangers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_bangers),
            },
            FieldInfoData {
                name: "RemoveEffects",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_effects),
            },
            FieldInfoData {
                name: "RemoveMeshProxies",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_mesh_proxies),
            },
            FieldInfoData {
                name: "RemoveStaticModels",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_static_models),
            },
            FieldInfoData {
                name: "RemoveDebrisClusters",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, remove_debris_clusters),
            },
            FieldInfoData {
                name: "ExcludeImmortalSoldiersInTeam",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, exclude_immortal_soldiers_in_team),
            },
            FieldInfoData {
                name: "TeamOfImmortalSoldiers",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(ClearAreaTriggerEntityData, team_of_immortal_soldiers),
            },
        ],
    }),
    array_type: Some(CLEARAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ClearAreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLEARAREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLEARAREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClearAreaTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClearAreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleStateTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub lock_amount: f32,
    pub allow_human_to_enter_all_seats: bool,
    pub restrict_human_to_specific_seat: bool,
    pub seat_specific_index_for_human: u32,
    pub allow_ai_to_enter_all_seats: bool,
    pub ban_ai_from_specific_seat: bool,
    pub seat_specific_index_for_ai: u32,
    pub bullet_count: u32,
    pub health_to_set: u32,
    pub health_to_check: u32,
    pub trigger_critical_on_health_set: bool,
    pub check_health_greater_or_equal: bool,
    pub destruction_radius: f32,
    pub should_destroy_vehicles: bool,
    pub should_destroy_bangers: bool,
}

pub trait VehicleStateTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn lock_amount(&self) -> &f32;
    fn lock_amount_mut(&mut self) -> &mut f32;
    fn allow_human_to_enter_all_seats(&self) -> &bool;
    fn allow_human_to_enter_all_seats_mut(&mut self) -> &mut bool;
    fn restrict_human_to_specific_seat(&self) -> &bool;
    fn restrict_human_to_specific_seat_mut(&mut self) -> &mut bool;
    fn seat_specific_index_for_human(&self) -> &u32;
    fn seat_specific_index_for_human_mut(&mut self) -> &mut u32;
    fn allow_ai_to_enter_all_seats(&self) -> &bool;
    fn allow_ai_to_enter_all_seats_mut(&mut self) -> &mut bool;
    fn ban_ai_from_specific_seat(&self) -> &bool;
    fn ban_ai_from_specific_seat_mut(&mut self) -> &mut bool;
    fn seat_specific_index_for_ai(&self) -> &u32;
    fn seat_specific_index_for_ai_mut(&mut self) -> &mut u32;
    fn bullet_count(&self) -> &u32;
    fn bullet_count_mut(&mut self) -> &mut u32;
    fn health_to_set(&self) -> &u32;
    fn health_to_set_mut(&mut self) -> &mut u32;
    fn health_to_check(&self) -> &u32;
    fn health_to_check_mut(&mut self) -> &mut u32;
    fn trigger_critical_on_health_set(&self) -> &bool;
    fn trigger_critical_on_health_set_mut(&mut self) -> &mut bool;
    fn check_health_greater_or_equal(&self) -> &bool;
    fn check_health_greater_or_equal_mut(&mut self) -> &mut bool;
    fn destruction_radius(&self) -> &f32;
    fn destruction_radius_mut(&mut self) -> &mut f32;
    fn should_destroy_vehicles(&self) -> &bool;
    fn should_destroy_vehicles_mut(&mut self) -> &mut bool;
    fn should_destroy_bangers(&self) -> &bool;
    fn should_destroy_bangers_mut(&mut self) -> &mut bool;
}

impl VehicleStateTriggerEntityDataTrait for VehicleStateTriggerEntityData {
    fn lock_amount(&self) -> &f32 {
        &self.lock_amount
    }
    fn lock_amount_mut(&mut self) -> &mut f32 {
        &mut self.lock_amount
    }
    fn allow_human_to_enter_all_seats(&self) -> &bool {
        &self.allow_human_to_enter_all_seats
    }
    fn allow_human_to_enter_all_seats_mut(&mut self) -> &mut bool {
        &mut self.allow_human_to_enter_all_seats
    }
    fn restrict_human_to_specific_seat(&self) -> &bool {
        &self.restrict_human_to_specific_seat
    }
    fn restrict_human_to_specific_seat_mut(&mut self) -> &mut bool {
        &mut self.restrict_human_to_specific_seat
    }
    fn seat_specific_index_for_human(&self) -> &u32 {
        &self.seat_specific_index_for_human
    }
    fn seat_specific_index_for_human_mut(&mut self) -> &mut u32 {
        &mut self.seat_specific_index_for_human
    }
    fn allow_ai_to_enter_all_seats(&self) -> &bool {
        &self.allow_ai_to_enter_all_seats
    }
    fn allow_ai_to_enter_all_seats_mut(&mut self) -> &mut bool {
        &mut self.allow_ai_to_enter_all_seats
    }
    fn ban_ai_from_specific_seat(&self) -> &bool {
        &self.ban_ai_from_specific_seat
    }
    fn ban_ai_from_specific_seat_mut(&mut self) -> &mut bool {
        &mut self.ban_ai_from_specific_seat
    }
    fn seat_specific_index_for_ai(&self) -> &u32 {
        &self.seat_specific_index_for_ai
    }
    fn seat_specific_index_for_ai_mut(&mut self) -> &mut u32 {
        &mut self.seat_specific_index_for_ai
    }
    fn bullet_count(&self) -> &u32 {
        &self.bullet_count
    }
    fn bullet_count_mut(&mut self) -> &mut u32 {
        &mut self.bullet_count
    }
    fn health_to_set(&self) -> &u32 {
        &self.health_to_set
    }
    fn health_to_set_mut(&mut self) -> &mut u32 {
        &mut self.health_to_set
    }
    fn health_to_check(&self) -> &u32 {
        &self.health_to_check
    }
    fn health_to_check_mut(&mut self) -> &mut u32 {
        &mut self.health_to_check
    }
    fn trigger_critical_on_health_set(&self) -> &bool {
        &self.trigger_critical_on_health_set
    }
    fn trigger_critical_on_health_set_mut(&mut self) -> &mut bool {
        &mut self.trigger_critical_on_health_set
    }
    fn check_health_greater_or_equal(&self) -> &bool {
        &self.check_health_greater_or_equal
    }
    fn check_health_greater_or_equal_mut(&mut self) -> &mut bool {
        &mut self.check_health_greater_or_equal
    }
    fn destruction_radius(&self) -> &f32 {
        &self.destruction_radius
    }
    fn destruction_radius_mut(&mut self) -> &mut f32 {
        &mut self.destruction_radius
    }
    fn should_destroy_vehicles(&self) -> &bool {
        &self.should_destroy_vehicles
    }
    fn should_destroy_vehicles_mut(&mut self) -> &mut bool {
        &mut self.should_destroy_vehicles
    }
    fn should_destroy_bangers(&self) -> &bool {
        &self.should_destroy_bangers
    }
    fn should_destroy_bangers_mut(&mut self) -> &mut bool {
        &mut self.should_destroy_bangers
    }
}

impl TriggerEntityDataTrait for VehicleStateTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for VehicleStateTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for VehicleStateTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for VehicleStateTriggerEntityData {
}

impl super::core::DataBusPeerTrait for VehicleStateTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleStateTriggerEntityData {
}

impl super::core::DataContainerTrait for VehicleStateTriggerEntityData {
}

pub static VEHICLESTATETRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleStateTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleStateTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LockAmount",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, lock_amount),
            },
            FieldInfoData {
                name: "AllowHumanToEnterAllSeats",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, allow_human_to_enter_all_seats),
            },
            FieldInfoData {
                name: "RestrictHumanToSpecificSeat",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, restrict_human_to_specific_seat),
            },
            FieldInfoData {
                name: "SeatSpecificIndexForHuman",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, seat_specific_index_for_human),
            },
            FieldInfoData {
                name: "AllowAiToEnterAllSeats",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, allow_ai_to_enter_all_seats),
            },
            FieldInfoData {
                name: "BanAiFromSpecificSeat",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, ban_ai_from_specific_seat),
            },
            FieldInfoData {
                name: "SeatSpecificIndexForAi",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, seat_specific_index_for_ai),
            },
            FieldInfoData {
                name: "BulletCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, bullet_count),
            },
            FieldInfoData {
                name: "HealthToSet",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, health_to_set),
            },
            FieldInfoData {
                name: "HealthToCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, health_to_check),
            },
            FieldInfoData {
                name: "TriggerCriticalOnHealthSet",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, trigger_critical_on_health_set),
            },
            FieldInfoData {
                name: "CheckHealthGreaterOrEqual",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, check_health_greater_or_equal),
            },
            FieldInfoData {
                name: "DestructionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, destruction_radius),
            },
            FieldInfoData {
                name: "ShouldDestroyVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, should_destroy_vehicles),
            },
            FieldInfoData {
                name: "ShouldDestroyBangers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleStateTriggerEntityData, should_destroy_bangers),
            },
        ],
    }),
    array_type: Some(VEHICLESTATETRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleStateTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLESTATETRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLESTATETRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleStateTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleStateTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CharacterPoseAction {
    #[default]
    CPTNoAction = 0,
    CPTForceToStand = 1,
    CPTForceToCroch = 2,
    CPTForceToProne = 3,
}

pub static CHARACTERPOSEACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseAction",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHARACTERPOSEACTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CharacterPoseAction {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERPOSEACTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHARACTERPOSEACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterPoseAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterPoseAction"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DelayTriggerEntityData {
    pub _glacier_base: TriggerEventEntityData,
    pub auto_trigger_event: bool,
}

pub trait DelayTriggerEntityDataTrait: TriggerEventEntityDataTrait {
    fn auto_trigger_event(&self) -> &bool;
    fn auto_trigger_event_mut(&mut self) -> &mut bool;
}

impl DelayTriggerEntityDataTrait for DelayTriggerEntityData {
    fn auto_trigger_event(&self) -> &bool {
        &self.auto_trigger_event
    }
    fn auto_trigger_event_mut(&mut self) -> &mut bool {
        &mut self.auto_trigger_event
    }
}

impl TriggerEventEntityDataTrait for DelayTriggerEntityData {
}

impl TriggerEntityDataTrait for DelayTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for DelayTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DelayTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for DelayTriggerEntityData {
}

impl super::core::DataBusPeerTrait for DelayTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DelayTriggerEntityData {
}

impl super::core::DataContainerTrait for DelayTriggerEntityData {
}

pub static DELAYTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGEREVENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DelayTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AutoTriggerEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DelayTriggerEntityData, auto_trigger_event),
            },
        ],
    }),
    array_type: Some(DELAYTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DelayTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DELAYTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELAYTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DelayTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultipleTriggerEntityData {
    pub _glacier_base: TriggerEventEntityData,
    pub trigger_amount: i32,
}

pub trait MultipleTriggerEntityDataTrait: TriggerEventEntityDataTrait {
    fn trigger_amount(&self) -> &i32;
    fn trigger_amount_mut(&mut self) -> &mut i32;
}

impl MultipleTriggerEntityDataTrait for MultipleTriggerEntityData {
    fn trigger_amount(&self) -> &i32 {
        &self.trigger_amount
    }
    fn trigger_amount_mut(&mut self) -> &mut i32 {
        &mut self.trigger_amount
    }
}

impl TriggerEventEntityDataTrait for MultipleTriggerEntityData {
}

impl TriggerEntityDataTrait for MultipleTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for MultipleTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for MultipleTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for MultipleTriggerEntityData {
}

impl super::core::DataBusPeerTrait for MultipleTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MultipleTriggerEntityData {
}

impl super::core::DataContainerTrait for MultipleTriggerEntityData {
}

pub static MULTIPLETRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGEREVENTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultipleTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TriggerAmount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MultipleTriggerEntityData, trigger_amount),
            },
        ],
    }),
    array_type: Some(MULTIPLETRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MultipleTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTIPLETRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTIPLETRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MultipleTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TriggerEventEntityData {
    pub _glacier_base: TriggerEntityData,
}

pub trait TriggerEventEntityDataTrait: TriggerEntityDataTrait {
}

impl TriggerEventEntityDataTrait for TriggerEventEntityData {
}

impl TriggerEntityDataTrait for TriggerEventEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for TriggerEventEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TriggerEventEntityData {
}

impl super::entity::GameObjectDataTrait for TriggerEventEntityData {
}

impl super::core::DataBusPeerTrait for TriggerEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TriggerEventEntityData {
}

impl super::core::DataContainerTrait for TriggerEventEntityData {
}

pub static TRIGGEREVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TriggerEventEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(TRIGGEREVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TriggerEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRIGGEREVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRIGGEREVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TriggerEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CombatActionTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub time_to_trigger_on_no_action: f32,
}

pub trait CombatActionTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn time_to_trigger_on_no_action(&self) -> &f32;
    fn time_to_trigger_on_no_action_mut(&mut self) -> &mut f32;
}

impl CombatActionTriggerEntityDataTrait for CombatActionTriggerEntityData {
    fn time_to_trigger_on_no_action(&self) -> &f32 {
        &self.time_to_trigger_on_no_action
    }
    fn time_to_trigger_on_no_action_mut(&mut self) -> &mut f32 {
        &mut self.time_to_trigger_on_no_action
    }
}

impl TriggerEntityDataTrait for CombatActionTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for CombatActionTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CombatActionTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for CombatActionTriggerEntityData {
}

impl super::core::DataBusPeerTrait for CombatActionTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CombatActionTriggerEntityData {
}

impl super::core::DataContainerTrait for CombatActionTriggerEntityData {
}

pub static COMBATACTIONTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatActionTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CombatActionTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TimeToTriggerOnNoAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatActionTriggerEntityData, time_to_trigger_on_no_action),
            },
        ],
    }),
    array_type: Some(COMBATACTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CombatActionTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COMBATACTIONTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMBATACTIONTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatActionTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CombatActionTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GeometryTriggerEntityData {
    pub _glacier_base: AreaTriggerEntityData,
}

pub trait GeometryTriggerEntityDataTrait: AreaTriggerEntityDataTrait {
}

impl GeometryTriggerEntityDataTrait for GeometryTriggerEntityData {
}

impl AreaTriggerEntityDataTrait for GeometryTriggerEntityData {
    fn geometry_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.geometry_transform()
    }
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.geometry_transform_mut()
    }
    fn include(&self) -> &AreaTriggerInclude {
        self._glacier_base.include()
    }
    fn include_mut(&mut self) -> &mut AreaTriggerInclude {
        self._glacier_base.include_mut()
    }
    fn use_character_entity(&self) -> &bool {
        self._glacier_base.use_character_entity()
    }
    fn use_character_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.use_character_entity_mut()
    }
    fn radius(&self) -> &f32 {
        self._glacier_base.radius()
    }
    fn radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.radius_mut()
    }
    fn use_radius_with_geometry_transform(&self) -> &bool {
        self._glacier_base.use_radius_with_geometry_transform()
    }
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool {
        self._glacier_base.use_radius_with_geometry_transform_mut()
    }
    fn geometries_follow_object(&self) -> &bool {
        self._glacier_base.geometries_follow_object()
    }
    fn geometries_follow_object_mut(&mut self) -> &mut bool {
        self._glacier_base.geometries_follow_object_mut()
    }
    fn inside_area_event_repeat_time(&self) -> &f32 {
        self._glacier_base.inside_area_event_repeat_time()
    }
    fn inside_area_event_repeat_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.inside_area_event_repeat_time_mut()
    }
    fn one_inside_area_event_per_soldier(&self) -> &bool {
        self._glacier_base.one_inside_area_event_per_soldier()
    }
    fn one_inside_area_event_per_soldier_mut(&mut self) -> &mut bool {
        self._glacier_base.one_inside_area_event_per_soldier_mut()
    }
    fn trigger_only_on_leave(&self) -> &bool {
        self._glacier_base.trigger_only_on_leave()
    }
    fn trigger_only_on_leave_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_only_on_leave_mut()
    }
    fn reset_on_enable(&self) -> &bool {
        self._glacier_base.reset_on_enable()
    }
    fn reset_on_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.reset_on_enable_mut()
    }
    fn trigger_on_leave_on_death(&self) -> &bool {
        self._glacier_base.trigger_on_leave_on_death()
    }
    fn trigger_on_leave_on_death_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_leave_on_death_mut()
    }
    fn trigger_on_leave_on_disable(&self) -> &bool {
        self._glacier_base.trigger_on_leave_on_disable()
    }
    fn trigger_on_leave_on_disable_mut(&mut self) -> &mut bool {
        self._glacier_base.trigger_on_leave_on_disable_mut()
    }
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.team_of_allies()
    }
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.team_of_allies_mut()
    }
}

impl TriggerEntityDataTrait for GeometryTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for GeometryTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for GeometryTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for GeometryTriggerEntityData {
}

impl super::core::DataBusPeerTrait for GeometryTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for GeometryTriggerEntityData {
}

impl super::core::DataContainerTrait for GeometryTriggerEntityData {
}

pub static GEOMETRYTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GeometryTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AREATRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GeometryTriggerEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GEOMETRYTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for GeometryTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        GEOMETRYTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GEOMETRYTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GeometryTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GeometryTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AreaTriggerEntityData {
    pub _glacier_base: TriggerEntityData,
    pub geometry_transform: super::core::LinearTransform,
    pub include: AreaTriggerInclude,
    pub use_character_entity: bool,
    pub radius: f32,
    pub use_radius_with_geometry_transform: bool,
    pub geometries_follow_object: bool,
    pub inside_area_event_repeat_time: f32,
    pub one_inside_area_event_per_soldier: bool,
    pub trigger_only_on_leave: bool,
    pub reset_on_enable: bool,
    pub trigger_on_leave_on_death: bool,
    pub trigger_on_leave_on_disable: bool,
    pub team_of_allies: super::gameplay_sim::TeamId,
}

pub trait AreaTriggerEntityDataTrait: TriggerEntityDataTrait {
    fn geometry_transform(&self) -> &super::core::LinearTransform;
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn include(&self) -> &AreaTriggerInclude;
    fn include_mut(&mut self) -> &mut AreaTriggerInclude;
    fn use_character_entity(&self) -> &bool;
    fn use_character_entity_mut(&mut self) -> &mut bool;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn use_radius_with_geometry_transform(&self) -> &bool;
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool;
    fn geometries_follow_object(&self) -> &bool;
    fn geometries_follow_object_mut(&mut self) -> &mut bool;
    fn inside_area_event_repeat_time(&self) -> &f32;
    fn inside_area_event_repeat_time_mut(&mut self) -> &mut f32;
    fn one_inside_area_event_per_soldier(&self) -> &bool;
    fn one_inside_area_event_per_soldier_mut(&mut self) -> &mut bool;
    fn trigger_only_on_leave(&self) -> &bool;
    fn trigger_only_on_leave_mut(&mut self) -> &mut bool;
    fn reset_on_enable(&self) -> &bool;
    fn reset_on_enable_mut(&mut self) -> &mut bool;
    fn trigger_on_leave_on_death(&self) -> &bool;
    fn trigger_on_leave_on_death_mut(&mut self) -> &mut bool;
    fn trigger_on_leave_on_disable(&self) -> &bool;
    fn trigger_on_leave_on_disable_mut(&mut self) -> &mut bool;
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId;
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
}

impl AreaTriggerEntityDataTrait for AreaTriggerEntityData {
    fn geometry_transform(&self) -> &super::core::LinearTransform {
        &self.geometry_transform
    }
    fn geometry_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.geometry_transform
    }
    fn include(&self) -> &AreaTriggerInclude {
        &self.include
    }
    fn include_mut(&mut self) -> &mut AreaTriggerInclude {
        &mut self.include
    }
    fn use_character_entity(&self) -> &bool {
        &self.use_character_entity
    }
    fn use_character_entity_mut(&mut self) -> &mut bool {
        &mut self.use_character_entity
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn use_radius_with_geometry_transform(&self) -> &bool {
        &self.use_radius_with_geometry_transform
    }
    fn use_radius_with_geometry_transform_mut(&mut self) -> &mut bool {
        &mut self.use_radius_with_geometry_transform
    }
    fn geometries_follow_object(&self) -> &bool {
        &self.geometries_follow_object
    }
    fn geometries_follow_object_mut(&mut self) -> &mut bool {
        &mut self.geometries_follow_object
    }
    fn inside_area_event_repeat_time(&self) -> &f32 {
        &self.inside_area_event_repeat_time
    }
    fn inside_area_event_repeat_time_mut(&mut self) -> &mut f32 {
        &mut self.inside_area_event_repeat_time
    }
    fn one_inside_area_event_per_soldier(&self) -> &bool {
        &self.one_inside_area_event_per_soldier
    }
    fn one_inside_area_event_per_soldier_mut(&mut self) -> &mut bool {
        &mut self.one_inside_area_event_per_soldier
    }
    fn trigger_only_on_leave(&self) -> &bool {
        &self.trigger_only_on_leave
    }
    fn trigger_only_on_leave_mut(&mut self) -> &mut bool {
        &mut self.trigger_only_on_leave
    }
    fn reset_on_enable(&self) -> &bool {
        &self.reset_on_enable
    }
    fn reset_on_enable_mut(&mut self) -> &mut bool {
        &mut self.reset_on_enable
    }
    fn trigger_on_leave_on_death(&self) -> &bool {
        &self.trigger_on_leave_on_death
    }
    fn trigger_on_leave_on_death_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_leave_on_death
    }
    fn trigger_on_leave_on_disable(&self) -> &bool {
        &self.trigger_on_leave_on_disable
    }
    fn trigger_on_leave_on_disable_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_leave_on_disable
    }
    fn team_of_allies(&self) -> &super::gameplay_sim::TeamId {
        &self.team_of_allies
    }
    fn team_of_allies_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team_of_allies
    }
}

impl TriggerEntityDataTrait for AreaTriggerEntityData {
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn run_once(&self) -> &bool {
        self._glacier_base.run_once()
    }
    fn run_once_mut(&mut self) -> &mut bool {
        self._glacier_base.run_once_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for AreaTriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for AreaTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for AreaTriggerEntityData {
}

impl super::core::DataBusPeerTrait for AreaTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AreaTriggerEntityData {
}

impl super::core::DataContainerTrait for AreaTriggerEntityData {
}

pub static AREATRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TRIGGERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AreaTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GeometryTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AreaTriggerEntityData, geometry_transform),
            },
            FieldInfoData {
                name: "Include",
                flags: MemberInfoFlags::new(0),
                field_type: "AreaTriggerInclude",
                rust_offset: offset_of!(AreaTriggerEntityData, include),
            },
            FieldInfoData {
                name: "UseCharacterEntity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, use_character_entity),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaTriggerEntityData, radius),
            },
            FieldInfoData {
                name: "UseRadiusWithGeometryTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, use_radius_with_geometry_transform),
            },
            FieldInfoData {
                name: "GeometriesFollowObject",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, geometries_follow_object),
            },
            FieldInfoData {
                name: "InsideAreaEventRepeatTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaTriggerEntityData, inside_area_event_repeat_time),
            },
            FieldInfoData {
                name: "OneInsideAreaEventPerSoldier",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, one_inside_area_event_per_soldier),
            },
            FieldInfoData {
                name: "TriggerOnlyOnLeave",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, trigger_only_on_leave),
            },
            FieldInfoData {
                name: "ResetOnEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, reset_on_enable),
            },
            FieldInfoData {
                name: "TriggerOnLeaveOnDeath",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, trigger_on_leave_on_death),
            },
            FieldInfoData {
                name: "TriggerOnLeaveOnDisable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AreaTriggerEntityData, trigger_on_leave_on_disable),
            },
            FieldInfoData {
                name: "TeamOfAllies",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(AreaTriggerEntityData, team_of_allies),
            },
        ],
    }),
    array_type: Some(AREATRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AreaTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AREATRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AREATRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AreaTriggerInclude {
    #[default]
    ATNone = 0,
    ATAll = 1,
    ATPlayers = 2,
    ATAI = 3,
    ATAI_Allies = 4,
    ATAI_Enemies = 5,
    ATAllies = 6,
    ATEnemies = 7,
}

pub static AREATRIGGERINCLUDE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaTriggerInclude",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(AREATRIGGERINCLUDE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AreaTriggerInclude {
    fn type_info(&self) -> &'static TypeInfo {
        AREATRIGGERINCLUDE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AREATRIGGERINCLUDE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaTriggerInclude-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AreaTriggerInclude"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TriggerEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub delay: f32,
    pub run_once: bool,
    pub enabled: bool,
}

pub trait TriggerEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn delay(&self) -> &f32;
    fn delay_mut(&mut self) -> &mut f32;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl TriggerEntityDataTrait for TriggerEntityData {
    fn delay(&self) -> &f32 {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut f32 {
        &mut self.delay
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for TriggerEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TriggerEntityData {
}

impl super::entity::GameObjectDataTrait for TriggerEntityData {
}

impl super::core::DataBusPeerTrait for TriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TriggerEntityData {
}

impl super::core::DataContainerTrait for TriggerEntityData {
}

pub static TRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TriggerEntityData, delay),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TriggerEntityData, run_once),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TriggerEntityData, enabled),
            },
        ],
    }),
    array_type: Some(TRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for TriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestPartBoundingBoxEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub first_vertex_indices: Vec<u32>,
    pub vertex_positions: Vec<super::core::Vec3>,
}

pub trait TestPartBoundingBoxEntityDataTrait: super::entity::EntityDataTrait {
    fn first_vertex_indices(&self) -> &Vec<u32>;
    fn first_vertex_indices_mut(&mut self) -> &mut Vec<u32>;
    fn vertex_positions(&self) -> &Vec<super::core::Vec3>;
    fn vertex_positions_mut(&mut self) -> &mut Vec<super::core::Vec3>;
}

impl TestPartBoundingBoxEntityDataTrait for TestPartBoundingBoxEntityData {
    fn first_vertex_indices(&self) -> &Vec<u32> {
        &self.first_vertex_indices
    }
    fn first_vertex_indices_mut(&mut self) -> &mut Vec<u32> {
        &mut self.first_vertex_indices
    }
    fn vertex_positions(&self) -> &Vec<super::core::Vec3> {
        &self.vertex_positions
    }
    fn vertex_positions_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.vertex_positions
    }
}

impl super::entity::EntityDataTrait for TestPartBoundingBoxEntityData {
}

impl super::entity::GameObjectDataTrait for TestPartBoundingBoxEntityData {
}

impl super::core::DataBusPeerTrait for TestPartBoundingBoxEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestPartBoundingBoxEntityData {
}

impl super::core::DataContainerTrait for TestPartBoundingBoxEntityData {
}

pub static TESTPARTBOUNDINGBOXENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPartBoundingBoxEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestPartBoundingBoxEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FirstVertexIndices",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(TestPartBoundingBoxEntityData, first_vertex_indices),
            },
            FieldInfoData {
                name: "VertexPositions",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(TestPartBoundingBoxEntityData, vertex_positions),
            },
        ],
    }),
    array_type: Some(TESTPARTBOUNDINGBOXENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestPartBoundingBoxEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTPARTBOUNDINGBOXENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTPARTBOUNDINGBOXENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPartBoundingBoxEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestPartBoundingBoxEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AssertTimeBombEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub auto_arm: bool,
    pub delay: f32,
}

pub trait AssertTimeBombEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn auto_arm(&self) -> &bool;
    fn auto_arm_mut(&mut self) -> &mut bool;
    fn delay(&self) -> &f32;
    fn delay_mut(&mut self) -> &mut f32;
}

impl AssertTimeBombEntityDataTrait for AssertTimeBombEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn auto_arm(&self) -> &bool {
        &self.auto_arm
    }
    fn auto_arm_mut(&mut self) -> &mut bool {
        &mut self.auto_arm
    }
    fn delay(&self) -> &f32 {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut f32 {
        &mut self.delay
    }
}

impl super::entity::SpatialEntityDataTrait for AssertTimeBombEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for AssertTimeBombEntityData {
}

impl super::entity::GameObjectDataTrait for AssertTimeBombEntityData {
}

impl super::core::DataBusPeerTrait for AssertTimeBombEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AssertTimeBombEntityData {
}

impl super::core::DataContainerTrait for AssertTimeBombEntityData {
}

pub static ASSERTTIMEBOMBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertTimeBombEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AssertTimeBombEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AssertTimeBombEntityData, realm),
            },
            FieldInfoData {
                name: "AutoArm",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AssertTimeBombEntityData, auto_arm),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AssertTimeBombEntityData, delay),
            },
        ],
    }),
    array_type: Some(ASSERTTIMEBOMBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AssertTimeBombEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ASSERTTIMEBOMBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ASSERTTIMEBOMBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertTimeBombEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AssertTimeBombEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AssertTimeBombBlueprint {
    pub _glacier_base: super::entity::ObjectBlueprint,
}

pub trait AssertTimeBombBlueprintTrait: super::entity::ObjectBlueprintTrait {
}

impl AssertTimeBombBlueprintTrait for AssertTimeBombBlueprint {
}

impl super::entity::ObjectBlueprintTrait for AssertTimeBombBlueprint {
    fn object(&self) -> &Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object()
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::EntityDataTrait>>> {
        self._glacier_base.object_mut()
    }
}

impl super::entity::BlueprintTrait for AssertTimeBombBlueprint {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn schematics(&self) -> &Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics()
    }
    fn schematics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::schematics::SchematicsBaseAssetTrait>>> {
        self._glacier_base.schematics_mut()
    }
}

impl super::entity::EntityBusDataTrait for AssertTimeBombBlueprint {
    fn event_connections(&self) -> &Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections()
    }
    fn event_connections_mut(&mut self) -> &mut Vec<super::entity::EventConnection> {
        self._glacier_base.event_connections_mut()
    }
}

impl super::core::DataBusDataTrait for AssertTimeBombBlueprint {
    fn flags(&self) -> &u16 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.flags_mut()
    }
    fn property_connections(&self) -> &Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections()
    }
    fn property_connections_mut(&mut self) -> &mut Vec<super::core::PropertyConnection> {
        self._glacier_base.property_connections_mut()
    }
    fn link_connections(&self) -> &Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections()
    }
    fn link_connections_mut(&mut self) -> &mut Vec<super::core::LinkConnection> {
        self._glacier_base.link_connections_mut()
    }
    fn interface(&self) -> &Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DynamicDataContainerTrait>>> {
        self._glacier_base.interface_mut()
    }
}

impl super::core::AssetTrait for AssertTimeBombBlueprint {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AssertTimeBombBlueprint {
}

pub static ASSERTTIMEBOMBBLUEPRINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertTimeBombBlueprint",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::OBJECTBLUEPRINT_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AssertTimeBombBlueprint as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(ASSERTTIMEBOMBBLUEPRINT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AssertTimeBombBlueprint {
    fn type_info(&self) -> &'static TypeInfo {
        ASSERTTIMEBOMBBLUEPRINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ASSERTTIMEBOMBBLUEPRINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertTimeBombBlueprint-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AssertTimeBombBlueprint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AttachmentVerificationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub entity1_bone_name: String,
    pub entity2_bone_name: String,
    pub entity2_offset: super::core::LinearTransform,
    pub epsilon: f32,
    pub fire_assert: bool,
    pub fail_continuously: bool,
}

pub trait AttachmentVerificationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn entity1_bone_name(&self) -> &String;
    fn entity1_bone_name_mut(&mut self) -> &mut String;
    fn entity2_bone_name(&self) -> &String;
    fn entity2_bone_name_mut(&mut self) -> &mut String;
    fn entity2_offset(&self) -> &super::core::LinearTransform;
    fn entity2_offset_mut(&mut self) -> &mut super::core::LinearTransform;
    fn epsilon(&self) -> &f32;
    fn epsilon_mut(&mut self) -> &mut f32;
    fn fire_assert(&self) -> &bool;
    fn fire_assert_mut(&mut self) -> &mut bool;
    fn fail_continuously(&self) -> &bool;
    fn fail_continuously_mut(&mut self) -> &mut bool;
}

impl AttachmentVerificationEntityDataTrait for AttachmentVerificationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn entity1_bone_name(&self) -> &String {
        &self.entity1_bone_name
    }
    fn entity1_bone_name_mut(&mut self) -> &mut String {
        &mut self.entity1_bone_name
    }
    fn entity2_bone_name(&self) -> &String {
        &self.entity2_bone_name
    }
    fn entity2_bone_name_mut(&mut self) -> &mut String {
        &mut self.entity2_bone_name
    }
    fn entity2_offset(&self) -> &super::core::LinearTransform {
        &self.entity2_offset
    }
    fn entity2_offset_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.entity2_offset
    }
    fn epsilon(&self) -> &f32 {
        &self.epsilon
    }
    fn epsilon_mut(&mut self) -> &mut f32 {
        &mut self.epsilon
    }
    fn fire_assert(&self) -> &bool {
        &self.fire_assert
    }
    fn fire_assert_mut(&mut self) -> &mut bool {
        &mut self.fire_assert
    }
    fn fail_continuously(&self) -> &bool {
        &self.fail_continuously
    }
    fn fail_continuously_mut(&mut self) -> &mut bool {
        &mut self.fail_continuously
    }
}

impl super::entity::EntityDataTrait for AttachmentVerificationEntityData {
}

impl super::entity::GameObjectDataTrait for AttachmentVerificationEntityData {
}

impl super::core::DataBusPeerTrait for AttachmentVerificationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AttachmentVerificationEntityData {
}

impl super::core::DataContainerTrait for AttachmentVerificationEntityData {
}

pub static ATTACHMENTVERIFICATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttachmentVerificationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AttachmentVerificationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AttachmentVerificationEntityData, realm),
            },
            FieldInfoData {
                name: "Entity1BoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AttachmentVerificationEntityData, entity1_bone_name),
            },
            FieldInfoData {
                name: "Entity2BoneName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AttachmentVerificationEntityData, entity2_bone_name),
            },
            FieldInfoData {
                name: "Entity2Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AttachmentVerificationEntityData, entity2_offset),
            },
            FieldInfoData {
                name: "Epsilon",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttachmentVerificationEntityData, epsilon),
            },
            FieldInfoData {
                name: "FireAssert",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AttachmentVerificationEntityData, fire_assert),
            },
            FieldInfoData {
                name: "FailContinuously",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AttachmentVerificationEntityData, fail_continuously),
            },
        ],
    }),
    array_type: Some(ATTACHMENTVERIFICATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AttachmentVerificationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ATTACHMENTVERIFICATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ATTACHMENTVERIFICATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttachmentVerificationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AttachmentVerificationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClosestPointEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub realm: super::core::Realm,
    pub max_distance: f32,
}

pub trait ClosestPointEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn max_distance(&self) -> &f32;
    fn max_distance_mut(&mut self) -> &mut f32;
}

impl ClosestPointEntityDataTrait for ClosestPointEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn max_distance(&self) -> &f32 {
        &self.max_distance
    }
    fn max_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_distance
    }
}

impl super::entity::SpatialEntityDataTrait for ClosestPointEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for ClosestPointEntityData {
}

impl super::entity::GameObjectDataTrait for ClosestPointEntityData {
}

impl super::core::DataBusPeerTrait for ClosestPointEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClosestPointEntityData {
}

impl super::core::DataContainerTrait for ClosestPointEntityData {
}

pub static CLOSESTPOINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClosestPointEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClosestPointEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ClosestPointEntityData, realm),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ClosestPointEntityData, max_distance),
            },
        ],
    }),
    array_type: Some(CLOSESTPOINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ClosestPointEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLOSESTPOINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLOSESTPOINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClosestPointEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClosestPointEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct JointValidationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub joint_name: String,
    pub joint_x: f32,
    pub joint_y: f32,
    pub joint_z: f32,
    pub tolerance: f32,
    pub tick: f32,
    pub disable_validation: bool,
}

pub trait JointValidationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn joint_name(&self) -> &String;
    fn joint_name_mut(&mut self) -> &mut String;
    fn joint_x(&self) -> &f32;
    fn joint_x_mut(&mut self) -> &mut f32;
    fn joint_y(&self) -> &f32;
    fn joint_y_mut(&mut self) -> &mut f32;
    fn joint_z(&self) -> &f32;
    fn joint_z_mut(&mut self) -> &mut f32;
    fn tolerance(&self) -> &f32;
    fn tolerance_mut(&mut self) -> &mut f32;
    fn tick(&self) -> &f32;
    fn tick_mut(&mut self) -> &mut f32;
    fn disable_validation(&self) -> &bool;
    fn disable_validation_mut(&mut self) -> &mut bool;
}

impl JointValidationEntityDataTrait for JointValidationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn joint_name(&self) -> &String {
        &self.joint_name
    }
    fn joint_name_mut(&mut self) -> &mut String {
        &mut self.joint_name
    }
    fn joint_x(&self) -> &f32 {
        &self.joint_x
    }
    fn joint_x_mut(&mut self) -> &mut f32 {
        &mut self.joint_x
    }
    fn joint_y(&self) -> &f32 {
        &self.joint_y
    }
    fn joint_y_mut(&mut self) -> &mut f32 {
        &mut self.joint_y
    }
    fn joint_z(&self) -> &f32 {
        &self.joint_z
    }
    fn joint_z_mut(&mut self) -> &mut f32 {
        &mut self.joint_z
    }
    fn tolerance(&self) -> &f32 {
        &self.tolerance
    }
    fn tolerance_mut(&mut self) -> &mut f32 {
        &mut self.tolerance
    }
    fn tick(&self) -> &f32 {
        &self.tick
    }
    fn tick_mut(&mut self) -> &mut f32 {
        &mut self.tick
    }
    fn disable_validation(&self) -> &bool {
        &self.disable_validation
    }
    fn disable_validation_mut(&mut self) -> &mut bool {
        &mut self.disable_validation
    }
}

impl super::entity::EntityDataTrait for JointValidationEntityData {
}

impl super::entity::GameObjectDataTrait for JointValidationEntityData {
}

impl super::core::DataBusPeerTrait for JointValidationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for JointValidationEntityData {
}

impl super::core::DataContainerTrait for JointValidationEntityData {
}

pub static JOINTVALIDATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "JointValidationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<JointValidationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(JointValidationEntityData, realm),
            },
            FieldInfoData {
                name: "JointName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(JointValidationEntityData, joint_name),
            },
            FieldInfoData {
                name: "Joint_X",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, joint_x),
            },
            FieldInfoData {
                name: "Joint_Y",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, joint_y),
            },
            FieldInfoData {
                name: "Joint_Z",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, joint_z),
            },
            FieldInfoData {
                name: "Tolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, tolerance),
            },
            FieldInfoData {
                name: "Tick",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(JointValidationEntityData, tick),
            },
            FieldInfoData {
                name: "DisableValidation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(JointValidationEntityData, disable_validation),
            },
        ],
    }),
    array_type: Some(JOINTVALIDATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for JointValidationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        JOINTVALIDATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static JOINTVALIDATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "JointValidationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("JointValidationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientPlayerInputPressEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub entry_input_action: i32,
    pub level: f32,
    pub press_for: f32,
}

pub trait ClientPlayerInputPressEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn entry_input_action(&self) -> &i32;
    fn entry_input_action_mut(&mut self) -> &mut i32;
    fn level(&self) -> &f32;
    fn level_mut(&mut self) -> &mut f32;
    fn press_for(&self) -> &f32;
    fn press_for_mut(&mut self) -> &mut f32;
}

impl ClientPlayerInputPressEntityDataTrait for ClientPlayerInputPressEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn entry_input_action(&self) -> &i32 {
        &self.entry_input_action
    }
    fn entry_input_action_mut(&mut self) -> &mut i32 {
        &mut self.entry_input_action
    }
    fn level(&self) -> &f32 {
        &self.level
    }
    fn level_mut(&mut self) -> &mut f32 {
        &mut self.level
    }
    fn press_for(&self) -> &f32 {
        &self.press_for
    }
    fn press_for_mut(&mut self) -> &mut f32 {
        &mut self.press_for
    }
}

impl super::entity::EntityDataTrait for ClientPlayerInputPressEntityData {
}

impl super::entity::GameObjectDataTrait for ClientPlayerInputPressEntityData {
}

impl super::core::DataBusPeerTrait for ClientPlayerInputPressEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClientPlayerInputPressEntityData {
}

impl super::core::DataContainerTrait for ClientPlayerInputPressEntityData {
}

pub static CLIENTPLAYERINPUTPRESSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputPressEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientPlayerInputPressEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ClientPlayerInputPressEntityData, realm),
            },
            FieldInfoData {
                name: "EntryInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ClientPlayerInputPressEntityData, entry_input_action),
            },
            FieldInfoData {
                name: "Level",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ClientPlayerInputPressEntityData, level),
            },
            FieldInfoData {
                name: "PressFor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ClientPlayerInputPressEntityData, press_for),
            },
        ],
    }),
    array_type: Some(CLIENTPLAYERINPUTPRESSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientPlayerInputPressEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPLAYERINPUTPRESSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTPLAYERINPUTPRESSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputPressEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClientPlayerInputPressEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientPlayerInputPlaybackEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub file_name: String,
    pub test_name: String,
    pub teleport: bool,
}

pub trait ClientPlayerInputPlaybackEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn file_name(&self) -> &String;
    fn file_name_mut(&mut self) -> &mut String;
    fn test_name(&self) -> &String;
    fn test_name_mut(&mut self) -> &mut String;
    fn teleport(&self) -> &bool;
    fn teleport_mut(&mut self) -> &mut bool;
}

impl ClientPlayerInputPlaybackEntityDataTrait for ClientPlayerInputPlaybackEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn file_name(&self) -> &String {
        &self.file_name
    }
    fn file_name_mut(&mut self) -> &mut String {
        &mut self.file_name
    }
    fn test_name(&self) -> &String {
        &self.test_name
    }
    fn test_name_mut(&mut self) -> &mut String {
        &mut self.test_name
    }
    fn teleport(&self) -> &bool {
        &self.teleport
    }
    fn teleport_mut(&mut self) -> &mut bool {
        &mut self.teleport
    }
}

impl super::entity::EntityDataTrait for ClientPlayerInputPlaybackEntityData {
}

impl super::entity::GameObjectDataTrait for ClientPlayerInputPlaybackEntityData {
}

impl super::core::DataBusPeerTrait for ClientPlayerInputPlaybackEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClientPlayerInputPlaybackEntityData {
}

impl super::core::DataContainerTrait for ClientPlayerInputPlaybackEntityData {
}

pub static CLIENTPLAYERINPUTPLAYBACKENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputPlaybackEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientPlayerInputPlaybackEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ClientPlayerInputPlaybackEntityData, realm),
            },
            FieldInfoData {
                name: "FileName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientPlayerInputPlaybackEntityData, file_name),
            },
            FieldInfoData {
                name: "TestName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientPlayerInputPlaybackEntityData, test_name),
            },
            FieldInfoData {
                name: "Teleport",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ClientPlayerInputPlaybackEntityData, teleport),
            },
        ],
    }),
    array_type: Some(CLIENTPLAYERINPUTPLAYBACKENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientPlayerInputPlaybackEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPLAYERINPUTPLAYBACKENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTPLAYERINPUTPLAYBACKENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputPlaybackEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClientPlayerInputPlaybackEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ClientPlayerInputRecorderEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub file_name_base: String,
    pub test_name: String,
}

pub trait ClientPlayerInputRecorderEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn file_name_base(&self) -> &String;
    fn file_name_base_mut(&mut self) -> &mut String;
    fn test_name(&self) -> &String;
    fn test_name_mut(&mut self) -> &mut String;
}

impl ClientPlayerInputRecorderEntityDataTrait for ClientPlayerInputRecorderEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn file_name_base(&self) -> &String {
        &self.file_name_base
    }
    fn file_name_base_mut(&mut self) -> &mut String {
        &mut self.file_name_base
    }
    fn test_name(&self) -> &String {
        &self.test_name
    }
    fn test_name_mut(&mut self) -> &mut String {
        &mut self.test_name
    }
}

impl super::entity::EntityDataTrait for ClientPlayerInputRecorderEntityData {
}

impl super::entity::GameObjectDataTrait for ClientPlayerInputRecorderEntityData {
}

impl super::core::DataBusPeerTrait for ClientPlayerInputRecorderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ClientPlayerInputRecorderEntityData {
}

impl super::core::DataContainerTrait for ClientPlayerInputRecorderEntityData {
}

pub static CLIENTPLAYERINPUTRECORDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputRecorderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ClientPlayerInputRecorderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ClientPlayerInputRecorderEntityData, realm),
            },
            FieldInfoData {
                name: "FileNameBase",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientPlayerInputRecorderEntityData, file_name_base),
            },
            FieldInfoData {
                name: "TestName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ClientPlayerInputRecorderEntityData, test_name),
            },
        ],
    }),
    array_type: Some(CLIENTPLAYERINPUTRECORDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ClientPlayerInputRecorderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLIENTPLAYERINPUTRECORDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLIENTPLAYERINPUTRECORDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ClientPlayerInputRecorderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ClientPlayerInputRecorderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LoggingEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub strings: Vec<String>,
    pub realm: super::core::Realm,
    pub float_value: f32,
    pub int_value: i32,
    pub transform_value: super::core::LinearTransform,
    pub vec2_value: super::core::Vec2,
    pub vec3_value: super::core::Vec3,
    pub bool_value: bool,
    pub string_value: String,
}

pub trait LoggingEntityDataTrait: super::entity::EntityDataTrait {
    fn strings(&self) -> &Vec<String>;
    fn strings_mut(&mut self) -> &mut Vec<String>;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn float_value(&self) -> &f32;
    fn float_value_mut(&mut self) -> &mut f32;
    fn int_value(&self) -> &i32;
    fn int_value_mut(&mut self) -> &mut i32;
    fn transform_value(&self) -> &super::core::LinearTransform;
    fn transform_value_mut(&mut self) -> &mut super::core::LinearTransform;
    fn vec2_value(&self) -> &super::core::Vec2;
    fn vec2_value_mut(&mut self) -> &mut super::core::Vec2;
    fn vec3_value(&self) -> &super::core::Vec3;
    fn vec3_value_mut(&mut self) -> &mut super::core::Vec3;
    fn bool_value(&self) -> &bool;
    fn bool_value_mut(&mut self) -> &mut bool;
    fn string_value(&self) -> &String;
    fn string_value_mut(&mut self) -> &mut String;
}

impl LoggingEntityDataTrait for LoggingEntityData {
    fn strings(&self) -> &Vec<String> {
        &self.strings
    }
    fn strings_mut(&mut self) -> &mut Vec<String> {
        &mut self.strings
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn float_value(&self) -> &f32 {
        &self.float_value
    }
    fn float_value_mut(&mut self) -> &mut f32 {
        &mut self.float_value
    }
    fn int_value(&self) -> &i32 {
        &self.int_value
    }
    fn int_value_mut(&mut self) -> &mut i32 {
        &mut self.int_value
    }
    fn transform_value(&self) -> &super::core::LinearTransform {
        &self.transform_value
    }
    fn transform_value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform_value
    }
    fn vec2_value(&self) -> &super::core::Vec2 {
        &self.vec2_value
    }
    fn vec2_value_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.vec2_value
    }
    fn vec3_value(&self) -> &super::core::Vec3 {
        &self.vec3_value
    }
    fn vec3_value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.vec3_value
    }
    fn bool_value(&self) -> &bool {
        &self.bool_value
    }
    fn bool_value_mut(&mut self) -> &mut bool {
        &mut self.bool_value
    }
    fn string_value(&self) -> &String {
        &self.string_value
    }
    fn string_value_mut(&mut self) -> &mut String {
        &mut self.string_value
    }
}

impl super::entity::EntityDataTrait for LoggingEntityData {
}

impl super::entity::GameObjectDataTrait for LoggingEntityData {
}

impl super::core::DataBusPeerTrait for LoggingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LoggingEntityData {
}

impl super::core::DataContainerTrait for LoggingEntityData {
}

pub static LOGGINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoggingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LoggingEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Strings",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(LoggingEntityData, strings),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LoggingEntityData, realm),
            },
            FieldInfoData {
                name: "FloatValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LoggingEntityData, float_value),
            },
            FieldInfoData {
                name: "IntValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(LoggingEntityData, int_value),
            },
            FieldInfoData {
                name: "TransformValue",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(LoggingEntityData, transform_value),
            },
            FieldInfoData {
                name: "Vec2Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(LoggingEntityData, vec2_value),
            },
            FieldInfoData {
                name: "Vec3Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(LoggingEntityData, vec3_value),
            },
            FieldInfoData {
                name: "BoolValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LoggingEntityData, bool_value),
            },
            FieldInfoData {
                name: "StringValue",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LoggingEntityData, string_value),
            },
        ],
    }),
    array_type: Some(LOGGINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LoggingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGGINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGGINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoggingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LoggingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DestructionCommandEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub instance_count_destroyed_per_frame: u32,
    pub instance_count_destroyed_per_type: u32,
}

pub trait DestructionCommandEntityDataTrait: super::entity::EntityDataTrait {
    fn instance_count_destroyed_per_frame(&self) -> &u32;
    fn instance_count_destroyed_per_frame_mut(&mut self) -> &mut u32;
    fn instance_count_destroyed_per_type(&self) -> &u32;
    fn instance_count_destroyed_per_type_mut(&mut self) -> &mut u32;
}

impl DestructionCommandEntityDataTrait for DestructionCommandEntityData {
    fn instance_count_destroyed_per_frame(&self) -> &u32 {
        &self.instance_count_destroyed_per_frame
    }
    fn instance_count_destroyed_per_frame_mut(&mut self) -> &mut u32 {
        &mut self.instance_count_destroyed_per_frame
    }
    fn instance_count_destroyed_per_type(&self) -> &u32 {
        &self.instance_count_destroyed_per_type
    }
    fn instance_count_destroyed_per_type_mut(&mut self) -> &mut u32 {
        &mut self.instance_count_destroyed_per_type
    }
}

impl super::entity::EntityDataTrait for DestructionCommandEntityData {
}

impl super::entity::GameObjectDataTrait for DestructionCommandEntityData {
}

impl super::core::DataBusPeerTrait for DestructionCommandEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DestructionCommandEntityData {
}

impl super::core::DataContainerTrait for DestructionCommandEntityData {
}

pub static DESTRUCTIONCOMMANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DestructionCommandEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DestructionCommandEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InstanceCountDestroyedPerFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DestructionCommandEntityData, instance_count_destroyed_per_frame),
            },
            FieldInfoData {
                name: "InstanceCountDestroyedPerType",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DestructionCommandEntityData, instance_count_destroyed_per_type),
            },
        ],
    }),
    array_type: Some(DESTRUCTIONCOMMANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DestructionCommandEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DESTRUCTIONCOMMANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DESTRUCTIONCOMMANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DestructionCommandEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DestructionCommandEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestPointEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub output_name: String,
}

pub trait TestPointEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn output_name(&self) -> &String;
    fn output_name_mut(&mut self) -> &mut String;
}

impl TestPointEntityDataTrait for TestPointEntityData {
    fn output_name(&self) -> &String {
        &self.output_name
    }
    fn output_name_mut(&mut self) -> &mut String {
        &mut self.output_name
    }
}

impl super::entity::SpatialEntityDataTrait for TestPointEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TestPointEntityData {
}

impl super::entity::GameObjectDataTrait for TestPointEntityData {
}

impl super::core::DataBusPeerTrait for TestPointEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestPointEntityData {
}

impl super::core::DataContainerTrait for TestPointEntityData {
}

pub static TESTPOINTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPointEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestPointEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OutputName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestPointEntityData, output_name),
            },
        ],
    }),
    array_type: Some(TESTPOINTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TestPointEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTPOINTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTPOINTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPointEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestPointEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierMovementSequenceData {
    pub _glacier_base: MovementActionData,
    pub recorded_input: Option<Arc<Mutex<dyn RecordedInputDataTrait>>>,
    pub input_recording_index: i32,
    pub ignore_recording_index_filter: bool,
    pub report_when_finished: bool,
}

pub trait SoldierMovementSequenceDataTrait: MovementActionDataTrait {
    fn recorded_input(&self) -> &Option<Arc<Mutex<dyn RecordedInputDataTrait>>>;
    fn recorded_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RecordedInputDataTrait>>>;
    fn input_recording_index(&self) -> &i32;
    fn input_recording_index_mut(&mut self) -> &mut i32;
    fn ignore_recording_index_filter(&self) -> &bool;
    fn ignore_recording_index_filter_mut(&mut self) -> &mut bool;
    fn report_when_finished(&self) -> &bool;
    fn report_when_finished_mut(&mut self) -> &mut bool;
}

impl SoldierMovementSequenceDataTrait for SoldierMovementSequenceData {
    fn recorded_input(&self) -> &Option<Arc<Mutex<dyn RecordedInputDataTrait>>> {
        &self.recorded_input
    }
    fn recorded_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn RecordedInputDataTrait>>> {
        &mut self.recorded_input
    }
    fn input_recording_index(&self) -> &i32 {
        &self.input_recording_index
    }
    fn input_recording_index_mut(&mut self) -> &mut i32 {
        &mut self.input_recording_index
    }
    fn ignore_recording_index_filter(&self) -> &bool {
        &self.ignore_recording_index_filter
    }
    fn ignore_recording_index_filter_mut(&mut self) -> &mut bool {
        &mut self.ignore_recording_index_filter
    }
    fn report_when_finished(&self) -> &bool {
        &self.report_when_finished
    }
    fn report_when_finished_mut(&mut self) -> &mut bool {
        &mut self.report_when_finished
    }
}

impl MovementActionDataTrait for SoldierMovementSequenceData {
}

impl super::core::DataContainerTrait for SoldierMovementSequenceData {
}

pub static SOLDIERMOVEMENTSEQUENCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierMovementSequenceData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MOVEMENTACTIONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierMovementSequenceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RecordedInput",
                flags: MemberInfoFlags::new(0),
                field_type: "RecordedInputData",
                rust_offset: offset_of!(SoldierMovementSequenceData, recorded_input),
            },
            FieldInfoData {
                name: "InputRecordingIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoldierMovementSequenceData, input_recording_index),
            },
            FieldInfoData {
                name: "IgnoreRecordingIndexFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierMovementSequenceData, ignore_recording_index_filter),
            },
            FieldInfoData {
                name: "ReportWhenFinished",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoldierMovementSequenceData, report_when_finished),
            },
        ],
    }),
    array_type: Some(SOLDIERMOVEMENTSEQUENCEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierMovementSequenceData {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERMOVEMENTSEQUENCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERMOVEMENTSEQUENCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierMovementSequenceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SoldierMovementSequenceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RecordedInputData {
    pub _glacier_base: super::core::Asset,
    pub track_data: Vec<InputRecorderTrackData>,
}

pub trait RecordedInputDataTrait: super::core::AssetTrait {
    fn track_data(&self) -> &Vec<InputRecorderTrackData>;
    fn track_data_mut(&mut self) -> &mut Vec<InputRecorderTrackData>;
}

impl RecordedInputDataTrait for RecordedInputData {
    fn track_data(&self) -> &Vec<InputRecorderTrackData> {
        &self.track_data
    }
    fn track_data_mut(&mut self) -> &mut Vec<InputRecorderTrackData> {
        &mut self.track_data
    }
}

impl super::core::AssetTrait for RecordedInputData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for RecordedInputData {
}

pub static RECORDEDINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordedInputData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RecordedInputData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TrackData",
                flags: MemberInfoFlags::new(144),
                field_type: "InputRecorderTrackData-Array",
                rust_offset: offset_of!(RecordedInputData, track_data),
            },
        ],
    }),
    array_type: Some(RECORDEDINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RecordedInputData {
    fn type_info(&self) -> &'static TypeInfo {
        RECORDEDINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECORDEDINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RecordedInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RecordedInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputRecorderData {
    pub _glacier_base: super::core::DataContainer,
    pub file_name_prefix: String,
    pub file_name: String,
    pub auto_increment_file_name: bool,
    pub toggle_record_action: i32,
}

pub trait InputRecorderDataTrait: super::core::DataContainerTrait {
    fn file_name_prefix(&self) -> &String;
    fn file_name_prefix_mut(&mut self) -> &mut String;
    fn file_name(&self) -> &String;
    fn file_name_mut(&mut self) -> &mut String;
    fn auto_increment_file_name(&self) -> &bool;
    fn auto_increment_file_name_mut(&mut self) -> &mut bool;
    fn toggle_record_action(&self) -> &i32;
    fn toggle_record_action_mut(&mut self) -> &mut i32;
}

impl InputRecorderDataTrait for InputRecorderData {
    fn file_name_prefix(&self) -> &String {
        &self.file_name_prefix
    }
    fn file_name_prefix_mut(&mut self) -> &mut String {
        &mut self.file_name_prefix
    }
    fn file_name(&self) -> &String {
        &self.file_name
    }
    fn file_name_mut(&mut self) -> &mut String {
        &mut self.file_name
    }
    fn auto_increment_file_name(&self) -> &bool {
        &self.auto_increment_file_name
    }
    fn auto_increment_file_name_mut(&mut self) -> &mut bool {
        &mut self.auto_increment_file_name
    }
    fn toggle_record_action(&self) -> &i32 {
        &self.toggle_record_action
    }
    fn toggle_record_action_mut(&mut self) -> &mut i32 {
        &mut self.toggle_record_action
    }
}

impl super::core::DataContainerTrait for InputRecorderData {
}

pub static INPUTRECORDERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRecorderData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputRecorderData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FileNamePrefix",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(InputRecorderData, file_name_prefix),
            },
            FieldInfoData {
                name: "FileName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(InputRecorderData, file_name),
            },
            FieldInfoData {
                name: "AutoIncrementFileName",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InputRecorderData, auto_increment_file_name),
            },
            FieldInfoData {
                name: "ToggleRecordAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputRecorderData, toggle_record_action),
            },
        ],
    }),
    array_type: Some(INPUTRECORDERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputRecorderData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTRECORDERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INPUTRECORDERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRecorderData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InputRecorderData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InputRecorderTrackData {
    pub name: String,
    pub input_action: i32,
    pub property_track: Option<Arc<Mutex<dyn super::entity::FloatPropertyTrackDataTrait>>>,
}

pub trait InputRecorderTrackDataTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn input_action(&self) -> &i32;
    fn input_action_mut(&mut self) -> &mut i32;
    fn property_track(&self) -> &Option<Arc<Mutex<dyn super::entity::FloatPropertyTrackDataTrait>>>;
    fn property_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::FloatPropertyTrackDataTrait>>>;
}

impl InputRecorderTrackDataTrait for InputRecorderTrackData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn input_action(&self) -> &i32 {
        &self.input_action
    }
    fn input_action_mut(&mut self) -> &mut i32 {
        &mut self.input_action
    }
    fn property_track(&self) -> &Option<Arc<Mutex<dyn super::entity::FloatPropertyTrackDataTrait>>> {
        &self.property_track
    }
    fn property_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::FloatPropertyTrackDataTrait>>> {
        &mut self.property_track
    }
}

pub static INPUTRECORDERTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRecorderTrackData",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InputRecorderTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(InputRecorderTrackData, name),
            },
            FieldInfoData {
                name: "InputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InputRecorderTrackData, input_action),
            },
            FieldInfoData {
                name: "PropertyTrack",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatPropertyTrackData",
                rust_offset: offset_of!(InputRecorderTrackData, property_track),
            },
        ],
    }),
    array_type: Some(INPUTRECORDERTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InputRecorderTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        INPUTRECORDERTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INPUTRECORDERTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InputRecorderTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InputRecorderTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleMovementActionData {
    pub _glacier_base: SimpleMovementActionBaseData,
    pub level: f32,
    pub action: i32,
    pub teleport: bool,
    pub respawn: bool,
    pub special_animation_index: i32,
}

pub trait SimpleMovementActionDataTrait: SimpleMovementActionBaseDataTrait {
    fn level(&self) -> &f32;
    fn level_mut(&mut self) -> &mut f32;
    fn action(&self) -> &i32;
    fn action_mut(&mut self) -> &mut i32;
    fn teleport(&self) -> &bool;
    fn teleport_mut(&mut self) -> &mut bool;
    fn respawn(&self) -> &bool;
    fn respawn_mut(&mut self) -> &mut bool;
    fn special_animation_index(&self) -> &i32;
    fn special_animation_index_mut(&mut self) -> &mut i32;
}

impl SimpleMovementActionDataTrait for SimpleMovementActionData {
    fn level(&self) -> &f32 {
        &self.level
    }
    fn level_mut(&mut self) -> &mut f32 {
        &mut self.level
    }
    fn action(&self) -> &i32 {
        &self.action
    }
    fn action_mut(&mut self) -> &mut i32 {
        &mut self.action
    }
    fn teleport(&self) -> &bool {
        &self.teleport
    }
    fn teleport_mut(&mut self) -> &mut bool {
        &mut self.teleport
    }
    fn respawn(&self) -> &bool {
        &self.respawn
    }
    fn respawn_mut(&mut self) -> &mut bool {
        &mut self.respawn
    }
    fn special_animation_index(&self) -> &i32 {
        &self.special_animation_index
    }
    fn special_animation_index_mut(&mut self) -> &mut i32 {
        &mut self.special_animation_index
    }
}

impl SimpleMovementActionBaseDataTrait for SimpleMovementActionData {
    fn start_time_info(&self) -> &SimpleMovementActionTimeData {
        self._glacier_base.start_time_info()
    }
    fn start_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        self._glacier_base.start_time_info_mut()
    }
    fn run_time_info(&self) -> &SimpleMovementActionTimeData {
        self._glacier_base.run_time_info()
    }
    fn run_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        self._glacier_base.run_time_info_mut()
    }
}

impl MovementActionDataTrait for SimpleMovementActionData {
}

impl super::core::DataContainerTrait for SimpleMovementActionData {
}

pub static SIMPLEMOVEMENTACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleMovementActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Level",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleMovementActionData, level),
            },
            FieldInfoData {
                name: "Action",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleMovementActionData, action),
            },
            FieldInfoData {
                name: "Teleport",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleMovementActionData, teleport),
            },
            FieldInfoData {
                name: "Respawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleMovementActionData, respawn),
            },
            FieldInfoData {
                name: "SpecialAnimationIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleMovementActionData, special_animation_index),
            },
        ],
    }),
    array_type: Some(SIMPLEMOVEMENTACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleMovementActionData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEMOVEMENTACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEMOVEMENTACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SimpleMovementActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CameraActionData {
    pub _glacier_base: SimpleMovementActionBaseData,
    pub action_mode: CameraMovementActionMode,
}

pub trait CameraActionDataTrait: SimpleMovementActionBaseDataTrait {
    fn action_mode(&self) -> &CameraMovementActionMode;
    fn action_mode_mut(&mut self) -> &mut CameraMovementActionMode;
}

impl CameraActionDataTrait for CameraActionData {
    fn action_mode(&self) -> &CameraMovementActionMode {
        &self.action_mode
    }
    fn action_mode_mut(&mut self) -> &mut CameraMovementActionMode {
        &mut self.action_mode
    }
}

impl SimpleMovementActionBaseDataTrait for CameraActionData {
    fn start_time_info(&self) -> &SimpleMovementActionTimeData {
        self._glacier_base.start_time_info()
    }
    fn start_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        self._glacier_base.start_time_info_mut()
    }
    fn run_time_info(&self) -> &SimpleMovementActionTimeData {
        self._glacier_base.run_time_info()
    }
    fn run_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        self._glacier_base.run_time_info_mut()
    }
}

impl MovementActionDataTrait for CameraActionData {
}

impl super::core::DataContainerTrait for CameraActionData {
}

pub static CAMERAACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraActionData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CameraActionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "CameraMovementActionMode",
                rust_offset: offset_of!(CameraActionData, action_mode),
            },
        ],
    }),
    array_type: Some(CAMERAACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CameraActionData {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CAMERAACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleMovementActionBaseData {
    pub _glacier_base: MovementActionData,
    pub start_time_info: SimpleMovementActionTimeData,
    pub run_time_info: SimpleMovementActionTimeData,
}

pub trait SimpleMovementActionBaseDataTrait: MovementActionDataTrait {
    fn start_time_info(&self) -> &SimpleMovementActionTimeData;
    fn start_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData;
    fn run_time_info(&self) -> &SimpleMovementActionTimeData;
    fn run_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData;
}

impl SimpleMovementActionBaseDataTrait for SimpleMovementActionBaseData {
    fn start_time_info(&self) -> &SimpleMovementActionTimeData {
        &self.start_time_info
    }
    fn start_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        &mut self.start_time_info
    }
    fn run_time_info(&self) -> &SimpleMovementActionTimeData {
        &self.run_time_info
    }
    fn run_time_info_mut(&mut self) -> &mut SimpleMovementActionTimeData {
        &mut self.run_time_info
    }
}

impl MovementActionDataTrait for SimpleMovementActionBaseData {
}

impl super::core::DataContainerTrait for SimpleMovementActionBaseData {
}

pub static SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionBaseData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MOVEMENTACTIONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleMovementActionBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartTimeInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleMovementActionTimeData",
                rust_offset: offset_of!(SimpleMovementActionBaseData, start_time_info),
            },
            FieldInfoData {
                name: "RunTimeInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleMovementActionTimeData",
                rust_offset: offset_of!(SimpleMovementActionBaseData, run_time_info),
            },
        ],
    }),
    array_type: Some(SIMPLEMOVEMENTACTIONBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleMovementActionBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEMOVEMENTACTIONBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEMOVEMENTACTIONBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SimpleMovementActionBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CameraMovementActionMode {
    #[default]
    CameraMovementActionMode_Start = 0,
    CameraMovementActionMode_Stop = 1,
    CameraMovementActionMode_StartAndStop = 2,
}

pub static CAMERAMOVEMENTACTIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraMovementActionMode",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(CAMERAMOVEMENTACTIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CameraMovementActionMode {
    fn type_info(&self) -> &'static TypeInfo {
        CAMERAMOVEMENTACTIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CAMERAMOVEMENTACTIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CameraMovementActionMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CameraMovementActionMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleMovementActionTimeData {
    pub time: f32,
    pub max_variation: f32,
}

pub trait SimpleMovementActionTimeDataTrait: TypeObject {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn max_variation(&self) -> &f32;
    fn max_variation_mut(&mut self) -> &mut f32;
}

impl SimpleMovementActionTimeDataTrait for SimpleMovementActionTimeData {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn max_variation(&self) -> &f32 {
        &self.max_variation
    }
    fn max_variation_mut(&mut self) -> &mut f32 {
        &mut self.max_variation
    }
}

pub static SIMPLEMOVEMENTACTIONTIMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionTimeData",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleMovementActionTimeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleMovementActionTimeData, time),
            },
            FieldInfoData {
                name: "MaxVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleMovementActionTimeData, max_variation),
            },
        ],
    }),
    array_type: Some(SIMPLEMOVEMENTACTIONTIMEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SimpleMovementActionTimeData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEMOVEMENTACTIONTIMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SIMPLEMOVEMENTACTIONTIMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleMovementActionTimeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SimpleMovementActionTimeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MovementActionRandomizerData {
    pub _glacier_base: MovementActionData,
    pub reinsert_into_randomized_list_after_use: bool,
    pub actions: Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>>,
}

pub trait MovementActionRandomizerDataTrait: MovementActionDataTrait {
    fn reinsert_into_randomized_list_after_use(&self) -> &bool;
    fn reinsert_into_randomized_list_after_use_mut(&mut self) -> &mut bool;
    fn actions(&self) -> &Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>>;
    fn actions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>>;
}

impl MovementActionRandomizerDataTrait for MovementActionRandomizerData {
    fn reinsert_into_randomized_list_after_use(&self) -> &bool {
        &self.reinsert_into_randomized_list_after_use
    }
    fn reinsert_into_randomized_list_after_use_mut(&mut self) -> &mut bool {
        &mut self.reinsert_into_randomized_list_after_use
    }
    fn actions(&self) -> &Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>> {
        &self.actions
    }
    fn actions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>> {
        &mut self.actions
    }
}

impl MovementActionDataTrait for MovementActionRandomizerData {
}

impl super::core::DataContainerTrait for MovementActionRandomizerData {
}

pub static MOVEMENTACTIONRANDOMIZERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionRandomizerData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MOVEMENTACTIONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementActionRandomizerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ReinsertIntoRandomizedListAfterUse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementActionRandomizerData, reinsert_into_randomized_list_after_use),
            },
            FieldInfoData {
                name: "Actions",
                flags: MemberInfoFlags::new(144),
                field_type: "MovementActionData-Array",
                rust_offset: offset_of!(MovementActionRandomizerData, actions),
            },
        ],
    }),
    array_type: Some(MOVEMENTACTIONRANDOMIZERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MovementActionRandomizerData {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTACTIONRANDOMIZERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVEMENTACTIONRANDOMIZERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionRandomizerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MovementActionRandomizerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MovementActionGroupData {
    pub _glacier_base: MovementActionData,
    pub actions: Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>>,
    pub run_simultaneously: bool,
    pub restart_children: bool,
}

pub trait MovementActionGroupDataTrait: MovementActionDataTrait {
    fn actions(&self) -> &Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>>;
    fn actions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>>;
    fn run_simultaneously(&self) -> &bool;
    fn run_simultaneously_mut(&mut self) -> &mut bool;
    fn restart_children(&self) -> &bool;
    fn restart_children_mut(&mut self) -> &mut bool;
}

impl MovementActionGroupDataTrait for MovementActionGroupData {
    fn actions(&self) -> &Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>> {
        &self.actions
    }
    fn actions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MovementActionDataTrait>>>> {
        &mut self.actions
    }
    fn run_simultaneously(&self) -> &bool {
        &self.run_simultaneously
    }
    fn run_simultaneously_mut(&mut self) -> &mut bool {
        &mut self.run_simultaneously
    }
    fn restart_children(&self) -> &bool {
        &self.restart_children
    }
    fn restart_children_mut(&mut self) -> &mut bool {
        &mut self.restart_children
    }
}

impl MovementActionDataTrait for MovementActionGroupData {
}

impl super::core::DataContainerTrait for MovementActionGroupData {
}

pub static MOVEMENTACTIONGROUPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionGroupData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MOVEMENTACTIONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementActionGroupData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Actions",
                flags: MemberInfoFlags::new(144),
                field_type: "MovementActionData-Array",
                rust_offset: offset_of!(MovementActionGroupData, actions),
            },
            FieldInfoData {
                name: "RunSimultaneously",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementActionGroupData, run_simultaneously),
            },
            FieldInfoData {
                name: "RestartChildren",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MovementActionGroupData, restart_children),
            },
        ],
    }),
    array_type: Some(MOVEMENTACTIONGROUPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MovementActionGroupData {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTACTIONGROUPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVEMENTACTIONGROUPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionGroupData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MovementActionGroupData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MovementActionRoot {
    pub _glacier_base: super::core::Asset,
    pub start_sequence: Option<Arc<Mutex<dyn MovementActionDataTrait>>>,
}

pub trait MovementActionRootTrait: super::core::AssetTrait {
    fn start_sequence(&self) -> &Option<Arc<Mutex<dyn MovementActionDataTrait>>>;
    fn start_sequence_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MovementActionDataTrait>>>;
}

impl MovementActionRootTrait for MovementActionRoot {
    fn start_sequence(&self) -> &Option<Arc<Mutex<dyn MovementActionDataTrait>>> {
        &self.start_sequence
    }
    fn start_sequence_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MovementActionDataTrait>>> {
        &mut self.start_sequence
    }
}

impl super::core::AssetTrait for MovementActionRoot {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MovementActionRoot {
}

pub static MOVEMENTACTIONROOT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionRoot",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementActionRoot as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartSequence",
                flags: MemberInfoFlags::new(0),
                field_type: "MovementActionData",
                rust_offset: offset_of!(MovementActionRoot, start_sequence),
            },
        ],
    }),
    array_type: Some(MOVEMENTACTIONROOT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MovementActionRoot {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTACTIONROOT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVEMENTACTIONROOT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionRoot-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MovementActionRoot"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MovementActionData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait MovementActionDataTrait: super::core::DataContainerTrait {
}

impl MovementActionDataTrait for MovementActionData {
}

impl super::core::DataContainerTrait for MovementActionData {
}

pub static MOVEMENTACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MovementActionData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MOVEMENTACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MovementActionData {
    fn type_info(&self) -> &'static TypeInfo {
        MOVEMENTACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVEMENTACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MovementActionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MovementActionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AssertEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub pass: bool,
    pub text: String,
    pub trigger_once: bool,
    pub trigger_on_pass_changed: bool,
}

pub trait AssertEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn pass(&self) -> &bool;
    fn pass_mut(&mut self) -> &mut bool;
    fn text(&self) -> &String;
    fn text_mut(&mut self) -> &mut String;
    fn trigger_once(&self) -> &bool;
    fn trigger_once_mut(&mut self) -> &mut bool;
    fn trigger_on_pass_changed(&self) -> &bool;
    fn trigger_on_pass_changed_mut(&mut self) -> &mut bool;
}

impl AssertEntityDataTrait for AssertEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn pass(&self) -> &bool {
        &self.pass
    }
    fn pass_mut(&mut self) -> &mut bool {
        &mut self.pass
    }
    fn text(&self) -> &String {
        &self.text
    }
    fn text_mut(&mut self) -> &mut String {
        &mut self.text
    }
    fn trigger_once(&self) -> &bool {
        &self.trigger_once
    }
    fn trigger_once_mut(&mut self) -> &mut bool {
        &mut self.trigger_once
    }
    fn trigger_on_pass_changed(&self) -> &bool {
        &self.trigger_on_pass_changed
    }
    fn trigger_on_pass_changed_mut(&mut self) -> &mut bool {
        &mut self.trigger_on_pass_changed
    }
}

impl super::entity::EntityDataTrait for AssertEntityData {
}

impl super::entity::GameObjectDataTrait for AssertEntityData {
}

impl super::core::DataBusPeerTrait for AssertEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AssertEntityData {
}

impl super::core::DataContainerTrait for AssertEntityData {
}

pub static ASSERTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AssertEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AssertEntityData, realm),
            },
            FieldInfoData {
                name: "Pass",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AssertEntityData, pass),
            },
            FieldInfoData {
                name: "Text",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AssertEntityData, text),
            },
            FieldInfoData {
                name: "TriggerOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AssertEntityData, trigger_once),
            },
            FieldInfoData {
                name: "TriggerOnPassChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AssertEntityData, trigger_on_pass_changed),
            },
        ],
    }),
    array_type: Some(ASSERTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AssertEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ASSERTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ASSERTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AssertEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AssertEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkDebugEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub pipeline_test_enabled: bool,
    pub realm: super::core::Realm,
    pub max_resolved_link_debugs: u32,
    pub test_on_init: bool,
    pub expect_all_targets_to_be_resolvable_from_source: bool,
    pub expect_all_targets_to_be_in_same_sub_level: bool,
    pub expect_all_targets_to_be_immutable: bool,
    pub expect_all_targets_to_be_dynamic: bool,
    pub expected_target_data_count_in_runtime: u32,
    pub expected_target_instance_count_in_runtime: u32,
}

pub trait LinkDebugEntityDataTrait: super::entity::EntityDataTrait {
    fn pipeline_test_enabled(&self) -> &bool;
    fn pipeline_test_enabled_mut(&mut self) -> &mut bool;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn max_resolved_link_debugs(&self) -> &u32;
    fn max_resolved_link_debugs_mut(&mut self) -> &mut u32;
    fn test_on_init(&self) -> &bool;
    fn test_on_init_mut(&mut self) -> &mut bool;
    fn expect_all_targets_to_be_resolvable_from_source(&self) -> &bool;
    fn expect_all_targets_to_be_resolvable_from_source_mut(&mut self) -> &mut bool;
    fn expect_all_targets_to_be_in_same_sub_level(&self) -> &bool;
    fn expect_all_targets_to_be_in_same_sub_level_mut(&mut self) -> &mut bool;
    fn expect_all_targets_to_be_immutable(&self) -> &bool;
    fn expect_all_targets_to_be_immutable_mut(&mut self) -> &mut bool;
    fn expect_all_targets_to_be_dynamic(&self) -> &bool;
    fn expect_all_targets_to_be_dynamic_mut(&mut self) -> &mut bool;
    fn expected_target_data_count_in_runtime(&self) -> &u32;
    fn expected_target_data_count_in_runtime_mut(&mut self) -> &mut u32;
    fn expected_target_instance_count_in_runtime(&self) -> &u32;
    fn expected_target_instance_count_in_runtime_mut(&mut self) -> &mut u32;
}

impl LinkDebugEntityDataTrait for LinkDebugEntityData {
    fn pipeline_test_enabled(&self) -> &bool {
        &self.pipeline_test_enabled
    }
    fn pipeline_test_enabled_mut(&mut self) -> &mut bool {
        &mut self.pipeline_test_enabled
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn max_resolved_link_debugs(&self) -> &u32 {
        &self.max_resolved_link_debugs
    }
    fn max_resolved_link_debugs_mut(&mut self) -> &mut u32 {
        &mut self.max_resolved_link_debugs
    }
    fn test_on_init(&self) -> &bool {
        &self.test_on_init
    }
    fn test_on_init_mut(&mut self) -> &mut bool {
        &mut self.test_on_init
    }
    fn expect_all_targets_to_be_resolvable_from_source(&self) -> &bool {
        &self.expect_all_targets_to_be_resolvable_from_source
    }
    fn expect_all_targets_to_be_resolvable_from_source_mut(&mut self) -> &mut bool {
        &mut self.expect_all_targets_to_be_resolvable_from_source
    }
    fn expect_all_targets_to_be_in_same_sub_level(&self) -> &bool {
        &self.expect_all_targets_to_be_in_same_sub_level
    }
    fn expect_all_targets_to_be_in_same_sub_level_mut(&mut self) -> &mut bool {
        &mut self.expect_all_targets_to_be_in_same_sub_level
    }
    fn expect_all_targets_to_be_immutable(&self) -> &bool {
        &self.expect_all_targets_to_be_immutable
    }
    fn expect_all_targets_to_be_immutable_mut(&mut self) -> &mut bool {
        &mut self.expect_all_targets_to_be_immutable
    }
    fn expect_all_targets_to_be_dynamic(&self) -> &bool {
        &self.expect_all_targets_to_be_dynamic
    }
    fn expect_all_targets_to_be_dynamic_mut(&mut self) -> &mut bool {
        &mut self.expect_all_targets_to_be_dynamic
    }
    fn expected_target_data_count_in_runtime(&self) -> &u32 {
        &self.expected_target_data_count_in_runtime
    }
    fn expected_target_data_count_in_runtime_mut(&mut self) -> &mut u32 {
        &mut self.expected_target_data_count_in_runtime
    }
    fn expected_target_instance_count_in_runtime(&self) -> &u32 {
        &self.expected_target_instance_count_in_runtime
    }
    fn expected_target_instance_count_in_runtime_mut(&mut self) -> &mut u32 {
        &mut self.expected_target_instance_count_in_runtime
    }
}

impl super::entity::EntityDataTrait for LinkDebugEntityData {
}

impl super::entity::GameObjectDataTrait for LinkDebugEntityData {
}

impl super::core::DataBusPeerTrait for LinkDebugEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LinkDebugEntityData {
}

impl super::core::DataContainerTrait for LinkDebugEntityData {
}

pub static LINKDEBUGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkDebugEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkDebugEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PipelineTestEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, pipeline_test_enabled),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(LinkDebugEntityData, realm),
            },
            FieldInfoData {
                name: "MaxResolvedLinkDebugs",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LinkDebugEntityData, max_resolved_link_debugs),
            },
            FieldInfoData {
                name: "TestOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, test_on_init),
            },
            FieldInfoData {
                name: "ExpectAllTargetsToBeResolvableFromSource",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, expect_all_targets_to_be_resolvable_from_source),
            },
            FieldInfoData {
                name: "ExpectAllTargetsToBeInSameSubLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, expect_all_targets_to_be_in_same_sub_level),
            },
            FieldInfoData {
                name: "ExpectAllTargetsToBeImmutable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, expect_all_targets_to_be_immutable),
            },
            FieldInfoData {
                name: "ExpectAllTargetsToBeDynamic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LinkDebugEntityData, expect_all_targets_to_be_dynamic),
            },
            FieldInfoData {
                name: "ExpectedTargetDataCountInRuntime",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LinkDebugEntityData, expected_target_data_count_in_runtime),
            },
            FieldInfoData {
                name: "ExpectedTargetInstanceCountInRuntime",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(LinkDebugEntityData, expected_target_instance_count_in_runtime),
            },
        ],
    }),
    array_type: Some(LINKDEBUGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkDebugEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKDEBUGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKDEBUGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkDebugEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LinkDebugEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DeltaViewerTableEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub table_name: String,
    pub mode: DeltaViewerMode,
    pub columns: Vec<Option<Arc<Mutex<dyn DeltaViewerColumnTrait>>>>,
}

pub trait DeltaViewerTableEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn table_name(&self) -> &String;
    fn table_name_mut(&mut self) -> &mut String;
    fn mode(&self) -> &DeltaViewerMode;
    fn mode_mut(&mut self) -> &mut DeltaViewerMode;
    fn columns(&self) -> &Vec<Option<Arc<Mutex<dyn DeltaViewerColumnTrait>>>>;
    fn columns_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DeltaViewerColumnTrait>>>>;
}

impl DeltaViewerTableEntityDataTrait for DeltaViewerTableEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn table_name(&self) -> &String {
        &self.table_name
    }
    fn table_name_mut(&mut self) -> &mut String {
        &mut self.table_name
    }
    fn mode(&self) -> &DeltaViewerMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut DeltaViewerMode {
        &mut self.mode
    }
    fn columns(&self) -> &Vec<Option<Arc<Mutex<dyn DeltaViewerColumnTrait>>>> {
        &self.columns
    }
    fn columns_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DeltaViewerColumnTrait>>>> {
        &mut self.columns
    }
}

impl super::entity::EntityDataTrait for DeltaViewerTableEntityData {
}

impl super::entity::GameObjectDataTrait for DeltaViewerTableEntityData {
}

impl super::core::DataBusPeerTrait for DeltaViewerTableEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DeltaViewerTableEntityData {
}

impl super::core::DataContainerTrait for DeltaViewerTableEntityData {
}

pub static DELTAVIEWERTABLEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerTableEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeltaViewerTableEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DeltaViewerTableEntityData, realm),
            },
            FieldInfoData {
                name: "TableName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DeltaViewerTableEntityData, table_name),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "DeltaViewerMode",
                rust_offset: offset_of!(DeltaViewerTableEntityData, mode),
            },
            FieldInfoData {
                name: "Columns",
                flags: MemberInfoFlags::new(144),
                field_type: "DeltaViewerColumn-Array",
                rust_offset: offset_of!(DeltaViewerTableEntityData, columns),
            },
        ],
    }),
    array_type: Some(DELTAVIEWERTABLEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeltaViewerTableEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DELTAVIEWERTABLEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELTAVIEWERTABLEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerTableEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeltaViewerTableEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DeltaViewerMode {
    #[default]
    DeltaViewerMode_Log = 0,
    DeltaViewerMode_Timer = 1,
}

pub static DELTAVIEWERMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerMode",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DELTAVIEWERMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DeltaViewerMode {
    fn type_info(&self) -> &'static TypeInfo {
        DELTAVIEWERMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DELTAVIEWERMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeltaViewerMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DeltaViewerColumn {
    pub _glacier_base: super::core::DataContainer,
    pub column_name: String,
    pub value_type: DeltaViewerColumnValueType,
}

pub trait DeltaViewerColumnTrait: super::core::DataContainerTrait {
    fn column_name(&self) -> &String;
    fn column_name_mut(&mut self) -> &mut String;
    fn value_type(&self) -> &DeltaViewerColumnValueType;
    fn value_type_mut(&mut self) -> &mut DeltaViewerColumnValueType;
}

impl DeltaViewerColumnTrait for DeltaViewerColumn {
    fn column_name(&self) -> &String {
        &self.column_name
    }
    fn column_name_mut(&mut self) -> &mut String {
        &mut self.column_name
    }
    fn value_type(&self) -> &DeltaViewerColumnValueType {
        &self.value_type
    }
    fn value_type_mut(&mut self) -> &mut DeltaViewerColumnValueType {
        &mut self.value_type
    }
}

impl super::core::DataContainerTrait for DeltaViewerColumn {
}

pub static DELTAVIEWERCOLUMN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerColumn",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeltaViewerColumn as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ColumnName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DeltaViewerColumn, column_name),
            },
            FieldInfoData {
                name: "ValueType",
                flags: MemberInfoFlags::new(0),
                field_type: "DeltaViewerColumnValueType",
                rust_offset: offset_of!(DeltaViewerColumn, value_type),
            },
        ],
    }),
    array_type: Some(DELTAVIEWERCOLUMN_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeltaViewerColumn {
    fn type_info(&self) -> &'static TypeInfo {
        DELTAVIEWERCOLUMN_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELTAVIEWERCOLUMN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerColumn-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeltaViewerColumn"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DeltaViewerColumnValueType {
    #[default]
    DeltaViewerColumnValueType_Bool = 0,
    DeltaViewerColumnValueType_Float = 1,
    DeltaViewerColumnValueType_Int = 2,
    DeltaViewerColumnValueType_String = 3,
    DeltaViewerColumnValueType_Count = 4,
}

pub static DELTAVIEWERCOLUMNVALUETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerColumnValueType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DELTAVIEWERCOLUMNVALUETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DeltaViewerColumnValueType {
    fn type_info(&self) -> &'static TypeInfo {
        DELTAVIEWERCOLUMNVALUETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DELTAVIEWERCOLUMNVALUETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaViewerColumnValueType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DeltaViewerColumnValueType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertyDebugEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub text_color: super::core::Vec3,
    pub screen_position: super::core::Vec2,
    pub world_position: super::core::Vec3,
    pub value_prefix: String,
    pub multiline: bool,
    pub show_transform_in_world: bool,
    pub show_transform_coordinates: bool,
    pub default_visible: bool,
    pub text_scale: f32,
    pub draw_graph: bool,
    pub graph_size: super::core::Vec2,
    pub graph_mode: PropertyDebugGraphMode,
    pub graph_value_min_max: super::core::Vec2,
    pub float_value: f32,
    pub int_value: i32,
    pub transform_value: super::core::LinearTransform,
    pub vec2_value: super::core::Vec2,
    pub vec3_value: super::core::Vec3,
    pub vec4_value: super::core::Vec4,
    pub string_value: String,
}

pub trait PropertyDebugEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn text_color(&self) -> &super::core::Vec3;
    fn text_color_mut(&mut self) -> &mut super::core::Vec3;
    fn screen_position(&self) -> &super::core::Vec2;
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2;
    fn world_position(&self) -> &super::core::Vec3;
    fn world_position_mut(&mut self) -> &mut super::core::Vec3;
    fn value_prefix(&self) -> &String;
    fn value_prefix_mut(&mut self) -> &mut String;
    fn multiline(&self) -> &bool;
    fn multiline_mut(&mut self) -> &mut bool;
    fn show_transform_in_world(&self) -> &bool;
    fn show_transform_in_world_mut(&mut self) -> &mut bool;
    fn show_transform_coordinates(&self) -> &bool;
    fn show_transform_coordinates_mut(&mut self) -> &mut bool;
    fn default_visible(&self) -> &bool;
    fn default_visible_mut(&mut self) -> &mut bool;
    fn text_scale(&self) -> &f32;
    fn text_scale_mut(&mut self) -> &mut f32;
    fn draw_graph(&self) -> &bool;
    fn draw_graph_mut(&mut self) -> &mut bool;
    fn graph_size(&self) -> &super::core::Vec2;
    fn graph_size_mut(&mut self) -> &mut super::core::Vec2;
    fn graph_mode(&self) -> &PropertyDebugGraphMode;
    fn graph_mode_mut(&mut self) -> &mut PropertyDebugGraphMode;
    fn graph_value_min_max(&self) -> &super::core::Vec2;
    fn graph_value_min_max_mut(&mut self) -> &mut super::core::Vec2;
    fn float_value(&self) -> &f32;
    fn float_value_mut(&mut self) -> &mut f32;
    fn int_value(&self) -> &i32;
    fn int_value_mut(&mut self) -> &mut i32;
    fn transform_value(&self) -> &super::core::LinearTransform;
    fn transform_value_mut(&mut self) -> &mut super::core::LinearTransform;
    fn vec2_value(&self) -> &super::core::Vec2;
    fn vec2_value_mut(&mut self) -> &mut super::core::Vec2;
    fn vec3_value(&self) -> &super::core::Vec3;
    fn vec3_value_mut(&mut self) -> &mut super::core::Vec3;
    fn vec4_value(&self) -> &super::core::Vec4;
    fn vec4_value_mut(&mut self) -> &mut super::core::Vec4;
    fn string_value(&self) -> &String;
    fn string_value_mut(&mut self) -> &mut String;
}

impl PropertyDebugEntityDataTrait for PropertyDebugEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn text_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.text_color
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.screen_position
    }
    fn world_position(&self) -> &super::core::Vec3 {
        &self.world_position
    }
    fn world_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.world_position
    }
    fn value_prefix(&self) -> &String {
        &self.value_prefix
    }
    fn value_prefix_mut(&mut self) -> &mut String {
        &mut self.value_prefix
    }
    fn multiline(&self) -> &bool {
        &self.multiline
    }
    fn multiline_mut(&mut self) -> &mut bool {
        &mut self.multiline
    }
    fn show_transform_in_world(&self) -> &bool {
        &self.show_transform_in_world
    }
    fn show_transform_in_world_mut(&mut self) -> &mut bool {
        &mut self.show_transform_in_world
    }
    fn show_transform_coordinates(&self) -> &bool {
        &self.show_transform_coordinates
    }
    fn show_transform_coordinates_mut(&mut self) -> &mut bool {
        &mut self.show_transform_coordinates
    }
    fn default_visible(&self) -> &bool {
        &self.default_visible
    }
    fn default_visible_mut(&mut self) -> &mut bool {
        &mut self.default_visible
    }
    fn text_scale(&self) -> &f32 {
        &self.text_scale
    }
    fn text_scale_mut(&mut self) -> &mut f32 {
        &mut self.text_scale
    }
    fn draw_graph(&self) -> &bool {
        &self.draw_graph
    }
    fn draw_graph_mut(&mut self) -> &mut bool {
        &mut self.draw_graph
    }
    fn graph_size(&self) -> &super::core::Vec2 {
        &self.graph_size
    }
    fn graph_size_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.graph_size
    }
    fn graph_mode(&self) -> &PropertyDebugGraphMode {
        &self.graph_mode
    }
    fn graph_mode_mut(&mut self) -> &mut PropertyDebugGraphMode {
        &mut self.graph_mode
    }
    fn graph_value_min_max(&self) -> &super::core::Vec2 {
        &self.graph_value_min_max
    }
    fn graph_value_min_max_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.graph_value_min_max
    }
    fn float_value(&self) -> &f32 {
        &self.float_value
    }
    fn float_value_mut(&mut self) -> &mut f32 {
        &mut self.float_value
    }
    fn int_value(&self) -> &i32 {
        &self.int_value
    }
    fn int_value_mut(&mut self) -> &mut i32 {
        &mut self.int_value
    }
    fn transform_value(&self) -> &super::core::LinearTransform {
        &self.transform_value
    }
    fn transform_value_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform_value
    }
    fn vec2_value(&self) -> &super::core::Vec2 {
        &self.vec2_value
    }
    fn vec2_value_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.vec2_value
    }
    fn vec3_value(&self) -> &super::core::Vec3 {
        &self.vec3_value
    }
    fn vec3_value_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.vec3_value
    }
    fn vec4_value(&self) -> &super::core::Vec4 {
        &self.vec4_value
    }
    fn vec4_value_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.vec4_value
    }
    fn string_value(&self) -> &String {
        &self.string_value
    }
    fn string_value_mut(&mut self) -> &mut String {
        &mut self.string_value
    }
}

impl super::entity::EntityDataTrait for PropertyDebugEntityData {
}

impl super::entity::GameObjectDataTrait for PropertyDebugEntityData {
}

impl super::core::DataBusPeerTrait for PropertyDebugEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PropertyDebugEntityData {
}

impl super::core::DataContainerTrait for PropertyDebugEntityData {
}

pub static PROPERTYDEBUGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyDebugEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertyDebugEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PropertyDebugEntityData, realm),
            },
            FieldInfoData {
                name: "TextColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PropertyDebugEntityData, text_color),
            },
            FieldInfoData {
                name: "ScreenPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PropertyDebugEntityData, screen_position),
            },
            FieldInfoData {
                name: "WorldPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PropertyDebugEntityData, world_position),
            },
            FieldInfoData {
                name: "ValuePrefix",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PropertyDebugEntityData, value_prefix),
            },
            FieldInfoData {
                name: "Multiline",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, multiline),
            },
            FieldInfoData {
                name: "ShowTransformInWorld",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, show_transform_in_world),
            },
            FieldInfoData {
                name: "ShowTransformCoordinates",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, show_transform_coordinates),
            },
            FieldInfoData {
                name: "DefaultVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, default_visible),
            },
            FieldInfoData {
                name: "TextScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PropertyDebugEntityData, text_scale),
            },
            FieldInfoData {
                name: "DrawGraph",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PropertyDebugEntityData, draw_graph),
            },
            FieldInfoData {
                name: "GraphSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PropertyDebugEntityData, graph_size),
            },
            FieldInfoData {
                name: "GraphMode",
                flags: MemberInfoFlags::new(0),
                field_type: "PropertyDebugGraphMode",
                rust_offset: offset_of!(PropertyDebugEntityData, graph_mode),
            },
            FieldInfoData {
                name: "GraphValueMinMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PropertyDebugEntityData, graph_value_min_max),
            },
            FieldInfoData {
                name: "FloatValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PropertyDebugEntityData, float_value),
            },
            FieldInfoData {
                name: "IntValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(PropertyDebugEntityData, int_value),
            },
            FieldInfoData {
                name: "TransformValue",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(PropertyDebugEntityData, transform_value),
            },
            FieldInfoData {
                name: "Vec2Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PropertyDebugEntityData, vec2_value),
            },
            FieldInfoData {
                name: "Vec3Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PropertyDebugEntityData, vec3_value),
            },
            FieldInfoData {
                name: "Vec4Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(PropertyDebugEntityData, vec4_value),
            },
            FieldInfoData {
                name: "StringValue",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PropertyDebugEntityData, string_value),
            },
        ],
    }),
    array_type: Some(PROPERTYDEBUGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PropertyDebugEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYDEBUGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYDEBUGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyDebugEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PropertyDebugEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PropertyDebugGraphMode {
    #[default]
    PropertyDebugGraphMode_Curve = 0,
    PropertyDebugGraphMode_Bar = 1,
}

pub static PROPERTYDEBUGGRAPHMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyDebugGraphMode",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PROPERTYDEBUGGRAPHMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PropertyDebugGraphMode {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYDEBUGGRAPHMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PROPERTYDEBUGGRAPHMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertyDebugGraphMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PropertyDebugGraphMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PrintDebugTextEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub text: String,
    pub text_color: super::core::Vec3,
    pub screen_position: super::core::Vec2,
    pub use_world_position: bool,
    pub world_position: super::core::Vec3,
    pub visible_at_start: bool,
    pub time_to_show: f32,
    pub text_scale: f32,
    pub enabled: bool,
}

pub trait PrintDebugTextEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn text(&self) -> &String;
    fn text_mut(&mut self) -> &mut String;
    fn text_color(&self) -> &super::core::Vec3;
    fn text_color_mut(&mut self) -> &mut super::core::Vec3;
    fn screen_position(&self) -> &super::core::Vec2;
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2;
    fn use_world_position(&self) -> &bool;
    fn use_world_position_mut(&mut self) -> &mut bool;
    fn world_position(&self) -> &super::core::Vec3;
    fn world_position_mut(&mut self) -> &mut super::core::Vec3;
    fn visible_at_start(&self) -> &bool;
    fn visible_at_start_mut(&mut self) -> &mut bool;
    fn time_to_show(&self) -> &f32;
    fn time_to_show_mut(&mut self) -> &mut f32;
    fn text_scale(&self) -> &f32;
    fn text_scale_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl PrintDebugTextEntityDataTrait for PrintDebugTextEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn text(&self) -> &String {
        &self.text
    }
    fn text_mut(&mut self) -> &mut String {
        &mut self.text
    }
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn text_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.text_color
    }
    fn screen_position(&self) -> &super::core::Vec2 {
        &self.screen_position
    }
    fn screen_position_mut(&mut self) -> &mut super::core::Vec2 {
        &mut self.screen_position
    }
    fn use_world_position(&self) -> &bool {
        &self.use_world_position
    }
    fn use_world_position_mut(&mut self) -> &mut bool {
        &mut self.use_world_position
    }
    fn world_position(&self) -> &super::core::Vec3 {
        &self.world_position
    }
    fn world_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.world_position
    }
    fn visible_at_start(&self) -> &bool {
        &self.visible_at_start
    }
    fn visible_at_start_mut(&mut self) -> &mut bool {
        &mut self.visible_at_start
    }
    fn time_to_show(&self) -> &f32 {
        &self.time_to_show
    }
    fn time_to_show_mut(&mut self) -> &mut f32 {
        &mut self.time_to_show
    }
    fn text_scale(&self) -> &f32 {
        &self.text_scale
    }
    fn text_scale_mut(&mut self) -> &mut f32 {
        &mut self.text_scale
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::EntityDataTrait for PrintDebugTextEntityData {
}

impl super::entity::GameObjectDataTrait for PrintDebugTextEntityData {
}

impl super::core::DataBusPeerTrait for PrintDebugTextEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PrintDebugTextEntityData {
}

impl super::core::DataContainerTrait for PrintDebugTextEntityData {
}

pub static PRINTDEBUGTEXTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrintDebugTextEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PrintDebugTextEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PrintDebugTextEntityData, realm),
            },
            FieldInfoData {
                name: "Text",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(PrintDebugTextEntityData, text),
            },
            FieldInfoData {
                name: "TextColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PrintDebugTextEntityData, text_color),
            },
            FieldInfoData {
                name: "ScreenPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec2",
                rust_offset: offset_of!(PrintDebugTextEntityData, screen_position),
            },
            FieldInfoData {
                name: "UseWorldPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PrintDebugTextEntityData, use_world_position),
            },
            FieldInfoData {
                name: "WorldPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(PrintDebugTextEntityData, world_position),
            },
            FieldInfoData {
                name: "VisibleAtStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PrintDebugTextEntityData, visible_at_start),
            },
            FieldInfoData {
                name: "TimeToShow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PrintDebugTextEntityData, time_to_show),
            },
            FieldInfoData {
                name: "TextScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PrintDebugTextEntityData, text_scale),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PrintDebugTextEntityData, enabled),
            },
        ],
    }),
    array_type: Some(PRINTDEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PrintDebugTextEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PRINTDEBUGTEXTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PRINTDEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrintDebugTextEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PrintDebugTextEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestCullIdCullableEffectEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub effect: Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>,
    pub mode: TestCullIdCullableEffectMode,
}

pub trait TestCullIdCullableEffectEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>>;
    fn mode(&self) -> &TestCullIdCullableEffectMode;
    fn mode_mut(&mut self) -> &mut TestCullIdCullableEffectMode;
}

impl TestCullIdCullableEffectEntityDataTrait for TestCullIdCullableEffectEntityData {
    fn effect(&self) -> &Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &self.effect
    }
    fn effect_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::effect_base::EffectBlueprintTrait>>> {
        &mut self.effect
    }
    fn mode(&self) -> &TestCullIdCullableEffectMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut TestCullIdCullableEffectMode {
        &mut self.mode
    }
}

impl super::entity::SpatialEntityDataTrait for TestCullIdCullableEffectEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for TestCullIdCullableEffectEntityData {
}

impl super::entity::GameObjectDataTrait for TestCullIdCullableEffectEntityData {
}

impl super::core::DataBusPeerTrait for TestCullIdCullableEffectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCullIdCullableEffectEntityData {
}

impl super::core::DataContainerTrait for TestCullIdCullableEffectEntityData {
}

pub static TESTCULLIDCULLABLEEFFECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCullIdCullableEffectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCullIdCullableEffectEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Effect",
                flags: MemberInfoFlags::new(0),
                field_type: "EffectBlueprint",
                rust_offset: offset_of!(TestCullIdCullableEffectEntityData, effect),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "TestCullIdCullableEffectMode",
                rust_offset: offset_of!(TestCullIdCullableEffectEntityData, mode),
            },
        ],
    }),
    array_type: Some(TESTCULLIDCULLABLEEFFECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TestCullIdCullableEffectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCULLIDCULLABLEEFFECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCULLIDCULLABLEEFFECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCullIdCullableEffectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCullIdCullableEffectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TestCullIdCullableEffectMode {
    #[default]
    FirstPersonOnly = 0,
    FirstViewOnly = 1,
    Any = 2,
}

pub static TESTCULLIDCULLABLEEFFECTMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCullIdCullableEffectMode",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(TESTCULLIDCULLABLEEFFECTMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TestCullIdCullableEffectMode {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCULLIDCULLABLEEFFECTMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TESTCULLIDCULLABLEEFFECTMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCullIdCullableEffectMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCullIdCullableEffectMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestEffectEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub active_ctrl_point_count: i32,
}

pub trait TestEffectEntityDataTrait: super::entity::EntityDataTrait {
    fn active_ctrl_point_count(&self) -> &i32;
    fn active_ctrl_point_count_mut(&mut self) -> &mut i32;
}

impl TestEffectEntityDataTrait for TestEffectEntityData {
    fn active_ctrl_point_count(&self) -> &i32 {
        &self.active_ctrl_point_count
    }
    fn active_ctrl_point_count_mut(&mut self) -> &mut i32 {
        &mut self.active_ctrl_point_count
    }
}

impl super::entity::EntityDataTrait for TestEffectEntityData {
}

impl super::entity::GameObjectDataTrait for TestEffectEntityData {
}

impl super::core::DataBusPeerTrait for TestEffectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestEffectEntityData {
}

impl super::core::DataContainerTrait for TestEffectEntityData {
}

pub static TESTEFFECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestEffectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestEffectEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActiveCtrlPointCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TestEffectEntityData, active_ctrl_point_count),
            },
        ],
    }),
    array_type: Some(TESTEFFECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestEffectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTEFFECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTEFFECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestEffectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestEffectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestCaseEntityEffectData {
    pub _glacier_base: super::entity::EntityData,
    pub file_name: String,
    pub file_path_is_from_data_root: bool,
    pub num_simulation_step: u32,
    pub auto_test_screen_shot_mode: bool,
}

pub trait TestCaseEntityEffectDataTrait: super::entity::EntityDataTrait {
    fn file_name(&self) -> &String;
    fn file_name_mut(&mut self) -> &mut String;
    fn file_path_is_from_data_root(&self) -> &bool;
    fn file_path_is_from_data_root_mut(&mut self) -> &mut bool;
    fn num_simulation_step(&self) -> &u32;
    fn num_simulation_step_mut(&mut self) -> &mut u32;
    fn auto_test_screen_shot_mode(&self) -> &bool;
    fn auto_test_screen_shot_mode_mut(&mut self) -> &mut bool;
}

impl TestCaseEntityEffectDataTrait for TestCaseEntityEffectData {
    fn file_name(&self) -> &String {
        &self.file_name
    }
    fn file_name_mut(&mut self) -> &mut String {
        &mut self.file_name
    }
    fn file_path_is_from_data_root(&self) -> &bool {
        &self.file_path_is_from_data_root
    }
    fn file_path_is_from_data_root_mut(&mut self) -> &mut bool {
        &mut self.file_path_is_from_data_root
    }
    fn num_simulation_step(&self) -> &u32 {
        &self.num_simulation_step
    }
    fn num_simulation_step_mut(&mut self) -> &mut u32 {
        &mut self.num_simulation_step
    }
    fn auto_test_screen_shot_mode(&self) -> &bool {
        &self.auto_test_screen_shot_mode
    }
    fn auto_test_screen_shot_mode_mut(&mut self) -> &mut bool {
        &mut self.auto_test_screen_shot_mode
    }
}

impl super::entity::EntityDataTrait for TestCaseEntityEffectData {
}

impl super::entity::GameObjectDataTrait for TestCaseEntityEffectData {
}

impl super::core::DataBusPeerTrait for TestCaseEntityEffectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCaseEntityEffectData {
}

impl super::core::DataContainerTrait for TestCaseEntityEffectData {
}

pub static TESTCASEENTITYEFFECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCaseEntityEffectData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCaseEntityEffectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FileName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityEffectData, file_name),
            },
            FieldInfoData {
                name: "FilePathIsFromDataRoot",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TestCaseEntityEffectData, file_path_is_from_data_root),
            },
            FieldInfoData {
                name: "NumSimulationStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TestCaseEntityEffectData, num_simulation_step),
            },
            FieldInfoData {
                name: "AutoTestScreenShotMode",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TestCaseEntityEffectData, auto_test_screen_shot_mode),
            },
        ],
    }),
    array_type: Some(TESTCASEENTITYEFFECTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestCaseEntityEffectData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCASEENTITYEFFECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCASEENTITYEFFECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCaseEntityEffectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCaseEntityEffectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScreenshotComparisonEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub allowed_diff_percentage: i32,
    pub screenshot_name: String,
    pub wait_for_streaming: bool,
    pub wait_frames: u32,
    pub enable_debug_rendering: bool,
}

pub trait ScreenshotComparisonEntityDataTrait: super::entity::EntityDataTrait {
    fn allowed_diff_percentage(&self) -> &i32;
    fn allowed_diff_percentage_mut(&mut self) -> &mut i32;
    fn screenshot_name(&self) -> &String;
    fn screenshot_name_mut(&mut self) -> &mut String;
    fn wait_for_streaming(&self) -> &bool;
    fn wait_for_streaming_mut(&mut self) -> &mut bool;
    fn wait_frames(&self) -> &u32;
    fn wait_frames_mut(&mut self) -> &mut u32;
    fn enable_debug_rendering(&self) -> &bool;
    fn enable_debug_rendering_mut(&mut self) -> &mut bool;
}

impl ScreenshotComparisonEntityDataTrait for ScreenshotComparisonEntityData {
    fn allowed_diff_percentage(&self) -> &i32 {
        &self.allowed_diff_percentage
    }
    fn allowed_diff_percentage_mut(&mut self) -> &mut i32 {
        &mut self.allowed_diff_percentage
    }
    fn screenshot_name(&self) -> &String {
        &self.screenshot_name
    }
    fn screenshot_name_mut(&mut self) -> &mut String {
        &mut self.screenshot_name
    }
    fn wait_for_streaming(&self) -> &bool {
        &self.wait_for_streaming
    }
    fn wait_for_streaming_mut(&mut self) -> &mut bool {
        &mut self.wait_for_streaming
    }
    fn wait_frames(&self) -> &u32 {
        &self.wait_frames
    }
    fn wait_frames_mut(&mut self) -> &mut u32 {
        &mut self.wait_frames
    }
    fn enable_debug_rendering(&self) -> &bool {
        &self.enable_debug_rendering
    }
    fn enable_debug_rendering_mut(&mut self) -> &mut bool {
        &mut self.enable_debug_rendering
    }
}

impl super::entity::EntityDataTrait for ScreenshotComparisonEntityData {
}

impl super::entity::GameObjectDataTrait for ScreenshotComparisonEntityData {
}

impl super::core::DataBusPeerTrait for ScreenshotComparisonEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ScreenshotComparisonEntityData {
}

impl super::core::DataContainerTrait for ScreenshotComparisonEntityData {
}

pub static SCREENSHOTCOMPARISONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenshotComparisonEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScreenshotComparisonEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AllowedDiffPercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, allowed_diff_percentage),
            },
            FieldInfoData {
                name: "ScreenshotName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, screenshot_name),
            },
            FieldInfoData {
                name: "WaitForStreaming",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, wait_for_streaming),
            },
            FieldInfoData {
                name: "WaitFrames",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, wait_frames),
            },
            FieldInfoData {
                name: "EnableDebugRendering",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScreenshotComparisonEntityData, enable_debug_rendering),
            },
        ],
    }),
    array_type: Some(SCREENSHOTCOMPARISONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScreenshotComparisonEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SCREENSHOTCOMPARISONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCREENSHOTCOMPARISONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScreenshotComparisonEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ScreenshotComparisonEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestComponentEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub maximum_distance: f32,
}

pub trait TestComponentEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn maximum_distance(&self) -> &f32;
    fn maximum_distance_mut(&mut self) -> &mut f32;
}

impl TestComponentEntityDataTrait for TestComponentEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn maximum_distance(&self) -> &f32 {
        &self.maximum_distance
    }
    fn maximum_distance_mut(&mut self) -> &mut f32 {
        &mut self.maximum_distance
    }
}

impl super::entity::EntityDataTrait for TestComponentEntityData {
}

impl super::entity::GameObjectDataTrait for TestComponentEntityData {
}

impl super::core::DataBusPeerTrait for TestComponentEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestComponentEntityData {
}

impl super::core::DataContainerTrait for TestComponentEntityData {
}

pub static TESTCOMPONENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestComponentEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestComponentEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestComponentEntityData, realm),
            },
            FieldInfoData {
                name: "MaximumDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TestComponentEntityData, maximum_distance),
            },
        ],
    }),
    array_type: Some(TESTCOMPONENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestComponentEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCOMPONENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCOMPONENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestComponentEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestComponentEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestPhysicsEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait TestPhysicsEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl TestPhysicsEntityDataTrait for TestPhysicsEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for TestPhysicsEntityData {
}

impl super::entity::GameObjectDataTrait for TestPhysicsEntityData {
}

impl super::core::DataBusPeerTrait for TestPhysicsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestPhysicsEntityData {
}

impl super::core::DataContainerTrait for TestPhysicsEntityData {
}

pub static TESTPHYSICSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPhysicsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestPhysicsEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestPhysicsEntityData, realm),
            },
        ],
    }),
    array_type: Some(TESTPHYSICSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestPhysicsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTPHYSICSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTPHYSICSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestPhysicsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestPhysicsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestCaseEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub time_out: f32,
    pub enabled: bool,
    pub test_group: String,
    pub stable: bool,
    pub description: String,
    pub test_case_name: String,
    pub test_author_name: String,
    pub cleanup_timeout: f32,
}

pub trait TestCaseEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn time_out(&self) -> &f32;
    fn time_out_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn test_group(&self) -> &String;
    fn test_group_mut(&mut self) -> &mut String;
    fn stable(&self) -> &bool;
    fn stable_mut(&mut self) -> &mut bool;
    fn description(&self) -> &String;
    fn description_mut(&mut self) -> &mut String;
    fn test_case_name(&self) -> &String;
    fn test_case_name_mut(&mut self) -> &mut String;
    fn test_author_name(&self) -> &String;
    fn test_author_name_mut(&mut self) -> &mut String;
    fn cleanup_timeout(&self) -> &f32;
    fn cleanup_timeout_mut(&mut self) -> &mut f32;
}

impl TestCaseEntityDataTrait for TestCaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn time_out(&self) -> &f32 {
        &self.time_out
    }
    fn time_out_mut(&mut self) -> &mut f32 {
        &mut self.time_out
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn test_group(&self) -> &String {
        &self.test_group
    }
    fn test_group_mut(&mut self) -> &mut String {
        &mut self.test_group
    }
    fn stable(&self) -> &bool {
        &self.stable
    }
    fn stable_mut(&mut self) -> &mut bool {
        &mut self.stable
    }
    fn description(&self) -> &String {
        &self.description
    }
    fn description_mut(&mut self) -> &mut String {
        &mut self.description
    }
    fn test_case_name(&self) -> &String {
        &self.test_case_name
    }
    fn test_case_name_mut(&mut self) -> &mut String {
        &mut self.test_case_name
    }
    fn test_author_name(&self) -> &String {
        &self.test_author_name
    }
    fn test_author_name_mut(&mut self) -> &mut String {
        &mut self.test_author_name
    }
    fn cleanup_timeout(&self) -> &f32 {
        &self.cleanup_timeout
    }
    fn cleanup_timeout_mut(&mut self) -> &mut f32 {
        &mut self.cleanup_timeout
    }
}

impl super::entity::EntityDataTrait for TestCaseEntityData {
}

impl super::entity::GameObjectDataTrait for TestCaseEntityData {
}

impl super::core::DataBusPeerTrait for TestCaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCaseEntityData {
}

impl super::core::DataContainerTrait for TestCaseEntityData {
}

pub static TESTCASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCaseEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCaseEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestCaseEntityData, realm),
            },
            FieldInfoData {
                name: "TimeOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TestCaseEntityData, time_out),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TestCaseEntityData, enabled),
            },
            FieldInfoData {
                name: "TestGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityData, test_group),
            },
            FieldInfoData {
                name: "Stable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TestCaseEntityData, stable),
            },
            FieldInfoData {
                name: "Description",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityData, description),
            },
            FieldInfoData {
                name: "TestCaseName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityData, test_case_name),
            },
            FieldInfoData {
                name: "TestAuthorName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(TestCaseEntityData, test_author_name),
            },
            FieldInfoData {
                name: "CleanupTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TestCaseEntityData, cleanup_timeout),
            },
        ],
    }),
    array_type: Some(TESTCASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestCaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCaseEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DebugMenuItemEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub item_type: DebugMenuItemType,
    pub text: String,
}

pub trait DebugMenuItemEntityDataTrait: super::entity::EntityDataTrait {
    fn item_type(&self) -> &DebugMenuItemType;
    fn item_type_mut(&mut self) -> &mut DebugMenuItemType;
    fn text(&self) -> &String;
    fn text_mut(&mut self) -> &mut String;
}

impl DebugMenuItemEntityDataTrait for DebugMenuItemEntityData {
    fn item_type(&self) -> &DebugMenuItemType {
        &self.item_type
    }
    fn item_type_mut(&mut self) -> &mut DebugMenuItemType {
        &mut self.item_type
    }
    fn text(&self) -> &String {
        &self.text
    }
    fn text_mut(&mut self) -> &mut String {
        &mut self.text
    }
}

impl super::entity::EntityDataTrait for DebugMenuItemEntityData {
}

impl super::entity::GameObjectDataTrait for DebugMenuItemEntityData {
}

impl super::core::DataBusPeerTrait for DebugMenuItemEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DebugMenuItemEntityData {
}

impl super::core::DataContainerTrait for DebugMenuItemEntityData {
}

pub static DEBUGMENUITEMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuItemEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugMenuItemEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ItemType",
                flags: MemberInfoFlags::new(0),
                field_type: "DebugMenuItemType",
                rust_offset: offset_of!(DebugMenuItemEntityData, item_type),
            },
            FieldInfoData {
                name: "Text",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DebugMenuItemEntityData, text),
            },
        ],
    }),
    array_type: Some(DEBUGMENUITEMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DebugMenuItemEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGMENUITEMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGMENUITEMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuItemEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DebugMenuItemEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DebugMenuItemType {
    #[default]
    DmitItem = 0,
    DmitToggle = 1,
}

pub static DEBUGMENUITEMTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuItemType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(DEBUGMENUITEMTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DebugMenuItemType {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGMENUITEMTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DEBUGMENUITEMTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuItemType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DebugMenuItemType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DebugMenuSubMenuEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub text: String,
}

pub trait DebugMenuSubMenuEntityDataTrait: super::entity::EntityDataTrait {
    fn text(&self) -> &String;
    fn text_mut(&mut self) -> &mut String;
}

impl DebugMenuSubMenuEntityDataTrait for DebugMenuSubMenuEntityData {
    fn text(&self) -> &String {
        &self.text
    }
    fn text_mut(&mut self) -> &mut String {
        &mut self.text
    }
}

impl super::entity::EntityDataTrait for DebugMenuSubMenuEntityData {
}

impl super::entity::GameObjectDataTrait for DebugMenuSubMenuEntityData {
}

impl super::core::DataBusPeerTrait for DebugMenuSubMenuEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DebugMenuSubMenuEntityData {
}

impl super::core::DataContainerTrait for DebugMenuSubMenuEntityData {
}

pub static DEBUGMENUSUBMENUENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuSubMenuEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugMenuSubMenuEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Text",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DebugMenuSubMenuEntityData, text),
            },
        ],
    }),
    array_type: Some(DEBUGMENUSUBMENUENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DebugMenuSubMenuEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGMENUSUBMENUENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGMENUSUBMENUENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugMenuSubMenuEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DebugMenuSubMenuEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ConsoleCommandTriggerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub command_name: String,
    pub group_name: String,
    pub realm: super::core::Realm,
    pub update_defaults_on_changed: bool,
    pub arguments: Vec<String>,
}

pub trait ConsoleCommandTriggerEntityDataTrait: super::entity::EntityDataTrait {
    fn command_name(&self) -> &String;
    fn command_name_mut(&mut self) -> &mut String;
    fn group_name(&self) -> &String;
    fn group_name_mut(&mut self) -> &mut String;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn update_defaults_on_changed(&self) -> &bool;
    fn update_defaults_on_changed_mut(&mut self) -> &mut bool;
    fn arguments(&self) -> &Vec<String>;
    fn arguments_mut(&mut self) -> &mut Vec<String>;
}

impl ConsoleCommandTriggerEntityDataTrait for ConsoleCommandTriggerEntityData {
    fn command_name(&self) -> &String {
        &self.command_name
    }
    fn command_name_mut(&mut self) -> &mut String {
        &mut self.command_name
    }
    fn group_name(&self) -> &String {
        &self.group_name
    }
    fn group_name_mut(&mut self) -> &mut String {
        &mut self.group_name
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn update_defaults_on_changed(&self) -> &bool {
        &self.update_defaults_on_changed
    }
    fn update_defaults_on_changed_mut(&mut self) -> &mut bool {
        &mut self.update_defaults_on_changed
    }
    fn arguments(&self) -> &Vec<String> {
        &self.arguments
    }
    fn arguments_mut(&mut self) -> &mut Vec<String> {
        &mut self.arguments
    }
}

impl super::entity::EntityDataTrait for ConsoleCommandTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for ConsoleCommandTriggerEntityData {
}

impl super::core::DataBusPeerTrait for ConsoleCommandTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ConsoleCommandTriggerEntityData {
}

impl super::core::DataContainerTrait for ConsoleCommandTriggerEntityData {
}

pub static CONSOLECOMMANDTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsoleCommandTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConsoleCommandTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CommandName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, command_name),
            },
            FieldInfoData {
                name: "GroupName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, group_name),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, realm),
            },
            FieldInfoData {
                name: "UpdateDefaultsOnChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, update_defaults_on_changed),
            },
            FieldInfoData {
                name: "Arguments",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(ConsoleCommandTriggerEntityData, arguments),
            },
        ],
    }),
    array_type: Some(CONSOLECOMMANDTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConsoleCommandTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CONSOLECOMMANDTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONSOLECOMMANDTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsoleCommandTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ConsoleCommandTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ConsoleCommandEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub commands: Vec<String>,
    pub dynamic_command: String,
    pub realm: super::core::Realm,
}

pub trait ConsoleCommandEntityDataTrait: super::entity::EntityDataTrait {
    fn commands(&self) -> &Vec<String>;
    fn commands_mut(&mut self) -> &mut Vec<String>;
    fn dynamic_command(&self) -> &String;
    fn dynamic_command_mut(&mut self) -> &mut String;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl ConsoleCommandEntityDataTrait for ConsoleCommandEntityData {
    fn commands(&self) -> &Vec<String> {
        &self.commands
    }
    fn commands_mut(&mut self) -> &mut Vec<String> {
        &mut self.commands
    }
    fn dynamic_command(&self) -> &String {
        &self.dynamic_command
    }
    fn dynamic_command_mut(&mut self) -> &mut String {
        &mut self.dynamic_command
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for ConsoleCommandEntityData {
}

impl super::entity::GameObjectDataTrait for ConsoleCommandEntityData {
}

impl super::core::DataBusPeerTrait for ConsoleCommandEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ConsoleCommandEntityData {
}

impl super::core::DataContainerTrait for ConsoleCommandEntityData {
}

pub static CONSOLECOMMANDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsoleCommandEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConsoleCommandEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Commands",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(ConsoleCommandEntityData, commands),
            },
            FieldInfoData {
                name: "DynamicCommand",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ConsoleCommandEntityData, dynamic_command),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ConsoleCommandEntityData, realm),
            },
        ],
    }),
    array_type: Some(CONSOLECOMMANDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConsoleCommandEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CONSOLECOMMANDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONSOLECOMMANDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConsoleCommandEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ConsoleCommandEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DebugTextEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub debug_text: String,
    pub text_color: super::core::Vec3,
    pub realm: super::core::Realm,
    pub centered: bool,
    pub visible: bool,
    pub scale: f32,
    pub depth_test: bool,
    pub scale_with_distance: bool,
}

pub trait DebugTextEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn debug_text(&self) -> &String;
    fn debug_text_mut(&mut self) -> &mut String;
    fn text_color(&self) -> &super::core::Vec3;
    fn text_color_mut(&mut self) -> &mut super::core::Vec3;
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn centered(&self) -> &bool;
    fn centered_mut(&mut self) -> &mut bool;
    fn visible(&self) -> &bool;
    fn visible_mut(&mut self) -> &mut bool;
    fn scale(&self) -> &f32;
    fn scale_mut(&mut self) -> &mut f32;
    fn depth_test(&self) -> &bool;
    fn depth_test_mut(&mut self) -> &mut bool;
    fn scale_with_distance(&self) -> &bool;
    fn scale_with_distance_mut(&mut self) -> &mut bool;
}

impl DebugTextEntityDataTrait for DebugTextEntityData {
    fn debug_text(&self) -> &String {
        &self.debug_text
    }
    fn debug_text_mut(&mut self) -> &mut String {
        &mut self.debug_text
    }
    fn text_color(&self) -> &super::core::Vec3 {
        &self.text_color
    }
    fn text_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.text_color
    }
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn centered(&self) -> &bool {
        &self.centered
    }
    fn centered_mut(&mut self) -> &mut bool {
        &mut self.centered
    }
    fn visible(&self) -> &bool {
        &self.visible
    }
    fn visible_mut(&mut self) -> &mut bool {
        &mut self.visible
    }
    fn scale(&self) -> &f32 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut f32 {
        &mut self.scale
    }
    fn depth_test(&self) -> &bool {
        &self.depth_test
    }
    fn depth_test_mut(&mut self) -> &mut bool {
        &mut self.depth_test
    }
    fn scale_with_distance(&self) -> &bool {
        &self.scale_with_distance
    }
    fn scale_with_distance_mut(&mut self) -> &mut bool {
        &mut self.scale_with_distance
    }
}

impl super::entity::SpatialEntityDataTrait for DebugTextEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for DebugTextEntityData {
}

impl super::entity::GameObjectDataTrait for DebugTextEntityData {
}

impl super::core::DataBusPeerTrait for DebugTextEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DebugTextEntityData {
}

impl super::core::DataContainerTrait for DebugTextEntityData {
}

pub static DEBUGTEXTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugTextEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugTextEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DebugText",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DebugTextEntityData, debug_text),
            },
            FieldInfoData {
                name: "TextColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DebugTextEntityData, text_color),
            },
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DebugTextEntityData, realm),
            },
            FieldInfoData {
                name: "Centered",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugTextEntityData, centered),
            },
            FieldInfoData {
                name: "Visible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugTextEntityData, visible),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DebugTextEntityData, scale),
            },
            FieldInfoData {
                name: "DepthTest",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugTextEntityData, depth_test),
            },
            FieldInfoData {
                name: "ScaleWithDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugTextEntityData, scale_with_distance),
            },
        ],
    }),
    array_type: Some(DEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DebugTextEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGTEXTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGTEXTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugTextEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("DebugTextEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestCollisionEventEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub expected_body_collisions: u32,
}

pub trait TestCollisionEventEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn expected_body_collisions(&self) -> &u32;
    fn expected_body_collisions_mut(&mut self) -> &mut u32;
}

impl TestCollisionEventEntityDataTrait for TestCollisionEventEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn expected_body_collisions(&self) -> &u32 {
        &self.expected_body_collisions
    }
    fn expected_body_collisions_mut(&mut self) -> &mut u32 {
        &mut self.expected_body_collisions
    }
}

impl super::entity::EntityDataTrait for TestCollisionEventEntityData {
}

impl super::entity::GameObjectDataTrait for TestCollisionEventEntityData {
}

impl super::core::DataBusPeerTrait for TestCollisionEventEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCollisionEventEntityData {
}

impl super::core::DataContainerTrait for TestCollisionEventEntityData {
}

pub static TESTCOLLISIONEVENTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCollisionEventEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCollisionEventEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestCollisionEventEntityData, realm),
            },
            FieldInfoData {
                name: "ExpectedBodyCollisions",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TestCollisionEventEntityData, expected_body_collisions),
            },
        ],
    }),
    array_type: Some(TESTCOLLISIONEVENTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TestCollisionEventEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCOLLISIONEVENTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCOLLISIONEVENTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCollisionEventEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCollisionEventEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TestCollisionEventComponentData {
    pub _glacier_base: super::entity::ComponentData,
    pub realm: super::core::Realm,
    pub expected_client_body_collisions: u32,
    pub expected_server_body_collisions: u32,
}

pub trait TestCollisionEventComponentDataTrait: super::entity::ComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn expected_client_body_collisions(&self) -> &u32;
    fn expected_client_body_collisions_mut(&mut self) -> &mut u32;
    fn expected_server_body_collisions(&self) -> &u32;
    fn expected_server_body_collisions_mut(&mut self) -> &mut u32;
}

impl TestCollisionEventComponentDataTrait for TestCollisionEventComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn expected_client_body_collisions(&self) -> &u32 {
        &self.expected_client_body_collisions
    }
    fn expected_client_body_collisions_mut(&mut self) -> &mut u32 {
        &mut self.expected_client_body_collisions
    }
    fn expected_server_body_collisions(&self) -> &u32 {
        &self.expected_server_body_collisions
    }
    fn expected_server_body_collisions_mut(&mut self) -> &mut u32 {
        &mut self.expected_server_body_collisions
    }
}

impl super::entity::ComponentDataTrait for TestCollisionEventComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for TestCollisionEventComponentData {
}

impl super::core::DataBusPeerTrait for TestCollisionEventComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TestCollisionEventComponentData {
}

impl super::core::DataContainerTrait for TestCollisionEventComponentData {
}

pub static TESTCOLLISIONEVENTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCollisionEventComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::COMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TestCollisionEventComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(TestCollisionEventComponentData, realm),
            },
            FieldInfoData {
                name: "ExpectedClientBodyCollisions",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TestCollisionEventComponentData, expected_client_body_collisions),
            },
            FieldInfoData {
                name: "ExpectedServerBodyCollisions",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(TestCollisionEventComponentData, expected_server_body_collisions),
            },
        ],
    }),
    array_type: Some(TESTCOLLISIONEVENTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for TestCollisionEventComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        TESTCOLLISIONEVENTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TESTCOLLISIONEVENTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TestCollisionEventComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TestCollisionEventComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TerrainDynamicDecalEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub physics_material: super::entity::MaterialDecl,
}

pub trait TerrainDynamicDecalEntityDataTrait: super::entity::EntityDataTrait {
    fn physics_material(&self) -> &super::entity::MaterialDecl;
    fn physics_material_mut(&mut self) -> &mut super::entity::MaterialDecl;
}

impl TerrainDynamicDecalEntityDataTrait for TerrainDynamicDecalEntityData {
    fn physics_material(&self) -> &super::entity::MaterialDecl {
        &self.physics_material
    }
    fn physics_material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.physics_material
    }
}

impl super::entity::EntityDataTrait for TerrainDynamicDecalEntityData {
}

impl super::entity::GameObjectDataTrait for TerrainDynamicDecalEntityData {
}

impl super::core::DataBusPeerTrait for TerrainDynamicDecalEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for TerrainDynamicDecalEntityData {
}

impl super::core::DataContainerTrait for TerrainDynamicDecalEntityData {
}

pub static TERRAINDYNAMICDECALENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TerrainDynamicDecalEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TerrainDynamicDecalEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PhysicsMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(TerrainDynamicDecalEntityData, physics_material),
            },
        ],
    }),
    array_type: Some(TERRAINDYNAMICDECALENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TerrainDynamicDecalEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        TERRAINDYNAMICDECALENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TERRAINDYNAMICDECALENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TerrainDynamicDecalEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("TerrainDynamicDecalEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SyncedSequenceEntityData {
    pub _glacier_base: super::entity::SequenceEntityData,
}

pub trait SyncedSequenceEntityDataTrait: super::entity::SequenceEntityDataTrait {
}

impl SyncedSequenceEntityDataTrait for SyncedSequenceEntityData {
}

impl super::entity::SequenceEntityDataTrait for SyncedSequenceEntityData {
    fn events(&self) -> &Vec<super::entity::SequenceEventData> {
        self._glacier_base.events()
    }
    fn events_mut(&mut self) -> &mut Vec<super::entity::SequenceEventData> {
        self._glacier_base.events_mut()
    }
    fn sequence_start_time(&self) -> &i32 {
        self._glacier_base.sequence_start_time()
    }
    fn sequence_start_time_mut(&mut self) -> &mut i32 {
        self._glacier_base.sequence_start_time_mut()
    }
    fn sequence_length(&self) -> &i32 {
        self._glacier_base.sequence_length()
    }
    fn sequence_length_mut(&mut self) -> &mut i32 {
        self._glacier_base.sequence_length_mut()
    }
    fn looping(&self) -> &bool {
        self._glacier_base.looping()
    }
    fn looping_mut(&mut self) -> &mut bool {
        self._glacier_base.looping_mut()
    }
    fn auto_start(&self) -> &bool {
        self._glacier_base.auto_start()
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_start_mut()
    }
    fn auto_play_first_frame(&self) -> &bool {
        self._glacier_base.auto_play_first_frame()
    }
    fn auto_play_first_frame_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_play_first_frame_mut()
    }
    fn play_in_reverse(&self) -> &bool {
        self._glacier_base.play_in_reverse()
    }
    fn play_in_reverse_mut(&mut self) -> &mut bool {
        self._glacier_base.play_in_reverse_mut()
    }
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn property_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::PropertyTrackDataTrait>>>> {
        self._glacier_base.property_tracks()
    }
    fn property_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::PropertyTrackDataTrait>>>> {
        self._glacier_base.property_tracks_mut()
    }
    fn custom_sequence_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::CustomSequenceTrackDataTrait>>>> {
        self._glacier_base.custom_sequence_tracks()
    }
    fn custom_sequence_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::CustomSequenceTrackDataTrait>>>> {
        self._glacier_base.custom_sequence_tracks_mut()
    }
    fn client_update_pass(&self) -> &super::entity::UpdatePass {
        self._glacier_base.client_update_pass()
    }
    fn client_update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        self._glacier_base.client_update_pass_mut()
    }
    fn server_update_pass(&self) -> &super::entity::UpdatePass {
        self._glacier_base.server_update_pass()
    }
    fn server_update_pass_mut(&mut self) -> &mut super::entity::UpdatePass {
        self._glacier_base.server_update_pass_mut()
    }
    fn external_time(&self) -> &f32 {
        self._glacier_base.external_time()
    }
    fn external_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.external_time_mut()
    }
    fn playback_speed(&self) -> &f32 {
        self._glacier_base.playback_speed()
    }
    fn playback_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.playback_speed_mut()
    }
}

impl super::entity::EntityDataTrait for SyncedSequenceEntityData {
}

impl super::entity::GameObjectDataTrait for SyncedSequenceEntityData {
}

impl super::core::DataBusPeerTrait for SyncedSequenceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SyncedSequenceEntityData {
}

impl super::core::DataContainerTrait for SyncedSequenceEntityData {
}

pub static SYNCEDSEQUENCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SyncedSequenceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SEQUENCEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SyncedSequenceEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SYNCEDSEQUENCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SyncedSequenceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SYNCEDSEQUENCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SYNCEDSEQUENCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SyncedSequenceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SyncedSequenceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameSubViewData {
    pub _glacier_base: super::gameplay_sim::SubViewData,
}

pub trait GameSubViewDataTrait: super::gameplay_sim::SubViewDataTrait {
}

impl GameSubViewDataTrait for GameSubViewData {
}

impl super::gameplay_sim::SubViewDataTrait for GameSubViewData {
}

impl super::core::DataContainerTrait for GameSubViewData {
}

pub static GAMESUBVIEWDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSubViewData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::SUBVIEWDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameSubViewData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMESUBVIEWDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameSubViewData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMESUBVIEWDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMESUBVIEWDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSubViewData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameSubViewData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpectatorSubViewData {
    pub _glacier_base: super::gameplay_sim::SubViewData,
}

pub trait SpectatorSubViewDataTrait: super::gameplay_sim::SubViewDataTrait {
}

impl SpectatorSubViewDataTrait for SpectatorSubViewData {
}

impl super::gameplay_sim::SubViewDataTrait for SpectatorSubViewData {
}

impl super::core::DataContainerTrait for SpectatorSubViewData {
}

pub static SPECTATORSUBVIEWDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpectatorSubViewData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::SUBVIEWDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpectatorSubViewData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SPECTATORSUBVIEWDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpectatorSubViewData {
    fn type_info(&self) -> &'static TypeInfo {
        SPECTATORSUBVIEWDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPECTATORSUBVIEWDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpectatorSubViewData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SpectatorSubViewData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubLevelStatusEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub sub_level_name: String,
}

pub trait SubLevelStatusEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn sub_level_name(&self) -> &String;
    fn sub_level_name_mut(&mut self) -> &mut String;
}

impl SubLevelStatusEntityDataTrait for SubLevelStatusEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn sub_level_name(&self) -> &String {
        &self.sub_level_name
    }
    fn sub_level_name_mut(&mut self) -> &mut String {
        &mut self.sub_level_name
    }
}

impl super::entity::EntityDataTrait for SubLevelStatusEntityData {
}

impl super::entity::GameObjectDataTrait for SubLevelStatusEntityData {
}

impl super::core::DataBusPeerTrait for SubLevelStatusEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SubLevelStatusEntityData {
}

impl super::core::DataContainerTrait for SubLevelStatusEntityData {
}

pub static SUBLEVELSTATUSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelStatusEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelStatusEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SubLevelStatusEntityData, realm),
            },
            FieldInfoData {
                name: "SubLevelName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SubLevelStatusEntityData, sub_level_name),
            },
        ],
    }),
    array_type: Some(SUBLEVELSTATUSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubLevelStatusEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELSTATUSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBLEVELSTATUSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelStatusEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SubLevelStatusEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SubLevelPreloadEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub sub_levels_to_preload: Vec<String>,
}

pub trait SubLevelPreloadEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn sub_levels_to_preload(&self) -> &Vec<String>;
    fn sub_levels_to_preload_mut(&mut self) -> &mut Vec<String>;
}

impl SubLevelPreloadEntityDataTrait for SubLevelPreloadEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn sub_levels_to_preload(&self) -> &Vec<String> {
        &self.sub_levels_to_preload
    }
    fn sub_levels_to_preload_mut(&mut self) -> &mut Vec<String> {
        &mut self.sub_levels_to_preload
    }
}

impl super::entity::EntityDataTrait for SubLevelPreloadEntityData {
}

impl super::entity::GameObjectDataTrait for SubLevelPreloadEntityData {
}

impl super::core::DataBusPeerTrait for SubLevelPreloadEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SubLevelPreloadEntityData {
}

impl super::core::DataContainerTrait for SubLevelPreloadEntityData {
}

pub static SUBLEVELPRELOADENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelPreloadEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SubLevelPreloadEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SubLevelPreloadEntityData, realm),
            },
            FieldInfoData {
                name: "SubLevelsToPreload",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SubLevelPreloadEntityData, sub_levels_to_preload),
            },
        ],
    }),
    array_type: Some(SUBLEVELPRELOADENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SubLevelPreloadEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SUBLEVELPRELOADENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUBLEVELPRELOADENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SubLevelPreloadEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SubLevelPreloadEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticModelNetworkDestructionComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub max_network_id: u32,
}

pub trait StaticModelNetworkDestructionComponentDataTrait: super::entity::GameComponentDataTrait {
    fn max_network_id(&self) -> &u32;
    fn max_network_id_mut(&mut self) -> &mut u32;
}

impl StaticModelNetworkDestructionComponentDataTrait for StaticModelNetworkDestructionComponentData {
    fn max_network_id(&self) -> &u32 {
        &self.max_network_id
    }
    fn max_network_id_mut(&mut self) -> &mut u32 {
        &mut self.max_network_id
    }
}

impl super::entity::GameComponentDataTrait for StaticModelNetworkDestructionComponentData {
}

impl super::entity::ComponentDataTrait for StaticModelNetworkDestructionComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelNetworkDestructionComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelNetworkDestructionComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelNetworkDestructionComponentData {
}

impl super::core::DataContainerTrait for StaticModelNetworkDestructionComponentData {
}

pub static STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelNetworkDestructionComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelNetworkDestructionComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxNetworkId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelNetworkDestructionComponentData, max_network_id),
            },
        ],
    }),
    array_type: Some(STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelNetworkDestructionComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELNETWORKDESTRUCTIONCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelNetworkDestructionComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelNetworkDestructionComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticModelHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait StaticModelHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl StaticModelHealthComponentDataTrait for StaticModelHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for StaticModelHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for StaticModelHealthComponentData {
}

impl super::entity::ComponentDataTrait for StaticModelHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelHealthComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelHealthComponentData {
}

impl super::core::DataContainerTrait for StaticModelHealthComponentData {
}

pub static STATICMODELHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelHealthComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticModelPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
}

pub trait StaticModelPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
}

impl StaticModelPhysicsComponentDataTrait for StaticModelPhysicsComponentData {
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for StaticModelPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for StaticModelPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for StaticModelPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for StaticModelPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for StaticModelPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelPhysicsComponentData {
}

impl super::core::DataContainerTrait for StaticModelPhysicsComponentData {
}

pub static STATICMODELPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelPhysicsComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(STATICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InteractableStaticModelEntityData {
    pub _glacier_base: StaticModelEntityData,
}

pub trait InteractableStaticModelEntityDataTrait: StaticModelEntityDataTrait {
}

impl InteractableStaticModelEntityDataTrait for InteractableStaticModelEntityData {
}

impl StaticModelEntityDataTrait for InteractableStaticModelEntityData {
    fn part_links(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links_mut()
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms()
    }
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms_mut()
    }
    fn exclude_from_nearby_object_destruction(&self) -> &bool {
        self._glacier_base.exclude_from_nearby_object_destruction()
    }
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool {
        self._glacier_base.exclude_from_nearby_object_destruction_mut()
    }
    fn physics_part_infos(&self) -> &Vec<PhysicsPartInfo> {
        self._glacier_base.physics_part_infos()
    }
    fn physics_part_infos_mut(&mut self) -> &mut Vec<PhysicsPartInfo> {
        self._glacier_base.physics_part_infos_mut()
    }
    fn network_info(&self) -> &StaticModelNetworkInfo {
        self._glacier_base.network_info()
    }
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo {
        self._glacier_base.network_info_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
    fn terrain_shader_nodes_enable(&self) -> &bool {
        self._glacier_base.terrain_shader_nodes_enable()
    }
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.terrain_shader_nodes_enable_mut()
    }
    fn explosion_packs_attachable(&self) -> &bool {
        self._glacier_base.explosion_packs_attachable()
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        self._glacier_base.explosion_packs_attachable_mut()
    }
    fn light_map_weight(&self) -> &f32 {
        self._glacier_base.light_map_weight()
    }
    fn light_map_weight_mut(&mut self) -> &mut f32 {
        self._glacier_base.light_map_weight_mut()
    }
    fn visible(&self) -> &bool {
        self._glacier_base.visible()
    }
    fn visible_mut(&mut self) -> &mut bool {
        self._glacier_base.visible_mut()
    }
    fn overlay_enabled(&self) -> &bool {
        self._glacier_base.overlay_enabled()
    }
    fn overlay_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.overlay_enabled_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for InteractableStaticModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for InteractableStaticModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for InteractableStaticModelEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for InteractableStaticModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for InteractableStaticModelEntityData {
}

impl super::entity::GameObjectDataTrait for InteractableStaticModelEntityData {
}

impl super::core::DataBusPeerTrait for InteractableStaticModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for InteractableStaticModelEntityData {
}

impl super::core::DataContainerTrait for InteractableStaticModelEntityData {
}

pub static INTERACTABLESTATICMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InteractableStaticModelEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(STATICMODELENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InteractableStaticModelEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(INTERACTABLESTATICMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for InteractableStaticModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        INTERACTABLESTATICMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INTERACTABLESTATICMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InteractableStaticModelEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("InteractableStaticModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FenceModelEntityData {
    pub _glacier_base: StaticModelEntityData,
    pub width: f32,
    pub angle: f32,
}

pub trait FenceModelEntityDataTrait: StaticModelEntityDataTrait {
    fn width(&self) -> &f32;
    fn width_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
}

impl FenceModelEntityDataTrait for FenceModelEntityData {
    fn width(&self) -> &f32 {
        &self.width
    }
    fn width_mut(&mut self) -> &mut f32 {
        &mut self.width
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
}

impl StaticModelEntityDataTrait for FenceModelEntityData {
    fn part_links(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links_mut()
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms()
    }
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms_mut()
    }
    fn exclude_from_nearby_object_destruction(&self) -> &bool {
        self._glacier_base.exclude_from_nearby_object_destruction()
    }
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool {
        self._glacier_base.exclude_from_nearby_object_destruction_mut()
    }
    fn physics_part_infos(&self) -> &Vec<PhysicsPartInfo> {
        self._glacier_base.physics_part_infos()
    }
    fn physics_part_infos_mut(&mut self) -> &mut Vec<PhysicsPartInfo> {
        self._glacier_base.physics_part_infos_mut()
    }
    fn network_info(&self) -> &StaticModelNetworkInfo {
        self._glacier_base.network_info()
    }
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo {
        self._glacier_base.network_info_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
    fn terrain_shader_nodes_enable(&self) -> &bool {
        self._glacier_base.terrain_shader_nodes_enable()
    }
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.terrain_shader_nodes_enable_mut()
    }
    fn explosion_packs_attachable(&self) -> &bool {
        self._glacier_base.explosion_packs_attachable()
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        self._glacier_base.explosion_packs_attachable_mut()
    }
    fn light_map_weight(&self) -> &f32 {
        self._glacier_base.light_map_weight()
    }
    fn light_map_weight_mut(&mut self) -> &mut f32 {
        self._glacier_base.light_map_weight_mut()
    }
    fn visible(&self) -> &bool {
        self._glacier_base.visible()
    }
    fn visible_mut(&mut self) -> &mut bool {
        self._glacier_base.visible_mut()
    }
    fn overlay_enabled(&self) -> &bool {
        self._glacier_base.overlay_enabled()
    }
    fn overlay_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.overlay_enabled_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for FenceModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for FenceModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for FenceModelEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for FenceModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for FenceModelEntityData {
}

impl super::entity::GameObjectDataTrait for FenceModelEntityData {
}

impl super::core::DataBusPeerTrait for FenceModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FenceModelEntityData {
}

impl super::core::DataContainerTrait for FenceModelEntityData {
}

pub static FENCEMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FenceModelEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(STATICMODELENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FenceModelEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Width",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FenceModelEntityData, width),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FenceModelEntityData, angle),
            },
        ],
    }),
    array_type: Some(FENCEMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FenceModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FENCEMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FENCEMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FenceModelEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FenceModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LadderEntityData {
    pub _glacier_base: StaticModelEntityData,
}

pub trait LadderEntityDataTrait: StaticModelEntityDataTrait {
}

impl LadderEntityDataTrait for LadderEntityData {
}

impl StaticModelEntityDataTrait for LadderEntityData {
    fn part_links(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links()
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        self._glacier_base.part_links_mut()
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh()
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        self._glacier_base.mesh_mut()
    }
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms()
    }
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        self._glacier_base.base_pose_transforms_mut()
    }
    fn exclude_from_nearby_object_destruction(&self) -> &bool {
        self._glacier_base.exclude_from_nearby_object_destruction()
    }
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool {
        self._glacier_base.exclude_from_nearby_object_destruction_mut()
    }
    fn physics_part_infos(&self) -> &Vec<PhysicsPartInfo> {
        self._glacier_base.physics_part_infos()
    }
    fn physics_part_infos_mut(&mut self) -> &mut Vec<PhysicsPartInfo> {
        self._glacier_base.physics_part_infos_mut()
    }
    fn network_info(&self) -> &StaticModelNetworkInfo {
        self._glacier_base.network_info()
    }
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo {
        self._glacier_base.network_info_mut()
    }
    fn animate_physics(&self) -> &bool {
        self._glacier_base.animate_physics()
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        self._glacier_base.animate_physics_mut()
    }
    fn terrain_shader_nodes_enable(&self) -> &bool {
        self._glacier_base.terrain_shader_nodes_enable()
    }
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.terrain_shader_nodes_enable_mut()
    }
    fn explosion_packs_attachable(&self) -> &bool {
        self._glacier_base.explosion_packs_attachable()
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        self._glacier_base.explosion_packs_attachable_mut()
    }
    fn light_map_weight(&self) -> &f32 {
        self._glacier_base.light_map_weight()
    }
    fn light_map_weight_mut(&mut self) -> &mut f32 {
        self._glacier_base.light_map_weight_mut()
    }
    fn visible(&self) -> &bool {
        self._glacier_base.visible()
    }
    fn visible_mut(&mut self) -> &mut bool {
        self._glacier_base.visible_mut()
    }
    fn overlay_enabled(&self) -> &bool {
        self._glacier_base.overlay_enabled()
    }
    fn overlay_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.overlay_enabled_mut()
    }
}

impl super::physics::GamePhysicsEntityDataTrait for LadderEntityData {
}

impl super::entity::GameComponentEntityDataTrait for LadderEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for LadderEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for LadderEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for LadderEntityData {
}

impl super::entity::GameObjectDataTrait for LadderEntityData {
}

impl super::core::DataBusPeerTrait for LadderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LadderEntityData {
}

impl super::core::DataContainerTrait for LadderEntityData {
}

pub static LADDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LadderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(STATICMODELENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LadderEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LADDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for LadderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LADDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LADDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LadderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("LadderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticModelEntityData {
    pub _glacier_base: super::physics::GamePhysicsEntityData,
    pub part_links: Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>>,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub base_pose_transforms: super::core::SparseTransformArray,
    pub exclude_from_nearby_object_destruction: bool,
    pub physics_part_infos: Vec<PhysicsPartInfo>,
    pub network_info: StaticModelNetworkInfo,
    pub animate_physics: bool,
    pub terrain_shader_nodes_enable: bool,
    pub explosion_packs_attachable: bool,
    pub light_map_weight: f32,
    pub visible: bool,
    pub overlay_enabled: bool,
}

pub trait StaticModelEntityDataTrait: super::physics::GamePhysicsEntityDataTrait {
    fn part_links(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>>;
    fn part_links_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>>;
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray;
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray;
    fn exclude_from_nearby_object_destruction(&self) -> &bool;
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool;
    fn physics_part_infos(&self) -> &Vec<PhysicsPartInfo>;
    fn physics_part_infos_mut(&mut self) -> &mut Vec<PhysicsPartInfo>;
    fn network_info(&self) -> &StaticModelNetworkInfo;
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo;
    fn animate_physics(&self) -> &bool;
    fn animate_physics_mut(&mut self) -> &mut bool;
    fn terrain_shader_nodes_enable(&self) -> &bool;
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool;
    fn explosion_packs_attachable(&self) -> &bool;
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool;
    fn light_map_weight(&self) -> &f32;
    fn light_map_weight_mut(&mut self) -> &mut f32;
    fn visible(&self) -> &bool;
    fn visible_mut(&mut self) -> &mut bool;
    fn overlay_enabled(&self) -> &bool;
    fn overlay_enabled_mut(&mut self) -> &mut bool;
}

impl StaticModelEntityDataTrait for StaticModelEntityData {
    fn part_links(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        &self.part_links
    }
    fn part_links_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::PartLinkDataTrait>>>> {
        &mut self.part_links
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn base_pose_transforms(&self) -> &super::core::SparseTransformArray {
        &self.base_pose_transforms
    }
    fn base_pose_transforms_mut(&mut self) -> &mut super::core::SparseTransformArray {
        &mut self.base_pose_transforms
    }
    fn exclude_from_nearby_object_destruction(&self) -> &bool {
        &self.exclude_from_nearby_object_destruction
    }
    fn exclude_from_nearby_object_destruction_mut(&mut self) -> &mut bool {
        &mut self.exclude_from_nearby_object_destruction
    }
    fn physics_part_infos(&self) -> &Vec<PhysicsPartInfo> {
        &self.physics_part_infos
    }
    fn physics_part_infos_mut(&mut self) -> &mut Vec<PhysicsPartInfo> {
        &mut self.physics_part_infos
    }
    fn network_info(&self) -> &StaticModelNetworkInfo {
        &self.network_info
    }
    fn network_info_mut(&mut self) -> &mut StaticModelNetworkInfo {
        &mut self.network_info
    }
    fn animate_physics(&self) -> &bool {
        &self.animate_physics
    }
    fn animate_physics_mut(&mut self) -> &mut bool {
        &mut self.animate_physics
    }
    fn terrain_shader_nodes_enable(&self) -> &bool {
        &self.terrain_shader_nodes_enable
    }
    fn terrain_shader_nodes_enable_mut(&mut self) -> &mut bool {
        &mut self.terrain_shader_nodes_enable
    }
    fn explosion_packs_attachable(&self) -> &bool {
        &self.explosion_packs_attachable
    }
    fn explosion_packs_attachable_mut(&mut self) -> &mut bool {
        &mut self.explosion_packs_attachable
    }
    fn light_map_weight(&self) -> &f32 {
        &self.light_map_weight
    }
    fn light_map_weight_mut(&mut self) -> &mut f32 {
        &mut self.light_map_weight
    }
    fn visible(&self) -> &bool {
        &self.visible
    }
    fn visible_mut(&mut self) -> &mut bool {
        &mut self.visible
    }
    fn overlay_enabled(&self) -> &bool {
        &self.overlay_enabled
    }
    fn overlay_enabled_mut(&mut self) -> &mut bool {
        &mut self.overlay_enabled
    }
}

impl super::physics::GamePhysicsEntityDataTrait for StaticModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for StaticModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for StaticModelEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for StaticModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for StaticModelEntityData {
}

impl super::entity::GameObjectDataTrait for StaticModelEntityData {
}

impl super::core::DataBusPeerTrait for StaticModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StaticModelEntityData {
}

impl super::core::DataContainerTrait for StaticModelEntityData {
}

pub static STATICMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::GAMEPHYSICSENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PartLinks",
                flags: MemberInfoFlags::new(144),
                field_type: "PartLinkData-Array",
                rust_offset: offset_of!(StaticModelEntityData, part_links),
            },
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(StaticModelEntityData, mesh),
            },
            FieldInfoData {
                name: "BasePoseTransforms",
                flags: MemberInfoFlags::new(0),
                field_type: "SparseTransformArray",
                rust_offset: offset_of!(StaticModelEntityData, base_pose_transforms),
            },
            FieldInfoData {
                name: "ExcludeFromNearbyObjectDestruction",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, exclude_from_nearby_object_destruction),
            },
            FieldInfoData {
                name: "PhysicsPartInfos",
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsPartInfo-Array",
                rust_offset: offset_of!(StaticModelEntityData, physics_part_infos),
            },
            FieldInfoData {
                name: "NetworkInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "StaticModelNetworkInfo",
                rust_offset: offset_of!(StaticModelEntityData, network_info),
            },
            FieldInfoData {
                name: "AnimatePhysics",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, animate_physics),
            },
            FieldInfoData {
                name: "TerrainShaderNodesEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, terrain_shader_nodes_enable),
            },
            FieldInfoData {
                name: "ExplosionPacksAttachable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, explosion_packs_attachable),
            },
            FieldInfoData {
                name: "LightMapWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StaticModelEntityData, light_map_weight),
            },
            FieldInfoData {
                name: "Visible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, visible),
            },
            FieldInfoData {
                name: "OverlayEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StaticModelEntityData, overlay_enabled),
            },
        ],
    }),
    array_type: Some(STATICMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StaticModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STATICMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StaticModelNetworkInfo {
    pub part_network_id_ranges: Vec<IndexRange>,
    pub network_id_count: u32,
    pub child_network_infos: Vec<ChildStaticModelNetworkInfo>,
    pub child_network_id_count: u32,
}

pub trait StaticModelNetworkInfoTrait: TypeObject {
    fn part_network_id_ranges(&self) -> &Vec<IndexRange>;
    fn part_network_id_ranges_mut(&mut self) -> &mut Vec<IndexRange>;
    fn network_id_count(&self) -> &u32;
    fn network_id_count_mut(&mut self) -> &mut u32;
    fn child_network_infos(&self) -> &Vec<ChildStaticModelNetworkInfo>;
    fn child_network_infos_mut(&mut self) -> &mut Vec<ChildStaticModelNetworkInfo>;
    fn child_network_id_count(&self) -> &u32;
    fn child_network_id_count_mut(&mut self) -> &mut u32;
}

impl StaticModelNetworkInfoTrait for StaticModelNetworkInfo {
    fn part_network_id_ranges(&self) -> &Vec<IndexRange> {
        &self.part_network_id_ranges
    }
    fn part_network_id_ranges_mut(&mut self) -> &mut Vec<IndexRange> {
        &mut self.part_network_id_ranges
    }
    fn network_id_count(&self) -> &u32 {
        &self.network_id_count
    }
    fn network_id_count_mut(&mut self) -> &mut u32 {
        &mut self.network_id_count
    }
    fn child_network_infos(&self) -> &Vec<ChildStaticModelNetworkInfo> {
        &self.child_network_infos
    }
    fn child_network_infos_mut(&mut self) -> &mut Vec<ChildStaticModelNetworkInfo> {
        &mut self.child_network_infos
    }
    fn child_network_id_count(&self) -> &u32 {
        &self.child_network_id_count
    }
    fn child_network_id_count_mut(&mut self) -> &mut u32 {
        &mut self.child_network_id_count
    }
}

pub static STATICMODELNETWORKINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelNetworkInfo",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StaticModelNetworkInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PartNetworkIdRanges",
                flags: MemberInfoFlags::new(144),
                field_type: "IndexRange-Array",
                rust_offset: offset_of!(StaticModelNetworkInfo, part_network_id_ranges),
            },
            FieldInfoData {
                name: "NetworkIdCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelNetworkInfo, network_id_count),
            },
            FieldInfoData {
                name: "ChildNetworkInfos",
                flags: MemberInfoFlags::new(144),
                field_type: "ChildStaticModelNetworkInfo-Array",
                rust_offset: offset_of!(StaticModelNetworkInfo, child_network_infos),
            },
            FieldInfoData {
                name: "ChildNetworkIdCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StaticModelNetworkInfo, child_network_id_count),
            },
        ],
    }),
    array_type: Some(STATICMODELNETWORKINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StaticModelNetworkInfo {
    fn type_info(&self) -> &'static TypeInfo {
        STATICMODELNETWORKINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STATICMODELNETWORKINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StaticModelNetworkInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("StaticModelNetworkInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChildStaticModelNetworkInfo {
    pub network_range: IndexRange,
    pub parent_part_component_index: u32,
    pub parent_health_state_index: u32,
    pub instance_index: u32,
}

pub trait ChildStaticModelNetworkInfoTrait: TypeObject {
    fn network_range(&self) -> &IndexRange;
    fn network_range_mut(&mut self) -> &mut IndexRange;
    fn parent_part_component_index(&self) -> &u32;
    fn parent_part_component_index_mut(&mut self) -> &mut u32;
    fn parent_health_state_index(&self) -> &u32;
    fn parent_health_state_index_mut(&mut self) -> &mut u32;
    fn instance_index(&self) -> &u32;
    fn instance_index_mut(&mut self) -> &mut u32;
}

impl ChildStaticModelNetworkInfoTrait for ChildStaticModelNetworkInfo {
    fn network_range(&self) -> &IndexRange {
        &self.network_range
    }
    fn network_range_mut(&mut self) -> &mut IndexRange {
        &mut self.network_range
    }
    fn parent_part_component_index(&self) -> &u32 {
        &self.parent_part_component_index
    }
    fn parent_part_component_index_mut(&mut self) -> &mut u32 {
        &mut self.parent_part_component_index
    }
    fn parent_health_state_index(&self) -> &u32 {
        &self.parent_health_state_index
    }
    fn parent_health_state_index_mut(&mut self) -> &mut u32 {
        &mut self.parent_health_state_index
    }
    fn instance_index(&self) -> &u32 {
        &self.instance_index
    }
    fn instance_index_mut(&mut self) -> &mut u32 {
        &mut self.instance_index
    }
}

pub static CHILDSTATICMODELNETWORKINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildStaticModelNetworkInfo",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChildStaticModelNetworkInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NetworkRange",
                flags: MemberInfoFlags::new(0),
                field_type: "IndexRange",
                rust_offset: offset_of!(ChildStaticModelNetworkInfo, network_range),
            },
            FieldInfoData {
                name: "ParentPartComponentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ChildStaticModelNetworkInfo, parent_part_component_index),
            },
            FieldInfoData {
                name: "ParentHealthStateIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ChildStaticModelNetworkInfo, parent_health_state_index),
            },
            FieldInfoData {
                name: "InstanceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ChildStaticModelNetworkInfo, instance_index),
            },
        ],
    }),
    array_type: Some(CHILDSTATICMODELNETWORKINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ChildStaticModelNetworkInfo {
    fn type_info(&self) -> &'static TypeInfo {
        CHILDSTATICMODELNETWORKINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHILDSTATICMODELNETWORKINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChildStaticModelNetworkInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ChildStaticModelNetworkInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IndexRange {
    pub first: u32,
    pub last: u32,
}

pub trait IndexRangeTrait: TypeObject {
    fn first(&self) -> &u32;
    fn first_mut(&mut self) -> &mut u32;
    fn last(&self) -> &u32;
    fn last_mut(&mut self) -> &mut u32;
}

impl IndexRangeTrait for IndexRange {
    fn first(&self) -> &u32 {
        &self.first
    }
    fn first_mut(&mut self) -> &mut u32 {
        &mut self.first
    }
    fn last(&self) -> &u32 {
        &self.last
    }
    fn last_mut(&mut self) -> &mut u32 {
        &mut self.last
    }
}

pub static INDEXRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IndexRange",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IndexRange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "First",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(IndexRange, first),
            },
            FieldInfoData {
                name: "Last",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(IndexRange, last),
            },
        ],
    }),
    array_type: Some(INDEXRANGE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for IndexRange {
    fn type_info(&self) -> &'static TypeInfo {
        INDEXRANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INDEXRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IndexRange-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("IndexRange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsPartInfo {
    pub part_component_index: u32,
    pub health_state_index: u32,
}

pub trait PhysicsPartInfoTrait: TypeObject {
    fn part_component_index(&self) -> &u32;
    fn part_component_index_mut(&mut self) -> &mut u32;
    fn health_state_index(&self) -> &u32;
    fn health_state_index_mut(&mut self) -> &mut u32;
}

impl PhysicsPartInfoTrait for PhysicsPartInfo {
    fn part_component_index(&self) -> &u32 {
        &self.part_component_index
    }
    fn part_component_index_mut(&mut self) -> &mut u32 {
        &mut self.part_component_index
    }
    fn health_state_index(&self) -> &u32 {
        &self.health_state_index
    }
    fn health_state_index_mut(&mut self) -> &mut u32 {
        &mut self.health_state_index
    }
}

pub static PHYSICSPARTINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsPartInfo",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsPartInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PartComponentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PhysicsPartInfo, part_component_index),
            },
            FieldInfoData {
                name: "HealthStateIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PhysicsPartInfo, health_state_index),
            },
        ],
    }),
    array_type: Some(PHYSICSPARTINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PhysicsPartInfo {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSPARTINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PHYSICSPARTINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsPartInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PhysicsPartInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleSpawnReferenceObjectData {
    pub _glacier_base: SpawnReferenceObjectData,
    pub wreck_duration: f32,
    pub set_team_on_spawn: bool,
    pub affected_by_impulse: bool,
    pub enter_restriction: EntryEnterRestriction,
    pub a_i_allowed_to_follow_human_in_vehicle: bool,
    pub a_i_use_exit_points: bool,
    pub apply_damage_to_abandoned_vehicles: bool,
    pub respawn_range: f32,
    pub time_until_abandoned: f32,
    pub time_until_abandoned_is_destroyed: f32,
    pub keep_alive_radius: f32,
    pub active_stance_entry_index: i32,
    pub active_stance: i32,
    pub vehicle_is_near_distance: f32,
    pub enable_available_seat_output: bool,
    pub disregard_spawn_allowed_setting: bool,
}

pub trait VehicleSpawnReferenceObjectDataTrait: SpawnReferenceObjectDataTrait {
    fn wreck_duration(&self) -> &f32;
    fn wreck_duration_mut(&mut self) -> &mut f32;
    fn set_team_on_spawn(&self) -> &bool;
    fn set_team_on_spawn_mut(&mut self) -> &mut bool;
    fn affected_by_impulse(&self) -> &bool;
    fn affected_by_impulse_mut(&mut self) -> &mut bool;
    fn enter_restriction(&self) -> &EntryEnterRestriction;
    fn enter_restriction_mut(&mut self) -> &mut EntryEnterRestriction;
    fn a_i_allowed_to_follow_human_in_vehicle(&self) -> &bool;
    fn a_i_allowed_to_follow_human_in_vehicle_mut(&mut self) -> &mut bool;
    fn a_i_use_exit_points(&self) -> &bool;
    fn a_i_use_exit_points_mut(&mut self) -> &mut bool;
    fn apply_damage_to_abandoned_vehicles(&self) -> &bool;
    fn apply_damage_to_abandoned_vehicles_mut(&mut self) -> &mut bool;
    fn respawn_range(&self) -> &f32;
    fn respawn_range_mut(&mut self) -> &mut f32;
    fn time_until_abandoned(&self) -> &f32;
    fn time_until_abandoned_mut(&mut self) -> &mut f32;
    fn time_until_abandoned_is_destroyed(&self) -> &f32;
    fn time_until_abandoned_is_destroyed_mut(&mut self) -> &mut f32;
    fn keep_alive_radius(&self) -> &f32;
    fn keep_alive_radius_mut(&mut self) -> &mut f32;
    fn active_stance_entry_index(&self) -> &i32;
    fn active_stance_entry_index_mut(&mut self) -> &mut i32;
    fn active_stance(&self) -> &i32;
    fn active_stance_mut(&mut self) -> &mut i32;
    fn vehicle_is_near_distance(&self) -> &f32;
    fn vehicle_is_near_distance_mut(&mut self) -> &mut f32;
    fn enable_available_seat_output(&self) -> &bool;
    fn enable_available_seat_output_mut(&mut self) -> &mut bool;
    fn disregard_spawn_allowed_setting(&self) -> &bool;
    fn disregard_spawn_allowed_setting_mut(&mut self) -> &mut bool;
}

impl VehicleSpawnReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn wreck_duration(&self) -> &f32 {
        &self.wreck_duration
    }
    fn wreck_duration_mut(&mut self) -> &mut f32 {
        &mut self.wreck_duration
    }
    fn set_team_on_spawn(&self) -> &bool {
        &self.set_team_on_spawn
    }
    fn set_team_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.set_team_on_spawn
    }
    fn affected_by_impulse(&self) -> &bool {
        &self.affected_by_impulse
    }
    fn affected_by_impulse_mut(&mut self) -> &mut bool {
        &mut self.affected_by_impulse
    }
    fn enter_restriction(&self) -> &EntryEnterRestriction {
        &self.enter_restriction
    }
    fn enter_restriction_mut(&mut self) -> &mut EntryEnterRestriction {
        &mut self.enter_restriction
    }
    fn a_i_allowed_to_follow_human_in_vehicle(&self) -> &bool {
        &self.a_i_allowed_to_follow_human_in_vehicle
    }
    fn a_i_allowed_to_follow_human_in_vehicle_mut(&mut self) -> &mut bool {
        &mut self.a_i_allowed_to_follow_human_in_vehicle
    }
    fn a_i_use_exit_points(&self) -> &bool {
        &self.a_i_use_exit_points
    }
    fn a_i_use_exit_points_mut(&mut self) -> &mut bool {
        &mut self.a_i_use_exit_points
    }
    fn apply_damage_to_abandoned_vehicles(&self) -> &bool {
        &self.apply_damage_to_abandoned_vehicles
    }
    fn apply_damage_to_abandoned_vehicles_mut(&mut self) -> &mut bool {
        &mut self.apply_damage_to_abandoned_vehicles
    }
    fn respawn_range(&self) -> &f32 {
        &self.respawn_range
    }
    fn respawn_range_mut(&mut self) -> &mut f32 {
        &mut self.respawn_range
    }
    fn time_until_abandoned(&self) -> &f32 {
        &self.time_until_abandoned
    }
    fn time_until_abandoned_mut(&mut self) -> &mut f32 {
        &mut self.time_until_abandoned
    }
    fn time_until_abandoned_is_destroyed(&self) -> &f32 {
        &self.time_until_abandoned_is_destroyed
    }
    fn time_until_abandoned_is_destroyed_mut(&mut self) -> &mut f32 {
        &mut self.time_until_abandoned_is_destroyed
    }
    fn keep_alive_radius(&self) -> &f32 {
        &self.keep_alive_radius
    }
    fn keep_alive_radius_mut(&mut self) -> &mut f32 {
        &mut self.keep_alive_radius
    }
    fn active_stance_entry_index(&self) -> &i32 {
        &self.active_stance_entry_index
    }
    fn active_stance_entry_index_mut(&mut self) -> &mut i32 {
        &mut self.active_stance_entry_index
    }
    fn active_stance(&self) -> &i32 {
        &self.active_stance
    }
    fn active_stance_mut(&mut self) -> &mut i32 {
        &mut self.active_stance
    }
    fn vehicle_is_near_distance(&self) -> &f32 {
        &self.vehicle_is_near_distance
    }
    fn vehicle_is_near_distance_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_is_near_distance
    }
    fn enable_available_seat_output(&self) -> &bool {
        &self.enable_available_seat_output
    }
    fn enable_available_seat_output_mut(&mut self) -> &mut bool {
        &mut self.enable_available_seat_output
    }
    fn disregard_spawn_allowed_setting(&self) -> &bool {
        &self.disregard_spawn_allowed_setting
    }
    fn disregard_spawn_allowed_setting_mut(&mut self) -> &mut bool {
        &mut self.disregard_spawn_allowed_setting
    }
}

impl SpawnReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.team()
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.team_mut()
    }
    fn locked_team(&self) -> &bool {
        self._glacier_base.locked_team()
    }
    fn locked_team_mut(&mut self) -> &mut bool {
        self._glacier_base.locked_team_mut()
    }
    fn spawn_area_radius(&self) -> &f32 {
        self._glacier_base.spawn_area_radius()
    }
    fn spawn_area_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_area_radius_mut()
    }
    fn spawn_protection_radius(&self) -> &f32 {
        self._glacier_base.spawn_protection_radius()
    }
    fn spawn_protection_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_radius_mut()
    }
    fn spawn_protection_check_all_teams(&self) -> &bool {
        self._glacier_base.spawn_protection_check_all_teams()
    }
    fn spawn_protection_check_all_teams_mut(&mut self) -> &mut bool {
        self._glacier_base.spawn_protection_check_all_teams_mut()
    }
    fn spawn_protection_friendly_killed_count(&self) -> &u32 {
        self._glacier_base.spawn_protection_friendly_killed_count()
    }
    fn spawn_protection_friendly_killed_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.spawn_protection_friendly_killed_count_mut()
    }
    fn spawn_protection_friendly_killed_time(&self) -> &f32 {
        self._glacier_base.spawn_protection_friendly_killed_time()
    }
    fn spawn_protection_friendly_killed_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_friendly_killed_time_mut()
    }
    fn clear_bangers_on_spawn(&self) -> &bool {
        self._glacier_base.clear_bangers_on_spawn()
    }
    fn clear_bangers_on_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.clear_bangers_on_spawn_mut()
    }
    fn try_to_spawn_out_of_sight(&self) -> &bool {
        self._glacier_base.try_to_spawn_out_of_sight()
    }
    fn try_to_spawn_out_of_sight_mut(&mut self) -> &mut bool {
        self._glacier_base.try_to_spawn_out_of_sight_mut()
    }
    fn send_weapon_events(&self) -> &bool {
        self._glacier_base.send_weapon_events()
    }
    fn send_weapon_events_mut(&mut self) -> &mut bool {
        self._glacier_base.send_weapon_events_mut()
    }
    fn take_control_on_transform_change(&self) -> &bool {
        self._glacier_base.take_control_on_transform_change()
    }
    fn take_control_on_transform_change_mut(&mut self) -> &mut bool {
        self._glacier_base.take_control_on_transform_change_mut()
    }
    fn return_control_on_idle(&self) -> &bool {
        self._glacier_base.return_control_on_idle()
    }
    fn return_control_on_idle_mut(&mut self) -> &mut bool {
        self._glacier_base.return_control_on_idle_mut()
    }
    fn take_control_entry_index(&self) -> &i32 {
        self._glacier_base.take_control_entry_index()
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.take_control_entry_index_mut()
    }
    fn rotation_yaw(&self) -> &f32 {
        self._glacier_base.rotation_yaw()
    }
    fn rotation_yaw_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_yaw_mut()
    }
    fn rotation_pitch(&self) -> &f32 {
        self._glacier_base.rotation_pitch()
    }
    fn rotation_pitch_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_pitch_mut()
    }
    fn rotation_roll(&self) -> &f32 {
        self._glacier_base.rotation_roll()
    }
    fn rotation_roll_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_roll_mut()
    }
    fn throttle(&self) -> &f32 {
        self._glacier_base.throttle()
    }
    fn throttle_mut(&mut self) -> &mut f32 {
        self._glacier_base.throttle_mut()
    }
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
    fn max_unspawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_unspawn_in_frame()
    }
    fn max_unspawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_unspawn_in_frame_mut()
    }
}

impl super::gameplay_sim::GameplaySpawnReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn extra_spawn_data(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::ExtraSpawnDataTrait>>>> {
        self._glacier_base.extra_spawn_data()
    }
    fn extra_spawn_data_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::ExtraSpawnDataTrait>>>> {
        self._glacier_base.extra_spawn_data_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn location_name_sid(&self) -> &String {
        self._glacier_base.location_name_sid()
    }
    fn location_name_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_name_sid_mut()
    }
    fn location_text_sid(&self) -> &String {
        self._glacier_base.location_text_sid()
    }
    fn location_text_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_text_sid_mut()
    }
    fn initial_auto_spawn(&self) -> &bool {
        self._glacier_base.initial_auto_spawn()
    }
    fn initial_auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.initial_auto_spawn_mut()
    }
    fn auto_spawn(&self) -> &bool {
        self._glacier_base.auto_spawn()
    }
    fn auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_spawn_mut()
    }
    fn queue_spawn_event(&self) -> &bool {
        self._glacier_base.queue_spawn_event()
    }
    fn queue_spawn_event_mut(&mut self) -> &mut bool {
        self._glacier_base.queue_spawn_event_mut()
    }
    fn use_as_spawn_point(&self) -> &bool {
        self._glacier_base.use_as_spawn_point()
    }
    fn use_as_spawn_point_mut(&mut self) -> &mut bool {
        self._glacier_base.use_as_spawn_point_mut()
    }
    fn initial_spawn_delay(&self) -> &f32 {
        self._glacier_base.initial_spawn_delay()
    }
    fn initial_spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.initial_spawn_delay_mut()
    }
    fn spawn_delay(&self) -> &f32 {
        self._glacier_base.spawn_delay()
    }
    fn spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_delay_mut()
    }
    fn max_count(&self) -> &i32 {
        self._glacier_base.max_count()
    }
    fn max_count_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_mut()
    }
    fn max_count_simultaneously(&self) -> &i32 {
        self._glacier_base.max_count_simultaneously()
    }
    fn max_count_simultaneously_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_simultaneously_mut()
    }
    fn total_count_simultaneously_of_type(&self) -> &i32 {
        self._glacier_base.total_count_simultaneously_of_type()
    }
    fn total_count_simultaneously_of_type_mut(&mut self) -> &mut i32 {
        self._glacier_base.total_count_simultaneously_of_type_mut()
    }
    fn max_spawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_spawn_in_frame()
    }
    fn max_spawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_spawn_in_frame_mut()
    }
    fn only_send_event_for_human_players(&self) -> &bool {
        self._glacier_base.only_send_event_for_human_players()
    }
    fn only_send_event_for_human_players_mut(&mut self) -> &mut bool {
        self._glacier_base.only_send_event_for_human_players_mut()
    }
    fn controllable_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_transform()
    }
    fn controllable_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_transform_mut()
    }
    fn controllable_input(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_input()
    }
    fn controllable_input_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_input_mut()
    }
}

impl super::entity::SpatialReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for VehicleSpawnReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for VehicleSpawnReferenceObjectData {
}

impl super::core::DataBusPeerTrait for VehicleSpawnReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VehicleSpawnReferenceObjectData {
}

impl super::core::DataContainerTrait for VehicleSpawnReferenceObjectData {
}

pub static VEHICLESPAWNREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSpawnReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPAWNREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleSpawnReferenceObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WreckDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, wreck_duration),
            },
            FieldInfoData {
                name: "SetTeamOnSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, set_team_on_spawn),
            },
            FieldInfoData {
                name: "AffectedByImpulse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, affected_by_impulse),
            },
            FieldInfoData {
                name: "EnterRestriction",
                flags: MemberInfoFlags::new(0),
                field_type: "EntryEnterRestriction",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, enter_restriction),
            },
            FieldInfoData {
                name: "AIAllowedToFollowHumanInVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, a_i_allowed_to_follow_human_in_vehicle),
            },
            FieldInfoData {
                name: "AIUseExitPoints",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, a_i_use_exit_points),
            },
            FieldInfoData {
                name: "ApplyDamageToAbandonedVehicles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, apply_damage_to_abandoned_vehicles),
            },
            FieldInfoData {
                name: "RespawnRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, respawn_range),
            },
            FieldInfoData {
                name: "TimeUntilAbandoned",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, time_until_abandoned),
            },
            FieldInfoData {
                name: "TimeUntilAbandonedIsDestroyed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, time_until_abandoned_is_destroyed),
            },
            FieldInfoData {
                name: "KeepAliveRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, keep_alive_radius),
            },
            FieldInfoData {
                name: "ActiveStanceEntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, active_stance_entry_index),
            },
            FieldInfoData {
                name: "ActiveStance",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, active_stance),
            },
            FieldInfoData {
                name: "VehicleIsNearDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, vehicle_is_near_distance),
            },
            FieldInfoData {
                name: "EnableAvailableSeatOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, enable_available_seat_output),
            },
            FieldInfoData {
                name: "DisregardSpawnAllowedSetting",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleSpawnReferenceObjectData, disregard_spawn_allowed_setting),
            },
        ],
    }),
    array_type: Some(VEHICLESPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VehicleSpawnReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLESPAWNREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLESPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSpawnReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("VehicleSpawnReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterSpawnReferenceObjectData {
    pub _glacier_base: SpawnReferenceObjectData,
    pub vehicle_entry_index: u32,
    pub allow_fallback_on_next_availabe_vehicle_entry: bool,
    pub template: Option<Arc<Mutex<dyn CharacterSpawnTemplateDataTrait>>>,
    pub spawn_visible: bool,
    pub human_target_preference: f32,
    pub is_target: bool,
    pub affect_minimap_position: bool,
    pub show_as_label_only: bool,
    pub show_in_menu: bool,
    pub menu_show_order: i32,
}

pub trait CharacterSpawnReferenceObjectDataTrait: SpawnReferenceObjectDataTrait {
    fn vehicle_entry_index(&self) -> &u32;
    fn vehicle_entry_index_mut(&mut self) -> &mut u32;
    fn allow_fallback_on_next_availabe_vehicle_entry(&self) -> &bool;
    fn allow_fallback_on_next_availabe_vehicle_entry_mut(&mut self) -> &mut bool;
    fn template(&self) -> &Option<Arc<Mutex<dyn CharacterSpawnTemplateDataTrait>>>;
    fn template_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterSpawnTemplateDataTrait>>>;
    fn spawn_visible(&self) -> &bool;
    fn spawn_visible_mut(&mut self) -> &mut bool;
    fn human_target_preference(&self) -> &f32;
    fn human_target_preference_mut(&mut self) -> &mut f32;
    fn is_target(&self) -> &bool;
    fn is_target_mut(&mut self) -> &mut bool;
    fn affect_minimap_position(&self) -> &bool;
    fn affect_minimap_position_mut(&mut self) -> &mut bool;
    fn show_as_label_only(&self) -> &bool;
    fn show_as_label_only_mut(&mut self) -> &mut bool;
    fn show_in_menu(&self) -> &bool;
    fn show_in_menu_mut(&mut self) -> &mut bool;
    fn menu_show_order(&self) -> &i32;
    fn menu_show_order_mut(&mut self) -> &mut i32;
}

impl CharacterSpawnReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn vehicle_entry_index(&self) -> &u32 {
        &self.vehicle_entry_index
    }
    fn vehicle_entry_index_mut(&mut self) -> &mut u32 {
        &mut self.vehicle_entry_index
    }
    fn allow_fallback_on_next_availabe_vehicle_entry(&self) -> &bool {
        &self.allow_fallback_on_next_availabe_vehicle_entry
    }
    fn allow_fallback_on_next_availabe_vehicle_entry_mut(&mut self) -> &mut bool {
        &mut self.allow_fallback_on_next_availabe_vehicle_entry
    }
    fn template(&self) -> &Option<Arc<Mutex<dyn CharacterSpawnTemplateDataTrait>>> {
        &self.template
    }
    fn template_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CharacterSpawnTemplateDataTrait>>> {
        &mut self.template
    }
    fn spawn_visible(&self) -> &bool {
        &self.spawn_visible
    }
    fn spawn_visible_mut(&mut self) -> &mut bool {
        &mut self.spawn_visible
    }
    fn human_target_preference(&self) -> &f32 {
        &self.human_target_preference
    }
    fn human_target_preference_mut(&mut self) -> &mut f32 {
        &mut self.human_target_preference
    }
    fn is_target(&self) -> &bool {
        &self.is_target
    }
    fn is_target_mut(&mut self) -> &mut bool {
        &mut self.is_target
    }
    fn affect_minimap_position(&self) -> &bool {
        &self.affect_minimap_position
    }
    fn affect_minimap_position_mut(&mut self) -> &mut bool {
        &mut self.affect_minimap_position
    }
    fn show_as_label_only(&self) -> &bool {
        &self.show_as_label_only
    }
    fn show_as_label_only_mut(&mut self) -> &mut bool {
        &mut self.show_as_label_only
    }
    fn show_in_menu(&self) -> &bool {
        &self.show_in_menu
    }
    fn show_in_menu_mut(&mut self) -> &mut bool {
        &mut self.show_in_menu
    }
    fn menu_show_order(&self) -> &i32 {
        &self.menu_show_order
    }
    fn menu_show_order_mut(&mut self) -> &mut i32 {
        &mut self.menu_show_order
    }
}

impl SpawnReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        self._glacier_base.team()
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        self._glacier_base.team_mut()
    }
    fn locked_team(&self) -> &bool {
        self._glacier_base.locked_team()
    }
    fn locked_team_mut(&mut self) -> &mut bool {
        self._glacier_base.locked_team_mut()
    }
    fn spawn_area_radius(&self) -> &f32 {
        self._glacier_base.spawn_area_radius()
    }
    fn spawn_area_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_area_radius_mut()
    }
    fn spawn_protection_radius(&self) -> &f32 {
        self._glacier_base.spawn_protection_radius()
    }
    fn spawn_protection_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_radius_mut()
    }
    fn spawn_protection_check_all_teams(&self) -> &bool {
        self._glacier_base.spawn_protection_check_all_teams()
    }
    fn spawn_protection_check_all_teams_mut(&mut self) -> &mut bool {
        self._glacier_base.spawn_protection_check_all_teams_mut()
    }
    fn spawn_protection_friendly_killed_count(&self) -> &u32 {
        self._glacier_base.spawn_protection_friendly_killed_count()
    }
    fn spawn_protection_friendly_killed_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.spawn_protection_friendly_killed_count_mut()
    }
    fn spawn_protection_friendly_killed_time(&self) -> &f32 {
        self._glacier_base.spawn_protection_friendly_killed_time()
    }
    fn spawn_protection_friendly_killed_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_protection_friendly_killed_time_mut()
    }
    fn clear_bangers_on_spawn(&self) -> &bool {
        self._glacier_base.clear_bangers_on_spawn()
    }
    fn clear_bangers_on_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.clear_bangers_on_spawn_mut()
    }
    fn try_to_spawn_out_of_sight(&self) -> &bool {
        self._glacier_base.try_to_spawn_out_of_sight()
    }
    fn try_to_spawn_out_of_sight_mut(&mut self) -> &mut bool {
        self._glacier_base.try_to_spawn_out_of_sight_mut()
    }
    fn send_weapon_events(&self) -> &bool {
        self._glacier_base.send_weapon_events()
    }
    fn send_weapon_events_mut(&mut self) -> &mut bool {
        self._glacier_base.send_weapon_events_mut()
    }
    fn take_control_on_transform_change(&self) -> &bool {
        self._glacier_base.take_control_on_transform_change()
    }
    fn take_control_on_transform_change_mut(&mut self) -> &mut bool {
        self._glacier_base.take_control_on_transform_change_mut()
    }
    fn return_control_on_idle(&self) -> &bool {
        self._glacier_base.return_control_on_idle()
    }
    fn return_control_on_idle_mut(&mut self) -> &mut bool {
        self._glacier_base.return_control_on_idle_mut()
    }
    fn take_control_entry_index(&self) -> &i32 {
        self._glacier_base.take_control_entry_index()
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.take_control_entry_index_mut()
    }
    fn rotation_yaw(&self) -> &f32 {
        self._glacier_base.rotation_yaw()
    }
    fn rotation_yaw_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_yaw_mut()
    }
    fn rotation_pitch(&self) -> &f32 {
        self._glacier_base.rotation_pitch()
    }
    fn rotation_pitch_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_pitch_mut()
    }
    fn rotation_roll(&self) -> &f32 {
        self._glacier_base.rotation_roll()
    }
    fn rotation_roll_mut(&mut self) -> &mut f32 {
        self._glacier_base.rotation_roll_mut()
    }
    fn throttle(&self) -> &f32 {
        self._glacier_base.throttle()
    }
    fn throttle_mut(&mut self) -> &mut f32 {
        self._glacier_base.throttle_mut()
    }
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type()
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        self._glacier_base.time_delta_type_mut()
    }
    fn max_unspawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_unspawn_in_frame()
    }
    fn max_unspawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_unspawn_in_frame_mut()
    }
}

impl super::gameplay_sim::GameplaySpawnReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn extra_spawn_data(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::ExtraSpawnDataTrait>>>> {
        self._glacier_base.extra_spawn_data()
    }
    fn extra_spawn_data_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::ExtraSpawnDataTrait>>>> {
        self._glacier_base.extra_spawn_data_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn location_name_sid(&self) -> &String {
        self._glacier_base.location_name_sid()
    }
    fn location_name_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_name_sid_mut()
    }
    fn location_text_sid(&self) -> &String {
        self._glacier_base.location_text_sid()
    }
    fn location_text_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_text_sid_mut()
    }
    fn initial_auto_spawn(&self) -> &bool {
        self._glacier_base.initial_auto_spawn()
    }
    fn initial_auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.initial_auto_spawn_mut()
    }
    fn auto_spawn(&self) -> &bool {
        self._glacier_base.auto_spawn()
    }
    fn auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_spawn_mut()
    }
    fn queue_spawn_event(&self) -> &bool {
        self._glacier_base.queue_spawn_event()
    }
    fn queue_spawn_event_mut(&mut self) -> &mut bool {
        self._glacier_base.queue_spawn_event_mut()
    }
    fn use_as_spawn_point(&self) -> &bool {
        self._glacier_base.use_as_spawn_point()
    }
    fn use_as_spawn_point_mut(&mut self) -> &mut bool {
        self._glacier_base.use_as_spawn_point_mut()
    }
    fn initial_spawn_delay(&self) -> &f32 {
        self._glacier_base.initial_spawn_delay()
    }
    fn initial_spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.initial_spawn_delay_mut()
    }
    fn spawn_delay(&self) -> &f32 {
        self._glacier_base.spawn_delay()
    }
    fn spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_delay_mut()
    }
    fn max_count(&self) -> &i32 {
        self._glacier_base.max_count()
    }
    fn max_count_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_mut()
    }
    fn max_count_simultaneously(&self) -> &i32 {
        self._glacier_base.max_count_simultaneously()
    }
    fn max_count_simultaneously_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_simultaneously_mut()
    }
    fn total_count_simultaneously_of_type(&self) -> &i32 {
        self._glacier_base.total_count_simultaneously_of_type()
    }
    fn total_count_simultaneously_of_type_mut(&mut self) -> &mut i32 {
        self._glacier_base.total_count_simultaneously_of_type_mut()
    }
    fn max_spawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_spawn_in_frame()
    }
    fn max_spawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_spawn_in_frame_mut()
    }
    fn only_send_event_for_human_players(&self) -> &bool {
        self._glacier_base.only_send_event_for_human_players()
    }
    fn only_send_event_for_human_players_mut(&mut self) -> &mut bool {
        self._glacier_base.only_send_event_for_human_players_mut()
    }
    fn controllable_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_transform()
    }
    fn controllable_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_transform_mut()
    }
    fn controllable_input(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_input()
    }
    fn controllable_input_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_input_mut()
    }
}

impl super::entity::SpatialReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for CharacterSpawnReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for CharacterSpawnReferenceObjectData {
}

impl super::core::DataBusPeerTrait for CharacterSpawnReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CharacterSpawnReferenceObjectData {
}

impl super::core::DataContainerTrait for CharacterSpawnReferenceObjectData {
}

pub static CHARACTERSPAWNREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSpawnReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPAWNREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterSpawnReferenceObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VehicleEntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, vehicle_entry_index),
            },
            FieldInfoData {
                name: "AllowFallbackOnNextAvailabeVehicleEntry",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, allow_fallback_on_next_availabe_vehicle_entry),
            },
            FieldInfoData {
                name: "Template",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterSpawnTemplateData",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, template),
            },
            FieldInfoData {
                name: "SpawnVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, spawn_visible),
            },
            FieldInfoData {
                name: "HumanTargetPreference",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, human_target_preference),
            },
            FieldInfoData {
                name: "IsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, is_target),
            },
            FieldInfoData {
                name: "AffectMinimapPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, affect_minimap_position),
            },
            FieldInfoData {
                name: "ShowAsLabelOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, show_as_label_only),
            },
            FieldInfoData {
                name: "ShowInMenu",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, show_in_menu),
            },
            FieldInfoData {
                name: "MenuShowOrder",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CharacterSpawnReferenceObjectData, menu_show_order),
            },
        ],
    }),
    array_type: Some(CHARACTERSPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CharacterSpawnReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSPAWNREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSpawnReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterSpawnReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CharacterToComponentsSpawnTemplateMessage {
}

pub trait CharacterToComponentsSpawnTemplateMessageTrait: TypeObject {
}

impl CharacterToComponentsSpawnTemplateMessageTrait for CharacterToComponentsSpawnTemplateMessage {
}

pub static CHARACTERTOCOMPONENTSSPAWNTEMPLATEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterToComponentsSpawnTemplateMessage",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterToComponentsSpawnTemplateMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for CharacterToComponentsSpawnTemplateMessage {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERTOCOMPONENTSSPAWNTEMPLATEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct CharacterSpawnTemplateData {
    pub _glacier_base: super::core::Asset,
    pub customize_character_data: Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>>,
    pub sensing: Option<Arc<Mutex<dyn GameSensingTemplateDataTrait>>>,
    pub behaviour: Option<Arc<Mutex<dyn GameBehaviourTemplateDataTrait>>>,
    pub animation_template: Option<Arc<Mutex<dyn AnimationSpawnTemplateTrait>>>,
    pub voice_over_labels: Vec<Option<Arc<Mutex<dyn super::audio::VoiceOverLabelTrait>>>>,
}

pub trait CharacterSpawnTemplateDataTrait: super::core::AssetTrait {
    fn customize_character_data(&self) -> &Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>>;
    fn customize_character_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>>;
    fn sensing(&self) -> &Option<Arc<Mutex<dyn GameSensingTemplateDataTrait>>>;
    fn sensing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GameSensingTemplateDataTrait>>>;
    fn behaviour(&self) -> &Option<Arc<Mutex<dyn GameBehaviourTemplateDataTrait>>>;
    fn behaviour_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GameBehaviourTemplateDataTrait>>>;
    fn animation_template(&self) -> &Option<Arc<Mutex<dyn AnimationSpawnTemplateTrait>>>;
    fn animation_template_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AnimationSpawnTemplateTrait>>>;
    fn voice_over_labels(&self) -> &Vec<Option<Arc<Mutex<dyn super::audio::VoiceOverLabelTrait>>>>;
    fn voice_over_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::audio::VoiceOverLabelTrait>>>>;
}

impl CharacterSpawnTemplateDataTrait for CharacterSpawnTemplateData {
    fn customize_character_data(&self) -> &Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>> {
        &self.customize_character_data
    }
    fn customize_character_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CustomizeCharacterDataTrait>>> {
        &mut self.customize_character_data
    }
    fn sensing(&self) -> &Option<Arc<Mutex<dyn GameSensingTemplateDataTrait>>> {
        &self.sensing
    }
    fn sensing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GameSensingTemplateDataTrait>>> {
        &mut self.sensing
    }
    fn behaviour(&self) -> &Option<Arc<Mutex<dyn GameBehaviourTemplateDataTrait>>> {
        &self.behaviour
    }
    fn behaviour_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GameBehaviourTemplateDataTrait>>> {
        &mut self.behaviour
    }
    fn animation_template(&self) -> &Option<Arc<Mutex<dyn AnimationSpawnTemplateTrait>>> {
        &self.animation_template
    }
    fn animation_template_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AnimationSpawnTemplateTrait>>> {
        &mut self.animation_template
    }
    fn voice_over_labels(&self) -> &Vec<Option<Arc<Mutex<dyn super::audio::VoiceOverLabelTrait>>>> {
        &self.voice_over_labels
    }
    fn voice_over_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::audio::VoiceOverLabelTrait>>>> {
        &mut self.voice_over_labels
    }
}

impl super::core::AssetTrait for CharacterSpawnTemplateData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CharacterSpawnTemplateData {
}

pub static CHARACTERSPAWNTEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSpawnTemplateData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CharacterSpawnTemplateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CustomizeCharacterData",
                flags: MemberInfoFlags::new(0),
                field_type: "CustomizeCharacterData",
                rust_offset: offset_of!(CharacterSpawnTemplateData, customize_character_data),
            },
            FieldInfoData {
                name: "Sensing",
                flags: MemberInfoFlags::new(0),
                field_type: "GameSensingTemplateData",
                rust_offset: offset_of!(CharacterSpawnTemplateData, sensing),
            },
            FieldInfoData {
                name: "Behaviour",
                flags: MemberInfoFlags::new(0),
                field_type: "GameBehaviourTemplateData",
                rust_offset: offset_of!(CharacterSpawnTemplateData, behaviour),
            },
            FieldInfoData {
                name: "AnimationTemplate",
                flags: MemberInfoFlags::new(0),
                field_type: "AnimationSpawnTemplate",
                rust_offset: offset_of!(CharacterSpawnTemplateData, animation_template),
            },
            FieldInfoData {
                name: "VoiceOverLabels",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabel-Array",
                rust_offset: offset_of!(CharacterSpawnTemplateData, voice_over_labels),
            },
        ],
    }),
    array_type: Some(CHARACTERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CharacterSpawnTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        CHARACTERSPAWNTEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARACTERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CharacterSpawnTemplateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CharacterSpawnTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AlternateSpawnEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub team: super::gameplay_sim::TeamId,
    pub priority: f32,
    pub enabled: bool,
}

pub trait AlternateSpawnEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn priority(&self) -> &f32;
    fn priority_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl AlternateSpawnEntityDataTrait for AlternateSpawnEntityData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn priority(&self) -> &f32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut f32 {
        &mut self.priority
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::SpatialEntityDataTrait for AlternateSpawnEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for AlternateSpawnEntityData {
}

impl super::entity::GameObjectDataTrait for AlternateSpawnEntityData {
}

impl super::core::DataBusPeerTrait for AlternateSpawnEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AlternateSpawnEntityData {
}

impl super::core::DataContainerTrait for AlternateSpawnEntityData {
}

pub static ALTERNATESPAWNENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlternateSpawnEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AlternateSpawnEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(AlternateSpawnEntityData, team),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AlternateSpawnEntityData, priority),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlternateSpawnEntityData, enabled),
            },
        ],
    }),
    array_type: Some(ALTERNATESPAWNENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AlternateSpawnEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ALTERNATESPAWNENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ALTERNATESPAWNENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlternateSpawnEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AlternateSpawnEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameBehaviourTemplateData {
    pub _glacier_base: super::core::Asset,
}

pub trait GameBehaviourTemplateDataTrait: super::core::AssetTrait {
}

impl GameBehaviourTemplateDataTrait for GameBehaviourTemplateData {
}

impl super::core::AssetTrait for GameBehaviourTemplateData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for GameBehaviourTemplateData {
}

pub static GAMEBEHAVIOURTEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameBehaviourTemplateData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameBehaviourTemplateData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMEBEHAVIOURTEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameBehaviourTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMEBEHAVIOURTEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMEBEHAVIOURTEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameBehaviourTemplateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameBehaviourTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameSensingTemplateData {
    pub _glacier_base: super::core::Asset,
}

pub trait GameSensingTemplateDataTrait: super::core::AssetTrait {
}

impl GameSensingTemplateDataTrait for GameSensingTemplateData {
}

impl super::core::AssetTrait for GameSensingTemplateData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for GameSensingTemplateData {
}

pub static GAMESENSINGTEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSensingTemplateData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameSensingTemplateData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(GAMESENSINGTEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameSensingTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMESENSINGTEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMESENSINGTEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameSensingTemplateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("GameSensingTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationSpawnTemplate {
    pub _glacier_base: super::core::DataContainer,
    pub run_style: Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>,
}

pub trait AnimationSpawnTemplateTrait: super::core::DataContainerTrait {
    fn run_style(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn run_style_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
}

impl AnimationSpawnTemplateTrait for AnimationSpawnTemplate {
    fn run_style(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &self.run_style
    }
    fn run_style_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &mut self.run_style
    }
}

impl super::core::DataContainerTrait for AnimationSpawnTemplate {
}

pub static ANIMATIONSPAWNTEMPLATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationSpawnTemplate",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationSpawnTemplate as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RunStyle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(AnimationSpawnTemplate, run_style),
            },
        ],
    }),
    array_type: Some(ANIMATIONSPAWNTEMPLATE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationSpawnTemplate {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONSPAWNTEMPLATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONSPAWNTEMPLATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationSpawnTemplate-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationSpawnTemplate"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpawnReferenceObjectData {
    pub _glacier_base: super::gameplay_sim::GameplaySpawnReferenceObjectData,
    pub team: super::gameplay_sim::TeamId,
    pub locked_team: bool,
    pub spawn_area_radius: f32,
    pub spawn_protection_radius: f32,
    pub spawn_protection_check_all_teams: bool,
    pub spawn_protection_friendly_killed_count: u32,
    pub spawn_protection_friendly_killed_time: f32,
    pub clear_bangers_on_spawn: bool,
    pub try_to_spawn_out_of_sight: bool,
    pub send_weapon_events: bool,
    pub take_control_on_transform_change: bool,
    pub return_control_on_idle: bool,
    pub take_control_entry_index: i32,
    pub rotation_yaw: f32,
    pub rotation_pitch: f32,
    pub rotation_roll: f32,
    pub throttle: f32,
    pub time_delta_type: super::entity::TimeDeltaType,
    pub max_unspawn_in_frame: i32,
}

pub trait SpawnReferenceObjectDataTrait: super::gameplay_sim::GameplaySpawnReferenceObjectDataTrait {
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn locked_team(&self) -> &bool;
    fn locked_team_mut(&mut self) -> &mut bool;
    fn spawn_area_radius(&self) -> &f32;
    fn spawn_area_radius_mut(&mut self) -> &mut f32;
    fn spawn_protection_radius(&self) -> &f32;
    fn spawn_protection_radius_mut(&mut self) -> &mut f32;
    fn spawn_protection_check_all_teams(&self) -> &bool;
    fn spawn_protection_check_all_teams_mut(&mut self) -> &mut bool;
    fn spawn_protection_friendly_killed_count(&self) -> &u32;
    fn spawn_protection_friendly_killed_count_mut(&mut self) -> &mut u32;
    fn spawn_protection_friendly_killed_time(&self) -> &f32;
    fn spawn_protection_friendly_killed_time_mut(&mut self) -> &mut f32;
    fn clear_bangers_on_spawn(&self) -> &bool;
    fn clear_bangers_on_spawn_mut(&mut self) -> &mut bool;
    fn try_to_spawn_out_of_sight(&self) -> &bool;
    fn try_to_spawn_out_of_sight_mut(&mut self) -> &mut bool;
    fn send_weapon_events(&self) -> &bool;
    fn send_weapon_events_mut(&mut self) -> &mut bool;
    fn take_control_on_transform_change(&self) -> &bool;
    fn take_control_on_transform_change_mut(&mut self) -> &mut bool;
    fn return_control_on_idle(&self) -> &bool;
    fn return_control_on_idle_mut(&mut self) -> &mut bool;
    fn take_control_entry_index(&self) -> &i32;
    fn take_control_entry_index_mut(&mut self) -> &mut i32;
    fn rotation_yaw(&self) -> &f32;
    fn rotation_yaw_mut(&mut self) -> &mut f32;
    fn rotation_pitch(&self) -> &f32;
    fn rotation_pitch_mut(&mut self) -> &mut f32;
    fn rotation_roll(&self) -> &f32;
    fn rotation_roll_mut(&mut self) -> &mut f32;
    fn throttle(&self) -> &f32;
    fn throttle_mut(&mut self) -> &mut f32;
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType;
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType;
    fn max_unspawn_in_frame(&self) -> &i32;
    fn max_unspawn_in_frame_mut(&mut self) -> &mut i32;
}

impl SpawnReferenceObjectDataTrait for SpawnReferenceObjectData {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn locked_team(&self) -> &bool {
        &self.locked_team
    }
    fn locked_team_mut(&mut self) -> &mut bool {
        &mut self.locked_team
    }
    fn spawn_area_radius(&self) -> &f32 {
        &self.spawn_area_radius
    }
    fn spawn_area_radius_mut(&mut self) -> &mut f32 {
        &mut self.spawn_area_radius
    }
    fn spawn_protection_radius(&self) -> &f32 {
        &self.spawn_protection_radius
    }
    fn spawn_protection_radius_mut(&mut self) -> &mut f32 {
        &mut self.spawn_protection_radius
    }
    fn spawn_protection_check_all_teams(&self) -> &bool {
        &self.spawn_protection_check_all_teams
    }
    fn spawn_protection_check_all_teams_mut(&mut self) -> &mut bool {
        &mut self.spawn_protection_check_all_teams
    }
    fn spawn_protection_friendly_killed_count(&self) -> &u32 {
        &self.spawn_protection_friendly_killed_count
    }
    fn spawn_protection_friendly_killed_count_mut(&mut self) -> &mut u32 {
        &mut self.spawn_protection_friendly_killed_count
    }
    fn spawn_protection_friendly_killed_time(&self) -> &f32 {
        &self.spawn_protection_friendly_killed_time
    }
    fn spawn_protection_friendly_killed_time_mut(&mut self) -> &mut f32 {
        &mut self.spawn_protection_friendly_killed_time
    }
    fn clear_bangers_on_spawn(&self) -> &bool {
        &self.clear_bangers_on_spawn
    }
    fn clear_bangers_on_spawn_mut(&mut self) -> &mut bool {
        &mut self.clear_bangers_on_spawn
    }
    fn try_to_spawn_out_of_sight(&self) -> &bool {
        &self.try_to_spawn_out_of_sight
    }
    fn try_to_spawn_out_of_sight_mut(&mut self) -> &mut bool {
        &mut self.try_to_spawn_out_of_sight
    }
    fn send_weapon_events(&self) -> &bool {
        &self.send_weapon_events
    }
    fn send_weapon_events_mut(&mut self) -> &mut bool {
        &mut self.send_weapon_events
    }
    fn take_control_on_transform_change(&self) -> &bool {
        &self.take_control_on_transform_change
    }
    fn take_control_on_transform_change_mut(&mut self) -> &mut bool {
        &mut self.take_control_on_transform_change
    }
    fn return_control_on_idle(&self) -> &bool {
        &self.return_control_on_idle
    }
    fn return_control_on_idle_mut(&mut self) -> &mut bool {
        &mut self.return_control_on_idle
    }
    fn take_control_entry_index(&self) -> &i32 {
        &self.take_control_entry_index
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        &mut self.take_control_entry_index
    }
    fn rotation_yaw(&self) -> &f32 {
        &self.rotation_yaw
    }
    fn rotation_yaw_mut(&mut self) -> &mut f32 {
        &mut self.rotation_yaw
    }
    fn rotation_pitch(&self) -> &f32 {
        &self.rotation_pitch
    }
    fn rotation_pitch_mut(&mut self) -> &mut f32 {
        &mut self.rotation_pitch
    }
    fn rotation_roll(&self) -> &f32 {
        &self.rotation_roll
    }
    fn rotation_roll_mut(&mut self) -> &mut f32 {
        &mut self.rotation_roll
    }
    fn throttle(&self) -> &f32 {
        &self.throttle
    }
    fn throttle_mut(&mut self) -> &mut f32 {
        &mut self.throttle
    }
    fn time_delta_type(&self) -> &super::entity::TimeDeltaType {
        &self.time_delta_type
    }
    fn time_delta_type_mut(&mut self) -> &mut super::entity::TimeDeltaType {
        &mut self.time_delta_type
    }
    fn max_unspawn_in_frame(&self) -> &i32 {
        &self.max_unspawn_in_frame
    }
    fn max_unspawn_in_frame_mut(&mut self) -> &mut i32 {
        &mut self.max_unspawn_in_frame
    }
}

impl super::gameplay_sim::GameplaySpawnReferenceObjectDataTrait for SpawnReferenceObjectData {
    fn extra_spawn_data(&self) -> &Vec<Option<Arc<Mutex<dyn super::gameplay_sim::ExtraSpawnDataTrait>>>> {
        self._glacier_base.extra_spawn_data()
    }
    fn extra_spawn_data_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::gameplay_sim::ExtraSpawnDataTrait>>>> {
        self._glacier_base.extra_spawn_data_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn location_name_sid(&self) -> &String {
        self._glacier_base.location_name_sid()
    }
    fn location_name_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_name_sid_mut()
    }
    fn location_text_sid(&self) -> &String {
        self._glacier_base.location_text_sid()
    }
    fn location_text_sid_mut(&mut self) -> &mut String {
        self._glacier_base.location_text_sid_mut()
    }
    fn initial_auto_spawn(&self) -> &bool {
        self._glacier_base.initial_auto_spawn()
    }
    fn initial_auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.initial_auto_spawn_mut()
    }
    fn auto_spawn(&self) -> &bool {
        self._glacier_base.auto_spawn()
    }
    fn auto_spawn_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_spawn_mut()
    }
    fn queue_spawn_event(&self) -> &bool {
        self._glacier_base.queue_spawn_event()
    }
    fn queue_spawn_event_mut(&mut self) -> &mut bool {
        self._glacier_base.queue_spawn_event_mut()
    }
    fn use_as_spawn_point(&self) -> &bool {
        self._glacier_base.use_as_spawn_point()
    }
    fn use_as_spawn_point_mut(&mut self) -> &mut bool {
        self._glacier_base.use_as_spawn_point_mut()
    }
    fn initial_spawn_delay(&self) -> &f32 {
        self._glacier_base.initial_spawn_delay()
    }
    fn initial_spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.initial_spawn_delay_mut()
    }
    fn spawn_delay(&self) -> &f32 {
        self._glacier_base.spawn_delay()
    }
    fn spawn_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.spawn_delay_mut()
    }
    fn max_count(&self) -> &i32 {
        self._glacier_base.max_count()
    }
    fn max_count_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_mut()
    }
    fn max_count_simultaneously(&self) -> &i32 {
        self._glacier_base.max_count_simultaneously()
    }
    fn max_count_simultaneously_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_count_simultaneously_mut()
    }
    fn total_count_simultaneously_of_type(&self) -> &i32 {
        self._glacier_base.total_count_simultaneously_of_type()
    }
    fn total_count_simultaneously_of_type_mut(&mut self) -> &mut i32 {
        self._glacier_base.total_count_simultaneously_of_type_mut()
    }
    fn max_spawn_in_frame(&self) -> &i32 {
        self._glacier_base.max_spawn_in_frame()
    }
    fn max_spawn_in_frame_mut(&mut self) -> &mut i32 {
        self._glacier_base.max_spawn_in_frame_mut()
    }
    fn only_send_event_for_human_players(&self) -> &bool {
        self._glacier_base.only_send_event_for_human_players()
    }
    fn only_send_event_for_human_players_mut(&mut self) -> &mut bool {
        self._glacier_base.only_send_event_for_human_players_mut()
    }
    fn controllable_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_transform()
    }
    fn controllable_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_transform_mut()
    }
    fn controllable_input(&self) -> &super::core::LinearTransform {
        self._glacier_base.controllable_input()
    }
    fn controllable_input_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.controllable_input_mut()
    }
}

impl super::entity::SpatialReferenceObjectDataTrait for SpawnReferenceObjectData {
    fn local_player_id(&self) -> &super::core::LocalPlayerId {
        self._glacier_base.local_player_id()
    }
    fn local_player_id_mut(&mut self) -> &mut super::core::LocalPlayerId {
        self._glacier_base.local_player_id_mut()
    }
}

impl super::entity::ReferenceObjectDataTrait for SpawnReferenceObjectData {
    fn blueprint_transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.blueprint_transform()
    }
    fn blueprint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.blueprint_transform_mut()
    }
    fn blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint()
    }
    fn blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::BlueprintTrait>>> {
        self._glacier_base.blueprint_mut()
    }
    fn object_variation(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation()
    }
    fn object_variation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectVariationTrait>>> {
        self._glacier_base.object_variation_mut()
    }
    fn stream_realm(&self) -> &super::entity::StreamRealm {
        self._glacier_base.stream_realm()
    }
    fn stream_realm_mut(&mut self) -> &mut super::entity::StreamRealm {
        self._glacier_base.stream_realm_mut()
    }
    fn radiosity_type_override(&self) -> &super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override()
    }
    fn radiosity_type_override_mut(&mut self) -> &mut super::core::RadiosityTypeOverride {
        self._glacier_base.radiosity_type_override_mut()
    }
    fn lightmap_resolution_scale(&self) -> &u32 {
        self._glacier_base.lightmap_resolution_scale()
    }
    fn lightmap_resolution_scale_mut(&mut self) -> &mut u32 {
        self._glacier_base.lightmap_resolution_scale_mut()
    }
    fn lightmap_scale_with_size(&self) -> &bool {
        self._glacier_base.lightmap_scale_with_size()
    }
    fn lightmap_scale_with_size_mut(&mut self) -> &mut bool {
        self._glacier_base.lightmap_scale_with_size_mut()
    }
    fn rendering_overrides(&self) -> &super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides()
    }
    fn rendering_overrides_mut(&mut self) -> &mut super::core::RenderingOverrides {
        self._glacier_base.rendering_overrides_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
    fn create_indestructible_entity(&self) -> &bool {
        self._glacier_base.create_indestructible_entity()
    }
    fn create_indestructible_entity_mut(&mut self) -> &mut bool {
        self._glacier_base.create_indestructible_entity_mut()
    }
}

impl super::entity::GameObjectDataTrait for SpawnReferenceObjectData {
}

impl super::core::DataBusPeerTrait for SpawnReferenceObjectData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpawnReferenceObjectData {
}

impl super::core::DataContainerTrait for SpawnReferenceObjectData {
}

pub static SPAWNREFERENCEOBJECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpawnReferenceObjectData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPLAYSPAWNREFERENCEOBJECTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpawnReferenceObjectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(SpawnReferenceObjectData, team),
            },
            FieldInfoData {
                name: "LockedTeam",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, locked_team),
            },
            FieldInfoData {
                name: "SpawnAreaRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_area_radius),
            },
            FieldInfoData {
                name: "SpawnProtectionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_protection_radius),
            },
            FieldInfoData {
                name: "SpawnProtectionCheckAllTeams",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_protection_check_all_teams),
            },
            FieldInfoData {
                name: "SpawnProtectionFriendlyKilledCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_protection_friendly_killed_count),
            },
            FieldInfoData {
                name: "SpawnProtectionFriendlyKilledTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, spawn_protection_friendly_killed_time),
            },
            FieldInfoData {
                name: "ClearBangersOnSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, clear_bangers_on_spawn),
            },
            FieldInfoData {
                name: "TryToSpawnOutOfSight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, try_to_spawn_out_of_sight),
            },
            FieldInfoData {
                name: "SendWeaponEvents",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, send_weapon_events),
            },
            FieldInfoData {
                name: "TakeControlOnTransformChange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, take_control_on_transform_change),
            },
            FieldInfoData {
                name: "ReturnControlOnIdle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpawnReferenceObjectData, return_control_on_idle),
            },
            FieldInfoData {
                name: "TakeControlEntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SpawnReferenceObjectData, take_control_entry_index),
            },
            FieldInfoData {
                name: "RotationYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, rotation_yaw),
            },
            FieldInfoData {
                name: "RotationPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, rotation_pitch),
            },
            FieldInfoData {
                name: "RotationRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, rotation_roll),
            },
            FieldInfoData {
                name: "Throttle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpawnReferenceObjectData, throttle),
            },
            FieldInfoData {
                name: "TimeDeltaType",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeDeltaType",
                rust_offset: offset_of!(SpawnReferenceObjectData, time_delta_type),
            },
            FieldInfoData {
                name: "MaxUnspawnInFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SpawnReferenceObjectData, max_unspawn_in_frame),
            },
        ],
    }),
    array_type: Some(SPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpawnReferenceObjectData {
    fn type_info(&self) -> &'static TypeInfo {
        SPAWNREFERENCEOBJECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPAWNREFERENCEOBJECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpawnReferenceObjectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SpawnReferenceObjectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EntryEnterRestriction {
    #[default]
    EntryEnterRestriction_NoRestriction = 0,
    EntryEnterRestriction_OnlyPrimaryEntry = 1,
}

pub static ENTRYENTERRESTRICTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryEnterRestriction",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(ENTRYENTERRESTRICTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EntryEnterRestriction {
    fn type_info(&self) -> &'static TypeInfo {
        ENTRYENTERRESTRICTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENTRYENTERRESTRICTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntryEnterRestriction-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EntryEnterRestriction"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PlayerSpawnType {
    #[default]
    PlayerSpawnType_HumanPlayer = 0,
    PlayerSpawnType_AiPlayer = 1,
    PlayerSpawnType_Actor = 2,
    PlayerSpawnType_BrainAI = 3,
    PlayerSpawnType_Ai2Player = 300,
}

pub static PLAYERSPAWNTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerSpawnType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(PLAYERSPAWNTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PlayerSpawnType {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERSPAWNTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PLAYERSPAWNTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerSpawnType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("PlayerSpawnType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SlowMotionEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub time_scale: f32,
    pub scale_down_transition_time: f32,
    pub scale_up_transition_time: f32,
}

pub trait SlowMotionEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn time_scale(&self) -> &f32;
    fn time_scale_mut(&mut self) -> &mut f32;
    fn scale_down_transition_time(&self) -> &f32;
    fn scale_down_transition_time_mut(&mut self) -> &mut f32;
    fn scale_up_transition_time(&self) -> &f32;
    fn scale_up_transition_time_mut(&mut self) -> &mut f32;
}

impl SlowMotionEntityDataTrait for SlowMotionEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn time_scale(&self) -> &f32 {
        &self.time_scale
    }
    fn time_scale_mut(&mut self) -> &mut f32 {
        &mut self.time_scale
    }
    fn scale_down_transition_time(&self) -> &f32 {
        &self.scale_down_transition_time
    }
    fn scale_down_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.scale_down_transition_time
    }
    fn scale_up_transition_time(&self) -> &f32 {
        &self.scale_up_transition_time
    }
    fn scale_up_transition_time_mut(&mut self) -> &mut f32 {
        &mut self.scale_up_transition_time
    }
}

impl super::entity::EntityDataTrait for SlowMotionEntityData {
}

impl super::entity::GameObjectDataTrait for SlowMotionEntityData {
}

impl super::core::DataBusPeerTrait for SlowMotionEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SlowMotionEntityData {
}

impl super::core::DataContainerTrait for SlowMotionEntityData {
}

pub static SLOWMOTIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SlowMotionEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SlowMotionEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SlowMotionEntityData, realm),
            },
            FieldInfoData {
                name: "TimeScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SlowMotionEntityData, time_scale),
            },
            FieldInfoData {
                name: "ScaleDownTransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SlowMotionEntityData, scale_down_transition_time),
            },
            FieldInfoData {
                name: "ScaleUpTransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SlowMotionEntityData, scale_up_transition_time),
            },
        ],
    }),
    array_type: Some(SLOWMOTIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SlowMotionEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SLOWMOTIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SLOWMOTIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SlowMotionEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SlowMotionEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CollisionNetState {
    pub position: super::core::Vec3,
    pub normal: super::core::Vec3,
    pub material: super::entity::MaterialDecl,
    pub own_material: super::entity::MaterialDecl,
    pub speed: f32,
    pub time: f32,
}

pub trait CollisionNetStateTrait: TypeObject {
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
    fn normal(&self) -> &super::core::Vec3;
    fn normal_mut(&mut self) -> &mut super::core::Vec3;
    fn material(&self) -> &super::entity::MaterialDecl;
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn own_material(&self) -> &super::entity::MaterialDecl;
    fn own_material_mut(&mut self) -> &mut super::entity::MaterialDecl;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
}

impl CollisionNetStateTrait for CollisionNetState {
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
    fn normal(&self) -> &super::core::Vec3 {
        &self.normal
    }
    fn normal_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.normal
    }
    fn material(&self) -> &super::entity::MaterialDecl {
        &self.material
    }
    fn material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.material
    }
    fn own_material(&self) -> &super::entity::MaterialDecl {
        &self.own_material
    }
    fn own_material_mut(&mut self) -> &mut super::entity::MaterialDecl {
        &mut self.own_material
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
}

pub static COLLISIONNETSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionNetState",
    flags: MemberInfoFlags::new(32841),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CollisionNetState as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CollisionNetState, position),
            },
            FieldInfoData {
                name: "Normal",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CollisionNetState, normal),
            },
            FieldInfoData {
                name: "Material",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(CollisionNetState, material),
            },
            FieldInfoData {
                name: "OwnMaterial",
                flags: MemberInfoFlags::new(0),
                field_type: "MaterialDecl",
                rust_offset: offset_of!(CollisionNetState, own_material),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionNetState, speed),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionNetState, time),
            },
        ],
    }),
    array_type: Some(COLLISIONNETSTATE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CollisionNetState {
    fn type_info(&self) -> &'static TypeInfo {
        COLLISIONNETSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COLLISIONNETSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionNetState-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CollisionNetState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ServerSettings {
    pub _glacier_base: super::core::SystemSettings,
    pub instance_path: String,
    pub remote_control_port: u32,
    pub query_provider_enabled: bool,
    pub max_queries_per_second: u32,
    pub debris_cluster_enabled: bool,
    pub vegetation_enabled: bool,
    pub water_physics_enabled: bool,
    pub is_deserting_allowed: bool,
    pub is_render_damage_events: bool,
    pub respawn_on_death_position: bool,
    pub is_stats_enabled: bool,
    pub is_network_stats_enabled: bool,
    pub is_ai_enabled: bool,
    pub is_destruction_enabled: bool,
    pub is_soldier_animation_enabled: bool,
    pub is_soldier_detailed_collision_enabled: bool,
    pub load_save_point: bool,
    pub save_point: String,
    pub disable_cutscenes: bool,
    pub havok_visual_debugger: bool,
    pub havok_capture_to_file: bool,
    pub show_trigger_debug_text: bool,
    pub timeout_game: bool,
    pub timeout_time: f32,
    pub player_count_needed_for_multiplayer: u32,
    pub a_i_looks_into_camera: bool,
    pub debug_menu_click: String,
    pub deathmatch_debug_info: bool,
    pub vehicle_interaction_ignores_see_through: bool,
    pub congestion_ctrl: CongestionControlSettings,
    pub job_enable: bool,
    pub threading_enable: bool,
    pub draw_active_physics_objects: bool,
    pub is_ranked: bool,
    pub unlock_resolver: bool,
    pub scoring_log_enabled: bool,
    pub instant_update_enabled: bool,
    pub loading_timeout: f32,
    pub ingame_timeout: f32,
    pub outgoing_frequency: f32,
    pub incoming_frequency: f32,
    pub incoming_rate: u32,
    pub outgoing_rate: u32,
    pub playlist: String,
    pub force_playlist: bool,
    pub dedicated_server_cpu: i32,
    pub auto_unspawn_bangers: bool,
    pub regulated_a_i_throttle: bool,
    pub enable_animation_culling: bool,
    pub fall_back_to_squad_spawn: bool,
    pub save_game_version: u32,
    pub save_game_use_profile_saves: bool,
    pub server_name: String,
    pub server_password: String,
    pub vehicle_spawn_allowed: bool,
    pub vehicle_spawn_delay_modifier: f32,
    pub human_health_multiplier: f32,
    pub respawn_time_modifier: f32,
    pub administration_enabled: bool,
    pub administration_log_enabled: bool,
    pub administration_time_stamp_log_names: bool,
    pub administration_events_enabled: bool,
    pub administration_server_name_restricted: bool,
    pub administration_password: String,
    pub remote_administration_port: String,
    pub extended_juice_logging_enabled: bool,
}

pub trait ServerSettingsTrait: super::core::SystemSettingsTrait {
    fn instance_path(&self) -> &String;
    fn instance_path_mut(&mut self) -> &mut String;
    fn remote_control_port(&self) -> &u32;
    fn remote_control_port_mut(&mut self) -> &mut u32;
    fn query_provider_enabled(&self) -> &bool;
    fn query_provider_enabled_mut(&mut self) -> &mut bool;
    fn max_queries_per_second(&self) -> &u32;
    fn max_queries_per_second_mut(&mut self) -> &mut u32;
    fn debris_cluster_enabled(&self) -> &bool;
    fn debris_cluster_enabled_mut(&mut self) -> &mut bool;
    fn vegetation_enabled(&self) -> &bool;
    fn vegetation_enabled_mut(&mut self) -> &mut bool;
    fn water_physics_enabled(&self) -> &bool;
    fn water_physics_enabled_mut(&mut self) -> &mut bool;
    fn is_deserting_allowed(&self) -> &bool;
    fn is_deserting_allowed_mut(&mut self) -> &mut bool;
    fn is_render_damage_events(&self) -> &bool;
    fn is_render_damage_events_mut(&mut self) -> &mut bool;
    fn respawn_on_death_position(&self) -> &bool;
    fn respawn_on_death_position_mut(&mut self) -> &mut bool;
    fn is_stats_enabled(&self) -> &bool;
    fn is_stats_enabled_mut(&mut self) -> &mut bool;
    fn is_network_stats_enabled(&self) -> &bool;
    fn is_network_stats_enabled_mut(&mut self) -> &mut bool;
    fn is_ai_enabled(&self) -> &bool;
    fn is_ai_enabled_mut(&mut self) -> &mut bool;
    fn is_destruction_enabled(&self) -> &bool;
    fn is_destruction_enabled_mut(&mut self) -> &mut bool;
    fn is_soldier_animation_enabled(&self) -> &bool;
    fn is_soldier_animation_enabled_mut(&mut self) -> &mut bool;
    fn is_soldier_detailed_collision_enabled(&self) -> &bool;
    fn is_soldier_detailed_collision_enabled_mut(&mut self) -> &mut bool;
    fn load_save_point(&self) -> &bool;
    fn load_save_point_mut(&mut self) -> &mut bool;
    fn save_point(&self) -> &String;
    fn save_point_mut(&mut self) -> &mut String;
    fn disable_cutscenes(&self) -> &bool;
    fn disable_cutscenes_mut(&mut self) -> &mut bool;
    fn havok_visual_debugger(&self) -> &bool;
    fn havok_visual_debugger_mut(&mut self) -> &mut bool;
    fn havok_capture_to_file(&self) -> &bool;
    fn havok_capture_to_file_mut(&mut self) -> &mut bool;
    fn show_trigger_debug_text(&self) -> &bool;
    fn show_trigger_debug_text_mut(&mut self) -> &mut bool;
    fn timeout_game(&self) -> &bool;
    fn timeout_game_mut(&mut self) -> &mut bool;
    fn timeout_time(&self) -> &f32;
    fn timeout_time_mut(&mut self) -> &mut f32;
    fn player_count_needed_for_multiplayer(&self) -> &u32;
    fn player_count_needed_for_multiplayer_mut(&mut self) -> &mut u32;
    fn a_i_looks_into_camera(&self) -> &bool;
    fn a_i_looks_into_camera_mut(&mut self) -> &mut bool;
    fn debug_menu_click(&self) -> &String;
    fn debug_menu_click_mut(&mut self) -> &mut String;
    fn deathmatch_debug_info(&self) -> &bool;
    fn deathmatch_debug_info_mut(&mut self) -> &mut bool;
    fn vehicle_interaction_ignores_see_through(&self) -> &bool;
    fn vehicle_interaction_ignores_see_through_mut(&mut self) -> &mut bool;
    fn congestion_ctrl(&self) -> &CongestionControlSettings;
    fn congestion_ctrl_mut(&mut self) -> &mut CongestionControlSettings;
    fn job_enable(&self) -> &bool;
    fn job_enable_mut(&mut self) -> &mut bool;
    fn threading_enable(&self) -> &bool;
    fn threading_enable_mut(&mut self) -> &mut bool;
    fn draw_active_physics_objects(&self) -> &bool;
    fn draw_active_physics_objects_mut(&mut self) -> &mut bool;
    fn is_ranked(&self) -> &bool;
    fn is_ranked_mut(&mut self) -> &mut bool;
    fn unlock_resolver(&self) -> &bool;
    fn unlock_resolver_mut(&mut self) -> &mut bool;
    fn scoring_log_enabled(&self) -> &bool;
    fn scoring_log_enabled_mut(&mut self) -> &mut bool;
    fn instant_update_enabled(&self) -> &bool;
    fn instant_update_enabled_mut(&mut self) -> &mut bool;
    fn loading_timeout(&self) -> &f32;
    fn loading_timeout_mut(&mut self) -> &mut f32;
    fn ingame_timeout(&self) -> &f32;
    fn ingame_timeout_mut(&mut self) -> &mut f32;
    fn outgoing_frequency(&self) -> &f32;
    fn outgoing_frequency_mut(&mut self) -> &mut f32;
    fn incoming_frequency(&self) -> &f32;
    fn incoming_frequency_mut(&mut self) -> &mut f32;
    fn incoming_rate(&self) -> &u32;
    fn incoming_rate_mut(&mut self) -> &mut u32;
    fn outgoing_rate(&self) -> &u32;
    fn outgoing_rate_mut(&mut self) -> &mut u32;
    fn playlist(&self) -> &String;
    fn playlist_mut(&mut self) -> &mut String;
    fn force_playlist(&self) -> &bool;
    fn force_playlist_mut(&mut self) -> &mut bool;
    fn dedicated_server_cpu(&self) -> &i32;
    fn dedicated_server_cpu_mut(&mut self) -> &mut i32;
    fn auto_unspawn_bangers(&self) -> &bool;
    fn auto_unspawn_bangers_mut(&mut self) -> &mut bool;
    fn regulated_a_i_throttle(&self) -> &bool;
    fn regulated_a_i_throttle_mut(&mut self) -> &mut bool;
    fn enable_animation_culling(&self) -> &bool;
    fn enable_animation_culling_mut(&mut self) -> &mut bool;
    fn fall_back_to_squad_spawn(&self) -> &bool;
    fn fall_back_to_squad_spawn_mut(&mut self) -> &mut bool;
    fn save_game_version(&self) -> &u32;
    fn save_game_version_mut(&mut self) -> &mut u32;
    fn save_game_use_profile_saves(&self) -> &bool;
    fn save_game_use_profile_saves_mut(&mut self) -> &mut bool;
    fn server_name(&self) -> &String;
    fn server_name_mut(&mut self) -> &mut String;
    fn server_password(&self) -> &String;
    fn server_password_mut(&mut self) -> &mut String;
    fn vehicle_spawn_allowed(&self) -> &bool;
    fn vehicle_spawn_allowed_mut(&mut self) -> &mut bool;
    fn vehicle_spawn_delay_modifier(&self) -> &f32;
    fn vehicle_spawn_delay_modifier_mut(&mut self) -> &mut f32;
    fn human_health_multiplier(&self) -> &f32;
    fn human_health_multiplier_mut(&mut self) -> &mut f32;
    fn respawn_time_modifier(&self) -> &f32;
    fn respawn_time_modifier_mut(&mut self) -> &mut f32;
    fn administration_enabled(&self) -> &bool;
    fn administration_enabled_mut(&mut self) -> &mut bool;
    fn administration_log_enabled(&self) -> &bool;
    fn administration_log_enabled_mut(&mut self) -> &mut bool;
    fn administration_time_stamp_log_names(&self) -> &bool;
    fn administration_time_stamp_log_names_mut(&mut self) -> &mut bool;
    fn administration_events_enabled(&self) -> &bool;
    fn administration_events_enabled_mut(&mut self) -> &mut bool;
    fn administration_server_name_restricted(&self) -> &bool;
    fn administration_server_name_restricted_mut(&mut self) -> &mut bool;
    fn administration_password(&self) -> &String;
    fn administration_password_mut(&mut self) -> &mut String;
    fn remote_administration_port(&self) -> &String;
    fn remote_administration_port_mut(&mut self) -> &mut String;
    fn extended_juice_logging_enabled(&self) -> &bool;
    fn extended_juice_logging_enabled_mut(&mut self) -> &mut bool;
}

impl ServerSettingsTrait for ServerSettings {
    fn instance_path(&self) -> &String {
        &self.instance_path
    }
    fn instance_path_mut(&mut self) -> &mut String {
        &mut self.instance_path
    }
    fn remote_control_port(&self) -> &u32 {
        &self.remote_control_port
    }
    fn remote_control_port_mut(&mut self) -> &mut u32 {
        &mut self.remote_control_port
    }
    fn query_provider_enabled(&self) -> &bool {
        &self.query_provider_enabled
    }
    fn query_provider_enabled_mut(&mut self) -> &mut bool {
        &mut self.query_provider_enabled
    }
    fn max_queries_per_second(&self) -> &u32 {
        &self.max_queries_per_second
    }
    fn max_queries_per_second_mut(&mut self) -> &mut u32 {
        &mut self.max_queries_per_second
    }
    fn debris_cluster_enabled(&self) -> &bool {
        &self.debris_cluster_enabled
    }
    fn debris_cluster_enabled_mut(&mut self) -> &mut bool {
        &mut self.debris_cluster_enabled
    }
    fn vegetation_enabled(&self) -> &bool {
        &self.vegetation_enabled
    }
    fn vegetation_enabled_mut(&mut self) -> &mut bool {
        &mut self.vegetation_enabled
    }
    fn water_physics_enabled(&self) -> &bool {
        &self.water_physics_enabled
    }
    fn water_physics_enabled_mut(&mut self) -> &mut bool {
        &mut self.water_physics_enabled
    }
    fn is_deserting_allowed(&self) -> &bool {
        &self.is_deserting_allowed
    }
    fn is_deserting_allowed_mut(&mut self) -> &mut bool {
        &mut self.is_deserting_allowed
    }
    fn is_render_damage_events(&self) -> &bool {
        &self.is_render_damage_events
    }
    fn is_render_damage_events_mut(&mut self) -> &mut bool {
        &mut self.is_render_damage_events
    }
    fn respawn_on_death_position(&self) -> &bool {
        &self.respawn_on_death_position
    }
    fn respawn_on_death_position_mut(&mut self) -> &mut bool {
        &mut self.respawn_on_death_position
    }
    fn is_stats_enabled(&self) -> &bool {
        &self.is_stats_enabled
    }
    fn is_stats_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_stats_enabled
    }
    fn is_network_stats_enabled(&self) -> &bool {
        &self.is_network_stats_enabled
    }
    fn is_network_stats_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_network_stats_enabled
    }
    fn is_ai_enabled(&self) -> &bool {
        &self.is_ai_enabled
    }
    fn is_ai_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_ai_enabled
    }
    fn is_destruction_enabled(&self) -> &bool {
        &self.is_destruction_enabled
    }
    fn is_destruction_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_destruction_enabled
    }
    fn is_soldier_animation_enabled(&self) -> &bool {
        &self.is_soldier_animation_enabled
    }
    fn is_soldier_animation_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_soldier_animation_enabled
    }
    fn is_soldier_detailed_collision_enabled(&self) -> &bool {
        &self.is_soldier_detailed_collision_enabled
    }
    fn is_soldier_detailed_collision_enabled_mut(&mut self) -> &mut bool {
        &mut self.is_soldier_detailed_collision_enabled
    }
    fn load_save_point(&self) -> &bool {
        &self.load_save_point
    }
    fn load_save_point_mut(&mut self) -> &mut bool {
        &mut self.load_save_point
    }
    fn save_point(&self) -> &String {
        &self.save_point
    }
    fn save_point_mut(&mut self) -> &mut String {
        &mut self.save_point
    }
    fn disable_cutscenes(&self) -> &bool {
        &self.disable_cutscenes
    }
    fn disable_cutscenes_mut(&mut self) -> &mut bool {
        &mut self.disable_cutscenes
    }
    fn havok_visual_debugger(&self) -> &bool {
        &self.havok_visual_debugger
    }
    fn havok_visual_debugger_mut(&mut self) -> &mut bool {
        &mut self.havok_visual_debugger
    }
    fn havok_capture_to_file(&self) -> &bool {
        &self.havok_capture_to_file
    }
    fn havok_capture_to_file_mut(&mut self) -> &mut bool {
        &mut self.havok_capture_to_file
    }
    fn show_trigger_debug_text(&self) -> &bool {
        &self.show_trigger_debug_text
    }
    fn show_trigger_debug_text_mut(&mut self) -> &mut bool {
        &mut self.show_trigger_debug_text
    }
    fn timeout_game(&self) -> &bool {
        &self.timeout_game
    }
    fn timeout_game_mut(&mut self) -> &mut bool {
        &mut self.timeout_game
    }
    fn timeout_time(&self) -> &f32 {
        &self.timeout_time
    }
    fn timeout_time_mut(&mut self) -> &mut f32 {
        &mut self.timeout_time
    }
    fn player_count_needed_for_multiplayer(&self) -> &u32 {
        &self.player_count_needed_for_multiplayer
    }
    fn player_count_needed_for_multiplayer_mut(&mut self) -> &mut u32 {
        &mut self.player_count_needed_for_multiplayer
    }
    fn a_i_looks_into_camera(&self) -> &bool {
        &self.a_i_looks_into_camera
    }
    fn a_i_looks_into_camera_mut(&mut self) -> &mut bool {
        &mut self.a_i_looks_into_camera
    }
    fn debug_menu_click(&self) -> &String {
        &self.debug_menu_click
    }
    fn debug_menu_click_mut(&mut self) -> &mut String {
        &mut self.debug_menu_click
    }
    fn deathmatch_debug_info(&self) -> &bool {
        &self.deathmatch_debug_info
    }
    fn deathmatch_debug_info_mut(&mut self) -> &mut bool {
        &mut self.deathmatch_debug_info
    }
    fn vehicle_interaction_ignores_see_through(&self) -> &bool {
        &self.vehicle_interaction_ignores_see_through
    }
    fn vehicle_interaction_ignores_see_through_mut(&mut self) -> &mut bool {
        &mut self.vehicle_interaction_ignores_see_through
    }
    fn congestion_ctrl(&self) -> &CongestionControlSettings {
        &self.congestion_ctrl
    }
    fn congestion_ctrl_mut(&mut self) -> &mut CongestionControlSettings {
        &mut self.congestion_ctrl
    }
    fn job_enable(&self) -> &bool {
        &self.job_enable
    }
    fn job_enable_mut(&mut self) -> &mut bool {
        &mut self.job_enable
    }
    fn threading_enable(&self) -> &bool {
        &self.threading_enable
    }
    fn threading_enable_mut(&mut self) -> &mut bool {
        &mut self.threading_enable
    }
    fn draw_active_physics_objects(&self) -> &bool {
        &self.draw_active_physics_objects
    }
    fn draw_active_physics_objects_mut(&mut self) -> &mut bool {
        &mut self.draw_active_physics_objects
    }
    fn is_ranked(&self) -> &bool {
        &self.is_ranked
    }
    fn is_ranked_mut(&mut self) -> &mut bool {
        &mut self.is_ranked
    }
    fn unlock_resolver(&self) -> &bool {
        &self.unlock_resolver
    }
    fn unlock_resolver_mut(&mut self) -> &mut bool {
        &mut self.unlock_resolver
    }
    fn scoring_log_enabled(&self) -> &bool {
        &self.scoring_log_enabled
    }
    fn scoring_log_enabled_mut(&mut self) -> &mut bool {
        &mut self.scoring_log_enabled
    }
    fn instant_update_enabled(&self) -> &bool {
        &self.instant_update_enabled
    }
    fn instant_update_enabled_mut(&mut self) -> &mut bool {
        &mut self.instant_update_enabled
    }
    fn loading_timeout(&self) -> &f32 {
        &self.loading_timeout
    }
    fn loading_timeout_mut(&mut self) -> &mut f32 {
        &mut self.loading_timeout
    }
    fn ingame_timeout(&self) -> &f32 {
        &self.ingame_timeout
    }
    fn ingame_timeout_mut(&mut self) -> &mut f32 {
        &mut self.ingame_timeout
    }
    fn outgoing_frequency(&self) -> &f32 {
        &self.outgoing_frequency
    }
    fn outgoing_frequency_mut(&mut self) -> &mut f32 {
        &mut self.outgoing_frequency
    }
    fn incoming_frequency(&self) -> &f32 {
        &self.incoming_frequency
    }
    fn incoming_frequency_mut(&mut self) -> &mut f32 {
        &mut self.incoming_frequency
    }
    fn incoming_rate(&self) -> &u32 {
        &self.incoming_rate
    }
    fn incoming_rate_mut(&mut self) -> &mut u32 {
        &mut self.incoming_rate
    }
    fn outgoing_rate(&self) -> &u32 {
        &self.outgoing_rate
    }
    fn outgoing_rate_mut(&mut self) -> &mut u32 {
        &mut self.outgoing_rate
    }
    fn playlist(&self) -> &String {
        &self.playlist
    }
    fn playlist_mut(&mut self) -> &mut String {
        &mut self.playlist
    }
    fn force_playlist(&self) -> &bool {
        &self.force_playlist
    }
    fn force_playlist_mut(&mut self) -> &mut bool {
        &mut self.force_playlist
    }
    fn dedicated_server_cpu(&self) -> &i32 {
        &self.dedicated_server_cpu
    }
    fn dedicated_server_cpu_mut(&mut self) -> &mut i32 {
        &mut self.dedicated_server_cpu
    }
    fn auto_unspawn_bangers(&self) -> &bool {
        &self.auto_unspawn_bangers
    }
    fn auto_unspawn_bangers_mut(&mut self) -> &mut bool {
        &mut self.auto_unspawn_bangers
    }
    fn regulated_a_i_throttle(&self) -> &bool {
        &self.regulated_a_i_throttle
    }
    fn regulated_a_i_throttle_mut(&mut self) -> &mut bool {
        &mut self.regulated_a_i_throttle
    }
    fn enable_animation_culling(&self) -> &bool {
        &self.enable_animation_culling
    }
    fn enable_animation_culling_mut(&mut self) -> &mut bool {
        &mut self.enable_animation_culling
    }
    fn fall_back_to_squad_spawn(&self) -> &bool {
        &self.fall_back_to_squad_spawn
    }
    fn fall_back_to_squad_spawn_mut(&mut self) -> &mut bool {
        &mut self.fall_back_to_squad_spawn
    }
    fn save_game_version(&self) -> &u32 {
        &self.save_game_version
    }
    fn save_game_version_mut(&mut self) -> &mut u32 {
        &mut self.save_game_version
    }
    fn save_game_use_profile_saves(&self) -> &bool {
        &self.save_game_use_profile_saves
    }
    fn save_game_use_profile_saves_mut(&mut self) -> &mut bool {
        &mut self.save_game_use_profile_saves
    }
    fn server_name(&self) -> &String {
        &self.server_name
    }
    fn server_name_mut(&mut self) -> &mut String {
        &mut self.server_name
    }
    fn server_password(&self) -> &String {
        &self.server_password
    }
    fn server_password_mut(&mut self) -> &mut String {
        &mut self.server_password
    }
    fn vehicle_spawn_allowed(&self) -> &bool {
        &self.vehicle_spawn_allowed
    }
    fn vehicle_spawn_allowed_mut(&mut self) -> &mut bool {
        &mut self.vehicle_spawn_allowed
    }
    fn vehicle_spawn_delay_modifier(&self) -> &f32 {
        &self.vehicle_spawn_delay_modifier
    }
    fn vehicle_spawn_delay_modifier_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_spawn_delay_modifier
    }
    fn human_health_multiplier(&self) -> &f32 {
        &self.human_health_multiplier
    }
    fn human_health_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.human_health_multiplier
    }
    fn respawn_time_modifier(&self) -> &f32 {
        &self.respawn_time_modifier
    }
    fn respawn_time_modifier_mut(&mut self) -> &mut f32 {
        &mut self.respawn_time_modifier
    }
    fn administration_enabled(&self) -> &bool {
        &self.administration_enabled
    }
    fn administration_enabled_mut(&mut self) -> &mut bool {
        &mut self.administration_enabled
    }
    fn administration_log_enabled(&self) -> &bool {
        &self.administration_log_enabled
    }
    fn administration_log_enabled_mut(&mut self) -> &mut bool {
        &mut self.administration_log_enabled
    }
    fn administration_time_stamp_log_names(&self) -> &bool {
        &self.administration_time_stamp_log_names
    }
    fn administration_time_stamp_log_names_mut(&mut self) -> &mut bool {
        &mut self.administration_time_stamp_log_names
    }
    fn administration_events_enabled(&self) -> &bool {
        &self.administration_events_enabled
    }
    fn administration_events_enabled_mut(&mut self) -> &mut bool {
        &mut self.administration_events_enabled
    }
    fn administration_server_name_restricted(&self) -> &bool {
        &self.administration_server_name_restricted
    }
    fn administration_server_name_restricted_mut(&mut self) -> &mut bool {
        &mut self.administration_server_name_restricted
    }
    fn administration_password(&self) -> &String {
        &self.administration_password
    }
    fn administration_password_mut(&mut self) -> &mut String {
        &mut self.administration_password
    }
    fn remote_administration_port(&self) -> &String {
        &self.remote_administration_port
    }
    fn remote_administration_port_mut(&mut self) -> &mut String {
        &mut self.remote_administration_port
    }
    fn extended_juice_logging_enabled(&self) -> &bool {
        &self.extended_juice_logging_enabled
    }
    fn extended_juice_logging_enabled_mut(&mut self) -> &mut bool {
        &mut self.extended_juice_logging_enabled
    }
}

impl super::core::SystemSettingsTrait for ServerSettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        self._glacier_base.platform_mut()
    }
}

impl super::core::DataContainerTrait for ServerSettings {
}

pub static SERVERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerSettings",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InstancePath",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, instance_path),
            },
            FieldInfoData {
                name: "RemoteControlPort",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, remote_control_port),
            },
            FieldInfoData {
                name: "QueryProviderEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, query_provider_enabled),
            },
            FieldInfoData {
                name: "MaxQueriesPerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, max_queries_per_second),
            },
            FieldInfoData {
                name: "DebrisClusterEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, debris_cluster_enabled),
            },
            FieldInfoData {
                name: "VegetationEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, vegetation_enabled),
            },
            FieldInfoData {
                name: "WaterPhysicsEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, water_physics_enabled),
            },
            FieldInfoData {
                name: "IsDesertingAllowed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_deserting_allowed),
            },
            FieldInfoData {
                name: "IsRenderDamageEvents",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_render_damage_events),
            },
            FieldInfoData {
                name: "RespawnOnDeathPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, respawn_on_death_position),
            },
            FieldInfoData {
                name: "IsStatsEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_stats_enabled),
            },
            FieldInfoData {
                name: "IsNetworkStatsEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_network_stats_enabled),
            },
            FieldInfoData {
                name: "IsAiEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_ai_enabled),
            },
            FieldInfoData {
                name: "IsDestructionEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_destruction_enabled),
            },
            FieldInfoData {
                name: "IsSoldierAnimationEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_soldier_animation_enabled),
            },
            FieldInfoData {
                name: "IsSoldierDetailedCollisionEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_soldier_detailed_collision_enabled),
            },
            FieldInfoData {
                name: "LoadSavePoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, load_save_point),
            },
            FieldInfoData {
                name: "SavePoint",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, save_point),
            },
            FieldInfoData {
                name: "DisableCutscenes",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, disable_cutscenes),
            },
            FieldInfoData {
                name: "HavokVisualDebugger",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, havok_visual_debugger),
            },
            FieldInfoData {
                name: "HavokCaptureToFile",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, havok_capture_to_file),
            },
            FieldInfoData {
                name: "ShowTriggerDebugText",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, show_trigger_debug_text),
            },
            FieldInfoData {
                name: "TimeoutGame",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, timeout_game),
            },
            FieldInfoData {
                name: "TimeoutTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, timeout_time),
            },
            FieldInfoData {
                name: "PlayerCountNeededForMultiplayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, player_count_needed_for_multiplayer),
            },
            FieldInfoData {
                name: "AILooksIntoCamera",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, a_i_looks_into_camera),
            },
            FieldInfoData {
                name: "DebugMenuClick",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, debug_menu_click),
            },
            FieldInfoData {
                name: "DeathmatchDebugInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, deathmatch_debug_info),
            },
            FieldInfoData {
                name: "VehicleInteractionIgnoresSeeThrough",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, vehicle_interaction_ignores_see_through),
            },
            FieldInfoData {
                name: "CongestionCtrl",
                flags: MemberInfoFlags::new(0),
                field_type: "CongestionControlSettings",
                rust_offset: offset_of!(ServerSettings, congestion_ctrl),
            },
            FieldInfoData {
                name: "JobEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, job_enable),
            },
            FieldInfoData {
                name: "ThreadingEnable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, threading_enable),
            },
            FieldInfoData {
                name: "DrawActivePhysicsObjects",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, draw_active_physics_objects),
            },
            FieldInfoData {
                name: "IsRanked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, is_ranked),
            },
            FieldInfoData {
                name: "UnlockResolver",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, unlock_resolver),
            },
            FieldInfoData {
                name: "ScoringLogEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, scoring_log_enabled),
            },
            FieldInfoData {
                name: "InstantUpdateEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, instant_update_enabled),
            },
            FieldInfoData {
                name: "LoadingTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, loading_timeout),
            },
            FieldInfoData {
                name: "IngameTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, ingame_timeout),
            },
            FieldInfoData {
                name: "OutgoingFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, outgoing_frequency),
            },
            FieldInfoData {
                name: "IncomingFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, incoming_frequency),
            },
            FieldInfoData {
                name: "IncomingRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, incoming_rate),
            },
            FieldInfoData {
                name: "OutgoingRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, outgoing_rate),
            },
            FieldInfoData {
                name: "Playlist",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, playlist),
            },
            FieldInfoData {
                name: "ForcePlaylist",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, force_playlist),
            },
            FieldInfoData {
                name: "DedicatedServerCpu",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ServerSettings, dedicated_server_cpu),
            },
            FieldInfoData {
                name: "AutoUnspawnBangers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, auto_unspawn_bangers),
            },
            FieldInfoData {
                name: "RegulatedAIThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, regulated_a_i_throttle),
            },
            FieldInfoData {
                name: "EnableAnimationCulling",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, enable_animation_culling),
            },
            FieldInfoData {
                name: "FallBackToSquadSpawn",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, fall_back_to_squad_spawn),
            },
            FieldInfoData {
                name: "SaveGameVersion",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ServerSettings, save_game_version),
            },
            FieldInfoData {
                name: "SaveGameUseProfileSaves",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, save_game_use_profile_saves),
            },
            FieldInfoData {
                name: "ServerName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, server_name),
            },
            FieldInfoData {
                name: "ServerPassword",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, server_password),
            },
            FieldInfoData {
                name: "VehicleSpawnAllowed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, vehicle_spawn_allowed),
            },
            FieldInfoData {
                name: "VehicleSpawnDelayModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, vehicle_spawn_delay_modifier),
            },
            FieldInfoData {
                name: "HumanHealthMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, human_health_multiplier),
            },
            FieldInfoData {
                name: "RespawnTimeModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ServerSettings, respawn_time_modifier),
            },
            FieldInfoData {
                name: "AdministrationEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_enabled),
            },
            FieldInfoData {
                name: "AdministrationLogEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_log_enabled),
            },
            FieldInfoData {
                name: "AdministrationTimeStampLogNames",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_time_stamp_log_names),
            },
            FieldInfoData {
                name: "AdministrationEventsEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_events_enabled),
            },
            FieldInfoData {
                name: "AdministrationServerNameRestricted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, administration_server_name_restricted),
            },
            FieldInfoData {
                name: "AdministrationPassword",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, administration_password),
            },
            FieldInfoData {
                name: "RemoteAdministrationPort",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ServerSettings, remote_administration_port),
            },
            FieldInfoData {
                name: "ExtendedJuiceLoggingEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ServerSettings, extended_juice_logging_enabled),
            },
        ],
    }),
    array_type: Some(SERVERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ServerSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SERVERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ServerSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CongestionControlSettings {
    pub enabled: bool,
    pub latency_sample_count: u32,
    pub latency_ms_min: f32,
    pub latency_ms_max: f32,
    pub packet_loss_min: f32,
    pub packet_loss_max: f32,
    pub latency_incr_ms_min: f32,
    pub latency_incr_ms_max: f32,
    pub connection_grade_bad: f32,
    pub connection_grade_good: f32,
    pub connection_grade_best: f32,
    pub freq_change_step_scale: f32,
    pub freq_dist_scale_min: f32,
    pub freq_dist_bias_max: f32,
}

pub trait CongestionControlSettingsTrait: TypeObject {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn latency_sample_count(&self) -> &u32;
    fn latency_sample_count_mut(&mut self) -> &mut u32;
    fn latency_ms_min(&self) -> &f32;
    fn latency_ms_min_mut(&mut self) -> &mut f32;
    fn latency_ms_max(&self) -> &f32;
    fn latency_ms_max_mut(&mut self) -> &mut f32;
    fn packet_loss_min(&self) -> &f32;
    fn packet_loss_min_mut(&mut self) -> &mut f32;
    fn packet_loss_max(&self) -> &f32;
    fn packet_loss_max_mut(&mut self) -> &mut f32;
    fn latency_incr_ms_min(&self) -> &f32;
    fn latency_incr_ms_min_mut(&mut self) -> &mut f32;
    fn latency_incr_ms_max(&self) -> &f32;
    fn latency_incr_ms_max_mut(&mut self) -> &mut f32;
    fn connection_grade_bad(&self) -> &f32;
    fn connection_grade_bad_mut(&mut self) -> &mut f32;
    fn connection_grade_good(&self) -> &f32;
    fn connection_grade_good_mut(&mut self) -> &mut f32;
    fn connection_grade_best(&self) -> &f32;
    fn connection_grade_best_mut(&mut self) -> &mut f32;
    fn freq_change_step_scale(&self) -> &f32;
    fn freq_change_step_scale_mut(&mut self) -> &mut f32;
    fn freq_dist_scale_min(&self) -> &f32;
    fn freq_dist_scale_min_mut(&mut self) -> &mut f32;
    fn freq_dist_bias_max(&self) -> &f32;
    fn freq_dist_bias_max_mut(&mut self) -> &mut f32;
}

impl CongestionControlSettingsTrait for CongestionControlSettings {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn latency_sample_count(&self) -> &u32 {
        &self.latency_sample_count
    }
    fn latency_sample_count_mut(&mut self) -> &mut u32 {
        &mut self.latency_sample_count
    }
    fn latency_ms_min(&self) -> &f32 {
        &self.latency_ms_min
    }
    fn latency_ms_min_mut(&mut self) -> &mut f32 {
        &mut self.latency_ms_min
    }
    fn latency_ms_max(&self) -> &f32 {
        &self.latency_ms_max
    }
    fn latency_ms_max_mut(&mut self) -> &mut f32 {
        &mut self.latency_ms_max
    }
    fn packet_loss_min(&self) -> &f32 {
        &self.packet_loss_min
    }
    fn packet_loss_min_mut(&mut self) -> &mut f32 {
        &mut self.packet_loss_min
    }
    fn packet_loss_max(&self) -> &f32 {
        &self.packet_loss_max
    }
    fn packet_loss_max_mut(&mut self) -> &mut f32 {
        &mut self.packet_loss_max
    }
    fn latency_incr_ms_min(&self) -> &f32 {
        &self.latency_incr_ms_min
    }
    fn latency_incr_ms_min_mut(&mut self) -> &mut f32 {
        &mut self.latency_incr_ms_min
    }
    fn latency_incr_ms_max(&self) -> &f32 {
        &self.latency_incr_ms_max
    }
    fn latency_incr_ms_max_mut(&mut self) -> &mut f32 {
        &mut self.latency_incr_ms_max
    }
    fn connection_grade_bad(&self) -> &f32 {
        &self.connection_grade_bad
    }
    fn connection_grade_bad_mut(&mut self) -> &mut f32 {
        &mut self.connection_grade_bad
    }
    fn connection_grade_good(&self) -> &f32 {
        &self.connection_grade_good
    }
    fn connection_grade_good_mut(&mut self) -> &mut f32 {
        &mut self.connection_grade_good
    }
    fn connection_grade_best(&self) -> &f32 {
        &self.connection_grade_best
    }
    fn connection_grade_best_mut(&mut self) -> &mut f32 {
        &mut self.connection_grade_best
    }
    fn freq_change_step_scale(&self) -> &f32 {
        &self.freq_change_step_scale
    }
    fn freq_change_step_scale_mut(&mut self) -> &mut f32 {
        &mut self.freq_change_step_scale
    }
    fn freq_dist_scale_min(&self) -> &f32 {
        &self.freq_dist_scale_min
    }
    fn freq_dist_scale_min_mut(&mut self) -> &mut f32 {
        &mut self.freq_dist_scale_min
    }
    fn freq_dist_bias_max(&self) -> &f32 {
        &self.freq_dist_bias_max
    }
    fn freq_dist_bias_max_mut(&mut self) -> &mut f32 {
        &mut self.freq_dist_bias_max
    }
}

pub static CONGESTIONCONTROLSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CongestionControlSettings",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CongestionControlSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CongestionControlSettings, enabled),
            },
            FieldInfoData {
                name: "LatencySampleCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CongestionControlSettings, latency_sample_count),
            },
            FieldInfoData {
                name: "LatencyMsMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, latency_ms_min),
            },
            FieldInfoData {
                name: "LatencyMsMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, latency_ms_max),
            },
            FieldInfoData {
                name: "PacketLossMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, packet_loss_min),
            },
            FieldInfoData {
                name: "PacketLossMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, packet_loss_max),
            },
            FieldInfoData {
                name: "LatencyIncrMsMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, latency_incr_ms_min),
            },
            FieldInfoData {
                name: "LatencyIncrMsMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, latency_incr_ms_max),
            },
            FieldInfoData {
                name: "ConnectionGradeBad",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, connection_grade_bad),
            },
            FieldInfoData {
                name: "ConnectionGradeGood",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, connection_grade_good),
            },
            FieldInfoData {
                name: "ConnectionGradeBest",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, connection_grade_best),
            },
            FieldInfoData {
                name: "FreqChangeStepScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, freq_change_step_scale),
            },
            FieldInfoData {
                name: "FreqDistScaleMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, freq_dist_scale_min),
            },
            FieldInfoData {
                name: "FreqDistBiasMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CongestionControlSettings, freq_dist_bias_max),
            },
        ],
    }),
    array_type: Some(CONGESTIONCONTROLSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CongestionControlSettings {
    fn type_info(&self) -> &'static TypeInfo {
        CONGESTIONCONTROLSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CONGESTIONCONTROLSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CongestionControlSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("CongestionControlSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ModelAnimationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub auto_start: bool,
    pub looping: bool,
    pub reset_after_stop: bool,
    pub play_first_frame: bool,
    pub default_animation: String,
    pub animation_index: i32,
    pub animation_set: Option<Arc<Mutex<dyn super::ant::AntAnimationSetAssetTrait>>>,
    pub external_time: f32,
    pub playback_speed: f32,
    pub instance_seed: i32,
    pub animation_entity_space: super::core::LinearTransform,
    pub animation_entity_space_active: bool,
    pub bone_to_place: super::entity::GameplayBones,
    pub disable_culling: bool,
    pub enable_joint_world_transform_output: bool,
    pub model_animation_transform_type: ModelAnimationTransformType,
    pub joint_world_transform_update_order: ModelAnimationUpdateOrder,
    pub show_debug_transforms: bool,
    pub joint_output_field_hashes: Vec<i32>,
}

pub trait ModelAnimationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn auto_start(&self) -> &bool;
    fn auto_start_mut(&mut self) -> &mut bool;
    fn looping(&self) -> &bool;
    fn looping_mut(&mut self) -> &mut bool;
    fn reset_after_stop(&self) -> &bool;
    fn reset_after_stop_mut(&mut self) -> &mut bool;
    fn play_first_frame(&self) -> &bool;
    fn play_first_frame_mut(&mut self) -> &mut bool;
    fn default_animation(&self) -> &String;
    fn default_animation_mut(&mut self) -> &mut String;
    fn animation_index(&self) -> &i32;
    fn animation_index_mut(&mut self) -> &mut i32;
    fn animation_set(&self) -> &Option<Arc<Mutex<dyn super::ant::AntAnimationSetAssetTrait>>>;
    fn animation_set_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::ant::AntAnimationSetAssetTrait>>>;
    fn external_time(&self) -> &f32;
    fn external_time_mut(&mut self) -> &mut f32;
    fn playback_speed(&self) -> &f32;
    fn playback_speed_mut(&mut self) -> &mut f32;
    fn instance_seed(&self) -> &i32;
    fn instance_seed_mut(&mut self) -> &mut i32;
    fn animation_entity_space(&self) -> &super::core::LinearTransform;
    fn animation_entity_space_mut(&mut self) -> &mut super::core::LinearTransform;
    fn animation_entity_space_active(&self) -> &bool;
    fn animation_entity_space_active_mut(&mut self) -> &mut bool;
    fn bone_to_place(&self) -> &super::entity::GameplayBones;
    fn bone_to_place_mut(&mut self) -> &mut super::entity::GameplayBones;
    fn disable_culling(&self) -> &bool;
    fn disable_culling_mut(&mut self) -> &mut bool;
    fn enable_joint_world_transform_output(&self) -> &bool;
    fn enable_joint_world_transform_output_mut(&mut self) -> &mut bool;
    fn model_animation_transform_type(&self) -> &ModelAnimationTransformType;
    fn model_animation_transform_type_mut(&mut self) -> &mut ModelAnimationTransformType;
    fn joint_world_transform_update_order(&self) -> &ModelAnimationUpdateOrder;
    fn joint_world_transform_update_order_mut(&mut self) -> &mut ModelAnimationUpdateOrder;
    fn show_debug_transforms(&self) -> &bool;
    fn show_debug_transforms_mut(&mut self) -> &mut bool;
    fn joint_output_field_hashes(&self) -> &Vec<i32>;
    fn joint_output_field_hashes_mut(&mut self) -> &mut Vec<i32>;
}

impl ModelAnimationEntityDataTrait for ModelAnimationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn auto_start(&self) -> &bool {
        &self.auto_start
    }
    fn auto_start_mut(&mut self) -> &mut bool {
        &mut self.auto_start
    }
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn looping_mut(&mut self) -> &mut bool {
        &mut self.looping
    }
    fn reset_after_stop(&self) -> &bool {
        &self.reset_after_stop
    }
    fn reset_after_stop_mut(&mut self) -> &mut bool {
        &mut self.reset_after_stop
    }
    fn play_first_frame(&self) -> &bool {
        &self.play_first_frame
    }
    fn play_first_frame_mut(&mut self) -> &mut bool {
        &mut self.play_first_frame
    }
    fn default_animation(&self) -> &String {
        &self.default_animation
    }
    fn default_animation_mut(&mut self) -> &mut String {
        &mut self.default_animation
    }
    fn animation_index(&self) -> &i32 {
        &self.animation_index
    }
    fn animation_index_mut(&mut self) -> &mut i32 {
        &mut self.animation_index
    }
    fn animation_set(&self) -> &Option<Arc<Mutex<dyn super::ant::AntAnimationSetAssetTrait>>> {
        &self.animation_set
    }
    fn animation_set_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::ant::AntAnimationSetAssetTrait>>> {
        &mut self.animation_set
    }
    fn external_time(&self) -> &f32 {
        &self.external_time
    }
    fn external_time_mut(&mut self) -> &mut f32 {
        &mut self.external_time
    }
    fn playback_speed(&self) -> &f32 {
        &self.playback_speed
    }
    fn playback_speed_mut(&mut self) -> &mut f32 {
        &mut self.playback_speed
    }
    fn instance_seed(&self) -> &i32 {
        &self.instance_seed
    }
    fn instance_seed_mut(&mut self) -> &mut i32 {
        &mut self.instance_seed
    }
    fn animation_entity_space(&self) -> &super::core::LinearTransform {
        &self.animation_entity_space
    }
    fn animation_entity_space_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.animation_entity_space
    }
    fn animation_entity_space_active(&self) -> &bool {
        &self.animation_entity_space_active
    }
    fn animation_entity_space_active_mut(&mut self) -> &mut bool {
        &mut self.animation_entity_space_active
    }
    fn bone_to_place(&self) -> &super::entity::GameplayBones {
        &self.bone_to_place
    }
    fn bone_to_place_mut(&mut self) -> &mut super::entity::GameplayBones {
        &mut self.bone_to_place
    }
    fn disable_culling(&self) -> &bool {
        &self.disable_culling
    }
    fn disable_culling_mut(&mut self) -> &mut bool {
        &mut self.disable_culling
    }
    fn enable_joint_world_transform_output(&self) -> &bool {
        &self.enable_joint_world_transform_output
    }
    fn enable_joint_world_transform_output_mut(&mut self) -> &mut bool {
        &mut self.enable_joint_world_transform_output
    }
    fn model_animation_transform_type(&self) -> &ModelAnimationTransformType {
        &self.model_animation_transform_type
    }
    fn model_animation_transform_type_mut(&mut self) -> &mut ModelAnimationTransformType {
        &mut self.model_animation_transform_type
    }
    fn joint_world_transform_update_order(&self) -> &ModelAnimationUpdateOrder {
        &self.joint_world_transform_update_order
    }
    fn joint_world_transform_update_order_mut(&mut self) -> &mut ModelAnimationUpdateOrder {
        &mut self.joint_world_transform_update_order
    }
    fn show_debug_transforms(&self) -> &bool {
        &self.show_debug_transforms
    }
    fn show_debug_transforms_mut(&mut self) -> &mut bool {
        &mut self.show_debug_transforms
    }
    fn joint_output_field_hashes(&self) -> &Vec<i32> {
        &self.joint_output_field_hashes
    }
    fn joint_output_field_hashes_mut(&mut self) -> &mut Vec<i32> {
        &mut self.joint_output_field_hashes
    }
}

impl super::entity::EntityDataTrait for ModelAnimationEntityData {
}

impl super::entity::GameObjectDataTrait for ModelAnimationEntityData {
}

impl super::core::DataBusPeerTrait for ModelAnimationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ModelAnimationEntityData {
}

impl super::core::DataContainerTrait for ModelAnimationEntityData {
}

pub static MODELANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ModelAnimationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(ModelAnimationEntityData, realm),
            },
            FieldInfoData {
                name: "AutoStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, auto_start),
            },
            FieldInfoData {
                name: "Looping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, looping),
            },
            FieldInfoData {
                name: "ResetAfterStop",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, reset_after_stop),
            },
            FieldInfoData {
                name: "PlayFirstFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, play_first_frame),
            },
            FieldInfoData {
                name: "DefaultAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(ModelAnimationEntityData, default_animation),
            },
            FieldInfoData {
                name: "AnimationIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ModelAnimationEntityData, animation_index),
            },
            FieldInfoData {
                name: "AnimationSet",
                flags: MemberInfoFlags::new(0),
                field_type: "AntAnimationSetAsset",
                rust_offset: offset_of!(ModelAnimationEntityData, animation_set),
            },
            FieldInfoData {
                name: "ExternalTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ModelAnimationEntityData, external_time),
            },
            FieldInfoData {
                name: "PlaybackSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ModelAnimationEntityData, playback_speed),
            },
            FieldInfoData {
                name: "InstanceSeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ModelAnimationEntityData, instance_seed),
            },
            FieldInfoData {
                name: "AnimationEntitySpace",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(ModelAnimationEntityData, animation_entity_space),
            },
            FieldInfoData {
                name: "AnimationEntitySpaceActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, animation_entity_space_active),
            },
            FieldInfoData {
                name: "BoneToPlace",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(ModelAnimationEntityData, bone_to_place),
            },
            FieldInfoData {
                name: "DisableCulling",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, disable_culling),
            },
            FieldInfoData {
                name: "EnableJointWorldTransformOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, enable_joint_world_transform_output),
            },
            FieldInfoData {
                name: "ModelAnimationTransformType",
                flags: MemberInfoFlags::new(0),
                field_type: "ModelAnimationTransformType",
                rust_offset: offset_of!(ModelAnimationEntityData, model_animation_transform_type),
            },
            FieldInfoData {
                name: "JointWorldTransformUpdateOrder",
                flags: MemberInfoFlags::new(0),
                field_type: "ModelAnimationUpdateOrder",
                rust_offset: offset_of!(ModelAnimationEntityData, joint_world_transform_update_order),
            },
            FieldInfoData {
                name: "ShowDebugTransforms",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ModelAnimationEntityData, show_debug_transforms),
            },
            FieldInfoData {
                name: "JointOutputFieldHashes",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(ModelAnimationEntityData, joint_output_field_hashes),
            },
        ],
    }),
    array_type: Some(MODELANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ModelAnimationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MODELANIMATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MODELANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ModelAnimationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ModelAnimationTransformType {
    #[default]
    ModelAnimationTransformType_World = 0,
    ModelAnimationTransformType_Model = 1,
    ModelAnimationTransformType_Local = 2,
}

pub static MODELANIMATIONTRANSFORMTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationTransformType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MODELANIMATIONTRANSFORMTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ModelAnimationTransformType {
    fn type_info(&self) -> &'static TypeInfo {
        MODELANIMATIONTRANSFORMTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MODELANIMATIONTRANSFORMTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationTransformType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ModelAnimationTransformType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ModelAnimationUpdateOrder {
    #[default]
    ModelAnimationUpdateOrder_PostAnimation = 0,
    ModelAnimationUpdateOrder_PreInput = 1,
}

pub static MODELANIMATIONUPDATEORDER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationUpdateOrder",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(MODELANIMATIONUPDATEORDER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ModelAnimationUpdateOrder {
    fn type_info(&self) -> &'static TypeInfo {
        MODELANIMATIONUPDATEORDER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MODELANIMATIONUPDATEORDER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelAnimationUpdateOrder-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ModelAnimationUpdateOrder"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationEnumerationChoiceEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub value: i32,
}

pub trait AnimationEnumerationChoiceEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl AnimationEnumerationChoiceEntityDataTrait for AnimationEnumerationChoiceEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

impl super::entity::EntityDataTrait for AnimationEnumerationChoiceEntityData {
}

impl super::entity::GameObjectDataTrait for AnimationEnumerationChoiceEntityData {
}

impl super::core::DataBusPeerTrait for AnimationEnumerationChoiceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationEnumerationChoiceEntityData {
}

impl super::core::DataContainerTrait for AnimationEnumerationChoiceEntityData {
}

pub static ANIMATIONENUMERATIONCHOICEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationEnumerationChoiceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationEnumerationChoiceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AnimationEnumerationChoiceEntityData, realm),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AnimationEnumerationChoiceEntityData, value),
            },
        ],
    }),
    array_type: Some(ANIMATIONENUMERATIONCHOICEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationEnumerationChoiceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONENUMERATIONCHOICEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONENUMERATIONCHOICEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationEnumerationChoiceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationEnumerationChoiceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationEnumerationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub ant_enum: Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>,
    pub detect_changes_from_start: bool,
}

pub trait AnimationEnumerationEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn ant_enum(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn ant_enum_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn detect_changes_from_start(&self) -> &bool;
    fn detect_changes_from_start_mut(&mut self) -> &mut bool;
}

impl AnimationEnumerationEntityDataTrait for AnimationEnumerationEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn ant_enum(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &self.ant_enum
    }
    fn ant_enum_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &mut self.ant_enum
    }
    fn detect_changes_from_start(&self) -> &bool {
        &self.detect_changes_from_start
    }
    fn detect_changes_from_start_mut(&mut self) -> &mut bool {
        &mut self.detect_changes_from_start
    }
}

impl super::entity::EntityDataTrait for AnimationEnumerationEntityData {
}

impl super::entity::GameObjectDataTrait for AnimationEnumerationEntityData {
}

impl super::core::DataBusPeerTrait for AnimationEnumerationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationEnumerationEntityData {
}

impl super::core::DataContainerTrait for AnimationEnumerationEntityData {
}

pub static ANIMATIONENUMERATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationEnumerationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationEnumerationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AnimationEnumerationEntityData, realm),
            },
            FieldInfoData {
                name: "AntEnum",
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(AnimationEnumerationEntityData, ant_enum),
            },
            FieldInfoData {
                name: "DetectChangesFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimationEnumerationEntityData, detect_changes_from_start),
            },
        ],
    }),
    array_type: Some(ANIMATIONENUMERATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationEnumerationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONENUMERATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONENUMERATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationEnumerationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationEnumerationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnimationSignalEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub signal: super::ant::AntRef,
    pub int_game_state: super::ant::AntRef,
    pub float_game_state: super::ant::AntRef,
    pub value_int: i32,
    pub value_float: f32,
    pub reset: bool,
    pub continuous: bool,
}

pub trait AnimationSignalEntityDataTrait: super::entity::EntityDataTrait {
    fn signal(&self) -> &super::ant::AntRef;
    fn signal_mut(&mut self) -> &mut super::ant::AntRef;
    fn int_game_state(&self) -> &super::ant::AntRef;
    fn int_game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn float_game_state(&self) -> &super::ant::AntRef;
    fn float_game_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn value_int(&self) -> &i32;
    fn value_int_mut(&mut self) -> &mut i32;
    fn value_float(&self) -> &f32;
    fn value_float_mut(&mut self) -> &mut f32;
    fn reset(&self) -> &bool;
    fn reset_mut(&mut self) -> &mut bool;
    fn continuous(&self) -> &bool;
    fn continuous_mut(&mut self) -> &mut bool;
}

impl AnimationSignalEntityDataTrait for AnimationSignalEntityData {
    fn signal(&self) -> &super::ant::AntRef {
        &self.signal
    }
    fn signal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.signal
    }
    fn int_game_state(&self) -> &super::ant::AntRef {
        &self.int_game_state
    }
    fn int_game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.int_game_state
    }
    fn float_game_state(&self) -> &super::ant::AntRef {
        &self.float_game_state
    }
    fn float_game_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.float_game_state
    }
    fn value_int(&self) -> &i32 {
        &self.value_int
    }
    fn value_int_mut(&mut self) -> &mut i32 {
        &mut self.value_int
    }
    fn value_float(&self) -> &f32 {
        &self.value_float
    }
    fn value_float_mut(&mut self) -> &mut f32 {
        &mut self.value_float
    }
    fn reset(&self) -> &bool {
        &self.reset
    }
    fn reset_mut(&mut self) -> &mut bool {
        &mut self.reset
    }
    fn continuous(&self) -> &bool {
        &self.continuous
    }
    fn continuous_mut(&mut self) -> &mut bool {
        &mut self.continuous
    }
}

impl super::entity::EntityDataTrait for AnimationSignalEntityData {
}

impl super::entity::GameObjectDataTrait for AnimationSignalEntityData {
}

impl super::core::DataBusPeerTrait for AnimationSignalEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AnimationSignalEntityData {
}

impl super::core::DataContainerTrait for AnimationSignalEntityData {
}

pub static ANIMATIONSIGNALENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationSignalEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnimationSignalEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Signal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationSignalEntityData, signal),
            },
            FieldInfoData {
                name: "IntGameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationSignalEntityData, int_game_state),
            },
            FieldInfoData {
                name: "FloatGameState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnimationSignalEntityData, float_game_state),
            },
            FieldInfoData {
                name: "ValueInt",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AnimationSignalEntityData, value_int),
            },
            FieldInfoData {
                name: "ValueFloat",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AnimationSignalEntityData, value_float),
            },
            FieldInfoData {
                name: "Reset",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimationSignalEntityData, reset),
            },
            FieldInfoData {
                name: "Continuous",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AnimationSignalEntityData, continuous),
            },
        ],
    }),
    array_type: Some(ANIMATIONSIGNALENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AnimationSignalEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ANIMATIONSIGNALENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ANIMATIONSIGNALENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnimationSignalEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("AnimationSignalEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ScoringVisibilityType {
    #[default]
    ScoringVisibilityType_Major = 0,
    ScoringVisibilityType_Minor = 1,
    ScoringVisibilityType_Hidden = 2,
}

pub static SCORINGVISIBILITYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScoringVisibilityType",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(SCORINGVISIBILITYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ScoringVisibilityType {
    fn type_info(&self) -> &'static TypeInfo {
        SCORINGVISIBILITYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SCORINGVISIBILITYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScoringVisibilityType-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("ScoringVisibilityType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FloatRecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait FloatRecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl FloatRecordPropertyTrackDataTrait for FloatRecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for FloatRecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for FloatRecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for FloatRecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for FloatRecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for FloatRecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for FloatRecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FloatRecordPropertyTrackData {
}

impl super::core::DataContainerTrait for FloatRecordPropertyTrackData {
}

pub static FLOATRECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatRecordPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FloatRecordPropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FLOATRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FloatRecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        FLOATRECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLOATRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FloatRecordPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("FloatRecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolValidatePropertyTrackData {
    pub _glacier_base: ValidatePropertyTrackBaseData,
}

pub trait BoolValidatePropertyTrackDataTrait: ValidatePropertyTrackBaseDataTrait {
}

impl BoolValidatePropertyTrackDataTrait for BoolValidatePropertyTrackData {
}

impl ValidatePropertyTrackBaseDataTrait for BoolValidatePropertyTrackData {
    fn recorded_data_track(&self) -> &Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track()
    }
    fn recorded_data_track_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>> {
        self._glacier_base.recorded_data_track_mut()
    }
    fn auto_generated(&self) -> &bool {
        self._glacier_base.auto_generated()
    }
    fn auto_generated_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_generated_mut()
    }
    fn recorded_key_time_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data()
    }
    fn recorded_key_time_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_time_data_mut()
    }
    fn recorded_key_value_data(&self) -> &glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data()
    }
    fn recorded_key_value_data_mut(&mut self) -> &mut glacier_reflect::builtin::ResourceRef {
        self._glacier_base.recorded_key_value_data_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for BoolValidatePropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for BoolValidatePropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for BoolValidatePropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for BoolValidatePropertyTrackData {
}

impl super::core::DataBusPeerTrait for BoolValidatePropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoolValidatePropertyTrackData {
}

impl super::core::DataContainerTrait for BoolValidatePropertyTrackData {
}

pub static BOOLVALIDATEPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolValidatePropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VALIDATEPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolValidatePropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolValidatePropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLVALIDATEPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLVALIDATEPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolValidatePropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoolValidatePropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BoolRecordPropertyTrackData {
    pub _glacier_base: RecordPropertyTrackBaseData,
}

pub trait BoolRecordPropertyTrackDataTrait: RecordPropertyTrackBaseDataTrait {
}

impl BoolRecordPropertyTrackDataTrait for BoolRecordPropertyTrackData {
}

impl RecordPropertyTrackBaseDataTrait for BoolRecordPropertyTrackData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes()
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TrimmingRangeKeyframeTrait>>>> {
        self._glacier_base.keyframes_mut()
    }
    fn trimmed_recording_ranges(&self) -> &Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges()
    }
    fn trimmed_recording_ranges_mut(&mut self) -> &mut Vec<TrimmedRecordingRange> {
        self._glacier_base.trimmed_recording_ranges_mut()
    }
}

impl super::timeline::PropertyReaderTrackBaseDataTrait for BoolRecordPropertyTrackData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::timeline::SchematicPinTrackDataTrait for BoolRecordPropertyTrackData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for BoolRecordPropertyTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for BoolRecordPropertyTrackData {
}

impl super::core::DataBusPeerTrait for BoolRecordPropertyTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BoolRecordPropertyTrackData {
}

impl super::core::DataContainerTrait for BoolRecordPropertyTrackData {
}

pub static BOOLRECORDPROPERTYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolRecordPropertyTrackData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(RECORDPROPERTYTRACKBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BoolRecordPropertyTrackData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BOOLRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BoolRecordPropertyTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        BOOLRECORDPROPERTYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BOOLRECORDPROPERTYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BoolRecordPropertyTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BoolRecordPropertyTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SyncedTimelineStateChangeMessageBase {
}

pub trait SyncedTimelineStateChangeMessageBaseTrait: TypeObject {
}

impl SyncedTimelineStateChangeMessageBaseTrait for SyncedTimelineStateChangeMessageBase {
}

pub static SYNCEDTIMELINESTATECHANGEMESSAGEBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SyncedTimelineStateChangeMessageBase",
    flags: MemberInfoFlags::new(73),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SyncedTimelineStateChangeMessageBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 255,
};

impl TypeObject for SyncedTimelineStateChangeMessageBase {
    fn type_info(&self) -> &'static TypeInfo {
        SYNCEDTIMELINESTATECHANGEMESSAGEBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct SharedLockGateEntityData {
    pub _glacier_base: SharedLockBaseEntityData,
}

pub trait SharedLockGateEntityDataTrait: SharedLockBaseEntityDataTrait {
}

impl SharedLockGateEntityDataTrait for SharedLockGateEntityData {
}

impl SharedLockBaseEntityDataTrait for SharedLockGateEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn asset(&self) -> &Option<Arc<Mutex<dyn SharedLockAssetTrait>>> {
        self._glacier_base.asset()
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SharedLockAssetTrait>>> {
        self._glacier_base.asset_mut()
    }
}

impl super::entity::EntityDataTrait for SharedLockGateEntityData {
}

impl super::entity::GameObjectDataTrait for SharedLockGateEntityData {
}

impl super::core::DataBusPeerTrait for SharedLockGateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SharedLockGateEntityData {
}

impl super::core::DataContainerTrait for SharedLockGateEntityData {
}

pub static SHAREDLOCKGATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockGateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHAREDLOCKBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockGateEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHAREDLOCKGATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedLockGateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKGATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKGATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockGateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockGateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SharedLockObserverEntityData {
    pub _glacier_base: SharedLockBaseEntityData,
}

pub trait SharedLockObserverEntityDataTrait: SharedLockBaseEntityDataTrait {
}

impl SharedLockObserverEntityDataTrait for SharedLockObserverEntityData {
}

impl SharedLockBaseEntityDataTrait for SharedLockObserverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn asset(&self) -> &Option<Arc<Mutex<dyn SharedLockAssetTrait>>> {
        self._glacier_base.asset()
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SharedLockAssetTrait>>> {
        self._glacier_base.asset_mut()
    }
}

impl super::entity::EntityDataTrait for SharedLockObserverEntityData {
}

impl super::entity::GameObjectDataTrait for SharedLockObserverEntityData {
}

impl super::core::DataBusPeerTrait for SharedLockObserverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SharedLockObserverEntityData {
}

impl super::core::DataContainerTrait for SharedLockObserverEntityData {
}

pub static SHAREDLOCKOBSERVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockObserverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHAREDLOCKBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockObserverEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHAREDLOCKOBSERVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedLockObserverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKOBSERVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKOBSERVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockObserverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockObserverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SharedLockControllerEntityData {
    pub _glacier_base: SharedLockBaseEntityData,
}

pub trait SharedLockControllerEntityDataTrait: SharedLockBaseEntityDataTrait {
}

impl SharedLockControllerEntityDataTrait for SharedLockControllerEntityData {
}

impl SharedLockBaseEntityDataTrait for SharedLockControllerEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn asset(&self) -> &Option<Arc<Mutex<dyn SharedLockAssetTrait>>> {
        self._glacier_base.asset()
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SharedLockAssetTrait>>> {
        self._glacier_base.asset_mut()
    }
}

impl super::entity::EntityDataTrait for SharedLockControllerEntityData {
}

impl super::entity::GameObjectDataTrait for SharedLockControllerEntityData {
}

impl super::core::DataBusPeerTrait for SharedLockControllerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SharedLockControllerEntityData {
}

impl super::core::DataContainerTrait for SharedLockControllerEntityData {
}

pub static SHAREDLOCKCONTROLLERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockControllerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SHAREDLOCKBASEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockControllerEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SHAREDLOCKCONTROLLERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedLockControllerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKCONTROLLERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKCONTROLLERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockControllerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockControllerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SharedLockBaseEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub asset: Option<Arc<Mutex<dyn SharedLockAssetTrait>>>,
}

pub trait SharedLockBaseEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn asset(&self) -> &Option<Arc<Mutex<dyn SharedLockAssetTrait>>>;
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SharedLockAssetTrait>>>;
}

impl SharedLockBaseEntityDataTrait for SharedLockBaseEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn asset(&self) -> &Option<Arc<Mutex<dyn SharedLockAssetTrait>>> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SharedLockAssetTrait>>> {
        &mut self.asset
    }
}

impl super::entity::EntityDataTrait for SharedLockBaseEntityData {
}

impl super::entity::GameObjectDataTrait for SharedLockBaseEntityData {
}

impl super::core::DataBusPeerTrait for SharedLockBaseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SharedLockBaseEntityData {
}

impl super::core::DataContainerTrait for SharedLockBaseEntityData {
}

pub static SHAREDLOCKBASEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockBaseEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockBaseEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SharedLockBaseEntityData, realm),
            },
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: "SharedLockAsset",
                rust_offset: offset_of!(SharedLockBaseEntityData, asset),
            },
        ],
    }),
    array_type: Some(SHAREDLOCKBASEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SharedLockBaseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKBASEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKBASEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockBaseEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockBaseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SharedLockAsset {
    pub _glacier_base: super::core::Asset,
    pub realm: super::core::Realm,
}

pub trait SharedLockAssetTrait: super::core::AssetTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl SharedLockAssetTrait for SharedLockAsset {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::core::AssetTrait for SharedLockAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SharedLockAsset {
}

pub static SHAREDLOCKASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockAsset",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SharedLockAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SharedLockAsset, realm),
            },
        ],
    }),
    array_type: Some(SHAREDLOCKASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SharedLockAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SHAREDLOCKASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SHAREDLOCKASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SharedLockAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("SharedLockAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MorphComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub mesh_blueprint: Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>,
}

pub trait MorphComponentDataTrait: super::entity::GameComponentDataTrait {
    fn mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
    fn mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>>;
}

impl MorphComponentDataTrait for MorphComponentData {
    fn mesh_blueprint(&self) -> &Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &self.mesh_blueprint
    }
    fn mesh_blueprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::entity::ObjectBlueprintTrait>>> {
        &mut self.mesh_blueprint
    }
}

impl super::entity::GameComponentDataTrait for MorphComponentData {
}

impl super::entity::ComponentDataTrait for MorphComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for MorphComponentData {
}

impl super::core::DataBusPeerTrait for MorphComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MorphComponentData {
}

impl super::core::DataContainerTrait for MorphComponentData {
}

pub static MORPHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MorphComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MorphComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MeshBlueprint",
                flags: MemberInfoFlags::new(0),
                field_type: "ObjectBlueprint",
                rust_offset: offset_of!(MorphComponentData, mesh_blueprint),
            },
        ],
    }),
    array_type: Some(MORPHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for MorphComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        MORPHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MORPHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MorphComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("MorphComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BreakableModelHealthComponentData {
    pub _glacier_base: super::gameplay_sim::GameHealthComponentData,
}

pub trait BreakableModelHealthComponentDataTrait: super::gameplay_sim::GameHealthComponentDataTrait {
}

impl BreakableModelHealthComponentDataTrait for BreakableModelHealthComponentData {
}

impl super::gameplay_sim::GameHealthComponentDataTrait for BreakableModelHealthComponentData {
}

impl super::gameplay_sim::HealthComponentDataTrait for BreakableModelHealthComponentData {
}

impl super::entity::ComponentDataTrait for BreakableModelHealthComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BreakableModelHealthComponentData {
}

impl super::core::DataBusPeerTrait for BreakableModelHealthComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakableModelHealthComponentData {
}

impl super::core::DataContainerTrait for BreakableModelHealthComponentData {
}

pub static BREAKABLEMODELHEALTHCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelHealthComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEHEALTHCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelHealthComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BREAKABLEMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakableModelHealthComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELHEALTHCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLEMODELHEALTHCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelHealthComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableModelHealthComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BreakableModelPhysicsComponentData {
    pub _glacier_base: super::gameplay_sim::GamePhysicsComponentData,
    pub breakable_bodies: Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>>,
}

pub trait BreakableModelPhysicsComponentDataTrait: super::gameplay_sim::GamePhysicsComponentDataTrait {
    fn breakable_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>>;
    fn breakable_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>>;
}

impl BreakableModelPhysicsComponentDataTrait for BreakableModelPhysicsComponentData {
    fn breakable_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        &self.breakable_bodies
    }
    fn breakable_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        &mut self.breakable_bodies
    }
}

impl super::gameplay_sim::GamePhysicsComponentDataTrait for BreakableModelPhysicsComponentData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn effect_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters()
    }
    fn effect_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::effect_base::EffectParameterTrait>>>> {
        self._glacier_base.effect_parameters_mut()
    }
}

impl super::physics::PhysicsComponentDataTrait for BreakableModelPhysicsComponentData {
    fn physics_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies()
    }
    fn physics_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsBodyDataTrait>>>> {
        self._glacier_base.physics_bodies_mut()
    }
    fn physics_constraints(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints()
    }
    fn physics_constraints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::PhysicsConstraintDataTrait>>>> {
        self._glacier_base.physics_constraints_mut()
    }
    fn parts(&self) -> &Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts()
    }
    fn parts_mut(&mut self) -> &mut Vec<super::physics::PhysicsPartData> {
        self._glacier_base.parts_mut()
    }
    fn movable_parts(&self) -> &bool {
        self._glacier_base.movable_parts()
    }
    fn movable_parts_mut(&mut self) -> &mut bool {
        self._glacier_base.movable_parts_mut()
    }
    fn internal_collision_disabling(&self) -> &super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling()
    }
    fn internal_collision_disabling_mut(&mut self) -> &mut super::physics::InternalCollisionDisablingBehavior {
        self._glacier_base.internal_collision_disabling_mut()
    }
    fn enable_collision_events(&self) -> &bool {
        self._glacier_base.enable_collision_events()
    }
    fn enable_collision_events_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_collision_events_mut()
    }
}

impl super::entity::ComponentDataTrait for BreakableModelPhysicsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BreakableModelPhysicsComponentData {
}

impl super::core::DataBusPeerTrait for BreakableModelPhysicsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakableModelPhysicsComponentData {
}

impl super::core::DataContainerTrait for BreakableModelPhysicsComponentData {
}

pub static BREAKABLEMODELPHYSICSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelPhysicsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEPHYSICSCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelPhysicsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BreakableBodies",
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsBodyData-Array",
                rust_offset: offset_of!(BreakableModelPhysicsComponentData, breakable_bodies),
            },
        ],
    }),
    array_type: Some(BREAKABLEMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakableModelPhysicsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELPHYSICSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLEMODELPHYSICSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelPhysicsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableModelPhysicsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage {
}

pub trait BreakableModelToComponentsSpawnPartObjectsOnCollapseMessageTrait: TypeObject {
}

impl BreakableModelToComponentsSpawnPartObjectsOnCollapseMessageTrait for BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage {
}

pub static BREAKABLEMODELTOCOMPONENTSSPAWNPARTOBJECTSONCOLLAPSEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for BreakableModelToComponentsSpawnPartObjectsOnCollapseMessage {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELTOCOMPONENTSSPAWNPARTOBJECTSONCOLLAPSEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct BreakableModelToComponentsCollapseMessage {
}

pub trait BreakableModelToComponentsCollapseMessageTrait: TypeObject {
}

impl BreakableModelToComponentsCollapseMessageTrait for BreakableModelToComponentsCollapseMessage {
}

pub static BREAKABLEMODELTOCOMPONENTSCOLLAPSEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelToComponentsCollapseMessage",
    flags: MemberInfoFlags::new(36937),
    module: "GameShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelToComponentsCollapseMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for BreakableModelToComponentsCollapseMessage {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELTOCOMPONENTSCOLLAPSEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct BreakableModelEntityData {
    pub _glacier_base: super::physics::GamePhysicsEntityData,
    pub decal_volume_shader: Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>>,
    pub decal_volume_scale_factor: f32,
    pub mesh: Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>,
    pub edge_models_data: Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>>,
}

pub trait BreakableModelEntityDataTrait: super::physics::GamePhysicsEntityDataTrait {
    fn decal_volume_shader(&self) -> &Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>>;
    fn decal_volume_shader_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>>;
    fn decal_volume_scale_factor(&self) -> &f32;
    fn decal_volume_scale_factor_mut(&mut self) -> &mut f32;
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>>;
    fn edge_models_data(&self) -> &Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>>;
    fn edge_models_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>>;
}

impl BreakableModelEntityDataTrait for BreakableModelEntityData {
    fn decal_volume_shader(&self) -> &Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>> {
        &self.decal_volume_shader
    }
    fn decal_volume_shader_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::SurfaceShaderBaseAssetTrait>>> {
        &mut self.decal_volume_shader
    }
    fn decal_volume_scale_factor(&self) -> &f32 {
        &self.decal_volume_scale_factor
    }
    fn decal_volume_scale_factor_mut(&mut self) -> &mut f32 {
        &mut self.decal_volume_scale_factor
    }
    fn mesh(&self) -> &Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &self.mesh
    }
    fn mesh_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::render_base::MeshBaseAssetTrait>>> {
        &mut self.mesh
    }
    fn edge_models_data(&self) -> &Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>> {
        &self.edge_models_data
    }
    fn edge_models_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>> {
        &mut self.edge_models_data
    }
}

impl super::physics::GamePhysicsEntityDataTrait for BreakableModelEntityData {
}

impl super::entity::GameComponentEntityDataTrait for BreakableModelEntityData {
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
}

impl super::entity::ComponentEntityDataTrait for BreakableModelEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn part_bounding_boxes(&self) -> &Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes()
    }
    fn part_bounding_boxes_mut(&mut self) -> &mut Vec<super::core::AxisAlignedBox> {
        self._glacier_base.part_bounding_boxes_mut()
    }
    fn client_runtime_component_count(&self) -> &u8 {
        self._glacier_base.client_runtime_component_count()
    }
    fn client_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_component_count_mut()
    }
    fn server_runtime_component_count(&self) -> &u8 {
        self._glacier_base.server_runtime_component_count()
    }
    fn server_runtime_component_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_component_count_mut()
    }
    fn client_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.client_runtime_transformation_count()
    }
    fn client_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_runtime_transformation_count_mut()
    }
    fn server_runtime_transformation_count(&self) -> &u8 {
        self._glacier_base.server_runtime_transformation_count()
    }
    fn server_runtime_transformation_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_runtime_transformation_count_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for BreakableModelEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for BreakableModelEntityData {
}

impl super::entity::GameObjectDataTrait for BreakableModelEntityData {
}

impl super::core::DataBusPeerTrait for BreakableModelEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakableModelEntityData {
}

impl super::core::DataContainerTrait for BreakableModelEntityData {
}

pub static BREAKABLEMODELENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelEntityData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::GAMEPHYSICSENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableModelEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DecalVolumeShader",
                flags: MemberInfoFlags::new(0),
                field_type: "SurfaceShaderBaseAsset",
                rust_offset: offset_of!(BreakableModelEntityData, decal_volume_shader),
            },
            FieldInfoData {
                name: "DecalVolumeScaleFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BreakableModelEntityData, decal_volume_scale_factor),
            },
            FieldInfoData {
                name: "Mesh",
                flags: MemberInfoFlags::new(0),
                field_type: "MeshBaseAsset",
                rust_offset: offset_of!(BreakableModelEntityData, mesh),
            },
            FieldInfoData {
                name: "EdgeModelsData",
                flags: MemberInfoFlags::new(0),
                field_type: "EdgeModelsBaseData",
                rust_offset: offset_of!(BreakableModelEntityData, edge_models_data),
            },
        ],
    }),
    array_type: Some(BREAKABLEMODELENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakableModelEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEMODELENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLEMODELENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableModelEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableModelEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EdgeModelComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub edge_models_data: Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>>,
    pub rigid_bodies: Vec<Option<Arc<Mutex<dyn super::physics::RigidBodyDataTrait>>>>,
}

pub trait EdgeModelComponentDataTrait: super::entity::GameComponentDataTrait {
    fn edge_models_data(&self) -> &Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>>;
    fn edge_models_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>>;
    fn rigid_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::RigidBodyDataTrait>>>>;
    fn rigid_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::RigidBodyDataTrait>>>>;
}

impl EdgeModelComponentDataTrait for EdgeModelComponentData {
    fn edge_models_data(&self) -> &Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>> {
        &self.edge_models_data
    }
    fn edge_models_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::world_base::EdgeModelsBaseDataTrait>>> {
        &mut self.edge_models_data
    }
    fn rigid_bodies(&self) -> &Vec<Option<Arc<Mutex<dyn super::physics::RigidBodyDataTrait>>>> {
        &self.rigid_bodies
    }
    fn rigid_bodies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::physics::RigidBodyDataTrait>>>> {
        &mut self.rigid_bodies
    }
}

impl super::entity::GameComponentDataTrait for EdgeModelComponentData {
}

impl super::entity::ComponentDataTrait for EdgeModelComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for EdgeModelComponentData {
}

impl super::core::DataBusPeerTrait for EdgeModelComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EdgeModelComponentData {
}

impl super::core::DataContainerTrait for EdgeModelComponentData {
}

pub static EDGEMODELCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EdgeModelComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EdgeModelComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EdgeModelsData",
                flags: MemberInfoFlags::new(0),
                field_type: "EdgeModelsBaseData",
                rust_offset: offset_of!(EdgeModelComponentData, edge_models_data),
            },
            FieldInfoData {
                name: "RigidBodies",
                flags: MemberInfoFlags::new(144),
                field_type: "RigidBodyData-Array",
                rust_offset: offset_of!(EdgeModelComponentData, rigid_bodies),
            },
        ],
    }),
    array_type: Some(EDGEMODELCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EdgeModelComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        EDGEMODELCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EDGEMODELCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EdgeModelComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("EdgeModelComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BreakableControllerComponentData {
    pub _glacier_base: super::physics::DestructionControllerComponentData,
    pub breakable_part_count: u32,
    pub network_id_count: u32,
}

pub trait BreakableControllerComponentDataTrait: super::physics::DestructionControllerComponentDataTrait {
    fn breakable_part_count(&self) -> &u32;
    fn breakable_part_count_mut(&mut self) -> &mut u32;
    fn network_id_count(&self) -> &u32;
    fn network_id_count_mut(&mut self) -> &mut u32;
}

impl BreakableControllerComponentDataTrait for BreakableControllerComponentData {
    fn breakable_part_count(&self) -> &u32 {
        &self.breakable_part_count
    }
    fn breakable_part_count_mut(&mut self) -> &mut u32 {
        &mut self.breakable_part_count
    }
    fn network_id_count(&self) -> &u32 {
        &self.network_id_count
    }
    fn network_id_count_mut(&mut self) -> &mut u32 {
        &mut self.network_id_count
    }
}

impl super::physics::DestructionControllerComponentDataTrait for BreakableControllerComponentData {
    fn structural_integrity_analyzer_enable(&self) -> &bool {
        self._glacier_base.structural_integrity_analyzer_enable()
    }
    fn structural_integrity_analyzer_enable_mut(&mut self) -> &mut bool {
        self._glacier_base.structural_integrity_analyzer_enable_mut()
    }
    fn breaking_length(&self) -> &f32 {
        self._glacier_base.breaking_length()
    }
    fn breaking_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.breaking_length_mut()
    }
    fn fracture_position(&self) -> &f32 {
        self._glacier_base.fracture_position()
    }
    fn fracture_position_mut(&mut self) -> &mut f32 {
        self._glacier_base.fracture_position_mut()
    }
    fn destruction_radius(&self) -> &f32 {
        self._glacier_base.destruction_radius()
    }
    fn destruction_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.destruction_radius_mut()
    }
    fn delay(&self) -> &f32 {
        self._glacier_base.delay()
    }
    fn delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.delay_mut()
    }
    fn refine_radius(&self) -> &f32 {
        self._glacier_base.refine_radius()
    }
    fn refine_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.refine_radius_mut()
    }
}

impl super::entity::GameComponentDataTrait for BreakableControllerComponentData {
}

impl super::entity::ComponentDataTrait for BreakableControllerComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BreakableControllerComponentData {
}

impl super::core::DataBusPeerTrait for BreakableControllerComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakableControllerComponentData {
}

impl super::core::DataContainerTrait for BreakableControllerComponentData {
}

pub static BREAKABLECONTROLLERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::DESTRUCTIONCONTROLLERCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakableControllerComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BreakablePartCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BreakableControllerComponentData, breakable_part_count),
            },
            FieldInfoData {
                name: "NetworkIdCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BreakableControllerComponentData, network_id_count),
            },
        ],
    }),
    array_type: Some(BREAKABLECONTROLLERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakableControllerComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLECONTROLLERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLECONTROLLERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableControllerComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BreakableControllerComponentNetworkIdMultiplier {
    #[default]
    BreakableControllerComponentNetworkIdMultiplier_HidePartObjects = 0,
    BreakableControllerComponentNetworkIdMultiplier_DisablePart = 1,
    BreakableControllerComponentNetworkIdMultiplier_PartCount = 2,
}

pub static BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentNetworkIdMultiplier",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BreakableControllerComponentNetworkIdMultiplier {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BREAKABLECONTROLLERCOMPONENTNETWORKIDMULTIPLIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentNetworkIdMultiplier-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableControllerComponentNetworkIdMultiplier"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BreakableControllerComponentNetworkId {
    #[default]
    BreakableControllerComponentNetworkId_Collapsed = 0,
    BreakableControllerComponentNetworkId_SpawnPartObjectsOnCollapse = 1,
    BreakableControllerComponentNetworkId_ExtraPartCount = 2,
}

pub static BREAKABLECONTROLLERCOMPONENTNETWORKID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentNetworkId",
    flags: MemberInfoFlags::new(49429),
    module: "GameShared",
    data: TypeInfoData::Enum,
    array_type: Some(BREAKABLECONTROLLERCOMPONENTNETWORKID_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BreakableControllerComponentNetworkId {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLECONTROLLERCOMPONENTNETWORKID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BREAKABLECONTROLLERCOMPONENTNETWORKID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakableControllerComponentNetworkId-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakableControllerComponentNetworkId"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BreakablePartComponentData {
    pub _glacier_base: super::physics::DestructionPartComponentData,
    pub health_percentage: u32,
    pub collapsable: bool,
    pub destroy_nearby_static_entities: bool,
}

pub trait BreakablePartComponentDataTrait: super::physics::DestructionPartComponentDataTrait {
    fn health_percentage(&self) -> &u32;
    fn health_percentage_mut(&mut self) -> &mut u32;
    fn collapsable(&self) -> &bool;
    fn collapsable_mut(&mut self) -> &mut bool;
    fn destroy_nearby_static_entities(&self) -> &bool;
    fn destroy_nearby_static_entities_mut(&mut self) -> &mut bool;
}

impl BreakablePartComponentDataTrait for BreakablePartComponentData {
    fn health_percentage(&self) -> &u32 {
        &self.health_percentage
    }
    fn health_percentage_mut(&mut self) -> &mut u32 {
        &mut self.health_percentage
    }
    fn collapsable(&self) -> &bool {
        &self.collapsable
    }
    fn collapsable_mut(&mut self) -> &mut bool {
        &mut self.collapsable
    }
    fn destroy_nearby_static_entities(&self) -> &bool {
        &self.destroy_nearby_static_entities
    }
    fn destroy_nearby_static_entities_mut(&mut self) -> &mut bool {
        &mut self.destroy_nearby_static_entities
    }
}

impl super::physics::DestructionPartComponentDataTrait for BreakablePartComponentData {
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects()
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.objects_mut()
    }
    fn part_index(&self) -> &u32 {
        self._glacier_base.part_index()
    }
    fn part_index_mut(&mut self) -> &mut u32 {
        self._glacier_base.part_index_mut()
    }
    fn fixed(&self) -> &bool {
        self._glacier_base.fixed()
    }
    fn fixed_mut(&mut self) -> &mut bool {
        self._glacier_base.fixed_mut()
    }
    fn fragile(&self) -> &bool {
        self._glacier_base.fragile()
    }
    fn fragile_mut(&mut self) -> &mut bool {
        self._glacier_base.fragile_mut()
    }
}

impl super::entity::GameComponentDataTrait for BreakablePartComponentData {
}

impl super::entity::ComponentDataTrait for BreakablePartComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BreakablePartComponentData {
}

impl super::core::DataBusPeerTrait for BreakablePartComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BreakablePartComponentData {
}

impl super::core::DataContainerTrait for BreakablePartComponentData {
}

pub static BREAKABLEPARTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakablePartComponentData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::physics::DESTRUCTIONPARTCOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BreakablePartComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HealthPercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BreakablePartComponentData, health_percentage),
            },
            FieldInfoData {
                name: "Collapsable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BreakablePartComponentData, collapsable),
            },
            FieldInfoData {
                name: "DestroyNearbyStaticEntities",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BreakablePartComponentData, destroy_nearby_static_entities),
            },
        ],
    }),
    array_type: Some(BREAKABLEPARTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BreakablePartComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BREAKABLEPARTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BREAKABLEPARTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BreakablePartComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("BreakablePartComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RawFileData {
}

pub trait RawFileDataTrait: TypeObject {
}

impl RawFileDataTrait for RawFileData {
}

pub static RAWFILEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileData",
    flags: MemberInfoFlags::new(101),
    module: "GameShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RawFileData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(RAWFILEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for RawFileData {
    fn type_info(&self) -> &'static TypeInfo {
        RAWFILEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RAWFILEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RawFileData-Array",
    flags: MemberInfoFlags::new(145),
    module: "GameShared",
    data: TypeInfoData::Array("RawFileData"),
    array_type: None,
    alignment: 8,
};


