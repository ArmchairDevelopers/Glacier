use std::{mem::offset_of, any::Any, option::Option, sync::Arc};
use tokio::sync::Mutex;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData, TypeObject, TypeFunctions,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_battle_a_i_shared_types(registry: &mut TypeRegistry) {
    registry.register_type(AISOUNDENTITYDATA_TYPE_INFO);
    registry.register_type(AISOUNDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISOUNDDEFAULTS_TYPE_INFO);
    registry.register_type(AISOUNDDEFAULTS_ARRAY_TYPE_INFO);
    registry.register_type(AISOUND_TYPE_INFO);
    registry.register_type(AISOUND_ARRAY_TYPE_INFO);
    registry.register_type(AISOUNDTYPE_TYPE_INFO);
    registry.register_type(AISOUNDTYPE_ARRAY_TYPE_INFO);
    registry.register_type(AISOLDIERSPAWNTEMPLATEDATA_TYPE_INFO);
    registry.register_type(AISOLDIERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERMELEETYPE_TYPE_INFO);
    registry.register_type(SOLDIERMELEETYPE_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSLOCOSETTINGS_TYPE_INFO);
    registry.register_type(PHYSICSLOCOSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(TRACKTARGETSETTINGS_TYPE_INFO);
    registry.register_type(TRACKTARGETSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERTACTICS_TYPE_INFO);
    registry.register_type(SOLDIERTACTICS_ARRAY_TYPE_INFO);
    registry.register_type(SECONDARYTHREATSETTINGS_TYPE_INFO);
    registry.register_type(SECONDARYTHREATSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESUPPRESSIONSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLESUPPRESSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSUPPRESSIONSETTINGS_TYPE_INFO);
    registry.register_type(WEAPONSUPPRESSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(PICKWEAPONSETTINGS_TYPE_INFO);
    registry.register_type(PICKWEAPONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SLOTRANGE_TYPE_INFO);
    registry.register_type(SLOTRANGE_ARRAY_TYPE_INFO);
    registry.register_type(STEALTHSTATETYPE_TYPE_INFO);
    registry.register_type(STEALTHSTATETYPE_ARRAY_TYPE_INFO);
    registry.register_type(ENGAGESETTINGS_TYPE_INFO);
    registry.register_type(ENGAGESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SQUADENGAGESETTINGS_TYPE_INFO);
    registry.register_type(SQUADENGAGESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SQUADMOVEMENTSETTINGS_TYPE_INFO);
    registry.register_type(SQUADMOVEMENTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CLOSECOMBATSETTINGS_TYPE_INFO);
    registry.register_type(CLOSECOMBATSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(GOTOATTACKPOINTSETTINGS_TYPE_INFO);
    registry.register_type(GOTOATTACKPOINTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(EVADEBEHAVIORSETTINGS_TYPE_INFO);
    registry.register_type(EVADEBEHAVIORSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FLEESETTINGS_TYPE_INFO);
    registry.register_type(FLEESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FLEECOVERREQUESTSETTINGS_TYPE_INFO);
    registry.register_type(FLEECOVERREQUESTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(HIDESETTINGS_TYPE_INFO);
    registry.register_type(HIDESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(GOTOTARGETSETTINGS_TYPE_INFO);
    registry.register_type(GOTOTARGETSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWSETTINGS_TYPE_INFO);
    registry.register_type(FOLLOWSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWSTEALTHAVOIDANCESETTINGS_TYPE_INFO);
    registry.register_type(FOLLOWSTEALTHAVOIDANCESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWCOVERSETTINGS_TYPE_INFO);
    registry.register_type(FOLLOWCOVERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWMOVESETTINGS_TYPE_INFO);
    registry.register_type(FOLLOWMOVESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWPOSEPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWPOSEPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWSPEEDCONTROLPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWSPEEDCONTROLPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWMOVESPEEDSELECTIONPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWMOVESPEEDSELECTIONPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWREPATHPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWREPATHPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(ATTACKSETTINGS_TYPE_INFO);
    registry.register_type(ATTACKSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(ATTACKCOVERREQUESTSETTINGS_TYPE_INFO);
    registry.register_type(ATTACKCOVERREQUESTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_TYPE_INFO);
    registry.register_type(ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(EXECUTEACTIONSETTINGS_TYPE_INFO);
    registry.register_type(EXECUTEACTIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGS_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CLOSERANGEATTACKSETTINGS_TYPE_INFO);
    registry.register_type(CLOSERANGEATTACKSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(MELEECHARGESETTINGS_TYPE_INFO);
    registry.register_type(MELEECHARGESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICMELEECHARGETOKENSSETTINGS_TYPE_INFO);
    registry.register_type(DYNAMICMELEECHARGETOKENSSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(BERSERKSETTINGS_TYPE_INFO);
    registry.register_type(BERSERKSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CHARGESETTINGS_TYPE_INFO);
    registry.register_type(CHARGESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESETTINGS_TYPE_INFO);
    registry.register_type(VEHICLESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(AIMELEESETTINGS_TYPE_INFO);
    registry.register_type(AIMELEESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(PROJECTILESETTINGS_TYPE_INFO);
    registry.register_type(PROJECTILESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(POSESETTINGS_TYPE_INFO);
    registry.register_type(POSESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COVERCONTROLSETTINGS_TYPE_INFO);
    registry.register_type(COVERCONTROLSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COVERHOVERDATA_TYPE_INFO);
    registry.register_type(COVERHOVERDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERSIDESTEPDATA_TYPE_INFO);
    registry.register_type(COVERSIDESTEPDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHECKTARGETINVEHICLE_TYPE_INFO);
    registry.register_type(CHECKTARGETINVEHICLE_ARRAY_TYPE_INFO);
    registry.register_type(AISPAWNDATA_TYPE_INFO);
    registry.register_type(AISPAWNDATA_ARRAY_TYPE_INFO);
    registry.register_type(TACTICS_TYPE_INFO);
    registry.register_type(TACTICS_ARRAY_TYPE_INFO);
    registry.register_type(AIRTARGETSELECTORENTITYDATA_TYPE_INFO);
    registry.register_type(AIRTARGETSELECTORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIREADINESSLEVEL_TYPE_INFO);
    registry.register_type(AIREADINESSLEVEL_ARRAY_TYPE_INFO);
    registry.register_type(AIRCOLLISIONAVOIDANCEENTITYDATA_TYPE_INFO);
    registry.register_type(AIRCOLLISIONAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPROXIMITYAIMINGSTATE_TYPE_INFO);
    registry.register_type(AIPROXIMITYAIMINGSTATE_ARRAY_TYPE_INFO);
    registry.register_type(AIPROXIMITYREACTIONSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIPROXIMITYREACTIONSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOOKATHUMAN_TYPE_INFO);
    registry.register_type(LOOKATHUMAN_ARRAY_TYPE_INFO);
    registry.register_type(AIPROXIMITYREACTIONSBINDING_TYPE_INFO);
    registry.register_type(AIPROXIMITYREACTIONSBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIALTFIREFROMANTSTATE_TYPE_INFO);
    registry.register_type(AIALTFIREFROMANTSTATE_ARRAY_TYPE_INFO);
    registry.register_type(AISTUNREACTIONANIMATIONTYPE_TYPE_INFO);
    registry.register_type(AISTUNREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(AIPROJECTILECOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIPROJECTILECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILEBINDING_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILEBINDING_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILE_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILE_ARRAY_TYPE_INFO);
    registry.register_type(DISPERSION_TYPE_INFO);
    registry.register_type(DISPERSION_ARRAY_TYPE_INFO);
    registry.register_type(GRENADETOKENTYPE_TYPE_INFO);
    registry.register_type(GRENADETOKENTYPE_ARRAY_TYPE_INFO);
    registry.register_type(GRENADETIMERTYPE_TYPE_INFO);
    registry.register_type(GRENADETIMERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(LINEARTIME_TYPE_INFO);
    registry.register_type(LINEARTIME_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILECURVETYPE_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILECURVETYPE_ARRAY_TYPE_INFO);
    registry.register_type(AIPHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(AIPHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISHAREDBINDING_TYPE_INFO);
    registry.register_type(AISHAREDBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIPHYSICSDRIVENANIMATIONBINDING_TYPE_INFO);
    registry.register_type(AIPHYSICSDRIVENANIMATIONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENCOVERSTATE_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENCOVERSTATE_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKUSAGETYPE_TYPE_INFO);
    registry.register_type(AIPATHLINKUSAGETYPE_ARRAY_TYPE_INFO);
    registry.register_type(AINAVOBSTACLEPENALTY_TYPE_INFO);
    registry.register_type(AINAVOBSTACLEPENALTY_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHFINDINGLAYER_TYPE_INFO);
    registry.register_type(AIPATHFINDINGLAYER_ARRAY_TYPE_INFO);
    registry.register_type(AISELFDESTRUCTENTITYDATA_TYPE_INFO);
    registry.register_type(AISELFDESTRUCTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOVERQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(AICOVERQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLOAKINGMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(CLOAKINGMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISOUNDAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AISOUNDAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOMBATGROUPENTITYDATA_TYPE_INFO);
    registry.register_type(AICOMBATGROUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMBATCOVERMOVEMENTSETTINGS_TYPE_INFO);
    registry.register_type(COMBATCOVERMOVEMENTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COMBATPROPAGATIONSETTINGS_TYPE_INFO);
    registry.register_type(COMBATPROPAGATIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(AITACTICENTITYDATA_TYPE_INFO);
    registry.register_type(AITACTICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISHOOTATTARGETSENTITYDATA_TYPE_INFO);
    registry.register_type(AISHOOTATTARGETSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPOINTTARGETDATA_TYPE_INFO);
    registry.register_type(AIPOINTTARGETDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIUSEWAYPOINTSENTITYDATA_TYPE_INFO);
    registry.register_type(AIUSEWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIUSECOVERENTITYDATA_TYPE_INFO);
    registry.register_type(AIUSECOVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOVERZONESOVERRIDEENTITYDATA_TYPE_INFO);
    registry.register_type(AICOVERZONESOVERRIDEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIAWARENESSENTITYDATA_TYPE_INFO);
    registry.register_type(AIAWARENESSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIWEAPONSLOTOVERRIDEENTITYDATA_TYPE_INFO);
    registry.register_type(AIWEAPONSLOTOVERRIDEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIWEAPONOVERRIDEENTITYDATA_TYPE_INFO);
    registry.register_type(AIWEAPONOVERRIDEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLEBEHAVIORENTITYDATA_TYPE_INFO);
    registry.register_type(AIVEHICLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AITARGETINGENTITYDATA_TYPE_INFO);
    registry.register_type(AITARGETINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOMBATBEHAVIORENTITYDATA_TYPE_INFO);
    registry.register_type(AICOMBATBEHAVIORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFORBIDDENAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIFORBIDDENAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFRIENDLYAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIFRIENDLYAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFLANKINGCORRIDORENTITYDATA_TYPE_INFO);
    registry.register_type(AIFLANKINGCORRIDORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISEARCHAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AISEARCHAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIDEFENDAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIDEFENDAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AITARGETCOORDINATORFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(AITARGETCOORDINATORFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TARGETCOORDINATORFILTER_TYPE_INFO);
    registry.register_type(TARGETCOORDINATORFILTER_ARRAY_TYPE_INFO);
    registry.register_type(TARGETCOORDINATORFILTERACTION_TYPE_INFO);
    registry.register_type(TARGETCOORDINATORFILTERACTION_ARRAY_TYPE_INFO);
    registry.register_type(AITARGETCOORDINATORENTITYDATA_TYPE_INFO);
    registry.register_type(AITARGETCOORDINATORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISTEALTHENTITYDATA_TYPE_INFO);
    registry.register_type(AISTEALTHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIBUDDYFOLLOWENTITYDATA_TYPE_INFO);
    registry.register_type(AIBUDDYFOLLOWENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWPREFERREDSLOTARC_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWPREFERREDSLOTARC_ARRAY_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWSLOTSCORINGDATA_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWSLOTSCORINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTENTITYDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTCONFIGASSET_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTCONFIGASSET_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTMOVEPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTMOVEPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTSLOTCONFIG_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTSLOTCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTPREFERREDSLOTARC_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTPREFERREDSLOTARC_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTSLOTSCORINGDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTSLOTSCORINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPREFERREDAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIPREFERREDAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIHEARINGPARAMETERENTITYDATA_TYPE_INFO);
    registry.register_type(AIHEARINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISENSINGPARAMETERENTITYDATA_TYPE_INFO);
    registry.register_type(AISENSINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIIDLEBEHAVIORENTITYDATA_TYPE_INFO);
    registry.register_type(AIIDLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO);
    registry.register_type(AIPARAMETERWITHSHAPEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPARAMETERENTITYDATA_TYPE_INFO);
    registry.register_type(AIPARAMETERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICANCELORDERENTITYDATA_TYPE_INFO);
    registry.register_type(AICANCELORDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIGOTOPLACEORDERENTITYDATA_TYPE_INFO);
    registry.register_type(AIGOTOPLACEORDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWWAYPOINTSORDERENTITYDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWWAYPOINTSORDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIORDERENTITYBASEDATA_TYPE_INFO);
    registry.register_type(AIORDERENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TACTICSENUMERATION_TYPE_INFO);
    registry.register_type(TACTICSENUMERATION_ARRAY_TYPE_INFO);
    registry.register_type(AICOMBATINTENSITY_TYPE_INFO);
    registry.register_type(AICOMBATINTENSITY_ARRAY_TYPE_INFO);
    registry.register_type(EXECUTIONPRIORITY_TYPE_INFO);
    registry.register_type(EXECUTIONPRIORITY_ARRAY_TYPE_INFO);
    registry.register_type(AISHOOTTYPE_TYPE_INFO);
    registry.register_type(AISHOOTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(IDLEREADINESS_TYPE_INFO);
    registry.register_type(IDLEREADINESS_ARRAY_TYPE_INFO);
    registry.register_type(AIORDERCOORDINATORCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIORDERCOORDINATORCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MEMBERACTION_TYPE_INFO);
    registry.register_type(MEMBERACTION_ARRAY_TYPE_INFO);
    registry.register_type(LEADERACTION_TYPE_INFO);
    registry.register_type(LEADERACTION_ARRAY_TYPE_INFO);
    registry.register_type(LEADERACTIONBINDING_TYPE_INFO);
    registry.register_type(LEADERACTIONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIOBSTACLECONTROLLERENTITYDATA_TYPE_INFO);
    registry.register_type(AIOBSTACLECONTROLLERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAINAVOBSTACLECOMPONENTDATA_TYPE_INFO);
    registry.register_type(BATTLEAINAVOBSTACLECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMELEECOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIMELEECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AITELEPORTENTITYDATA_TYPE_INFO);
    registry.register_type(AITELEPORTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAYPOINTSWALKERENTITYDATA_TYPE_INFO);
    registry.register_type(WAYPOINTSWALKERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFIREPATTERNENTITYDATA_TYPE_INFO);
    registry.register_type(AIFIREPATTERNENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEFIREPATTERNDATA_TYPE_INFO);
    registry.register_type(SIMPLEFIREPATTERNDATA_ARRAY_TYPE_INFO);
    registry.register_type(AITEMPLATEFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(AITEMPLATEFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(POINTOFINTERESTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(POINTOFINTERESTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERVEHICLEPROXIMITYENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERVEHICLEPROXIMITYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HEAVYPLANEPILOTENTITYDATA_TYPE_INFO);
    registry.register_type(HEAVYPLANEPILOTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PILOTENTITYDATA_TYPE_INFO);
    registry.register_type(PILOTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PILOTENTITYBASEDATA_TYPE_INFO);
    registry.register_type(PILOTENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PATHFINDINGOVERRIDEDATA_TYPE_INFO);
    registry.register_type(PATHFINDINGOVERRIDEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PATHFOLLOWINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PATHFOLLOWINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWWAYPOINTSENTITYDATA_TYPE_INFO);
    registry.register_type(FOLLOWWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTENTITYDATA_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAYPOINTTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(WAYPOINTTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PATHFINDINGSTREAMENTITYDATA_TYPE_INFO);
    registry.register_type(PATHFINDINGSTREAMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAIPATHLINKENTITYDATA_TYPE_INFO);
    registry.register_type(BATTLEAIPATHLINKENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANDARDMOVEPATHLINKDATA_TYPE_INFO);
    registry.register_type(STANDARDMOVEPATHLINKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCENARIOPATHLINKDATA_TYPE_INFO);
    registry.register_type(SCENARIOPATHLINKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKDATA_TYPE_INFO);
    registry.register_type(AIPATHLINKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKDIRECTION_TYPE_INFO);
    registry.register_type(AIPATHLINKDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKPENALTY_TYPE_INFO);
    registry.register_type(AIPATHLINKPENALTY_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKTYPE_TYPE_INFO);
    registry.register_type(AIPATHLINKTYPE_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKGEOMETRYTYPE_TYPE_INFO);
    registry.register_type(AIPATHLINKGEOMETRYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MOVESETTINGS_TYPE_INFO);
    registry.register_type(MOVESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(STARTSTOPSETTINGS_TYPE_INFO);
    registry.register_type(STARTSTOPSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(WALKSETTINGS_TYPE_INFO);
    registry.register_type(WALKSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SPRINTSETTINGS_TYPE_INFO);
    registry.register_type(SPRINTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(POSE_TYPE_INFO);
    registry.register_type(POSE_ARRAY_TYPE_INFO);
    registry.register_type(MOVESPEED_TYPE_INFO);
    registry.register_type(MOVESPEED_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGSOVERRIDEDATA_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGSOVERRIDEDATA_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATEOVERRIDETYPE_TYPE_INFO);
    registry.register_type(INVESTIGATEOVERRIDETYPE_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSCUSTOMIZATIONS_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSCUSTOMIZATIONS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSCUSTOMIZATION_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNS_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATEENDCONDITIONS_TYPE_INFO);
    registry.register_type(INVESTIGATEENDCONDITIONS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATEENDONAREACLEARED_TYPE_INFO);
    registry.register_type(INVESTIGATEENDONAREACLEARED_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSKNOWLEDGESHARING_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSKNOWLEDGESHARING_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKDATA_TYPE_INFO);
    registry.register_type(GAMETWEAKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEAMSETTINGS_TYPE_INFO);
    registry.register_type(TEAMSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKBLINDEDBEHAVIOR_TYPE_INFO);
    registry.register_type(GAMETWEAKBLINDEDBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKPANICBEHAVIOR_TYPE_INFO);
    registry.register_type(GAMETWEAKPANICBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKSNIPER_TYPE_INFO);
    registry.register_type(GAMETWEAKSNIPER_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKBUCKETDAMAGE_TYPE_INFO);
    registry.register_type(GAMETWEAKBUCKETDAMAGE_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKAITARGETING_TYPE_INFO);
    registry.register_type(GAMETWEAKAITARGETING_ARRAY_TYPE_INFO);
    registry.register_type(EVASIVEBUCKETTIMESETTINGS_TYPE_INFO);
    registry.register_type(EVASIVEBUCKETTIMESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(ACCURACYPENALTYSETTINGS_TYPE_INFO);
    registry.register_type(ACCURACYPENALTYSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKCOMMON_TYPE_INFO);
    registry.register_type(GAMETWEAKCOMMON_ARRAY_TYPE_INFO);
    registry.register_type(CORPSEDATA_TYPE_INFO);
    registry.register_type(CORPSEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEMPERATUREDATA_TYPE_INFO);
    registry.register_type(TEMPERATUREDATA_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATEDATA_TYPE_INFO);
    registry.register_type(INVESTIGATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MELEECHARGEDATA_TYPE_INFO);
    registry.register_type(MELEECHARGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PASSIVITYDATA_TYPE_INFO);
    registry.register_type(PASSIVITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AWAREMODIFIERSETTINGS_TYPE_INFO);
    registry.register_type(AWAREMODIFIERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIER_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIERSETTINGS_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREA_TYPE_INFO);
    registry.register_type(SENSINGAREA_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREAID_TYPE_INFO);
    registry.register_type(SENSINGAREAID_ARRAY_TYPE_INFO);
    registry.register_type(GRENADETOKENLIST_TYPE_INFO);
    registry.register_type(GRENADETOKENLIST_ARRAY_TYPE_INFO);
    registry.register_type(PIECEWISELINEARCURVE_TYPE_INFO);
    registry.register_type(PIECEWISELINEARCURVE_ARRAY_TYPE_INFO);
    registry.register_type(CURVEPOINT_TYPE_INFO);
    registry.register_type(CURVEPOINT_ARRAY_TYPE_INFO);
    registry.register_type(TINYPIECEWISELINEARCURVE_TYPE_INFO);
    registry.register_type(TINYPIECEWISELINEARCURVE_ARRAY_TYPE_INFO);
    registry.register_type(FIRINGPATTERNCOLLECTIONDATA_TYPE_INFO);
    registry.register_type(FIRINGPATTERNCOLLECTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(FIRINGPATTERNDATA_TYPE_INFO);
    registry.register_type(FIRINGPATTERNDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTENSITYCLASS_TYPE_INFO);
    registry.register_type(INTENSITYCLASS_ARRAY_TYPE_INFO);
    registry.register_type(FIRINGWEAPONCLASS_TYPE_INFO);
    registry.register_type(FIRINGWEAPONCLASS_ARRAY_TYPE_INFO);
    registry.register_type(PROTECTBASEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(PROTECTBASEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CREATEDISTANCEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(CREATEDISTANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SETWAYPOINTSENTITYDATA_TYPE_INFO);
    registry.register_type(SETWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWWAYPOINTSMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(FOLLOWWAYPOINTSMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLYTOMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(FLYTOMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STALLTURNMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(STALLTURNMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPINDESCENTMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(SPINDESCENTMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIDETOSIDEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(SIDETOSIDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(IMMELMANNMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(IMMELMANNMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BARRELROLLMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(BARRELROLLMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPLITSMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(SPLITSMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASICDEFENSIVEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(BASICDEFENSIVEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STRAFERUNMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(STRAFERUNMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASICATTACKMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(BASICATTACKMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLLISIONAVOIDANCEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(COLLISIONAVOIDANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENFORCEALTITUDEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(ENFORCEALTITUDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEFENSIVEMANEUVERSELECTORENTITYDATA_TYPE_INFO);
    registry.register_type(DEFENSIVEMANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MANEUVERSELECTORENTITYDATA_TYPE_INFO);
    registry.register_type(MANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTORTYPE_TYPE_INFO);
    registry.register_type(SELECTORTYPE_ARRAY_TYPE_INFO);
    registry.register_type(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO);
    registry.register_type(DOGFIGHTMANEUVERENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WSDOGFIGHTINGENTITYDATA_TYPE_INFO);
    registry.register_type(WSDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BFDOGFIGHTINGENTITYDATA_TYPE_INFO);
    registry.register_type(BFDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DOGFIGHTINGENTITYDATA_TYPE_INFO);
    registry.register_type(DOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERENTITYDATA_TYPE_INFO);
    registry.register_type(COVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERPREVIEWANIMTYPE_TYPE_INFO);
    registry.register_type(COVERPREVIEWANIMTYPE_ARRAY_TYPE_INFO);
    registry.register_type(COVERSLOT_TYPE_INFO);
    registry.register_type(COVERSLOT_ARRAY_TYPE_INFO);
    registry.register_type(COVERTYPE_TYPE_INFO);
    registry.register_type(COVERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(OLDCOVERQUERYDATA_TYPE_INFO);
    registry.register_type(OLDCOVERQUERYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCOREDATA_TYPE_INFO);
    registry.register_type(COVERQUERYSCOREDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCORERUNTIME_TYPE_INFO);
    registry.register_type(COVERQUERYSCORERUNTIME_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCORERUNTIMEFLAGS_TYPE_INFO);
    registry.register_type(COVERQUERYSCORERUNTIMEFLAGS_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCOREBASE_TYPE_INFO);
    registry.register_type(COVERQUERYSCOREBASE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCORESECONDARYDATA_TYPE_INFO);
    registry.register_type(COVERQUERYSCORESECONDARYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYDIRECTION_TYPE_INFO);
    registry.register_type(COVERQUERYDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSTYLE_TYPE_INFO);
    registry.register_type(COVERQUERYSTYLE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYCURVEXSOURCE_TYPE_INFO);
    registry.register_type(COVERQUERYCURVEXSOURCE_ARRAY_TYPE_INFO);
    registry.register_type(COVERVALIDATEDATA_TYPE_INFO);
    registry.register_type(COVERVALIDATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERVALIDATIONSCOREDATA_TYPE_INFO);
    registry.register_type(COVERVALIDATIONSCOREDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERVALIDATIONSTATUS_TYPE_INFO);
    registry.register_type(COVERVALIDATIONSTATUS_ARRAY_TYPE_INFO);
    registry.register_type(COVERSELECTDATA_TYPE_INFO);
    registry.register_type(COVERSELECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERSCOREASSET_TYPE_INFO);
    registry.register_type(COVERSCOREASSET_ARRAY_TYPE_INFO);
    registry.register_type(COVERSCOREEXECUTIONPARAMS_TYPE_INFO);
    registry.register_type(COVERSCOREEXECUTIONPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(COVERPATHSPEC_TYPE_INFO);
    registry.register_type(COVERPATHSPEC_ARRAY_TYPE_INFO);
    registry.register_type(COVERPATHMODE_TYPE_INFO);
    registry.register_type(COVERPATHMODE_ARRAY_TYPE_INFO);
    registry.register_type(COVERSCOREDATABASE_TYPE_INFO);
    registry.register_type(COVERSCOREDATABASE_ARRAY_TYPE_INFO);
    registry.register_type(COVEREXCLUSIONVOLUMESHAPEDATA_TYPE_INFO);
    registry.register_type(COVEREXCLUSIONVOLUMESHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERAUTOGENVOLUMESHAPEDATA_TYPE_INFO);
    registry.register_type(COVERAUTOGENVOLUMESHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOVERSCOREMODIFIERREMOVEMESSAGE_TYPE_INFO);
    registry.register_type(AICOVERSCOREMODIFIERADDMESSAGE_TYPE_INFO);
    registry.register_type(COVERSCOREMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(COVERSCOREMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERGROUPENTITYDATA_TYPE_INFO);
    registry.register_type(COVERGROUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERDATA_TYPE_INFO);
    registry.register_type(COVERDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYDATA_TYPE_INFO);
    registry.register_type(COVERQUERYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPATHENEMYAVOIDANCEDATA_TYPE_INFO);
    registry.register_type(COVERQUERYPATHENEMYAVOIDANCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_TYPE_INFO);
    registry.register_type(COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPATHAVOIDANCEZONE_TYPE_INFO);
    registry.register_type(COVERQUERYPATHAVOIDANCEZONE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPATHAVOIDANCETYPE_TYPE_INFO);
    registry.register_type(COVERQUERYPATHAVOIDANCETYPE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYFILTER_TYPE_INFO);
    registry.register_type(COVERQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYWEAPONRANGE_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYWEAPONRANGE_ARRAY_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYDEFENDAREA_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYDEFENDAREA_ARRAY_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYRADIUS_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYRADIUS_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSPATIALBASE_TYPE_INFO);
    registry.register_type(COVERQUERYSPATIALBASE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPOSITION_TYPE_INFO);
    registry.register_type(COVERQUERYPOSITION_ARRAY_TYPE_INFO);
    registry.register_type(COVERCONSTANTDATA_TYPE_INFO);
    registry.register_type(COVERCONSTANTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROTECTIVECOVERWALLOCCLUSIONSETTINGS_TYPE_INFO);
    registry.register_type(PROTECTIVECOVERWALLOCCLUSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(LEDGEJUMPDOWNPATHLINKCONFIG_TYPE_INFO);
    registry.register_type(LEDGEJUMPDOWNPATHLINKCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(VAULTOVERPATHLINKCONFIG_TYPE_INFO);
    registry.register_type(VAULTOVERPATHLINKCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(COVERZONES_TYPE_INFO);
    registry.register_type(COVERZONES_ARRAY_TYPE_INFO);
    registry.register_type(COVERZONEDEFINITION_TYPE_INFO);
    registry.register_type(COVERZONEDEFINITION_ARRAY_TYPE_INFO);
    registry.register_type(COVERZONE_TYPE_INFO);
    registry.register_type(COVERZONE_ARRAY_TYPE_INFO);
    registry.register_type(AICONCEALMENTVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(AICONCEALMENTVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIWEAPONDATA_TYPE_INFO);
    registry.register_type(AIWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(TARGETINGDATA_TYPE_INFO);
    registry.register_type(TARGETINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(DISTANCETOAWARECURVEOVERRIDE_TYPE_INFO);
    registry.register_type(DISTANCETOAWARECURVEOVERRIDE_ARRAY_TYPE_INFO);
    registry.register_type(SUPPRESSIONVALUES_TYPE_INFO);
    registry.register_type(SUPPRESSIONVALUES_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONHITPROBABILITY_TYPE_INFO);
    registry.register_type(WEAPONHITPROBABILITY_ARRAY_TYPE_INFO);
    registry.register_type(SPECIALBEHAVIOR_TYPE_INFO);
    registry.register_type(SPECIALBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(PREFERREDRANGE_TYPE_INFO);
    registry.register_type(PREFERREDRANGE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONRESTRICTIONS_TYPE_INFO);
    registry.register_type(WEAPONRESTRICTIONS_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIEREXTENDED_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIEREXTENDED_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIER_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(SUPPRESSEDBEHAVIOR_TYPE_INFO);
    registry.register_type(SUPPRESSEDBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEINACCURACYSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLEINACCURACYSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(TARGETMODIFIER_TYPE_INFO);
    registry.register_type(TARGETMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(FLASHLIGHTMODIFIER_TYPE_INFO);
    registry.register_type(FLASHLIGHTMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(HEARINGMODIFIER_TYPE_INFO);
    registry.register_type(HEARINGMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(VISIONMODIFIER_TYPE_INFO);
    registry.register_type(VISIONMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(EVASIONVOLUME_TYPE_INFO);
    registry.register_type(EVASIONVOLUME_ARRAY_TYPE_INFO);
    registry.register_type(ACCURACYHITBOX_TYPE_INFO);
    registry.register_type(ACCURACYHITBOX_ARRAY_TYPE_INFO);
    registry.register_type(SPRAYPATTERN_TYPE_INFO);
    registry.register_type(SPRAYPATTERN_ARRAY_TYPE_INFO);
    registry.register_type(CREEPINGAIRBARRAGE_TYPE_INFO);
    registry.register_type(CREEPINGAIRBARRAGE_ARRAY_TYPE_INFO);
    registry.register_type(BURSTINTERVALPATTERN_TYPE_INFO);
    registry.register_type(BURSTINTERVALPATTERN_ARRAY_TYPE_INFO);
    registry.register_type(BURSTINTERVAL_TYPE_INFO);
    registry.register_type(BURSTINTERVAL_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGDATA_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSWEEPAREASETTINGS_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSWEEPAREASETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSTATE_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSTATE_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGFIRESTYLE_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGFIRESTYLE_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSWEEPAREASTATE_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSWEEPAREASTATE_ARRAY_TYPE_INFO);
    registry.register_type(FIRINGINTERVALPATTERN_TYPE_INFO);
    registry.register_type(FIRINGINTERVALPATTERN_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEAIMERSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLEAIMERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(INTERVAL_TYPE_INFO);
    registry.register_type(INTERVAL_ARRAY_TYPE_INFO);
    registry.register_type(VOPRIMARYFIRETYPE_TYPE_INFO);
    registry.register_type(VOPRIMARYFIRETYPE_ARRAY_TYPE_INFO);
    registry.register_type(COMBATENVIRONMENT_TYPE_INFO);
    registry.register_type(COMBATENVIRONMENT_ARRAY_TYPE_INFO);
    registry.register_type(TARGETPREFERENCE_TYPE_INFO);
    registry.register_type(TARGETPREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(VALIDAGAINST_TYPE_INFO);
    registry.register_type(VALIDAGAINST_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLECOMBATENTITYDATA_TYPE_INFO);
    registry.register_type(AIVEHICLECOMBATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECOMBATSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLECOMBATSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEVSVEHICLE_TYPE_INFO);
    registry.register_type(VEHICLEVSVEHICLE_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEVSSOLDIER_TYPE_INFO);
    registry.register_type(VEHICLEVSSOLDIER_ARRAY_TYPE_INFO);
    registry.register_type(EVADESETTINGS_TYPE_INFO);
    registry.register_type(EVADESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COMBATSETTINGS_TYPE_INFO);
    registry.register_type(COMBATSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(DISTANCES_TYPE_INFO);
    registry.register_type(DISTANCES_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLEAIMINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIVEHICLEAIMINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLEAIMINGCONSTRAINTS_TYPE_INFO);
    registry.register_type(AIVEHICLEAIMINGCONSTRAINTS_ARRAY_TYPE_INFO);
    registry.register_type(AISERVERTARGETCOMPONENTTEAMCHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(AISERVERTARGETCOMPONENTDESTROYEDMESSAGE_TYPE_INFO);
    registry.register_type(AISERVERTARGETCOMPONENTSPAWNEDMESSAGE_TYPE_INFO);
    registry.register_type(AITARGETCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AITARGETCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISYSTEMENTITYDATA_TYPE_INFO);
    registry.register_type(AISYSTEMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHFINDINGREPATHREQUIREDMESSAGE_TYPE_INFO);
    registry.register_type(AIPATHFINDINGPATHFINDERSREGISTEREDMESSAGE_TYPE_INFO);
    registry.register_type(AIPATHFINDINGINITIALIZEDMESSAGE_TYPE_INFO);
    registry.register_type(BATTLEAISETTINGS_TYPE_INFO);
    registry.register_type(BATTLEAISETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAISYSTEMDATA_TYPE_INFO);
    registry.register_type(BATTLEAISYSTEMDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALERTNESSDATA_TYPE_INFO);
    registry.register_type(ALERTNESSDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROJECTILEDATA_TYPE_INFO);
    registry.register_type(PROJECTILEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREABOOKINGSETTINGS_TYPE_INFO);
    registry.register_type(AREABOOKINGSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SQUADENGAGEDATA_TYPE_INFO);
    registry.register_type(SQUADENGAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHOOTINGDATA_TYPE_INFO);
    registry.register_type(SHOOTINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISUPPRESSWEAPONFIRINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AISUPPRESSWEAPONFIRINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIGLOBALENGAGESTATE_TYPE_INFO);
    registry.register_type(AIGLOBALENGAGESTATE_ARRAY_TYPE_INFO);
    registry.register_type(AISTATEENTITYDATA_TYPE_INFO);
    registry.register_type(AISTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISUPPRESSIONSTATE_TYPE_INFO);
    registry.register_type(AISUPPRESSIONSTATE_ARRAY_TYPE_INFO);
    registry.register_type(AISPOTTINGPOTENTIALMESSAGE_TYPE_INFO);
    registry.register_type(AISPOTTINGFOUNDMESSAGE_TYPE_INFO);
    registry.register_type(AISPOTTINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AISPOTTINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOCOMPACTIONSIGNALMESSAGE_TYPE_INFO);
    registry.register_type(AILOCOCOMPEXITANIMATIONMESSAGE_TYPE_INFO);
    registry.register_type(AILOCOCOMPENTERANIMATIONMESSAGE_TYPE_INFO);
    registry.register_type(AIWAYPOINTSSHAPEDATA_TYPE_INFO);
    registry.register_type(AIWAYPOINTSSHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AILOCOCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANDARDMOVEWAYPOINTDATA_TYPE_INFO);
    registry.register_type(STANDARDMOVEWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VAULTWAYPOINTDATA_TYPE_INFO);
    registry.register_type(VAULTWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERWAYPOINTDATA_TYPE_INFO);
    registry.register_type(COVERWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCENARIOWAYPOINTDATA_TYPE_INFO);
    registry.register_type(SCENARIOWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO);
    registry.register_type(ABSTRACTLOCOWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCENARIOTASKDATA_TYPE_INFO);
    registry.register_type(SCENARIOTASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOCOVERTASKDATA_TYPE_INFO);
    registry.register_type(AILOCOCOVERTASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERSIDESTEPFUTUREPOSE_TYPE_INFO);
    registry.register_type(COVERSIDESTEPFUTUREPOSE_ARRAY_TYPE_INFO);
    registry.register_type(COVERSIDESTEPDIRECTION_TYPE_INFO);
    registry.register_type(COVERSIDESTEPDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(COVERHOVERDIRECTION_TYPE_INFO);
    registry.register_type(COVERHOVERDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(AIEXTRACOVERANIMATIONDATA_TYPE_INFO);
    registry.register_type(AIEXTRACOVERANIMATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVEREXITSTYLE_TYPE_INFO);
    registry.register_type(COVEREXITSTYLE_ARRAY_TYPE_INFO);
    registry.register_type(COVERENTERSTRATEGY_TYPE_INFO);
    registry.register_type(COVERENTERSTRATEGY_ARRAY_TYPE_INFO);
    registry.register_type(COVERIDLETYPE_TYPE_INFO);
    registry.register_type(COVERIDLETYPE_ARRAY_TYPE_INFO);
    registry.register_type(COVERPEEKTYPE_TYPE_INFO);
    registry.register_type(COVERPEEKTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ANTCOVERFIRETYPE_TYPE_INFO);
    registry.register_type(ANTCOVERFIRETYPE_ARRAY_TYPE_INFO);
    registry.register_type(COVERFIRETYPE_TYPE_INFO);
    registry.register_type(COVERFIRETYPE_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOBASETASKDATA_TYPE_INFO);
    registry.register_type(AILOCOBASETASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOMOVETASKDATA_TYPE_INFO);
    registry.register_type(AILOCOMOVETASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOVAULTTASKDATA_TYPE_INFO);
    registry.register_type(AILOCOVAULTTASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTSPEEDLEVEL_TYPE_INFO);
    registry.register_type(ANTSPEEDLEVEL_ARRAY_TYPE_INFO);
    registry.register_type(ANTATTENTIONSTATEENUM_TYPE_INFO);
    registry.register_type(ANTATTENTIONSTATEENUM_ARRAY_TYPE_INFO);
    registry.register_type(ANTCOVERENUM_TYPE_INFO);
    registry.register_type(ANTCOVERENUM_ARRAY_TYPE_INFO);
    registry.register_type(ANTPOSEENUM_TYPE_INFO);
    registry.register_type(ANTPOSEENUM_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOCOVERBINDING_TYPE_INFO);
    registry.register_type(AILOCOCOVERBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOVAULTBINDING_TYPE_INFO);
    registry.register_type(AILOCOVAULTBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOBINDING_TYPE_INFO);
    registry.register_type(AILOCOBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIKILLCOUNTERENTITYDATA_TYPE_INFO);
    registry.register_type(AIKILLCOUNTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIENCOUNTERMANAGERENTITYDATA_TYPE_INFO);
    registry.register_type(AIENCOUNTERMANAGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENCOUNTERCONFIG_TYPE_INFO);
    registry.register_type(ENCOUNTERCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(ENCOUNTERZONECONFIG_TYPE_INFO);
    registry.register_type(ENCOUNTERZONECONFIG_ARRAY_TYPE_INFO);
    registry.register_type(SERVERENCOUNTERMANAGERREMOVEDMESSAGE_TYPE_INFO);
    registry.register_type(AIDYNAMICCONCEALMENTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIDYNAMICCONCEALMENTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICCONCEALMENTCONDITION_TYPE_INFO);
    registry.register_type(DYNAMICCONCEALMENTCONDITION_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICCONCEALMENTORIGIN_TYPE_INFO);
    registry.register_type(DYNAMICCONCEALMENTORIGIN_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERCHANNELDATA_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERBINDING_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIDEBUGPROXYDATA_TYPE_INFO);
    registry.register_type(AIDEBUGPROXYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICUSTOMINPUTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AICUSTOMINPUTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIINPUTACTION_TYPE_INFO);
    registry.register_type(AIINPUTACTION_ARRAY_TYPE_INFO);
    registry.register_type(TARGETCOORDINATIONGLOBALSETTINGS_TYPE_INFO);
    registry.register_type(TARGETCOORDINATIONGLOBALSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(AICOLLISIONAVOIDANCESETUPENTITYDATA_TYPE_INFO);
    registry.register_type(AICOLLISIONAVOIDANCESETUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIBUCKETSYSTEMCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIBUCKETSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIBLOCKERENTITYDATA_TYPE_INFO);
    registry.register_type(AIBLOCKERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIANCHORTOPOINTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIANCHORTOPOINTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIANCHORSTATETRANSITION_TYPE_INFO);
    registry.register_type(AIANCHORSTATETRANSITION_ARRAY_TYPE_INFO);
    registry.register_type(ANCHORTOPOINTBINDING_TYPE_INFO);
    registry.register_type(ANCHORTOPOINTBINDING_ARRAY_TYPE_INFO);
}

#[derive(Clone, Debug, Default)]
pub struct AISoundEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub sound_params: AISound,
    pub send_once: bool,
}

pub trait AISoundEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn sound_params(&self) -> &AISound;
    fn sound_params_mut(&mut self) -> &mut AISound;
    fn send_once(&self) -> &bool;
    fn send_once_mut(&mut self) -> &mut bool;
}

impl AISoundEntityDataTrait for AISoundEntityData {
    fn sound_params(&self) -> &AISound {
        &self.sound_params
    }
    fn sound_params_mut(&mut self) -> &mut AISound {
        &mut self.sound_params
    }
    fn send_once(&self) -> &bool {
        &self.send_once
    }
    fn send_once_mut(&mut self) -> &mut bool {
        &mut self.send_once
    }
}

impl super::entity::SpatialEntityDataTrait for AISoundEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for AISoundEntityData {
}

impl super::entity::GameObjectDataTrait for AISoundEntityData {
}

impl super::core::DataBusPeerTrait for AISoundEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AISoundEntityData {
}

impl super::core::DataContainerTrait for AISoundEntityData {
}

pub static AISOUNDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISoundEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoundParams",
                flags: MemberInfoFlags::new(0),
                field_type: "AISound",
                rust_offset: offset_of!(AISoundEntityData, sound_params),
            },
            FieldInfoData {
                name: "SendOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AISoundEntityData, send_once),
            },
        ],
    }),
    array_type: Some(AISOUNDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AISoundEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AISOUNDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISOUNDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoundEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISoundDefaults {
    pub sounds: Vec<AISound>,
}

pub trait AISoundDefaultsTrait: TypeObject {
    fn sounds(&self) -> &Vec<AISound>;
    fn sounds_mut(&mut self) -> &mut Vec<AISound>;
}

impl AISoundDefaultsTrait for AISoundDefaults {
    fn sounds(&self) -> &Vec<AISound> {
        &self.sounds
    }
    fn sounds_mut(&mut self) -> &mut Vec<AISound> {
        &mut self.sounds
    }
}

pub static AISOUNDDEFAULTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundDefaults",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISoundDefaults as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Sounds",
                flags: MemberInfoFlags::new(144),
                field_type: "AISound-Array",
                rust_offset: offset_of!(AISoundDefaults, sounds),
            },
        ],
    }),
    array_type: Some(AISOUNDDEFAULTS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISoundDefaults {
    fn type_info(&self) -> &'static TypeInfo {
        AISOUNDDEFAULTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AISOUNDDEFAULTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundDefaults-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoundDefaults"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISound {
    pub sound_type: AISoundType,
    pub radius: f32,
    pub occlusion_radius: f32,
    pub occlusion_factor: f32,
    pub temperature: u8,
    pub priority: u8,
    pub volume: u8,
    pub max_investigators: u8,
    pub temperature_distance: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
}

pub trait AISoundTrait: TypeObject {
    fn sound_type(&self) -> &AISoundType;
    fn sound_type_mut(&mut self) -> &mut AISoundType;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn occlusion_radius(&self) -> &f32;
    fn occlusion_radius_mut(&mut self) -> &mut f32;
    fn occlusion_factor(&self) -> &f32;
    fn occlusion_factor_mut(&mut self) -> &mut f32;
    fn temperature(&self) -> &u8;
    fn temperature_mut(&mut self) -> &mut u8;
    fn priority(&self) -> &u8;
    fn priority_mut(&mut self) -> &mut u8;
    fn volume(&self) -> &u8;
    fn volume_mut(&mut self) -> &mut u8;
    fn max_investigators(&self) -> &u8;
    fn max_investigators_mut(&mut self) -> &mut u8;
    fn temperature_distance(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn temperature_distance_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
}

impl AISoundTrait for AISound {
    fn sound_type(&self) -> &AISoundType {
        &self.sound_type
    }
    fn sound_type_mut(&mut self) -> &mut AISoundType {
        &mut self.sound_type
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn occlusion_radius(&self) -> &f32 {
        &self.occlusion_radius
    }
    fn occlusion_radius_mut(&mut self) -> &mut f32 {
        &mut self.occlusion_radius
    }
    fn occlusion_factor(&self) -> &f32 {
        &self.occlusion_factor
    }
    fn occlusion_factor_mut(&mut self) -> &mut f32 {
        &mut self.occlusion_factor
    }
    fn temperature(&self) -> &u8 {
        &self.temperature
    }
    fn temperature_mut(&mut self) -> &mut u8 {
        &mut self.temperature
    }
    fn priority(&self) -> &u8 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut u8 {
        &mut self.priority
    }
    fn volume(&self) -> &u8 {
        &self.volume
    }
    fn volume_mut(&mut self) -> &mut u8 {
        &mut self.volume
    }
    fn max_investigators(&self) -> &u8 {
        &self.max_investigators
    }
    fn max_investigators_mut(&mut self) -> &mut u8 {
        &mut self.max_investigators
    }
    fn temperature_distance(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.temperature_distance
    }
    fn temperature_distance_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.temperature_distance
    }
}

pub static AISOUND_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISound",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISound as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoundType",
                flags: MemberInfoFlags::new(0),
                field_type: "AISoundType",
                rust_offset: offset_of!(AISound, sound_type),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISound, radius),
            },
            FieldInfoData {
                name: "OcclusionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISound, occlusion_radius),
            },
            FieldInfoData {
                name: "OcclusionFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISound, occlusion_factor),
            },
            FieldInfoData {
                name: "Temperature",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(AISound, temperature),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(AISound, priority),
            },
            FieldInfoData {
                name: "Volume",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(AISound, volume),
            },
            FieldInfoData {
                name: "MaxInvestigators",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(AISound, max_investigators),
            },
            FieldInfoData {
                name: "TemperatureDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(AISound, temperature_distance),
            },
        ],
    }),
    array_type: Some(AISOUND_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISound {
    fn type_info(&self) -> &'static TypeInfo {
        AISOUND_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AISOUND_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISound-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISound"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AISoundType {
    #[default]
    AISoundType_Invalid = 0,
    AISoundType_None = 1,
    AISoundType_Gunshot = 2,
    AISoundType_Impact = 3,
    AISoundType_Background = 4,
    AISoundType_Distraction = 5,
    AISoundType_Pain = 6,
    AISoundType_Death = 7,
    AISoundType_Footstep = 8,
    AISoundType_Body = 9,
    AISoundType_FallImpact = 10,
    AISoundType_Explosion = 11,
    AISoundType_BrokenByShot = 12,
    AISoundType_FootstepQuiet = 13,
    AISoundType_Search = 14,
    AISoundType_Vehicle = 15,
    AISoundType_GunshotSilenced = 16,
    AISoundType_Noise = 17,
    AISoundType_VehicleQuiet = 18,
    AISoundType_Broadcast_Searching = 19,
    AISoundType_Broadcast_Alerted = 20,
    AISoundType_MaxTypes = 21,
}

pub static AISOUNDTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AISOUNDTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AISoundType {
    fn type_info(&self) -> &'static TypeInfo {
        AISOUNDTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AISOUNDTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoundType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISoldierSpawnTemplateData {
    pub _glacier_base: super::game_shared::CharacterSpawnTemplateData,
    pub tactics: Option<Arc<Mutex<dyn SoldierTacticsTrait>>>,
    pub projectile: Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>,
    pub melee: Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>,
    pub soldier_melee_type: SoldierMeleeType,
    pub allow_hover_from_cover: bool,
    pub cover_zones_override: Option<Arc<Mutex<dyn CoverZonesTrait>>>,
    pub fire_height_offset: f32,
    pub npc_unique_id: i32,
    pub alert_propagation_speed: f32,
    pub allow_a_i_alert_enemy_team: bool,
    pub target_lost_time: f32,
    pub extrapolate_after_l_o_s_lost_time: f32,
    pub allowed_to_be_melee_charge_target: bool,
    pub physics_loco_settings: Option<Arc<Mutex<dyn PhysicsLocoSettingsTrait>>>,
    pub character_customization_asset: Option<Arc<Mutex<dyn super::game_shared::CharacterCustomizationAssetTrait>>>,
}

pub trait AISoldierSpawnTemplateDataTrait: super::game_shared::CharacterSpawnTemplateDataTrait {
    fn tactics(&self) -> &Option<Arc<Mutex<dyn SoldierTacticsTrait>>>;
    fn tactics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierTacticsTrait>>>;
    fn projectile(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn projectile_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn melee(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn melee_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn soldier_melee_type(&self) -> &SoldierMeleeType;
    fn soldier_melee_type_mut(&mut self) -> &mut SoldierMeleeType;
    fn allow_hover_from_cover(&self) -> &bool;
    fn allow_hover_from_cover_mut(&mut self) -> &mut bool;
    fn cover_zones_override(&self) -> &Option<Arc<Mutex<dyn CoverZonesTrait>>>;
    fn cover_zones_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZonesTrait>>>;
    fn fire_height_offset(&self) -> &f32;
    fn fire_height_offset_mut(&mut self) -> &mut f32;
    fn npc_unique_id(&self) -> &i32;
    fn npc_unique_id_mut(&mut self) -> &mut i32;
    fn alert_propagation_speed(&self) -> &f32;
    fn alert_propagation_speed_mut(&mut self) -> &mut f32;
    fn allow_a_i_alert_enemy_team(&self) -> &bool;
    fn allow_a_i_alert_enemy_team_mut(&mut self) -> &mut bool;
    fn target_lost_time(&self) -> &f32;
    fn target_lost_time_mut(&mut self) -> &mut f32;
    fn extrapolate_after_l_o_s_lost_time(&self) -> &f32;
    fn extrapolate_after_l_o_s_lost_time_mut(&mut self) -> &mut f32;
    fn allowed_to_be_melee_charge_target(&self) -> &bool;
    fn allowed_to_be_melee_charge_target_mut(&mut self) -> &mut bool;
    fn physics_loco_settings(&self) -> &Option<Arc<Mutex<dyn PhysicsLocoSettingsTrait>>>;
    fn physics_loco_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PhysicsLocoSettingsTrait>>>;
    fn character_customization_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CharacterCustomizationAssetTrait>>>;
    fn character_customization_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CharacterCustomizationAssetTrait>>>;
}

impl AISoldierSpawnTemplateDataTrait for AISoldierSpawnTemplateData {
    fn tactics(&self) -> &Option<Arc<Mutex<dyn SoldierTacticsTrait>>> {
        &self.tactics
    }
    fn tactics_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoldierTacticsTrait>>> {
        &mut self.tactics
    }
    fn projectile(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &self.projectile
    }
    fn projectile_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &mut self.projectile
    }
    fn melee(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &self.melee
    }
    fn melee_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &mut self.melee
    }
    fn soldier_melee_type(&self) -> &SoldierMeleeType {
        &self.soldier_melee_type
    }
    fn soldier_melee_type_mut(&mut self) -> &mut SoldierMeleeType {
        &mut self.soldier_melee_type
    }
    fn allow_hover_from_cover(&self) -> &bool {
        &self.allow_hover_from_cover
    }
    fn allow_hover_from_cover_mut(&mut self) -> &mut bool {
        &mut self.allow_hover_from_cover
    }
    fn cover_zones_override(&self) -> &Option<Arc<Mutex<dyn CoverZonesTrait>>> {
        &self.cover_zones_override
    }
    fn cover_zones_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZonesTrait>>> {
        &mut self.cover_zones_override
    }
    fn fire_height_offset(&self) -> &f32 {
        &self.fire_height_offset
    }
    fn fire_height_offset_mut(&mut self) -> &mut f32 {
        &mut self.fire_height_offset
    }
    fn npc_unique_id(&self) -> &i32 {
        &self.npc_unique_id
    }
    fn npc_unique_id_mut(&mut self) -> &mut i32 {
        &mut self.npc_unique_id
    }
    fn alert_propagation_speed(&self) -> &f32 {
        &self.alert_propagation_speed
    }
    fn alert_propagation_speed_mut(&mut self) -> &mut f32 {
        &mut self.alert_propagation_speed
    }
    fn allow_a_i_alert_enemy_team(&self) -> &bool {
        &self.allow_a_i_alert_enemy_team
    }
    fn allow_a_i_alert_enemy_team_mut(&mut self) -> &mut bool {
        &mut self.allow_a_i_alert_enemy_team
    }
    fn target_lost_time(&self) -> &f32 {
        &self.target_lost_time
    }
    fn target_lost_time_mut(&mut self) -> &mut f32 {
        &mut self.target_lost_time
    }
    fn extrapolate_after_l_o_s_lost_time(&self) -> &f32 {
        &self.extrapolate_after_l_o_s_lost_time
    }
    fn extrapolate_after_l_o_s_lost_time_mut(&mut self) -> &mut f32 {
        &mut self.extrapolate_after_l_o_s_lost_time
    }
    fn allowed_to_be_melee_charge_target(&self) -> &bool {
        &self.allowed_to_be_melee_charge_target
    }
    fn allowed_to_be_melee_charge_target_mut(&mut self) -> &mut bool {
        &mut self.allowed_to_be_melee_charge_target
    }
    fn physics_loco_settings(&self) -> &Option<Arc<Mutex<dyn PhysicsLocoSettingsTrait>>> {
        &self.physics_loco_settings
    }
    fn physics_loco_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PhysicsLocoSettingsTrait>>> {
        &mut self.physics_loco_settings
    }
    fn character_customization_asset(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CharacterCustomizationAssetTrait>>> {
        &self.character_customization_asset
    }
    fn character_customization_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CharacterCustomizationAssetTrait>>> {
        &mut self.character_customization_asset
    }
}

impl super::game_shared::CharacterSpawnTemplateDataTrait for AISoldierSpawnTemplateData {
    fn customize_character_data(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CustomizeCharacterDataTrait>>> {
        self._glacier_base.customize_character_data()
    }
    fn customize_character_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CustomizeCharacterDataTrait>>> {
        self._glacier_base.customize_character_data_mut()
    }
    fn sensing(&self) -> &Option<Arc<Mutex<dyn super::game_shared::GameSensingTemplateDataTrait>>> {
        self._glacier_base.sensing()
    }
    fn sensing_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::GameSensingTemplateDataTrait>>> {
        self._glacier_base.sensing_mut()
    }
    fn behaviour(&self) -> &Option<Arc<Mutex<dyn super::game_shared::GameBehaviourTemplateDataTrait>>> {
        self._glacier_base.behaviour()
    }
    fn behaviour_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::GameBehaviourTemplateDataTrait>>> {
        self._glacier_base.behaviour_mut()
    }
    fn animation_template(&self) -> &Option<Arc<Mutex<dyn super::game_shared::AnimationSpawnTemplateTrait>>> {
        self._glacier_base.animation_template()
    }
    fn animation_template_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::AnimationSpawnTemplateTrait>>> {
        self._glacier_base.animation_template_mut()
    }
    fn voice_over_labels(&self) -> &Vec<Option<Arc<Mutex<dyn super::audio::VoiceOverLabelTrait>>>> {
        self._glacier_base.voice_over_labels()
    }
    fn voice_over_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::audio::VoiceOverLabelTrait>>>> {
        self._glacier_base.voice_over_labels_mut()
    }
}

impl super::core::AssetTrait for AISoldierSpawnTemplateData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AISoldierSpawnTemplateData {
}

pub static AISOLDIERSPAWNTEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoldierSpawnTemplateData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::CHARACTERSPAWNTEMPLATEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISoldierSpawnTemplateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Tactics",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierTactics",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, tactics),
            },
            FieldInfoData {
                name: "Projectile",
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, projectile),
            },
            FieldInfoData {
                name: "Melee",
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, melee),
            },
            FieldInfoData {
                name: "SoldierMeleeType",
                flags: MemberInfoFlags::new(0),
                field_type: "SoldierMeleeType",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, soldier_melee_type),
            },
            FieldInfoData {
                name: "AllowHoverFromCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, allow_hover_from_cover),
            },
            FieldInfoData {
                name: "CoverZonesOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverZones",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, cover_zones_override),
            },
            FieldInfoData {
                name: "FireHeightOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, fire_height_offset),
            },
            FieldInfoData {
                name: "NpcUniqueId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, npc_unique_id),
            },
            FieldInfoData {
                name: "AlertPropagationSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, alert_propagation_speed),
            },
            FieldInfoData {
                name: "AllowAIAlertEnemyTeam",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, allow_a_i_alert_enemy_team),
            },
            FieldInfoData {
                name: "TargetLostTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, target_lost_time),
            },
            FieldInfoData {
                name: "ExtrapolateAfterLOSLostTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, extrapolate_after_l_o_s_lost_time),
            },
            FieldInfoData {
                name: "AllowedToBeMeleeChargeTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, allowed_to_be_melee_charge_target),
            },
            FieldInfoData {
                name: "PhysicsLocoSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "PhysicsLocoSettings",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, physics_loco_settings),
            },
            FieldInfoData {
                name: "CharacterCustomizationAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterCustomizationAsset",
                rust_offset: offset_of!(AISoldierSpawnTemplateData, character_customization_asset),
            },
        ],
    }),
    array_type: Some(AISOLDIERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISoldierSpawnTemplateData {
    fn type_info(&self) -> &'static TypeInfo {
        AISOLDIERSPAWNTEMPLATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISOLDIERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoldierSpawnTemplateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoldierSpawnTemplateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoldierMeleeType {
    #[default]
    SoldierMelee_Normal = 0,
    SoldierMelee_MeleeTrooper = 1,
    SoldierMelee_Creature = 2,
}

pub static SOLDIERMELEETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierMeleeType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SOLDIERMELEETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoldierMeleeType {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERMELEETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOLDIERMELEETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierMeleeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SoldierMeleeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsLocoSettings {
    pub _glacier_base: super::core::DataContainer,
    pub mass: f32,
    pub walk_speed: f32,
    pub run_speed: f32,
    pub use_directional_run_speed_blending: bool,
    pub strafe_run_speed: f32,
    pub backward_run_speed: f32,
    pub sprint_multiplier: f32,
    pub track_target_settings: Option<Arc<Mutex<dyn TrackTargetSettingsTrait>>>,
}

pub trait PhysicsLocoSettingsTrait: super::core::DataContainerTrait {
    fn mass(&self) -> &f32;
    fn mass_mut(&mut self) -> &mut f32;
    fn walk_speed(&self) -> &f32;
    fn walk_speed_mut(&mut self) -> &mut f32;
    fn run_speed(&self) -> &f32;
    fn run_speed_mut(&mut self) -> &mut f32;
    fn use_directional_run_speed_blending(&self) -> &bool;
    fn use_directional_run_speed_blending_mut(&mut self) -> &mut bool;
    fn strafe_run_speed(&self) -> &f32;
    fn strafe_run_speed_mut(&mut self) -> &mut f32;
    fn backward_run_speed(&self) -> &f32;
    fn backward_run_speed_mut(&mut self) -> &mut f32;
    fn sprint_multiplier(&self) -> &f32;
    fn sprint_multiplier_mut(&mut self) -> &mut f32;
    fn track_target_settings(&self) -> &Option<Arc<Mutex<dyn TrackTargetSettingsTrait>>>;
    fn track_target_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TrackTargetSettingsTrait>>>;
}

impl PhysicsLocoSettingsTrait for PhysicsLocoSettings {
    fn mass(&self) -> &f32 {
        &self.mass
    }
    fn mass_mut(&mut self) -> &mut f32 {
        &mut self.mass
    }
    fn walk_speed(&self) -> &f32 {
        &self.walk_speed
    }
    fn walk_speed_mut(&mut self) -> &mut f32 {
        &mut self.walk_speed
    }
    fn run_speed(&self) -> &f32 {
        &self.run_speed
    }
    fn run_speed_mut(&mut self) -> &mut f32 {
        &mut self.run_speed
    }
    fn use_directional_run_speed_blending(&self) -> &bool {
        &self.use_directional_run_speed_blending
    }
    fn use_directional_run_speed_blending_mut(&mut self) -> &mut bool {
        &mut self.use_directional_run_speed_blending
    }
    fn strafe_run_speed(&self) -> &f32 {
        &self.strafe_run_speed
    }
    fn strafe_run_speed_mut(&mut self) -> &mut f32 {
        &mut self.strafe_run_speed
    }
    fn backward_run_speed(&self) -> &f32 {
        &self.backward_run_speed
    }
    fn backward_run_speed_mut(&mut self) -> &mut f32 {
        &mut self.backward_run_speed
    }
    fn sprint_multiplier(&self) -> &f32 {
        &self.sprint_multiplier
    }
    fn sprint_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.sprint_multiplier
    }
    fn track_target_settings(&self) -> &Option<Arc<Mutex<dyn TrackTargetSettingsTrait>>> {
        &self.track_target_settings
    }
    fn track_target_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TrackTargetSettingsTrait>>> {
        &mut self.track_target_settings
    }
}

impl super::core::DataContainerTrait for PhysicsLocoSettings {
}

pub static PHYSICSLOCOSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsLocoSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsLocoSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mass",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsLocoSettings, mass),
            },
            FieldInfoData {
                name: "WalkSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsLocoSettings, walk_speed),
            },
            FieldInfoData {
                name: "RunSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsLocoSettings, run_speed),
            },
            FieldInfoData {
                name: "UseDirectionalRunSpeedBlending",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PhysicsLocoSettings, use_directional_run_speed_blending),
            },
            FieldInfoData {
                name: "StrafeRunSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsLocoSettings, strafe_run_speed),
            },
            FieldInfoData {
                name: "BackwardRunSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsLocoSettings, backward_run_speed),
            },
            FieldInfoData {
                name: "SprintMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PhysicsLocoSettings, sprint_multiplier),
            },
            FieldInfoData {
                name: "TrackTargetSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "TrackTargetSettings",
                rust_offset: offset_of!(PhysicsLocoSettings, track_target_settings),
            },
        ],
    }),
    array_type: Some(PHYSICSLOCOSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsLocoSettings {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSLOCOSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHYSICSLOCOSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsLocoSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PhysicsLocoSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TrackTargetSettings {
    pub _glacier_base: super::core::DataContainer,
    pub require_line_of_sight: bool,
    pub lost_line_of_sight_stop_tracking_time: f32,
    pub start_tracking_distance_to_target: f32,
    pub stop_tracking_distance_to_target: f32,
}

pub trait TrackTargetSettingsTrait: super::core::DataContainerTrait {
    fn require_line_of_sight(&self) -> &bool;
    fn require_line_of_sight_mut(&mut self) -> &mut bool;
    fn lost_line_of_sight_stop_tracking_time(&self) -> &f32;
    fn lost_line_of_sight_stop_tracking_time_mut(&mut self) -> &mut f32;
    fn start_tracking_distance_to_target(&self) -> &f32;
    fn start_tracking_distance_to_target_mut(&mut self) -> &mut f32;
    fn stop_tracking_distance_to_target(&self) -> &f32;
    fn stop_tracking_distance_to_target_mut(&mut self) -> &mut f32;
}

impl TrackTargetSettingsTrait for TrackTargetSettings {
    fn require_line_of_sight(&self) -> &bool {
        &self.require_line_of_sight
    }
    fn require_line_of_sight_mut(&mut self) -> &mut bool {
        &mut self.require_line_of_sight
    }
    fn lost_line_of_sight_stop_tracking_time(&self) -> &f32 {
        &self.lost_line_of_sight_stop_tracking_time
    }
    fn lost_line_of_sight_stop_tracking_time_mut(&mut self) -> &mut f32 {
        &mut self.lost_line_of_sight_stop_tracking_time
    }
    fn start_tracking_distance_to_target(&self) -> &f32 {
        &self.start_tracking_distance_to_target
    }
    fn start_tracking_distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.start_tracking_distance_to_target
    }
    fn stop_tracking_distance_to_target(&self) -> &f32 {
        &self.stop_tracking_distance_to_target
    }
    fn stop_tracking_distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.stop_tracking_distance_to_target
    }
}

impl super::core::DataContainerTrait for TrackTargetSettings {
}

pub static TRACKTARGETSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackTargetSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TrackTargetSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RequireLineOfSight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TrackTargetSettings, require_line_of_sight),
            },
            FieldInfoData {
                name: "LostLineOfSightStopTrackingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrackTargetSettings, lost_line_of_sight_stop_tracking_time),
            },
            FieldInfoData {
                name: "StartTrackingDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrackTargetSettings, start_tracking_distance_to_target),
            },
            FieldInfoData {
                name: "StopTrackingDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TrackTargetSettings, stop_tracking_distance_to_target),
            },
        ],
    }),
    array_type: Some(TRACKTARGETSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TrackTargetSettings {
    fn type_info(&self) -> &'static TypeInfo {
        TRACKTARGETSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TRACKTARGETSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackTargetSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TrackTargetSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoldierTactics {
    pub _glacier_base: super::core::Asset,
    pub vehicle: Option<Arc<Mutex<dyn VehicleSettingsTrait>>>,
    pub charge: Option<Arc<Mutex<dyn ChargeSettingsTrait>>>,
    pub berserk: Option<Arc<Mutex<dyn BerserkSettingsTrait>>>,
    pub melee_charge: Option<Arc<Mutex<dyn MeleeChargeSettingsTrait>>>,
    pub close_range_attack: Option<Arc<Mutex<dyn CloseRangeAttackSettingsTrait>>>,
    pub investigate: Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>,
    pub combat_investigate: Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>,
    pub combat_search_area: Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>,
    pub search_area: Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>,
    pub execute_idle_action: Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>>,
    pub execute_search_action: Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>>,
    pub execute_combat_action: Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>>,
    pub attack: Option<Arc<Mutex<dyn AttackSettingsTrait>>>,
    pub hide: Option<Arc<Mutex<dyn HideSettingsTrait>>>,
    pub flee: Option<Arc<Mutex<dyn FleeSettingsTrait>>>,
    pub evade: Option<Arc<Mutex<dyn EvadeBehaviorSettingsTrait>>>,
    pub go_to_attack_point: Option<Arc<Mutex<dyn GoToAttackPointSettingsTrait>>>,
    pub close_combat: Option<Arc<Mutex<dyn CloseCombatSettingsTrait>>>,
    pub follow: Option<Arc<Mutex<dyn FollowSettingsTrait>>>,
    pub go_to_target: Option<Arc<Mutex<dyn GoToTargetSettingsTrait>>>,
    pub squad_movement: Option<Arc<Mutex<dyn SquadMovementSettingsTrait>>>,
    pub squad_engage_settings: Option<Arc<Mutex<dyn SquadEngageSettingsTrait>>>,
    pub engage_settings: EngageSettings,
    pub pick_weapon_settings: Option<Arc<Mutex<dyn PickWeaponSettingsTrait>>>,
    pub weapon_suppression_settings: WeaponSuppressionSettings,
    pub vehicle_suppression_settings: VehicleSuppressionSettings,
    pub targeting_settings: Option<Arc<Mutex<dyn TargetingDataTrait>>>,
    pub secondary_threats: Option<Arc<Mutex<dyn SecondaryThreatSettingsTrait>>>,
}

pub trait SoldierTacticsTrait: super::core::AssetTrait {
    fn vehicle(&self) -> &Option<Arc<Mutex<dyn VehicleSettingsTrait>>>;
    fn vehicle_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleSettingsTrait>>>;
    fn charge(&self) -> &Option<Arc<Mutex<dyn ChargeSettingsTrait>>>;
    fn charge_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ChargeSettingsTrait>>>;
    fn berserk(&self) -> &Option<Arc<Mutex<dyn BerserkSettingsTrait>>>;
    fn berserk_mut(&mut self) -> &mut Option<Arc<Mutex<dyn BerserkSettingsTrait>>>;
    fn melee_charge(&self) -> &Option<Arc<Mutex<dyn MeleeChargeSettingsTrait>>>;
    fn melee_charge_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MeleeChargeSettingsTrait>>>;
    fn close_range_attack(&self) -> &Option<Arc<Mutex<dyn CloseRangeAttackSettingsTrait>>>;
    fn close_range_attack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CloseRangeAttackSettingsTrait>>>;
    fn investigate(&self) -> &Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>;
    fn investigate_mut(&mut self) -> &mut Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>;
    fn combat_investigate(&self) -> &Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>;
    fn combat_investigate_mut(&mut self) -> &mut Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>;
    fn combat_search_area(&self) -> &Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>;
    fn combat_search_area_mut(&mut self) -> &mut Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>;
    fn search_area(&self) -> &Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>;
    fn search_area_mut(&mut self) -> &mut Option<Arc<Mutex<dyn InvestigateSettingsTrait>>>;
    fn execute_idle_action(&self) -> &Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>>;
    fn execute_idle_action_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>>;
    fn execute_search_action(&self) -> &Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>>;
    fn execute_search_action_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>>;
    fn execute_combat_action(&self) -> &Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>>;
    fn execute_combat_action_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>>;
    fn attack(&self) -> &Option<Arc<Mutex<dyn AttackSettingsTrait>>>;
    fn attack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AttackSettingsTrait>>>;
    fn hide(&self) -> &Option<Arc<Mutex<dyn HideSettingsTrait>>>;
    fn hide_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HideSettingsTrait>>>;
    fn flee(&self) -> &Option<Arc<Mutex<dyn FleeSettingsTrait>>>;
    fn flee_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FleeSettingsTrait>>>;
    fn evade(&self) -> &Option<Arc<Mutex<dyn EvadeBehaviorSettingsTrait>>>;
    fn evade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn EvadeBehaviorSettingsTrait>>>;
    fn go_to_attack_point(&self) -> &Option<Arc<Mutex<dyn GoToAttackPointSettingsTrait>>>;
    fn go_to_attack_point_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GoToAttackPointSettingsTrait>>>;
    fn close_combat(&self) -> &Option<Arc<Mutex<dyn CloseCombatSettingsTrait>>>;
    fn close_combat_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CloseCombatSettingsTrait>>>;
    fn follow(&self) -> &Option<Arc<Mutex<dyn FollowSettingsTrait>>>;
    fn follow_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FollowSettingsTrait>>>;
    fn go_to_target(&self) -> &Option<Arc<Mutex<dyn GoToTargetSettingsTrait>>>;
    fn go_to_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GoToTargetSettingsTrait>>>;
    fn squad_movement(&self) -> &Option<Arc<Mutex<dyn SquadMovementSettingsTrait>>>;
    fn squad_movement_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SquadMovementSettingsTrait>>>;
    fn squad_engage_settings(&self) -> &Option<Arc<Mutex<dyn SquadEngageSettingsTrait>>>;
    fn squad_engage_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SquadEngageSettingsTrait>>>;
    fn engage_settings(&self) -> &EngageSettings;
    fn engage_settings_mut(&mut self) -> &mut EngageSettings;
    fn pick_weapon_settings(&self) -> &Option<Arc<Mutex<dyn PickWeaponSettingsTrait>>>;
    fn pick_weapon_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PickWeaponSettingsTrait>>>;
    fn weapon_suppression_settings(&self) -> &WeaponSuppressionSettings;
    fn weapon_suppression_settings_mut(&mut self) -> &mut WeaponSuppressionSettings;
    fn vehicle_suppression_settings(&self) -> &VehicleSuppressionSettings;
    fn vehicle_suppression_settings_mut(&mut self) -> &mut VehicleSuppressionSettings;
    fn targeting_settings(&self) -> &Option<Arc<Mutex<dyn TargetingDataTrait>>>;
    fn targeting_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TargetingDataTrait>>>;
    fn secondary_threats(&self) -> &Option<Arc<Mutex<dyn SecondaryThreatSettingsTrait>>>;
    fn secondary_threats_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SecondaryThreatSettingsTrait>>>;
}

impl SoldierTacticsTrait for SoldierTactics {
    fn vehicle(&self) -> &Option<Arc<Mutex<dyn VehicleSettingsTrait>>> {
        &self.vehicle
    }
    fn vehicle_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleSettingsTrait>>> {
        &mut self.vehicle
    }
    fn charge(&self) -> &Option<Arc<Mutex<dyn ChargeSettingsTrait>>> {
        &self.charge
    }
    fn charge_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ChargeSettingsTrait>>> {
        &mut self.charge
    }
    fn berserk(&self) -> &Option<Arc<Mutex<dyn BerserkSettingsTrait>>> {
        &self.berserk
    }
    fn berserk_mut(&mut self) -> &mut Option<Arc<Mutex<dyn BerserkSettingsTrait>>> {
        &mut self.berserk
    }
    fn melee_charge(&self) -> &Option<Arc<Mutex<dyn MeleeChargeSettingsTrait>>> {
        &self.melee_charge
    }
    fn melee_charge_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MeleeChargeSettingsTrait>>> {
        &mut self.melee_charge
    }
    fn close_range_attack(&self) -> &Option<Arc<Mutex<dyn CloseRangeAttackSettingsTrait>>> {
        &self.close_range_attack
    }
    fn close_range_attack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CloseRangeAttackSettingsTrait>>> {
        &mut self.close_range_attack
    }
    fn investigate(&self) -> &Option<Arc<Mutex<dyn InvestigateSettingsTrait>>> {
        &self.investigate
    }
    fn investigate_mut(&mut self) -> &mut Option<Arc<Mutex<dyn InvestigateSettingsTrait>>> {
        &mut self.investigate
    }
    fn combat_investigate(&self) -> &Option<Arc<Mutex<dyn InvestigateSettingsTrait>>> {
        &self.combat_investigate
    }
    fn combat_investigate_mut(&mut self) -> &mut Option<Arc<Mutex<dyn InvestigateSettingsTrait>>> {
        &mut self.combat_investigate
    }
    fn combat_search_area(&self) -> &Option<Arc<Mutex<dyn InvestigateSettingsTrait>>> {
        &self.combat_search_area
    }
    fn combat_search_area_mut(&mut self) -> &mut Option<Arc<Mutex<dyn InvestigateSettingsTrait>>> {
        &mut self.combat_search_area
    }
    fn search_area(&self) -> &Option<Arc<Mutex<dyn InvestigateSettingsTrait>>> {
        &self.search_area
    }
    fn search_area_mut(&mut self) -> &mut Option<Arc<Mutex<dyn InvestigateSettingsTrait>>> {
        &mut self.search_area
    }
    fn execute_idle_action(&self) -> &Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>> {
        &self.execute_idle_action
    }
    fn execute_idle_action_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>> {
        &mut self.execute_idle_action
    }
    fn execute_search_action(&self) -> &Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>> {
        &self.execute_search_action
    }
    fn execute_search_action_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>> {
        &mut self.execute_search_action
    }
    fn execute_combat_action(&self) -> &Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>> {
        &self.execute_combat_action
    }
    fn execute_combat_action_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ExecuteActionSettingsTrait>>> {
        &mut self.execute_combat_action
    }
    fn attack(&self) -> &Option<Arc<Mutex<dyn AttackSettingsTrait>>> {
        &self.attack
    }
    fn attack_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AttackSettingsTrait>>> {
        &mut self.attack
    }
    fn hide(&self) -> &Option<Arc<Mutex<dyn HideSettingsTrait>>> {
        &self.hide
    }
    fn hide_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HideSettingsTrait>>> {
        &mut self.hide
    }
    fn flee(&self) -> &Option<Arc<Mutex<dyn FleeSettingsTrait>>> {
        &self.flee
    }
    fn flee_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FleeSettingsTrait>>> {
        &mut self.flee
    }
    fn evade(&self) -> &Option<Arc<Mutex<dyn EvadeBehaviorSettingsTrait>>> {
        &self.evade
    }
    fn evade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn EvadeBehaviorSettingsTrait>>> {
        &mut self.evade
    }
    fn go_to_attack_point(&self) -> &Option<Arc<Mutex<dyn GoToAttackPointSettingsTrait>>> {
        &self.go_to_attack_point
    }
    fn go_to_attack_point_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GoToAttackPointSettingsTrait>>> {
        &mut self.go_to_attack_point
    }
    fn close_combat(&self) -> &Option<Arc<Mutex<dyn CloseCombatSettingsTrait>>> {
        &self.close_combat
    }
    fn close_combat_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CloseCombatSettingsTrait>>> {
        &mut self.close_combat
    }
    fn follow(&self) -> &Option<Arc<Mutex<dyn FollowSettingsTrait>>> {
        &self.follow
    }
    fn follow_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FollowSettingsTrait>>> {
        &mut self.follow
    }
    fn go_to_target(&self) -> &Option<Arc<Mutex<dyn GoToTargetSettingsTrait>>> {
        &self.go_to_target
    }
    fn go_to_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn GoToTargetSettingsTrait>>> {
        &mut self.go_to_target
    }
    fn squad_movement(&self) -> &Option<Arc<Mutex<dyn SquadMovementSettingsTrait>>> {
        &self.squad_movement
    }
    fn squad_movement_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SquadMovementSettingsTrait>>> {
        &mut self.squad_movement
    }
    fn squad_engage_settings(&self) -> &Option<Arc<Mutex<dyn SquadEngageSettingsTrait>>> {
        &self.squad_engage_settings
    }
    fn squad_engage_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SquadEngageSettingsTrait>>> {
        &mut self.squad_engage_settings
    }
    fn engage_settings(&self) -> &EngageSettings {
        &self.engage_settings
    }
    fn engage_settings_mut(&mut self) -> &mut EngageSettings {
        &mut self.engage_settings
    }
    fn pick_weapon_settings(&self) -> &Option<Arc<Mutex<dyn PickWeaponSettingsTrait>>> {
        &self.pick_weapon_settings
    }
    fn pick_weapon_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PickWeaponSettingsTrait>>> {
        &mut self.pick_weapon_settings
    }
    fn weapon_suppression_settings(&self) -> &WeaponSuppressionSettings {
        &self.weapon_suppression_settings
    }
    fn weapon_suppression_settings_mut(&mut self) -> &mut WeaponSuppressionSettings {
        &mut self.weapon_suppression_settings
    }
    fn vehicle_suppression_settings(&self) -> &VehicleSuppressionSettings {
        &self.vehicle_suppression_settings
    }
    fn vehicle_suppression_settings_mut(&mut self) -> &mut VehicleSuppressionSettings {
        &mut self.vehicle_suppression_settings
    }
    fn targeting_settings(&self) -> &Option<Arc<Mutex<dyn TargetingDataTrait>>> {
        &self.targeting_settings
    }
    fn targeting_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TargetingDataTrait>>> {
        &mut self.targeting_settings
    }
    fn secondary_threats(&self) -> &Option<Arc<Mutex<dyn SecondaryThreatSettingsTrait>>> {
        &self.secondary_threats
    }
    fn secondary_threats_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SecondaryThreatSettingsTrait>>> {
        &mut self.secondary_threats
    }
}

impl super::core::AssetTrait for SoldierTactics {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoldierTactics {
}

pub static SOLDIERTACTICS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierTactics",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoldierTactics as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Vehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleSettings",
                rust_offset: offset_of!(SoldierTactics, vehicle),
            },
            FieldInfoData {
                name: "Charge",
                flags: MemberInfoFlags::new(0),
                field_type: "ChargeSettings",
                rust_offset: offset_of!(SoldierTactics, charge),
            },
            FieldInfoData {
                name: "Berserk",
                flags: MemberInfoFlags::new(0),
                field_type: "BerserkSettings",
                rust_offset: offset_of!(SoldierTactics, berserk),
            },
            FieldInfoData {
                name: "MeleeCharge",
                flags: MemberInfoFlags::new(0),
                field_type: "MeleeChargeSettings",
                rust_offset: offset_of!(SoldierTactics, melee_charge),
            },
            FieldInfoData {
                name: "CloseRangeAttack",
                flags: MemberInfoFlags::new(0),
                field_type: "CloseRangeAttackSettings",
                rust_offset: offset_of!(SoldierTactics, close_range_attack),
            },
            FieldInfoData {
                name: "Investigate",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettings",
                rust_offset: offset_of!(SoldierTactics, investigate),
            },
            FieldInfoData {
                name: "CombatInvestigate",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettings",
                rust_offset: offset_of!(SoldierTactics, combat_investigate),
            },
            FieldInfoData {
                name: "CombatSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettings",
                rust_offset: offset_of!(SoldierTactics, combat_search_area),
            },
            FieldInfoData {
                name: "SearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettings",
                rust_offset: offset_of!(SoldierTactics, search_area),
            },
            FieldInfoData {
                name: "ExecuteIdleAction",
                flags: MemberInfoFlags::new(0),
                field_type: "ExecuteActionSettings",
                rust_offset: offset_of!(SoldierTactics, execute_idle_action),
            },
            FieldInfoData {
                name: "ExecuteSearchAction",
                flags: MemberInfoFlags::new(0),
                field_type: "ExecuteActionSettings",
                rust_offset: offset_of!(SoldierTactics, execute_search_action),
            },
            FieldInfoData {
                name: "ExecuteCombatAction",
                flags: MemberInfoFlags::new(0),
                field_type: "ExecuteActionSettings",
                rust_offset: offset_of!(SoldierTactics, execute_combat_action),
            },
            FieldInfoData {
                name: "Attack",
                flags: MemberInfoFlags::new(0),
                field_type: "AttackSettings",
                rust_offset: offset_of!(SoldierTactics, attack),
            },
            FieldInfoData {
                name: "Hide",
                flags: MemberInfoFlags::new(0),
                field_type: "HideSettings",
                rust_offset: offset_of!(SoldierTactics, hide),
            },
            FieldInfoData {
                name: "Flee",
                flags: MemberInfoFlags::new(0),
                field_type: "FleeSettings",
                rust_offset: offset_of!(SoldierTactics, flee),
            },
            FieldInfoData {
                name: "Evade",
                flags: MemberInfoFlags::new(0),
                field_type: "EvadeBehaviorSettings",
                rust_offset: offset_of!(SoldierTactics, evade),
            },
            FieldInfoData {
                name: "GoToAttackPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "GoToAttackPointSettings",
                rust_offset: offset_of!(SoldierTactics, go_to_attack_point),
            },
            FieldInfoData {
                name: "CloseCombat",
                flags: MemberInfoFlags::new(0),
                field_type: "CloseCombatSettings",
                rust_offset: offset_of!(SoldierTactics, close_combat),
            },
            FieldInfoData {
                name: "Follow",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowSettings",
                rust_offset: offset_of!(SoldierTactics, follow),
            },
            FieldInfoData {
                name: "GoToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "GoToTargetSettings",
                rust_offset: offset_of!(SoldierTactics, go_to_target),
            },
            FieldInfoData {
                name: "SquadMovement",
                flags: MemberInfoFlags::new(0),
                field_type: "SquadMovementSettings",
                rust_offset: offset_of!(SoldierTactics, squad_movement),
            },
            FieldInfoData {
                name: "SquadEngageSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "SquadEngageSettings",
                rust_offset: offset_of!(SoldierTactics, squad_engage_settings),
            },
            FieldInfoData {
                name: "EngageSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "EngageSettings",
                rust_offset: offset_of!(SoldierTactics, engage_settings),
            },
            FieldInfoData {
                name: "PickWeaponSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "PickWeaponSettings",
                rust_offset: offset_of!(SoldierTactics, pick_weapon_settings),
            },
            FieldInfoData {
                name: "WeaponSuppressionSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponSuppressionSettings",
                rust_offset: offset_of!(SoldierTactics, weapon_suppression_settings),
            },
            FieldInfoData {
                name: "VehicleSuppressionSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleSuppressionSettings",
                rust_offset: offset_of!(SoldierTactics, vehicle_suppression_settings),
            },
            FieldInfoData {
                name: "TargetingSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetingData",
                rust_offset: offset_of!(SoldierTactics, targeting_settings),
            },
            FieldInfoData {
                name: "SecondaryThreats",
                flags: MemberInfoFlags::new(0),
                field_type: "SecondaryThreatSettings",
                rust_offset: offset_of!(SoldierTactics, secondary_threats),
            },
        ],
    }),
    array_type: Some(SOLDIERTACTICS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierTactics {
    fn type_info(&self) -> &'static TypeInfo {
        SOLDIERTACTICS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOLDIERTACTICS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierTactics-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SoldierTactics"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SecondaryThreatSettings {
    pub _glacier_base: super::core::DataContainer,
    pub max_distance_cover_to_enemy: f32,
    pub max_enemy_to_use_for_scoring: i32,
    pub secondary_enemies_score: Option<Arc<Mutex<dyn CoverQueryScoreDataTrait>>>,
}

pub trait SecondaryThreatSettingsTrait: super::core::DataContainerTrait {
    fn max_distance_cover_to_enemy(&self) -> &f32;
    fn max_distance_cover_to_enemy_mut(&mut self) -> &mut f32;
    fn max_enemy_to_use_for_scoring(&self) -> &i32;
    fn max_enemy_to_use_for_scoring_mut(&mut self) -> &mut i32;
    fn secondary_enemies_score(&self) -> &Option<Arc<Mutex<dyn CoverQueryScoreDataTrait>>>;
    fn secondary_enemies_score_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryScoreDataTrait>>>;
}

impl SecondaryThreatSettingsTrait for SecondaryThreatSettings {
    fn max_distance_cover_to_enemy(&self) -> &f32 {
        &self.max_distance_cover_to_enemy
    }
    fn max_distance_cover_to_enemy_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_cover_to_enemy
    }
    fn max_enemy_to_use_for_scoring(&self) -> &i32 {
        &self.max_enemy_to_use_for_scoring
    }
    fn max_enemy_to_use_for_scoring_mut(&mut self) -> &mut i32 {
        &mut self.max_enemy_to_use_for_scoring
    }
    fn secondary_enemies_score(&self) -> &Option<Arc<Mutex<dyn CoverQueryScoreDataTrait>>> {
        &self.secondary_enemies_score
    }
    fn secondary_enemies_score_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryScoreDataTrait>>> {
        &mut self.secondary_enemies_score
    }
}

impl super::core::DataContainerTrait for SecondaryThreatSettings {
}

pub static SECONDARYTHREATSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SecondaryThreatSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SecondaryThreatSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxDistanceCoverToEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SecondaryThreatSettings, max_distance_cover_to_enemy),
            },
            FieldInfoData {
                name: "MaxEnemyToUseForScoring",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SecondaryThreatSettings, max_enemy_to_use_for_scoring),
            },
            FieldInfoData {
                name: "SecondaryEnemiesScore",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryScoreData",
                rust_offset: offset_of!(SecondaryThreatSettings, secondary_enemies_score),
            },
        ],
    }),
    array_type: Some(SECONDARYTHREATSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SecondaryThreatSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SECONDARYTHREATSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SECONDARYTHREATSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SecondaryThreatSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SecondaryThreatSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleSuppressionSettings {
    pub suppression_distance: f32,
    pub reevaluate_cover_distance: f32,
}

pub trait VehicleSuppressionSettingsTrait: TypeObject {
    fn suppression_distance(&self) -> &f32;
    fn suppression_distance_mut(&mut self) -> &mut f32;
    fn reevaluate_cover_distance(&self) -> &f32;
    fn reevaluate_cover_distance_mut(&mut self) -> &mut f32;
}

impl VehicleSuppressionSettingsTrait for VehicleSuppressionSettings {
    fn suppression_distance(&self) -> &f32 {
        &self.suppression_distance
    }
    fn suppression_distance_mut(&mut self) -> &mut f32 {
        &mut self.suppression_distance
    }
    fn reevaluate_cover_distance(&self) -> &f32 {
        &self.reevaluate_cover_distance
    }
    fn reevaluate_cover_distance_mut(&mut self) -> &mut f32 {
        &mut self.reevaluate_cover_distance
    }
}

pub static VEHICLESUPPRESSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSuppressionSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleSuppressionSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SuppressionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSuppressionSettings, suppression_distance),
            },
            FieldInfoData {
                name: "ReevaluateCoverDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSuppressionSettings, reevaluate_cover_distance),
            },
        ],
    }),
    array_type: Some(VEHICLESUPPRESSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleSuppressionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLESUPPRESSIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLESUPPRESSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSuppressionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleSuppressionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponSuppressionSettings {
    pub suppression_value: f32,
    pub continuous_suppression_time: f32,
    pub suppression_area_size: f32,
}

pub trait WeaponSuppressionSettingsTrait: TypeObject {
    fn suppression_value(&self) -> &f32;
    fn suppression_value_mut(&mut self) -> &mut f32;
    fn continuous_suppression_time(&self) -> &f32;
    fn continuous_suppression_time_mut(&mut self) -> &mut f32;
    fn suppression_area_size(&self) -> &f32;
    fn suppression_area_size_mut(&mut self) -> &mut f32;
}

impl WeaponSuppressionSettingsTrait for WeaponSuppressionSettings {
    fn suppression_value(&self) -> &f32 {
        &self.suppression_value
    }
    fn suppression_value_mut(&mut self) -> &mut f32 {
        &mut self.suppression_value
    }
    fn continuous_suppression_time(&self) -> &f32 {
        &self.continuous_suppression_time
    }
    fn continuous_suppression_time_mut(&mut self) -> &mut f32 {
        &mut self.continuous_suppression_time
    }
    fn suppression_area_size(&self) -> &f32 {
        &self.suppression_area_size
    }
    fn suppression_area_size_mut(&mut self) -> &mut f32 {
        &mut self.suppression_area_size
    }
}

pub static WEAPONSUPPRESSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSuppressionSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponSuppressionSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SuppressionValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponSuppressionSettings, suppression_value),
            },
            FieldInfoData {
                name: "ContinuousSuppressionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponSuppressionSettings, continuous_suppression_time),
            },
            FieldInfoData {
                name: "SuppressionAreaSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponSuppressionSettings, suppression_area_size),
            },
        ],
    }),
    array_type: Some(WEAPONSUPPRESSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WeaponSuppressionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONSUPPRESSIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WEAPONSUPPRESSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSuppressionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WeaponSuppressionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PickWeaponSettings {
    pub _glacier_base: super::core::DataContainer,
    pub slots: Vec<SlotRange>,
}

pub trait PickWeaponSettingsTrait: super::core::DataContainerTrait {
    fn slots(&self) -> &Vec<SlotRange>;
    fn slots_mut(&mut self) -> &mut Vec<SlotRange>;
}

impl PickWeaponSettingsTrait for PickWeaponSettings {
    fn slots(&self) -> &Vec<SlotRange> {
        &self.slots
    }
    fn slots_mut(&mut self) -> &mut Vec<SlotRange> {
        &mut self.slots
    }
}

impl super::core::DataContainerTrait for PickWeaponSettings {
}

pub static PICKWEAPONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickWeaponSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PickWeaponSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Slots",
                flags: MemberInfoFlags::new(144),
                field_type: "SlotRange-Array",
                rust_offset: offset_of!(PickWeaponSettings, slots),
            },
        ],
    }),
    array_type: Some(PICKWEAPONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PickWeaponSettings {
    fn type_info(&self) -> &'static TypeInfo {
        PICKWEAPONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PICKWEAPONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickWeaponSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PickWeaponSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SlotRange {
    pub slot: super::weapon_shared::WeaponSlot,
    pub min_range: f32,
    pub max_range: f32,
    pub only_if_weapon_is_available: bool,
    pub automatic_switch_back: bool,
    pub keep_until_unavailable: bool,
    pub only_when_in_open_cover: bool,
    pub only_when_alerted: bool,
    pub max_friendly_gadgets: i32,
    pub only_if_target_in_vehicle: CheckTargetInVehicle,
    pub stealth_state: StealthStateType,
}

pub trait SlotRangeTrait: TypeObject {
    fn slot(&self) -> &super::weapon_shared::WeaponSlot;
    fn slot_mut(&mut self) -> &mut super::weapon_shared::WeaponSlot;
    fn min_range(&self) -> &f32;
    fn min_range_mut(&mut self) -> &mut f32;
    fn max_range(&self) -> &f32;
    fn max_range_mut(&mut self) -> &mut f32;
    fn only_if_weapon_is_available(&self) -> &bool;
    fn only_if_weapon_is_available_mut(&mut self) -> &mut bool;
    fn automatic_switch_back(&self) -> &bool;
    fn automatic_switch_back_mut(&mut self) -> &mut bool;
    fn keep_until_unavailable(&self) -> &bool;
    fn keep_until_unavailable_mut(&mut self) -> &mut bool;
    fn only_when_in_open_cover(&self) -> &bool;
    fn only_when_in_open_cover_mut(&mut self) -> &mut bool;
    fn only_when_alerted(&self) -> &bool;
    fn only_when_alerted_mut(&mut self) -> &mut bool;
    fn max_friendly_gadgets(&self) -> &i32;
    fn max_friendly_gadgets_mut(&mut self) -> &mut i32;
    fn only_if_target_in_vehicle(&self) -> &CheckTargetInVehicle;
    fn only_if_target_in_vehicle_mut(&mut self) -> &mut CheckTargetInVehicle;
    fn stealth_state(&self) -> &StealthStateType;
    fn stealth_state_mut(&mut self) -> &mut StealthStateType;
}

impl SlotRangeTrait for SlotRange {
    fn slot(&self) -> &super::weapon_shared::WeaponSlot {
        &self.slot
    }
    fn slot_mut(&mut self) -> &mut super::weapon_shared::WeaponSlot {
        &mut self.slot
    }
    fn min_range(&self) -> &f32 {
        &self.min_range
    }
    fn min_range_mut(&mut self) -> &mut f32 {
        &mut self.min_range
    }
    fn max_range(&self) -> &f32 {
        &self.max_range
    }
    fn max_range_mut(&mut self) -> &mut f32 {
        &mut self.max_range
    }
    fn only_if_weapon_is_available(&self) -> &bool {
        &self.only_if_weapon_is_available
    }
    fn only_if_weapon_is_available_mut(&mut self) -> &mut bool {
        &mut self.only_if_weapon_is_available
    }
    fn automatic_switch_back(&self) -> &bool {
        &self.automatic_switch_back
    }
    fn automatic_switch_back_mut(&mut self) -> &mut bool {
        &mut self.automatic_switch_back
    }
    fn keep_until_unavailable(&self) -> &bool {
        &self.keep_until_unavailable
    }
    fn keep_until_unavailable_mut(&mut self) -> &mut bool {
        &mut self.keep_until_unavailable
    }
    fn only_when_in_open_cover(&self) -> &bool {
        &self.only_when_in_open_cover
    }
    fn only_when_in_open_cover_mut(&mut self) -> &mut bool {
        &mut self.only_when_in_open_cover
    }
    fn only_when_alerted(&self) -> &bool {
        &self.only_when_alerted
    }
    fn only_when_alerted_mut(&mut self) -> &mut bool {
        &mut self.only_when_alerted
    }
    fn max_friendly_gadgets(&self) -> &i32 {
        &self.max_friendly_gadgets
    }
    fn max_friendly_gadgets_mut(&mut self) -> &mut i32 {
        &mut self.max_friendly_gadgets
    }
    fn only_if_target_in_vehicle(&self) -> &CheckTargetInVehicle {
        &self.only_if_target_in_vehicle
    }
    fn only_if_target_in_vehicle_mut(&mut self) -> &mut CheckTargetInVehicle {
        &mut self.only_if_target_in_vehicle
    }
    fn stealth_state(&self) -> &StealthStateType {
        &self.stealth_state
    }
    fn stealth_state_mut(&mut self) -> &mut StealthStateType {
        &mut self.stealth_state
    }
}

pub static SLOTRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SlotRange",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SlotRange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Slot",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponSlot",
                rust_offset: offset_of!(SlotRange, slot),
            },
            FieldInfoData {
                name: "MinRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SlotRange, min_range),
            },
            FieldInfoData {
                name: "MaxRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SlotRange, max_range),
            },
            FieldInfoData {
                name: "OnlyIfWeaponIsAvailable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SlotRange, only_if_weapon_is_available),
            },
            FieldInfoData {
                name: "AutomaticSwitchBack",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SlotRange, automatic_switch_back),
            },
            FieldInfoData {
                name: "KeepUntilUnavailable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SlotRange, keep_until_unavailable),
            },
            FieldInfoData {
                name: "OnlyWhenInOpenCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SlotRange, only_when_in_open_cover),
            },
            FieldInfoData {
                name: "OnlyWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SlotRange, only_when_alerted),
            },
            FieldInfoData {
                name: "MaxFriendlyGadgets",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SlotRange, max_friendly_gadgets),
            },
            FieldInfoData {
                name: "OnlyIfTargetInVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "CheckTargetInVehicle",
                rust_offset: offset_of!(SlotRange, only_if_target_in_vehicle),
            },
            FieldInfoData {
                name: "StealthState",
                flags: MemberInfoFlags::new(0),
                field_type: "StealthStateType",
                rust_offset: offset_of!(SlotRange, stealth_state),
            },
        ],
    }),
    array_type: Some(SLOTRANGE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SlotRange {
    fn type_info(&self) -> &'static TypeInfo {
        SLOTRANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SLOTRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SlotRange-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SlotRange"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum StealthStateType {
    #[default]
    StealthState_Any = 0,
    StealthState_InStealth = 1,
    StealthState_NotInStealth = 2,
}

pub static STEALTHSTATETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StealthStateType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(STEALTHSTATETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for StealthStateType {
    fn type_info(&self) -> &'static TypeInfo {
        STEALTHSTATETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STEALTHSTATETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StealthStateType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StealthStateType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EngageSettings {
    pub distance_to_target: f32,
    pub suppression_value: f32,
}

pub trait EngageSettingsTrait: TypeObject {
    fn distance_to_target(&self) -> &f32;
    fn distance_to_target_mut(&mut self) -> &mut f32;
    fn suppression_value(&self) -> &f32;
    fn suppression_value_mut(&mut self) -> &mut f32;
}

impl EngageSettingsTrait for EngageSettings {
    fn distance_to_target(&self) -> &f32 {
        &self.distance_to_target
    }
    fn distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_target
    }
    fn suppression_value(&self) -> &f32 {
        &self.suppression_value
    }
    fn suppression_value_mut(&mut self) -> &mut f32 {
        &mut self.suppression_value
    }
}

pub static ENGAGESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EngageSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EngageSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EngageSettings, distance_to_target),
            },
            FieldInfoData {
                name: "SuppressionValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EngageSettings, suppression_value),
            },
        ],
    }),
    array_type: Some(ENGAGESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EngageSettings {
    fn type_info(&self) -> &'static TypeInfo {
        ENGAGESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENGAGESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EngageSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EngageSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SquadEngageSettings {
    pub _glacier_base: super::core::DataContainer,
    pub cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
}

pub trait SquadEngageSettingsTrait: super::core::DataContainerTrait {
    fn cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
}

impl SquadEngageSettingsTrait for SquadEngageSettings {
    fn cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.cover_query
    }
    fn cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.cover_query
    }
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
}

impl super::core::DataContainerTrait for SquadEngageSettings {
}

pub static SQUADENGAGESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadEngageSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SquadEngageSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(SquadEngageSettings, cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(SquadEngageSettings, move_settings),
            },
        ],
    }),
    array_type: Some(SQUADENGAGESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SquadEngageSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SQUADENGAGESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SQUADENGAGESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadEngageSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SquadEngageSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SquadMovementSettings {
    pub _glacier_base: super::core::DataContainer,
    pub idle_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub alerted_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub friendly_area_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub cover_settings: Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>,
    pub max_acceptable_distance_to_human: f32,
    pub max_acceptable_height_difference_to_human: f32,
    pub invalidate_open_cover_if_alerted: bool,
    pub cover_compromised_timer: f32,
}

pub trait SquadMovementSettingsTrait: super::core::DataContainerTrait {
    fn idle_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn idle_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn alerted_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn alerted_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn friendly_area_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn friendly_area_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn max_acceptable_distance_to_human(&self) -> &f32;
    fn max_acceptable_distance_to_human_mut(&mut self) -> &mut f32;
    fn max_acceptable_height_difference_to_human(&self) -> &f32;
    fn max_acceptable_height_difference_to_human_mut(&mut self) -> &mut f32;
    fn invalidate_open_cover_if_alerted(&self) -> &bool;
    fn invalidate_open_cover_if_alerted_mut(&mut self) -> &mut bool;
    fn cover_compromised_timer(&self) -> &f32;
    fn cover_compromised_timer_mut(&mut self) -> &mut f32;
}

impl SquadMovementSettingsTrait for SquadMovementSettings {
    fn idle_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.idle_cover_query
    }
    fn idle_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.idle_cover_query
    }
    fn alerted_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.alerted_cover_query
    }
    fn alerted_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.alerted_cover_query
    }
    fn friendly_area_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.friendly_area_cover_query
    }
    fn friendly_area_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.friendly_area_cover_query
    }
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &self.cover_settings
    }
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &mut self.cover_settings
    }
    fn max_acceptable_distance_to_human(&self) -> &f32 {
        &self.max_acceptable_distance_to_human
    }
    fn max_acceptable_distance_to_human_mut(&mut self) -> &mut f32 {
        &mut self.max_acceptable_distance_to_human
    }
    fn max_acceptable_height_difference_to_human(&self) -> &f32 {
        &self.max_acceptable_height_difference_to_human
    }
    fn max_acceptable_height_difference_to_human_mut(&mut self) -> &mut f32 {
        &mut self.max_acceptable_height_difference_to_human
    }
    fn invalidate_open_cover_if_alerted(&self) -> &bool {
        &self.invalidate_open_cover_if_alerted
    }
    fn invalidate_open_cover_if_alerted_mut(&mut self) -> &mut bool {
        &mut self.invalidate_open_cover_if_alerted
    }
    fn cover_compromised_timer(&self) -> &f32 {
        &self.cover_compromised_timer
    }
    fn cover_compromised_timer_mut(&mut self) -> &mut f32 {
        &mut self.cover_compromised_timer
    }
}

impl super::core::DataContainerTrait for SquadMovementSettings {
}

pub static SQUADMOVEMENTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadMovementSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SquadMovementSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IdleCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(SquadMovementSettings, idle_cover_query),
            },
            FieldInfoData {
                name: "AlertedCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(SquadMovementSettings, alerted_cover_query),
            },
            FieldInfoData {
                name: "FriendlyAreaCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(SquadMovementSettings, friendly_area_cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(SquadMovementSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverControlSettings",
                rust_offset: offset_of!(SquadMovementSettings, cover_settings),
            },
            FieldInfoData {
                name: "MaxAcceptableDistanceToHuman",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadMovementSettings, max_acceptable_distance_to_human),
            },
            FieldInfoData {
                name: "MaxAcceptableHeightDifferenceToHuman",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadMovementSettings, max_acceptable_height_difference_to_human),
            },
            FieldInfoData {
                name: "InvalidateOpenCoverIfAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SquadMovementSettings, invalidate_open_cover_if_alerted),
            },
            FieldInfoData {
                name: "CoverCompromisedTimer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadMovementSettings, cover_compromised_timer),
            },
        ],
    }),
    array_type: Some(SQUADMOVEMENTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SquadMovementSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SQUADMOVEMENTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SQUADMOVEMENTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadMovementSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SquadMovementSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CloseCombatSettings {
    pub _glacier_base: super::core::DataContainer,
    pub distance: f32,
    pub height_distance: f32,
    pub distance_limit: f32,
    pub lost_visibility_timeout: f32,
    pub ignore_line_of_fire_on_enter: bool,
    pub pose_settings: Option<Arc<Mutex<dyn PoseSettingsTrait>>>,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub melee_projectile_settings: Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>,
}

pub trait CloseCombatSettingsTrait: super::core::DataContainerTrait {
    fn distance(&self) -> &f32;
    fn distance_mut(&mut self) -> &mut f32;
    fn height_distance(&self) -> &f32;
    fn height_distance_mut(&mut self) -> &mut f32;
    fn distance_limit(&self) -> &f32;
    fn distance_limit_mut(&mut self) -> &mut f32;
    fn lost_visibility_timeout(&self) -> &f32;
    fn lost_visibility_timeout_mut(&mut self) -> &mut f32;
    fn ignore_line_of_fire_on_enter(&self) -> &bool;
    fn ignore_line_of_fire_on_enter_mut(&mut self) -> &mut bool;
    fn pose_settings(&self) -> &Option<Arc<Mutex<dyn PoseSettingsTrait>>>;
    fn pose_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PoseSettingsTrait>>>;
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn melee_projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn melee_projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
}

impl CloseCombatSettingsTrait for CloseCombatSettings {
    fn distance(&self) -> &f32 {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut f32 {
        &mut self.distance
    }
    fn height_distance(&self) -> &f32 {
        &self.height_distance
    }
    fn height_distance_mut(&mut self) -> &mut f32 {
        &mut self.height_distance
    }
    fn distance_limit(&self) -> &f32 {
        &self.distance_limit
    }
    fn distance_limit_mut(&mut self) -> &mut f32 {
        &mut self.distance_limit
    }
    fn lost_visibility_timeout(&self) -> &f32 {
        &self.lost_visibility_timeout
    }
    fn lost_visibility_timeout_mut(&mut self) -> &mut f32 {
        &mut self.lost_visibility_timeout
    }
    fn ignore_line_of_fire_on_enter(&self) -> &bool {
        &self.ignore_line_of_fire_on_enter
    }
    fn ignore_line_of_fire_on_enter_mut(&mut self) -> &mut bool {
        &mut self.ignore_line_of_fire_on_enter
    }
    fn pose_settings(&self) -> &Option<Arc<Mutex<dyn PoseSettingsTrait>>> {
        &self.pose_settings
    }
    fn pose_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PoseSettingsTrait>>> {
        &mut self.pose_settings
    }
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn melee_projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &self.melee_projectile_settings
    }
    fn melee_projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &mut self.melee_projectile_settings
    }
}

impl super::core::DataContainerTrait for CloseCombatSettings {
}

pub static CLOSECOMBATSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloseCombatSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CloseCombatSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloseCombatSettings, distance),
            },
            FieldInfoData {
                name: "HeightDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloseCombatSettings, height_distance),
            },
            FieldInfoData {
                name: "DistanceLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloseCombatSettings, distance_limit),
            },
            FieldInfoData {
                name: "LostVisibilityTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CloseCombatSettings, lost_visibility_timeout),
            },
            FieldInfoData {
                name: "IgnoreLineOfFireOnEnter",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CloseCombatSettings, ignore_line_of_fire_on_enter),
            },
            FieldInfoData {
                name: "PoseSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "PoseSettings",
                rust_offset: offset_of!(CloseCombatSettings, pose_settings),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(CloseCombatSettings, move_settings),
            },
            FieldInfoData {
                name: "MeleeProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileSettings",
                rust_offset: offset_of!(CloseCombatSettings, melee_projectile_settings),
            },
        ],
    }),
    array_type: Some(CLOSECOMBATSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CloseCombatSettings {
    fn type_info(&self) -> &'static TypeInfo {
        CLOSECOMBATSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLOSECOMBATSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloseCombatSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CloseCombatSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GoToAttackPointSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub min_time_no_l_o_s_before_move: f32,
    pub max_time_no_l_o_s_before_move: f32,
    pub min_time_out_of_range_before_move: f32,
    pub max_time_out_of_range_before_move: f32,
    pub move_on_shot_at: bool,
}

pub trait GoToAttackPointSettingsTrait: super::core::DataContainerTrait {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn min_time_no_l_o_s_before_move(&self) -> &f32;
    fn min_time_no_l_o_s_before_move_mut(&mut self) -> &mut f32;
    fn max_time_no_l_o_s_before_move(&self) -> &f32;
    fn max_time_no_l_o_s_before_move_mut(&mut self) -> &mut f32;
    fn min_time_out_of_range_before_move(&self) -> &f32;
    fn min_time_out_of_range_before_move_mut(&mut self) -> &mut f32;
    fn max_time_out_of_range_before_move(&self) -> &f32;
    fn max_time_out_of_range_before_move_mut(&mut self) -> &mut f32;
    fn move_on_shot_at(&self) -> &bool;
    fn move_on_shot_at_mut(&mut self) -> &mut bool;
}

impl GoToAttackPointSettingsTrait for GoToAttackPointSettings {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn min_time_no_l_o_s_before_move(&self) -> &f32 {
        &self.min_time_no_l_o_s_before_move
    }
    fn min_time_no_l_o_s_before_move_mut(&mut self) -> &mut f32 {
        &mut self.min_time_no_l_o_s_before_move
    }
    fn max_time_no_l_o_s_before_move(&self) -> &f32 {
        &self.max_time_no_l_o_s_before_move
    }
    fn max_time_no_l_o_s_before_move_mut(&mut self) -> &mut f32 {
        &mut self.max_time_no_l_o_s_before_move
    }
    fn min_time_out_of_range_before_move(&self) -> &f32 {
        &self.min_time_out_of_range_before_move
    }
    fn min_time_out_of_range_before_move_mut(&mut self) -> &mut f32 {
        &mut self.min_time_out_of_range_before_move
    }
    fn max_time_out_of_range_before_move(&self) -> &f32 {
        &self.max_time_out_of_range_before_move
    }
    fn max_time_out_of_range_before_move_mut(&mut self) -> &mut f32 {
        &mut self.max_time_out_of_range_before_move
    }
    fn move_on_shot_at(&self) -> &bool {
        &self.move_on_shot_at
    }
    fn move_on_shot_at_mut(&mut self) -> &mut bool {
        &mut self.move_on_shot_at
    }
}

impl super::core::DataContainerTrait for GoToAttackPointSettings {
}

pub static GOTOATTACKPOINTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GoToAttackPointSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GoToAttackPointSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(GoToAttackPointSettings, move_settings),
            },
            FieldInfoData {
                name: "MinTimeNoLOSBeforeMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GoToAttackPointSettings, min_time_no_l_o_s_before_move),
            },
            FieldInfoData {
                name: "MaxTimeNoLOSBeforeMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GoToAttackPointSettings, max_time_no_l_o_s_before_move),
            },
            FieldInfoData {
                name: "MinTimeOutOfRangeBeforeMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GoToAttackPointSettings, min_time_out_of_range_before_move),
            },
            FieldInfoData {
                name: "MaxTimeOutOfRangeBeforeMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GoToAttackPointSettings, max_time_out_of_range_before_move),
            },
            FieldInfoData {
                name: "MoveOnShotAt",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GoToAttackPointSettings, move_on_shot_at),
            },
        ],
    }),
    array_type: Some(GOTOATTACKPOINTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GoToAttackPointSettings {
    fn type_info(&self) -> &'static TypeInfo {
        GOTOATTACKPOINTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GOTOATTACKPOINTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GoToAttackPointSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GoToAttackPointSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EvadeBehaviorSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub min_evade_distance: f32,
    pub max_expansion_count: i32,
    pub post_evade_pause_duration: f32,
    pub evade_breakout_min_time: f32,
}

pub trait EvadeBehaviorSettingsTrait: super::core::DataContainerTrait {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn min_evade_distance(&self) -> &f32;
    fn min_evade_distance_mut(&mut self) -> &mut f32;
    fn max_expansion_count(&self) -> &i32;
    fn max_expansion_count_mut(&mut self) -> &mut i32;
    fn post_evade_pause_duration(&self) -> &f32;
    fn post_evade_pause_duration_mut(&mut self) -> &mut f32;
    fn evade_breakout_min_time(&self) -> &f32;
    fn evade_breakout_min_time_mut(&mut self) -> &mut f32;
}

impl EvadeBehaviorSettingsTrait for EvadeBehaviorSettings {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn min_evade_distance(&self) -> &f32 {
        &self.min_evade_distance
    }
    fn min_evade_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_evade_distance
    }
    fn max_expansion_count(&self) -> &i32 {
        &self.max_expansion_count
    }
    fn max_expansion_count_mut(&mut self) -> &mut i32 {
        &mut self.max_expansion_count
    }
    fn post_evade_pause_duration(&self) -> &f32 {
        &self.post_evade_pause_duration
    }
    fn post_evade_pause_duration_mut(&mut self) -> &mut f32 {
        &mut self.post_evade_pause_duration
    }
    fn evade_breakout_min_time(&self) -> &f32 {
        &self.evade_breakout_min_time
    }
    fn evade_breakout_min_time_mut(&mut self) -> &mut f32 {
        &mut self.evade_breakout_min_time
    }
}

impl super::core::DataContainerTrait for EvadeBehaviorSettings {
}

pub static EVADEBEHAVIORSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvadeBehaviorSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EvadeBehaviorSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(EvadeBehaviorSettings, move_settings),
            },
            FieldInfoData {
                name: "MinEvadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvadeBehaviorSettings, min_evade_distance),
            },
            FieldInfoData {
                name: "MaxExpansionCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EvadeBehaviorSettings, max_expansion_count),
            },
            FieldInfoData {
                name: "PostEvadePauseDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvadeBehaviorSettings, post_evade_pause_duration),
            },
            FieldInfoData {
                name: "EvadeBreakoutMinTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvadeBehaviorSettings, evade_breakout_min_time),
            },
        ],
    }),
    array_type: Some(EVADEBEHAVIORSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EvadeBehaviorSettings {
    fn type_info(&self) -> &'static TypeInfo {
        EVADEBEHAVIORSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVADEBEHAVIORSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvadeBehaviorSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EvadeBehaviorSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FleeSettings {
    pub _glacier_base: super::core::DataContainer,
    pub cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub cover_settings: Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>,
    pub cover_request_settings: FleeCoverRequestSettings,
}

pub trait FleeSettingsTrait: super::core::DataContainerTrait {
    fn cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn cover_request_settings(&self) -> &FleeCoverRequestSettings;
    fn cover_request_settings_mut(&mut self) -> &mut FleeCoverRequestSettings;
}

impl FleeSettingsTrait for FleeSettings {
    fn cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.cover_query
    }
    fn cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.cover_query
    }
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &self.cover_settings
    }
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &mut self.cover_settings
    }
    fn cover_request_settings(&self) -> &FleeCoverRequestSettings {
        &self.cover_request_settings
    }
    fn cover_request_settings_mut(&mut self) -> &mut FleeCoverRequestSettings {
        &mut self.cover_request_settings
    }
}

impl super::core::DataContainerTrait for FleeSettings {
}

pub static FLEESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FleeSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FleeSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(FleeSettings, cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(FleeSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverControlSettings",
                rust_offset: offset_of!(FleeSettings, cover_settings),
            },
            FieldInfoData {
                name: "CoverRequestSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "FleeCoverRequestSettings",
                rust_offset: offset_of!(FleeSettings, cover_request_settings),
            },
        ],
    }),
    array_type: Some(FLEESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FleeSettings {
    fn type_info(&self) -> &'static TypeInfo {
        FLEESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLEESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FleeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FleeSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FleeCoverRequestSettings {
    pub allow_exposed_covers: bool,
}

pub trait FleeCoverRequestSettingsTrait: TypeObject {
    fn allow_exposed_covers(&self) -> &bool;
    fn allow_exposed_covers_mut(&mut self) -> &mut bool;
}

impl FleeCoverRequestSettingsTrait for FleeCoverRequestSettings {
    fn allow_exposed_covers(&self) -> &bool {
        &self.allow_exposed_covers
    }
    fn allow_exposed_covers_mut(&mut self) -> &mut bool {
        &mut self.allow_exposed_covers
    }
}

pub static FLEECOVERREQUESTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FleeCoverRequestSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FleeCoverRequestSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AllowExposedCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FleeCoverRequestSettings, allow_exposed_covers),
            },
        ],
    }),
    array_type: Some(FLEECOVERREQUESTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FleeCoverRequestSettings {
    fn type_info(&self) -> &'static TypeInfo {
        FLEECOVERREQUESTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FLEECOVERREQUESTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FleeCoverRequestSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FleeCoverRequestSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HideSettings {
    pub _glacier_base: super::core::DataContainer,
    pub cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub cover_settings: Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>,
    pub invalidate_cover_angle: f32,
    pub minimum_time_active: f32,
    pub maximum_time_active: f32,
}

pub trait HideSettingsTrait: super::core::DataContainerTrait {
    fn cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn invalidate_cover_angle(&self) -> &f32;
    fn invalidate_cover_angle_mut(&mut self) -> &mut f32;
    fn minimum_time_active(&self) -> &f32;
    fn minimum_time_active_mut(&mut self) -> &mut f32;
    fn maximum_time_active(&self) -> &f32;
    fn maximum_time_active_mut(&mut self) -> &mut f32;
}

impl HideSettingsTrait for HideSettings {
    fn cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.cover_query
    }
    fn cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.cover_query
    }
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &self.cover_settings
    }
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &mut self.cover_settings
    }
    fn invalidate_cover_angle(&self) -> &f32 {
        &self.invalidate_cover_angle
    }
    fn invalidate_cover_angle_mut(&mut self) -> &mut f32 {
        &mut self.invalidate_cover_angle
    }
    fn minimum_time_active(&self) -> &f32 {
        &self.minimum_time_active
    }
    fn minimum_time_active_mut(&mut self) -> &mut f32 {
        &mut self.minimum_time_active
    }
    fn maximum_time_active(&self) -> &f32 {
        &self.maximum_time_active
    }
    fn maximum_time_active_mut(&mut self) -> &mut f32 {
        &mut self.maximum_time_active
    }
}

impl super::core::DataContainerTrait for HideSettings {
}

pub static HIDESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HideSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HideSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(HideSettings, cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(HideSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverControlSettings",
                rust_offset: offset_of!(HideSettings, cover_settings),
            },
            FieldInfoData {
                name: "InvalidateCoverAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HideSettings, invalidate_cover_angle),
            },
            FieldInfoData {
                name: "MinimumTimeActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HideSettings, minimum_time_active),
            },
            FieldInfoData {
                name: "MaximumTimeActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HideSettings, maximum_time_active),
            },
        ],
    }),
    array_type: Some(HIDESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HideSettings {
    fn type_info(&self) -> &'static TypeInfo {
        HIDESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HIDESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HideSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("HideSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GoToTargetSettings {
    pub _glacier_base: super::core::DataContainer,
    pub only_go_if_inside_defend_area: bool,
    pub only_go_if_inside_preferred_area: bool,
    pub cooldown_time: f32,
    pub max_dist_from_go_to_pos: f32,
    pub path_recalculate_frequency: f32,
    pub path_recalculate_distance_threshold: f32,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
}

pub trait GoToTargetSettingsTrait: super::core::DataContainerTrait {
    fn only_go_if_inside_defend_area(&self) -> &bool;
    fn only_go_if_inside_defend_area_mut(&mut self) -> &mut bool;
    fn only_go_if_inside_preferred_area(&self) -> &bool;
    fn only_go_if_inside_preferred_area_mut(&mut self) -> &mut bool;
    fn cooldown_time(&self) -> &f32;
    fn cooldown_time_mut(&mut self) -> &mut f32;
    fn max_dist_from_go_to_pos(&self) -> &f32;
    fn max_dist_from_go_to_pos_mut(&mut self) -> &mut f32;
    fn path_recalculate_frequency(&self) -> &f32;
    fn path_recalculate_frequency_mut(&mut self) -> &mut f32;
    fn path_recalculate_distance_threshold(&self) -> &f32;
    fn path_recalculate_distance_threshold_mut(&mut self) -> &mut f32;
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
}

impl GoToTargetSettingsTrait for GoToTargetSettings {
    fn only_go_if_inside_defend_area(&self) -> &bool {
        &self.only_go_if_inside_defend_area
    }
    fn only_go_if_inside_defend_area_mut(&mut self) -> &mut bool {
        &mut self.only_go_if_inside_defend_area
    }
    fn only_go_if_inside_preferred_area(&self) -> &bool {
        &self.only_go_if_inside_preferred_area
    }
    fn only_go_if_inside_preferred_area_mut(&mut self) -> &mut bool {
        &mut self.only_go_if_inside_preferred_area
    }
    fn cooldown_time(&self) -> &f32 {
        &self.cooldown_time
    }
    fn cooldown_time_mut(&mut self) -> &mut f32 {
        &mut self.cooldown_time
    }
    fn max_dist_from_go_to_pos(&self) -> &f32 {
        &self.max_dist_from_go_to_pos
    }
    fn max_dist_from_go_to_pos_mut(&mut self) -> &mut f32 {
        &mut self.max_dist_from_go_to_pos
    }
    fn path_recalculate_frequency(&self) -> &f32 {
        &self.path_recalculate_frequency
    }
    fn path_recalculate_frequency_mut(&mut self) -> &mut f32 {
        &mut self.path_recalculate_frequency
    }
    fn path_recalculate_distance_threshold(&self) -> &f32 {
        &self.path_recalculate_distance_threshold
    }
    fn path_recalculate_distance_threshold_mut(&mut self) -> &mut f32 {
        &mut self.path_recalculate_distance_threshold
    }
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
}

impl super::core::DataContainerTrait for GoToTargetSettings {
}

pub static GOTOTARGETSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GoToTargetSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GoToTargetSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OnlyGoIfInsideDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GoToTargetSettings, only_go_if_inside_defend_area),
            },
            FieldInfoData {
                name: "OnlyGoIfInsidePreferredArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GoToTargetSettings, only_go_if_inside_preferred_area),
            },
            FieldInfoData {
                name: "CooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GoToTargetSettings, cooldown_time),
            },
            FieldInfoData {
                name: "MaxDistFromGoToPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GoToTargetSettings, max_dist_from_go_to_pos),
            },
            FieldInfoData {
                name: "PathRecalculateFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GoToTargetSettings, path_recalculate_frequency),
            },
            FieldInfoData {
                name: "PathRecalculateDistanceThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GoToTargetSettings, path_recalculate_distance_threshold),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(GoToTargetSettings, move_settings),
            },
        ],
    }),
    array_type: Some(GOTOTARGETSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GoToTargetSettings {
    fn type_info(&self) -> &'static TypeInfo {
        GOTOTARGETSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GOTOTARGETSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GoToTargetSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GoToTargetSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub follow_move_settings: FollowMoveSettings,
    pub stealth_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub stealth_cover_to_cover_advance_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub stealth_protective_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub max_distance_from_follow_object_to_run_stealth_protective_query: f32,
    pub follow_stealth_avoidance_settings: FollowStealthAvoidanceSettings,
    pub follow_stealth_cover_settings: FollowCoverSettings,
    pub attack_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub follow_attack_cover_settings: FollowCoverSettings,
    pub attack_cover_settings: Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>,
}

pub trait FollowSettingsTrait: super::core::DataContainerTrait {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn follow_move_settings(&self) -> &FollowMoveSettings;
    fn follow_move_settings_mut(&mut self) -> &mut FollowMoveSettings;
    fn stealth_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn stealth_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn stealth_cover_to_cover_advance_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn stealth_cover_to_cover_advance_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn stealth_protective_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn stealth_protective_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn max_distance_from_follow_object_to_run_stealth_protective_query(&self) -> &f32;
    fn max_distance_from_follow_object_to_run_stealth_protective_query_mut(&mut self) -> &mut f32;
    fn follow_stealth_avoidance_settings(&self) -> &FollowStealthAvoidanceSettings;
    fn follow_stealth_avoidance_settings_mut(&mut self) -> &mut FollowStealthAvoidanceSettings;
    fn follow_stealth_cover_settings(&self) -> &FollowCoverSettings;
    fn follow_stealth_cover_settings_mut(&mut self) -> &mut FollowCoverSettings;
    fn attack_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn follow_attack_cover_settings(&self) -> &FollowCoverSettings;
    fn follow_attack_cover_settings_mut(&mut self) -> &mut FollowCoverSettings;
    fn attack_cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn attack_cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
}

impl FollowSettingsTrait for FollowSettings {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn follow_move_settings(&self) -> &FollowMoveSettings {
        &self.follow_move_settings
    }
    fn follow_move_settings_mut(&mut self) -> &mut FollowMoveSettings {
        &mut self.follow_move_settings
    }
    fn stealth_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.stealth_cover_query
    }
    fn stealth_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.stealth_cover_query
    }
    fn stealth_cover_to_cover_advance_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.stealth_cover_to_cover_advance_query
    }
    fn stealth_cover_to_cover_advance_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.stealth_cover_to_cover_advance_query
    }
    fn stealth_protective_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.stealth_protective_query
    }
    fn stealth_protective_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.stealth_protective_query
    }
    fn max_distance_from_follow_object_to_run_stealth_protective_query(&self) -> &f32 {
        &self.max_distance_from_follow_object_to_run_stealth_protective_query
    }
    fn max_distance_from_follow_object_to_run_stealth_protective_query_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_from_follow_object_to_run_stealth_protective_query
    }
    fn follow_stealth_avoidance_settings(&self) -> &FollowStealthAvoidanceSettings {
        &self.follow_stealth_avoidance_settings
    }
    fn follow_stealth_avoidance_settings_mut(&mut self) -> &mut FollowStealthAvoidanceSettings {
        &mut self.follow_stealth_avoidance_settings
    }
    fn follow_stealth_cover_settings(&self) -> &FollowCoverSettings {
        &self.follow_stealth_cover_settings
    }
    fn follow_stealth_cover_settings_mut(&mut self) -> &mut FollowCoverSettings {
        &mut self.follow_stealth_cover_settings
    }
    fn attack_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.attack_cover_query
    }
    fn attack_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.attack_cover_query
    }
    fn follow_attack_cover_settings(&self) -> &FollowCoverSettings {
        &self.follow_attack_cover_settings
    }
    fn follow_attack_cover_settings_mut(&mut self) -> &mut FollowCoverSettings {
        &mut self.follow_attack_cover_settings
    }
    fn attack_cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &self.attack_cover_settings
    }
    fn attack_cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &mut self.attack_cover_settings
    }
}

impl super::core::DataContainerTrait for FollowSettings {
}

pub static FOLLOWSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(FollowSettings, move_settings),
            },
            FieldInfoData {
                name: "FollowMoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowMoveSettings",
                rust_offset: offset_of!(FollowSettings, follow_move_settings),
            },
            FieldInfoData {
                name: "StealthCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(FollowSettings, stealth_cover_query),
            },
            FieldInfoData {
                name: "StealthCoverToCoverAdvanceQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(FollowSettings, stealth_cover_to_cover_advance_query),
            },
            FieldInfoData {
                name: "StealthProtectiveQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(FollowSettings, stealth_protective_query),
            },
            FieldInfoData {
                name: "MaxDistanceFromFollowObjectToRunStealthProtectiveQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowSettings, max_distance_from_follow_object_to_run_stealth_protective_query),
            },
            FieldInfoData {
                name: "FollowStealthAvoidanceSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowStealthAvoidanceSettings",
                rust_offset: offset_of!(FollowSettings, follow_stealth_avoidance_settings),
            },
            FieldInfoData {
                name: "FollowStealthCoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowCoverSettings",
                rust_offset: offset_of!(FollowSettings, follow_stealth_cover_settings),
            },
            FieldInfoData {
                name: "AttackCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(FollowSettings, attack_cover_query),
            },
            FieldInfoData {
                name: "FollowAttackCoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowCoverSettings",
                rust_offset: offset_of!(FollowSettings, follow_attack_cover_settings),
            },
            FieldInfoData {
                name: "AttackCoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverControlSettings",
                rust_offset: offset_of!(FollowSettings, attack_cover_settings),
            },
        ],
    }),
    array_type: Some(FOLLOWSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowSettings {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOLLOWSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowStealthAvoidanceSettings {
    pub min_follow_object_distance: f32,
    pub max_follow_object_distance: f32,
    pub path_look_ahead_distance: f32,
    pub enemy_avoidance_distance: f32,
}

pub trait FollowStealthAvoidanceSettingsTrait: TypeObject {
    fn min_follow_object_distance(&self) -> &f32;
    fn min_follow_object_distance_mut(&mut self) -> &mut f32;
    fn max_follow_object_distance(&self) -> &f32;
    fn max_follow_object_distance_mut(&mut self) -> &mut f32;
    fn path_look_ahead_distance(&self) -> &f32;
    fn path_look_ahead_distance_mut(&mut self) -> &mut f32;
    fn enemy_avoidance_distance(&self) -> &f32;
    fn enemy_avoidance_distance_mut(&mut self) -> &mut f32;
}

impl FollowStealthAvoidanceSettingsTrait for FollowStealthAvoidanceSettings {
    fn min_follow_object_distance(&self) -> &f32 {
        &self.min_follow_object_distance
    }
    fn min_follow_object_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_follow_object_distance
    }
    fn max_follow_object_distance(&self) -> &f32 {
        &self.max_follow_object_distance
    }
    fn max_follow_object_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_follow_object_distance
    }
    fn path_look_ahead_distance(&self) -> &f32 {
        &self.path_look_ahead_distance
    }
    fn path_look_ahead_distance_mut(&mut self) -> &mut f32 {
        &mut self.path_look_ahead_distance
    }
    fn enemy_avoidance_distance(&self) -> &f32 {
        &self.enemy_avoidance_distance
    }
    fn enemy_avoidance_distance_mut(&mut self) -> &mut f32 {
        &mut self.enemy_avoidance_distance
    }
}

pub static FOLLOWSTEALTHAVOIDANCESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowStealthAvoidanceSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowStealthAvoidanceSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinFollowObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowStealthAvoidanceSettings, min_follow_object_distance),
            },
            FieldInfoData {
                name: "MaxFollowObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowStealthAvoidanceSettings, max_follow_object_distance),
            },
            FieldInfoData {
                name: "PathLookAheadDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowStealthAvoidanceSettings, path_look_ahead_distance),
            },
            FieldInfoData {
                name: "EnemyAvoidanceDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowStealthAvoidanceSettings, enemy_avoidance_distance),
            },
        ],
    }),
    array_type: Some(FOLLOWSTEALTHAVOIDANCESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowStealthAvoidanceSettings {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWSTEALTHAVOIDANCESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWSTEALTHAVOIDANCESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowStealthAvoidanceSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowStealthAvoidanceSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowCoverSettings {
    pub min_time_in_open_cover: f32,
    pub min_time_in_protected_cover: f32,
    pub min_time_between_cover_requests: f32,
    pub max_distance_to_enemy_to_enable_cover_in: f32,
    pub max_distance_to_enemy_to_enable_cover_out: f32,
    pub max_distance_to_visible_enemy_to_enable_cover: f32,
    pub max_time_since_visible_enemy_seen: f32,
}

pub trait FollowCoverSettingsTrait: TypeObject {
    fn min_time_in_open_cover(&self) -> &f32;
    fn min_time_in_open_cover_mut(&mut self) -> &mut f32;
    fn min_time_in_protected_cover(&self) -> &f32;
    fn min_time_in_protected_cover_mut(&mut self) -> &mut f32;
    fn min_time_between_cover_requests(&self) -> &f32;
    fn min_time_between_cover_requests_mut(&mut self) -> &mut f32;
    fn max_distance_to_enemy_to_enable_cover_in(&self) -> &f32;
    fn max_distance_to_enemy_to_enable_cover_in_mut(&mut self) -> &mut f32;
    fn max_distance_to_enemy_to_enable_cover_out(&self) -> &f32;
    fn max_distance_to_enemy_to_enable_cover_out_mut(&mut self) -> &mut f32;
    fn max_distance_to_visible_enemy_to_enable_cover(&self) -> &f32;
    fn max_distance_to_visible_enemy_to_enable_cover_mut(&mut self) -> &mut f32;
    fn max_time_since_visible_enemy_seen(&self) -> &f32;
    fn max_time_since_visible_enemy_seen_mut(&mut self) -> &mut f32;
}

impl FollowCoverSettingsTrait for FollowCoverSettings {
    fn min_time_in_open_cover(&self) -> &f32 {
        &self.min_time_in_open_cover
    }
    fn min_time_in_open_cover_mut(&mut self) -> &mut f32 {
        &mut self.min_time_in_open_cover
    }
    fn min_time_in_protected_cover(&self) -> &f32 {
        &self.min_time_in_protected_cover
    }
    fn min_time_in_protected_cover_mut(&mut self) -> &mut f32 {
        &mut self.min_time_in_protected_cover
    }
    fn min_time_between_cover_requests(&self) -> &f32 {
        &self.min_time_between_cover_requests
    }
    fn min_time_between_cover_requests_mut(&mut self) -> &mut f32 {
        &mut self.min_time_between_cover_requests
    }
    fn max_distance_to_enemy_to_enable_cover_in(&self) -> &f32 {
        &self.max_distance_to_enemy_to_enable_cover_in
    }
    fn max_distance_to_enemy_to_enable_cover_in_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_to_enemy_to_enable_cover_in
    }
    fn max_distance_to_enemy_to_enable_cover_out(&self) -> &f32 {
        &self.max_distance_to_enemy_to_enable_cover_out
    }
    fn max_distance_to_enemy_to_enable_cover_out_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_to_enemy_to_enable_cover_out
    }
    fn max_distance_to_visible_enemy_to_enable_cover(&self) -> &f32 {
        &self.max_distance_to_visible_enemy_to_enable_cover
    }
    fn max_distance_to_visible_enemy_to_enable_cover_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_to_visible_enemy_to_enable_cover
    }
    fn max_time_since_visible_enemy_seen(&self) -> &f32 {
        &self.max_time_since_visible_enemy_seen
    }
    fn max_time_since_visible_enemy_seen_mut(&mut self) -> &mut f32 {
        &mut self.max_time_since_visible_enemy_seen
    }
}

pub static FOLLOWCOVERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowCoverSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowCoverSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinTimeInOpenCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCoverSettings, min_time_in_open_cover),
            },
            FieldInfoData {
                name: "MinTimeInProtectedCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCoverSettings, min_time_in_protected_cover),
            },
            FieldInfoData {
                name: "MinTimeBetweenCoverRequests",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCoverSettings, min_time_between_cover_requests),
            },
            FieldInfoData {
                name: "MaxDistanceToEnemyToEnableCoverIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCoverSettings, max_distance_to_enemy_to_enable_cover_in),
            },
            FieldInfoData {
                name: "MaxDistanceToEnemyToEnableCoverOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCoverSettings, max_distance_to_enemy_to_enable_cover_out),
            },
            FieldInfoData {
                name: "MaxDistanceToVisibleEnemyToEnableCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCoverSettings, max_distance_to_visible_enemy_to_enable_cover),
            },
            FieldInfoData {
                name: "MaxTimeSinceVisibleEnemySeen",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowCoverSettings, max_time_since_visible_enemy_seen),
            },
        ],
    }),
    array_type: Some(FOLLOWCOVERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowCoverSettings {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWCOVERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWCOVERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowCoverSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowCoverSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowMoveSettings {
    pub speed_control_params: FollowSpeedControlParams,
    pub repath_params: FollowRepathParams,
    pub pose_params: FollowPoseParams,
    pub disable_canned_turns: bool,
}

pub trait FollowMoveSettingsTrait: TypeObject {
    fn speed_control_params(&self) -> &FollowSpeedControlParams;
    fn speed_control_params_mut(&mut self) -> &mut FollowSpeedControlParams;
    fn repath_params(&self) -> &FollowRepathParams;
    fn repath_params_mut(&mut self) -> &mut FollowRepathParams;
    fn pose_params(&self) -> &FollowPoseParams;
    fn pose_params_mut(&mut self) -> &mut FollowPoseParams;
    fn disable_canned_turns(&self) -> &bool;
    fn disable_canned_turns_mut(&mut self) -> &mut bool;
}

impl FollowMoveSettingsTrait for FollowMoveSettings {
    fn speed_control_params(&self) -> &FollowSpeedControlParams {
        &self.speed_control_params
    }
    fn speed_control_params_mut(&mut self) -> &mut FollowSpeedControlParams {
        &mut self.speed_control_params
    }
    fn repath_params(&self) -> &FollowRepathParams {
        &self.repath_params
    }
    fn repath_params_mut(&mut self) -> &mut FollowRepathParams {
        &mut self.repath_params
    }
    fn pose_params(&self) -> &FollowPoseParams {
        &self.pose_params
    }
    fn pose_params_mut(&mut self) -> &mut FollowPoseParams {
        &mut self.pose_params
    }
    fn disable_canned_turns(&self) -> &bool {
        &self.disable_canned_turns
    }
    fn disable_canned_turns_mut(&mut self) -> &mut bool {
        &mut self.disable_canned_turns
    }
}

pub static FOLLOWMOVESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowMoveSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowMoveSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SpeedControlParams",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowSpeedControlParams",
                rust_offset: offset_of!(FollowMoveSettings, speed_control_params),
            },
            FieldInfoData {
                name: "RepathParams",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowRepathParams",
                rust_offset: offset_of!(FollowMoveSettings, repath_params),
            },
            FieldInfoData {
                name: "PoseParams",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowPoseParams",
                rust_offset: offset_of!(FollowMoveSettings, pose_params),
            },
            FieldInfoData {
                name: "DisableCannedTurns",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FollowMoveSettings, disable_canned_turns),
            },
        ],
    }),
    array_type: Some(FOLLOWMOVESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowMoveSettings {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWMOVESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWMOVESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowMoveSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowMoveSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowPoseParams {
    pub pose_matching_max_distance: f32,
    pub pose_match_min_delay: f32,
    pub pose_match_max_delay: f32,
}

pub trait FollowPoseParamsTrait: TypeObject {
    fn pose_matching_max_distance(&self) -> &f32;
    fn pose_matching_max_distance_mut(&mut self) -> &mut f32;
    fn pose_match_min_delay(&self) -> &f32;
    fn pose_match_min_delay_mut(&mut self) -> &mut f32;
    fn pose_match_max_delay(&self) -> &f32;
    fn pose_match_max_delay_mut(&mut self) -> &mut f32;
}

impl FollowPoseParamsTrait for FollowPoseParams {
    fn pose_matching_max_distance(&self) -> &f32 {
        &self.pose_matching_max_distance
    }
    fn pose_matching_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.pose_matching_max_distance
    }
    fn pose_match_min_delay(&self) -> &f32 {
        &self.pose_match_min_delay
    }
    fn pose_match_min_delay_mut(&mut self) -> &mut f32 {
        &mut self.pose_match_min_delay
    }
    fn pose_match_max_delay(&self) -> &f32 {
        &self.pose_match_max_delay
    }
    fn pose_match_max_delay_mut(&mut self) -> &mut f32 {
        &mut self.pose_match_max_delay
    }
}

pub static FOLLOWPOSEPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowPoseParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowPoseParams as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PoseMatchingMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowPoseParams, pose_matching_max_distance),
            },
            FieldInfoData {
                name: "PoseMatchMinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowPoseParams, pose_match_min_delay),
            },
            FieldInfoData {
                name: "PoseMatchMaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowPoseParams, pose_match_max_delay),
            },
        ],
    }),
    array_type: Some(FOLLOWPOSEPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowPoseParams {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWPOSEPARAMS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWPOSEPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowPoseParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowPoseParams"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowSpeedControlParams {
    pub default_speed_selection_params: FollowMoveSpeedSelectionParams,
    pub cautious_speed_selection_params: FollowMoveSpeedSelectionParams,
    pub catchup_speed_scaling_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub speed_matching_speed_scaling_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub rubberband_p_i_d: super::game_shared::PID,
    pub min_rubberband_speed_multiplier: f32,
    pub max_rubberband_speed_multiplier: f32,
}

pub trait FollowSpeedControlParamsTrait: TypeObject {
    fn default_speed_selection_params(&self) -> &FollowMoveSpeedSelectionParams;
    fn default_speed_selection_params_mut(&mut self) -> &mut FollowMoveSpeedSelectionParams;
    fn cautious_speed_selection_params(&self) -> &FollowMoveSpeedSelectionParams;
    fn cautious_speed_selection_params_mut(&mut self) -> &mut FollowMoveSpeedSelectionParams;
    fn catchup_speed_scaling_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn catchup_speed_scaling_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn speed_matching_speed_scaling_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn speed_matching_speed_scaling_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn rubberband_p_i_d(&self) -> &super::game_shared::PID;
    fn rubberband_p_i_d_mut(&mut self) -> &mut super::game_shared::PID;
    fn min_rubberband_speed_multiplier(&self) -> &f32;
    fn min_rubberband_speed_multiplier_mut(&mut self) -> &mut f32;
    fn max_rubberband_speed_multiplier(&self) -> &f32;
    fn max_rubberband_speed_multiplier_mut(&mut self) -> &mut f32;
}

impl FollowSpeedControlParamsTrait for FollowSpeedControlParams {
    fn default_speed_selection_params(&self) -> &FollowMoveSpeedSelectionParams {
        &self.default_speed_selection_params
    }
    fn default_speed_selection_params_mut(&mut self) -> &mut FollowMoveSpeedSelectionParams {
        &mut self.default_speed_selection_params
    }
    fn cautious_speed_selection_params(&self) -> &FollowMoveSpeedSelectionParams {
        &self.cautious_speed_selection_params
    }
    fn cautious_speed_selection_params_mut(&mut self) -> &mut FollowMoveSpeedSelectionParams {
        &mut self.cautious_speed_selection_params
    }
    fn catchup_speed_scaling_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.catchup_speed_scaling_curve
    }
    fn catchup_speed_scaling_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.catchup_speed_scaling_curve
    }
    fn speed_matching_speed_scaling_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.speed_matching_speed_scaling_curve
    }
    fn speed_matching_speed_scaling_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.speed_matching_speed_scaling_curve
    }
    fn rubberband_p_i_d(&self) -> &super::game_shared::PID {
        &self.rubberband_p_i_d
    }
    fn rubberband_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        &mut self.rubberband_p_i_d
    }
    fn min_rubberband_speed_multiplier(&self) -> &f32 {
        &self.min_rubberband_speed_multiplier
    }
    fn min_rubberband_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.min_rubberband_speed_multiplier
    }
    fn max_rubberband_speed_multiplier(&self) -> &f32 {
        &self.max_rubberband_speed_multiplier
    }
    fn max_rubberband_speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.max_rubberband_speed_multiplier
    }
}

pub static FOLLOWSPEEDCONTROLPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowSpeedControlParams",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowSpeedControlParams as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultSpeedSelectionParams",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowMoveSpeedSelectionParams",
                rust_offset: offset_of!(FollowSpeedControlParams, default_speed_selection_params),
            },
            FieldInfoData {
                name: "CautiousSpeedSelectionParams",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowMoveSpeedSelectionParams",
                rust_offset: offset_of!(FollowSpeedControlParams, cautious_speed_selection_params),
            },
            FieldInfoData {
                name: "CatchupSpeedScalingCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(FollowSpeedControlParams, catchup_speed_scaling_curve),
            },
            FieldInfoData {
                name: "SpeedMatchingSpeedScalingCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(FollowSpeedControlParams, speed_matching_speed_scaling_curve),
            },
            FieldInfoData {
                name: "RubberbandPID",
                flags: MemberInfoFlags::new(0),
                field_type: "PID",
                rust_offset: offset_of!(FollowSpeedControlParams, rubberband_p_i_d),
            },
            FieldInfoData {
                name: "MinRubberbandSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowSpeedControlParams, min_rubberband_speed_multiplier),
            },
            FieldInfoData {
                name: "MaxRubberbandSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowSpeedControlParams, max_rubberband_speed_multiplier),
            },
        ],
    }),
    array_type: Some(FOLLOWSPEEDCONTROLPARAMS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowSpeedControlParams {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWSPEEDCONTROLPARAMS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWSPEEDCONTROLPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowSpeedControlParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowSpeedControlParams"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowMoveSpeedSelectionParams {
    pub always_sprint_distance: f32,
    pub always_run_or_sprint_distance: f32,
    pub walk_run_transition_speed: f32,
    pub min_target_sustained_run_before_run_enabled: f32,
}

pub trait FollowMoveSpeedSelectionParamsTrait: TypeObject {
    fn always_sprint_distance(&self) -> &f32;
    fn always_sprint_distance_mut(&mut self) -> &mut f32;
    fn always_run_or_sprint_distance(&self) -> &f32;
    fn always_run_or_sprint_distance_mut(&mut self) -> &mut f32;
    fn walk_run_transition_speed(&self) -> &f32;
    fn walk_run_transition_speed_mut(&mut self) -> &mut f32;
    fn min_target_sustained_run_before_run_enabled(&self) -> &f32;
    fn min_target_sustained_run_before_run_enabled_mut(&mut self) -> &mut f32;
}

impl FollowMoveSpeedSelectionParamsTrait for FollowMoveSpeedSelectionParams {
    fn always_sprint_distance(&self) -> &f32 {
        &self.always_sprint_distance
    }
    fn always_sprint_distance_mut(&mut self) -> &mut f32 {
        &mut self.always_sprint_distance
    }
    fn always_run_or_sprint_distance(&self) -> &f32 {
        &self.always_run_or_sprint_distance
    }
    fn always_run_or_sprint_distance_mut(&mut self) -> &mut f32 {
        &mut self.always_run_or_sprint_distance
    }
    fn walk_run_transition_speed(&self) -> &f32 {
        &self.walk_run_transition_speed
    }
    fn walk_run_transition_speed_mut(&mut self) -> &mut f32 {
        &mut self.walk_run_transition_speed
    }
    fn min_target_sustained_run_before_run_enabled(&self) -> &f32 {
        &self.min_target_sustained_run_before_run_enabled
    }
    fn min_target_sustained_run_before_run_enabled_mut(&mut self) -> &mut f32 {
        &mut self.min_target_sustained_run_before_run_enabled
    }
}

pub static FOLLOWMOVESPEEDSELECTIONPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowMoveSpeedSelectionParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowMoveSpeedSelectionParams as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AlwaysSprintDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowMoveSpeedSelectionParams, always_sprint_distance),
            },
            FieldInfoData {
                name: "AlwaysRunOrSprintDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowMoveSpeedSelectionParams, always_run_or_sprint_distance),
            },
            FieldInfoData {
                name: "WalkRunTransitionSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowMoveSpeedSelectionParams, walk_run_transition_speed),
            },
            FieldInfoData {
                name: "MinTargetSustainedRunBeforeRunEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowMoveSpeedSelectionParams, min_target_sustained_run_before_run_enabled),
            },
        ],
    }),
    array_type: Some(FOLLOWMOVESPEEDSELECTIONPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowMoveSpeedSelectionParams {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWMOVESPEEDSELECTIONPARAMS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWMOVESPEEDSELECTIONPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowMoveSpeedSelectionParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowMoveSpeedSelectionParams"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowRepathParams {
    pub repath_min_target_move_dist: f32,
    pub repath_max_target_move_dist: f32,
    pub target_proximity_for_max_repath_rate: f32,
    pub target_proximity_for_min_repath_rate: f32,
}

pub trait FollowRepathParamsTrait: TypeObject {
    fn repath_min_target_move_dist(&self) -> &f32;
    fn repath_min_target_move_dist_mut(&mut self) -> &mut f32;
    fn repath_max_target_move_dist(&self) -> &f32;
    fn repath_max_target_move_dist_mut(&mut self) -> &mut f32;
    fn target_proximity_for_max_repath_rate(&self) -> &f32;
    fn target_proximity_for_max_repath_rate_mut(&mut self) -> &mut f32;
    fn target_proximity_for_min_repath_rate(&self) -> &f32;
    fn target_proximity_for_min_repath_rate_mut(&mut self) -> &mut f32;
}

impl FollowRepathParamsTrait for FollowRepathParams {
    fn repath_min_target_move_dist(&self) -> &f32 {
        &self.repath_min_target_move_dist
    }
    fn repath_min_target_move_dist_mut(&mut self) -> &mut f32 {
        &mut self.repath_min_target_move_dist
    }
    fn repath_max_target_move_dist(&self) -> &f32 {
        &self.repath_max_target_move_dist
    }
    fn repath_max_target_move_dist_mut(&mut self) -> &mut f32 {
        &mut self.repath_max_target_move_dist
    }
    fn target_proximity_for_max_repath_rate(&self) -> &f32 {
        &self.target_proximity_for_max_repath_rate
    }
    fn target_proximity_for_max_repath_rate_mut(&mut self) -> &mut f32 {
        &mut self.target_proximity_for_max_repath_rate
    }
    fn target_proximity_for_min_repath_rate(&self) -> &f32 {
        &self.target_proximity_for_min_repath_rate
    }
    fn target_proximity_for_min_repath_rate_mut(&mut self) -> &mut f32 {
        &mut self.target_proximity_for_min_repath_rate
    }
}

pub static FOLLOWREPATHPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowRepathParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowRepathParams as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RepathMinTargetMoveDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowRepathParams, repath_min_target_move_dist),
            },
            FieldInfoData {
                name: "RepathMaxTargetMoveDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowRepathParams, repath_max_target_move_dist),
            },
            FieldInfoData {
                name: "TargetProximityForMaxRepathRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowRepathParams, target_proximity_for_max_repath_rate),
            },
            FieldInfoData {
                name: "TargetProximityForMinRepathRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowRepathParams, target_proximity_for_min_repath_rate),
            },
        ],
    }),
    array_type: Some(FOLLOWREPATHPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowRepathParams {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWREPATHPARAMS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWREPATHPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowRepathParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowRepathParams"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AttackSettings {
    pub _glacier_base: super::core::DataContainer,
    pub goal_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub protection_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub hide_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub valid_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub forced_move_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub cover_settings: Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>,
    pub cover_request_settings: AttackCoverRequestSettings,
    pub indoor_cover_request_settings: AttackCoverRequestSettings,
    pub outdoor_cover_request_settings: AttackCoverRequestSettings,
    pub projectile_settings: Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>,
    pub melee_projectile_settings: Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>,
    pub combat_intensity: AICombatIntensity,
}

pub trait AttackSettingsTrait: super::core::DataContainerTrait {
    fn goal_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn goal_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn protection_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn protection_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn hide_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn hide_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn valid_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn valid_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn forced_move_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn forced_move_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn cover_request_settings(&self) -> &AttackCoverRequestSettings;
    fn cover_request_settings_mut(&mut self) -> &mut AttackCoverRequestSettings;
    fn indoor_cover_request_settings(&self) -> &AttackCoverRequestSettings;
    fn indoor_cover_request_settings_mut(&mut self) -> &mut AttackCoverRequestSettings;
    fn outdoor_cover_request_settings(&self) -> &AttackCoverRequestSettings;
    fn outdoor_cover_request_settings_mut(&mut self) -> &mut AttackCoverRequestSettings;
    fn projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn melee_projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn melee_projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn combat_intensity(&self) -> &AICombatIntensity;
    fn combat_intensity_mut(&mut self) -> &mut AICombatIntensity;
}

impl AttackSettingsTrait for AttackSettings {
    fn goal_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.goal_cover_query
    }
    fn goal_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.goal_cover_query
    }
    fn protection_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.protection_cover_query
    }
    fn protection_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.protection_cover_query
    }
    fn hide_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.hide_cover_query
    }
    fn hide_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.hide_cover_query
    }
    fn valid_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.valid_cover_query
    }
    fn valid_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.valid_cover_query
    }
    fn forced_move_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.forced_move_cover_query
    }
    fn forced_move_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.forced_move_cover_query
    }
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &self.cover_settings
    }
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &mut self.cover_settings
    }
    fn cover_request_settings(&self) -> &AttackCoverRequestSettings {
        &self.cover_request_settings
    }
    fn cover_request_settings_mut(&mut self) -> &mut AttackCoverRequestSettings {
        &mut self.cover_request_settings
    }
    fn indoor_cover_request_settings(&self) -> &AttackCoverRequestSettings {
        &self.indoor_cover_request_settings
    }
    fn indoor_cover_request_settings_mut(&mut self) -> &mut AttackCoverRequestSettings {
        &mut self.indoor_cover_request_settings
    }
    fn outdoor_cover_request_settings(&self) -> &AttackCoverRequestSettings {
        &self.outdoor_cover_request_settings
    }
    fn outdoor_cover_request_settings_mut(&mut self) -> &mut AttackCoverRequestSettings {
        &mut self.outdoor_cover_request_settings
    }
    fn projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &self.projectile_settings
    }
    fn projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &mut self.projectile_settings
    }
    fn melee_projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &self.melee_projectile_settings
    }
    fn melee_projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &mut self.melee_projectile_settings
    }
    fn combat_intensity(&self) -> &AICombatIntensity {
        &self.combat_intensity
    }
    fn combat_intensity_mut(&mut self) -> &mut AICombatIntensity {
        &mut self.combat_intensity
    }
}

impl super::core::DataContainerTrait for AttackSettings {
}

pub static ATTACKSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AttackSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GoalCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AttackSettings, goal_cover_query),
            },
            FieldInfoData {
                name: "ProtectionCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AttackSettings, protection_cover_query),
            },
            FieldInfoData {
                name: "HideCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AttackSettings, hide_cover_query),
            },
            FieldInfoData {
                name: "ValidCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AttackSettings, valid_cover_query),
            },
            FieldInfoData {
                name: "ForcedMoveCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AttackSettings, forced_move_cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(AttackSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverControlSettings",
                rust_offset: offset_of!(AttackSettings, cover_settings),
            },
            FieldInfoData {
                name: "CoverRequestSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "AttackCoverRequestSettings",
                rust_offset: offset_of!(AttackSettings, cover_request_settings),
            },
            FieldInfoData {
                name: "IndoorCoverRequestSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "AttackCoverRequestSettings",
                rust_offset: offset_of!(AttackSettings, indoor_cover_request_settings),
            },
            FieldInfoData {
                name: "OutdoorCoverRequestSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "AttackCoverRequestSettings",
                rust_offset: offset_of!(AttackSettings, outdoor_cover_request_settings),
            },
            FieldInfoData {
                name: "ProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileSettings",
                rust_offset: offset_of!(AttackSettings, projectile_settings),
            },
            FieldInfoData {
                name: "MeleeProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileSettings",
                rust_offset: offset_of!(AttackSettings, melee_projectile_settings),
            },
            FieldInfoData {
                name: "CombatIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "AICombatIntensity",
                rust_offset: offset_of!(AttackSettings, combat_intensity),
            },
        ],
    }),
    array_type: Some(ATTACKSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AttackSettings {
    fn type_info(&self) -> &'static TypeInfo {
        ATTACKSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ATTACKSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AttackSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AttackCoverRequestSettings {
    pub minimum_time_in_cover_to_request: f32,
    pub maximum_time_in_cover_to_request: f32,
    pub minimum_time_between_goal_cover_requests: f32,
    pub minimum_time_interval_to_request_protective_cover: f32,
    pub maximum_time_interval_to_request_protective_cover: f32,
    pub max_dist_outside_weapon_range_to_request_protective_cover: f32,
    pub min_path_dist_to_request_protective_cover: f32,
    pub minimum_time_interval_to_request_hide_cover: f32,
    pub maximum_time_interval_to_request_hide_cover: f32,
    pub target_lost_last_seen_distance_multiplier: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub minimum_time_in_cover_after_target_lost: f32,
    pub maximum_time_in_cover_after_target_lost: f32,
    pub minimum_time_in_cover_after_target_l_o_f_lost: f32,
    pub maximum_time_in_cover_after_target_l_o_f_lost: f32,
    pub distance_to_target_compromised_threshold: f32,
    pub minimum_distance_to_target: f32,
    pub minimum_distance_to_target_vehicle: f32,
    pub time_required_after_shot_at_to_request_goal_cover: f32,
    pub ignore_shot_at_from_a_is: bool,
    pub minimum_initial_delay: TinyPiecewiseLinearCurve,
    pub maximum_initial_delay: TinyPiecewiseLinearCurve,
    pub advance_on_target_settings: AttackCoverRequestAdvanceOnTargetSettings,
    pub try_advance_even_if_already_in_weapon_range: bool,
    pub use_tactical_instead_of_valid_cover_when_having_been_in_combat: bool,
}

pub trait AttackCoverRequestSettingsTrait: TypeObject {
    fn minimum_time_in_cover_to_request(&self) -> &f32;
    fn minimum_time_in_cover_to_request_mut(&mut self) -> &mut f32;
    fn maximum_time_in_cover_to_request(&self) -> &f32;
    fn maximum_time_in_cover_to_request_mut(&mut self) -> &mut f32;
    fn minimum_time_between_goal_cover_requests(&self) -> &f32;
    fn minimum_time_between_goal_cover_requests_mut(&mut self) -> &mut f32;
    fn minimum_time_interval_to_request_protective_cover(&self) -> &f32;
    fn minimum_time_interval_to_request_protective_cover_mut(&mut self) -> &mut f32;
    fn maximum_time_interval_to_request_protective_cover(&self) -> &f32;
    fn maximum_time_interval_to_request_protective_cover_mut(&mut self) -> &mut f32;
    fn max_dist_outside_weapon_range_to_request_protective_cover(&self) -> &f32;
    fn max_dist_outside_weapon_range_to_request_protective_cover_mut(&mut self) -> &mut f32;
    fn min_path_dist_to_request_protective_cover(&self) -> &f32;
    fn min_path_dist_to_request_protective_cover_mut(&mut self) -> &mut f32;
    fn minimum_time_interval_to_request_hide_cover(&self) -> &f32;
    fn minimum_time_interval_to_request_hide_cover_mut(&mut self) -> &mut f32;
    fn maximum_time_interval_to_request_hide_cover(&self) -> &f32;
    fn maximum_time_interval_to_request_hide_cover_mut(&mut self) -> &mut f32;
    fn target_lost_last_seen_distance_multiplier(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn target_lost_last_seen_distance_multiplier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn minimum_time_in_cover_after_target_lost(&self) -> &f32;
    fn minimum_time_in_cover_after_target_lost_mut(&mut self) -> &mut f32;
    fn maximum_time_in_cover_after_target_lost(&self) -> &f32;
    fn maximum_time_in_cover_after_target_lost_mut(&mut self) -> &mut f32;
    fn minimum_time_in_cover_after_target_l_o_f_lost(&self) -> &f32;
    fn minimum_time_in_cover_after_target_l_o_f_lost_mut(&mut self) -> &mut f32;
    fn maximum_time_in_cover_after_target_l_o_f_lost(&self) -> &f32;
    fn maximum_time_in_cover_after_target_l_o_f_lost_mut(&mut self) -> &mut f32;
    fn distance_to_target_compromised_threshold(&self) -> &f32;
    fn distance_to_target_compromised_threshold_mut(&mut self) -> &mut f32;
    fn minimum_distance_to_target(&self) -> &f32;
    fn minimum_distance_to_target_mut(&mut self) -> &mut f32;
    fn minimum_distance_to_target_vehicle(&self) -> &f32;
    fn minimum_distance_to_target_vehicle_mut(&mut self) -> &mut f32;
    fn time_required_after_shot_at_to_request_goal_cover(&self) -> &f32;
    fn time_required_after_shot_at_to_request_goal_cover_mut(&mut self) -> &mut f32;
    fn ignore_shot_at_from_a_is(&self) -> &bool;
    fn ignore_shot_at_from_a_is_mut(&mut self) -> &mut bool;
    fn minimum_initial_delay(&self) -> &TinyPiecewiseLinearCurve;
    fn minimum_initial_delay_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn maximum_initial_delay(&self) -> &TinyPiecewiseLinearCurve;
    fn maximum_initial_delay_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn advance_on_target_settings(&self) -> &AttackCoverRequestAdvanceOnTargetSettings;
    fn advance_on_target_settings_mut(&mut self) -> &mut AttackCoverRequestAdvanceOnTargetSettings;
    fn try_advance_even_if_already_in_weapon_range(&self) -> &bool;
    fn try_advance_even_if_already_in_weapon_range_mut(&mut self) -> &mut bool;
    fn use_tactical_instead_of_valid_cover_when_having_been_in_combat(&self) -> &bool;
    fn use_tactical_instead_of_valid_cover_when_having_been_in_combat_mut(&mut self) -> &mut bool;
}

impl AttackCoverRequestSettingsTrait for AttackCoverRequestSettings {
    fn minimum_time_in_cover_to_request(&self) -> &f32 {
        &self.minimum_time_in_cover_to_request
    }
    fn minimum_time_in_cover_to_request_mut(&mut self) -> &mut f32 {
        &mut self.minimum_time_in_cover_to_request
    }
    fn maximum_time_in_cover_to_request(&self) -> &f32 {
        &self.maximum_time_in_cover_to_request
    }
    fn maximum_time_in_cover_to_request_mut(&mut self) -> &mut f32 {
        &mut self.maximum_time_in_cover_to_request
    }
    fn minimum_time_between_goal_cover_requests(&self) -> &f32 {
        &self.minimum_time_between_goal_cover_requests
    }
    fn minimum_time_between_goal_cover_requests_mut(&mut self) -> &mut f32 {
        &mut self.minimum_time_between_goal_cover_requests
    }
    fn minimum_time_interval_to_request_protective_cover(&self) -> &f32 {
        &self.minimum_time_interval_to_request_protective_cover
    }
    fn minimum_time_interval_to_request_protective_cover_mut(&mut self) -> &mut f32 {
        &mut self.minimum_time_interval_to_request_protective_cover
    }
    fn maximum_time_interval_to_request_protective_cover(&self) -> &f32 {
        &self.maximum_time_interval_to_request_protective_cover
    }
    fn maximum_time_interval_to_request_protective_cover_mut(&mut self) -> &mut f32 {
        &mut self.maximum_time_interval_to_request_protective_cover
    }
    fn max_dist_outside_weapon_range_to_request_protective_cover(&self) -> &f32 {
        &self.max_dist_outside_weapon_range_to_request_protective_cover
    }
    fn max_dist_outside_weapon_range_to_request_protective_cover_mut(&mut self) -> &mut f32 {
        &mut self.max_dist_outside_weapon_range_to_request_protective_cover
    }
    fn min_path_dist_to_request_protective_cover(&self) -> &f32 {
        &self.min_path_dist_to_request_protective_cover
    }
    fn min_path_dist_to_request_protective_cover_mut(&mut self) -> &mut f32 {
        &mut self.min_path_dist_to_request_protective_cover
    }
    fn minimum_time_interval_to_request_hide_cover(&self) -> &f32 {
        &self.minimum_time_interval_to_request_hide_cover
    }
    fn minimum_time_interval_to_request_hide_cover_mut(&mut self) -> &mut f32 {
        &mut self.minimum_time_interval_to_request_hide_cover
    }
    fn maximum_time_interval_to_request_hide_cover(&self) -> &f32 {
        &self.maximum_time_interval_to_request_hide_cover
    }
    fn maximum_time_interval_to_request_hide_cover_mut(&mut self) -> &mut f32 {
        &mut self.maximum_time_interval_to_request_hide_cover
    }
    fn target_lost_last_seen_distance_multiplier(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.target_lost_last_seen_distance_multiplier
    }
    fn target_lost_last_seen_distance_multiplier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.target_lost_last_seen_distance_multiplier
    }
    fn minimum_time_in_cover_after_target_lost(&self) -> &f32 {
        &self.minimum_time_in_cover_after_target_lost
    }
    fn minimum_time_in_cover_after_target_lost_mut(&mut self) -> &mut f32 {
        &mut self.minimum_time_in_cover_after_target_lost
    }
    fn maximum_time_in_cover_after_target_lost(&self) -> &f32 {
        &self.maximum_time_in_cover_after_target_lost
    }
    fn maximum_time_in_cover_after_target_lost_mut(&mut self) -> &mut f32 {
        &mut self.maximum_time_in_cover_after_target_lost
    }
    fn minimum_time_in_cover_after_target_l_o_f_lost(&self) -> &f32 {
        &self.minimum_time_in_cover_after_target_l_o_f_lost
    }
    fn minimum_time_in_cover_after_target_l_o_f_lost_mut(&mut self) -> &mut f32 {
        &mut self.minimum_time_in_cover_after_target_l_o_f_lost
    }
    fn maximum_time_in_cover_after_target_l_o_f_lost(&self) -> &f32 {
        &self.maximum_time_in_cover_after_target_l_o_f_lost
    }
    fn maximum_time_in_cover_after_target_l_o_f_lost_mut(&mut self) -> &mut f32 {
        &mut self.maximum_time_in_cover_after_target_l_o_f_lost
    }
    fn distance_to_target_compromised_threshold(&self) -> &f32 {
        &self.distance_to_target_compromised_threshold
    }
    fn distance_to_target_compromised_threshold_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_target_compromised_threshold
    }
    fn minimum_distance_to_target(&self) -> &f32 {
        &self.minimum_distance_to_target
    }
    fn minimum_distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.minimum_distance_to_target
    }
    fn minimum_distance_to_target_vehicle(&self) -> &f32 {
        &self.minimum_distance_to_target_vehicle
    }
    fn minimum_distance_to_target_vehicle_mut(&mut self) -> &mut f32 {
        &mut self.minimum_distance_to_target_vehicle
    }
    fn time_required_after_shot_at_to_request_goal_cover(&self) -> &f32 {
        &self.time_required_after_shot_at_to_request_goal_cover
    }
    fn time_required_after_shot_at_to_request_goal_cover_mut(&mut self) -> &mut f32 {
        &mut self.time_required_after_shot_at_to_request_goal_cover
    }
    fn ignore_shot_at_from_a_is(&self) -> &bool {
        &self.ignore_shot_at_from_a_is
    }
    fn ignore_shot_at_from_a_is_mut(&mut self) -> &mut bool {
        &mut self.ignore_shot_at_from_a_is
    }
    fn minimum_initial_delay(&self) -> &TinyPiecewiseLinearCurve {
        &self.minimum_initial_delay
    }
    fn minimum_initial_delay_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.minimum_initial_delay
    }
    fn maximum_initial_delay(&self) -> &TinyPiecewiseLinearCurve {
        &self.maximum_initial_delay
    }
    fn maximum_initial_delay_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.maximum_initial_delay
    }
    fn advance_on_target_settings(&self) -> &AttackCoverRequestAdvanceOnTargetSettings {
        &self.advance_on_target_settings
    }
    fn advance_on_target_settings_mut(&mut self) -> &mut AttackCoverRequestAdvanceOnTargetSettings {
        &mut self.advance_on_target_settings
    }
    fn try_advance_even_if_already_in_weapon_range(&self) -> &bool {
        &self.try_advance_even_if_already_in_weapon_range
    }
    fn try_advance_even_if_already_in_weapon_range_mut(&mut self) -> &mut bool {
        &mut self.try_advance_even_if_already_in_weapon_range
    }
    fn use_tactical_instead_of_valid_cover_when_having_been_in_combat(&self) -> &bool {
        &self.use_tactical_instead_of_valid_cover_when_having_been_in_combat
    }
    fn use_tactical_instead_of_valid_cover_when_having_been_in_combat_mut(&mut self) -> &mut bool {
        &mut self.use_tactical_instead_of_valid_cover_when_having_been_in_combat
    }
}

pub static ATTACKCOVERREQUESTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackCoverRequestSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AttackCoverRequestSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinimumTimeInCoverToRequest",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_in_cover_to_request),
            },
            FieldInfoData {
                name: "MaximumTimeInCoverToRequest",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_in_cover_to_request),
            },
            FieldInfoData {
                name: "MinimumTimeBetweenGoalCoverRequests",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_between_goal_cover_requests),
            },
            FieldInfoData {
                name: "MinimumTimeIntervalToRequestProtectiveCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_interval_to_request_protective_cover),
            },
            FieldInfoData {
                name: "MaximumTimeIntervalToRequestProtectiveCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_interval_to_request_protective_cover),
            },
            FieldInfoData {
                name: "MaxDistOutsideWeaponRangeToRequestProtectiveCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, max_dist_outside_weapon_range_to_request_protective_cover),
            },
            FieldInfoData {
                name: "MinPathDistToRequestProtectiveCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, min_path_dist_to_request_protective_cover),
            },
            FieldInfoData {
                name: "MinimumTimeIntervalToRequestHideCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_interval_to_request_hide_cover),
            },
            FieldInfoData {
                name: "MaximumTimeIntervalToRequestHideCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_interval_to_request_hide_cover),
            },
            FieldInfoData {
                name: "TargetLostLastSeenDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(AttackCoverRequestSettings, target_lost_last_seen_distance_multiplier),
            },
            FieldInfoData {
                name: "MinimumTimeInCoverAfterTargetLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_in_cover_after_target_lost),
            },
            FieldInfoData {
                name: "MaximumTimeInCoverAfterTargetLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_in_cover_after_target_lost),
            },
            FieldInfoData {
                name: "MinimumTimeInCoverAfterTargetLOFLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_in_cover_after_target_l_o_f_lost),
            },
            FieldInfoData {
                name: "MaximumTimeInCoverAfterTargetLOFLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_in_cover_after_target_l_o_f_lost),
            },
            FieldInfoData {
                name: "DistanceToTargetCompromisedThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, distance_to_target_compromised_threshold),
            },
            FieldInfoData {
                name: "MinimumDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_distance_to_target),
            },
            FieldInfoData {
                name: "MinimumDistanceToTargetVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_distance_to_target_vehicle),
            },
            FieldInfoData {
                name: "TimeRequiredAfterShotAtToRequestGoalCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestSettings, time_required_after_shot_at_to_request_goal_cover),
            },
            FieldInfoData {
                name: "IgnoreShotAtFromAIs",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AttackCoverRequestSettings, ignore_shot_at_from_a_is),
            },
            FieldInfoData {
                name: "MinimumInitialDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_initial_delay),
            },
            FieldInfoData {
                name: "MaximumInitialDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_initial_delay),
            },
            FieldInfoData {
                name: "AdvanceOnTargetSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "AttackCoverRequestAdvanceOnTargetSettings",
                rust_offset: offset_of!(AttackCoverRequestSettings, advance_on_target_settings),
            },
            FieldInfoData {
                name: "TryAdvanceEvenIfAlreadyInWeaponRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AttackCoverRequestSettings, try_advance_even_if_already_in_weapon_range),
            },
            FieldInfoData {
                name: "UseTacticalInsteadOfValidCoverWhenHavingBeenInCombat",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AttackCoverRequestSettings, use_tactical_instead_of_valid_cover_when_having_been_in_combat),
            },
        ],
    }),
    array_type: Some(ATTACKCOVERREQUESTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AttackCoverRequestSettings {
    fn type_info(&self) -> &'static TypeInfo {
        ATTACKCOVERREQUESTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ATTACKCOVERREQUESTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackCoverRequestSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AttackCoverRequestSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AttackCoverRequestAdvanceOnTargetSettings {
    pub minimum_time_in_cover_to_request: f32,
    pub maximum_time_in_cover_to_request: f32,
}

pub trait AttackCoverRequestAdvanceOnTargetSettingsTrait: TypeObject {
    fn minimum_time_in_cover_to_request(&self) -> &f32;
    fn minimum_time_in_cover_to_request_mut(&mut self) -> &mut f32;
    fn maximum_time_in_cover_to_request(&self) -> &f32;
    fn maximum_time_in_cover_to_request_mut(&mut self) -> &mut f32;
}

impl AttackCoverRequestAdvanceOnTargetSettingsTrait for AttackCoverRequestAdvanceOnTargetSettings {
    fn minimum_time_in_cover_to_request(&self) -> &f32 {
        &self.minimum_time_in_cover_to_request
    }
    fn minimum_time_in_cover_to_request_mut(&mut self) -> &mut f32 {
        &mut self.minimum_time_in_cover_to_request
    }
    fn maximum_time_in_cover_to_request(&self) -> &f32 {
        &self.maximum_time_in_cover_to_request
    }
    fn maximum_time_in_cover_to_request_mut(&mut self) -> &mut f32 {
        &mut self.maximum_time_in_cover_to_request
    }
}

pub static ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackCoverRequestAdvanceOnTargetSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AttackCoverRequestAdvanceOnTargetSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinimumTimeInCoverToRequest",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestAdvanceOnTargetSettings, minimum_time_in_cover_to_request),
            },
            FieldInfoData {
                name: "MaximumTimeInCoverToRequest",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AttackCoverRequestAdvanceOnTargetSettings, maximum_time_in_cover_to_request),
            },
        ],
    }),
    array_type: Some(ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AttackCoverRequestAdvanceOnTargetSettings {
    fn type_info(&self) -> &'static TypeInfo {
        ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackCoverRequestAdvanceOnTargetSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AttackCoverRequestAdvanceOnTargetSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExecuteActionSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub cooldown_time: f32,
    pub is_valid_for_during_scripted_path: bool,
}

pub trait ExecuteActionSettingsTrait: super::core::DataContainerTrait {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn cooldown_time(&self) -> &f32;
    fn cooldown_time_mut(&mut self) -> &mut f32;
    fn is_valid_for_during_scripted_path(&self) -> &bool;
    fn is_valid_for_during_scripted_path_mut(&mut self) -> &mut bool;
}

impl ExecuteActionSettingsTrait for ExecuteActionSettings {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn cooldown_time(&self) -> &f32 {
        &self.cooldown_time
    }
    fn cooldown_time_mut(&mut self) -> &mut f32 {
        &mut self.cooldown_time
    }
    fn is_valid_for_during_scripted_path(&self) -> &bool {
        &self.is_valid_for_during_scripted_path
    }
    fn is_valid_for_during_scripted_path_mut(&mut self) -> &mut bool {
        &mut self.is_valid_for_during_scripted_path
    }
}

impl super::core::DataContainerTrait for ExecuteActionSettings {
}

pub static EXECUTEACTIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecuteActionSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExecuteActionSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(ExecuteActionSettings, move_settings),
            },
            FieldInfoData {
                name: "CooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ExecuteActionSettings, cooldown_time),
            },
            FieldInfoData {
                name: "IsValidForDuringScriptedPath",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ExecuteActionSettings, is_valid_for_during_scripted_path),
            },
        ],
    }),
    array_type: Some(EXECUTEACTIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExecuteActionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        EXECUTEACTIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXECUTEACTIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecuteActionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ExecuteActionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub make_investigations_part_of_active_search: bool,
    pub num_secondary_inspections: i32,
    pub secondary_inspect_min_dist: f32,
    pub secondary_inspect_max_dist: f32,
    pub time_spent_inspecting: f32,
    pub find_secondary_pos_from_current_pos: bool,
    pub keep_initial_reaction_state: bool,
    pub initial_reaction_time: f32,
    pub give_up_reaction_time: f32,
    pub stand_in_place_and_look_time: f32,
    pub min_dist_from_investigate_pos: f32,
    pub max_dist_from_investigate_pos: f32,
    pub fail_to_find_position_timeout: f32,
    pub cooldown_time: f32,
    pub stop_abruptly_duration: f32,
    pub secondary_inspect_wait_for_available_action_station: f32,
    pub perform_initial_inspect: bool,
    pub initial_inspect_count_as_secondary: bool,
    pub max_perform_initial_inspectors: i32,
    pub only_investigate_inside_defend_area: bool,
    pub snap_investigate_pos_to_defend_area: bool,
    pub stand_and_look_investigate_outside_defend_area: bool,
    pub restrict_secondary_points_to_defend_area: bool,
    pub only_investigate_inside_search_area: bool,
    pub snap_investigate_pos_to_search_area: bool,
    pub stand_and_look_investigate_outside_search_area: bool,
    pub restrict_secondary_points_to_search_area: bool,
    pub disregard_corpses: bool,
    pub remove_disregarded_corpse: bool,
    pub return_to_start_position: bool,
    pub angle_correction_wait_time: f32,
}

pub trait InvestigateSettingsTrait: super::core::DataContainerTrait {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn make_investigations_part_of_active_search(&self) -> &bool;
    fn make_investigations_part_of_active_search_mut(&mut self) -> &mut bool;
    fn num_secondary_inspections(&self) -> &i32;
    fn num_secondary_inspections_mut(&mut self) -> &mut i32;
    fn secondary_inspect_min_dist(&self) -> &f32;
    fn secondary_inspect_min_dist_mut(&mut self) -> &mut f32;
    fn secondary_inspect_max_dist(&self) -> &f32;
    fn secondary_inspect_max_dist_mut(&mut self) -> &mut f32;
    fn time_spent_inspecting(&self) -> &f32;
    fn time_spent_inspecting_mut(&mut self) -> &mut f32;
    fn find_secondary_pos_from_current_pos(&self) -> &bool;
    fn find_secondary_pos_from_current_pos_mut(&mut self) -> &mut bool;
    fn keep_initial_reaction_state(&self) -> &bool;
    fn keep_initial_reaction_state_mut(&mut self) -> &mut bool;
    fn initial_reaction_time(&self) -> &f32;
    fn initial_reaction_time_mut(&mut self) -> &mut f32;
    fn give_up_reaction_time(&self) -> &f32;
    fn give_up_reaction_time_mut(&mut self) -> &mut f32;
    fn stand_in_place_and_look_time(&self) -> &f32;
    fn stand_in_place_and_look_time_mut(&mut self) -> &mut f32;
    fn min_dist_from_investigate_pos(&self) -> &f32;
    fn min_dist_from_investigate_pos_mut(&mut self) -> &mut f32;
    fn max_dist_from_investigate_pos(&self) -> &f32;
    fn max_dist_from_investigate_pos_mut(&mut self) -> &mut f32;
    fn fail_to_find_position_timeout(&self) -> &f32;
    fn fail_to_find_position_timeout_mut(&mut self) -> &mut f32;
    fn cooldown_time(&self) -> &f32;
    fn cooldown_time_mut(&mut self) -> &mut f32;
    fn stop_abruptly_duration(&self) -> &f32;
    fn stop_abruptly_duration_mut(&mut self) -> &mut f32;
    fn secondary_inspect_wait_for_available_action_station(&self) -> &f32;
    fn secondary_inspect_wait_for_available_action_station_mut(&mut self) -> &mut f32;
    fn perform_initial_inspect(&self) -> &bool;
    fn perform_initial_inspect_mut(&mut self) -> &mut bool;
    fn initial_inspect_count_as_secondary(&self) -> &bool;
    fn initial_inspect_count_as_secondary_mut(&mut self) -> &mut bool;
    fn max_perform_initial_inspectors(&self) -> &i32;
    fn max_perform_initial_inspectors_mut(&mut self) -> &mut i32;
    fn only_investigate_inside_defend_area(&self) -> &bool;
    fn only_investigate_inside_defend_area_mut(&mut self) -> &mut bool;
    fn snap_investigate_pos_to_defend_area(&self) -> &bool;
    fn snap_investigate_pos_to_defend_area_mut(&mut self) -> &mut bool;
    fn stand_and_look_investigate_outside_defend_area(&self) -> &bool;
    fn stand_and_look_investigate_outside_defend_area_mut(&mut self) -> &mut bool;
    fn restrict_secondary_points_to_defend_area(&self) -> &bool;
    fn restrict_secondary_points_to_defend_area_mut(&mut self) -> &mut bool;
    fn only_investigate_inside_search_area(&self) -> &bool;
    fn only_investigate_inside_search_area_mut(&mut self) -> &mut bool;
    fn snap_investigate_pos_to_search_area(&self) -> &bool;
    fn snap_investigate_pos_to_search_area_mut(&mut self) -> &mut bool;
    fn stand_and_look_investigate_outside_search_area(&self) -> &bool;
    fn stand_and_look_investigate_outside_search_area_mut(&mut self) -> &mut bool;
    fn restrict_secondary_points_to_search_area(&self) -> &bool;
    fn restrict_secondary_points_to_search_area_mut(&mut self) -> &mut bool;
    fn disregard_corpses(&self) -> &bool;
    fn disregard_corpses_mut(&mut self) -> &mut bool;
    fn remove_disregarded_corpse(&self) -> &bool;
    fn remove_disregarded_corpse_mut(&mut self) -> &mut bool;
    fn return_to_start_position(&self) -> &bool;
    fn return_to_start_position_mut(&mut self) -> &mut bool;
    fn angle_correction_wait_time(&self) -> &f32;
    fn angle_correction_wait_time_mut(&mut self) -> &mut f32;
}

impl InvestigateSettingsTrait for InvestigateSettings {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn make_investigations_part_of_active_search(&self) -> &bool {
        &self.make_investigations_part_of_active_search
    }
    fn make_investigations_part_of_active_search_mut(&mut self) -> &mut bool {
        &mut self.make_investigations_part_of_active_search
    }
    fn num_secondary_inspections(&self) -> &i32 {
        &self.num_secondary_inspections
    }
    fn num_secondary_inspections_mut(&mut self) -> &mut i32 {
        &mut self.num_secondary_inspections
    }
    fn secondary_inspect_min_dist(&self) -> &f32 {
        &self.secondary_inspect_min_dist
    }
    fn secondary_inspect_min_dist_mut(&mut self) -> &mut f32 {
        &mut self.secondary_inspect_min_dist
    }
    fn secondary_inspect_max_dist(&self) -> &f32 {
        &self.secondary_inspect_max_dist
    }
    fn secondary_inspect_max_dist_mut(&mut self) -> &mut f32 {
        &mut self.secondary_inspect_max_dist
    }
    fn time_spent_inspecting(&self) -> &f32 {
        &self.time_spent_inspecting
    }
    fn time_spent_inspecting_mut(&mut self) -> &mut f32 {
        &mut self.time_spent_inspecting
    }
    fn find_secondary_pos_from_current_pos(&self) -> &bool {
        &self.find_secondary_pos_from_current_pos
    }
    fn find_secondary_pos_from_current_pos_mut(&mut self) -> &mut bool {
        &mut self.find_secondary_pos_from_current_pos
    }
    fn keep_initial_reaction_state(&self) -> &bool {
        &self.keep_initial_reaction_state
    }
    fn keep_initial_reaction_state_mut(&mut self) -> &mut bool {
        &mut self.keep_initial_reaction_state
    }
    fn initial_reaction_time(&self) -> &f32 {
        &self.initial_reaction_time
    }
    fn initial_reaction_time_mut(&mut self) -> &mut f32 {
        &mut self.initial_reaction_time
    }
    fn give_up_reaction_time(&self) -> &f32 {
        &self.give_up_reaction_time
    }
    fn give_up_reaction_time_mut(&mut self) -> &mut f32 {
        &mut self.give_up_reaction_time
    }
    fn stand_in_place_and_look_time(&self) -> &f32 {
        &self.stand_in_place_and_look_time
    }
    fn stand_in_place_and_look_time_mut(&mut self) -> &mut f32 {
        &mut self.stand_in_place_and_look_time
    }
    fn min_dist_from_investigate_pos(&self) -> &f32 {
        &self.min_dist_from_investigate_pos
    }
    fn min_dist_from_investigate_pos_mut(&mut self) -> &mut f32 {
        &mut self.min_dist_from_investigate_pos
    }
    fn max_dist_from_investigate_pos(&self) -> &f32 {
        &self.max_dist_from_investigate_pos
    }
    fn max_dist_from_investigate_pos_mut(&mut self) -> &mut f32 {
        &mut self.max_dist_from_investigate_pos
    }
    fn fail_to_find_position_timeout(&self) -> &f32 {
        &self.fail_to_find_position_timeout
    }
    fn fail_to_find_position_timeout_mut(&mut self) -> &mut f32 {
        &mut self.fail_to_find_position_timeout
    }
    fn cooldown_time(&self) -> &f32 {
        &self.cooldown_time
    }
    fn cooldown_time_mut(&mut self) -> &mut f32 {
        &mut self.cooldown_time
    }
    fn stop_abruptly_duration(&self) -> &f32 {
        &self.stop_abruptly_duration
    }
    fn stop_abruptly_duration_mut(&mut self) -> &mut f32 {
        &mut self.stop_abruptly_duration
    }
    fn secondary_inspect_wait_for_available_action_station(&self) -> &f32 {
        &self.secondary_inspect_wait_for_available_action_station
    }
    fn secondary_inspect_wait_for_available_action_station_mut(&mut self) -> &mut f32 {
        &mut self.secondary_inspect_wait_for_available_action_station
    }
    fn perform_initial_inspect(&self) -> &bool {
        &self.perform_initial_inspect
    }
    fn perform_initial_inspect_mut(&mut self) -> &mut bool {
        &mut self.perform_initial_inspect
    }
    fn initial_inspect_count_as_secondary(&self) -> &bool {
        &self.initial_inspect_count_as_secondary
    }
    fn initial_inspect_count_as_secondary_mut(&mut self) -> &mut bool {
        &mut self.initial_inspect_count_as_secondary
    }
    fn max_perform_initial_inspectors(&self) -> &i32 {
        &self.max_perform_initial_inspectors
    }
    fn max_perform_initial_inspectors_mut(&mut self) -> &mut i32 {
        &mut self.max_perform_initial_inspectors
    }
    fn only_investigate_inside_defend_area(&self) -> &bool {
        &self.only_investigate_inside_defend_area
    }
    fn only_investigate_inside_defend_area_mut(&mut self) -> &mut bool {
        &mut self.only_investigate_inside_defend_area
    }
    fn snap_investigate_pos_to_defend_area(&self) -> &bool {
        &self.snap_investigate_pos_to_defend_area
    }
    fn snap_investigate_pos_to_defend_area_mut(&mut self) -> &mut bool {
        &mut self.snap_investigate_pos_to_defend_area
    }
    fn stand_and_look_investigate_outside_defend_area(&self) -> &bool {
        &self.stand_and_look_investigate_outside_defend_area
    }
    fn stand_and_look_investigate_outside_defend_area_mut(&mut self) -> &mut bool {
        &mut self.stand_and_look_investigate_outside_defend_area
    }
    fn restrict_secondary_points_to_defend_area(&self) -> &bool {
        &self.restrict_secondary_points_to_defend_area
    }
    fn restrict_secondary_points_to_defend_area_mut(&mut self) -> &mut bool {
        &mut self.restrict_secondary_points_to_defend_area
    }
    fn only_investigate_inside_search_area(&self) -> &bool {
        &self.only_investigate_inside_search_area
    }
    fn only_investigate_inside_search_area_mut(&mut self) -> &mut bool {
        &mut self.only_investigate_inside_search_area
    }
    fn snap_investigate_pos_to_search_area(&self) -> &bool {
        &self.snap_investigate_pos_to_search_area
    }
    fn snap_investigate_pos_to_search_area_mut(&mut self) -> &mut bool {
        &mut self.snap_investigate_pos_to_search_area
    }
    fn stand_and_look_investigate_outside_search_area(&self) -> &bool {
        &self.stand_and_look_investigate_outside_search_area
    }
    fn stand_and_look_investigate_outside_search_area_mut(&mut self) -> &mut bool {
        &mut self.stand_and_look_investigate_outside_search_area
    }
    fn restrict_secondary_points_to_search_area(&self) -> &bool {
        &self.restrict_secondary_points_to_search_area
    }
    fn restrict_secondary_points_to_search_area_mut(&mut self) -> &mut bool {
        &mut self.restrict_secondary_points_to_search_area
    }
    fn disregard_corpses(&self) -> &bool {
        &self.disregard_corpses
    }
    fn disregard_corpses_mut(&mut self) -> &mut bool {
        &mut self.disregard_corpses
    }
    fn remove_disregarded_corpse(&self) -> &bool {
        &self.remove_disregarded_corpse
    }
    fn remove_disregarded_corpse_mut(&mut self) -> &mut bool {
        &mut self.remove_disregarded_corpse
    }
    fn return_to_start_position(&self) -> &bool {
        &self.return_to_start_position
    }
    fn return_to_start_position_mut(&mut self) -> &mut bool {
        &mut self.return_to_start_position
    }
    fn angle_correction_wait_time(&self) -> &f32 {
        &self.angle_correction_wait_time
    }
    fn angle_correction_wait_time_mut(&mut self) -> &mut f32 {
        &mut self.angle_correction_wait_time
    }
}

impl super::core::DataContainerTrait for InvestigateSettings {
}

pub static INVESTIGATESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(InvestigateSettings, move_settings),
            },
            FieldInfoData {
                name: "MakeInvestigationsPartOfActiveSearch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, make_investigations_part_of_active_search),
            },
            FieldInfoData {
                name: "NumSecondaryInspections",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InvestigateSettings, num_secondary_inspections),
            },
            FieldInfoData {
                name: "SecondaryInspectMinDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, secondary_inspect_min_dist),
            },
            FieldInfoData {
                name: "SecondaryInspectMaxDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, secondary_inspect_max_dist),
            },
            FieldInfoData {
                name: "TimeSpentInspecting",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, time_spent_inspecting),
            },
            FieldInfoData {
                name: "FindSecondaryPosFromCurrentPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, find_secondary_pos_from_current_pos),
            },
            FieldInfoData {
                name: "KeepInitialReactionState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, keep_initial_reaction_state),
            },
            FieldInfoData {
                name: "InitialReactionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, initial_reaction_time),
            },
            FieldInfoData {
                name: "GiveUpReactionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, give_up_reaction_time),
            },
            FieldInfoData {
                name: "StandInPlaceAndLookTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, stand_in_place_and_look_time),
            },
            FieldInfoData {
                name: "MinDistFromInvestigatePos",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, min_dist_from_investigate_pos),
            },
            FieldInfoData {
                name: "MaxDistFromInvestigatePos",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, max_dist_from_investigate_pos),
            },
            FieldInfoData {
                name: "FailToFindPositionTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, fail_to_find_position_timeout),
            },
            FieldInfoData {
                name: "CooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, cooldown_time),
            },
            FieldInfoData {
                name: "StopAbruptlyDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, stop_abruptly_duration),
            },
            FieldInfoData {
                name: "SecondaryInspectWaitForAvailableActionStation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, secondary_inspect_wait_for_available_action_station),
            },
            FieldInfoData {
                name: "PerformInitialInspect",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, perform_initial_inspect),
            },
            FieldInfoData {
                name: "InitialInspectCountAsSecondary",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, initial_inspect_count_as_secondary),
            },
            FieldInfoData {
                name: "MaxPerformInitialInspectors",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InvestigateSettings, max_perform_initial_inspectors),
            },
            FieldInfoData {
                name: "OnlyInvestigateInsideDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, only_investigate_inside_defend_area),
            },
            FieldInfoData {
                name: "SnapInvestigatePosToDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, snap_investigate_pos_to_defend_area),
            },
            FieldInfoData {
                name: "StandAndLookInvestigateOutsideDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, stand_and_look_investigate_outside_defend_area),
            },
            FieldInfoData {
                name: "RestrictSecondaryPointsToDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, restrict_secondary_points_to_defend_area),
            },
            FieldInfoData {
                name: "OnlyInvestigateInsideSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, only_investigate_inside_search_area),
            },
            FieldInfoData {
                name: "SnapInvestigatePosToSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, snap_investigate_pos_to_search_area),
            },
            FieldInfoData {
                name: "StandAndLookInvestigateOutsideSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, stand_and_look_investigate_outside_search_area),
            },
            FieldInfoData {
                name: "RestrictSecondaryPointsToSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, restrict_secondary_points_to_search_area),
            },
            FieldInfoData {
                name: "DisregardCorpses",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, disregard_corpses),
            },
            FieldInfoData {
                name: "RemoveDisregardedCorpse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, remove_disregarded_corpse),
            },
            FieldInfoData {
                name: "ReturnToStartPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettings, return_to_start_position),
            },
            FieldInfoData {
                name: "AngleCorrectionWaitTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettings, angle_correction_wait_time),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InvestigateSettings {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INVESTIGATESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CloseRangeAttackSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub cover_settings: Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>,
    pub cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
}

pub trait CloseRangeAttackSettingsTrait: super::core::DataContainerTrait {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>>;
    fn cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
}

impl CloseRangeAttackSettingsTrait for CloseRangeAttackSettings {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn cover_settings(&self) -> &Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &self.cover_settings
    }
    fn cover_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverControlSettingsTrait>>> {
        &mut self.cover_settings
    }
    fn cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.cover_query
    }
    fn cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.cover_query
    }
}

impl super::core::DataContainerTrait for CloseRangeAttackSettings {
}

pub static CLOSERANGEATTACKSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloseRangeAttackSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CloseRangeAttackSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(CloseRangeAttackSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverControlSettings",
                rust_offset: offset_of!(CloseRangeAttackSettings, cover_settings),
            },
            FieldInfoData {
                name: "CoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(CloseRangeAttackSettings, cover_query),
            },
        ],
    }),
    array_type: Some(CLOSERANGEATTACKSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CloseRangeAttackSettings {
    fn type_info(&self) -> &'static TypeInfo {
        CLOSERANGEATTACKSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLOSERANGEATTACKSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloseRangeAttackSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CloseRangeAttackSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeleeChargeSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub melee_projectile_settings: Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>,
    pub dynamic_melee_charge_tokens_settings: Option<Arc<Mutex<dyn DynamicMeleeChargeTokensSettingsTrait>>>,
    pub min_melee_charge_distance: f32,
    pub max_melee_charge_distance: f32,
    pub time_stop_melee_charge_for_invalid_path: f32,
    pub min_time_in_player_view_to_charge: f32,
    pub max_time_in_player_view_to_charge: f32,
    pub bypass_token_requirement: bool,
    pub allow_charging_charged_target: bool,
    pub manual_token_release: bool,
    pub check_is_player_in_front: bool,
    pub disable_canned_starts: bool,
    pub disable_canned_stops: bool,
    pub disable_canned_turns: bool,
    pub disable_canned_animation_range: f32,
    pub warp_on_attack: bool,
    pub screaming_v_o_range: f32,
    pub complete_on_melee: bool,
    pub charge_cooldown: f32,
    pub off_navmesh_correction: f32,
}

pub trait MeleeChargeSettingsTrait: super::core::DataContainerTrait {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn melee_projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn melee_projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn dynamic_melee_charge_tokens_settings(&self) -> &Option<Arc<Mutex<dyn DynamicMeleeChargeTokensSettingsTrait>>>;
    fn dynamic_melee_charge_tokens_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DynamicMeleeChargeTokensSettingsTrait>>>;
    fn min_melee_charge_distance(&self) -> &f32;
    fn min_melee_charge_distance_mut(&mut self) -> &mut f32;
    fn max_melee_charge_distance(&self) -> &f32;
    fn max_melee_charge_distance_mut(&mut self) -> &mut f32;
    fn time_stop_melee_charge_for_invalid_path(&self) -> &f32;
    fn time_stop_melee_charge_for_invalid_path_mut(&mut self) -> &mut f32;
    fn min_time_in_player_view_to_charge(&self) -> &f32;
    fn min_time_in_player_view_to_charge_mut(&mut self) -> &mut f32;
    fn max_time_in_player_view_to_charge(&self) -> &f32;
    fn max_time_in_player_view_to_charge_mut(&mut self) -> &mut f32;
    fn bypass_token_requirement(&self) -> &bool;
    fn bypass_token_requirement_mut(&mut self) -> &mut bool;
    fn allow_charging_charged_target(&self) -> &bool;
    fn allow_charging_charged_target_mut(&mut self) -> &mut bool;
    fn manual_token_release(&self) -> &bool;
    fn manual_token_release_mut(&mut self) -> &mut bool;
    fn check_is_player_in_front(&self) -> &bool;
    fn check_is_player_in_front_mut(&mut self) -> &mut bool;
    fn disable_canned_starts(&self) -> &bool;
    fn disable_canned_starts_mut(&mut self) -> &mut bool;
    fn disable_canned_stops(&self) -> &bool;
    fn disable_canned_stops_mut(&mut self) -> &mut bool;
    fn disable_canned_turns(&self) -> &bool;
    fn disable_canned_turns_mut(&mut self) -> &mut bool;
    fn disable_canned_animation_range(&self) -> &f32;
    fn disable_canned_animation_range_mut(&mut self) -> &mut f32;
    fn warp_on_attack(&self) -> &bool;
    fn warp_on_attack_mut(&mut self) -> &mut bool;
    fn screaming_v_o_range(&self) -> &f32;
    fn screaming_v_o_range_mut(&mut self) -> &mut f32;
    fn complete_on_melee(&self) -> &bool;
    fn complete_on_melee_mut(&mut self) -> &mut bool;
    fn charge_cooldown(&self) -> &f32;
    fn charge_cooldown_mut(&mut self) -> &mut f32;
    fn off_navmesh_correction(&self) -> &f32;
    fn off_navmesh_correction_mut(&mut self) -> &mut f32;
}

impl MeleeChargeSettingsTrait for MeleeChargeSettings {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn melee_projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &self.melee_projectile_settings
    }
    fn melee_projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &mut self.melee_projectile_settings
    }
    fn dynamic_melee_charge_tokens_settings(&self) -> &Option<Arc<Mutex<dyn DynamicMeleeChargeTokensSettingsTrait>>> {
        &self.dynamic_melee_charge_tokens_settings
    }
    fn dynamic_melee_charge_tokens_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DynamicMeleeChargeTokensSettingsTrait>>> {
        &mut self.dynamic_melee_charge_tokens_settings
    }
    fn min_melee_charge_distance(&self) -> &f32 {
        &self.min_melee_charge_distance
    }
    fn min_melee_charge_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_melee_charge_distance
    }
    fn max_melee_charge_distance(&self) -> &f32 {
        &self.max_melee_charge_distance
    }
    fn max_melee_charge_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_melee_charge_distance
    }
    fn time_stop_melee_charge_for_invalid_path(&self) -> &f32 {
        &self.time_stop_melee_charge_for_invalid_path
    }
    fn time_stop_melee_charge_for_invalid_path_mut(&mut self) -> &mut f32 {
        &mut self.time_stop_melee_charge_for_invalid_path
    }
    fn min_time_in_player_view_to_charge(&self) -> &f32 {
        &self.min_time_in_player_view_to_charge
    }
    fn min_time_in_player_view_to_charge_mut(&mut self) -> &mut f32 {
        &mut self.min_time_in_player_view_to_charge
    }
    fn max_time_in_player_view_to_charge(&self) -> &f32 {
        &self.max_time_in_player_view_to_charge
    }
    fn max_time_in_player_view_to_charge_mut(&mut self) -> &mut f32 {
        &mut self.max_time_in_player_view_to_charge
    }
    fn bypass_token_requirement(&self) -> &bool {
        &self.bypass_token_requirement
    }
    fn bypass_token_requirement_mut(&mut self) -> &mut bool {
        &mut self.bypass_token_requirement
    }
    fn allow_charging_charged_target(&self) -> &bool {
        &self.allow_charging_charged_target
    }
    fn allow_charging_charged_target_mut(&mut self) -> &mut bool {
        &mut self.allow_charging_charged_target
    }
    fn manual_token_release(&self) -> &bool {
        &self.manual_token_release
    }
    fn manual_token_release_mut(&mut self) -> &mut bool {
        &mut self.manual_token_release
    }
    fn check_is_player_in_front(&self) -> &bool {
        &self.check_is_player_in_front
    }
    fn check_is_player_in_front_mut(&mut self) -> &mut bool {
        &mut self.check_is_player_in_front
    }
    fn disable_canned_starts(&self) -> &bool {
        &self.disable_canned_starts
    }
    fn disable_canned_starts_mut(&mut self) -> &mut bool {
        &mut self.disable_canned_starts
    }
    fn disable_canned_stops(&self) -> &bool {
        &self.disable_canned_stops
    }
    fn disable_canned_stops_mut(&mut self) -> &mut bool {
        &mut self.disable_canned_stops
    }
    fn disable_canned_turns(&self) -> &bool {
        &self.disable_canned_turns
    }
    fn disable_canned_turns_mut(&mut self) -> &mut bool {
        &mut self.disable_canned_turns
    }
    fn disable_canned_animation_range(&self) -> &f32 {
        &self.disable_canned_animation_range
    }
    fn disable_canned_animation_range_mut(&mut self) -> &mut f32 {
        &mut self.disable_canned_animation_range
    }
    fn warp_on_attack(&self) -> &bool {
        &self.warp_on_attack
    }
    fn warp_on_attack_mut(&mut self) -> &mut bool {
        &mut self.warp_on_attack
    }
    fn screaming_v_o_range(&self) -> &f32 {
        &self.screaming_v_o_range
    }
    fn screaming_v_o_range_mut(&mut self) -> &mut f32 {
        &mut self.screaming_v_o_range
    }
    fn complete_on_melee(&self) -> &bool {
        &self.complete_on_melee
    }
    fn complete_on_melee_mut(&mut self) -> &mut bool {
        &mut self.complete_on_melee
    }
    fn charge_cooldown(&self) -> &f32 {
        &self.charge_cooldown
    }
    fn charge_cooldown_mut(&mut self) -> &mut f32 {
        &mut self.charge_cooldown
    }
    fn off_navmesh_correction(&self) -> &f32 {
        &self.off_navmesh_correction
    }
    fn off_navmesh_correction_mut(&mut self) -> &mut f32 {
        &mut self.off_navmesh_correction
    }
}

impl super::core::DataContainerTrait for MeleeChargeSettings {
}

pub static MELEECHARGESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeChargeSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeleeChargeSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(MeleeChargeSettings, move_settings),
            },
            FieldInfoData {
                name: "MeleeProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileSettings",
                rust_offset: offset_of!(MeleeChargeSettings, melee_projectile_settings),
            },
            FieldInfoData {
                name: "DynamicMeleeChargeTokensSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "DynamicMeleeChargeTokensSettings",
                rust_offset: offset_of!(MeleeChargeSettings, dynamic_melee_charge_tokens_settings),
            },
            FieldInfoData {
                name: "MinMeleeChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeSettings, min_melee_charge_distance),
            },
            FieldInfoData {
                name: "MaxMeleeChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeSettings, max_melee_charge_distance),
            },
            FieldInfoData {
                name: "TimeStopMeleeChargeForInvalidPath",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeSettings, time_stop_melee_charge_for_invalid_path),
            },
            FieldInfoData {
                name: "MinTimeInPlayerViewToCharge",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeSettings, min_time_in_player_view_to_charge),
            },
            FieldInfoData {
                name: "MaxTimeInPlayerViewToCharge",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeSettings, max_time_in_player_view_to_charge),
            },
            FieldInfoData {
                name: "BypassTokenRequirement",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeChargeSettings, bypass_token_requirement),
            },
            FieldInfoData {
                name: "AllowChargingChargedTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeChargeSettings, allow_charging_charged_target),
            },
            FieldInfoData {
                name: "ManualTokenRelease",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeChargeSettings, manual_token_release),
            },
            FieldInfoData {
                name: "CheckIsPlayerInFront",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeChargeSettings, check_is_player_in_front),
            },
            FieldInfoData {
                name: "DisableCannedStarts",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeChargeSettings, disable_canned_starts),
            },
            FieldInfoData {
                name: "DisableCannedStops",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeChargeSettings, disable_canned_stops),
            },
            FieldInfoData {
                name: "DisableCannedTurns",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeChargeSettings, disable_canned_turns),
            },
            FieldInfoData {
                name: "DisableCannedAnimationRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeSettings, disable_canned_animation_range),
            },
            FieldInfoData {
                name: "WarpOnAttack",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeChargeSettings, warp_on_attack),
            },
            FieldInfoData {
                name: "ScreamingVORange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeSettings, screaming_v_o_range),
            },
            FieldInfoData {
                name: "CompleteOnMelee",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MeleeChargeSettings, complete_on_melee),
            },
            FieldInfoData {
                name: "ChargeCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeSettings, charge_cooldown),
            },
            FieldInfoData {
                name: "OffNavmeshCorrection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeSettings, off_navmesh_correction),
            },
        ],
    }),
    array_type: Some(MELEECHARGESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeleeChargeSettings {
    fn type_info(&self) -> &'static TypeInfo {
        MELEECHARGESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MELEECHARGESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeChargeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MeleeChargeSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DynamicMeleeChargeTokensSettings {
    pub _glacier_base: super::core::DataContainer,
    pub trigger_refill_token_count: i32,
    pub refill_token_count: i32,
    pub force_melee_charge_distance: f32,
    pub time_force_melee_charge: f32,
    pub stop_melee_charge_distance: f32,
    pub time_stop_melee_charge_for_distance: f32,
}

pub trait DynamicMeleeChargeTokensSettingsTrait: super::core::DataContainerTrait {
    fn trigger_refill_token_count(&self) -> &i32;
    fn trigger_refill_token_count_mut(&mut self) -> &mut i32;
    fn refill_token_count(&self) -> &i32;
    fn refill_token_count_mut(&mut self) -> &mut i32;
    fn force_melee_charge_distance(&self) -> &f32;
    fn force_melee_charge_distance_mut(&mut self) -> &mut f32;
    fn time_force_melee_charge(&self) -> &f32;
    fn time_force_melee_charge_mut(&mut self) -> &mut f32;
    fn stop_melee_charge_distance(&self) -> &f32;
    fn stop_melee_charge_distance_mut(&mut self) -> &mut f32;
    fn time_stop_melee_charge_for_distance(&self) -> &f32;
    fn time_stop_melee_charge_for_distance_mut(&mut self) -> &mut f32;
}

impl DynamicMeleeChargeTokensSettingsTrait for DynamicMeleeChargeTokensSettings {
    fn trigger_refill_token_count(&self) -> &i32 {
        &self.trigger_refill_token_count
    }
    fn trigger_refill_token_count_mut(&mut self) -> &mut i32 {
        &mut self.trigger_refill_token_count
    }
    fn refill_token_count(&self) -> &i32 {
        &self.refill_token_count
    }
    fn refill_token_count_mut(&mut self) -> &mut i32 {
        &mut self.refill_token_count
    }
    fn force_melee_charge_distance(&self) -> &f32 {
        &self.force_melee_charge_distance
    }
    fn force_melee_charge_distance_mut(&mut self) -> &mut f32 {
        &mut self.force_melee_charge_distance
    }
    fn time_force_melee_charge(&self) -> &f32 {
        &self.time_force_melee_charge
    }
    fn time_force_melee_charge_mut(&mut self) -> &mut f32 {
        &mut self.time_force_melee_charge
    }
    fn stop_melee_charge_distance(&self) -> &f32 {
        &self.stop_melee_charge_distance
    }
    fn stop_melee_charge_distance_mut(&mut self) -> &mut f32 {
        &mut self.stop_melee_charge_distance
    }
    fn time_stop_melee_charge_for_distance(&self) -> &f32 {
        &self.time_stop_melee_charge_for_distance
    }
    fn time_stop_melee_charge_for_distance_mut(&mut self) -> &mut f32 {
        &mut self.time_stop_melee_charge_for_distance
    }
}

impl super::core::DataContainerTrait for DynamicMeleeChargeTokensSettings {
}

pub static DYNAMICMELEECHARGETOKENSSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicMeleeChargeTokensSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DynamicMeleeChargeTokensSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TriggerRefillTokenCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, trigger_refill_token_count),
            },
            FieldInfoData {
                name: "RefillTokenCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, refill_token_count),
            },
            FieldInfoData {
                name: "ForceMeleeChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, force_melee_charge_distance),
            },
            FieldInfoData {
                name: "TimeForceMeleeCharge",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, time_force_melee_charge),
            },
            FieldInfoData {
                name: "StopMeleeChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, stop_melee_charge_distance),
            },
            FieldInfoData {
                name: "TimeStopMeleeChargeForDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, time_stop_melee_charge_for_distance),
            },
        ],
    }),
    array_type: Some(DYNAMICMELEECHARGETOKENSSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DynamicMeleeChargeTokensSettings {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICMELEECHARGETOKENSSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DYNAMICMELEECHARGETOKENSSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicMeleeChargeTokensSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DynamicMeleeChargeTokensSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BerserkSettings {
    pub _glacier_base: super::core::DataContainer,
    pub only_scriptable: bool,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub berserk_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub max_berserk_distance: f32,
    pub melee_projectile_settings: Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>,
    pub projectile_settings: Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>,
}

pub trait BerserkSettingsTrait: super::core::DataContainerTrait {
    fn only_scriptable(&self) -> &bool;
    fn only_scriptable_mut(&mut self) -> &mut bool;
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn berserk_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn berserk_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn max_berserk_distance(&self) -> &f32;
    fn max_berserk_distance_mut(&mut self) -> &mut f32;
    fn melee_projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn melee_projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
    fn projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>>;
}

impl BerserkSettingsTrait for BerserkSettings {
    fn only_scriptable(&self) -> &bool {
        &self.only_scriptable
    }
    fn only_scriptable_mut(&mut self) -> &mut bool {
        &mut self.only_scriptable
    }
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn berserk_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.berserk_cover_query
    }
    fn berserk_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.berserk_cover_query
    }
    fn max_berserk_distance(&self) -> &f32 {
        &self.max_berserk_distance
    }
    fn max_berserk_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_berserk_distance
    }
    fn melee_projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &self.melee_projectile_settings
    }
    fn melee_projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &mut self.melee_projectile_settings
    }
    fn projectile_settings(&self) -> &Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &self.projectile_settings
    }
    fn projectile_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ProjectileSettingsTrait>>> {
        &mut self.projectile_settings
    }
}

impl super::core::DataContainerTrait for BerserkSettings {
}

pub static BERSERKSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BerserkSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BerserkSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OnlyScriptable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BerserkSettings, only_scriptable),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(BerserkSettings, move_settings),
            },
            FieldInfoData {
                name: "BerserkCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(BerserkSettings, berserk_cover_query),
            },
            FieldInfoData {
                name: "MaxBerserkDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BerserkSettings, max_berserk_distance),
            },
            FieldInfoData {
                name: "MeleeProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileSettings",
                rust_offset: offset_of!(BerserkSettings, melee_projectile_settings),
            },
            FieldInfoData {
                name: "ProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileSettings",
                rust_offset: offset_of!(BerserkSettings, projectile_settings),
            },
        ],
    }),
    array_type: Some(BERSERKSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BerserkSettings {
    fn type_info(&self) -> &'static TypeInfo {
        BERSERKSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BERSERKSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BerserkSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BerserkSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChargeSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub charge_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub allowed_to_charge_distance: f32,
}

pub trait ChargeSettingsTrait: super::core::DataContainerTrait {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn charge_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn charge_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn allowed_to_charge_distance(&self) -> &f32;
    fn allowed_to_charge_distance_mut(&mut self) -> &mut f32;
}

impl ChargeSettingsTrait for ChargeSettings {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn charge_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.charge_cover_query
    }
    fn charge_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.charge_cover_query
    }
    fn allowed_to_charge_distance(&self) -> &f32 {
        &self.allowed_to_charge_distance
    }
    fn allowed_to_charge_distance_mut(&mut self) -> &mut f32 {
        &mut self.allowed_to_charge_distance
    }
}

impl super::core::DataContainerTrait for ChargeSettings {
}

pub static CHARGESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChargeSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChargeSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(ChargeSettings, move_settings),
            },
            FieldInfoData {
                name: "ChargeCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(ChargeSettings, charge_cover_query),
            },
            FieldInfoData {
                name: "AllowedToChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChargeSettings, allowed_to_charge_distance),
            },
        ],
    }),
    array_type: Some(CHARGESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChargeSettings {
    fn type_info(&self) -> &'static TypeInfo {
        CHARGESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHARGESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChargeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ChargeSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_settings: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub distance_to_vehicle: f32,
    pub distance_vehicle_to_human: f32,
}

pub trait VehicleSettingsTrait: super::core::DataContainerTrait {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn distance_to_vehicle(&self) -> &f32;
    fn distance_to_vehicle_mut(&mut self) -> &mut f32;
    fn distance_vehicle_to_human(&self) -> &f32;
    fn distance_vehicle_to_human_mut(&mut self) -> &mut f32;
}

impl VehicleSettingsTrait for VehicleSettings {
    fn move_settings(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings
    }
    fn move_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings
    }
    fn distance_to_vehicle(&self) -> &f32 {
        &self.distance_to_vehicle
    }
    fn distance_to_vehicle_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_vehicle
    }
    fn distance_vehicle_to_human(&self) -> &f32 {
        &self.distance_vehicle_to_human
    }
    fn distance_vehicle_to_human_mut(&mut self) -> &mut f32 {
        &mut self.distance_vehicle_to_human
    }
}

impl super::core::DataContainerTrait for VehicleSettings {
}

pub static VEHICLESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(VehicleSettings, move_settings),
            },
            FieldInfoData {
                name: "DistanceToVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSettings, distance_to_vehicle),
            },
            FieldInfoData {
                name: "DistanceVehicleToHuman",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleSettings, distance_vehicle_to_human),
            },
        ],
    }),
    array_type: Some(VEHICLESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleSettings {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIMeleeSettings {
    pub _glacier_base: super::core::DataContainer,
    pub team_melee_attack_interval_time: f32,
    pub last_melee_timer: f32,
    pub player_health_takedown_threshold: f32,
    pub max_player_takedown_angle_deg: f32,
    pub check_animation_allows_fire: bool,
    pub charge_between_attacks: bool,
}

pub trait AIMeleeSettingsTrait: super::core::DataContainerTrait {
    fn team_melee_attack_interval_time(&self) -> &f32;
    fn team_melee_attack_interval_time_mut(&mut self) -> &mut f32;
    fn last_melee_timer(&self) -> &f32;
    fn last_melee_timer_mut(&mut self) -> &mut f32;
    fn player_health_takedown_threshold(&self) -> &f32;
    fn player_health_takedown_threshold_mut(&mut self) -> &mut f32;
    fn max_player_takedown_angle_deg(&self) -> &f32;
    fn max_player_takedown_angle_deg_mut(&mut self) -> &mut f32;
    fn check_animation_allows_fire(&self) -> &bool;
    fn check_animation_allows_fire_mut(&mut self) -> &mut bool;
    fn charge_between_attacks(&self) -> &bool;
    fn charge_between_attacks_mut(&mut self) -> &mut bool;
}

impl AIMeleeSettingsTrait for AIMeleeSettings {
    fn team_melee_attack_interval_time(&self) -> &f32 {
        &self.team_melee_attack_interval_time
    }
    fn team_melee_attack_interval_time_mut(&mut self) -> &mut f32 {
        &mut self.team_melee_attack_interval_time
    }
    fn last_melee_timer(&self) -> &f32 {
        &self.last_melee_timer
    }
    fn last_melee_timer_mut(&mut self) -> &mut f32 {
        &mut self.last_melee_timer
    }
    fn player_health_takedown_threshold(&self) -> &f32 {
        &self.player_health_takedown_threshold
    }
    fn player_health_takedown_threshold_mut(&mut self) -> &mut f32 {
        &mut self.player_health_takedown_threshold
    }
    fn max_player_takedown_angle_deg(&self) -> &f32 {
        &self.max_player_takedown_angle_deg
    }
    fn max_player_takedown_angle_deg_mut(&mut self) -> &mut f32 {
        &mut self.max_player_takedown_angle_deg
    }
    fn check_animation_allows_fire(&self) -> &bool {
        &self.check_animation_allows_fire
    }
    fn check_animation_allows_fire_mut(&mut self) -> &mut bool {
        &mut self.check_animation_allows_fire
    }
    fn charge_between_attacks(&self) -> &bool {
        &self.charge_between_attacks
    }
    fn charge_between_attacks_mut(&mut self) -> &mut bool {
        &mut self.charge_between_attacks
    }
}

impl super::core::DataContainerTrait for AIMeleeSettings {
}

pub static AIMELEESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIMeleeSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIMeleeSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TeamMeleeAttackIntervalTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIMeleeSettings, team_melee_attack_interval_time),
            },
            FieldInfoData {
                name: "LastMeleeTimer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIMeleeSettings, last_melee_timer),
            },
            FieldInfoData {
                name: "PlayerHealthTakedownThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIMeleeSettings, player_health_takedown_threshold),
            },
            FieldInfoData {
                name: "MaxPlayerTakedownAngleDeg",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIMeleeSettings, max_player_takedown_angle_deg),
            },
            FieldInfoData {
                name: "CheckAnimationAllowsFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIMeleeSettings, check_animation_allows_fire),
            },
            FieldInfoData {
                name: "ChargeBetweenAttacks",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIMeleeSettings, charge_between_attacks),
            },
        ],
    }),
    array_type: Some(AIMELEESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIMeleeSettings {
    fn type_info(&self) -> &'static TypeInfo {
        AIMELEESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMELEESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIMeleeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIMeleeSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProjectileSettings {
    pub _glacier_base: super::core::DataContainer,
    pub is_continuous: bool,
    pub minimum_interval: f32,
    pub maximum_interval: f32,
    pub require_passive_damage: bool,
    pub require_passive_movement: bool,
    pub charge: bool,
    pub avoid_friendly_fire: bool,
    pub friendly_fire_radius: f32,
    pub lower: f32,
    pub upper: f32,
    pub valid_against: ValidAgainst,
    pub a_i_melee_settings: Option<Arc<Mutex<dyn AIMeleeSettingsTrait>>>,
}

pub trait ProjectileSettingsTrait: super::core::DataContainerTrait {
    fn is_continuous(&self) -> &bool;
    fn is_continuous_mut(&mut self) -> &mut bool;
    fn minimum_interval(&self) -> &f32;
    fn minimum_interval_mut(&mut self) -> &mut f32;
    fn maximum_interval(&self) -> &f32;
    fn maximum_interval_mut(&mut self) -> &mut f32;
    fn require_passive_damage(&self) -> &bool;
    fn require_passive_damage_mut(&mut self) -> &mut bool;
    fn require_passive_movement(&self) -> &bool;
    fn require_passive_movement_mut(&mut self) -> &mut bool;
    fn charge(&self) -> &bool;
    fn charge_mut(&mut self) -> &mut bool;
    fn avoid_friendly_fire(&self) -> &bool;
    fn avoid_friendly_fire_mut(&mut self) -> &mut bool;
    fn friendly_fire_radius(&self) -> &f32;
    fn friendly_fire_radius_mut(&mut self) -> &mut f32;
    fn lower(&self) -> &f32;
    fn lower_mut(&mut self) -> &mut f32;
    fn upper(&self) -> &f32;
    fn upper_mut(&mut self) -> &mut f32;
    fn valid_against(&self) -> &ValidAgainst;
    fn valid_against_mut(&mut self) -> &mut ValidAgainst;
    fn a_i_melee_settings(&self) -> &Option<Arc<Mutex<dyn AIMeleeSettingsTrait>>>;
    fn a_i_melee_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIMeleeSettingsTrait>>>;
}

impl ProjectileSettingsTrait for ProjectileSettings {
    fn is_continuous(&self) -> &bool {
        &self.is_continuous
    }
    fn is_continuous_mut(&mut self) -> &mut bool {
        &mut self.is_continuous
    }
    fn minimum_interval(&self) -> &f32 {
        &self.minimum_interval
    }
    fn minimum_interval_mut(&mut self) -> &mut f32 {
        &mut self.minimum_interval
    }
    fn maximum_interval(&self) -> &f32 {
        &self.maximum_interval
    }
    fn maximum_interval_mut(&mut self) -> &mut f32 {
        &mut self.maximum_interval
    }
    fn require_passive_damage(&self) -> &bool {
        &self.require_passive_damage
    }
    fn require_passive_damage_mut(&mut self) -> &mut bool {
        &mut self.require_passive_damage
    }
    fn require_passive_movement(&self) -> &bool {
        &self.require_passive_movement
    }
    fn require_passive_movement_mut(&mut self) -> &mut bool {
        &mut self.require_passive_movement
    }
    fn charge(&self) -> &bool {
        &self.charge
    }
    fn charge_mut(&mut self) -> &mut bool {
        &mut self.charge
    }
    fn avoid_friendly_fire(&self) -> &bool {
        &self.avoid_friendly_fire
    }
    fn avoid_friendly_fire_mut(&mut self) -> &mut bool {
        &mut self.avoid_friendly_fire
    }
    fn friendly_fire_radius(&self) -> &f32 {
        &self.friendly_fire_radius
    }
    fn friendly_fire_radius_mut(&mut self) -> &mut f32 {
        &mut self.friendly_fire_radius
    }
    fn lower(&self) -> &f32 {
        &self.lower
    }
    fn lower_mut(&mut self) -> &mut f32 {
        &mut self.lower
    }
    fn upper(&self) -> &f32 {
        &self.upper
    }
    fn upper_mut(&mut self) -> &mut f32 {
        &mut self.upper
    }
    fn valid_against(&self) -> &ValidAgainst {
        &self.valid_against
    }
    fn valid_against_mut(&mut self) -> &mut ValidAgainst {
        &mut self.valid_against
    }
    fn a_i_melee_settings(&self) -> &Option<Arc<Mutex<dyn AIMeleeSettingsTrait>>> {
        &self.a_i_melee_settings
    }
    fn a_i_melee_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIMeleeSettingsTrait>>> {
        &mut self.a_i_melee_settings
    }
}

impl super::core::DataContainerTrait for ProjectileSettings {
}

pub static PROJECTILESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProjectileSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProjectileSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsContinuous",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProjectileSettings, is_continuous),
            },
            FieldInfoData {
                name: "MinimumInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProjectileSettings, minimum_interval),
            },
            FieldInfoData {
                name: "MaximumInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProjectileSettings, maximum_interval),
            },
            FieldInfoData {
                name: "RequirePassiveDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProjectileSettings, require_passive_damage),
            },
            FieldInfoData {
                name: "RequirePassiveMovement",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProjectileSettings, require_passive_movement),
            },
            FieldInfoData {
                name: "Charge",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProjectileSettings, charge),
            },
            FieldInfoData {
                name: "AvoidFriendlyFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProjectileSettings, avoid_friendly_fire),
            },
            FieldInfoData {
                name: "FriendlyFireRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProjectileSettings, friendly_fire_radius),
            },
            FieldInfoData {
                name: "Lower",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProjectileSettings, lower),
            },
            FieldInfoData {
                name: "Upper",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProjectileSettings, upper),
            },
            FieldInfoData {
                name: "ValidAgainst",
                flags: MemberInfoFlags::new(0),
                field_type: "ValidAgainst",
                rust_offset: offset_of!(ProjectileSettings, valid_against),
            },
            FieldInfoData {
                name: "AIMeleeSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "AIMeleeSettings",
                rust_offset: offset_of!(ProjectileSettings, a_i_melee_settings),
            },
        ],
    }),
    array_type: Some(PROJECTILESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ProjectileSettings {
    fn type_info(&self) -> &'static TypeInfo {
        PROJECTILESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROJECTILESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProjectileSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ProjectileSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PoseSettings {
    pub _glacier_base: super::core::DataContainer,
    pub pose: Pose,
}

pub trait PoseSettingsTrait: super::core::DataContainerTrait {
    fn pose(&self) -> &Pose;
    fn pose_mut(&mut self) -> &mut Pose;
}

impl PoseSettingsTrait for PoseSettings {
    fn pose(&self) -> &Pose {
        &self.pose
    }
    fn pose_mut(&mut self) -> &mut Pose {
        &mut self.pose
    }
}

impl super::core::DataContainerTrait for PoseSettings {
}

pub static POSESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PoseSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Pose",
                flags: MemberInfoFlags::new(0),
                field_type: "Pose",
                rust_offset: offset_of!(PoseSettings, pose),
            },
        ],
    }),
    array_type: Some(POSESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PoseSettings {
    fn type_info(&self) -> &'static TypeInfo {
        POSESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static POSESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PoseSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverControlSettings {
    pub _glacier_base: super::core::DataContainer,
    pub firing_times: Vec<f32>,
    pub idle_times: Vec<f32>,
    pub allow_suppression: bool,
    pub suppression_threshold: f32,
    pub allow_open_cover_crouch: bool,
    pub cover_hover_settings: CoverHoverData,
    pub cover_side_step_settings: CoverSideStepData,
}

pub trait CoverControlSettingsTrait: super::core::DataContainerTrait {
    fn firing_times(&self) -> &Vec<f32>;
    fn firing_times_mut(&mut self) -> &mut Vec<f32>;
    fn idle_times(&self) -> &Vec<f32>;
    fn idle_times_mut(&mut self) -> &mut Vec<f32>;
    fn allow_suppression(&self) -> &bool;
    fn allow_suppression_mut(&mut self) -> &mut bool;
    fn suppression_threshold(&self) -> &f32;
    fn suppression_threshold_mut(&mut self) -> &mut f32;
    fn allow_open_cover_crouch(&self) -> &bool;
    fn allow_open_cover_crouch_mut(&mut self) -> &mut bool;
    fn cover_hover_settings(&self) -> &CoverHoverData;
    fn cover_hover_settings_mut(&mut self) -> &mut CoverHoverData;
    fn cover_side_step_settings(&self) -> &CoverSideStepData;
    fn cover_side_step_settings_mut(&mut self) -> &mut CoverSideStepData;
}

impl CoverControlSettingsTrait for CoverControlSettings {
    fn firing_times(&self) -> &Vec<f32> {
        &self.firing_times
    }
    fn firing_times_mut(&mut self) -> &mut Vec<f32> {
        &mut self.firing_times
    }
    fn idle_times(&self) -> &Vec<f32> {
        &self.idle_times
    }
    fn idle_times_mut(&mut self) -> &mut Vec<f32> {
        &mut self.idle_times
    }
    fn allow_suppression(&self) -> &bool {
        &self.allow_suppression
    }
    fn allow_suppression_mut(&mut self) -> &mut bool {
        &mut self.allow_suppression
    }
    fn suppression_threshold(&self) -> &f32 {
        &self.suppression_threshold
    }
    fn suppression_threshold_mut(&mut self) -> &mut f32 {
        &mut self.suppression_threshold
    }
    fn allow_open_cover_crouch(&self) -> &bool {
        &self.allow_open_cover_crouch
    }
    fn allow_open_cover_crouch_mut(&mut self) -> &mut bool {
        &mut self.allow_open_cover_crouch
    }
    fn cover_hover_settings(&self) -> &CoverHoverData {
        &self.cover_hover_settings
    }
    fn cover_hover_settings_mut(&mut self) -> &mut CoverHoverData {
        &mut self.cover_hover_settings
    }
    fn cover_side_step_settings(&self) -> &CoverSideStepData {
        &self.cover_side_step_settings
    }
    fn cover_side_step_settings_mut(&mut self) -> &mut CoverSideStepData {
        &mut self.cover_side_step_settings
    }
}

impl super::core::DataContainerTrait for CoverControlSettings {
}

pub static COVERCONTROLSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverControlSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverControlSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FiringTimes",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(CoverControlSettings, firing_times),
            },
            FieldInfoData {
                name: "IdleTimes",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(CoverControlSettings, idle_times),
            },
            FieldInfoData {
                name: "AllowSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverControlSettings, allow_suppression),
            },
            FieldInfoData {
                name: "SuppressionThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverControlSettings, suppression_threshold),
            },
            FieldInfoData {
                name: "AllowOpenCoverCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverControlSettings, allow_open_cover_crouch),
            },
            FieldInfoData {
                name: "CoverHoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverHoverData",
                rust_offset: offset_of!(CoverControlSettings, cover_hover_settings),
            },
            FieldInfoData {
                name: "CoverSideStepSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverSideStepData",
                rust_offset: offset_of!(CoverControlSettings, cover_side_step_settings),
            },
        ],
    }),
    array_type: Some(COVERCONTROLSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverControlSettings {
    fn type_info(&self) -> &'static TypeInfo {
        COVERCONTROLSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERCONTROLSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverControlSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverControlSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverHoverData {
    pub max_distance_to_target: f32,
    pub min_hover_time: f32,
    pub max_hover_time: f32,
    pub min_hover_interval: f32,
    pub max_hover_interval: f32,
    pub cover_side_hover_settings: CoverSideStepData,
}

pub trait CoverHoverDataTrait: TypeObject {
    fn max_distance_to_target(&self) -> &f32;
    fn max_distance_to_target_mut(&mut self) -> &mut f32;
    fn min_hover_time(&self) -> &f32;
    fn min_hover_time_mut(&mut self) -> &mut f32;
    fn max_hover_time(&self) -> &f32;
    fn max_hover_time_mut(&mut self) -> &mut f32;
    fn min_hover_interval(&self) -> &f32;
    fn min_hover_interval_mut(&mut self) -> &mut f32;
    fn max_hover_interval(&self) -> &f32;
    fn max_hover_interval_mut(&mut self) -> &mut f32;
    fn cover_side_hover_settings(&self) -> &CoverSideStepData;
    fn cover_side_hover_settings_mut(&mut self) -> &mut CoverSideStepData;
}

impl CoverHoverDataTrait for CoverHoverData {
    fn max_distance_to_target(&self) -> &f32 {
        &self.max_distance_to_target
    }
    fn max_distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_to_target
    }
    fn min_hover_time(&self) -> &f32 {
        &self.min_hover_time
    }
    fn min_hover_time_mut(&mut self) -> &mut f32 {
        &mut self.min_hover_time
    }
    fn max_hover_time(&self) -> &f32 {
        &self.max_hover_time
    }
    fn max_hover_time_mut(&mut self) -> &mut f32 {
        &mut self.max_hover_time
    }
    fn min_hover_interval(&self) -> &f32 {
        &self.min_hover_interval
    }
    fn min_hover_interval_mut(&mut self) -> &mut f32 {
        &mut self.min_hover_interval
    }
    fn max_hover_interval(&self) -> &f32 {
        &self.max_hover_interval
    }
    fn max_hover_interval_mut(&mut self) -> &mut f32 {
        &mut self.max_hover_interval
    }
    fn cover_side_hover_settings(&self) -> &CoverSideStepData {
        &self.cover_side_hover_settings
    }
    fn cover_side_hover_settings_mut(&mut self) -> &mut CoverSideStepData {
        &mut self.cover_side_hover_settings
    }
}

pub static COVERHOVERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverHoverData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverHoverData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverHoverData, max_distance_to_target),
            },
            FieldInfoData {
                name: "MinHoverTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverHoverData, min_hover_time),
            },
            FieldInfoData {
                name: "MaxHoverTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverHoverData, max_hover_time),
            },
            FieldInfoData {
                name: "MinHoverInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverHoverData, min_hover_interval),
            },
            FieldInfoData {
                name: "MaxHoverInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverHoverData, max_hover_interval),
            },
            FieldInfoData {
                name: "CoverSideHoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverSideStepData",
                rust_offset: offset_of!(CoverHoverData, cover_side_hover_settings),
            },
        ],
    }),
    array_type: Some(COVERHOVERDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverHoverData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERHOVERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERHOVERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverHoverData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverHoverData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverSideStepData {
    pub shot_at_step_chance: i32,
    pub aim_at_step_chance: i32,
    pub aim_at_step_interval: f32,
    pub idle_step_chance: i32,
    pub idle_step_interval: f32,
    pub side_step_initial_cooldown: f32,
    pub side_step_cooldown: f32,
    pub side_step_angle_threshold: i32,
}

pub trait CoverSideStepDataTrait: TypeObject {
    fn shot_at_step_chance(&self) -> &i32;
    fn shot_at_step_chance_mut(&mut self) -> &mut i32;
    fn aim_at_step_chance(&self) -> &i32;
    fn aim_at_step_chance_mut(&mut self) -> &mut i32;
    fn aim_at_step_interval(&self) -> &f32;
    fn aim_at_step_interval_mut(&mut self) -> &mut f32;
    fn idle_step_chance(&self) -> &i32;
    fn idle_step_chance_mut(&mut self) -> &mut i32;
    fn idle_step_interval(&self) -> &f32;
    fn idle_step_interval_mut(&mut self) -> &mut f32;
    fn side_step_initial_cooldown(&self) -> &f32;
    fn side_step_initial_cooldown_mut(&mut self) -> &mut f32;
    fn side_step_cooldown(&self) -> &f32;
    fn side_step_cooldown_mut(&mut self) -> &mut f32;
    fn side_step_angle_threshold(&self) -> &i32;
    fn side_step_angle_threshold_mut(&mut self) -> &mut i32;
}

impl CoverSideStepDataTrait for CoverSideStepData {
    fn shot_at_step_chance(&self) -> &i32 {
        &self.shot_at_step_chance
    }
    fn shot_at_step_chance_mut(&mut self) -> &mut i32 {
        &mut self.shot_at_step_chance
    }
    fn aim_at_step_chance(&self) -> &i32 {
        &self.aim_at_step_chance
    }
    fn aim_at_step_chance_mut(&mut self) -> &mut i32 {
        &mut self.aim_at_step_chance
    }
    fn aim_at_step_interval(&self) -> &f32 {
        &self.aim_at_step_interval
    }
    fn aim_at_step_interval_mut(&mut self) -> &mut f32 {
        &mut self.aim_at_step_interval
    }
    fn idle_step_chance(&self) -> &i32 {
        &self.idle_step_chance
    }
    fn idle_step_chance_mut(&mut self) -> &mut i32 {
        &mut self.idle_step_chance
    }
    fn idle_step_interval(&self) -> &f32 {
        &self.idle_step_interval
    }
    fn idle_step_interval_mut(&mut self) -> &mut f32 {
        &mut self.idle_step_interval
    }
    fn side_step_initial_cooldown(&self) -> &f32 {
        &self.side_step_initial_cooldown
    }
    fn side_step_initial_cooldown_mut(&mut self) -> &mut f32 {
        &mut self.side_step_initial_cooldown
    }
    fn side_step_cooldown(&self) -> &f32 {
        &self.side_step_cooldown
    }
    fn side_step_cooldown_mut(&mut self) -> &mut f32 {
        &mut self.side_step_cooldown
    }
    fn side_step_angle_threshold(&self) -> &i32 {
        &self.side_step_angle_threshold
    }
    fn side_step_angle_threshold_mut(&mut self) -> &mut i32 {
        &mut self.side_step_angle_threshold
    }
}

pub static COVERSIDESTEPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverSideStepData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ShotAtStepChance",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverSideStepData, shot_at_step_chance),
            },
            FieldInfoData {
                name: "AimAtStepChance",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverSideStepData, aim_at_step_chance),
            },
            FieldInfoData {
                name: "AimAtStepInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverSideStepData, aim_at_step_interval),
            },
            FieldInfoData {
                name: "IdleStepChance",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverSideStepData, idle_step_chance),
            },
            FieldInfoData {
                name: "IdleStepInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverSideStepData, idle_step_interval),
            },
            FieldInfoData {
                name: "SideStepInitialCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverSideStepData, side_step_initial_cooldown),
            },
            FieldInfoData {
                name: "SideStepCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverSideStepData, side_step_cooldown),
            },
            FieldInfoData {
                name: "SideStepAngleThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverSideStepData, side_step_angle_threshold),
            },
        ],
    }),
    array_type: Some(COVERSIDESTEPDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverSideStepData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERSIDESTEPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERSIDESTEPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSideStepData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CheckTargetInVehicle {
    #[default]
    CheckTargetInVehicle_NoCheck = 0,
    CheckTargetInVehicle_InVehicle = 1,
    CheckTargetInVehicle_NotInVehicle = 2,
}

pub static CHECKTARGETINVEHICLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CheckTargetInVehicle",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHECKTARGETINVEHICLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CheckTargetInVehicle {
    fn type_info(&self) -> &'static TypeInfo {
        CHECKTARGETINVEHICLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CHECKTARGETINVEHICLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CheckTargetInVehicle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CheckTargetInVehicle"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISpawnData {
    pub _glacier_base: super::gameplay_sim::ExtraSpawnData,
    pub despawn_distance: f32,
}

pub trait AISpawnDataTrait: super::gameplay_sim::ExtraSpawnDataTrait {
    fn despawn_distance(&self) -> &f32;
    fn despawn_distance_mut(&mut self) -> &mut f32;
}

impl AISpawnDataTrait for AISpawnData {
    fn despawn_distance(&self) -> &f32 {
        &self.despawn_distance
    }
    fn despawn_distance_mut(&mut self) -> &mut f32 {
        &mut self.despawn_distance
    }
}

impl super::gameplay_sim::ExtraSpawnDataTrait for AISpawnData {
}

impl super::core::DataContainerTrait for AISpawnData {
}

pub static AISPAWNDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpawnData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::EXTRASPAWNDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISpawnData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DespawnDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISpawnData, despawn_distance),
            },
        ],
    }),
    array_type: Some(AISPAWNDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISpawnData {
    fn type_info(&self) -> &'static TypeInfo {
        AISPAWNDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISPAWNDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpawnData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISpawnData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum Tactics {
    #[default]
    NoTactic = 0,
    VehicleTactic = 1,
    ChargeTactic = 2,
    AttackTactic = 3,
    HideTactic = 4,
    FleeTactic = 5,
    CloseCombatTactic = 6,
    BerserkTactic = 7,
    CloseRangeAttackTactic = 8,
    SquadMovementTactic = 9,
    SquadEngageTactic = 10,
    InvestigateTactic = 11,
    CombatInvestigateTactic = 12,
    CombatSearchAreaTactic = 13,
    SearchAreaTactic = 14,
    ExecuteIdleActionTactic = 15,
    ExecuteSearchActionTactic = 16,
    ExecuteCombatActionTactic = 17,
    FollowTactic = 18,
    GoToTargetTactic = 19,
    EvadeTactic = 20,
    MeleeChargeTactic = 21,
    GoToAttackPointTactic = 22,
    TacticsCount = 23,
}

pub static TACTICS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Tactics",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(TACTICS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Tactics {
    fn type_info(&self) -> &'static TypeInfo {
        TACTICS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TACTICS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Tactics-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Tactics"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AirTargetSelectorEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub search_radius: f32,
    pub target_lost_slack: f32,
    pub max_attacker_count_for_priority_to_count: i32,
    pub prioritize_attackers_from_behind: bool,
    pub max_aim_angle_fault: f32,
    pub max_angle_off_our_backwards_vector: f32,
    pub max_distance: f32,
    pub max_team1_human_attackers: i32,
    pub max_team2_human_attackers: i32,
    pub evenly_distribute_targets: bool,
    pub dont_attack_targets_being_chased_by_humans: bool,
    pub maximum_distance_to_human_to_drop_current_target: f32,
    pub prioritize_humans: bool,
    pub auto_activate: bool,
    pub max_entities_updated_per_frame: i32,
}

pub trait AirTargetSelectorEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn search_radius(&self) -> &f32;
    fn search_radius_mut(&mut self) -> &mut f32;
    fn target_lost_slack(&self) -> &f32;
    fn target_lost_slack_mut(&mut self) -> &mut f32;
    fn max_attacker_count_for_priority_to_count(&self) -> &i32;
    fn max_attacker_count_for_priority_to_count_mut(&mut self) -> &mut i32;
    fn prioritize_attackers_from_behind(&self) -> &bool;
    fn prioritize_attackers_from_behind_mut(&mut self) -> &mut bool;
    fn max_aim_angle_fault(&self) -> &f32;
    fn max_aim_angle_fault_mut(&mut self) -> &mut f32;
    fn max_angle_off_our_backwards_vector(&self) -> &f32;
    fn max_angle_off_our_backwards_vector_mut(&mut self) -> &mut f32;
    fn max_distance(&self) -> &f32;
    fn max_distance_mut(&mut self) -> &mut f32;
    fn max_team1_human_attackers(&self) -> &i32;
    fn max_team1_human_attackers_mut(&mut self) -> &mut i32;
    fn max_team2_human_attackers(&self) -> &i32;
    fn max_team2_human_attackers_mut(&mut self) -> &mut i32;
    fn evenly_distribute_targets(&self) -> &bool;
    fn evenly_distribute_targets_mut(&mut self) -> &mut bool;
    fn dont_attack_targets_being_chased_by_humans(&self) -> &bool;
    fn dont_attack_targets_being_chased_by_humans_mut(&mut self) -> &mut bool;
    fn maximum_distance_to_human_to_drop_current_target(&self) -> &f32;
    fn maximum_distance_to_human_to_drop_current_target_mut(&mut self) -> &mut f32;
    fn prioritize_humans(&self) -> &bool;
    fn prioritize_humans_mut(&mut self) -> &mut bool;
    fn auto_activate(&self) -> &bool;
    fn auto_activate_mut(&mut self) -> &mut bool;
    fn max_entities_updated_per_frame(&self) -> &i32;
    fn max_entities_updated_per_frame_mut(&mut self) -> &mut i32;
}

impl AirTargetSelectorEntityDataTrait for AirTargetSelectorEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn search_radius(&self) -> &f32 {
        &self.search_radius
    }
    fn search_radius_mut(&mut self) -> &mut f32 {
        &mut self.search_radius
    }
    fn target_lost_slack(&self) -> &f32 {
        &self.target_lost_slack
    }
    fn target_lost_slack_mut(&mut self) -> &mut f32 {
        &mut self.target_lost_slack
    }
    fn max_attacker_count_for_priority_to_count(&self) -> &i32 {
        &self.max_attacker_count_for_priority_to_count
    }
    fn max_attacker_count_for_priority_to_count_mut(&mut self) -> &mut i32 {
        &mut self.max_attacker_count_for_priority_to_count
    }
    fn prioritize_attackers_from_behind(&self) -> &bool {
        &self.prioritize_attackers_from_behind
    }
    fn prioritize_attackers_from_behind_mut(&mut self) -> &mut bool {
        &mut self.prioritize_attackers_from_behind
    }
    fn max_aim_angle_fault(&self) -> &f32 {
        &self.max_aim_angle_fault
    }
    fn max_aim_angle_fault_mut(&mut self) -> &mut f32 {
        &mut self.max_aim_angle_fault
    }
    fn max_angle_off_our_backwards_vector(&self) -> &f32 {
        &self.max_angle_off_our_backwards_vector
    }
    fn max_angle_off_our_backwards_vector_mut(&mut self) -> &mut f32 {
        &mut self.max_angle_off_our_backwards_vector
    }
    fn max_distance(&self) -> &f32 {
        &self.max_distance
    }
    fn max_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_distance
    }
    fn max_team1_human_attackers(&self) -> &i32 {
        &self.max_team1_human_attackers
    }
    fn max_team1_human_attackers_mut(&mut self) -> &mut i32 {
        &mut self.max_team1_human_attackers
    }
    fn max_team2_human_attackers(&self) -> &i32 {
        &self.max_team2_human_attackers
    }
    fn max_team2_human_attackers_mut(&mut self) -> &mut i32 {
        &mut self.max_team2_human_attackers
    }
    fn evenly_distribute_targets(&self) -> &bool {
        &self.evenly_distribute_targets
    }
    fn evenly_distribute_targets_mut(&mut self) -> &mut bool {
        &mut self.evenly_distribute_targets
    }
    fn dont_attack_targets_being_chased_by_humans(&self) -> &bool {
        &self.dont_attack_targets_being_chased_by_humans
    }
    fn dont_attack_targets_being_chased_by_humans_mut(&mut self) -> &mut bool {
        &mut self.dont_attack_targets_being_chased_by_humans
    }
    fn maximum_distance_to_human_to_drop_current_target(&self) -> &f32 {
        &self.maximum_distance_to_human_to_drop_current_target
    }
    fn maximum_distance_to_human_to_drop_current_target_mut(&mut self) -> &mut f32 {
        &mut self.maximum_distance_to_human_to_drop_current_target
    }
    fn prioritize_humans(&self) -> &bool {
        &self.prioritize_humans
    }
    fn prioritize_humans_mut(&mut self) -> &mut bool {
        &mut self.prioritize_humans
    }
    fn auto_activate(&self) -> &bool {
        &self.auto_activate
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        &mut self.auto_activate
    }
    fn max_entities_updated_per_frame(&self) -> &i32 {
        &self.max_entities_updated_per_frame
    }
    fn max_entities_updated_per_frame_mut(&mut self) -> &mut i32 {
        &mut self.max_entities_updated_per_frame
    }
}

impl super::entity::EntityDataTrait for AirTargetSelectorEntityData {
}

impl super::entity::GameObjectDataTrait for AirTargetSelectorEntityData {
}

impl super::core::DataBusPeerTrait for AirTargetSelectorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AirTargetSelectorEntityData {
}

impl super::core::DataContainerTrait for AirTargetSelectorEntityData {
}

pub static AIRTARGETSELECTORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirTargetSelectorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AirTargetSelectorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AirTargetSelectorEntityData, realm),
            },
            FieldInfoData {
                name: "SearchRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, search_radius),
            },
            FieldInfoData {
                name: "TargetLostSlack",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, target_lost_slack),
            },
            FieldInfoData {
                name: "MaxAttackerCountForPriorityToCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_attacker_count_for_priority_to_count),
            },
            FieldInfoData {
                name: "PrioritizeAttackersFromBehind",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirTargetSelectorEntityData, prioritize_attackers_from_behind),
            },
            FieldInfoData {
                name: "MaxAimAngleFault",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_aim_angle_fault),
            },
            FieldInfoData {
                name: "MaxAngleOffOurBackwardsVector",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_angle_off_our_backwards_vector),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_distance),
            },
            FieldInfoData {
                name: "MaxTeam1HumanAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_team1_human_attackers),
            },
            FieldInfoData {
                name: "MaxTeam2HumanAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_team2_human_attackers),
            },
            FieldInfoData {
                name: "EvenlyDistributeTargets",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirTargetSelectorEntityData, evenly_distribute_targets),
            },
            FieldInfoData {
                name: "DontAttackTargetsBeingChasedByHumans",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirTargetSelectorEntityData, dont_attack_targets_being_chased_by_humans),
            },
            FieldInfoData {
                name: "MaximumDistanceToHumanToDropCurrentTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, maximum_distance_to_human_to_drop_current_target),
            },
            FieldInfoData {
                name: "PrioritizeHumans",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirTargetSelectorEntityData, prioritize_humans),
            },
            FieldInfoData {
                name: "AutoActivate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirTargetSelectorEntityData, auto_activate),
            },
            FieldInfoData {
                name: "MaxEntitiesUpdatedPerFrame",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_entities_updated_per_frame),
            },
        ],
    }),
    array_type: Some(AIRTARGETSELECTORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AirTargetSelectorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIRTARGETSELECTORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIRTARGETSELECTORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirTargetSelectorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AirTargetSelectorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIReadinessLevel {
    #[default]
    RLPatrol = 0,
    RLReady = 1,
    RLCombat = 2,
    RLNone = 3,
}

pub static AIREADINESSLEVEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIReadinessLevel",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIREADINESSLEVEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIReadinessLevel {
    fn type_info(&self) -> &'static TypeInfo {
        AIREADINESSLEVEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIREADINESSLEVEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIReadinessLevel-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIReadinessLevel"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AirCollisionAvoidanceEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub o_b_b_as_capsule: bool,
    pub player_scale: f32,
    pub o_b_b_scale: f32,
    pub large_o_b_b_scale_treshold: f32,
    pub entity_scale: f32,
    pub max_distance: f32,
    pub ray_length: f32,
    pub same_direction_test_uses_velocity: bool,
    pub ignore_same_direction_objects: bool,
    pub ray_length_same_direction: f32,
    pub prioritize_humans: bool,
    pub auto_activate: bool,
    pub player_extrapolation_time: f32,
    pub use_player_extrapolation: bool,
}

pub trait AirCollisionAvoidanceEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn o_b_b_as_capsule(&self) -> &bool;
    fn o_b_b_as_capsule_mut(&mut self) -> &mut bool;
    fn player_scale(&self) -> &f32;
    fn player_scale_mut(&mut self) -> &mut f32;
    fn o_b_b_scale(&self) -> &f32;
    fn o_b_b_scale_mut(&mut self) -> &mut f32;
    fn large_o_b_b_scale_treshold(&self) -> &f32;
    fn large_o_b_b_scale_treshold_mut(&mut self) -> &mut f32;
    fn entity_scale(&self) -> &f32;
    fn entity_scale_mut(&mut self) -> &mut f32;
    fn max_distance(&self) -> &f32;
    fn max_distance_mut(&mut self) -> &mut f32;
    fn ray_length(&self) -> &f32;
    fn ray_length_mut(&mut self) -> &mut f32;
    fn same_direction_test_uses_velocity(&self) -> &bool;
    fn same_direction_test_uses_velocity_mut(&mut self) -> &mut bool;
    fn ignore_same_direction_objects(&self) -> &bool;
    fn ignore_same_direction_objects_mut(&mut self) -> &mut bool;
    fn ray_length_same_direction(&self) -> &f32;
    fn ray_length_same_direction_mut(&mut self) -> &mut f32;
    fn prioritize_humans(&self) -> &bool;
    fn prioritize_humans_mut(&mut self) -> &mut bool;
    fn auto_activate(&self) -> &bool;
    fn auto_activate_mut(&mut self) -> &mut bool;
    fn player_extrapolation_time(&self) -> &f32;
    fn player_extrapolation_time_mut(&mut self) -> &mut f32;
    fn use_player_extrapolation(&self) -> &bool;
    fn use_player_extrapolation_mut(&mut self) -> &mut bool;
}

impl AirCollisionAvoidanceEntityDataTrait for AirCollisionAvoidanceEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn o_b_b_as_capsule(&self) -> &bool {
        &self.o_b_b_as_capsule
    }
    fn o_b_b_as_capsule_mut(&mut self) -> &mut bool {
        &mut self.o_b_b_as_capsule
    }
    fn player_scale(&self) -> &f32 {
        &self.player_scale
    }
    fn player_scale_mut(&mut self) -> &mut f32 {
        &mut self.player_scale
    }
    fn o_b_b_scale(&self) -> &f32 {
        &self.o_b_b_scale
    }
    fn o_b_b_scale_mut(&mut self) -> &mut f32 {
        &mut self.o_b_b_scale
    }
    fn large_o_b_b_scale_treshold(&self) -> &f32 {
        &self.large_o_b_b_scale_treshold
    }
    fn large_o_b_b_scale_treshold_mut(&mut self) -> &mut f32 {
        &mut self.large_o_b_b_scale_treshold
    }
    fn entity_scale(&self) -> &f32 {
        &self.entity_scale
    }
    fn entity_scale_mut(&mut self) -> &mut f32 {
        &mut self.entity_scale
    }
    fn max_distance(&self) -> &f32 {
        &self.max_distance
    }
    fn max_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_distance
    }
    fn ray_length(&self) -> &f32 {
        &self.ray_length
    }
    fn ray_length_mut(&mut self) -> &mut f32 {
        &mut self.ray_length
    }
    fn same_direction_test_uses_velocity(&self) -> &bool {
        &self.same_direction_test_uses_velocity
    }
    fn same_direction_test_uses_velocity_mut(&mut self) -> &mut bool {
        &mut self.same_direction_test_uses_velocity
    }
    fn ignore_same_direction_objects(&self) -> &bool {
        &self.ignore_same_direction_objects
    }
    fn ignore_same_direction_objects_mut(&mut self) -> &mut bool {
        &mut self.ignore_same_direction_objects
    }
    fn ray_length_same_direction(&self) -> &f32 {
        &self.ray_length_same_direction
    }
    fn ray_length_same_direction_mut(&mut self) -> &mut f32 {
        &mut self.ray_length_same_direction
    }
    fn prioritize_humans(&self) -> &bool {
        &self.prioritize_humans
    }
    fn prioritize_humans_mut(&mut self) -> &mut bool {
        &mut self.prioritize_humans
    }
    fn auto_activate(&self) -> &bool {
        &self.auto_activate
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        &mut self.auto_activate
    }
    fn player_extrapolation_time(&self) -> &f32 {
        &self.player_extrapolation_time
    }
    fn player_extrapolation_time_mut(&mut self) -> &mut f32 {
        &mut self.player_extrapolation_time
    }
    fn use_player_extrapolation(&self) -> &bool {
        &self.use_player_extrapolation
    }
    fn use_player_extrapolation_mut(&mut self) -> &mut bool {
        &mut self.use_player_extrapolation
    }
}

impl super::entity::EntityDataTrait for AirCollisionAvoidanceEntityData {
}

impl super::entity::GameObjectDataTrait for AirCollisionAvoidanceEntityData {
}

impl super::core::DataBusPeerTrait for AirCollisionAvoidanceEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AirCollisionAvoidanceEntityData {
}

impl super::core::DataContainerTrait for AirCollisionAvoidanceEntityData {
}

pub static AIRCOLLISIONAVOIDANCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirCollisionAvoidanceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AirCollisionAvoidanceEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, realm),
            },
            FieldInfoData {
                name: "OBBAsCapsule",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, o_b_b_as_capsule),
            },
            FieldInfoData {
                name: "PlayerScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, player_scale),
            },
            FieldInfoData {
                name: "OBBScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, o_b_b_scale),
            },
            FieldInfoData {
                name: "LargeOBBScaleTreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, large_o_b_b_scale_treshold),
            },
            FieldInfoData {
                name: "EntityScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, entity_scale),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, max_distance),
            },
            FieldInfoData {
                name: "RayLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, ray_length),
            },
            FieldInfoData {
                name: "SameDirectionTestUsesVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, same_direction_test_uses_velocity),
            },
            FieldInfoData {
                name: "IgnoreSameDirectionObjects",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, ignore_same_direction_objects),
            },
            FieldInfoData {
                name: "RayLengthSameDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, ray_length_same_direction),
            },
            FieldInfoData {
                name: "PrioritizeHumans",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, prioritize_humans),
            },
            FieldInfoData {
                name: "AutoActivate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, auto_activate),
            },
            FieldInfoData {
                name: "PlayerExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, player_extrapolation_time),
            },
            FieldInfoData {
                name: "UsePlayerExtrapolation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, use_player_extrapolation),
            },
        ],
    }),
    array_type: Some(AIRCOLLISIONAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AirCollisionAvoidanceEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIRCOLLISIONAVOIDANCEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIRCOLLISIONAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirCollisionAvoidanceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AirCollisionAvoidanceEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIProximityAimingState {
    #[default]
    AIProximityConditionalState_NotAiming = 0,
    AIProximityConditionalState_AimingAtPosition = 1,
    AIProximityConditionalState_AimingAtEntity = 2,
}

pub static AIPROXIMITYAIMINGSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityAimingState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPROXIMITYAIMINGSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIProximityAimingState {
    fn type_info(&self) -> &'static TypeInfo {
        AIPROXIMITYAIMINGSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIPROXIMITYAIMINGSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityAimingState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIProximityAimingState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIProximityReactionsComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub binding: AIProximityReactionsBinding,
    pub check_alerted_reaction_on_spot_radius: f32,
    pub check_navmesh_in_reaction_direction: bool,
    pub check_navmesh_length: f32,
    pub check_melee_forward_navmesh_length: f32,
    pub min_explosion_impulse_force: f32,
    pub max_explosion_look_distance: f32,
    pub fire_reaction_distance: f32,
    pub drastic_aim_yaw_amount: f32,
    pub allow_impulse_reaction_during_scenario_waypoint: bool,
    pub look_at_human_timing: Vec<LookAtHuman>,
    pub enabled: bool,
    pub enable_friendly_vehicle_kills: bool,
    pub has_available_bayonet: bool,
    pub animation_time_scale_override: f32,
}

pub trait AIProximityReactionsComponentDataTrait: super::entity::GameComponentDataTrait {
    fn binding(&self) -> &AIProximityReactionsBinding;
    fn binding_mut(&mut self) -> &mut AIProximityReactionsBinding;
    fn check_alerted_reaction_on_spot_radius(&self) -> &f32;
    fn check_alerted_reaction_on_spot_radius_mut(&mut self) -> &mut f32;
    fn check_navmesh_in_reaction_direction(&self) -> &bool;
    fn check_navmesh_in_reaction_direction_mut(&mut self) -> &mut bool;
    fn check_navmesh_length(&self) -> &f32;
    fn check_navmesh_length_mut(&mut self) -> &mut f32;
    fn check_melee_forward_navmesh_length(&self) -> &f32;
    fn check_melee_forward_navmesh_length_mut(&mut self) -> &mut f32;
    fn min_explosion_impulse_force(&self) -> &f32;
    fn min_explosion_impulse_force_mut(&mut self) -> &mut f32;
    fn max_explosion_look_distance(&self) -> &f32;
    fn max_explosion_look_distance_mut(&mut self) -> &mut f32;
    fn fire_reaction_distance(&self) -> &f32;
    fn fire_reaction_distance_mut(&mut self) -> &mut f32;
    fn drastic_aim_yaw_amount(&self) -> &f32;
    fn drastic_aim_yaw_amount_mut(&mut self) -> &mut f32;
    fn allow_impulse_reaction_during_scenario_waypoint(&self) -> &bool;
    fn allow_impulse_reaction_during_scenario_waypoint_mut(&mut self) -> &mut bool;
    fn look_at_human_timing(&self) -> &Vec<LookAtHuman>;
    fn look_at_human_timing_mut(&mut self) -> &mut Vec<LookAtHuman>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn enable_friendly_vehicle_kills(&self) -> &bool;
    fn enable_friendly_vehicle_kills_mut(&mut self) -> &mut bool;
    fn has_available_bayonet(&self) -> &bool;
    fn has_available_bayonet_mut(&mut self) -> &mut bool;
    fn animation_time_scale_override(&self) -> &f32;
    fn animation_time_scale_override_mut(&mut self) -> &mut f32;
}

impl AIProximityReactionsComponentDataTrait for AIProximityReactionsComponentData {
    fn binding(&self) -> &AIProximityReactionsBinding {
        &self.binding
    }
    fn binding_mut(&mut self) -> &mut AIProximityReactionsBinding {
        &mut self.binding
    }
    fn check_alerted_reaction_on_spot_radius(&self) -> &f32 {
        &self.check_alerted_reaction_on_spot_radius
    }
    fn check_alerted_reaction_on_spot_radius_mut(&mut self) -> &mut f32 {
        &mut self.check_alerted_reaction_on_spot_radius
    }
    fn check_navmesh_in_reaction_direction(&self) -> &bool {
        &self.check_navmesh_in_reaction_direction
    }
    fn check_navmesh_in_reaction_direction_mut(&mut self) -> &mut bool {
        &mut self.check_navmesh_in_reaction_direction
    }
    fn check_navmesh_length(&self) -> &f32 {
        &self.check_navmesh_length
    }
    fn check_navmesh_length_mut(&mut self) -> &mut f32 {
        &mut self.check_navmesh_length
    }
    fn check_melee_forward_navmesh_length(&self) -> &f32 {
        &self.check_melee_forward_navmesh_length
    }
    fn check_melee_forward_navmesh_length_mut(&mut self) -> &mut f32 {
        &mut self.check_melee_forward_navmesh_length
    }
    fn min_explosion_impulse_force(&self) -> &f32 {
        &self.min_explosion_impulse_force
    }
    fn min_explosion_impulse_force_mut(&mut self) -> &mut f32 {
        &mut self.min_explosion_impulse_force
    }
    fn max_explosion_look_distance(&self) -> &f32 {
        &self.max_explosion_look_distance
    }
    fn max_explosion_look_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_explosion_look_distance
    }
    fn fire_reaction_distance(&self) -> &f32 {
        &self.fire_reaction_distance
    }
    fn fire_reaction_distance_mut(&mut self) -> &mut f32 {
        &mut self.fire_reaction_distance
    }
    fn drastic_aim_yaw_amount(&self) -> &f32 {
        &self.drastic_aim_yaw_amount
    }
    fn drastic_aim_yaw_amount_mut(&mut self) -> &mut f32 {
        &mut self.drastic_aim_yaw_amount
    }
    fn allow_impulse_reaction_during_scenario_waypoint(&self) -> &bool {
        &self.allow_impulse_reaction_during_scenario_waypoint
    }
    fn allow_impulse_reaction_during_scenario_waypoint_mut(&mut self) -> &mut bool {
        &mut self.allow_impulse_reaction_during_scenario_waypoint
    }
    fn look_at_human_timing(&self) -> &Vec<LookAtHuman> {
        &self.look_at_human_timing
    }
    fn look_at_human_timing_mut(&mut self) -> &mut Vec<LookAtHuman> {
        &mut self.look_at_human_timing
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn enable_friendly_vehicle_kills(&self) -> &bool {
        &self.enable_friendly_vehicle_kills
    }
    fn enable_friendly_vehicle_kills_mut(&mut self) -> &mut bool {
        &mut self.enable_friendly_vehicle_kills
    }
    fn has_available_bayonet(&self) -> &bool {
        &self.has_available_bayonet
    }
    fn has_available_bayonet_mut(&mut self) -> &mut bool {
        &mut self.has_available_bayonet
    }
    fn animation_time_scale_override(&self) -> &f32 {
        &self.animation_time_scale_override
    }
    fn animation_time_scale_override_mut(&mut self) -> &mut f32 {
        &mut self.animation_time_scale_override
    }
}

impl super::entity::GameComponentDataTrait for AIProximityReactionsComponentData {
}

impl super::entity::ComponentDataTrait for AIProximityReactionsComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AIProximityReactionsComponentData {
}

impl super::core::DataBusPeerTrait for AIProximityReactionsComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIProximityReactionsComponentData {
}

impl super::core::DataContainerTrait for AIProximityReactionsComponentData {
}

pub static AIPROXIMITYREACTIONSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityReactionsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIProximityReactionsComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: "AIProximityReactionsBinding",
                rust_offset: offset_of!(AIProximityReactionsComponentData, binding),
            },
            FieldInfoData {
                name: "CheckAlertedReactionOnSpotRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIProximityReactionsComponentData, check_alerted_reaction_on_spot_radius),
            },
            FieldInfoData {
                name: "CheckNavmeshInReactionDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProximityReactionsComponentData, check_navmesh_in_reaction_direction),
            },
            FieldInfoData {
                name: "CheckNavmeshLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIProximityReactionsComponentData, check_navmesh_length),
            },
            FieldInfoData {
                name: "CheckMeleeForwardNavmeshLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIProximityReactionsComponentData, check_melee_forward_navmesh_length),
            },
            FieldInfoData {
                name: "MinExplosionImpulseForce",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIProximityReactionsComponentData, min_explosion_impulse_force),
            },
            FieldInfoData {
                name: "MaxExplosionLookDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIProximityReactionsComponentData, max_explosion_look_distance),
            },
            FieldInfoData {
                name: "FireReactionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIProximityReactionsComponentData, fire_reaction_distance),
            },
            FieldInfoData {
                name: "DrasticAimYawAmount",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIProximityReactionsComponentData, drastic_aim_yaw_amount),
            },
            FieldInfoData {
                name: "AllowImpulseReactionDuringScenarioWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProximityReactionsComponentData, allow_impulse_reaction_during_scenario_waypoint),
            },
            FieldInfoData {
                name: "LookAtHumanTiming",
                flags: MemberInfoFlags::new(144),
                field_type: "LookAtHuman-Array",
                rust_offset: offset_of!(AIProximityReactionsComponentData, look_at_human_timing),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProximityReactionsComponentData, enabled),
            },
            FieldInfoData {
                name: "EnableFriendlyVehicleKills",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProximityReactionsComponentData, enable_friendly_vehicle_kills),
            },
            FieldInfoData {
                name: "HasAvailableBayonet",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProximityReactionsComponentData, has_available_bayonet),
            },
            FieldInfoData {
                name: "AnimationTimeScaleOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIProximityReactionsComponentData, animation_time_scale_override),
            },
        ],
    }),
    array_type: Some(AIPROXIMITYREACTIONSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIProximityReactionsComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIPROXIMITYREACTIONSCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIPROXIMITYREACTIONSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityReactionsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIProximityReactionsComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LookAtHuman {
    pub speed_level: AntSpeedLevel,
    pub delay_min: f32,
    pub delay_max: f32,
    pub length_min: f32,
    pub length_max: f32,
}

pub trait LookAtHumanTrait: TypeObject {
    fn speed_level(&self) -> &AntSpeedLevel;
    fn speed_level_mut(&mut self) -> &mut AntSpeedLevel;
    fn delay_min(&self) -> &f32;
    fn delay_min_mut(&mut self) -> &mut f32;
    fn delay_max(&self) -> &f32;
    fn delay_max_mut(&mut self) -> &mut f32;
    fn length_min(&self) -> &f32;
    fn length_min_mut(&mut self) -> &mut f32;
    fn length_max(&self) -> &f32;
    fn length_max_mut(&mut self) -> &mut f32;
}

impl LookAtHumanTrait for LookAtHuman {
    fn speed_level(&self) -> &AntSpeedLevel {
        &self.speed_level
    }
    fn speed_level_mut(&mut self) -> &mut AntSpeedLevel {
        &mut self.speed_level
    }
    fn delay_min(&self) -> &f32 {
        &self.delay_min
    }
    fn delay_min_mut(&mut self) -> &mut f32 {
        &mut self.delay_min
    }
    fn delay_max(&self) -> &f32 {
        &self.delay_max
    }
    fn delay_max_mut(&mut self) -> &mut f32 {
        &mut self.delay_max
    }
    fn length_min(&self) -> &f32 {
        &self.length_min
    }
    fn length_min_mut(&mut self) -> &mut f32 {
        &mut self.length_min
    }
    fn length_max(&self) -> &f32 {
        &self.length_max
    }
    fn length_max_mut(&mut self) -> &mut f32 {
        &mut self.length_max
    }
}

pub static LOOKATHUMAN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtHuman",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LookAtHuman as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SpeedLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AntSpeedLevel",
                rust_offset: offset_of!(LookAtHuman, speed_level),
            },
            FieldInfoData {
                name: "DelayMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LookAtHuman, delay_min),
            },
            FieldInfoData {
                name: "DelayMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LookAtHuman, delay_max),
            },
            FieldInfoData {
                name: "LengthMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LookAtHuman, length_min),
            },
            FieldInfoData {
                name: "LengthMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LookAtHuman, length_max),
            },
        ],
    }),
    array_type: Some(LOOKATHUMAN_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LookAtHuman {
    fn type_info(&self) -> &'static TypeInfo {
        LOOKATHUMAN_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LOOKATHUMAN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtHuman-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LookAtHuman"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIProximityReactionsBinding {
    pub a_i_reaction: super::ant::AntRef,
    pub a_i_explosion_reaction: super::ant::AntRef,
    pub a_i_explosion_force: super::ant::AntRef,
    pub a_i_stun_reaction: super::ant::AntRef,
    pub a_i_stun_reaction_random_factor: super::ant::AntRef,
    pub a_i_reaction_on_the_spot: super::ant::AntRef,
    pub a_i_reaction_direction: super::ant::AntRef,
    pub is_panicking: super::ant::AntRef,
    pub fire_nearby: super::ant::AntRef,
    pub aim_up_and_down: super::ant::AntRef,
    pub focus_aim_scale: super::ant::AntRef,
    pub focus_aiming: super::ant::AntRef,
    pub enable_procedural_head_aim: super::ant::AntRef,
    pub kill_from_animation: super::ant::AntRef,
    pub player_animation_kill: super::ant::AntRef,
    pub player_initiated_ragdoll: super::ant::AntRef,
    pub a_i_suppressed: super::ant::AntRef,
    pub human_awareness: super::ant::AntRef,
    pub alerted_on_spot: super::ant::AntRef,
    pub human_is_close: super::ant::AntRef,
    pub human_target_yaw: super::ant::AntRef,
    pub human_target_yaw_world_rad: super::ant::AntRef,
    pub look_at_human: super::ant::AntRef,
    pub human_yaw_rad: super::ant::AntRef,
    pub human_pitch: super::ant::AntRef,
    pub retrigger_idle: super::ant::AntRef,
    pub has_wanted_precision: super::ant::AntRef,
    pub target_visible: super::ant::AntRef,
    pub wanted_aim_target_visible: super::ant::AntRef,
    pub target_spotted: super::ant::AntRef,
    pub target_distance: super::ant::AntRef,
    pub cruise_speed_level: super::ant::AntRef,
    pub drastic_aim_yaw_change: super::ant::AntRef,
    pub melee_attack: super::ant::AntRef,
    pub forward_distance_to_obstacle: super::ant::AntRef,
    pub investigate_state: super::ant::AntRef,
    pub new_investigation_started: super::ant::AntRef,
    pub is_investigating: super::ant::AntRef,
    pub is_searching: super::ant::AntRef,
    pub investigate_trigger_type: super::ant::AntRef,
    pub investigate_type: super::ant::AntRef,
    pub investigate_react: super::ant::AntRef,
    pub alerted_position_yaw_rad: super::ant::AntRef,
    pub sustained_fire_spin_up: super::ant::AntRef,
    pub player_is_current_target: super::ant::AntRef,
    pub a_i_allow_fire: super::ant::AntRef,
    pub a_i_alt_fire_from_ant: super::ant::AntRef,
}

pub trait AIProximityReactionsBindingTrait: TypeObject {
    fn a_i_reaction(&self) -> &super::ant::AntRef;
    fn a_i_reaction_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_explosion_reaction(&self) -> &super::ant::AntRef;
    fn a_i_explosion_reaction_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_explosion_force(&self) -> &super::ant::AntRef;
    fn a_i_explosion_force_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_stun_reaction(&self) -> &super::ant::AntRef;
    fn a_i_stun_reaction_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_stun_reaction_random_factor(&self) -> &super::ant::AntRef;
    fn a_i_stun_reaction_random_factor_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_reaction_on_the_spot(&self) -> &super::ant::AntRef;
    fn a_i_reaction_on_the_spot_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_reaction_direction(&self) -> &super::ant::AntRef;
    fn a_i_reaction_direction_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_panicking(&self) -> &super::ant::AntRef;
    fn is_panicking_mut(&mut self) -> &mut super::ant::AntRef;
    fn fire_nearby(&self) -> &super::ant::AntRef;
    fn fire_nearby_mut(&mut self) -> &mut super::ant::AntRef;
    fn aim_up_and_down(&self) -> &super::ant::AntRef;
    fn aim_up_and_down_mut(&mut self) -> &mut super::ant::AntRef;
    fn focus_aim_scale(&self) -> &super::ant::AntRef;
    fn focus_aim_scale_mut(&mut self) -> &mut super::ant::AntRef;
    fn focus_aiming(&self) -> &super::ant::AntRef;
    fn focus_aiming_mut(&mut self) -> &mut super::ant::AntRef;
    fn enable_procedural_head_aim(&self) -> &super::ant::AntRef;
    fn enable_procedural_head_aim_mut(&mut self) -> &mut super::ant::AntRef;
    fn kill_from_animation(&self) -> &super::ant::AntRef;
    fn kill_from_animation_mut(&mut self) -> &mut super::ant::AntRef;
    fn player_animation_kill(&self) -> &super::ant::AntRef;
    fn player_animation_kill_mut(&mut self) -> &mut super::ant::AntRef;
    fn player_initiated_ragdoll(&self) -> &super::ant::AntRef;
    fn player_initiated_ragdoll_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_suppressed(&self) -> &super::ant::AntRef;
    fn a_i_suppressed_mut(&mut self) -> &mut super::ant::AntRef;
    fn human_awareness(&self) -> &super::ant::AntRef;
    fn human_awareness_mut(&mut self) -> &mut super::ant::AntRef;
    fn alerted_on_spot(&self) -> &super::ant::AntRef;
    fn alerted_on_spot_mut(&mut self) -> &mut super::ant::AntRef;
    fn human_is_close(&self) -> &super::ant::AntRef;
    fn human_is_close_mut(&mut self) -> &mut super::ant::AntRef;
    fn human_target_yaw(&self) -> &super::ant::AntRef;
    fn human_target_yaw_mut(&mut self) -> &mut super::ant::AntRef;
    fn human_target_yaw_world_rad(&self) -> &super::ant::AntRef;
    fn human_target_yaw_world_rad_mut(&mut self) -> &mut super::ant::AntRef;
    fn look_at_human(&self) -> &super::ant::AntRef;
    fn look_at_human_mut(&mut self) -> &mut super::ant::AntRef;
    fn human_yaw_rad(&self) -> &super::ant::AntRef;
    fn human_yaw_rad_mut(&mut self) -> &mut super::ant::AntRef;
    fn human_pitch(&self) -> &super::ant::AntRef;
    fn human_pitch_mut(&mut self) -> &mut super::ant::AntRef;
    fn retrigger_idle(&self) -> &super::ant::AntRef;
    fn retrigger_idle_mut(&mut self) -> &mut super::ant::AntRef;
    fn has_wanted_precision(&self) -> &super::ant::AntRef;
    fn has_wanted_precision_mut(&mut self) -> &mut super::ant::AntRef;
    fn target_visible(&self) -> &super::ant::AntRef;
    fn target_visible_mut(&mut self) -> &mut super::ant::AntRef;
    fn wanted_aim_target_visible(&self) -> &super::ant::AntRef;
    fn wanted_aim_target_visible_mut(&mut self) -> &mut super::ant::AntRef;
    fn target_spotted(&self) -> &super::ant::AntRef;
    fn target_spotted_mut(&mut self) -> &mut super::ant::AntRef;
    fn target_distance(&self) -> &super::ant::AntRef;
    fn target_distance_mut(&mut self) -> &mut super::ant::AntRef;
    fn cruise_speed_level(&self) -> &super::ant::AntRef;
    fn cruise_speed_level_mut(&mut self) -> &mut super::ant::AntRef;
    fn drastic_aim_yaw_change(&self) -> &super::ant::AntRef;
    fn drastic_aim_yaw_change_mut(&mut self) -> &mut super::ant::AntRef;
    fn melee_attack(&self) -> &super::ant::AntRef;
    fn melee_attack_mut(&mut self) -> &mut super::ant::AntRef;
    fn forward_distance_to_obstacle(&self) -> &super::ant::AntRef;
    fn forward_distance_to_obstacle_mut(&mut self) -> &mut super::ant::AntRef;
    fn investigate_state(&self) -> &super::ant::AntRef;
    fn investigate_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn new_investigation_started(&self) -> &super::ant::AntRef;
    fn new_investigation_started_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_investigating(&self) -> &super::ant::AntRef;
    fn is_investigating_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_searching(&self) -> &super::ant::AntRef;
    fn is_searching_mut(&mut self) -> &mut super::ant::AntRef;
    fn investigate_trigger_type(&self) -> &super::ant::AntRef;
    fn investigate_trigger_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn investigate_type(&self) -> &super::ant::AntRef;
    fn investigate_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn investigate_react(&self) -> &super::ant::AntRef;
    fn investigate_react_mut(&mut self) -> &mut super::ant::AntRef;
    fn alerted_position_yaw_rad(&self) -> &super::ant::AntRef;
    fn alerted_position_yaw_rad_mut(&mut self) -> &mut super::ant::AntRef;
    fn sustained_fire_spin_up(&self) -> &super::ant::AntRef;
    fn sustained_fire_spin_up_mut(&mut self) -> &mut super::ant::AntRef;
    fn player_is_current_target(&self) -> &super::ant::AntRef;
    fn player_is_current_target_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_allow_fire(&self) -> &super::ant::AntRef;
    fn a_i_allow_fire_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_alt_fire_from_ant(&self) -> &super::ant::AntRef;
    fn a_i_alt_fire_from_ant_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AIProximityReactionsBindingTrait for AIProximityReactionsBinding {
    fn a_i_reaction(&self) -> &super::ant::AntRef {
        &self.a_i_reaction
    }
    fn a_i_reaction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_reaction
    }
    fn a_i_explosion_reaction(&self) -> &super::ant::AntRef {
        &self.a_i_explosion_reaction
    }
    fn a_i_explosion_reaction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_explosion_reaction
    }
    fn a_i_explosion_force(&self) -> &super::ant::AntRef {
        &self.a_i_explosion_force
    }
    fn a_i_explosion_force_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_explosion_force
    }
    fn a_i_stun_reaction(&self) -> &super::ant::AntRef {
        &self.a_i_stun_reaction
    }
    fn a_i_stun_reaction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_stun_reaction
    }
    fn a_i_stun_reaction_random_factor(&self) -> &super::ant::AntRef {
        &self.a_i_stun_reaction_random_factor
    }
    fn a_i_stun_reaction_random_factor_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_stun_reaction_random_factor
    }
    fn a_i_reaction_on_the_spot(&self) -> &super::ant::AntRef {
        &self.a_i_reaction_on_the_spot
    }
    fn a_i_reaction_on_the_spot_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_reaction_on_the_spot
    }
    fn a_i_reaction_direction(&self) -> &super::ant::AntRef {
        &self.a_i_reaction_direction
    }
    fn a_i_reaction_direction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_reaction_direction
    }
    fn is_panicking(&self) -> &super::ant::AntRef {
        &self.is_panicking
    }
    fn is_panicking_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_panicking
    }
    fn fire_nearby(&self) -> &super::ant::AntRef {
        &self.fire_nearby
    }
    fn fire_nearby_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.fire_nearby
    }
    fn aim_up_and_down(&self) -> &super::ant::AntRef {
        &self.aim_up_and_down
    }
    fn aim_up_and_down_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.aim_up_and_down
    }
    fn focus_aim_scale(&self) -> &super::ant::AntRef {
        &self.focus_aim_scale
    }
    fn focus_aim_scale_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.focus_aim_scale
    }
    fn focus_aiming(&self) -> &super::ant::AntRef {
        &self.focus_aiming
    }
    fn focus_aiming_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.focus_aiming
    }
    fn enable_procedural_head_aim(&self) -> &super::ant::AntRef {
        &self.enable_procedural_head_aim
    }
    fn enable_procedural_head_aim_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enable_procedural_head_aim
    }
    fn kill_from_animation(&self) -> &super::ant::AntRef {
        &self.kill_from_animation
    }
    fn kill_from_animation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.kill_from_animation
    }
    fn player_animation_kill(&self) -> &super::ant::AntRef {
        &self.player_animation_kill
    }
    fn player_animation_kill_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.player_animation_kill
    }
    fn player_initiated_ragdoll(&self) -> &super::ant::AntRef {
        &self.player_initiated_ragdoll
    }
    fn player_initiated_ragdoll_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.player_initiated_ragdoll
    }
    fn a_i_suppressed(&self) -> &super::ant::AntRef {
        &self.a_i_suppressed
    }
    fn a_i_suppressed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_suppressed
    }
    fn human_awareness(&self) -> &super::ant::AntRef {
        &self.human_awareness
    }
    fn human_awareness_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.human_awareness
    }
    fn alerted_on_spot(&self) -> &super::ant::AntRef {
        &self.alerted_on_spot
    }
    fn alerted_on_spot_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.alerted_on_spot
    }
    fn human_is_close(&self) -> &super::ant::AntRef {
        &self.human_is_close
    }
    fn human_is_close_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.human_is_close
    }
    fn human_target_yaw(&self) -> &super::ant::AntRef {
        &self.human_target_yaw
    }
    fn human_target_yaw_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.human_target_yaw
    }
    fn human_target_yaw_world_rad(&self) -> &super::ant::AntRef {
        &self.human_target_yaw_world_rad
    }
    fn human_target_yaw_world_rad_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.human_target_yaw_world_rad
    }
    fn look_at_human(&self) -> &super::ant::AntRef {
        &self.look_at_human
    }
    fn look_at_human_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.look_at_human
    }
    fn human_yaw_rad(&self) -> &super::ant::AntRef {
        &self.human_yaw_rad
    }
    fn human_yaw_rad_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.human_yaw_rad
    }
    fn human_pitch(&self) -> &super::ant::AntRef {
        &self.human_pitch
    }
    fn human_pitch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.human_pitch
    }
    fn retrigger_idle(&self) -> &super::ant::AntRef {
        &self.retrigger_idle
    }
    fn retrigger_idle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.retrigger_idle
    }
    fn has_wanted_precision(&self) -> &super::ant::AntRef {
        &self.has_wanted_precision
    }
    fn has_wanted_precision_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.has_wanted_precision
    }
    fn target_visible(&self) -> &super::ant::AntRef {
        &self.target_visible
    }
    fn target_visible_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.target_visible
    }
    fn wanted_aim_target_visible(&self) -> &super::ant::AntRef {
        &self.wanted_aim_target_visible
    }
    fn wanted_aim_target_visible_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.wanted_aim_target_visible
    }
    fn target_spotted(&self) -> &super::ant::AntRef {
        &self.target_spotted
    }
    fn target_spotted_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.target_spotted
    }
    fn target_distance(&self) -> &super::ant::AntRef {
        &self.target_distance
    }
    fn target_distance_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.target_distance
    }
    fn cruise_speed_level(&self) -> &super::ant::AntRef {
        &self.cruise_speed_level
    }
    fn cruise_speed_level_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cruise_speed_level
    }
    fn drastic_aim_yaw_change(&self) -> &super::ant::AntRef {
        &self.drastic_aim_yaw_change
    }
    fn drastic_aim_yaw_change_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.drastic_aim_yaw_change
    }
    fn melee_attack(&self) -> &super::ant::AntRef {
        &self.melee_attack
    }
    fn melee_attack_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.melee_attack
    }
    fn forward_distance_to_obstacle(&self) -> &super::ant::AntRef {
        &self.forward_distance_to_obstacle
    }
    fn forward_distance_to_obstacle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.forward_distance_to_obstacle
    }
    fn investigate_state(&self) -> &super::ant::AntRef {
        &self.investigate_state
    }
    fn investigate_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.investigate_state
    }
    fn new_investigation_started(&self) -> &super::ant::AntRef {
        &self.new_investigation_started
    }
    fn new_investigation_started_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.new_investigation_started
    }
    fn is_investigating(&self) -> &super::ant::AntRef {
        &self.is_investigating
    }
    fn is_investigating_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_investigating
    }
    fn is_searching(&self) -> &super::ant::AntRef {
        &self.is_searching
    }
    fn is_searching_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_searching
    }
    fn investigate_trigger_type(&self) -> &super::ant::AntRef {
        &self.investigate_trigger_type
    }
    fn investigate_trigger_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.investigate_trigger_type
    }
    fn investigate_type(&self) -> &super::ant::AntRef {
        &self.investigate_type
    }
    fn investigate_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.investigate_type
    }
    fn investigate_react(&self) -> &super::ant::AntRef {
        &self.investigate_react
    }
    fn investigate_react_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.investigate_react
    }
    fn alerted_position_yaw_rad(&self) -> &super::ant::AntRef {
        &self.alerted_position_yaw_rad
    }
    fn alerted_position_yaw_rad_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.alerted_position_yaw_rad
    }
    fn sustained_fire_spin_up(&self) -> &super::ant::AntRef {
        &self.sustained_fire_spin_up
    }
    fn sustained_fire_spin_up_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.sustained_fire_spin_up
    }
    fn player_is_current_target(&self) -> &super::ant::AntRef {
        &self.player_is_current_target
    }
    fn player_is_current_target_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.player_is_current_target
    }
    fn a_i_allow_fire(&self) -> &super::ant::AntRef {
        &self.a_i_allow_fire
    }
    fn a_i_allow_fire_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_allow_fire
    }
    fn a_i_alt_fire_from_ant(&self) -> &super::ant::AntRef {
        &self.a_i_alt_fire_from_ant
    }
    fn a_i_alt_fire_from_ant_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_alt_fire_from_ant
    }
}

pub static AIPROXIMITYREACTIONSBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityReactionsBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIProximityReactionsBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AIReaction",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_reaction),
            },
            FieldInfoData {
                name: "AIExplosionReaction",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_explosion_reaction),
            },
            FieldInfoData {
                name: "AIExplosionForce",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_explosion_force),
            },
            FieldInfoData {
                name: "AIStunReaction",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_stun_reaction),
            },
            FieldInfoData {
                name: "AIStunReactionRandomFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_stun_reaction_random_factor),
            },
            FieldInfoData {
                name: "AIReactionOnTheSpot",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_reaction_on_the_spot),
            },
            FieldInfoData {
                name: "AIReactionDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_reaction_direction),
            },
            FieldInfoData {
                name: "IsPanicking",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, is_panicking),
            },
            FieldInfoData {
                name: "FireNearby",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, fire_nearby),
            },
            FieldInfoData {
                name: "AimUpAndDown",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, aim_up_and_down),
            },
            FieldInfoData {
                name: "FocusAimScale",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, focus_aim_scale),
            },
            FieldInfoData {
                name: "FocusAiming",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, focus_aiming),
            },
            FieldInfoData {
                name: "EnableProceduralHeadAim",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, enable_procedural_head_aim),
            },
            FieldInfoData {
                name: "KillFromAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, kill_from_animation),
            },
            FieldInfoData {
                name: "PlayerAnimationKill",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, player_animation_kill),
            },
            FieldInfoData {
                name: "PlayerInitiatedRagdoll",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, player_initiated_ragdoll),
            },
            FieldInfoData {
                name: "AISuppressed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_suppressed),
            },
            FieldInfoData {
                name: "HumanAwareness",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, human_awareness),
            },
            FieldInfoData {
                name: "AlertedOnSpot",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, alerted_on_spot),
            },
            FieldInfoData {
                name: "HumanIsClose",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, human_is_close),
            },
            FieldInfoData {
                name: "HumanTargetYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, human_target_yaw),
            },
            FieldInfoData {
                name: "HumanTargetYawWorldRad",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, human_target_yaw_world_rad),
            },
            FieldInfoData {
                name: "LookAtHuman",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, look_at_human),
            },
            FieldInfoData {
                name: "HumanYawRad",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, human_yaw_rad),
            },
            FieldInfoData {
                name: "HumanPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, human_pitch),
            },
            FieldInfoData {
                name: "RetriggerIdle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, retrigger_idle),
            },
            FieldInfoData {
                name: "HasWantedPrecision",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, has_wanted_precision),
            },
            FieldInfoData {
                name: "TargetVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, target_visible),
            },
            FieldInfoData {
                name: "WantedAimTargetVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, wanted_aim_target_visible),
            },
            FieldInfoData {
                name: "TargetSpotted",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, target_spotted),
            },
            FieldInfoData {
                name: "TargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, target_distance),
            },
            FieldInfoData {
                name: "CruiseSpeedLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, cruise_speed_level),
            },
            FieldInfoData {
                name: "DrasticAimYawChange",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, drastic_aim_yaw_change),
            },
            FieldInfoData {
                name: "MeleeAttack",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, melee_attack),
            },
            FieldInfoData {
                name: "ForwardDistanceToObstacle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, forward_distance_to_obstacle),
            },
            FieldInfoData {
                name: "InvestigateState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, investigate_state),
            },
            FieldInfoData {
                name: "NewInvestigationStarted",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, new_investigation_started),
            },
            FieldInfoData {
                name: "IsInvestigating",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, is_investigating),
            },
            FieldInfoData {
                name: "IsSearching",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, is_searching),
            },
            FieldInfoData {
                name: "InvestigateTriggerType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, investigate_trigger_type),
            },
            FieldInfoData {
                name: "InvestigateType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, investigate_type),
            },
            FieldInfoData {
                name: "InvestigateReact",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, investigate_react),
            },
            FieldInfoData {
                name: "AlertedPositionYawRad",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, alerted_position_yaw_rad),
            },
            FieldInfoData {
                name: "SustainedFireSpinUp",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, sustained_fire_spin_up),
            },
            FieldInfoData {
                name: "PlayerIsCurrentTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, player_is_current_target),
            },
            FieldInfoData {
                name: "AIAllowFire",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_allow_fire),
            },
            FieldInfoData {
                name: "AIAltFireFromAnt",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_alt_fire_from_ant),
            },
        ],
    }),
    array_type: Some(AIPROXIMITYREACTIONSBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIProximityReactionsBinding {
    fn type_info(&self) -> &'static TypeInfo {
        AIPROXIMITYREACTIONSBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIPROXIMITYREACTIONSBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityReactionsBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIProximityReactionsBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIAltFireFromAntState {
    #[default]
    AltFireFromAntState_NoForcedFire = 0,
    AltFireFromAntState_Prepare = 1,
    AltFireFromAntState_ForceFire = 2,
}

pub static AIALTFIREFROMANTSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAltFireFromAntState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIALTFIREFROMANTSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIAltFireFromAntState {
    fn type_info(&self) -> &'static TypeInfo {
        AIALTFIREFROMANTSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIALTFIREFROMANTSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAltFireFromAntState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIAltFireFromAntState"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIStunReactionAnimationType {
    #[default]
    AIStunReactionAnimationType_1 = 0,
    AIStunReactionAnimationType_2 = 1,
    AIStunReactionAnimationType_3 = 2,
    AIStunReactionAnimationType_4 = 3,
    AIStunReactionAnimationType_5 = 4,
    AIStunReactionAnimationType_Count = 5,
}

pub static AISTUNREACTIONANIMATIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStunReactionAnimationType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AISTUNREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIStunReactionAnimationType {
    fn type_info(&self) -> &'static TypeInfo {
        AISTUNREACTIONANIMATIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AISTUNREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStunReactionAnimationType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIStunReactionAnimationType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIProjectileComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub projectiles: Vec<BattleAIProjectile>,
    pub projectile_gamestates: BattleAIProjectileBinding,
    pub melee_projectile: bool,
    pub use_pre_throw_target_position_as_fallback: bool,
    pub only_use_pre_throw_target_position: bool,
    pub fetch_target_pos_from_comp: bool,
    pub projectile_spawn_bone: super::entity::GameplayBones,
    pub target_position: super::core::Vec3,
    pub target_relative_yaw: f32,
    pub target_is_vulnerable: bool,
    pub projectile_spawn_transform: super::core::LinearTransform,
    pub projectile_index_override: i32,
}

pub trait AIProjectileComponentDataTrait: super::entity::GameComponentDataTrait {
    fn projectiles(&self) -> &Vec<BattleAIProjectile>;
    fn projectiles_mut(&mut self) -> &mut Vec<BattleAIProjectile>;
    fn projectile_gamestates(&self) -> &BattleAIProjectileBinding;
    fn projectile_gamestates_mut(&mut self) -> &mut BattleAIProjectileBinding;
    fn melee_projectile(&self) -> &bool;
    fn melee_projectile_mut(&mut self) -> &mut bool;
    fn use_pre_throw_target_position_as_fallback(&self) -> &bool;
    fn use_pre_throw_target_position_as_fallback_mut(&mut self) -> &mut bool;
    fn only_use_pre_throw_target_position(&self) -> &bool;
    fn only_use_pre_throw_target_position_mut(&mut self) -> &mut bool;
    fn fetch_target_pos_from_comp(&self) -> &bool;
    fn fetch_target_pos_from_comp_mut(&mut self) -> &mut bool;
    fn projectile_spawn_bone(&self) -> &super::entity::GameplayBones;
    fn projectile_spawn_bone_mut(&mut self) -> &mut super::entity::GameplayBones;
    fn target_position(&self) -> &super::core::Vec3;
    fn target_position_mut(&mut self) -> &mut super::core::Vec3;
    fn target_relative_yaw(&self) -> &f32;
    fn target_relative_yaw_mut(&mut self) -> &mut f32;
    fn target_is_vulnerable(&self) -> &bool;
    fn target_is_vulnerable_mut(&mut self) -> &mut bool;
    fn projectile_spawn_transform(&self) -> &super::core::LinearTransform;
    fn projectile_spawn_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn projectile_index_override(&self) -> &i32;
    fn projectile_index_override_mut(&mut self) -> &mut i32;
}

impl AIProjectileComponentDataTrait for AIProjectileComponentData {
    fn projectiles(&self) -> &Vec<BattleAIProjectile> {
        &self.projectiles
    }
    fn projectiles_mut(&mut self) -> &mut Vec<BattleAIProjectile> {
        &mut self.projectiles
    }
    fn projectile_gamestates(&self) -> &BattleAIProjectileBinding {
        &self.projectile_gamestates
    }
    fn projectile_gamestates_mut(&mut self) -> &mut BattleAIProjectileBinding {
        &mut self.projectile_gamestates
    }
    fn melee_projectile(&self) -> &bool {
        &self.melee_projectile
    }
    fn melee_projectile_mut(&mut self) -> &mut bool {
        &mut self.melee_projectile
    }
    fn use_pre_throw_target_position_as_fallback(&self) -> &bool {
        &self.use_pre_throw_target_position_as_fallback
    }
    fn use_pre_throw_target_position_as_fallback_mut(&mut self) -> &mut bool {
        &mut self.use_pre_throw_target_position_as_fallback
    }
    fn only_use_pre_throw_target_position(&self) -> &bool {
        &self.only_use_pre_throw_target_position
    }
    fn only_use_pre_throw_target_position_mut(&mut self) -> &mut bool {
        &mut self.only_use_pre_throw_target_position
    }
    fn fetch_target_pos_from_comp(&self) -> &bool {
        &self.fetch_target_pos_from_comp
    }
    fn fetch_target_pos_from_comp_mut(&mut self) -> &mut bool {
        &mut self.fetch_target_pos_from_comp
    }
    fn projectile_spawn_bone(&self) -> &super::entity::GameplayBones {
        &self.projectile_spawn_bone
    }
    fn projectile_spawn_bone_mut(&mut self) -> &mut super::entity::GameplayBones {
        &mut self.projectile_spawn_bone
    }
    fn target_position(&self) -> &super::core::Vec3 {
        &self.target_position
    }
    fn target_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_position
    }
    fn target_relative_yaw(&self) -> &f32 {
        &self.target_relative_yaw
    }
    fn target_relative_yaw_mut(&mut self) -> &mut f32 {
        &mut self.target_relative_yaw
    }
    fn target_is_vulnerable(&self) -> &bool {
        &self.target_is_vulnerable
    }
    fn target_is_vulnerable_mut(&mut self) -> &mut bool {
        &mut self.target_is_vulnerable
    }
    fn projectile_spawn_transform(&self) -> &super::core::LinearTransform {
        &self.projectile_spawn_transform
    }
    fn projectile_spawn_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.projectile_spawn_transform
    }
    fn projectile_index_override(&self) -> &i32 {
        &self.projectile_index_override
    }
    fn projectile_index_override_mut(&mut self) -> &mut i32 {
        &mut self.projectile_index_override
    }
}

impl super::entity::GameComponentDataTrait for AIProjectileComponentData {
}

impl super::entity::ComponentDataTrait for AIProjectileComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AIProjectileComponentData {
}

impl super::core::DataBusPeerTrait for AIProjectileComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIProjectileComponentData {
}

impl super::core::DataContainerTrait for AIProjectileComponentData {
}

pub static AIPROJECTILECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProjectileComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIProjectileComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Projectiles",
                flags: MemberInfoFlags::new(144),
                field_type: "BattleAIProjectile-Array",
                rust_offset: offset_of!(AIProjectileComponentData, projectiles),
            },
            FieldInfoData {
                name: "ProjectileGamestates",
                flags: MemberInfoFlags::new(0),
                field_type: "BattleAIProjectileBinding",
                rust_offset: offset_of!(AIProjectileComponentData, projectile_gamestates),
            },
            FieldInfoData {
                name: "MeleeProjectile",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProjectileComponentData, melee_projectile),
            },
            FieldInfoData {
                name: "UsePreThrowTargetPositionAsFallback",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProjectileComponentData, use_pre_throw_target_position_as_fallback),
            },
            FieldInfoData {
                name: "OnlyUsePreThrowTargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProjectileComponentData, only_use_pre_throw_target_position),
            },
            FieldInfoData {
                name: "FetchTargetPosFromComp",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProjectileComponentData, fetch_target_pos_from_comp),
            },
            FieldInfoData {
                name: "ProjectileSpawnBone",
                flags: MemberInfoFlags::new(0),
                field_type: "GameplayBones",
                rust_offset: offset_of!(AIProjectileComponentData, projectile_spawn_bone),
            },
            FieldInfoData {
                name: "TargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AIProjectileComponentData, target_position),
            },
            FieldInfoData {
                name: "TargetRelativeYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIProjectileComponentData, target_relative_yaw),
            },
            FieldInfoData {
                name: "TargetIsVulnerable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIProjectileComponentData, target_is_vulnerable),
            },
            FieldInfoData {
                name: "ProjectileSpawnTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AIProjectileComponentData, projectile_spawn_transform),
            },
            FieldInfoData {
                name: "ProjectileIndexOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AIProjectileComponentData, projectile_index_override),
            },
        ],
    }),
    array_type: Some(AIPROJECTILECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIProjectileComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIPROJECTILECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIPROJECTILECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProjectileComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIProjectileComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BattleAIProjectileBinding {
    pub fire_projectile: super::ant::AntRef,
}

pub trait BattleAIProjectileBindingTrait: TypeObject {
    fn fire_projectile(&self) -> &super::ant::AntRef;
    fn fire_projectile_mut(&mut self) -> &mut super::ant::AntRef;
}

impl BattleAIProjectileBindingTrait for BattleAIProjectileBinding {
    fn fire_projectile(&self) -> &super::ant::AntRef {
        &self.fire_projectile
    }
    fn fire_projectile_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.fire_projectile
    }
}

pub static BATTLEAIPROJECTILEBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectileBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BattleAIProjectileBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FireProjectile",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(BattleAIProjectileBinding, fire_projectile),
            },
        ],
    }),
    array_type: Some(BATTLEAIPROJECTILEBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BattleAIProjectileBinding {
    fn type_info(&self) -> &'static TypeInfo {
        BATTLEAIPROJECTILEBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BATTLEAIPROJECTILEBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectileBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAIProjectileBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BattleAIProjectile {
    pub curve: BattleAIProjectileCurveType,
    pub minimum: LinearTime,
    pub maximum: LinearTime,
    pub dispersion: Dispersion,
    pub projectile: Option<Arc<Mutex<dyn super::weapon_shared::ProjectileBlueprintTrait>>>,
    pub sound: Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>,
    pub timer_type: GrenadeTimerType,
    pub vulnerable_target_dispersion: Dispersion,
    pub dispersion_from_behind_angle: f32,
    pub to_target_distance_ratio: f32,
    pub force_min_distance_to_target: f32,
    pub target_prediction_lead_time: f32,
    pub use_target_position_for_lead_time: bool,
    pub max_pre_throw_correction_distance: f32,
    pub validate_trajectory_pre_throw: bool,
    pub validate_trajectory_throw: bool,
    pub use_last_known_position: bool,
    pub skip_range_check: bool,
    pub token_type: GrenadeTokenType,
    pub unlock_asset: Option<Arc<Mutex<dyn super::weapon_shared::WeaponUnlockAssetTrait>>>,
}

pub trait BattleAIProjectileTrait: TypeObject {
    fn curve(&self) -> &BattleAIProjectileCurveType;
    fn curve_mut(&mut self) -> &mut BattleAIProjectileCurveType;
    fn minimum(&self) -> &LinearTime;
    fn minimum_mut(&mut self) -> &mut LinearTime;
    fn maximum(&self) -> &LinearTime;
    fn maximum_mut(&mut self) -> &mut LinearTime;
    fn dispersion(&self) -> &Dispersion;
    fn dispersion_mut(&mut self) -> &mut Dispersion;
    fn projectile(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::ProjectileBlueprintTrait>>>;
    fn projectile_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::ProjectileBlueprintTrait>>>;
    fn sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>>;
    fn timer_type(&self) -> &GrenadeTimerType;
    fn timer_type_mut(&mut self) -> &mut GrenadeTimerType;
    fn vulnerable_target_dispersion(&self) -> &Dispersion;
    fn vulnerable_target_dispersion_mut(&mut self) -> &mut Dispersion;
    fn dispersion_from_behind_angle(&self) -> &f32;
    fn dispersion_from_behind_angle_mut(&mut self) -> &mut f32;
    fn to_target_distance_ratio(&self) -> &f32;
    fn to_target_distance_ratio_mut(&mut self) -> &mut f32;
    fn force_min_distance_to_target(&self) -> &f32;
    fn force_min_distance_to_target_mut(&mut self) -> &mut f32;
    fn target_prediction_lead_time(&self) -> &f32;
    fn target_prediction_lead_time_mut(&mut self) -> &mut f32;
    fn use_target_position_for_lead_time(&self) -> &bool;
    fn use_target_position_for_lead_time_mut(&mut self) -> &mut bool;
    fn max_pre_throw_correction_distance(&self) -> &f32;
    fn max_pre_throw_correction_distance_mut(&mut self) -> &mut f32;
    fn validate_trajectory_pre_throw(&self) -> &bool;
    fn validate_trajectory_pre_throw_mut(&mut self) -> &mut bool;
    fn validate_trajectory_throw(&self) -> &bool;
    fn validate_trajectory_throw_mut(&mut self) -> &mut bool;
    fn use_last_known_position(&self) -> &bool;
    fn use_last_known_position_mut(&mut self) -> &mut bool;
    fn skip_range_check(&self) -> &bool;
    fn skip_range_check_mut(&mut self) -> &mut bool;
    fn token_type(&self) -> &GrenadeTokenType;
    fn token_type_mut(&mut self) -> &mut GrenadeTokenType;
    fn unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponUnlockAssetTrait>>>;
    fn unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponUnlockAssetTrait>>>;
}

impl BattleAIProjectileTrait for BattleAIProjectile {
    fn curve(&self) -> &BattleAIProjectileCurveType {
        &self.curve
    }
    fn curve_mut(&mut self) -> &mut BattleAIProjectileCurveType {
        &mut self.curve
    }
    fn minimum(&self) -> &LinearTime {
        &self.minimum
    }
    fn minimum_mut(&mut self) -> &mut LinearTime {
        &mut self.minimum
    }
    fn maximum(&self) -> &LinearTime {
        &self.maximum
    }
    fn maximum_mut(&mut self) -> &mut LinearTime {
        &mut self.maximum
    }
    fn dispersion(&self) -> &Dispersion {
        &self.dispersion
    }
    fn dispersion_mut(&mut self) -> &mut Dispersion {
        &mut self.dispersion
    }
    fn projectile(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::ProjectileBlueprintTrait>>> {
        &self.projectile
    }
    fn projectile_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::ProjectileBlueprintTrait>>> {
        &mut self.projectile
    }
    fn sound(&self) -> &Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::audio::SoundAssetTrait>>> {
        &mut self.sound
    }
    fn timer_type(&self) -> &GrenadeTimerType {
        &self.timer_type
    }
    fn timer_type_mut(&mut self) -> &mut GrenadeTimerType {
        &mut self.timer_type
    }
    fn vulnerable_target_dispersion(&self) -> &Dispersion {
        &self.vulnerable_target_dispersion
    }
    fn vulnerable_target_dispersion_mut(&mut self) -> &mut Dispersion {
        &mut self.vulnerable_target_dispersion
    }
    fn dispersion_from_behind_angle(&self) -> &f32 {
        &self.dispersion_from_behind_angle
    }
    fn dispersion_from_behind_angle_mut(&mut self) -> &mut f32 {
        &mut self.dispersion_from_behind_angle
    }
    fn to_target_distance_ratio(&self) -> &f32 {
        &self.to_target_distance_ratio
    }
    fn to_target_distance_ratio_mut(&mut self) -> &mut f32 {
        &mut self.to_target_distance_ratio
    }
    fn force_min_distance_to_target(&self) -> &f32 {
        &self.force_min_distance_to_target
    }
    fn force_min_distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.force_min_distance_to_target
    }
    fn target_prediction_lead_time(&self) -> &f32 {
        &self.target_prediction_lead_time
    }
    fn target_prediction_lead_time_mut(&mut self) -> &mut f32 {
        &mut self.target_prediction_lead_time
    }
    fn use_target_position_for_lead_time(&self) -> &bool {
        &self.use_target_position_for_lead_time
    }
    fn use_target_position_for_lead_time_mut(&mut self) -> &mut bool {
        &mut self.use_target_position_for_lead_time
    }
    fn max_pre_throw_correction_distance(&self) -> &f32 {
        &self.max_pre_throw_correction_distance
    }
    fn max_pre_throw_correction_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_pre_throw_correction_distance
    }
    fn validate_trajectory_pre_throw(&self) -> &bool {
        &self.validate_trajectory_pre_throw
    }
    fn validate_trajectory_pre_throw_mut(&mut self) -> &mut bool {
        &mut self.validate_trajectory_pre_throw
    }
    fn validate_trajectory_throw(&self) -> &bool {
        &self.validate_trajectory_throw
    }
    fn validate_trajectory_throw_mut(&mut self) -> &mut bool {
        &mut self.validate_trajectory_throw
    }
    fn use_last_known_position(&self) -> &bool {
        &self.use_last_known_position
    }
    fn use_last_known_position_mut(&mut self) -> &mut bool {
        &mut self.use_last_known_position
    }
    fn skip_range_check(&self) -> &bool {
        &self.skip_range_check
    }
    fn skip_range_check_mut(&mut self) -> &mut bool {
        &mut self.skip_range_check
    }
    fn token_type(&self) -> &GrenadeTokenType {
        &self.token_type
    }
    fn token_type_mut(&mut self) -> &mut GrenadeTokenType {
        &mut self.token_type
    }
    fn unlock_asset(&self) -> &Option<Arc<Mutex<dyn super::weapon_shared::WeaponUnlockAssetTrait>>> {
        &self.unlock_asset
    }
    fn unlock_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::weapon_shared::WeaponUnlockAssetTrait>>> {
        &mut self.unlock_asset
    }
}

pub static BATTLEAIPROJECTILE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectile",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BattleAIProjectile as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(0),
                field_type: "BattleAIProjectileCurveType",
                rust_offset: offset_of!(BattleAIProjectile, curve),
            },
            FieldInfoData {
                name: "Minimum",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTime",
                rust_offset: offset_of!(BattleAIProjectile, minimum),
            },
            FieldInfoData {
                name: "Maximum",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTime",
                rust_offset: offset_of!(BattleAIProjectile, maximum),
            },
            FieldInfoData {
                name: "Dispersion",
                flags: MemberInfoFlags::new(0),
                field_type: "Dispersion",
                rust_offset: offset_of!(BattleAIProjectile, dispersion),
            },
            FieldInfoData {
                name: "Projectile",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileBlueprint",
                rust_offset: offset_of!(BattleAIProjectile, projectile),
            },
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(BattleAIProjectile, sound),
            },
            FieldInfoData {
                name: "TimerType",
                flags: MemberInfoFlags::new(0),
                field_type: "GrenadeTimerType",
                rust_offset: offset_of!(BattleAIProjectile, timer_type),
            },
            FieldInfoData {
                name: "VulnerableTargetDispersion",
                flags: MemberInfoFlags::new(0),
                field_type: "Dispersion",
                rust_offset: offset_of!(BattleAIProjectile, vulnerable_target_dispersion),
            },
            FieldInfoData {
                name: "DispersionFromBehindAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BattleAIProjectile, dispersion_from_behind_angle),
            },
            FieldInfoData {
                name: "ToTargetDistanceRatio",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BattleAIProjectile, to_target_distance_ratio),
            },
            FieldInfoData {
                name: "ForceMinDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BattleAIProjectile, force_min_distance_to_target),
            },
            FieldInfoData {
                name: "TargetPredictionLeadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BattleAIProjectile, target_prediction_lead_time),
            },
            FieldInfoData {
                name: "UseTargetPositionForLeadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAIProjectile, use_target_position_for_lead_time),
            },
            FieldInfoData {
                name: "MaxPreThrowCorrectionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BattleAIProjectile, max_pre_throw_correction_distance),
            },
            FieldInfoData {
                name: "ValidateTrajectoryPreThrow",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAIProjectile, validate_trajectory_pre_throw),
            },
            FieldInfoData {
                name: "ValidateTrajectoryThrow",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAIProjectile, validate_trajectory_throw),
            },
            FieldInfoData {
                name: "UseLastKnownPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAIProjectile, use_last_known_position),
            },
            FieldInfoData {
                name: "SkipRangeCheck",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAIProjectile, skip_range_check),
            },
            FieldInfoData {
                name: "TokenType",
                flags: MemberInfoFlags::new(0),
                field_type: "GrenadeTokenType",
                rust_offset: offset_of!(BattleAIProjectile, token_type),
            },
            FieldInfoData {
                name: "UnlockAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponUnlockAsset",
                rust_offset: offset_of!(BattleAIProjectile, unlock_asset),
            },
        ],
    }),
    array_type: Some(BATTLEAIPROJECTILE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BattleAIProjectile {
    fn type_info(&self) -> &'static TypeInfo {
        BATTLEAIPROJECTILE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BATTLEAIPROJECTILE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectile-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAIProjectile"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Dispersion {
    pub minimum_horizontal: f32,
    pub maximum_horizontal: f32,
    pub minimum_vertical: f32,
    pub maximum_vertical: f32,
    pub scaling_distance: f32,
    pub scale_with_distance: bool,
}

pub trait DispersionTrait: TypeObject {
    fn minimum_horizontal(&self) -> &f32;
    fn minimum_horizontal_mut(&mut self) -> &mut f32;
    fn maximum_horizontal(&self) -> &f32;
    fn maximum_horizontal_mut(&mut self) -> &mut f32;
    fn minimum_vertical(&self) -> &f32;
    fn minimum_vertical_mut(&mut self) -> &mut f32;
    fn maximum_vertical(&self) -> &f32;
    fn maximum_vertical_mut(&mut self) -> &mut f32;
    fn scaling_distance(&self) -> &f32;
    fn scaling_distance_mut(&mut self) -> &mut f32;
    fn scale_with_distance(&self) -> &bool;
    fn scale_with_distance_mut(&mut self) -> &mut bool;
}

impl DispersionTrait for Dispersion {
    fn minimum_horizontal(&self) -> &f32 {
        &self.minimum_horizontal
    }
    fn minimum_horizontal_mut(&mut self) -> &mut f32 {
        &mut self.minimum_horizontal
    }
    fn maximum_horizontal(&self) -> &f32 {
        &self.maximum_horizontal
    }
    fn maximum_horizontal_mut(&mut self) -> &mut f32 {
        &mut self.maximum_horizontal
    }
    fn minimum_vertical(&self) -> &f32 {
        &self.minimum_vertical
    }
    fn minimum_vertical_mut(&mut self) -> &mut f32 {
        &mut self.minimum_vertical
    }
    fn maximum_vertical(&self) -> &f32 {
        &self.maximum_vertical
    }
    fn maximum_vertical_mut(&mut self) -> &mut f32 {
        &mut self.maximum_vertical
    }
    fn scaling_distance(&self) -> &f32 {
        &self.scaling_distance
    }
    fn scaling_distance_mut(&mut self) -> &mut f32 {
        &mut self.scaling_distance
    }
    fn scale_with_distance(&self) -> &bool {
        &self.scale_with_distance
    }
    fn scale_with_distance_mut(&mut self) -> &mut bool {
        &mut self.scale_with_distance
    }
}

pub static DISPERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Dispersion",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Dispersion as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinimumHorizontal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Dispersion, minimum_horizontal),
            },
            FieldInfoData {
                name: "MaximumHorizontal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Dispersion, maximum_horizontal),
            },
            FieldInfoData {
                name: "MinimumVertical",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Dispersion, minimum_vertical),
            },
            FieldInfoData {
                name: "MaximumVertical",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Dispersion, maximum_vertical),
            },
            FieldInfoData {
                name: "ScalingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Dispersion, scaling_distance),
            },
            FieldInfoData {
                name: "ScaleWithDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(Dispersion, scale_with_distance),
            },
        ],
    }),
    array_type: Some(DISPERSION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Dispersion {
    fn type_info(&self) -> &'static TypeInfo {
        DISPERSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DISPERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Dispersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Dispersion"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GrenadeTokenType {
    #[default]
    GrenadeTokenType_Frag = 0,
    GrenadeTokenType_AT = 1,
    GrenadeTokenType_Smoke = 2,
    GrenadeTokenType_Incendiary = 3,
    GrenadeTokenType_Gas = 4,
    GrenadeTokenType_Flash = 5,
}

pub static GRENADETOKENTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTokenType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(GRENADETOKENTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GrenadeTokenType {
    fn type_info(&self) -> &'static TypeInfo {
        GRENADETOKENTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GRENADETOKENTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTokenType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GrenadeTokenType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GrenadeTimerType {
    #[default]
    GrenadeTimerType_Grenade = 0,
    GrenadeTimerType_Smoke = 1,
}

pub static GRENADETIMERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTimerType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(GRENADETIMERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GrenadeTimerType {
    fn type_info(&self) -> &'static TypeInfo {
        GRENADETIMERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GRENADETIMERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTimerType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GrenadeTimerType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinearTime {
    pub distance: f32,
    pub time: f32,
}

pub trait LinearTimeTrait: TypeObject {
    fn distance(&self) -> &f32;
    fn distance_mut(&mut self) -> &mut f32;
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
}

impl LinearTimeTrait for LinearTime {
    fn distance(&self) -> &f32 {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut f32 {
        &mut self.distance
    }
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
}

pub static LINEARTIME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearTime",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinearTime as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearTime, distance),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LinearTime, time),
            },
        ],
    }),
    array_type: Some(LINEARTIME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LinearTime {
    fn type_info(&self) -> &'static TypeInfo {
        LINEARTIME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LINEARTIME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearTime-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LinearTime"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BattleAIProjectileCurveType {
    #[default]
    BattleAIProjectileType_Straight = 0,
    BattleAIProjectileType_Parabolic = 1,
}

pub static BATTLEAIPROJECTILECURVETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectileCurveType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(BATTLEAIPROJECTILECURVETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BattleAIProjectileCurveType {
    fn type_info(&self) -> &'static TypeInfo {
        BATTLEAIPROJECTILECURVETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BATTLEAIPROJECTILECURVETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectileCurveType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAIProjectileCurveType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIPhysicsDrivenAnimationEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub bindings: AIPhysicsDrivenAnimationBinding,
    pub loco_shared_bindings: AISharedBinding,
    pub enable: bool,
    pub force_set_transform: bool,
    pub move_speed_state: i32,
    pub target_position: super::core::Vec3,
    pub rotation_speed: f32,
    pub move_speed_scale: f32,
    pub rotation_speed_scale: f32,
    pub start_decel_distance: f32,
    pub stop_physics_loco_distance: f32,
    pub enable_target_tracking: bool,
    pub acceleration: f32,
    pub deceleration: f32,
    pub enter_cover_distance: f32,
    pub rotate_to_cover_distance: f32,
    pub rotate_to_scenario_distance: f32,
    pub face_next_waypoint_distance: f32,
}

pub trait AIPhysicsDrivenAnimationEntityDataTrait: super::entity::EntityDataTrait {
    fn bindings(&self) -> &AIPhysicsDrivenAnimationBinding;
    fn bindings_mut(&mut self) -> &mut AIPhysicsDrivenAnimationBinding;
    fn loco_shared_bindings(&self) -> &AISharedBinding;
    fn loco_shared_bindings_mut(&mut self) -> &mut AISharedBinding;
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn force_set_transform(&self) -> &bool;
    fn force_set_transform_mut(&mut self) -> &mut bool;
    fn move_speed_state(&self) -> &i32;
    fn move_speed_state_mut(&mut self) -> &mut i32;
    fn target_position(&self) -> &super::core::Vec3;
    fn target_position_mut(&mut self) -> &mut super::core::Vec3;
    fn rotation_speed(&self) -> &f32;
    fn rotation_speed_mut(&mut self) -> &mut f32;
    fn move_speed_scale(&self) -> &f32;
    fn move_speed_scale_mut(&mut self) -> &mut f32;
    fn rotation_speed_scale(&self) -> &f32;
    fn rotation_speed_scale_mut(&mut self) -> &mut f32;
    fn start_decel_distance(&self) -> &f32;
    fn start_decel_distance_mut(&mut self) -> &mut f32;
    fn stop_physics_loco_distance(&self) -> &f32;
    fn stop_physics_loco_distance_mut(&mut self) -> &mut f32;
    fn enable_target_tracking(&self) -> &bool;
    fn enable_target_tracking_mut(&mut self) -> &mut bool;
    fn acceleration(&self) -> &f32;
    fn acceleration_mut(&mut self) -> &mut f32;
    fn deceleration(&self) -> &f32;
    fn deceleration_mut(&mut self) -> &mut f32;
    fn enter_cover_distance(&self) -> &f32;
    fn enter_cover_distance_mut(&mut self) -> &mut f32;
    fn rotate_to_cover_distance(&self) -> &f32;
    fn rotate_to_cover_distance_mut(&mut self) -> &mut f32;
    fn rotate_to_scenario_distance(&self) -> &f32;
    fn rotate_to_scenario_distance_mut(&mut self) -> &mut f32;
    fn face_next_waypoint_distance(&self) -> &f32;
    fn face_next_waypoint_distance_mut(&mut self) -> &mut f32;
}

impl AIPhysicsDrivenAnimationEntityDataTrait for AIPhysicsDrivenAnimationEntityData {
    fn bindings(&self) -> &AIPhysicsDrivenAnimationBinding {
        &self.bindings
    }
    fn bindings_mut(&mut self) -> &mut AIPhysicsDrivenAnimationBinding {
        &mut self.bindings
    }
    fn loco_shared_bindings(&self) -> &AISharedBinding {
        &self.loco_shared_bindings
    }
    fn loco_shared_bindings_mut(&mut self) -> &mut AISharedBinding {
        &mut self.loco_shared_bindings
    }
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn force_set_transform(&self) -> &bool {
        &self.force_set_transform
    }
    fn force_set_transform_mut(&mut self) -> &mut bool {
        &mut self.force_set_transform
    }
    fn move_speed_state(&self) -> &i32 {
        &self.move_speed_state
    }
    fn move_speed_state_mut(&mut self) -> &mut i32 {
        &mut self.move_speed_state
    }
    fn target_position(&self) -> &super::core::Vec3 {
        &self.target_position
    }
    fn target_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_position
    }
    fn rotation_speed(&self) -> &f32 {
        &self.rotation_speed
    }
    fn rotation_speed_mut(&mut self) -> &mut f32 {
        &mut self.rotation_speed
    }
    fn move_speed_scale(&self) -> &f32 {
        &self.move_speed_scale
    }
    fn move_speed_scale_mut(&mut self) -> &mut f32 {
        &mut self.move_speed_scale
    }
    fn rotation_speed_scale(&self) -> &f32 {
        &self.rotation_speed_scale
    }
    fn rotation_speed_scale_mut(&mut self) -> &mut f32 {
        &mut self.rotation_speed_scale
    }
    fn start_decel_distance(&self) -> &f32 {
        &self.start_decel_distance
    }
    fn start_decel_distance_mut(&mut self) -> &mut f32 {
        &mut self.start_decel_distance
    }
    fn stop_physics_loco_distance(&self) -> &f32 {
        &self.stop_physics_loco_distance
    }
    fn stop_physics_loco_distance_mut(&mut self) -> &mut f32 {
        &mut self.stop_physics_loco_distance
    }
    fn enable_target_tracking(&self) -> &bool {
        &self.enable_target_tracking
    }
    fn enable_target_tracking_mut(&mut self) -> &mut bool {
        &mut self.enable_target_tracking
    }
    fn acceleration(&self) -> &f32 {
        &self.acceleration
    }
    fn acceleration_mut(&mut self) -> &mut f32 {
        &mut self.acceleration
    }
    fn deceleration(&self) -> &f32 {
        &self.deceleration
    }
    fn deceleration_mut(&mut self) -> &mut f32 {
        &mut self.deceleration
    }
    fn enter_cover_distance(&self) -> &f32 {
        &self.enter_cover_distance
    }
    fn enter_cover_distance_mut(&mut self) -> &mut f32 {
        &mut self.enter_cover_distance
    }
    fn rotate_to_cover_distance(&self) -> &f32 {
        &self.rotate_to_cover_distance
    }
    fn rotate_to_cover_distance_mut(&mut self) -> &mut f32 {
        &mut self.rotate_to_cover_distance
    }
    fn rotate_to_scenario_distance(&self) -> &f32 {
        &self.rotate_to_scenario_distance
    }
    fn rotate_to_scenario_distance_mut(&mut self) -> &mut f32 {
        &mut self.rotate_to_scenario_distance
    }
    fn face_next_waypoint_distance(&self) -> &f32 {
        &self.face_next_waypoint_distance
    }
    fn face_next_waypoint_distance_mut(&mut self) -> &mut f32 {
        &mut self.face_next_waypoint_distance
    }
}

impl super::entity::EntityDataTrait for AIPhysicsDrivenAnimationEntityData {
}

impl super::entity::GameObjectDataTrait for AIPhysicsDrivenAnimationEntityData {
}

impl super::core::DataBusPeerTrait for AIPhysicsDrivenAnimationEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIPhysicsDrivenAnimationEntityData {
}

impl super::core::DataContainerTrait for AIPhysicsDrivenAnimationEntityData {
}

pub static AIPHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPhysicsDrivenAnimationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIPhysicsDrivenAnimationEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Bindings",
                flags: MemberInfoFlags::new(0),
                field_type: "AIPhysicsDrivenAnimationBinding",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, bindings),
            },
            FieldInfoData {
                name: "LocoSharedBindings",
                flags: MemberInfoFlags::new(0),
                field_type: "AISharedBinding",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, loco_shared_bindings),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, enable),
            },
            FieldInfoData {
                name: "ForceSetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, force_set_transform),
            },
            FieldInfoData {
                name: "MoveSpeedState",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, move_speed_state),
            },
            FieldInfoData {
                name: "TargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, target_position),
            },
            FieldInfoData {
                name: "RotationSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, rotation_speed),
            },
            FieldInfoData {
                name: "MoveSpeedScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, move_speed_scale),
            },
            FieldInfoData {
                name: "RotationSpeedScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, rotation_speed_scale),
            },
            FieldInfoData {
                name: "StartDecelDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, start_decel_distance),
            },
            FieldInfoData {
                name: "StopPhysicsLocoDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, stop_physics_loco_distance),
            },
            FieldInfoData {
                name: "EnableTargetTracking",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, enable_target_tracking),
            },
            FieldInfoData {
                name: "Acceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, acceleration),
            },
            FieldInfoData {
                name: "Deceleration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, deceleration),
            },
            FieldInfoData {
                name: "EnterCoverDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, enter_cover_distance),
            },
            FieldInfoData {
                name: "RotateToCoverDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, rotate_to_cover_distance),
            },
            FieldInfoData {
                name: "RotateToScenarioDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, rotate_to_scenario_distance),
            },
            FieldInfoData {
                name: "FaceNextWaypointDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, face_next_waypoint_distance),
            },
        ],
    }),
    array_type: Some(AIPHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIPhysicsDrivenAnimationEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIPHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIPHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPhysicsDrivenAnimationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPhysicsDrivenAnimationEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISharedBinding {
    pub relative_aim: super::ant::AntRef,
    pub desired_steering: super::ant::AntRef,
}

pub trait AISharedBindingTrait: TypeObject {
    fn relative_aim(&self) -> &super::ant::AntRef;
    fn relative_aim_mut(&mut self) -> &mut super::ant::AntRef;
    fn desired_steering(&self) -> &super::ant::AntRef;
    fn desired_steering_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AISharedBindingTrait for AISharedBinding {
    fn relative_aim(&self) -> &super::ant::AntRef {
        &self.relative_aim
    }
    fn relative_aim_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.relative_aim
    }
    fn desired_steering(&self) -> &super::ant::AntRef {
        &self.desired_steering
    }
    fn desired_steering_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.desired_steering
    }
}

pub static AISHAREDBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISharedBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISharedBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RelativeAim",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AISharedBinding, relative_aim),
            },
            FieldInfoData {
                name: "DesiredSteering",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AISharedBinding, desired_steering),
            },
        ],
    }),
    array_type: Some(AISHAREDBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AISharedBinding {
    fn type_info(&self) -> &'static TypeInfo {
        AISHAREDBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AISHAREDBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISharedBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISharedBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIPhysicsDrivenAnimationBinding {
    pub is_animation_controlled: super::ant::AntRef,
    pub ant_current_speed: super::ant::AntRef,
    pub translation: super::ant::AntRef,
    pub rotation_quat: super::ant::AntRef,
    pub out_movement_speed: super::ant::AntRef,
    pub out_move: super::ant::AntRef,
    pub out_relative_move: super::ant::AntRef,
    pub out_facing_angle: super::ant::AntRef,
    pub out_relative_facing_angle: super::ant::AntRef,
    pub is_physics_driven_behavior: super::ant::AntRef,
    pub enable_physics_motion: super::ant::AntRef,
    pub enable_steering: super::ant::AntRef,
    pub sprint: super::ant::AntRef,
    pub gun_down: super::ant::AntRef,
    pub gun_down_weight: super::ant::AntRef,
    pub aim_up_and_down: super::ant::AntRef,
    pub ground_normal: super::ant::AntRef,
}

pub trait AIPhysicsDrivenAnimationBindingTrait: TypeObject {
    fn is_animation_controlled(&self) -> &super::ant::AntRef;
    fn is_animation_controlled_mut(&mut self) -> &mut super::ant::AntRef;
    fn ant_current_speed(&self) -> &super::ant::AntRef;
    fn ant_current_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn translation(&self) -> &super::ant::AntRef;
    fn translation_mut(&mut self) -> &mut super::ant::AntRef;
    fn rotation_quat(&self) -> &super::ant::AntRef;
    fn rotation_quat_mut(&mut self) -> &mut super::ant::AntRef;
    fn out_movement_speed(&self) -> &super::ant::AntRef;
    fn out_movement_speed_mut(&mut self) -> &mut super::ant::AntRef;
    fn out_move(&self) -> &super::ant::AntRef;
    fn out_move_mut(&mut self) -> &mut super::ant::AntRef;
    fn out_relative_move(&self) -> &super::ant::AntRef;
    fn out_relative_move_mut(&mut self) -> &mut super::ant::AntRef;
    fn out_facing_angle(&self) -> &super::ant::AntRef;
    fn out_facing_angle_mut(&mut self) -> &mut super::ant::AntRef;
    fn out_relative_facing_angle(&self) -> &super::ant::AntRef;
    fn out_relative_facing_angle_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_physics_driven_behavior(&self) -> &super::ant::AntRef;
    fn is_physics_driven_behavior_mut(&mut self) -> &mut super::ant::AntRef;
    fn enable_physics_motion(&self) -> &super::ant::AntRef;
    fn enable_physics_motion_mut(&mut self) -> &mut super::ant::AntRef;
    fn enable_steering(&self) -> &super::ant::AntRef;
    fn enable_steering_mut(&mut self) -> &mut super::ant::AntRef;
    fn sprint(&self) -> &super::ant::AntRef;
    fn sprint_mut(&mut self) -> &mut super::ant::AntRef;
    fn gun_down(&self) -> &super::ant::AntRef;
    fn gun_down_mut(&mut self) -> &mut super::ant::AntRef;
    fn gun_down_weight(&self) -> &super::ant::AntRef;
    fn gun_down_weight_mut(&mut self) -> &mut super::ant::AntRef;
    fn aim_up_and_down(&self) -> &super::ant::AntRef;
    fn aim_up_and_down_mut(&mut self) -> &mut super::ant::AntRef;
    fn ground_normal(&self) -> &super::ant::AntRef;
    fn ground_normal_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AIPhysicsDrivenAnimationBindingTrait for AIPhysicsDrivenAnimationBinding {
    fn is_animation_controlled(&self) -> &super::ant::AntRef {
        &self.is_animation_controlled
    }
    fn is_animation_controlled_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_animation_controlled
    }
    fn ant_current_speed(&self) -> &super::ant::AntRef {
        &self.ant_current_speed
    }
    fn ant_current_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ant_current_speed
    }
    fn translation(&self) -> &super::ant::AntRef {
        &self.translation
    }
    fn translation_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.translation
    }
    fn rotation_quat(&self) -> &super::ant::AntRef {
        &self.rotation_quat
    }
    fn rotation_quat_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.rotation_quat
    }
    fn out_movement_speed(&self) -> &super::ant::AntRef {
        &self.out_movement_speed
    }
    fn out_movement_speed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.out_movement_speed
    }
    fn out_move(&self) -> &super::ant::AntRef {
        &self.out_move
    }
    fn out_move_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.out_move
    }
    fn out_relative_move(&self) -> &super::ant::AntRef {
        &self.out_relative_move
    }
    fn out_relative_move_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.out_relative_move
    }
    fn out_facing_angle(&self) -> &super::ant::AntRef {
        &self.out_facing_angle
    }
    fn out_facing_angle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.out_facing_angle
    }
    fn out_relative_facing_angle(&self) -> &super::ant::AntRef {
        &self.out_relative_facing_angle
    }
    fn out_relative_facing_angle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.out_relative_facing_angle
    }
    fn is_physics_driven_behavior(&self) -> &super::ant::AntRef {
        &self.is_physics_driven_behavior
    }
    fn is_physics_driven_behavior_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_physics_driven_behavior
    }
    fn enable_physics_motion(&self) -> &super::ant::AntRef {
        &self.enable_physics_motion
    }
    fn enable_physics_motion_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enable_physics_motion
    }
    fn enable_steering(&self) -> &super::ant::AntRef {
        &self.enable_steering
    }
    fn enable_steering_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enable_steering
    }
    fn sprint(&self) -> &super::ant::AntRef {
        &self.sprint
    }
    fn sprint_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.sprint
    }
    fn gun_down(&self) -> &super::ant::AntRef {
        &self.gun_down
    }
    fn gun_down_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.gun_down
    }
    fn gun_down_weight(&self) -> &super::ant::AntRef {
        &self.gun_down_weight
    }
    fn gun_down_weight_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.gun_down_weight
    }
    fn aim_up_and_down(&self) -> &super::ant::AntRef {
        &self.aim_up_and_down
    }
    fn aim_up_and_down_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.aim_up_and_down
    }
    fn ground_normal(&self) -> &super::ant::AntRef {
        &self.ground_normal
    }
    fn ground_normal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.ground_normal
    }
}

pub static AIPHYSICSDRIVENANIMATIONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPhysicsDrivenAnimationBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIPhysicsDrivenAnimationBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsAnimationControlled",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, is_animation_controlled),
            },
            FieldInfoData {
                name: "AntCurrentSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, ant_current_speed),
            },
            FieldInfoData {
                name: "Translation",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, translation),
            },
            FieldInfoData {
                name: "RotationQuat",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, rotation_quat),
            },
            FieldInfoData {
                name: "OutMovementSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_movement_speed),
            },
            FieldInfoData {
                name: "OutMove",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_move),
            },
            FieldInfoData {
                name: "OutRelativeMove",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_relative_move),
            },
            FieldInfoData {
                name: "OutFacingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_facing_angle),
            },
            FieldInfoData {
                name: "OutRelativeFacingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_relative_facing_angle),
            },
            FieldInfoData {
                name: "IsPhysicsDrivenBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, is_physics_driven_behavior),
            },
            FieldInfoData {
                name: "EnablePhysicsMotion",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, enable_physics_motion),
            },
            FieldInfoData {
                name: "EnableSteering",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, enable_steering),
            },
            FieldInfoData {
                name: "Sprint",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, sprint),
            },
            FieldInfoData {
                name: "GunDown",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, gun_down),
            },
            FieldInfoData {
                name: "GunDownWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, gun_down_weight),
            },
            FieldInfoData {
                name: "AimUpAndDown",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, aim_up_and_down),
            },
            FieldInfoData {
                name: "GroundNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, ground_normal),
            },
        ],
    }),
    array_type: Some(AIPHYSICSDRIVENANIMATIONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIPhysicsDrivenAnimationBinding {
    fn type_info(&self) -> &'static TypeInfo {
        AIPHYSICSDRIVENANIMATIONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIPHYSICSDRIVENANIMATIONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPhysicsDrivenAnimationBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPhysicsDrivenAnimationBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PhysicsDrivenCoverState {
    #[default]
    Inactive = 0,
    InCover = 1,
    MoveToCover = 2,
    GetInCover = 3,
}

pub static PHYSICSDRIVENCOVERSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenCoverState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(PHYSICSDRIVENCOVERSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PhysicsDrivenCoverState {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSDRIVENCOVERSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PHYSICSDRIVENCOVERSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenCoverState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PhysicsDrivenCoverState"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIPathlinkUsageType {
    #[default]
    AIPathlinkUsageType_Combat = 1,
    AIPathlinkUsageType_NonCombat = 2,
    AIPathlinkUsageType_Any = 65535,
}

pub static AIPATHLINKUSAGETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathlinkUsageType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKUSAGETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathlinkUsageType {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHLINKUSAGETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIPATHLINKUSAGETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathlinkUsageType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathlinkUsageType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AINavObstaclePenalty {
    #[default]
    AINavObstaclePenalty_None = 0,
    AINavObstaclePenalty_Light = 1,
    AINavObstaclePenalty_Moderate = 2,
    AINavObstaclePenalty_Heavy = 3,
    AINavObstaclePenalty_Max = 4,
    AINavObstaclePenalty_NumTypes = 5,
}

pub static AINAVOBSTACLEPENALTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AINavObstaclePenalty",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AINAVOBSTACLEPENALTY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AINavObstaclePenalty {
    fn type_info(&self) -> &'static TypeInfo {
        AINAVOBSTACLEPENALTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AINAVOBSTACLEPENALTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AINavObstaclePenalty-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AINavObstaclePenalty"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIPathfindingLayer {
    #[default]
    AIPathfindingLayer_All = 4294967295,
    AIPathfindingLayer_Soldier_Default = 0,
    AIPathfindingLayer_Vehicle_Default = 1,
    AIPathfindingLayer_Count = 2,
}

pub static AIPATHFINDINGLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingLayer",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHFINDINGLAYER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathfindingLayer {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHFINDINGLAYER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIPATHFINDINGLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathfindingLayer"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISelfDestructEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub self_destruct_count: u32,
    pub self_destruct_delay: f32,
    pub self_destruct_no_l_o_s_delay: f32,
}

pub trait AISelfDestructEntityDataTrait: AIParameterEntityDataTrait {
    fn self_destruct_count(&self) -> &u32;
    fn self_destruct_count_mut(&mut self) -> &mut u32;
    fn self_destruct_delay(&self) -> &f32;
    fn self_destruct_delay_mut(&mut self) -> &mut f32;
    fn self_destruct_no_l_o_s_delay(&self) -> &f32;
    fn self_destruct_no_l_o_s_delay_mut(&mut self) -> &mut f32;
}

impl AISelfDestructEntityDataTrait for AISelfDestructEntityData {
    fn self_destruct_count(&self) -> &u32 {
        &self.self_destruct_count
    }
    fn self_destruct_count_mut(&mut self) -> &mut u32 {
        &mut self.self_destruct_count
    }
    fn self_destruct_delay(&self) -> &f32 {
        &self.self_destruct_delay
    }
    fn self_destruct_delay_mut(&mut self) -> &mut f32 {
        &mut self.self_destruct_delay
    }
    fn self_destruct_no_l_o_s_delay(&self) -> &f32 {
        &self.self_destruct_no_l_o_s_delay
    }
    fn self_destruct_no_l_o_s_delay_mut(&mut self) -> &mut f32 {
        &mut self.self_destruct_no_l_o_s_delay
    }
}

impl AIParameterEntityDataTrait for AISelfDestructEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AISelfDestructEntityData {
}

impl super::entity::GameObjectDataTrait for AISelfDestructEntityData {
}

impl super::core::DataBusPeerTrait for AISelfDestructEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AISelfDestructEntityData {
}

impl super::core::DataContainerTrait for AISelfDestructEntityData {
}

pub static AISELFDESTRUCTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISelfDestructEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISelfDestructEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SelfDestructCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AISelfDestructEntityData, self_destruct_count),
            },
            FieldInfoData {
                name: "SelfDestructDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISelfDestructEntityData, self_destruct_delay),
            },
            FieldInfoData {
                name: "SelfDestructNoLOSDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISelfDestructEntityData, self_destruct_no_l_o_s_delay),
            },
        ],
    }),
    array_type: Some(AISELFDESTRUCTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISelfDestructEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AISELFDESTRUCTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISELFDESTRUCTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISelfDestructEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISelfDestructEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AICoverQueryEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub priority: i32,
    pub attack_goal_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub attack_protective_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub attack_hide_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub attack_valid_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub attack_forced_move_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
}

pub trait AICoverQueryEntityDataTrait: AIParameterEntityDataTrait {
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
    fn attack_goal_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_goal_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_protective_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_protective_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_hide_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_hide_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_valid_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_valid_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_forced_move_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn attack_forced_move_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
}

impl AICoverQueryEntityDataTrait for AICoverQueryEntityData {
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
    fn attack_goal_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.attack_goal_cover_query
    }
    fn attack_goal_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.attack_goal_cover_query
    }
    fn attack_protective_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.attack_protective_cover_query
    }
    fn attack_protective_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.attack_protective_cover_query
    }
    fn attack_hide_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.attack_hide_cover_query
    }
    fn attack_hide_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.attack_hide_cover_query
    }
    fn attack_valid_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.attack_valid_cover_query
    }
    fn attack_valid_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.attack_valid_cover_query
    }
    fn attack_forced_move_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.attack_forced_move_cover_query
    }
    fn attack_forced_move_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.attack_forced_move_cover_query
    }
}

impl AIParameterEntityDataTrait for AICoverQueryEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AICoverQueryEntityData {
}

impl super::entity::GameObjectDataTrait for AICoverQueryEntityData {
}

impl super::core::DataBusPeerTrait for AICoverQueryEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AICoverQueryEntityData {
}

impl super::core::DataContainerTrait for AICoverQueryEntityData {
}

pub static AICOVERQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AICoverQueryEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AICoverQueryEntityData, priority),
            },
            FieldInfoData {
                name: "AttackGoalCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AICoverQueryEntityData, attack_goal_cover_query),
            },
            FieldInfoData {
                name: "AttackProtectiveCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AICoverQueryEntityData, attack_protective_cover_query),
            },
            FieldInfoData {
                name: "AttackHideCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AICoverQueryEntityData, attack_hide_cover_query),
            },
            FieldInfoData {
                name: "AttackValidCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AICoverQueryEntityData, attack_valid_cover_query),
            },
            FieldInfoData {
                name: "AttackForcedMoveCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AICoverQueryEntityData, attack_forced_move_cover_query),
            },
        ],
    }),
    array_type: Some(AICOVERQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICoverQueryEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AICOVERQUERYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AICOVERQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICoverQueryEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CloakingModifierEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub modifier: SensingAreaModifier,
}

pub trait CloakingModifierEntityDataTrait: AIParameterEntityDataTrait {
    fn modifier(&self) -> &SensingAreaModifier;
    fn modifier_mut(&mut self) -> &mut SensingAreaModifier;
}

impl CloakingModifierEntityDataTrait for CloakingModifierEntityData {
    fn modifier(&self) -> &SensingAreaModifier {
        &self.modifier
    }
    fn modifier_mut(&mut self) -> &mut SensingAreaModifier {
        &mut self.modifier
    }
}

impl AIParameterEntityDataTrait for CloakingModifierEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for CloakingModifierEntityData {
}

impl super::entity::GameObjectDataTrait for CloakingModifierEntityData {
}

impl super::core::DataBusPeerTrait for CloakingModifierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CloakingModifierEntityData {
}

impl super::core::DataContainerTrait for CloakingModifierEntityData {
}

pub static CLOAKINGMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloakingModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CloakingModifierEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Modifier",
                flags: MemberInfoFlags::new(0),
                field_type: "SensingAreaModifier",
                rust_offset: offset_of!(CloakingModifierEntityData, modifier),
            },
        ],
    }),
    array_type: Some(CLOAKINGMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CloakingModifierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CLOAKINGMODIFIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CLOAKINGMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloakingModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CloakingModifierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SensingAreaModifierEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub modifier: SensingAreaModifier,
}

pub trait SensingAreaModifierEntityDataTrait: AIParameterEntityDataTrait {
    fn modifier(&self) -> &SensingAreaModifier;
    fn modifier_mut(&mut self) -> &mut SensingAreaModifier;
}

impl SensingAreaModifierEntityDataTrait for SensingAreaModifierEntityData {
    fn modifier(&self) -> &SensingAreaModifier {
        &self.modifier
    }
    fn modifier_mut(&mut self) -> &mut SensingAreaModifier {
        &mut self.modifier
    }
}

impl AIParameterEntityDataTrait for SensingAreaModifierEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for SensingAreaModifierEntityData {
}

impl super::entity::GameObjectDataTrait for SensingAreaModifierEntityData {
}

impl super::core::DataBusPeerTrait for SensingAreaModifierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SensingAreaModifierEntityData {
}

impl super::core::DataContainerTrait for SensingAreaModifierEntityData {
}

pub static SENSINGAREAMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SensingAreaModifierEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Modifier",
                flags: MemberInfoFlags::new(0),
                field_type: "SensingAreaModifier",
                rust_offset: offset_of!(SensingAreaModifierEntityData, modifier),
            },
        ],
    }),
    array_type: Some(SENSINGAREAMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SensingAreaModifierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SENSINGAREAMODIFIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SENSINGAREAMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingAreaModifierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISoundAreaEntityData {
    pub _glacier_base: AIParameterWithShapeEntityData,
}

pub trait AISoundAreaEntityDataTrait: AIParameterWithShapeEntityDataTrait {
}

impl AISoundAreaEntityDataTrait for AISoundAreaEntityData {
}

impl AIParameterWithShapeEntityDataTrait for AISoundAreaEntityData {
    fn ignore_rotation(&self) -> &bool {
        self._glacier_base.ignore_rotation()
    }
    fn ignore_rotation_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_rotation_mut()
    }
}

impl AIParameterEntityDataTrait for AISoundAreaEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AISoundAreaEntityData {
}

impl super::entity::GameObjectDataTrait for AISoundAreaEntityData {
}

impl super::core::DataBusPeerTrait for AISoundAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AISoundAreaEntityData {
}

impl super::core::DataContainerTrait for AISoundAreaEntityData {
}

pub static AISOUNDAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISoundAreaEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AISOUNDAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISoundAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AISOUNDAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISOUNDAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoundAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AICombatGroupEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub auto_alert_on_activate: bool,
    pub scripted_alert_location: super::core::LinearTransform,
    pub share_targeting_info: bool,
    pub can_drop_alerted_state: bool,
    pub can_drop_alerted_state_with_alive_enemies: bool,
    pub use_alertness_temperature_settings: bool,
    pub combat_propagation: Option<Arc<Mutex<dyn CombatPropagationSettingsTrait>>>,
    pub cover_movement_settings: Option<Arc<Mutex<dyn CombatCoverMovementSettingsTrait>>>,
}

pub trait AICombatGroupEntityDataTrait: AIParameterEntityDataTrait {
    fn auto_alert_on_activate(&self) -> &bool;
    fn auto_alert_on_activate_mut(&mut self) -> &mut bool;
    fn scripted_alert_location(&self) -> &super::core::LinearTransform;
    fn scripted_alert_location_mut(&mut self) -> &mut super::core::LinearTransform;
    fn share_targeting_info(&self) -> &bool;
    fn share_targeting_info_mut(&mut self) -> &mut bool;
    fn can_drop_alerted_state(&self) -> &bool;
    fn can_drop_alerted_state_mut(&mut self) -> &mut bool;
    fn can_drop_alerted_state_with_alive_enemies(&self) -> &bool;
    fn can_drop_alerted_state_with_alive_enemies_mut(&mut self) -> &mut bool;
    fn use_alertness_temperature_settings(&self) -> &bool;
    fn use_alertness_temperature_settings_mut(&mut self) -> &mut bool;
    fn combat_propagation(&self) -> &Option<Arc<Mutex<dyn CombatPropagationSettingsTrait>>>;
    fn combat_propagation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CombatPropagationSettingsTrait>>>;
    fn cover_movement_settings(&self) -> &Option<Arc<Mutex<dyn CombatCoverMovementSettingsTrait>>>;
    fn cover_movement_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CombatCoverMovementSettingsTrait>>>;
}

impl AICombatGroupEntityDataTrait for AICombatGroupEntityData {
    fn auto_alert_on_activate(&self) -> &bool {
        &self.auto_alert_on_activate
    }
    fn auto_alert_on_activate_mut(&mut self) -> &mut bool {
        &mut self.auto_alert_on_activate
    }
    fn scripted_alert_location(&self) -> &super::core::LinearTransform {
        &self.scripted_alert_location
    }
    fn scripted_alert_location_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.scripted_alert_location
    }
    fn share_targeting_info(&self) -> &bool {
        &self.share_targeting_info
    }
    fn share_targeting_info_mut(&mut self) -> &mut bool {
        &mut self.share_targeting_info
    }
    fn can_drop_alerted_state(&self) -> &bool {
        &self.can_drop_alerted_state
    }
    fn can_drop_alerted_state_mut(&mut self) -> &mut bool {
        &mut self.can_drop_alerted_state
    }
    fn can_drop_alerted_state_with_alive_enemies(&self) -> &bool {
        &self.can_drop_alerted_state_with_alive_enemies
    }
    fn can_drop_alerted_state_with_alive_enemies_mut(&mut self) -> &mut bool {
        &mut self.can_drop_alerted_state_with_alive_enemies
    }
    fn use_alertness_temperature_settings(&self) -> &bool {
        &self.use_alertness_temperature_settings
    }
    fn use_alertness_temperature_settings_mut(&mut self) -> &mut bool {
        &mut self.use_alertness_temperature_settings
    }
    fn combat_propagation(&self) -> &Option<Arc<Mutex<dyn CombatPropagationSettingsTrait>>> {
        &self.combat_propagation
    }
    fn combat_propagation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CombatPropagationSettingsTrait>>> {
        &mut self.combat_propagation
    }
    fn cover_movement_settings(&self) -> &Option<Arc<Mutex<dyn CombatCoverMovementSettingsTrait>>> {
        &self.cover_movement_settings
    }
    fn cover_movement_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CombatCoverMovementSettingsTrait>>> {
        &mut self.cover_movement_settings
    }
}

impl AIParameterEntityDataTrait for AICombatGroupEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AICombatGroupEntityData {
}

impl super::entity::GameObjectDataTrait for AICombatGroupEntityData {
}

impl super::core::DataBusPeerTrait for AICombatGroupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AICombatGroupEntityData {
}

impl super::core::DataContainerTrait for AICombatGroupEntityData {
}

pub static AICOMBATGROUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatGroupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AICombatGroupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AutoAlertOnActivate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatGroupEntityData, auto_alert_on_activate),
            },
            FieldInfoData {
                name: "ScriptedAlertLocation",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AICombatGroupEntityData, scripted_alert_location),
            },
            FieldInfoData {
                name: "ShareTargetingInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatGroupEntityData, share_targeting_info),
            },
            FieldInfoData {
                name: "CanDropAlertedState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatGroupEntityData, can_drop_alerted_state),
            },
            FieldInfoData {
                name: "CanDropAlertedStateWithAliveEnemies",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatGroupEntityData, can_drop_alerted_state_with_alive_enemies),
            },
            FieldInfoData {
                name: "UseAlertnessTemperatureSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatGroupEntityData, use_alertness_temperature_settings),
            },
            FieldInfoData {
                name: "CombatPropagation",
                flags: MemberInfoFlags::new(0),
                field_type: "CombatPropagationSettings",
                rust_offset: offset_of!(AICombatGroupEntityData, combat_propagation),
            },
            FieldInfoData {
                name: "CoverMovementSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CombatCoverMovementSettings",
                rust_offset: offset_of!(AICombatGroupEntityData, cover_movement_settings),
            },
        ],
    }),
    array_type: Some(AICOMBATGROUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AICombatGroupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AICOMBATGROUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AICOMBATGROUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatGroupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICombatGroupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CombatCoverMovementSettings {
    pub _glacier_base: super::core::DataContainer,
    pub movement_token_count: u32,
    pub min_token_cooldown: f32,
    pub max_token_cooldown: f32,
    pub soldier_move_global_token_cooldown_increment: f32,
    pub soldier_min_time_in_cover: f32,
}

pub trait CombatCoverMovementSettingsTrait: super::core::DataContainerTrait {
    fn movement_token_count(&self) -> &u32;
    fn movement_token_count_mut(&mut self) -> &mut u32;
    fn min_token_cooldown(&self) -> &f32;
    fn min_token_cooldown_mut(&mut self) -> &mut f32;
    fn max_token_cooldown(&self) -> &f32;
    fn max_token_cooldown_mut(&mut self) -> &mut f32;
    fn soldier_move_global_token_cooldown_increment(&self) -> &f32;
    fn soldier_move_global_token_cooldown_increment_mut(&mut self) -> &mut f32;
    fn soldier_min_time_in_cover(&self) -> &f32;
    fn soldier_min_time_in_cover_mut(&mut self) -> &mut f32;
}

impl CombatCoverMovementSettingsTrait for CombatCoverMovementSettings {
    fn movement_token_count(&self) -> &u32 {
        &self.movement_token_count
    }
    fn movement_token_count_mut(&mut self) -> &mut u32 {
        &mut self.movement_token_count
    }
    fn min_token_cooldown(&self) -> &f32 {
        &self.min_token_cooldown
    }
    fn min_token_cooldown_mut(&mut self) -> &mut f32 {
        &mut self.min_token_cooldown
    }
    fn max_token_cooldown(&self) -> &f32 {
        &self.max_token_cooldown
    }
    fn max_token_cooldown_mut(&mut self) -> &mut f32 {
        &mut self.max_token_cooldown
    }
    fn soldier_move_global_token_cooldown_increment(&self) -> &f32 {
        &self.soldier_move_global_token_cooldown_increment
    }
    fn soldier_move_global_token_cooldown_increment_mut(&mut self) -> &mut f32 {
        &mut self.soldier_move_global_token_cooldown_increment
    }
    fn soldier_min_time_in_cover(&self) -> &f32 {
        &self.soldier_min_time_in_cover
    }
    fn soldier_min_time_in_cover_mut(&mut self) -> &mut f32 {
        &mut self.soldier_min_time_in_cover
    }
}

impl super::core::DataContainerTrait for CombatCoverMovementSettings {
}

pub static COMBATCOVERMOVEMENTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatCoverMovementSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CombatCoverMovementSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MovementTokenCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CombatCoverMovementSettings, movement_token_count),
            },
            FieldInfoData {
                name: "MinTokenCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatCoverMovementSettings, min_token_cooldown),
            },
            FieldInfoData {
                name: "MaxTokenCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatCoverMovementSettings, max_token_cooldown),
            },
            FieldInfoData {
                name: "SoldierMoveGlobalTokenCooldownIncrement",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatCoverMovementSettings, soldier_move_global_token_cooldown_increment),
            },
            FieldInfoData {
                name: "SoldierMinTimeInCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatCoverMovementSettings, soldier_min_time_in_cover),
            },
        ],
    }),
    array_type: Some(COMBATCOVERMOVEMENTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CombatCoverMovementSettings {
    fn type_info(&self) -> &'static TypeInfo {
        COMBATCOVERMOVEMENTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMBATCOVERMOVEMENTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatCoverMovementSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CombatCoverMovementSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CombatPropagationSettings {
    pub _glacier_base: super::core::DataContainer,
    pub default_sound: AISound,
    pub interpolated_sound: AISound,
    pub interpolation_start_time: f32,
    pub interpolation_time: f32,
}

pub trait CombatPropagationSettingsTrait: super::core::DataContainerTrait {
    fn default_sound(&self) -> &AISound;
    fn default_sound_mut(&mut self) -> &mut AISound;
    fn interpolated_sound(&self) -> &AISound;
    fn interpolated_sound_mut(&mut self) -> &mut AISound;
    fn interpolation_start_time(&self) -> &f32;
    fn interpolation_start_time_mut(&mut self) -> &mut f32;
    fn interpolation_time(&self) -> &f32;
    fn interpolation_time_mut(&mut self) -> &mut f32;
}

impl CombatPropagationSettingsTrait for CombatPropagationSettings {
    fn default_sound(&self) -> &AISound {
        &self.default_sound
    }
    fn default_sound_mut(&mut self) -> &mut AISound {
        &mut self.default_sound
    }
    fn interpolated_sound(&self) -> &AISound {
        &self.interpolated_sound
    }
    fn interpolated_sound_mut(&mut self) -> &mut AISound {
        &mut self.interpolated_sound
    }
    fn interpolation_start_time(&self) -> &f32 {
        &self.interpolation_start_time
    }
    fn interpolation_start_time_mut(&mut self) -> &mut f32 {
        &mut self.interpolation_start_time
    }
    fn interpolation_time(&self) -> &f32 {
        &self.interpolation_time
    }
    fn interpolation_time_mut(&mut self) -> &mut f32 {
        &mut self.interpolation_time
    }
}

impl super::core::DataContainerTrait for CombatPropagationSettings {
}

pub static COMBATPROPAGATIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatPropagationSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CombatPropagationSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultSound",
                flags: MemberInfoFlags::new(0),
                field_type: "AISound",
                rust_offset: offset_of!(CombatPropagationSettings, default_sound),
            },
            FieldInfoData {
                name: "InterpolatedSound",
                flags: MemberInfoFlags::new(0),
                field_type: "AISound",
                rust_offset: offset_of!(CombatPropagationSettings, interpolated_sound),
            },
            FieldInfoData {
                name: "InterpolationStartTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatPropagationSettings, interpolation_start_time),
            },
            FieldInfoData {
                name: "InterpolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatPropagationSettings, interpolation_time),
            },
        ],
    }),
    array_type: Some(COMBATPROPAGATIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CombatPropagationSettings {
    fn type_info(&self) -> &'static TypeInfo {
        COMBATPROPAGATIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMBATPROPAGATIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatPropagationSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CombatPropagationSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AITacticEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub tactic: TacticsEnumeration,
}

pub trait AITacticEntityDataTrait: AIParameterEntityDataTrait {
    fn tactic(&self) -> &TacticsEnumeration;
    fn tactic_mut(&mut self) -> &mut TacticsEnumeration;
}

impl AITacticEntityDataTrait for AITacticEntityData {
    fn tactic(&self) -> &TacticsEnumeration {
        &self.tactic
    }
    fn tactic_mut(&mut self) -> &mut TacticsEnumeration {
        &mut self.tactic
    }
}

impl AIParameterEntityDataTrait for AITacticEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AITacticEntityData {
}

impl super::entity::GameObjectDataTrait for AITacticEntityData {
}

impl super::core::DataBusPeerTrait for AITacticEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AITacticEntityData {
}

impl super::core::DataContainerTrait for AITacticEntityData {
}

pub static AITACTICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITacticEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AITacticEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Tactic",
                flags: MemberInfoFlags::new(0),
                field_type: "TacticsEnumeration",
                rust_offset: offset_of!(AITacticEntityData, tactic),
            },
        ],
    }),
    array_type: Some(AITACTICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITacticEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AITACTICENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AITACTICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITacticEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITacticEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIShootAtTargetsEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub shoot_type: AIShootType,
    pub cycle_targets: bool,
    pub random_target_order: bool,
    pub combat_intensity: AICombatIntensity,
    pub disable_on_soldier_engaged: bool,
    pub target_weight_multiplier: f32,
}

pub trait AIShootAtTargetsEntityDataTrait: AIParameterEntityDataTrait {
    fn shoot_type(&self) -> &AIShootType;
    fn shoot_type_mut(&mut self) -> &mut AIShootType;
    fn cycle_targets(&self) -> &bool;
    fn cycle_targets_mut(&mut self) -> &mut bool;
    fn random_target_order(&self) -> &bool;
    fn random_target_order_mut(&mut self) -> &mut bool;
    fn combat_intensity(&self) -> &AICombatIntensity;
    fn combat_intensity_mut(&mut self) -> &mut AICombatIntensity;
    fn disable_on_soldier_engaged(&self) -> &bool;
    fn disable_on_soldier_engaged_mut(&mut self) -> &mut bool;
    fn target_weight_multiplier(&self) -> &f32;
    fn target_weight_multiplier_mut(&mut self) -> &mut f32;
}

impl AIShootAtTargetsEntityDataTrait for AIShootAtTargetsEntityData {
    fn shoot_type(&self) -> &AIShootType {
        &self.shoot_type
    }
    fn shoot_type_mut(&mut self) -> &mut AIShootType {
        &mut self.shoot_type
    }
    fn cycle_targets(&self) -> &bool {
        &self.cycle_targets
    }
    fn cycle_targets_mut(&mut self) -> &mut bool {
        &mut self.cycle_targets
    }
    fn random_target_order(&self) -> &bool {
        &self.random_target_order
    }
    fn random_target_order_mut(&mut self) -> &mut bool {
        &mut self.random_target_order
    }
    fn combat_intensity(&self) -> &AICombatIntensity {
        &self.combat_intensity
    }
    fn combat_intensity_mut(&mut self) -> &mut AICombatIntensity {
        &mut self.combat_intensity
    }
    fn disable_on_soldier_engaged(&self) -> &bool {
        &self.disable_on_soldier_engaged
    }
    fn disable_on_soldier_engaged_mut(&mut self) -> &mut bool {
        &mut self.disable_on_soldier_engaged
    }
    fn target_weight_multiplier(&self) -> &f32 {
        &self.target_weight_multiplier
    }
    fn target_weight_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.target_weight_multiplier
    }
}

impl AIParameterEntityDataTrait for AIShootAtTargetsEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIShootAtTargetsEntityData {
}

impl super::entity::GameObjectDataTrait for AIShootAtTargetsEntityData {
}

impl super::core::DataBusPeerTrait for AIShootAtTargetsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIShootAtTargetsEntityData {
}

impl super::core::DataContainerTrait for AIShootAtTargetsEntityData {
}

pub static AISHOOTATTARGETSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIShootAtTargetsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIShootAtTargetsEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ShootType",
                flags: MemberInfoFlags::new(0),
                field_type: "AIShootType",
                rust_offset: offset_of!(AIShootAtTargetsEntityData, shoot_type),
            },
            FieldInfoData {
                name: "CycleTargets",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIShootAtTargetsEntityData, cycle_targets),
            },
            FieldInfoData {
                name: "RandomTargetOrder",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIShootAtTargetsEntityData, random_target_order),
            },
            FieldInfoData {
                name: "CombatIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "AICombatIntensity",
                rust_offset: offset_of!(AIShootAtTargetsEntityData, combat_intensity),
            },
            FieldInfoData {
                name: "DisableOnSoldierEngaged",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIShootAtTargetsEntityData, disable_on_soldier_engaged),
            },
            FieldInfoData {
                name: "TargetWeightMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIShootAtTargetsEntityData, target_weight_multiplier),
            },
        ],
    }),
    array_type: Some(AISHOOTATTARGETSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIShootAtTargetsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AISHOOTATTARGETSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISHOOTATTARGETSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIShootAtTargetsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIShootAtTargetsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIPointTargetData {
    pub _glacier_base: super::entity::SpatialEntityData,
}

pub trait AIPointTargetDataTrait: super::entity::SpatialEntityDataTrait {
}

impl AIPointTargetDataTrait for AIPointTargetData {
}

impl super::entity::SpatialEntityDataTrait for AIPointTargetData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for AIPointTargetData {
}

impl super::entity::GameObjectDataTrait for AIPointTargetData {
}

impl super::core::DataBusPeerTrait for AIPointTargetData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIPointTargetData {
}

impl super::core::DataContainerTrait for AIPointTargetData {
}

pub static AIPOINTTARGETDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPointTargetData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIPointTargetData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AIPOINTTARGETDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIPointTargetData {
    fn type_info(&self) -> &'static TypeInfo {
        AIPOINTTARGETDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIPOINTTARGETDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPointTargetData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPointTargetData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIUseWaypointsEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub waypoint_transform: super::core::LinearTransform,
    pub type_of_route: super::pathfinding_shared::RouteType,
    pub start_at_geometrically_closest_waypoint: bool,
    pub path_finding: super::pathfinding_shared::PathfindingChoice,
    pub pathlink_usage_type: AIPathlinkUsageType,
    pub priority: ExecutionPriority,
    pub tactic_condition: TacticsEnumeration,
    pub allow_a_i_control_after_destination_reached: bool,
    pub use_physics_driven_locomotion: bool,
}

pub trait AIUseWaypointsEntityDataTrait: AIParameterEntityDataTrait {
    fn waypoint_transform(&self) -> &super::core::LinearTransform;
    fn waypoint_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn type_of_route(&self) -> &super::pathfinding_shared::RouteType;
    fn type_of_route_mut(&mut self) -> &mut super::pathfinding_shared::RouteType;
    fn start_at_geometrically_closest_waypoint(&self) -> &bool;
    fn start_at_geometrically_closest_waypoint_mut(&mut self) -> &mut bool;
    fn path_finding(&self) -> &super::pathfinding_shared::PathfindingChoice;
    fn path_finding_mut(&mut self) -> &mut super::pathfinding_shared::PathfindingChoice;
    fn pathlink_usage_type(&self) -> &AIPathlinkUsageType;
    fn pathlink_usage_type_mut(&mut self) -> &mut AIPathlinkUsageType;
    fn priority(&self) -> &ExecutionPriority;
    fn priority_mut(&mut self) -> &mut ExecutionPriority;
    fn tactic_condition(&self) -> &TacticsEnumeration;
    fn tactic_condition_mut(&mut self) -> &mut TacticsEnumeration;
    fn allow_a_i_control_after_destination_reached(&self) -> &bool;
    fn allow_a_i_control_after_destination_reached_mut(&mut self) -> &mut bool;
    fn use_physics_driven_locomotion(&self) -> &bool;
    fn use_physics_driven_locomotion_mut(&mut self) -> &mut bool;
}

impl AIUseWaypointsEntityDataTrait for AIUseWaypointsEntityData {
    fn waypoint_transform(&self) -> &super::core::LinearTransform {
        &self.waypoint_transform
    }
    fn waypoint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.waypoint_transform
    }
    fn type_of_route(&self) -> &super::pathfinding_shared::RouteType {
        &self.type_of_route
    }
    fn type_of_route_mut(&mut self) -> &mut super::pathfinding_shared::RouteType {
        &mut self.type_of_route
    }
    fn start_at_geometrically_closest_waypoint(&self) -> &bool {
        &self.start_at_geometrically_closest_waypoint
    }
    fn start_at_geometrically_closest_waypoint_mut(&mut self) -> &mut bool {
        &mut self.start_at_geometrically_closest_waypoint
    }
    fn path_finding(&self) -> &super::pathfinding_shared::PathfindingChoice {
        &self.path_finding
    }
    fn path_finding_mut(&mut self) -> &mut super::pathfinding_shared::PathfindingChoice {
        &mut self.path_finding
    }
    fn pathlink_usage_type(&self) -> &AIPathlinkUsageType {
        &self.pathlink_usage_type
    }
    fn pathlink_usage_type_mut(&mut self) -> &mut AIPathlinkUsageType {
        &mut self.pathlink_usage_type
    }
    fn priority(&self) -> &ExecutionPriority {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut ExecutionPriority {
        &mut self.priority
    }
    fn tactic_condition(&self) -> &TacticsEnumeration {
        &self.tactic_condition
    }
    fn tactic_condition_mut(&mut self) -> &mut TacticsEnumeration {
        &mut self.tactic_condition
    }
    fn allow_a_i_control_after_destination_reached(&self) -> &bool {
        &self.allow_a_i_control_after_destination_reached
    }
    fn allow_a_i_control_after_destination_reached_mut(&mut self) -> &mut bool {
        &mut self.allow_a_i_control_after_destination_reached
    }
    fn use_physics_driven_locomotion(&self) -> &bool {
        &self.use_physics_driven_locomotion
    }
    fn use_physics_driven_locomotion_mut(&mut self) -> &mut bool {
        &mut self.use_physics_driven_locomotion
    }
}

impl AIParameterEntityDataTrait for AIUseWaypointsEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIUseWaypointsEntityData {
}

impl super::entity::GameObjectDataTrait for AIUseWaypointsEntityData {
}

impl super::core::DataBusPeerTrait for AIUseWaypointsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIUseWaypointsEntityData {
}

impl super::core::DataContainerTrait for AIUseWaypointsEntityData {
}

pub static AIUSEWAYPOINTSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIUseWaypointsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIUseWaypointsEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WaypointTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AIUseWaypointsEntityData, waypoint_transform),
            },
            FieldInfoData {
                name: "TypeOfRoute",
                flags: MemberInfoFlags::new(0),
                field_type: "RouteType",
                rust_offset: offset_of!(AIUseWaypointsEntityData, type_of_route),
            },
            FieldInfoData {
                name: "StartAtGeometricallyClosestWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIUseWaypointsEntityData, start_at_geometrically_closest_waypoint),
            },
            FieldInfoData {
                name: "PathFinding",
                flags: MemberInfoFlags::new(0),
                field_type: "PathfindingChoice",
                rust_offset: offset_of!(AIUseWaypointsEntityData, path_finding),
            },
            FieldInfoData {
                name: "PathlinkUsageType",
                flags: MemberInfoFlags::new(0),
                field_type: "AIPathlinkUsageType",
                rust_offset: offset_of!(AIUseWaypointsEntityData, pathlink_usage_type),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "ExecutionPriority",
                rust_offset: offset_of!(AIUseWaypointsEntityData, priority),
            },
            FieldInfoData {
                name: "TacticCondition",
                flags: MemberInfoFlags::new(0),
                field_type: "TacticsEnumeration",
                rust_offset: offset_of!(AIUseWaypointsEntityData, tactic_condition),
            },
            FieldInfoData {
                name: "AllowAIControlAfterDestinationReached",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIUseWaypointsEntityData, allow_a_i_control_after_destination_reached),
            },
            FieldInfoData {
                name: "UsePhysicsDrivenLocomotion",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIUseWaypointsEntityData, use_physics_driven_locomotion),
            },
        ],
    }),
    array_type: Some(AIUSEWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIUseWaypointsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIUSEWAYPOINTSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIUSEWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIUseWaypointsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIUseWaypointsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIUseCoverEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub cover_slot_index: i32,
    pub is_scripted_to_cover: bool,
    pub cover_transform: super::core::LinearTransform,
}

pub trait AIUseCoverEntityDataTrait: AIParameterEntityDataTrait {
    fn cover_slot_index(&self) -> &i32;
    fn cover_slot_index_mut(&mut self) -> &mut i32;
    fn is_scripted_to_cover(&self) -> &bool;
    fn is_scripted_to_cover_mut(&mut self) -> &mut bool;
    fn cover_transform(&self) -> &super::core::LinearTransform;
    fn cover_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl AIUseCoverEntityDataTrait for AIUseCoverEntityData {
    fn cover_slot_index(&self) -> &i32 {
        &self.cover_slot_index
    }
    fn cover_slot_index_mut(&mut self) -> &mut i32 {
        &mut self.cover_slot_index
    }
    fn is_scripted_to_cover(&self) -> &bool {
        &self.is_scripted_to_cover
    }
    fn is_scripted_to_cover_mut(&mut self) -> &mut bool {
        &mut self.is_scripted_to_cover
    }
    fn cover_transform(&self) -> &super::core::LinearTransform {
        &self.cover_transform
    }
    fn cover_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.cover_transform
    }
}

impl AIParameterEntityDataTrait for AIUseCoverEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIUseCoverEntityData {
}

impl super::entity::GameObjectDataTrait for AIUseCoverEntityData {
}

impl super::core::DataBusPeerTrait for AIUseCoverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIUseCoverEntityData {
}

impl super::core::DataContainerTrait for AIUseCoverEntityData {
}

pub static AIUSECOVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIUseCoverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIUseCoverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverSlotIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AIUseCoverEntityData, cover_slot_index),
            },
            FieldInfoData {
                name: "IsScriptedToCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIUseCoverEntityData, is_scripted_to_cover),
            },
            FieldInfoData {
                name: "CoverTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AIUseCoverEntityData, cover_transform),
            },
        ],
    }),
    array_type: Some(AIUSECOVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIUseCoverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIUSECOVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIUSECOVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIUseCoverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIUseCoverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AICoverZonesOverrideEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub cover_zones: Option<Arc<Mutex<dyn CoverZonesTrait>>>,
}

pub trait AICoverZonesOverrideEntityDataTrait: AIParameterEntityDataTrait {
    fn cover_zones(&self) -> &Option<Arc<Mutex<dyn CoverZonesTrait>>>;
    fn cover_zones_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZonesTrait>>>;
}

impl AICoverZonesOverrideEntityDataTrait for AICoverZonesOverrideEntityData {
    fn cover_zones(&self) -> &Option<Arc<Mutex<dyn CoverZonesTrait>>> {
        &self.cover_zones
    }
    fn cover_zones_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZonesTrait>>> {
        &mut self.cover_zones
    }
}

impl AIParameterEntityDataTrait for AICoverZonesOverrideEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AICoverZonesOverrideEntityData {
}

impl super::entity::GameObjectDataTrait for AICoverZonesOverrideEntityData {
}

impl super::core::DataBusPeerTrait for AICoverZonesOverrideEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AICoverZonesOverrideEntityData {
}

impl super::core::DataContainerTrait for AICoverZonesOverrideEntityData {
}

pub static AICOVERZONESOVERRIDEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverZonesOverrideEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AICoverZonesOverrideEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverZones",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverZones",
                rust_offset: offset_of!(AICoverZonesOverrideEntityData, cover_zones),
            },
        ],
    }),
    array_type: Some(AICOVERZONESOVERRIDEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICoverZonesOverrideEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AICOVERZONESOVERRIDEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AICOVERZONESOVERRIDEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverZonesOverrideEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICoverZonesOverrideEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIAwarenessEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub enable_alertness_states: bool,
    pub enable_sounds: bool,
}

pub trait AIAwarenessEntityDataTrait: AIParameterEntityDataTrait {
    fn enable_alertness_states(&self) -> &bool;
    fn enable_alertness_states_mut(&mut self) -> &mut bool;
    fn enable_sounds(&self) -> &bool;
    fn enable_sounds_mut(&mut self) -> &mut bool;
}

impl AIAwarenessEntityDataTrait for AIAwarenessEntityData {
    fn enable_alertness_states(&self) -> &bool {
        &self.enable_alertness_states
    }
    fn enable_alertness_states_mut(&mut self) -> &mut bool {
        &mut self.enable_alertness_states
    }
    fn enable_sounds(&self) -> &bool {
        &self.enable_sounds
    }
    fn enable_sounds_mut(&mut self) -> &mut bool {
        &mut self.enable_sounds
    }
}

impl AIParameterEntityDataTrait for AIAwarenessEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIAwarenessEntityData {
}

impl super::entity::GameObjectDataTrait for AIAwarenessEntityData {
}

impl super::core::DataBusPeerTrait for AIAwarenessEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIAwarenessEntityData {
}

impl super::core::DataContainerTrait for AIAwarenessEntityData {
}

pub static AIAWARENESSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAwarenessEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIAwarenessEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnableAlertnessStates",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIAwarenessEntityData, enable_alertness_states),
            },
            FieldInfoData {
                name: "EnableSounds",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIAwarenessEntityData, enable_sounds),
            },
        ],
    }),
    array_type: Some(AIAWARENESSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIAwarenessEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIAWARENESSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIAWARENESSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAwarenessEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIAwarenessEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIWeaponSlotOverrideEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub weapon_slot: i32,
}

pub trait AIWeaponSlotOverrideEntityDataTrait: AIParameterEntityDataTrait {
    fn weapon_slot(&self) -> &i32;
    fn weapon_slot_mut(&mut self) -> &mut i32;
}

impl AIWeaponSlotOverrideEntityDataTrait for AIWeaponSlotOverrideEntityData {
    fn weapon_slot(&self) -> &i32 {
        &self.weapon_slot
    }
    fn weapon_slot_mut(&mut self) -> &mut i32 {
        &mut self.weapon_slot
    }
}

impl AIParameterEntityDataTrait for AIWeaponSlotOverrideEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIWeaponSlotOverrideEntityData {
}

impl super::entity::GameObjectDataTrait for AIWeaponSlotOverrideEntityData {
}

impl super::core::DataBusPeerTrait for AIWeaponSlotOverrideEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIWeaponSlotOverrideEntityData {
}

impl super::core::DataContainerTrait for AIWeaponSlotOverrideEntityData {
}

pub static AIWEAPONSLOTOVERRIDEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponSlotOverrideEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIWeaponSlotOverrideEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AIWeaponSlotOverrideEntityData, weapon_slot),
            },
        ],
    }),
    array_type: Some(AIWEAPONSLOTOVERRIDEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIWeaponSlotOverrideEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIWEAPONSLOTOVERRIDEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIWEAPONSLOTOVERRIDEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponSlotOverrideEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIWeaponSlotOverrideEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIWeaponOverrideEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub weapon_data: Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>>,
}

pub trait AIWeaponOverrideEntityDataTrait: AIParameterEntityDataTrait {
    fn weapon_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>>;
    fn weapon_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>>;
}

impl AIWeaponOverrideEntityDataTrait for AIWeaponOverrideEntityData {
    fn weapon_data(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>> {
        &self.weapon_data
    }
    fn weapon_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::GameAIWeaponDataTrait>>> {
        &mut self.weapon_data
    }
}

impl AIParameterEntityDataTrait for AIWeaponOverrideEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIWeaponOverrideEntityData {
}

impl super::entity::GameObjectDataTrait for AIWeaponOverrideEntityData {
}

impl super::core::DataBusPeerTrait for AIWeaponOverrideEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIWeaponOverrideEntityData {
}

impl super::core::DataContainerTrait for AIWeaponOverrideEntityData {
}

pub static AIWEAPONOVERRIDEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponOverrideEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIWeaponOverrideEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponData",
                flags: MemberInfoFlags::new(0),
                field_type: "GameAIWeaponData",
                rust_offset: offset_of!(AIWeaponOverrideEntityData, weapon_data),
            },
        ],
    }),
    array_type: Some(AIWEAPONOVERRIDEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIWeaponOverrideEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIWEAPONOVERRIDEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIWEAPONOVERRIDEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponOverrideEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIWeaponOverrideEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIVehicleBehaviorEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub prevent_vehicle_usage: bool,
}

pub trait AIVehicleBehaviorEntityDataTrait: AIParameterEntityDataTrait {
    fn prevent_vehicle_usage(&self) -> &bool;
    fn prevent_vehicle_usage_mut(&mut self) -> &mut bool;
}

impl AIVehicleBehaviorEntityDataTrait for AIVehicleBehaviorEntityData {
    fn prevent_vehicle_usage(&self) -> &bool {
        &self.prevent_vehicle_usage
    }
    fn prevent_vehicle_usage_mut(&mut self) -> &mut bool {
        &mut self.prevent_vehicle_usage
    }
}

impl AIParameterEntityDataTrait for AIVehicleBehaviorEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIVehicleBehaviorEntityData {
}

impl super::entity::GameObjectDataTrait for AIVehicleBehaviorEntityData {
}

impl super::core::DataBusPeerTrait for AIVehicleBehaviorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIVehicleBehaviorEntityData {
}

impl super::core::DataContainerTrait for AIVehicleBehaviorEntityData {
}

pub static AIVEHICLEBEHAVIORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleBehaviorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIVehicleBehaviorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PreventVehicleUsage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIVehicleBehaviorEntityData, prevent_vehicle_usage),
            },
        ],
    }),
    array_type: Some(AIVEHICLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIVehicleBehaviorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIVEHICLEBEHAVIORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIVEHICLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleBehaviorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIVehicleBehaviorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AITargetingEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub human_target_preference: f32,
    pub threat_distance_multiplier: f32,
    pub is_target: bool,
}

pub trait AITargetingEntityDataTrait: AIParameterEntityDataTrait {
    fn human_target_preference(&self) -> &f32;
    fn human_target_preference_mut(&mut self) -> &mut f32;
    fn threat_distance_multiplier(&self) -> &f32;
    fn threat_distance_multiplier_mut(&mut self) -> &mut f32;
    fn is_target(&self) -> &bool;
    fn is_target_mut(&mut self) -> &mut bool;
}

impl AITargetingEntityDataTrait for AITargetingEntityData {
    fn human_target_preference(&self) -> &f32 {
        &self.human_target_preference
    }
    fn human_target_preference_mut(&mut self) -> &mut f32 {
        &mut self.human_target_preference
    }
    fn threat_distance_multiplier(&self) -> &f32 {
        &self.threat_distance_multiplier
    }
    fn threat_distance_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.threat_distance_multiplier
    }
    fn is_target(&self) -> &bool {
        &self.is_target
    }
    fn is_target_mut(&mut self) -> &mut bool {
        &mut self.is_target
    }
}

impl AIParameterEntityDataTrait for AITargetingEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AITargetingEntityData {
}

impl super::entity::GameObjectDataTrait for AITargetingEntityData {
}

impl super::core::DataBusPeerTrait for AITargetingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AITargetingEntityData {
}

impl super::core::DataContainerTrait for AITargetingEntityData {
}

pub static AITARGETINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AITargetingEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HumanTargetPreference",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AITargetingEntityData, human_target_preference),
            },
            FieldInfoData {
                name: "ThreatDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AITargetingEntityData, threat_distance_multiplier),
            },
            FieldInfoData {
                name: "IsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITargetingEntityData, is_target),
            },
        ],
    }),
    array_type: Some(AITARGETINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITargetingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AITARGETINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AITARGETINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITargetingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AICombatBehaviorEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub allow_fire: bool,
    pub allow_fire_during_scripted_animations: bool,
    pub allow_detect_players: bool,
    pub is_on_human_squad: bool,
    pub try_advance_even_if_already_in_weapon_range: bool,
    pub allow_targeting_unaware_enemies: bool,
    pub combat_environment: CombatEnvironment,
}

pub trait AICombatBehaviorEntityDataTrait: AIParameterEntityDataTrait {
    fn allow_fire(&self) -> &bool;
    fn allow_fire_mut(&mut self) -> &mut bool;
    fn allow_fire_during_scripted_animations(&self) -> &bool;
    fn allow_fire_during_scripted_animations_mut(&mut self) -> &mut bool;
    fn allow_detect_players(&self) -> &bool;
    fn allow_detect_players_mut(&mut self) -> &mut bool;
    fn is_on_human_squad(&self) -> &bool;
    fn is_on_human_squad_mut(&mut self) -> &mut bool;
    fn try_advance_even_if_already_in_weapon_range(&self) -> &bool;
    fn try_advance_even_if_already_in_weapon_range_mut(&mut self) -> &mut bool;
    fn allow_targeting_unaware_enemies(&self) -> &bool;
    fn allow_targeting_unaware_enemies_mut(&mut self) -> &mut bool;
    fn combat_environment(&self) -> &CombatEnvironment;
    fn combat_environment_mut(&mut self) -> &mut CombatEnvironment;
}

impl AICombatBehaviorEntityDataTrait for AICombatBehaviorEntityData {
    fn allow_fire(&self) -> &bool {
        &self.allow_fire
    }
    fn allow_fire_mut(&mut self) -> &mut bool {
        &mut self.allow_fire
    }
    fn allow_fire_during_scripted_animations(&self) -> &bool {
        &self.allow_fire_during_scripted_animations
    }
    fn allow_fire_during_scripted_animations_mut(&mut self) -> &mut bool {
        &mut self.allow_fire_during_scripted_animations
    }
    fn allow_detect_players(&self) -> &bool {
        &self.allow_detect_players
    }
    fn allow_detect_players_mut(&mut self) -> &mut bool {
        &mut self.allow_detect_players
    }
    fn is_on_human_squad(&self) -> &bool {
        &self.is_on_human_squad
    }
    fn is_on_human_squad_mut(&mut self) -> &mut bool {
        &mut self.is_on_human_squad
    }
    fn try_advance_even_if_already_in_weapon_range(&self) -> &bool {
        &self.try_advance_even_if_already_in_weapon_range
    }
    fn try_advance_even_if_already_in_weapon_range_mut(&mut self) -> &mut bool {
        &mut self.try_advance_even_if_already_in_weapon_range
    }
    fn allow_targeting_unaware_enemies(&self) -> &bool {
        &self.allow_targeting_unaware_enemies
    }
    fn allow_targeting_unaware_enemies_mut(&mut self) -> &mut bool {
        &mut self.allow_targeting_unaware_enemies
    }
    fn combat_environment(&self) -> &CombatEnvironment {
        &self.combat_environment
    }
    fn combat_environment_mut(&mut self) -> &mut CombatEnvironment {
        &mut self.combat_environment
    }
}

impl AIParameterEntityDataTrait for AICombatBehaviorEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AICombatBehaviorEntityData {
}

impl super::entity::GameObjectDataTrait for AICombatBehaviorEntityData {
}

impl super::core::DataBusPeerTrait for AICombatBehaviorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AICombatBehaviorEntityData {
}

impl super::core::DataContainerTrait for AICombatBehaviorEntityData {
}

pub static AICOMBATBEHAVIORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatBehaviorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AICombatBehaviorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AllowFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatBehaviorEntityData, allow_fire),
            },
            FieldInfoData {
                name: "AllowFireDuringScriptedAnimations",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatBehaviorEntityData, allow_fire_during_scripted_animations),
            },
            FieldInfoData {
                name: "AllowDetectPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatBehaviorEntityData, allow_detect_players),
            },
            FieldInfoData {
                name: "IsOnHumanSquad",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatBehaviorEntityData, is_on_human_squad),
            },
            FieldInfoData {
                name: "TryAdvanceEvenIfAlreadyInWeaponRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatBehaviorEntityData, try_advance_even_if_already_in_weapon_range),
            },
            FieldInfoData {
                name: "AllowTargetingUnawareEnemies",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICombatBehaviorEntityData, allow_targeting_unaware_enemies),
            },
            FieldInfoData {
                name: "CombatEnvironment",
                flags: MemberInfoFlags::new(0),
                field_type: "CombatEnvironment",
                rust_offset: offset_of!(AICombatBehaviorEntityData, combat_environment),
            },
        ],
    }),
    array_type: Some(AICOMBATBEHAVIORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICombatBehaviorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AICOMBATBEHAVIORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AICOMBATBEHAVIORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatBehaviorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICombatBehaviorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIForbiddenAreaEntityData {
    pub _glacier_base: AIParameterWithShapeEntityData,
}

pub trait AIForbiddenAreaEntityDataTrait: AIParameterWithShapeEntityDataTrait {
}

impl AIForbiddenAreaEntityDataTrait for AIForbiddenAreaEntityData {
}

impl AIParameterWithShapeEntityDataTrait for AIForbiddenAreaEntityData {
    fn ignore_rotation(&self) -> &bool {
        self._glacier_base.ignore_rotation()
    }
    fn ignore_rotation_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_rotation_mut()
    }
}

impl AIParameterEntityDataTrait for AIForbiddenAreaEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIForbiddenAreaEntityData {
}

impl super::entity::GameObjectDataTrait for AIForbiddenAreaEntityData {
}

impl super::core::DataBusPeerTrait for AIForbiddenAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIForbiddenAreaEntityData {
}

impl super::core::DataContainerTrait for AIForbiddenAreaEntityData {
}

pub static AIFORBIDDENAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIForbiddenAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIForbiddenAreaEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AIFORBIDDENAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIForbiddenAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFORBIDDENAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIFORBIDDENAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIForbiddenAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIForbiddenAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFollowAreaEntityData {
    pub _glacier_base: AIParameterWithShapeEntityData,
}

pub trait AIFollowAreaEntityDataTrait: AIParameterWithShapeEntityDataTrait {
}

impl AIFollowAreaEntityDataTrait for AIFollowAreaEntityData {
}

impl AIParameterWithShapeEntityDataTrait for AIFollowAreaEntityData {
    fn ignore_rotation(&self) -> &bool {
        self._glacier_base.ignore_rotation()
    }
    fn ignore_rotation_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_rotation_mut()
    }
}

impl AIParameterEntityDataTrait for AIFollowAreaEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIFollowAreaEntityData {
}

impl super::entity::GameObjectDataTrait for AIFollowAreaEntityData {
}

impl super::core::DataBusPeerTrait for AIFollowAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIFollowAreaEntityData {
}

impl super::core::DataContainerTrait for AIFollowAreaEntityData {
}

pub static AIFOLLOWAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFollowAreaEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AIFOLLOWAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFollowAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFOLLOWAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIFOLLOWAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFriendlyAreaEntityData {
    pub _glacier_base: AIParameterWithShapeEntityData,
}

pub trait AIFriendlyAreaEntityDataTrait: AIParameterWithShapeEntityDataTrait {
}

impl AIFriendlyAreaEntityDataTrait for AIFriendlyAreaEntityData {
}

impl AIParameterWithShapeEntityDataTrait for AIFriendlyAreaEntityData {
    fn ignore_rotation(&self) -> &bool {
        self._glacier_base.ignore_rotation()
    }
    fn ignore_rotation_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_rotation_mut()
    }
}

impl AIParameterEntityDataTrait for AIFriendlyAreaEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIFriendlyAreaEntityData {
}

impl super::entity::GameObjectDataTrait for AIFriendlyAreaEntityData {
}

impl super::core::DataBusPeerTrait for AIFriendlyAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIFriendlyAreaEntityData {
}

impl super::core::DataContainerTrait for AIFriendlyAreaEntityData {
}

pub static AIFRIENDLYAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFriendlyAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFriendlyAreaEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AIFRIENDLYAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFriendlyAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFRIENDLYAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIFRIENDLYAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFriendlyAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFriendlyAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFlankingCorridorEntityData {
    pub _glacier_base: AIParameterWithShapeEntityData,
    pub advance_count: i32,
    pub advance_interval: f32,
    pub human_target_distance: f32,
    pub allow_leaving_flanking_corridor: bool,
}

pub trait AIFlankingCorridorEntityDataTrait: AIParameterWithShapeEntityDataTrait {
    fn advance_count(&self) -> &i32;
    fn advance_count_mut(&mut self) -> &mut i32;
    fn advance_interval(&self) -> &f32;
    fn advance_interval_mut(&mut self) -> &mut f32;
    fn human_target_distance(&self) -> &f32;
    fn human_target_distance_mut(&mut self) -> &mut f32;
    fn allow_leaving_flanking_corridor(&self) -> &bool;
    fn allow_leaving_flanking_corridor_mut(&mut self) -> &mut bool;
}

impl AIFlankingCorridorEntityDataTrait for AIFlankingCorridorEntityData {
    fn advance_count(&self) -> &i32 {
        &self.advance_count
    }
    fn advance_count_mut(&mut self) -> &mut i32 {
        &mut self.advance_count
    }
    fn advance_interval(&self) -> &f32 {
        &self.advance_interval
    }
    fn advance_interval_mut(&mut self) -> &mut f32 {
        &mut self.advance_interval
    }
    fn human_target_distance(&self) -> &f32 {
        &self.human_target_distance
    }
    fn human_target_distance_mut(&mut self) -> &mut f32 {
        &mut self.human_target_distance
    }
    fn allow_leaving_flanking_corridor(&self) -> &bool {
        &self.allow_leaving_flanking_corridor
    }
    fn allow_leaving_flanking_corridor_mut(&mut self) -> &mut bool {
        &mut self.allow_leaving_flanking_corridor
    }
}

impl AIParameterWithShapeEntityDataTrait for AIFlankingCorridorEntityData {
    fn ignore_rotation(&self) -> &bool {
        self._glacier_base.ignore_rotation()
    }
    fn ignore_rotation_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_rotation_mut()
    }
}

impl AIParameterEntityDataTrait for AIFlankingCorridorEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIFlankingCorridorEntityData {
}

impl super::entity::GameObjectDataTrait for AIFlankingCorridorEntityData {
}

impl super::core::DataBusPeerTrait for AIFlankingCorridorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIFlankingCorridorEntityData {
}

impl super::core::DataContainerTrait for AIFlankingCorridorEntityData {
}

pub static AIFLANKINGCORRIDORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFlankingCorridorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFlankingCorridorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AdvanceCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AIFlankingCorridorEntityData, advance_count),
            },
            FieldInfoData {
                name: "AdvanceInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFlankingCorridorEntityData, advance_interval),
            },
            FieldInfoData {
                name: "HumanTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFlankingCorridorEntityData, human_target_distance),
            },
            FieldInfoData {
                name: "AllowLeavingFlankingCorridor",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIFlankingCorridorEntityData, allow_leaving_flanking_corridor),
            },
        ],
    }),
    array_type: Some(AIFLANKINGCORRIDORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFlankingCorridorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFLANKINGCORRIDORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIFLANKINGCORRIDORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFlankingCorridorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFlankingCorridorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISearchAreaEntityData {
    pub _glacier_base: AIParameterWithShapeEntityData,
}

pub trait AISearchAreaEntityDataTrait: AIParameterWithShapeEntityDataTrait {
}

impl AISearchAreaEntityDataTrait for AISearchAreaEntityData {
}

impl AIParameterWithShapeEntityDataTrait for AISearchAreaEntityData {
    fn ignore_rotation(&self) -> &bool {
        self._glacier_base.ignore_rotation()
    }
    fn ignore_rotation_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_rotation_mut()
    }
}

impl AIParameterEntityDataTrait for AISearchAreaEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AISearchAreaEntityData {
}

impl super::entity::GameObjectDataTrait for AISearchAreaEntityData {
}

impl super::core::DataBusPeerTrait for AISearchAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AISearchAreaEntityData {
}

impl super::core::DataContainerTrait for AISearchAreaEntityData {
}

pub static AISEARCHAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISearchAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISearchAreaEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AISEARCHAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISearchAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AISEARCHAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISEARCHAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISearchAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISearchAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIDefendAreaEntityData {
    pub _glacier_base: AIParameterWithShapeEntityData,
    pub follow_object_attract_radius: f32,
}

pub trait AIDefendAreaEntityDataTrait: AIParameterWithShapeEntityDataTrait {
    fn follow_object_attract_radius(&self) -> &f32;
    fn follow_object_attract_radius_mut(&mut self) -> &mut f32;
}

impl AIDefendAreaEntityDataTrait for AIDefendAreaEntityData {
    fn follow_object_attract_radius(&self) -> &f32 {
        &self.follow_object_attract_radius
    }
    fn follow_object_attract_radius_mut(&mut self) -> &mut f32 {
        &mut self.follow_object_attract_radius
    }
}

impl AIParameterWithShapeEntityDataTrait for AIDefendAreaEntityData {
    fn ignore_rotation(&self) -> &bool {
        self._glacier_base.ignore_rotation()
    }
    fn ignore_rotation_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_rotation_mut()
    }
}

impl AIParameterEntityDataTrait for AIDefendAreaEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIDefendAreaEntityData {
}

impl super::entity::GameObjectDataTrait for AIDefendAreaEntityData {
}

impl super::core::DataBusPeerTrait for AIDefendAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIDefendAreaEntityData {
}

impl super::core::DataContainerTrait for AIDefendAreaEntityData {
}

pub static AIDEFENDAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDefendAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIDefendAreaEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FollowObjectAttractRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIDefendAreaEntityData, follow_object_attract_radius),
            },
        ],
    }),
    array_type: Some(AIDEFENDAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIDefendAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIDEFENDAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIDEFENDAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDefendAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIDefendAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AITargetCoordinatorFilterEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub template_filters: Vec<Option<Arc<Mutex<dyn TargetCoordinatorFilterTrait>>>>,
}

pub trait AITargetCoordinatorFilterEntityDataTrait: AIParameterEntityDataTrait {
    fn template_filters(&self) -> &Vec<Option<Arc<Mutex<dyn TargetCoordinatorFilterTrait>>>>;
    fn template_filters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TargetCoordinatorFilterTrait>>>>;
}

impl AITargetCoordinatorFilterEntityDataTrait for AITargetCoordinatorFilterEntityData {
    fn template_filters(&self) -> &Vec<Option<Arc<Mutex<dyn TargetCoordinatorFilterTrait>>>> {
        &self.template_filters
    }
    fn template_filters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn TargetCoordinatorFilterTrait>>>> {
        &mut self.template_filters
    }
}

impl AIParameterEntityDataTrait for AITargetCoordinatorFilterEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AITargetCoordinatorFilterEntityData {
}

impl super::entity::GameObjectDataTrait for AITargetCoordinatorFilterEntityData {
}

impl super::core::DataBusPeerTrait for AITargetCoordinatorFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AITargetCoordinatorFilterEntityData {
}

impl super::core::DataContainerTrait for AITargetCoordinatorFilterEntityData {
}

pub static AITARGETCOORDINATORFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetCoordinatorFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AITargetCoordinatorFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TemplateFilters",
                flags: MemberInfoFlags::new(144),
                field_type: "TargetCoordinatorFilter-Array",
                rust_offset: offset_of!(AITargetCoordinatorFilterEntityData, template_filters),
            },
        ],
    }),
    array_type: Some(AITARGETCOORDINATORFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITargetCoordinatorFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AITARGETCOORDINATORFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AITARGETCOORDINATORFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetCoordinatorFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITargetCoordinatorFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TargetCoordinatorFilter {
    pub _glacier_base: super::core::DataContainer,
    pub template: Option<Arc<Mutex<dyn super::game_shared::CharacterSpawnTemplateDataTrait>>>,
    pub max_attackers: i32,
    pub action_on_filtered: TargetCoordinatorFilterAction,
}

pub trait TargetCoordinatorFilterTrait: super::core::DataContainerTrait {
    fn template(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CharacterSpawnTemplateDataTrait>>>;
    fn template_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CharacterSpawnTemplateDataTrait>>>;
    fn max_attackers(&self) -> &i32;
    fn max_attackers_mut(&mut self) -> &mut i32;
    fn action_on_filtered(&self) -> &TargetCoordinatorFilterAction;
    fn action_on_filtered_mut(&mut self) -> &mut TargetCoordinatorFilterAction;
}

impl TargetCoordinatorFilterTrait for TargetCoordinatorFilter {
    fn template(&self) -> &Option<Arc<Mutex<dyn super::game_shared::CharacterSpawnTemplateDataTrait>>> {
        &self.template
    }
    fn template_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::CharacterSpawnTemplateDataTrait>>> {
        &mut self.template
    }
    fn max_attackers(&self) -> &i32 {
        &self.max_attackers
    }
    fn max_attackers_mut(&mut self) -> &mut i32 {
        &mut self.max_attackers
    }
    fn action_on_filtered(&self) -> &TargetCoordinatorFilterAction {
        &self.action_on_filtered
    }
    fn action_on_filtered_mut(&mut self) -> &mut TargetCoordinatorFilterAction {
        &mut self.action_on_filtered
    }
}

impl super::core::DataContainerTrait for TargetCoordinatorFilter {
}

pub static TARGETCOORDINATORFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinatorFilter",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TargetCoordinatorFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Template",
                flags: MemberInfoFlags::new(0),
                field_type: "CharacterSpawnTemplateData",
                rust_offset: offset_of!(TargetCoordinatorFilter, template),
            },
            FieldInfoData {
                name: "MaxAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(TargetCoordinatorFilter, max_attackers),
            },
            FieldInfoData {
                name: "ActionOnFiltered",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetCoordinatorFilterAction",
                rust_offset: offset_of!(TargetCoordinatorFilter, action_on_filtered),
            },
        ],
    }),
    array_type: Some(TARGETCOORDINATORFILTER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TargetCoordinatorFilter {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETCOORDINATORFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TARGETCOORDINATORFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinatorFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetCoordinatorFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TargetCoordinatorFilterAction {
    #[default]
    TargetCoordinatorFilterAction_Miss = 0,
    TargetCoordinatorFilterAction_HoldFire = 1,
    TargetCoordinatorFilterAction_Hide = 2,
}

pub static TARGETCOORDINATORFILTERACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinatorFilterAction",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(TARGETCOORDINATORFILTERACTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TargetCoordinatorFilterAction {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETCOORDINATORFILTERACTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TARGETCOORDINATORFILTERACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinatorFilterAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetCoordinatorFilterAction"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AITargetCoordinatorEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub max_attackers: i32,
    pub max_attackers_deliberate_miss: i32,
    pub attacker_threshold: i32,
    pub use_fov: bool,
    pub use_enhanced_coordination: bool,
    pub attacker_randomness: f32,
    pub refuse_out_of_sight_attackers: bool,
}

pub trait AITargetCoordinatorEntityDataTrait: AIParameterEntityDataTrait {
    fn max_attackers(&self) -> &i32;
    fn max_attackers_mut(&mut self) -> &mut i32;
    fn max_attackers_deliberate_miss(&self) -> &i32;
    fn max_attackers_deliberate_miss_mut(&mut self) -> &mut i32;
    fn attacker_threshold(&self) -> &i32;
    fn attacker_threshold_mut(&mut self) -> &mut i32;
    fn use_fov(&self) -> &bool;
    fn use_fov_mut(&mut self) -> &mut bool;
    fn use_enhanced_coordination(&self) -> &bool;
    fn use_enhanced_coordination_mut(&mut self) -> &mut bool;
    fn attacker_randomness(&self) -> &f32;
    fn attacker_randomness_mut(&mut self) -> &mut f32;
    fn refuse_out_of_sight_attackers(&self) -> &bool;
    fn refuse_out_of_sight_attackers_mut(&mut self) -> &mut bool;
}

impl AITargetCoordinatorEntityDataTrait for AITargetCoordinatorEntityData {
    fn max_attackers(&self) -> &i32 {
        &self.max_attackers
    }
    fn max_attackers_mut(&mut self) -> &mut i32 {
        &mut self.max_attackers
    }
    fn max_attackers_deliberate_miss(&self) -> &i32 {
        &self.max_attackers_deliberate_miss
    }
    fn max_attackers_deliberate_miss_mut(&mut self) -> &mut i32 {
        &mut self.max_attackers_deliberate_miss
    }
    fn attacker_threshold(&self) -> &i32 {
        &self.attacker_threshold
    }
    fn attacker_threshold_mut(&mut self) -> &mut i32 {
        &mut self.attacker_threshold
    }
    fn use_fov(&self) -> &bool {
        &self.use_fov
    }
    fn use_fov_mut(&mut self) -> &mut bool {
        &mut self.use_fov
    }
    fn use_enhanced_coordination(&self) -> &bool {
        &self.use_enhanced_coordination
    }
    fn use_enhanced_coordination_mut(&mut self) -> &mut bool {
        &mut self.use_enhanced_coordination
    }
    fn attacker_randomness(&self) -> &f32 {
        &self.attacker_randomness
    }
    fn attacker_randomness_mut(&mut self) -> &mut f32 {
        &mut self.attacker_randomness
    }
    fn refuse_out_of_sight_attackers(&self) -> &bool {
        &self.refuse_out_of_sight_attackers
    }
    fn refuse_out_of_sight_attackers_mut(&mut self) -> &mut bool {
        &mut self.refuse_out_of_sight_attackers
    }
}

impl AIParameterEntityDataTrait for AITargetCoordinatorEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AITargetCoordinatorEntityData {
}

impl super::entity::GameObjectDataTrait for AITargetCoordinatorEntityData {
}

impl super::core::DataBusPeerTrait for AITargetCoordinatorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AITargetCoordinatorEntityData {
}

impl super::core::DataContainerTrait for AITargetCoordinatorEntityData {
}

pub static AITARGETCOORDINATORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetCoordinatorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AITargetCoordinatorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AITargetCoordinatorEntityData, max_attackers),
            },
            FieldInfoData {
                name: "MaxAttackersDeliberateMiss",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AITargetCoordinatorEntityData, max_attackers_deliberate_miss),
            },
            FieldInfoData {
                name: "AttackerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AITargetCoordinatorEntityData, attacker_threshold),
            },
            FieldInfoData {
                name: "UseFov",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITargetCoordinatorEntityData, use_fov),
            },
            FieldInfoData {
                name: "UseEnhancedCoordination",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITargetCoordinatorEntityData, use_enhanced_coordination),
            },
            FieldInfoData {
                name: "AttackerRandomness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AITargetCoordinatorEntityData, attacker_randomness),
            },
            FieldInfoData {
                name: "RefuseOutOfSightAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITargetCoordinatorEntityData, refuse_out_of_sight_attackers),
            },
        ],
    }),
    array_type: Some(AITARGETCOORDINATORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITargetCoordinatorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AITARGETCOORDINATORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AITARGETCOORDINATORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetCoordinatorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITargetCoordinatorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIStealthEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub enemey_too_close_distance: f32,
    pub extra_buffer_distance_to_resume_stealth: f32,
    pub only_be_stealthy_if_aware_of_enemies: bool,
    pub only_be_stealthy_if_target_not_alerted: bool,
    pub is_invisible_while_stealthy: bool,
}

pub trait AIStealthEntityDataTrait: AIParameterEntityDataTrait {
    fn enemey_too_close_distance(&self) -> &f32;
    fn enemey_too_close_distance_mut(&mut self) -> &mut f32;
    fn extra_buffer_distance_to_resume_stealth(&self) -> &f32;
    fn extra_buffer_distance_to_resume_stealth_mut(&mut self) -> &mut f32;
    fn only_be_stealthy_if_aware_of_enemies(&self) -> &bool;
    fn only_be_stealthy_if_aware_of_enemies_mut(&mut self) -> &mut bool;
    fn only_be_stealthy_if_target_not_alerted(&self) -> &bool;
    fn only_be_stealthy_if_target_not_alerted_mut(&mut self) -> &mut bool;
    fn is_invisible_while_stealthy(&self) -> &bool;
    fn is_invisible_while_stealthy_mut(&mut self) -> &mut bool;
}

impl AIStealthEntityDataTrait for AIStealthEntityData {
    fn enemey_too_close_distance(&self) -> &f32 {
        &self.enemey_too_close_distance
    }
    fn enemey_too_close_distance_mut(&mut self) -> &mut f32 {
        &mut self.enemey_too_close_distance
    }
    fn extra_buffer_distance_to_resume_stealth(&self) -> &f32 {
        &self.extra_buffer_distance_to_resume_stealth
    }
    fn extra_buffer_distance_to_resume_stealth_mut(&mut self) -> &mut f32 {
        &mut self.extra_buffer_distance_to_resume_stealth
    }
    fn only_be_stealthy_if_aware_of_enemies(&self) -> &bool {
        &self.only_be_stealthy_if_aware_of_enemies
    }
    fn only_be_stealthy_if_aware_of_enemies_mut(&mut self) -> &mut bool {
        &mut self.only_be_stealthy_if_aware_of_enemies
    }
    fn only_be_stealthy_if_target_not_alerted(&self) -> &bool {
        &self.only_be_stealthy_if_target_not_alerted
    }
    fn only_be_stealthy_if_target_not_alerted_mut(&mut self) -> &mut bool {
        &mut self.only_be_stealthy_if_target_not_alerted
    }
    fn is_invisible_while_stealthy(&self) -> &bool {
        &self.is_invisible_while_stealthy
    }
    fn is_invisible_while_stealthy_mut(&mut self) -> &mut bool {
        &mut self.is_invisible_while_stealthy
    }
}

impl AIParameterEntityDataTrait for AIStealthEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIStealthEntityData {
}

impl super::entity::GameObjectDataTrait for AIStealthEntityData {
}

impl super::core::DataBusPeerTrait for AIStealthEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIStealthEntityData {
}

impl super::core::DataContainerTrait for AIStealthEntityData {
}

pub static AISTEALTHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStealthEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIStealthEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnemeyTooCloseDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIStealthEntityData, enemey_too_close_distance),
            },
            FieldInfoData {
                name: "ExtraBufferDistanceToResumeStealth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIStealthEntityData, extra_buffer_distance_to_resume_stealth),
            },
            FieldInfoData {
                name: "OnlyBeStealthyIfAwareOfEnemies",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIStealthEntityData, only_be_stealthy_if_aware_of_enemies),
            },
            FieldInfoData {
                name: "OnlyBeStealthyIfTargetNotAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIStealthEntityData, only_be_stealthy_if_target_not_alerted),
            },
            FieldInfoData {
                name: "IsInvisibleWhileStealthy",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIStealthEntityData, is_invisible_while_stealthy),
            },
        ],
    }),
    array_type: Some(AISTEALTHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIStealthEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AISTEALTHENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISTEALTHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStealthEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIStealthEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIBuddyFollowEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub slot_count: u32,
    pub follow_distance: f32,
    pub closest_distance: f32,
    pub start_moving_max_dist_outside_follow_dist: f32,
    pub start_moving_max_dist_from_slot: f32,
    pub reached_slot_distance: f32,
    pub max_slot_assignment_distance_in: f32,
    pub max_slot_assignment_distance_out: f32,
    pub max_slot_assignment_vertical_distance: f32,
    pub preferred_slot_arcs: Vec<BuddyFollowPreferredSlotArc>,
    pub use_velocity_for_forward_direction: bool,
    pub align_slots_with_forward_direction: bool,
    pub forward_direction_smoothing: BuddyFollowDirectionSmoothingData,
    pub slot_scoring_data: BuddyFollowSlotScoringData,
    pub pose_matching_max_distance: f32,
    pub pose_match_min_delay: f32,
    pub pose_match_max_delay: f32,
}

pub trait AIBuddyFollowEntityDataTrait: AIParameterEntityDataTrait {
    fn slot_count(&self) -> &u32;
    fn slot_count_mut(&mut self) -> &mut u32;
    fn follow_distance(&self) -> &f32;
    fn follow_distance_mut(&mut self) -> &mut f32;
    fn closest_distance(&self) -> &f32;
    fn closest_distance_mut(&mut self) -> &mut f32;
    fn start_moving_max_dist_outside_follow_dist(&self) -> &f32;
    fn start_moving_max_dist_outside_follow_dist_mut(&mut self) -> &mut f32;
    fn start_moving_max_dist_from_slot(&self) -> &f32;
    fn start_moving_max_dist_from_slot_mut(&mut self) -> &mut f32;
    fn reached_slot_distance(&self) -> &f32;
    fn reached_slot_distance_mut(&mut self) -> &mut f32;
    fn max_slot_assignment_distance_in(&self) -> &f32;
    fn max_slot_assignment_distance_in_mut(&mut self) -> &mut f32;
    fn max_slot_assignment_distance_out(&self) -> &f32;
    fn max_slot_assignment_distance_out_mut(&mut self) -> &mut f32;
    fn max_slot_assignment_vertical_distance(&self) -> &f32;
    fn max_slot_assignment_vertical_distance_mut(&mut self) -> &mut f32;
    fn preferred_slot_arcs(&self) -> &Vec<BuddyFollowPreferredSlotArc>;
    fn preferred_slot_arcs_mut(&mut self) -> &mut Vec<BuddyFollowPreferredSlotArc>;
    fn use_velocity_for_forward_direction(&self) -> &bool;
    fn use_velocity_for_forward_direction_mut(&mut self) -> &mut bool;
    fn align_slots_with_forward_direction(&self) -> &bool;
    fn align_slots_with_forward_direction_mut(&mut self) -> &mut bool;
    fn forward_direction_smoothing(&self) -> &BuddyFollowDirectionSmoothingData;
    fn forward_direction_smoothing_mut(&mut self) -> &mut BuddyFollowDirectionSmoothingData;
    fn slot_scoring_data(&self) -> &BuddyFollowSlotScoringData;
    fn slot_scoring_data_mut(&mut self) -> &mut BuddyFollowSlotScoringData;
    fn pose_matching_max_distance(&self) -> &f32;
    fn pose_matching_max_distance_mut(&mut self) -> &mut f32;
    fn pose_match_min_delay(&self) -> &f32;
    fn pose_match_min_delay_mut(&mut self) -> &mut f32;
    fn pose_match_max_delay(&self) -> &f32;
    fn pose_match_max_delay_mut(&mut self) -> &mut f32;
}

impl AIBuddyFollowEntityDataTrait for AIBuddyFollowEntityData {
    fn slot_count(&self) -> &u32 {
        &self.slot_count
    }
    fn slot_count_mut(&mut self) -> &mut u32 {
        &mut self.slot_count
    }
    fn follow_distance(&self) -> &f32 {
        &self.follow_distance
    }
    fn follow_distance_mut(&mut self) -> &mut f32 {
        &mut self.follow_distance
    }
    fn closest_distance(&self) -> &f32 {
        &self.closest_distance
    }
    fn closest_distance_mut(&mut self) -> &mut f32 {
        &mut self.closest_distance
    }
    fn start_moving_max_dist_outside_follow_dist(&self) -> &f32 {
        &self.start_moving_max_dist_outside_follow_dist
    }
    fn start_moving_max_dist_outside_follow_dist_mut(&mut self) -> &mut f32 {
        &mut self.start_moving_max_dist_outside_follow_dist
    }
    fn start_moving_max_dist_from_slot(&self) -> &f32 {
        &self.start_moving_max_dist_from_slot
    }
    fn start_moving_max_dist_from_slot_mut(&mut self) -> &mut f32 {
        &mut self.start_moving_max_dist_from_slot
    }
    fn reached_slot_distance(&self) -> &f32 {
        &self.reached_slot_distance
    }
    fn reached_slot_distance_mut(&mut self) -> &mut f32 {
        &mut self.reached_slot_distance
    }
    fn max_slot_assignment_distance_in(&self) -> &f32 {
        &self.max_slot_assignment_distance_in
    }
    fn max_slot_assignment_distance_in_mut(&mut self) -> &mut f32 {
        &mut self.max_slot_assignment_distance_in
    }
    fn max_slot_assignment_distance_out(&self) -> &f32 {
        &self.max_slot_assignment_distance_out
    }
    fn max_slot_assignment_distance_out_mut(&mut self) -> &mut f32 {
        &mut self.max_slot_assignment_distance_out
    }
    fn max_slot_assignment_vertical_distance(&self) -> &f32 {
        &self.max_slot_assignment_vertical_distance
    }
    fn max_slot_assignment_vertical_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_slot_assignment_vertical_distance
    }
    fn preferred_slot_arcs(&self) -> &Vec<BuddyFollowPreferredSlotArc> {
        &self.preferred_slot_arcs
    }
    fn preferred_slot_arcs_mut(&mut self) -> &mut Vec<BuddyFollowPreferredSlotArc> {
        &mut self.preferred_slot_arcs
    }
    fn use_velocity_for_forward_direction(&self) -> &bool {
        &self.use_velocity_for_forward_direction
    }
    fn use_velocity_for_forward_direction_mut(&mut self) -> &mut bool {
        &mut self.use_velocity_for_forward_direction
    }
    fn align_slots_with_forward_direction(&self) -> &bool {
        &self.align_slots_with_forward_direction
    }
    fn align_slots_with_forward_direction_mut(&mut self) -> &mut bool {
        &mut self.align_slots_with_forward_direction
    }
    fn forward_direction_smoothing(&self) -> &BuddyFollowDirectionSmoothingData {
        &self.forward_direction_smoothing
    }
    fn forward_direction_smoothing_mut(&mut self) -> &mut BuddyFollowDirectionSmoothingData {
        &mut self.forward_direction_smoothing
    }
    fn slot_scoring_data(&self) -> &BuddyFollowSlotScoringData {
        &self.slot_scoring_data
    }
    fn slot_scoring_data_mut(&mut self) -> &mut BuddyFollowSlotScoringData {
        &mut self.slot_scoring_data
    }
    fn pose_matching_max_distance(&self) -> &f32 {
        &self.pose_matching_max_distance
    }
    fn pose_matching_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.pose_matching_max_distance
    }
    fn pose_match_min_delay(&self) -> &f32 {
        &self.pose_match_min_delay
    }
    fn pose_match_min_delay_mut(&mut self) -> &mut f32 {
        &mut self.pose_match_min_delay
    }
    fn pose_match_max_delay(&self) -> &f32 {
        &self.pose_match_max_delay
    }
    fn pose_match_max_delay_mut(&mut self) -> &mut f32 {
        &mut self.pose_match_max_delay
    }
}

impl AIParameterEntityDataTrait for AIBuddyFollowEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIBuddyFollowEntityData {
}

impl super::entity::GameObjectDataTrait for AIBuddyFollowEntityData {
}

impl super::core::DataBusPeerTrait for AIBuddyFollowEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIBuddyFollowEntityData {
}

impl super::core::DataContainerTrait for AIBuddyFollowEntityData {
}

pub static AIBUDDYFOLLOWENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBuddyFollowEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIBuddyFollowEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SlotCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, slot_count),
            },
            FieldInfoData {
                name: "FollowDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, follow_distance),
            },
            FieldInfoData {
                name: "ClosestDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, closest_distance),
            },
            FieldInfoData {
                name: "StartMovingMaxDistOutsideFollowDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, start_moving_max_dist_outside_follow_dist),
            },
            FieldInfoData {
                name: "StartMovingMaxDistFromSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, start_moving_max_dist_from_slot),
            },
            FieldInfoData {
                name: "ReachedSlotDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, reached_slot_distance),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentDistanceIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, max_slot_assignment_distance_in),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentDistanceOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, max_slot_assignment_distance_out),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentVerticalDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, max_slot_assignment_vertical_distance),
            },
            FieldInfoData {
                name: "PreferredSlotArcs",
                flags: MemberInfoFlags::new(144),
                field_type: "BuddyFollowPreferredSlotArc-Array",
                rust_offset: offset_of!(AIBuddyFollowEntityData, preferred_slot_arcs),
            },
            FieldInfoData {
                name: "UseVelocityForForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIBuddyFollowEntityData, use_velocity_for_forward_direction),
            },
            FieldInfoData {
                name: "AlignSlotsWithForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIBuddyFollowEntityData, align_slots_with_forward_direction),
            },
            FieldInfoData {
                name: "ForwardDirectionSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "BuddyFollowDirectionSmoothingData",
                rust_offset: offset_of!(AIBuddyFollowEntityData, forward_direction_smoothing),
            },
            FieldInfoData {
                name: "SlotScoringData",
                flags: MemberInfoFlags::new(0),
                field_type: "BuddyFollowSlotScoringData",
                rust_offset: offset_of!(AIBuddyFollowEntityData, slot_scoring_data),
            },
            FieldInfoData {
                name: "PoseMatchingMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, pose_matching_max_distance),
            },
            FieldInfoData {
                name: "PoseMatchMinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, pose_match_min_delay),
            },
            FieldInfoData {
                name: "PoseMatchMaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBuddyFollowEntityData, pose_match_max_delay),
            },
        ],
    }),
    array_type: Some(AIBUDDYFOLLOWENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIBuddyFollowEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIBUDDYFOLLOWENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIBUDDYFOLLOWENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBuddyFollowEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIBuddyFollowEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BuddyFollowDirectionSmoothingData {
    pub linear_speed_to_angular_speed_max: f32,
    pub linear_speed_lower_threshold: f32,
    pub linear_speed_upper_threshold: f32,
    pub move_distance_to_angular_speed_max: f32,
    pub move_distance_lower_threshold: f32,
    pub move_distance_upper_threshold: f32,
}

pub trait BuddyFollowDirectionSmoothingDataTrait: TypeObject {
    fn linear_speed_to_angular_speed_max(&self) -> &f32;
    fn linear_speed_to_angular_speed_max_mut(&mut self) -> &mut f32;
    fn linear_speed_lower_threshold(&self) -> &f32;
    fn linear_speed_lower_threshold_mut(&mut self) -> &mut f32;
    fn linear_speed_upper_threshold(&self) -> &f32;
    fn linear_speed_upper_threshold_mut(&mut self) -> &mut f32;
    fn move_distance_to_angular_speed_max(&self) -> &f32;
    fn move_distance_to_angular_speed_max_mut(&mut self) -> &mut f32;
    fn move_distance_lower_threshold(&self) -> &f32;
    fn move_distance_lower_threshold_mut(&mut self) -> &mut f32;
    fn move_distance_upper_threshold(&self) -> &f32;
    fn move_distance_upper_threshold_mut(&mut self) -> &mut f32;
}

impl BuddyFollowDirectionSmoothingDataTrait for BuddyFollowDirectionSmoothingData {
    fn linear_speed_to_angular_speed_max(&self) -> &f32 {
        &self.linear_speed_to_angular_speed_max
    }
    fn linear_speed_to_angular_speed_max_mut(&mut self) -> &mut f32 {
        &mut self.linear_speed_to_angular_speed_max
    }
    fn linear_speed_lower_threshold(&self) -> &f32 {
        &self.linear_speed_lower_threshold
    }
    fn linear_speed_lower_threshold_mut(&mut self) -> &mut f32 {
        &mut self.linear_speed_lower_threshold
    }
    fn linear_speed_upper_threshold(&self) -> &f32 {
        &self.linear_speed_upper_threshold
    }
    fn linear_speed_upper_threshold_mut(&mut self) -> &mut f32 {
        &mut self.linear_speed_upper_threshold
    }
    fn move_distance_to_angular_speed_max(&self) -> &f32 {
        &self.move_distance_to_angular_speed_max
    }
    fn move_distance_to_angular_speed_max_mut(&mut self) -> &mut f32 {
        &mut self.move_distance_to_angular_speed_max
    }
    fn move_distance_lower_threshold(&self) -> &f32 {
        &self.move_distance_lower_threshold
    }
    fn move_distance_lower_threshold_mut(&mut self) -> &mut f32 {
        &mut self.move_distance_lower_threshold
    }
    fn move_distance_upper_threshold(&self) -> &f32 {
        &self.move_distance_upper_threshold
    }
    fn move_distance_upper_threshold_mut(&mut self) -> &mut f32 {
        &mut self.move_distance_upper_threshold
    }
}

pub static BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowDirectionSmoothingData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BuddyFollowDirectionSmoothingData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LinearSpeedToAngularSpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, linear_speed_to_angular_speed_max),
            },
            FieldInfoData {
                name: "LinearSpeedLowerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, linear_speed_lower_threshold),
            },
            FieldInfoData {
                name: "LinearSpeedUpperThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, linear_speed_upper_threshold),
            },
            FieldInfoData {
                name: "MoveDistanceToAngularSpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, move_distance_to_angular_speed_max),
            },
            FieldInfoData {
                name: "MoveDistanceLowerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, move_distance_lower_threshold),
            },
            FieldInfoData {
                name: "MoveDistanceUpperThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, move_distance_upper_threshold),
            },
        ],
    }),
    array_type: Some(BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BuddyFollowDirectionSmoothingData {
    fn type_info(&self) -> &'static TypeInfo {
        BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowDirectionSmoothingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BuddyFollowDirectionSmoothingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BuddyFollowPreferredSlotArc {
    pub center: f32,
    pub extent: f32,
    pub cost: f32,
}

pub trait BuddyFollowPreferredSlotArcTrait: TypeObject {
    fn center(&self) -> &f32;
    fn center_mut(&mut self) -> &mut f32;
    fn extent(&self) -> &f32;
    fn extent_mut(&mut self) -> &mut f32;
    fn cost(&self) -> &f32;
    fn cost_mut(&mut self) -> &mut f32;
}

impl BuddyFollowPreferredSlotArcTrait for BuddyFollowPreferredSlotArc {
    fn center(&self) -> &f32 {
        &self.center
    }
    fn center_mut(&mut self) -> &mut f32 {
        &mut self.center
    }
    fn extent(&self) -> &f32 {
        &self.extent
    }
    fn extent_mut(&mut self) -> &mut f32 {
        &mut self.extent
    }
    fn cost(&self) -> &f32 {
        &self.cost
    }
    fn cost_mut(&mut self) -> &mut f32 {
        &mut self.cost
    }
}

pub static BUDDYFOLLOWPREFERREDSLOTARC_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowPreferredSlotArc",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BuddyFollowPreferredSlotArc as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowPreferredSlotArc, center),
            },
            FieldInfoData {
                name: "Extent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowPreferredSlotArc, extent),
            },
            FieldInfoData {
                name: "Cost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowPreferredSlotArc, cost),
            },
        ],
    }),
    array_type: Some(BUDDYFOLLOWPREFERREDSLOTARC_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BuddyFollowPreferredSlotArc {
    fn type_info(&self) -> &'static TypeInfo {
        BUDDYFOLLOWPREFERREDSLOTARC_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUDDYFOLLOWPREFERREDSLOTARC_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowPreferredSlotArc-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BuddyFollowPreferredSlotArc"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BuddyFollowSlotScoringData {
    pub slot_distance_max_cost: f32,
    pub future_occluded_cost: f32,
    pub future_colliding_cost: f32,
    pub distance_to_slot_cost_per_meter: f32,
    pub slot_stickyness_cost: f32,
}

pub trait BuddyFollowSlotScoringDataTrait: TypeObject {
    fn slot_distance_max_cost(&self) -> &f32;
    fn slot_distance_max_cost_mut(&mut self) -> &mut f32;
    fn future_occluded_cost(&self) -> &f32;
    fn future_occluded_cost_mut(&mut self) -> &mut f32;
    fn future_colliding_cost(&self) -> &f32;
    fn future_colliding_cost_mut(&mut self) -> &mut f32;
    fn distance_to_slot_cost_per_meter(&self) -> &f32;
    fn distance_to_slot_cost_per_meter_mut(&mut self) -> &mut f32;
    fn slot_stickyness_cost(&self) -> &f32;
    fn slot_stickyness_cost_mut(&mut self) -> &mut f32;
}

impl BuddyFollowSlotScoringDataTrait for BuddyFollowSlotScoringData {
    fn slot_distance_max_cost(&self) -> &f32 {
        &self.slot_distance_max_cost
    }
    fn slot_distance_max_cost_mut(&mut self) -> &mut f32 {
        &mut self.slot_distance_max_cost
    }
    fn future_occluded_cost(&self) -> &f32 {
        &self.future_occluded_cost
    }
    fn future_occluded_cost_mut(&mut self) -> &mut f32 {
        &mut self.future_occluded_cost
    }
    fn future_colliding_cost(&self) -> &f32 {
        &self.future_colliding_cost
    }
    fn future_colliding_cost_mut(&mut self) -> &mut f32 {
        &mut self.future_colliding_cost
    }
    fn distance_to_slot_cost_per_meter(&self) -> &f32 {
        &self.distance_to_slot_cost_per_meter
    }
    fn distance_to_slot_cost_per_meter_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_slot_cost_per_meter
    }
    fn slot_stickyness_cost(&self) -> &f32 {
        &self.slot_stickyness_cost
    }
    fn slot_stickyness_cost_mut(&mut self) -> &mut f32 {
        &mut self.slot_stickyness_cost
    }
}

pub static BUDDYFOLLOWSLOTSCORINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowSlotScoringData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BuddyFollowSlotScoringData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SlotDistanceMaxCost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowSlotScoringData, slot_distance_max_cost),
            },
            FieldInfoData {
                name: "FutureOccludedCost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowSlotScoringData, future_occluded_cost),
            },
            FieldInfoData {
                name: "FutureCollidingCost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowSlotScoringData, future_colliding_cost),
            },
            FieldInfoData {
                name: "DistanceToSlotCostPerMeter",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowSlotScoringData, distance_to_slot_cost_per_meter),
            },
            FieldInfoData {
                name: "SlotStickynessCost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BuddyFollowSlotScoringData, slot_stickyness_cost),
            },
        ],
    }),
    array_type: Some(BUDDYFOLLOWSLOTSCORINGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BuddyFollowSlotScoringData {
    fn type_info(&self) -> &'static TypeInfo {
        BUDDYFOLLOWSLOTSCORINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BUDDYFOLLOWSLOTSCORINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowSlotScoringData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BuddyFollowSlotScoringData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFollowObjectEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub go_to_position: super::core::LinearTransform,
    pub config: Option<Arc<Mutex<dyn AIFollowObjectConfigAssetTrait>>>,
}

pub trait AIFollowObjectEntityDataTrait: AIParameterEntityDataTrait {
    fn go_to_position(&self) -> &super::core::LinearTransform;
    fn go_to_position_mut(&mut self) -> &mut super::core::LinearTransform;
    fn config(&self) -> &Option<Arc<Mutex<dyn AIFollowObjectConfigAssetTrait>>>;
    fn config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIFollowObjectConfigAssetTrait>>>;
}

impl AIFollowObjectEntityDataTrait for AIFollowObjectEntityData {
    fn go_to_position(&self) -> &super::core::LinearTransform {
        &self.go_to_position
    }
    fn go_to_position_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.go_to_position
    }
    fn config(&self) -> &Option<Arc<Mutex<dyn AIFollowObjectConfigAssetTrait>>> {
        &self.config
    }
    fn config_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIFollowObjectConfigAssetTrait>>> {
        &mut self.config
    }
}

impl AIParameterEntityDataTrait for AIFollowObjectEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIFollowObjectEntityData {
}

impl super::entity::GameObjectDataTrait for AIFollowObjectEntityData {
}

impl super::core::DataBusPeerTrait for AIFollowObjectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIFollowObjectEntityData {
}

impl super::core::DataContainerTrait for AIFollowObjectEntityData {
}

pub static AIFOLLOWOBJECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFollowObjectEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GoToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AIFollowObjectEntityData, go_to_position),
            },
            FieldInfoData {
                name: "Config",
                flags: MemberInfoFlags::new(0),
                field_type: "AIFollowObjectConfigAsset",
                rust_offset: offset_of!(AIFollowObjectEntityData, config),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIFollowObjectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFOLLOWOBJECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIFOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFollowObjectConfigAsset {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub slot_config: FollowObjectSlotConfig,
    pub move_params: FollowObjectMoveParams,
    pub sustained_movement_params: FollowObjectSustainedMovementParams,
    pub reticle_avoidance_params: FollowObjectReticleAvoidanceParams,
    pub min_follower_dist_to_check_teleport: f32,
}

pub trait AIFollowObjectConfigAssetTrait: super::core::DataContainerPolicyAssetTrait {
    fn slot_config(&self) -> &FollowObjectSlotConfig;
    fn slot_config_mut(&mut self) -> &mut FollowObjectSlotConfig;
    fn move_params(&self) -> &FollowObjectMoveParams;
    fn move_params_mut(&mut self) -> &mut FollowObjectMoveParams;
    fn sustained_movement_params(&self) -> &FollowObjectSustainedMovementParams;
    fn sustained_movement_params_mut(&mut self) -> &mut FollowObjectSustainedMovementParams;
    fn reticle_avoidance_params(&self) -> &FollowObjectReticleAvoidanceParams;
    fn reticle_avoidance_params_mut(&mut self) -> &mut FollowObjectReticleAvoidanceParams;
    fn min_follower_dist_to_check_teleport(&self) -> &f32;
    fn min_follower_dist_to_check_teleport_mut(&mut self) -> &mut f32;
}

impl AIFollowObjectConfigAssetTrait for AIFollowObjectConfigAsset {
    fn slot_config(&self) -> &FollowObjectSlotConfig {
        &self.slot_config
    }
    fn slot_config_mut(&mut self) -> &mut FollowObjectSlotConfig {
        &mut self.slot_config
    }
    fn move_params(&self) -> &FollowObjectMoveParams {
        &self.move_params
    }
    fn move_params_mut(&mut self) -> &mut FollowObjectMoveParams {
        &mut self.move_params
    }
    fn sustained_movement_params(&self) -> &FollowObjectSustainedMovementParams {
        &self.sustained_movement_params
    }
    fn sustained_movement_params_mut(&mut self) -> &mut FollowObjectSustainedMovementParams {
        &mut self.sustained_movement_params
    }
    fn reticle_avoidance_params(&self) -> &FollowObjectReticleAvoidanceParams {
        &self.reticle_avoidance_params
    }
    fn reticle_avoidance_params_mut(&mut self) -> &mut FollowObjectReticleAvoidanceParams {
        &mut self.reticle_avoidance_params
    }
    fn min_follower_dist_to_check_teleport(&self) -> &f32 {
        &self.min_follower_dist_to_check_teleport
    }
    fn min_follower_dist_to_check_teleport_mut(&mut self) -> &mut f32 {
        &mut self.min_follower_dist_to_check_teleport
    }
}

impl super::core::DataContainerPolicyAssetTrait for AIFollowObjectConfigAsset {
}

impl super::core::AssetTrait for AIFollowObjectConfigAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AIFollowObjectConfigAsset {
}

pub static AIFOLLOWOBJECTCONFIGASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectConfigAsset",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFollowObjectConfigAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SlotConfig",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowObjectSlotConfig",
                rust_offset: offset_of!(AIFollowObjectConfigAsset, slot_config),
            },
            FieldInfoData {
                name: "MoveParams",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowObjectMoveParams",
                rust_offset: offset_of!(AIFollowObjectConfigAsset, move_params),
            },
            FieldInfoData {
                name: "SustainedMovementParams",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowObjectSustainedMovementParams",
                rust_offset: offset_of!(AIFollowObjectConfigAsset, sustained_movement_params),
            },
            FieldInfoData {
                name: "ReticleAvoidanceParams",
                flags: MemberInfoFlags::new(0),
                field_type: "FollowObjectReticleAvoidanceParams",
                rust_offset: offset_of!(AIFollowObjectConfigAsset, reticle_avoidance_params),
            },
            FieldInfoData {
                name: "MinFollowerDistToCheckTeleport",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectConfigAsset, min_follower_dist_to_check_teleport),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTCONFIGASSET_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIFollowObjectConfigAsset {
    fn type_info(&self) -> &'static TypeInfo {
        AIFOLLOWOBJECTCONFIGASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIFOLLOWOBJECTCONFIGASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectConfigAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectConfigAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowObjectReticleAvoidanceParams {
    pub enabled: bool,
    pub max_aim_angle_to_enemy: f32,
    pub min_aim_cos_angle_to_enemy: f32,
    pub max_distance_to_enemy: f32,
    pub max_distance_to_follower: f32,
    pub follower_bounds_expansion: super::core::Vec3,
    pub predict_future_blocking_look_ahead_time: f32,
}

pub trait FollowObjectReticleAvoidanceParamsTrait: TypeObject {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn max_aim_angle_to_enemy(&self) -> &f32;
    fn max_aim_angle_to_enemy_mut(&mut self) -> &mut f32;
    fn min_aim_cos_angle_to_enemy(&self) -> &f32;
    fn min_aim_cos_angle_to_enemy_mut(&mut self) -> &mut f32;
    fn max_distance_to_enemy(&self) -> &f32;
    fn max_distance_to_enemy_mut(&mut self) -> &mut f32;
    fn max_distance_to_follower(&self) -> &f32;
    fn max_distance_to_follower_mut(&mut self) -> &mut f32;
    fn follower_bounds_expansion(&self) -> &super::core::Vec3;
    fn follower_bounds_expansion_mut(&mut self) -> &mut super::core::Vec3;
    fn predict_future_blocking_look_ahead_time(&self) -> &f32;
    fn predict_future_blocking_look_ahead_time_mut(&mut self) -> &mut f32;
}

impl FollowObjectReticleAvoidanceParamsTrait for FollowObjectReticleAvoidanceParams {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn max_aim_angle_to_enemy(&self) -> &f32 {
        &self.max_aim_angle_to_enemy
    }
    fn max_aim_angle_to_enemy_mut(&mut self) -> &mut f32 {
        &mut self.max_aim_angle_to_enemy
    }
    fn min_aim_cos_angle_to_enemy(&self) -> &f32 {
        &self.min_aim_cos_angle_to_enemy
    }
    fn min_aim_cos_angle_to_enemy_mut(&mut self) -> &mut f32 {
        &mut self.min_aim_cos_angle_to_enemy
    }
    fn max_distance_to_enemy(&self) -> &f32 {
        &self.max_distance_to_enemy
    }
    fn max_distance_to_enemy_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_to_enemy
    }
    fn max_distance_to_follower(&self) -> &f32 {
        &self.max_distance_to_follower
    }
    fn max_distance_to_follower_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_to_follower
    }
    fn follower_bounds_expansion(&self) -> &super::core::Vec3 {
        &self.follower_bounds_expansion
    }
    fn follower_bounds_expansion_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.follower_bounds_expansion
    }
    fn predict_future_blocking_look_ahead_time(&self) -> &f32 {
        &self.predict_future_blocking_look_ahead_time
    }
    fn predict_future_blocking_look_ahead_time_mut(&mut self) -> &mut f32 {
        &mut self.predict_future_blocking_look_ahead_time
    }
}

pub static FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectReticleAvoidanceParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowObjectReticleAvoidanceParams as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, enabled),
            },
            FieldInfoData {
                name: "MaxAimAngleToEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, max_aim_angle_to_enemy),
            },
            FieldInfoData {
                name: "MinAimCosAngleToEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, min_aim_cos_angle_to_enemy),
            },
            FieldInfoData {
                name: "MaxDistanceToEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, max_distance_to_enemy),
            },
            FieldInfoData {
                name: "MaxDistanceToFollower",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, max_distance_to_follower),
            },
            FieldInfoData {
                name: "FollowerBoundsExpansion",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, follower_bounds_expansion),
            },
            FieldInfoData {
                name: "PredictFutureBlockingLookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, predict_future_blocking_look_ahead_time),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FollowObjectReticleAvoidanceParams {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectReticleAvoidanceParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectReticleAvoidanceParams"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowObjectSustainedMovementParams {
    pub min_move_speed_sustain: f32,
    pub max_move_speed_release: f32,
    pub min_sustain_time: f32,
    pub min_release_time: f32,
}

pub trait FollowObjectSustainedMovementParamsTrait: TypeObject {
    fn min_move_speed_sustain(&self) -> &f32;
    fn min_move_speed_sustain_mut(&mut self) -> &mut f32;
    fn max_move_speed_release(&self) -> &f32;
    fn max_move_speed_release_mut(&mut self) -> &mut f32;
    fn min_sustain_time(&self) -> &f32;
    fn min_sustain_time_mut(&mut self) -> &mut f32;
    fn min_release_time(&self) -> &f32;
    fn min_release_time_mut(&mut self) -> &mut f32;
}

impl FollowObjectSustainedMovementParamsTrait for FollowObjectSustainedMovementParams {
    fn min_move_speed_sustain(&self) -> &f32 {
        &self.min_move_speed_sustain
    }
    fn min_move_speed_sustain_mut(&mut self) -> &mut f32 {
        &mut self.min_move_speed_sustain
    }
    fn max_move_speed_release(&self) -> &f32 {
        &self.max_move_speed_release
    }
    fn max_move_speed_release_mut(&mut self) -> &mut f32 {
        &mut self.max_move_speed_release
    }
    fn min_sustain_time(&self) -> &f32 {
        &self.min_sustain_time
    }
    fn min_sustain_time_mut(&mut self) -> &mut f32 {
        &mut self.min_sustain_time
    }
    fn min_release_time(&self) -> &f32 {
        &self.min_release_time
    }
    fn min_release_time_mut(&mut self) -> &mut f32 {
        &mut self.min_release_time
    }
}

pub static FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectSustainedMovementParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowObjectSustainedMovementParams as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinMoveSpeedSustain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSustainedMovementParams, min_move_speed_sustain),
            },
            FieldInfoData {
                name: "MaxMoveSpeedRelease",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSustainedMovementParams, max_move_speed_release),
            },
            FieldInfoData {
                name: "MinSustainTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSustainedMovementParams, min_sustain_time),
            },
            FieldInfoData {
                name: "MinReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSustainedMovementParams, min_release_time),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowObjectSustainedMovementParams {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectSustainedMovementParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectSustainedMovementParams"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowObjectMoveParams {
    pub start_moving_max_dist_outside_follow_range: f32,
    pub start_moving_max_dist_from_slot: f32,
    pub start_moving_min_delay: f32,
    pub start_moving_max_delay: f32,
    pub min_time_follow_object_not_moving_for_idle: f32,
    pub reached_slot_distance: f32,
    pub unassigned_max_distance: f32,
    pub unassigned_closest_distance_idle: f32,
    pub unassigned_closest_distance_moving: f32,
    pub force_crouch_max_follow_object_speed: f32,
    pub force_crouch_max_follow_object_distance: f32,
    pub force_crouch_max_target_dist: f32,
    pub force_crouch_max_time_since_target_seen: f32,
    pub target_min_speed_for_run: f32,
}

pub trait FollowObjectMoveParamsTrait: TypeObject {
    fn start_moving_max_dist_outside_follow_range(&self) -> &f32;
    fn start_moving_max_dist_outside_follow_range_mut(&mut self) -> &mut f32;
    fn start_moving_max_dist_from_slot(&self) -> &f32;
    fn start_moving_max_dist_from_slot_mut(&mut self) -> &mut f32;
    fn start_moving_min_delay(&self) -> &f32;
    fn start_moving_min_delay_mut(&mut self) -> &mut f32;
    fn start_moving_max_delay(&self) -> &f32;
    fn start_moving_max_delay_mut(&mut self) -> &mut f32;
    fn min_time_follow_object_not_moving_for_idle(&self) -> &f32;
    fn min_time_follow_object_not_moving_for_idle_mut(&mut self) -> &mut f32;
    fn reached_slot_distance(&self) -> &f32;
    fn reached_slot_distance_mut(&mut self) -> &mut f32;
    fn unassigned_max_distance(&self) -> &f32;
    fn unassigned_max_distance_mut(&mut self) -> &mut f32;
    fn unassigned_closest_distance_idle(&self) -> &f32;
    fn unassigned_closest_distance_idle_mut(&mut self) -> &mut f32;
    fn unassigned_closest_distance_moving(&self) -> &f32;
    fn unassigned_closest_distance_moving_mut(&mut self) -> &mut f32;
    fn force_crouch_max_follow_object_speed(&self) -> &f32;
    fn force_crouch_max_follow_object_speed_mut(&mut self) -> &mut f32;
    fn force_crouch_max_follow_object_distance(&self) -> &f32;
    fn force_crouch_max_follow_object_distance_mut(&mut self) -> &mut f32;
    fn force_crouch_max_target_dist(&self) -> &f32;
    fn force_crouch_max_target_dist_mut(&mut self) -> &mut f32;
    fn force_crouch_max_time_since_target_seen(&self) -> &f32;
    fn force_crouch_max_time_since_target_seen_mut(&mut self) -> &mut f32;
    fn target_min_speed_for_run(&self) -> &f32;
    fn target_min_speed_for_run_mut(&mut self) -> &mut f32;
}

impl FollowObjectMoveParamsTrait for FollowObjectMoveParams {
    fn start_moving_max_dist_outside_follow_range(&self) -> &f32 {
        &self.start_moving_max_dist_outside_follow_range
    }
    fn start_moving_max_dist_outside_follow_range_mut(&mut self) -> &mut f32 {
        &mut self.start_moving_max_dist_outside_follow_range
    }
    fn start_moving_max_dist_from_slot(&self) -> &f32 {
        &self.start_moving_max_dist_from_slot
    }
    fn start_moving_max_dist_from_slot_mut(&mut self) -> &mut f32 {
        &mut self.start_moving_max_dist_from_slot
    }
    fn start_moving_min_delay(&self) -> &f32 {
        &self.start_moving_min_delay
    }
    fn start_moving_min_delay_mut(&mut self) -> &mut f32 {
        &mut self.start_moving_min_delay
    }
    fn start_moving_max_delay(&self) -> &f32 {
        &self.start_moving_max_delay
    }
    fn start_moving_max_delay_mut(&mut self) -> &mut f32 {
        &mut self.start_moving_max_delay
    }
    fn min_time_follow_object_not_moving_for_idle(&self) -> &f32 {
        &self.min_time_follow_object_not_moving_for_idle
    }
    fn min_time_follow_object_not_moving_for_idle_mut(&mut self) -> &mut f32 {
        &mut self.min_time_follow_object_not_moving_for_idle
    }
    fn reached_slot_distance(&self) -> &f32 {
        &self.reached_slot_distance
    }
    fn reached_slot_distance_mut(&mut self) -> &mut f32 {
        &mut self.reached_slot_distance
    }
    fn unassigned_max_distance(&self) -> &f32 {
        &self.unassigned_max_distance
    }
    fn unassigned_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.unassigned_max_distance
    }
    fn unassigned_closest_distance_idle(&self) -> &f32 {
        &self.unassigned_closest_distance_idle
    }
    fn unassigned_closest_distance_idle_mut(&mut self) -> &mut f32 {
        &mut self.unassigned_closest_distance_idle
    }
    fn unassigned_closest_distance_moving(&self) -> &f32 {
        &self.unassigned_closest_distance_moving
    }
    fn unassigned_closest_distance_moving_mut(&mut self) -> &mut f32 {
        &mut self.unassigned_closest_distance_moving
    }
    fn force_crouch_max_follow_object_speed(&self) -> &f32 {
        &self.force_crouch_max_follow_object_speed
    }
    fn force_crouch_max_follow_object_speed_mut(&mut self) -> &mut f32 {
        &mut self.force_crouch_max_follow_object_speed
    }
    fn force_crouch_max_follow_object_distance(&self) -> &f32 {
        &self.force_crouch_max_follow_object_distance
    }
    fn force_crouch_max_follow_object_distance_mut(&mut self) -> &mut f32 {
        &mut self.force_crouch_max_follow_object_distance
    }
    fn force_crouch_max_target_dist(&self) -> &f32 {
        &self.force_crouch_max_target_dist
    }
    fn force_crouch_max_target_dist_mut(&mut self) -> &mut f32 {
        &mut self.force_crouch_max_target_dist
    }
    fn force_crouch_max_time_since_target_seen(&self) -> &f32 {
        &self.force_crouch_max_time_since_target_seen
    }
    fn force_crouch_max_time_since_target_seen_mut(&mut self) -> &mut f32 {
        &mut self.force_crouch_max_time_since_target_seen
    }
    fn target_min_speed_for_run(&self) -> &f32 {
        &self.target_min_speed_for_run
    }
    fn target_min_speed_for_run_mut(&mut self) -> &mut f32 {
        &mut self.target_min_speed_for_run
    }
}

pub static FOLLOWOBJECTMOVEPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectMoveParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowObjectMoveParams as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartMovingMaxDistOutsideFollowRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, start_moving_max_dist_outside_follow_range),
            },
            FieldInfoData {
                name: "StartMovingMaxDistFromSlot",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, start_moving_max_dist_from_slot),
            },
            FieldInfoData {
                name: "StartMovingMinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, start_moving_min_delay),
            },
            FieldInfoData {
                name: "StartMovingMaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, start_moving_max_delay),
            },
            FieldInfoData {
                name: "MinTimeFollowObjectNotMovingForIdle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, min_time_follow_object_not_moving_for_idle),
            },
            FieldInfoData {
                name: "ReachedSlotDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, reached_slot_distance),
            },
            FieldInfoData {
                name: "UnassignedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, unassigned_max_distance),
            },
            FieldInfoData {
                name: "UnassignedClosestDistanceIdle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, unassigned_closest_distance_idle),
            },
            FieldInfoData {
                name: "UnassignedClosestDistanceMoving",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, unassigned_closest_distance_moving),
            },
            FieldInfoData {
                name: "ForceCrouchMaxFollowObjectSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, force_crouch_max_follow_object_speed),
            },
            FieldInfoData {
                name: "ForceCrouchMaxFollowObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, force_crouch_max_follow_object_distance),
            },
            FieldInfoData {
                name: "ForceCrouchMaxTargetDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, force_crouch_max_target_dist),
            },
            FieldInfoData {
                name: "ForceCrouchMaxTimeSinceTargetSeen",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, force_crouch_max_time_since_target_seen),
            },
            FieldInfoData {
                name: "TargetMinSpeedForRun",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectMoveParams, target_min_speed_for_run),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTMOVEPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowObjectMoveParams {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWOBJECTMOVEPARAMS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWOBJECTMOVEPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectMoveParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectMoveParams"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowObjectSlotConfig {
    pub slot_count: u32,
    pub normal_slot_distance: f32,
    pub closest_slot_distance: f32,
    pub max_slot_assignment_distance_in: f32,
    pub max_slot_assignment_distance_out: f32,
    pub max_slot_assignment_vertical_distance: f32,
    pub preferred_slot_arcs: Vec<AIFollowObjectPreferredSlotArc>,
    pub use_velocity_for_forward_direction: bool,
    pub align_slots_with_forward_direction: bool,
    pub forward_direction_smoothing: AIFollowObjectDirectionSmoothingData,
    pub slot_scoring_data: AIFollowObjectSlotScoringData,
    pub forbidden_path_radius_around_target: f32,
    pub forbidden_path_rear_wedge_angle: f32,
    pub forbidden_path_rear_wedge_radius: f32,
    pub no_crossing_penalty_max_angle: f32,
    pub slot_switching_delay_normal: f32,
    pub slot_switching_delay_critical: f32,
    pub slot_extrapolate_target_speed_factor: f32,
    pub slot_extrapolate_min_dist: f32,
    pub slot_extrapolate_max_dist: f32,
}

pub trait FollowObjectSlotConfigTrait: TypeObject {
    fn slot_count(&self) -> &u32;
    fn slot_count_mut(&mut self) -> &mut u32;
    fn normal_slot_distance(&self) -> &f32;
    fn normal_slot_distance_mut(&mut self) -> &mut f32;
    fn closest_slot_distance(&self) -> &f32;
    fn closest_slot_distance_mut(&mut self) -> &mut f32;
    fn max_slot_assignment_distance_in(&self) -> &f32;
    fn max_slot_assignment_distance_in_mut(&mut self) -> &mut f32;
    fn max_slot_assignment_distance_out(&self) -> &f32;
    fn max_slot_assignment_distance_out_mut(&mut self) -> &mut f32;
    fn max_slot_assignment_vertical_distance(&self) -> &f32;
    fn max_slot_assignment_vertical_distance_mut(&mut self) -> &mut f32;
    fn preferred_slot_arcs(&self) -> &Vec<AIFollowObjectPreferredSlotArc>;
    fn preferred_slot_arcs_mut(&mut self) -> &mut Vec<AIFollowObjectPreferredSlotArc>;
    fn use_velocity_for_forward_direction(&self) -> &bool;
    fn use_velocity_for_forward_direction_mut(&mut self) -> &mut bool;
    fn align_slots_with_forward_direction(&self) -> &bool;
    fn align_slots_with_forward_direction_mut(&mut self) -> &mut bool;
    fn forward_direction_smoothing(&self) -> &AIFollowObjectDirectionSmoothingData;
    fn forward_direction_smoothing_mut(&mut self) -> &mut AIFollowObjectDirectionSmoothingData;
    fn slot_scoring_data(&self) -> &AIFollowObjectSlotScoringData;
    fn slot_scoring_data_mut(&mut self) -> &mut AIFollowObjectSlotScoringData;
    fn forbidden_path_radius_around_target(&self) -> &f32;
    fn forbidden_path_radius_around_target_mut(&mut self) -> &mut f32;
    fn forbidden_path_rear_wedge_angle(&self) -> &f32;
    fn forbidden_path_rear_wedge_angle_mut(&mut self) -> &mut f32;
    fn forbidden_path_rear_wedge_radius(&self) -> &f32;
    fn forbidden_path_rear_wedge_radius_mut(&mut self) -> &mut f32;
    fn no_crossing_penalty_max_angle(&self) -> &f32;
    fn no_crossing_penalty_max_angle_mut(&mut self) -> &mut f32;
    fn slot_switching_delay_normal(&self) -> &f32;
    fn slot_switching_delay_normal_mut(&mut self) -> &mut f32;
    fn slot_switching_delay_critical(&self) -> &f32;
    fn slot_switching_delay_critical_mut(&mut self) -> &mut f32;
    fn slot_extrapolate_target_speed_factor(&self) -> &f32;
    fn slot_extrapolate_target_speed_factor_mut(&mut self) -> &mut f32;
    fn slot_extrapolate_min_dist(&self) -> &f32;
    fn slot_extrapolate_min_dist_mut(&mut self) -> &mut f32;
    fn slot_extrapolate_max_dist(&self) -> &f32;
    fn slot_extrapolate_max_dist_mut(&mut self) -> &mut f32;
}

impl FollowObjectSlotConfigTrait for FollowObjectSlotConfig {
    fn slot_count(&self) -> &u32 {
        &self.slot_count
    }
    fn slot_count_mut(&mut self) -> &mut u32 {
        &mut self.slot_count
    }
    fn normal_slot_distance(&self) -> &f32 {
        &self.normal_slot_distance
    }
    fn normal_slot_distance_mut(&mut self) -> &mut f32 {
        &mut self.normal_slot_distance
    }
    fn closest_slot_distance(&self) -> &f32 {
        &self.closest_slot_distance
    }
    fn closest_slot_distance_mut(&mut self) -> &mut f32 {
        &mut self.closest_slot_distance
    }
    fn max_slot_assignment_distance_in(&self) -> &f32 {
        &self.max_slot_assignment_distance_in
    }
    fn max_slot_assignment_distance_in_mut(&mut self) -> &mut f32 {
        &mut self.max_slot_assignment_distance_in
    }
    fn max_slot_assignment_distance_out(&self) -> &f32 {
        &self.max_slot_assignment_distance_out
    }
    fn max_slot_assignment_distance_out_mut(&mut self) -> &mut f32 {
        &mut self.max_slot_assignment_distance_out
    }
    fn max_slot_assignment_vertical_distance(&self) -> &f32 {
        &self.max_slot_assignment_vertical_distance
    }
    fn max_slot_assignment_vertical_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_slot_assignment_vertical_distance
    }
    fn preferred_slot_arcs(&self) -> &Vec<AIFollowObjectPreferredSlotArc> {
        &self.preferred_slot_arcs
    }
    fn preferred_slot_arcs_mut(&mut self) -> &mut Vec<AIFollowObjectPreferredSlotArc> {
        &mut self.preferred_slot_arcs
    }
    fn use_velocity_for_forward_direction(&self) -> &bool {
        &self.use_velocity_for_forward_direction
    }
    fn use_velocity_for_forward_direction_mut(&mut self) -> &mut bool {
        &mut self.use_velocity_for_forward_direction
    }
    fn align_slots_with_forward_direction(&self) -> &bool {
        &self.align_slots_with_forward_direction
    }
    fn align_slots_with_forward_direction_mut(&mut self) -> &mut bool {
        &mut self.align_slots_with_forward_direction
    }
    fn forward_direction_smoothing(&self) -> &AIFollowObjectDirectionSmoothingData {
        &self.forward_direction_smoothing
    }
    fn forward_direction_smoothing_mut(&mut self) -> &mut AIFollowObjectDirectionSmoothingData {
        &mut self.forward_direction_smoothing
    }
    fn slot_scoring_data(&self) -> &AIFollowObjectSlotScoringData {
        &self.slot_scoring_data
    }
    fn slot_scoring_data_mut(&mut self) -> &mut AIFollowObjectSlotScoringData {
        &mut self.slot_scoring_data
    }
    fn forbidden_path_radius_around_target(&self) -> &f32 {
        &self.forbidden_path_radius_around_target
    }
    fn forbidden_path_radius_around_target_mut(&mut self) -> &mut f32 {
        &mut self.forbidden_path_radius_around_target
    }
    fn forbidden_path_rear_wedge_angle(&self) -> &f32 {
        &self.forbidden_path_rear_wedge_angle
    }
    fn forbidden_path_rear_wedge_angle_mut(&mut self) -> &mut f32 {
        &mut self.forbidden_path_rear_wedge_angle
    }
    fn forbidden_path_rear_wedge_radius(&self) -> &f32 {
        &self.forbidden_path_rear_wedge_radius
    }
    fn forbidden_path_rear_wedge_radius_mut(&mut self) -> &mut f32 {
        &mut self.forbidden_path_rear_wedge_radius
    }
    fn no_crossing_penalty_max_angle(&self) -> &f32 {
        &self.no_crossing_penalty_max_angle
    }
    fn no_crossing_penalty_max_angle_mut(&mut self) -> &mut f32 {
        &mut self.no_crossing_penalty_max_angle
    }
    fn slot_switching_delay_normal(&self) -> &f32 {
        &self.slot_switching_delay_normal
    }
    fn slot_switching_delay_normal_mut(&mut self) -> &mut f32 {
        &mut self.slot_switching_delay_normal
    }
    fn slot_switching_delay_critical(&self) -> &f32 {
        &self.slot_switching_delay_critical
    }
    fn slot_switching_delay_critical_mut(&mut self) -> &mut f32 {
        &mut self.slot_switching_delay_critical
    }
    fn slot_extrapolate_target_speed_factor(&self) -> &f32 {
        &self.slot_extrapolate_target_speed_factor
    }
    fn slot_extrapolate_target_speed_factor_mut(&mut self) -> &mut f32 {
        &mut self.slot_extrapolate_target_speed_factor
    }
    fn slot_extrapolate_min_dist(&self) -> &f32 {
        &self.slot_extrapolate_min_dist
    }
    fn slot_extrapolate_min_dist_mut(&mut self) -> &mut f32 {
        &mut self.slot_extrapolate_min_dist
    }
    fn slot_extrapolate_max_dist(&self) -> &f32 {
        &self.slot_extrapolate_max_dist
    }
    fn slot_extrapolate_max_dist_mut(&mut self) -> &mut f32 {
        &mut self.slot_extrapolate_max_dist
    }
}

pub static FOLLOWOBJECTSLOTCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectSlotConfig",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowObjectSlotConfig as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SlotCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_count),
            },
            FieldInfoData {
                name: "NormalSlotDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, normal_slot_distance),
            },
            FieldInfoData {
                name: "ClosestSlotDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, closest_slot_distance),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentDistanceIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, max_slot_assignment_distance_in),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentDistanceOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, max_slot_assignment_distance_out),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentVerticalDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, max_slot_assignment_vertical_distance),
            },
            FieldInfoData {
                name: "PreferredSlotArcs",
                flags: MemberInfoFlags::new(144),
                field_type: "AIFollowObjectPreferredSlotArc-Array",
                rust_offset: offset_of!(FollowObjectSlotConfig, preferred_slot_arcs),
            },
            FieldInfoData {
                name: "UseVelocityForForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FollowObjectSlotConfig, use_velocity_for_forward_direction),
            },
            FieldInfoData {
                name: "AlignSlotsWithForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FollowObjectSlotConfig, align_slots_with_forward_direction),
            },
            FieldInfoData {
                name: "ForwardDirectionSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: "AIFollowObjectDirectionSmoothingData",
                rust_offset: offset_of!(FollowObjectSlotConfig, forward_direction_smoothing),
            },
            FieldInfoData {
                name: "SlotScoringData",
                flags: MemberInfoFlags::new(0),
                field_type: "AIFollowObjectSlotScoringData",
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_scoring_data),
            },
            FieldInfoData {
                name: "ForbiddenPathRadiusAroundTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, forbidden_path_radius_around_target),
            },
            FieldInfoData {
                name: "ForbiddenPathRearWedgeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, forbidden_path_rear_wedge_angle),
            },
            FieldInfoData {
                name: "ForbiddenPathRearWedgeRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, forbidden_path_rear_wedge_radius),
            },
            FieldInfoData {
                name: "NoCrossingPenaltyMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, no_crossing_penalty_max_angle),
            },
            FieldInfoData {
                name: "SlotSwitchingDelayNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_switching_delay_normal),
            },
            FieldInfoData {
                name: "SlotSwitchingDelayCritical",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_switching_delay_critical),
            },
            FieldInfoData {
                name: "SlotExtrapolateTargetSpeedFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_extrapolate_target_speed_factor),
            },
            FieldInfoData {
                name: "SlotExtrapolateMinDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_extrapolate_min_dist),
            },
            FieldInfoData {
                name: "SlotExtrapolateMaxDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_extrapolate_max_dist),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTSLOTCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowObjectSlotConfig {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWOBJECTSLOTCONFIG_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLLOWOBJECTSLOTCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectSlotConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectSlotConfig"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFollowObjectDirectionSmoothingData {
    pub linear_speed_to_angular_speed_max: f32,
    pub linear_speed_lower_threshold: f32,
    pub linear_speed_upper_threshold: f32,
    pub move_distance_to_angular_speed_max: f32,
    pub move_distance_lower_threshold: f32,
    pub move_distance_upper_threshold: f32,
}

pub trait AIFollowObjectDirectionSmoothingDataTrait: TypeObject {
    fn linear_speed_to_angular_speed_max(&self) -> &f32;
    fn linear_speed_to_angular_speed_max_mut(&mut self) -> &mut f32;
    fn linear_speed_lower_threshold(&self) -> &f32;
    fn linear_speed_lower_threshold_mut(&mut self) -> &mut f32;
    fn linear_speed_upper_threshold(&self) -> &f32;
    fn linear_speed_upper_threshold_mut(&mut self) -> &mut f32;
    fn move_distance_to_angular_speed_max(&self) -> &f32;
    fn move_distance_to_angular_speed_max_mut(&mut self) -> &mut f32;
    fn move_distance_lower_threshold(&self) -> &f32;
    fn move_distance_lower_threshold_mut(&mut self) -> &mut f32;
    fn move_distance_upper_threshold(&self) -> &f32;
    fn move_distance_upper_threshold_mut(&mut self) -> &mut f32;
}

impl AIFollowObjectDirectionSmoothingDataTrait for AIFollowObjectDirectionSmoothingData {
    fn linear_speed_to_angular_speed_max(&self) -> &f32 {
        &self.linear_speed_to_angular_speed_max
    }
    fn linear_speed_to_angular_speed_max_mut(&mut self) -> &mut f32 {
        &mut self.linear_speed_to_angular_speed_max
    }
    fn linear_speed_lower_threshold(&self) -> &f32 {
        &self.linear_speed_lower_threshold
    }
    fn linear_speed_lower_threshold_mut(&mut self) -> &mut f32 {
        &mut self.linear_speed_lower_threshold
    }
    fn linear_speed_upper_threshold(&self) -> &f32 {
        &self.linear_speed_upper_threshold
    }
    fn linear_speed_upper_threshold_mut(&mut self) -> &mut f32 {
        &mut self.linear_speed_upper_threshold
    }
    fn move_distance_to_angular_speed_max(&self) -> &f32 {
        &self.move_distance_to_angular_speed_max
    }
    fn move_distance_to_angular_speed_max_mut(&mut self) -> &mut f32 {
        &mut self.move_distance_to_angular_speed_max
    }
    fn move_distance_lower_threshold(&self) -> &f32 {
        &self.move_distance_lower_threshold
    }
    fn move_distance_lower_threshold_mut(&mut self) -> &mut f32 {
        &mut self.move_distance_lower_threshold
    }
    fn move_distance_upper_threshold(&self) -> &f32 {
        &self.move_distance_upper_threshold
    }
    fn move_distance_upper_threshold_mut(&mut self) -> &mut f32 {
        &mut self.move_distance_upper_threshold
    }
}

pub static AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectDirectionSmoothingData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFollowObjectDirectionSmoothingData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LinearSpeedToAngularSpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, linear_speed_to_angular_speed_max),
            },
            FieldInfoData {
                name: "LinearSpeedLowerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, linear_speed_lower_threshold),
            },
            FieldInfoData {
                name: "LinearSpeedUpperThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, linear_speed_upper_threshold),
            },
            FieldInfoData {
                name: "MoveDistanceToAngularSpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, move_distance_to_angular_speed_max),
            },
            FieldInfoData {
                name: "MoveDistanceLowerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, move_distance_lower_threshold),
            },
            FieldInfoData {
                name: "MoveDistanceUpperThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, move_distance_upper_threshold),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIFollowObjectDirectionSmoothingData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectDirectionSmoothingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectDirectionSmoothingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFollowObjectPreferredSlotArc {
    pub center: f32,
    pub extent: f32,
    pub cost: f32,
}

pub trait AIFollowObjectPreferredSlotArcTrait: TypeObject {
    fn center(&self) -> &f32;
    fn center_mut(&mut self) -> &mut f32;
    fn extent(&self) -> &f32;
    fn extent_mut(&mut self) -> &mut f32;
    fn cost(&self) -> &f32;
    fn cost_mut(&mut self) -> &mut f32;
}

impl AIFollowObjectPreferredSlotArcTrait for AIFollowObjectPreferredSlotArc {
    fn center(&self) -> &f32 {
        &self.center
    }
    fn center_mut(&mut self) -> &mut f32 {
        &mut self.center
    }
    fn extent(&self) -> &f32 {
        &self.extent
    }
    fn extent_mut(&mut self) -> &mut f32 {
        &mut self.extent
    }
    fn cost(&self) -> &f32 {
        &self.cost
    }
    fn cost_mut(&mut self) -> &mut f32 {
        &mut self.cost
    }
}

pub static AIFOLLOWOBJECTPREFERREDSLOTARC_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectPreferredSlotArc",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFollowObjectPreferredSlotArc as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectPreferredSlotArc, center),
            },
            FieldInfoData {
                name: "Extent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectPreferredSlotArc, extent),
            },
            FieldInfoData {
                name: "Cost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectPreferredSlotArc, cost),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTPREFERREDSLOTARC_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIFollowObjectPreferredSlotArc {
    fn type_info(&self) -> &'static TypeInfo {
        AIFOLLOWOBJECTPREFERREDSLOTARC_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIFOLLOWOBJECTPREFERREDSLOTARC_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectPreferredSlotArc-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectPreferredSlotArc"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFollowObjectSlotScoringData {
    pub slot_distance_adjust_cost_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub future_occluded_cost: f32,
    pub future_colliding_cost: f32,
    pub path_dist_to_slot_cost_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub distance_from_assigned_slot_cost_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub cross_front_of_target_cost: f32,
    pub cross_behind_target_cost: f32,
}

pub trait AIFollowObjectSlotScoringDataTrait: TypeObject {
    fn slot_distance_adjust_cost_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn slot_distance_adjust_cost_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn future_occluded_cost(&self) -> &f32;
    fn future_occluded_cost_mut(&mut self) -> &mut f32;
    fn future_colliding_cost(&self) -> &f32;
    fn future_colliding_cost_mut(&mut self) -> &mut f32;
    fn path_dist_to_slot_cost_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn path_dist_to_slot_cost_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn distance_from_assigned_slot_cost_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn distance_from_assigned_slot_cost_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn cross_front_of_target_cost(&self) -> &f32;
    fn cross_front_of_target_cost_mut(&mut self) -> &mut f32;
    fn cross_behind_target_cost(&self) -> &f32;
    fn cross_behind_target_cost_mut(&mut self) -> &mut f32;
}

impl AIFollowObjectSlotScoringDataTrait for AIFollowObjectSlotScoringData {
    fn slot_distance_adjust_cost_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.slot_distance_adjust_cost_curve
    }
    fn slot_distance_adjust_cost_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.slot_distance_adjust_cost_curve
    }
    fn future_occluded_cost(&self) -> &f32 {
        &self.future_occluded_cost
    }
    fn future_occluded_cost_mut(&mut self) -> &mut f32 {
        &mut self.future_occluded_cost
    }
    fn future_colliding_cost(&self) -> &f32 {
        &self.future_colliding_cost
    }
    fn future_colliding_cost_mut(&mut self) -> &mut f32 {
        &mut self.future_colliding_cost
    }
    fn path_dist_to_slot_cost_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.path_dist_to_slot_cost_curve
    }
    fn path_dist_to_slot_cost_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.path_dist_to_slot_cost_curve
    }
    fn distance_from_assigned_slot_cost_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.distance_from_assigned_slot_cost_curve
    }
    fn distance_from_assigned_slot_cost_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.distance_from_assigned_slot_cost_curve
    }
    fn cross_front_of_target_cost(&self) -> &f32 {
        &self.cross_front_of_target_cost
    }
    fn cross_front_of_target_cost_mut(&mut self) -> &mut f32 {
        &mut self.cross_front_of_target_cost
    }
    fn cross_behind_target_cost(&self) -> &f32 {
        &self.cross_behind_target_cost
    }
    fn cross_behind_target_cost_mut(&mut self) -> &mut f32 {
        &mut self.cross_behind_target_cost
    }
}

pub static AIFOLLOWOBJECTSLOTSCORINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectSlotScoringData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFollowObjectSlotScoringData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SlotDistanceAdjustCostCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, slot_distance_adjust_cost_curve),
            },
            FieldInfoData {
                name: "FutureOccludedCost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, future_occluded_cost),
            },
            FieldInfoData {
                name: "FutureCollidingCost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, future_colliding_cost),
            },
            FieldInfoData {
                name: "PathDistToSlotCostCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, path_dist_to_slot_cost_curve),
            },
            FieldInfoData {
                name: "DistanceFromAssignedSlotCostCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, distance_from_assigned_slot_cost_curve),
            },
            FieldInfoData {
                name: "CrossFrontOfTargetCost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, cross_front_of_target_cost),
            },
            FieldInfoData {
                name: "CrossBehindTargetCost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, cross_behind_target_cost),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTSLOTSCORINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFollowObjectSlotScoringData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFOLLOWOBJECTSLOTSCORINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIFOLLOWOBJECTSLOTSCORINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectSlotScoringData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectSlotScoringData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIPreferredAreaEntityData {
    pub _glacier_base: AIParameterWithShapeEntityData,
    pub follow_object_attract_radius: f32,
    pub influence_distance_outside_shape: f32,
    pub use_own_last_position_as_origin: bool,
    pub score: f32,
}

pub trait AIPreferredAreaEntityDataTrait: AIParameterWithShapeEntityDataTrait {
    fn follow_object_attract_radius(&self) -> &f32;
    fn follow_object_attract_radius_mut(&mut self) -> &mut f32;
    fn influence_distance_outside_shape(&self) -> &f32;
    fn influence_distance_outside_shape_mut(&mut self) -> &mut f32;
    fn use_own_last_position_as_origin(&self) -> &bool;
    fn use_own_last_position_as_origin_mut(&mut self) -> &mut bool;
    fn score(&self) -> &f32;
    fn score_mut(&mut self) -> &mut f32;
}

impl AIPreferredAreaEntityDataTrait for AIPreferredAreaEntityData {
    fn follow_object_attract_radius(&self) -> &f32 {
        &self.follow_object_attract_radius
    }
    fn follow_object_attract_radius_mut(&mut self) -> &mut f32 {
        &mut self.follow_object_attract_radius
    }
    fn influence_distance_outside_shape(&self) -> &f32 {
        &self.influence_distance_outside_shape
    }
    fn influence_distance_outside_shape_mut(&mut self) -> &mut f32 {
        &mut self.influence_distance_outside_shape
    }
    fn use_own_last_position_as_origin(&self) -> &bool {
        &self.use_own_last_position_as_origin
    }
    fn use_own_last_position_as_origin_mut(&mut self) -> &mut bool {
        &mut self.use_own_last_position_as_origin
    }
    fn score(&self) -> &f32 {
        &self.score
    }
    fn score_mut(&mut self) -> &mut f32 {
        &mut self.score
    }
}

impl AIParameterWithShapeEntityDataTrait for AIPreferredAreaEntityData {
    fn ignore_rotation(&self) -> &bool {
        self._glacier_base.ignore_rotation()
    }
    fn ignore_rotation_mut(&mut self) -> &mut bool {
        self._glacier_base.ignore_rotation_mut()
    }
}

impl AIParameterEntityDataTrait for AIPreferredAreaEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIPreferredAreaEntityData {
}

impl super::entity::GameObjectDataTrait for AIPreferredAreaEntityData {
}

impl super::core::DataBusPeerTrait for AIPreferredAreaEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIPreferredAreaEntityData {
}

impl super::core::DataContainerTrait for AIPreferredAreaEntityData {
}

pub static AIPREFERREDAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPreferredAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIPreferredAreaEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FollowObjectAttractRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPreferredAreaEntityData, follow_object_attract_radius),
            },
            FieldInfoData {
                name: "InfluenceDistanceOutsideShape",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPreferredAreaEntityData, influence_distance_outside_shape),
            },
            FieldInfoData {
                name: "UseOwnLastPositionAsOrigin",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIPreferredAreaEntityData, use_own_last_position_as_origin),
            },
            FieldInfoData {
                name: "Score",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPreferredAreaEntityData, score),
            },
        ],
    }),
    array_type: Some(AIPREFERREDAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIPreferredAreaEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIPREFERREDAREAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIPREFERREDAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPreferredAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPreferredAreaEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIHearingParameterEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub sensing_shot_fired_distance: f32,
    pub sensing_human_driven_vehicle_distance: f32,
    pub sensing_explosion_distance: f32,
    pub sensing_grenade_distance: f32,
}

pub trait AIHearingParameterEntityDataTrait: AIParameterEntityDataTrait {
    fn sensing_shot_fired_distance(&self) -> &f32;
    fn sensing_shot_fired_distance_mut(&mut self) -> &mut f32;
    fn sensing_human_driven_vehicle_distance(&self) -> &f32;
    fn sensing_human_driven_vehicle_distance_mut(&mut self) -> &mut f32;
    fn sensing_explosion_distance(&self) -> &f32;
    fn sensing_explosion_distance_mut(&mut self) -> &mut f32;
    fn sensing_grenade_distance(&self) -> &f32;
    fn sensing_grenade_distance_mut(&mut self) -> &mut f32;
}

impl AIHearingParameterEntityDataTrait for AIHearingParameterEntityData {
    fn sensing_shot_fired_distance(&self) -> &f32 {
        &self.sensing_shot_fired_distance
    }
    fn sensing_shot_fired_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_shot_fired_distance
    }
    fn sensing_human_driven_vehicle_distance(&self) -> &f32 {
        &self.sensing_human_driven_vehicle_distance
    }
    fn sensing_human_driven_vehicle_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_human_driven_vehicle_distance
    }
    fn sensing_explosion_distance(&self) -> &f32 {
        &self.sensing_explosion_distance
    }
    fn sensing_explosion_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_explosion_distance
    }
    fn sensing_grenade_distance(&self) -> &f32 {
        &self.sensing_grenade_distance
    }
    fn sensing_grenade_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_grenade_distance
    }
}

impl AIParameterEntityDataTrait for AIHearingParameterEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIHearingParameterEntityData {
}

impl super::entity::GameObjectDataTrait for AIHearingParameterEntityData {
}

impl super::core::DataBusPeerTrait for AIHearingParameterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIHearingParameterEntityData {
}

impl super::core::DataContainerTrait for AIHearingParameterEntityData {
}

pub static AIHEARINGPARAMETERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIHearingParameterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIHearingParameterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SensingShotFiredDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIHearingParameterEntityData, sensing_shot_fired_distance),
            },
            FieldInfoData {
                name: "SensingHumanDrivenVehicleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIHearingParameterEntityData, sensing_human_driven_vehicle_distance),
            },
            FieldInfoData {
                name: "SensingExplosionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIHearingParameterEntityData, sensing_explosion_distance),
            },
            FieldInfoData {
                name: "SensingGrenadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIHearingParameterEntityData, sensing_grenade_distance),
            },
        ],
    }),
    array_type: Some(AIHEARINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIHearingParameterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIHEARINGPARAMETERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIHEARINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIHearingParameterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIHearingParameterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISensingParameterEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub include_terrain: bool,
    pub allow_investigations: bool,
}

pub trait AISensingParameterEntityDataTrait: AIParameterEntityDataTrait {
    fn include_terrain(&self) -> &bool;
    fn include_terrain_mut(&mut self) -> &mut bool;
    fn allow_investigations(&self) -> &bool;
    fn allow_investigations_mut(&mut self) -> &mut bool;
}

impl AISensingParameterEntityDataTrait for AISensingParameterEntityData {
    fn include_terrain(&self) -> &bool {
        &self.include_terrain
    }
    fn include_terrain_mut(&mut self) -> &mut bool {
        &mut self.include_terrain
    }
    fn allow_investigations(&self) -> &bool {
        &self.allow_investigations
    }
    fn allow_investigations_mut(&mut self) -> &mut bool {
        &mut self.allow_investigations
    }
}

impl AIParameterEntityDataTrait for AISensingParameterEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AISensingParameterEntityData {
}

impl super::entity::GameObjectDataTrait for AISensingParameterEntityData {
}

impl super::core::DataBusPeerTrait for AISensingParameterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AISensingParameterEntityData {
}

impl super::core::DataContainerTrait for AISensingParameterEntityData {
}

pub static AISENSINGPARAMETERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISensingParameterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISensingParameterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IncludeTerrain",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AISensingParameterEntityData, include_terrain),
            },
            FieldInfoData {
                name: "AllowInvestigations",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AISensingParameterEntityData, allow_investigations),
            },
        ],
    }),
    array_type: Some(AISENSINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISensingParameterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AISENSINGPARAMETERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISENSINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISensingParameterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISensingParameterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIIdleBehaviorEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub idle_readiness: IdleReadiness,
    pub allow_aiming_while_scripted: bool,
    pub aiming_target_distance: f32,
}

pub trait AIIdleBehaviorEntityDataTrait: AIParameterEntityDataTrait {
    fn idle_readiness(&self) -> &IdleReadiness;
    fn idle_readiness_mut(&mut self) -> &mut IdleReadiness;
    fn allow_aiming_while_scripted(&self) -> &bool;
    fn allow_aiming_while_scripted_mut(&mut self) -> &mut bool;
    fn aiming_target_distance(&self) -> &f32;
    fn aiming_target_distance_mut(&mut self) -> &mut f32;
}

impl AIIdleBehaviorEntityDataTrait for AIIdleBehaviorEntityData {
    fn idle_readiness(&self) -> &IdleReadiness {
        &self.idle_readiness
    }
    fn idle_readiness_mut(&mut self) -> &mut IdleReadiness {
        &mut self.idle_readiness
    }
    fn allow_aiming_while_scripted(&self) -> &bool {
        &self.allow_aiming_while_scripted
    }
    fn allow_aiming_while_scripted_mut(&mut self) -> &mut bool {
        &mut self.allow_aiming_while_scripted
    }
    fn aiming_target_distance(&self) -> &f32 {
        &self.aiming_target_distance
    }
    fn aiming_target_distance_mut(&mut self) -> &mut f32 {
        &mut self.aiming_target_distance
    }
}

impl AIParameterEntityDataTrait for AIIdleBehaviorEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIIdleBehaviorEntityData {
}

impl super::entity::GameObjectDataTrait for AIIdleBehaviorEntityData {
}

impl super::core::DataBusPeerTrait for AIIdleBehaviorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIIdleBehaviorEntityData {
}

impl super::core::DataContainerTrait for AIIdleBehaviorEntityData {
}

pub static AIIDLEBEHAVIORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIIdleBehaviorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIIdleBehaviorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IdleReadiness",
                flags: MemberInfoFlags::new(0),
                field_type: "IdleReadiness",
                rust_offset: offset_of!(AIIdleBehaviorEntityData, idle_readiness),
            },
            FieldInfoData {
                name: "AllowAimingWhileScripted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIIdleBehaviorEntityData, allow_aiming_while_scripted),
            },
            FieldInfoData {
                name: "AimingTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIIdleBehaviorEntityData, aiming_target_distance),
            },
        ],
    }),
    array_type: Some(AIIDLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIIdleBehaviorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIIDLEBEHAVIORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIIDLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIIdleBehaviorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIIdleBehaviorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIParameterWithShapeEntityData {
    pub _glacier_base: AIParameterEntityData,
    pub ignore_rotation: bool,
}

pub trait AIParameterWithShapeEntityDataTrait: AIParameterEntityDataTrait {
    fn ignore_rotation(&self) -> &bool;
    fn ignore_rotation_mut(&mut self) -> &mut bool;
}

impl AIParameterWithShapeEntityDataTrait for AIParameterWithShapeEntityData {
    fn ignore_rotation(&self) -> &bool {
        &self.ignore_rotation
    }
    fn ignore_rotation_mut(&mut self) -> &mut bool {
        &mut self.ignore_rotation
    }
}

impl AIParameterEntityDataTrait for AIParameterWithShapeEntityData {
    fn auto_activate(&self) -> &bool {
        self._glacier_base.auto_activate()
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_activate_mut()
    }
}

impl super::entity::EntityDataTrait for AIParameterWithShapeEntityData {
}

impl super::entity::GameObjectDataTrait for AIParameterWithShapeEntityData {
}

impl super::core::DataBusPeerTrait for AIParameterWithShapeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIParameterWithShapeEntityData {
}

impl super::core::DataContainerTrait for AIParameterWithShapeEntityData {
}

pub static AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIParameterWithShapeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIParameterWithShapeEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IgnoreRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIParameterWithShapeEntityData, ignore_rotation),
            },
        ],
    }),
    array_type: Some(AIPARAMETERWITHSHAPEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AIParameterWithShapeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIPARAMETERWITHSHAPEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIParameterWithShapeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIParameterWithShapeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIParameterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub auto_activate: bool,
}

pub trait AIParameterEntityDataTrait: super::entity::EntityDataTrait {
    fn auto_activate(&self) -> &bool;
    fn auto_activate_mut(&mut self) -> &mut bool;
}

impl AIParameterEntityDataTrait for AIParameterEntityData {
    fn auto_activate(&self) -> &bool {
        &self.auto_activate
    }
    fn auto_activate_mut(&mut self) -> &mut bool {
        &mut self.auto_activate
    }
}

impl super::entity::EntityDataTrait for AIParameterEntityData {
}

impl super::entity::GameObjectDataTrait for AIParameterEntityData {
}

impl super::core::DataBusPeerTrait for AIParameterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIParameterEntityData {
}

impl super::core::DataContainerTrait for AIParameterEntityData {
}

pub static AIPARAMETERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIParameterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIParameterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AutoActivate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIParameterEntityData, auto_activate),
            },
        ],
    }),
    array_type: Some(AIPARAMETERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AIParameterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIPARAMETERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIPARAMETERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIParameterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIParameterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AICancelOrderEntityData {
    pub _glacier_base: AIOrderEntityBaseData,
}

pub trait AICancelOrderEntityDataTrait: AIOrderEntityBaseDataTrait {
}

impl AICancelOrderEntityDataTrait for AICancelOrderEntityData {
}

impl AIOrderEntityBaseDataTrait for AICancelOrderEntityData {
}

impl super::entity::EntityDataTrait for AICancelOrderEntityData {
}

impl super::entity::GameObjectDataTrait for AICancelOrderEntityData {
}

impl super::core::DataBusPeerTrait for AICancelOrderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AICancelOrderEntityData {
}

impl super::core::DataContainerTrait for AICancelOrderEntityData {
}

pub static AICANCELORDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICancelOrderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIORDERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AICancelOrderEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AICANCELORDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICancelOrderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AICANCELORDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AICANCELORDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICancelOrderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICancelOrderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIGotoPlaceOrderEntityData {
    pub _glacier_base: AIOrderEntityBaseData,
    pub max_distance: f32,
    pub min_distance: f32,
    pub go_to_position: super::core::LinearTransform,
    pub randomize_destination: bool,
    pub change_of_destination_distance_tolerance: f32,
    pub move_settings_alerted: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
    pub move_settings_not_alerted: Option<Arc<Mutex<dyn MoveSettingsTrait>>>,
}

pub trait AIGotoPlaceOrderEntityDataTrait: AIOrderEntityBaseDataTrait {
    fn max_distance(&self) -> &f32;
    fn max_distance_mut(&mut self) -> &mut f32;
    fn min_distance(&self) -> &f32;
    fn min_distance_mut(&mut self) -> &mut f32;
    fn go_to_position(&self) -> &super::core::LinearTransform;
    fn go_to_position_mut(&mut self) -> &mut super::core::LinearTransform;
    fn randomize_destination(&self) -> &bool;
    fn randomize_destination_mut(&mut self) -> &mut bool;
    fn change_of_destination_distance_tolerance(&self) -> &f32;
    fn change_of_destination_distance_tolerance_mut(&mut self) -> &mut f32;
    fn move_settings_alerted(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_alerted_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_not_alerted(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
    fn move_settings_not_alerted_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>>;
}

impl AIGotoPlaceOrderEntityDataTrait for AIGotoPlaceOrderEntityData {
    fn max_distance(&self) -> &f32 {
        &self.max_distance
    }
    fn max_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_distance
    }
    fn min_distance(&self) -> &f32 {
        &self.min_distance
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_distance
    }
    fn go_to_position(&self) -> &super::core::LinearTransform {
        &self.go_to_position
    }
    fn go_to_position_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.go_to_position
    }
    fn randomize_destination(&self) -> &bool {
        &self.randomize_destination
    }
    fn randomize_destination_mut(&mut self) -> &mut bool {
        &mut self.randomize_destination
    }
    fn change_of_destination_distance_tolerance(&self) -> &f32 {
        &self.change_of_destination_distance_tolerance
    }
    fn change_of_destination_distance_tolerance_mut(&mut self) -> &mut f32 {
        &mut self.change_of_destination_distance_tolerance
    }
    fn move_settings_alerted(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings_alerted
    }
    fn move_settings_alerted_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings_alerted
    }
    fn move_settings_not_alerted(&self) -> &Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &self.move_settings_not_alerted
    }
    fn move_settings_not_alerted_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MoveSettingsTrait>>> {
        &mut self.move_settings_not_alerted
    }
}

impl AIOrderEntityBaseDataTrait for AIGotoPlaceOrderEntityData {
}

impl super::entity::EntityDataTrait for AIGotoPlaceOrderEntityData {
}

impl super::entity::GameObjectDataTrait for AIGotoPlaceOrderEntityData {
}

impl super::core::DataBusPeerTrait for AIGotoPlaceOrderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIGotoPlaceOrderEntityData {
}

impl super::core::DataContainerTrait for AIGotoPlaceOrderEntityData {
}

pub static AIGOTOPLACEORDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIGotoPlaceOrderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIORDERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIGotoPlaceOrderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, max_distance),
            },
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, min_distance),
            },
            FieldInfoData {
                name: "GoToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, go_to_position),
            },
            FieldInfoData {
                name: "RandomizeDestination",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, randomize_destination),
            },
            FieldInfoData {
                name: "ChangeOfDestinationDistanceTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, change_of_destination_distance_tolerance),
            },
            FieldInfoData {
                name: "MoveSettingsAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, move_settings_alerted),
            },
            FieldInfoData {
                name: "MoveSettingsNotAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSettings",
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, move_settings_not_alerted),
            },
        ],
    }),
    array_type: Some(AIGOTOPLACEORDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIGotoPlaceOrderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIGOTOPLACEORDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIGOTOPLACEORDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIGotoPlaceOrderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIGotoPlaceOrderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFollowWaypointsOrderEntityData {
    pub _glacier_base: AIOrderEntityBaseData,
    pub waypoint_transform: super::core::LinearTransform,
    pub type_of_route: super::pathfinding_shared::RouteType,
    pub start_at_geometrically_closest_waypoint: bool,
    pub use_physics_driven_locomotion: bool,
    pub path_finding: super::pathfinding_shared::PathfindingChoice,
    pub pathlink_usage_type: AIPathlinkUsageType,
}

pub trait AIFollowWaypointsOrderEntityDataTrait: AIOrderEntityBaseDataTrait {
    fn waypoint_transform(&self) -> &super::core::LinearTransform;
    fn waypoint_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn type_of_route(&self) -> &super::pathfinding_shared::RouteType;
    fn type_of_route_mut(&mut self) -> &mut super::pathfinding_shared::RouteType;
    fn start_at_geometrically_closest_waypoint(&self) -> &bool;
    fn start_at_geometrically_closest_waypoint_mut(&mut self) -> &mut bool;
    fn use_physics_driven_locomotion(&self) -> &bool;
    fn use_physics_driven_locomotion_mut(&mut self) -> &mut bool;
    fn path_finding(&self) -> &super::pathfinding_shared::PathfindingChoice;
    fn path_finding_mut(&mut self) -> &mut super::pathfinding_shared::PathfindingChoice;
    fn pathlink_usage_type(&self) -> &AIPathlinkUsageType;
    fn pathlink_usage_type_mut(&mut self) -> &mut AIPathlinkUsageType;
}

impl AIFollowWaypointsOrderEntityDataTrait for AIFollowWaypointsOrderEntityData {
    fn waypoint_transform(&self) -> &super::core::LinearTransform {
        &self.waypoint_transform
    }
    fn waypoint_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.waypoint_transform
    }
    fn type_of_route(&self) -> &super::pathfinding_shared::RouteType {
        &self.type_of_route
    }
    fn type_of_route_mut(&mut self) -> &mut super::pathfinding_shared::RouteType {
        &mut self.type_of_route
    }
    fn start_at_geometrically_closest_waypoint(&self) -> &bool {
        &self.start_at_geometrically_closest_waypoint
    }
    fn start_at_geometrically_closest_waypoint_mut(&mut self) -> &mut bool {
        &mut self.start_at_geometrically_closest_waypoint
    }
    fn use_physics_driven_locomotion(&self) -> &bool {
        &self.use_physics_driven_locomotion
    }
    fn use_physics_driven_locomotion_mut(&mut self) -> &mut bool {
        &mut self.use_physics_driven_locomotion
    }
    fn path_finding(&self) -> &super::pathfinding_shared::PathfindingChoice {
        &self.path_finding
    }
    fn path_finding_mut(&mut self) -> &mut super::pathfinding_shared::PathfindingChoice {
        &mut self.path_finding
    }
    fn pathlink_usage_type(&self) -> &AIPathlinkUsageType {
        &self.pathlink_usage_type
    }
    fn pathlink_usage_type_mut(&mut self) -> &mut AIPathlinkUsageType {
        &mut self.pathlink_usage_type
    }
}

impl AIOrderEntityBaseDataTrait for AIFollowWaypointsOrderEntityData {
}

impl super::entity::EntityDataTrait for AIFollowWaypointsOrderEntityData {
}

impl super::entity::GameObjectDataTrait for AIFollowWaypointsOrderEntityData {
}

impl super::core::DataBusPeerTrait for AIFollowWaypointsOrderEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIFollowWaypointsOrderEntityData {
}

impl super::core::DataContainerTrait for AIFollowWaypointsOrderEntityData {
}

pub static AIFOLLOWWAYPOINTSORDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowWaypointsOrderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIORDERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFollowWaypointsOrderEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WaypointTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, waypoint_transform),
            },
            FieldInfoData {
                name: "TypeOfRoute",
                flags: MemberInfoFlags::new(0),
                field_type: "RouteType",
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, type_of_route),
            },
            FieldInfoData {
                name: "StartAtGeometricallyClosestWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, start_at_geometrically_closest_waypoint),
            },
            FieldInfoData {
                name: "UsePhysicsDrivenLocomotion",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, use_physics_driven_locomotion),
            },
            FieldInfoData {
                name: "PathFinding",
                flags: MemberInfoFlags::new(0),
                field_type: "PathfindingChoice",
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, path_finding),
            },
            FieldInfoData {
                name: "PathlinkUsageType",
                flags: MemberInfoFlags::new(0),
                field_type: "AIPathlinkUsageType",
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, pathlink_usage_type),
            },
        ],
    }),
    array_type: Some(AIFOLLOWWAYPOINTSORDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIFollowWaypointsOrderEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFOLLOWWAYPOINTSORDERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIFOLLOWWAYPOINTSORDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowWaypointsOrderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowWaypointsOrderEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIOrderEntityBaseData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait AIOrderEntityBaseDataTrait: super::entity::EntityDataTrait {
}

impl AIOrderEntityBaseDataTrait for AIOrderEntityBaseData {
}

impl super::entity::EntityDataTrait for AIOrderEntityBaseData {
}

impl super::entity::GameObjectDataTrait for AIOrderEntityBaseData {
}

impl super::core::DataBusPeerTrait for AIOrderEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIOrderEntityBaseData {
}

impl super::core::DataContainerTrait for AIOrderEntityBaseData {
}

pub static AIORDERENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIOrderEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIOrderEntityBaseData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AIORDERENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIOrderEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        AIORDERENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIORDERENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIOrderEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIOrderEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TacticsEnumeration {
    #[default]
    TacticsEnumeration_None = 0,
    TacticsEnumeration_Vehicle = 1,
    TacticsEnumeration_Charge = 2,
    TacticsEnumeration_Attack = 3,
    TacticsEnumeration_Hide = 4,
    TacticsEnumeration_Flee = 5,
    TacticsEnumeration_CloseCombat = 6,
    TacticsEnumeration_Berserk = 7,
    TacticsEnumeration_CloseRangeAttack = 8,
    TacticsEnumeration_SquadMovement = 9,
    TacticsEnumeration_SquadEngage = 10,
    TacticsEnumeration_Investigate = 11,
    TacticsEnumeration_CombatInvestigate = 12,
    TacticsEnumeration_CombatSearchArea = 13,
    TacticsEnumeration_SearchAreaTactic = 14,
}

pub static TACTICSENUMERATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TacticsEnumeration",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(TACTICSENUMERATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TacticsEnumeration {
    fn type_info(&self) -> &'static TypeInfo {
        TACTICSENUMERATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TACTICSENUMERATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TacticsEnumeration-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TacticsEnumeration"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AICombatIntensity {
    #[default]
    AICombatIntensity_None = 0,
    AICombatIntensity_Low = 1,
    AICombatIntensity_Medium = 2,
    AICombatIntensity_High = 3,
}

pub static AICOMBATINTENSITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatIntensity",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AICOMBATINTENSITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AICombatIntensity {
    fn type_info(&self) -> &'static TypeInfo {
        AICOMBATINTENSITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AICOMBATINTENSITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatIntensity-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICombatIntensity"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ExecutionPriority {
    #[default]
    ExecutionPriority_All = 0,
    ExecutionPriority_Idle = 1,
    ExecutionPriority_Combat = 2,
}

pub static EXECUTIONPRIORITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecutionPriority",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(EXECUTIONPRIORITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ExecutionPriority {
    fn type_info(&self) -> &'static TypeInfo {
        EXECUTIONPRIORITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EXECUTIONPRIORITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecutionPriority-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ExecutionPriority"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIShootType {
    #[default]
    AIShootType_OneBurstPerTarget = 0,
    AIShootType_Continuous = 1,
    AIShootType_HVT = 2,
}

pub static AISHOOTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIShootType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AISHOOTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIShootType {
    fn type_info(&self) -> &'static TypeInfo {
        AISHOOTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AISHOOTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIShootType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIShootType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum IdleReadiness {
    #[default]
    IdleReadiness_Relaxed = 0,
    IdleReadiness_Ready = 1,
}

pub static IDLEREADINESS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IdleReadiness",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(IDLEREADINESS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for IdleReadiness {
    fn type_info(&self) -> &'static TypeInfo {
        IDLEREADINESS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static IDLEREADINESS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IdleReadiness-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("IdleReadiness"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIOrderCoordinatorComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub is_active: bool,
    pub is_leader: bool,
    pub use_combat_group: bool,
    pub must_be_alerted: bool,
    pub must_be_in_cover: bool,
    pub must_have_seen_enemy: bool,
    pub must_have_seen_enemy_for_self_orders: bool,
    pub order_abort_and_reset_action_cooldown: bool,
    pub self_order_cooldown: f32,
    pub self_order_buffer_time: f32,
    pub order_freq_min: f32,
    pub order_freq_max: f32,
    pub order_buffer_time: f32,
    pub leader_binding: LeaderActionBinding,
    pub leader_actions: Vec<LeaderAction>,
    pub random_weight: f32,
    pub can_see_weight: f32,
    pub is_in_front_of_leader_weight: f32,
    pub forward_leader_angle_threshold: f32,
    pub member_actions: Vec<MemberAction>,
}

pub trait AIOrderCoordinatorComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn is_active(&self) -> &bool;
    fn is_active_mut(&mut self) -> &mut bool;
    fn is_leader(&self) -> &bool;
    fn is_leader_mut(&mut self) -> &mut bool;
    fn use_combat_group(&self) -> &bool;
    fn use_combat_group_mut(&mut self) -> &mut bool;
    fn must_be_alerted(&self) -> &bool;
    fn must_be_alerted_mut(&mut self) -> &mut bool;
    fn must_be_in_cover(&self) -> &bool;
    fn must_be_in_cover_mut(&mut self) -> &mut bool;
    fn must_have_seen_enemy(&self) -> &bool;
    fn must_have_seen_enemy_mut(&mut self) -> &mut bool;
    fn must_have_seen_enemy_for_self_orders(&self) -> &bool;
    fn must_have_seen_enemy_for_self_orders_mut(&mut self) -> &mut bool;
    fn order_abort_and_reset_action_cooldown(&self) -> &bool;
    fn order_abort_and_reset_action_cooldown_mut(&mut self) -> &mut bool;
    fn self_order_cooldown(&self) -> &f32;
    fn self_order_cooldown_mut(&mut self) -> &mut f32;
    fn self_order_buffer_time(&self) -> &f32;
    fn self_order_buffer_time_mut(&mut self) -> &mut f32;
    fn order_freq_min(&self) -> &f32;
    fn order_freq_min_mut(&mut self) -> &mut f32;
    fn order_freq_max(&self) -> &f32;
    fn order_freq_max_mut(&mut self) -> &mut f32;
    fn order_buffer_time(&self) -> &f32;
    fn order_buffer_time_mut(&mut self) -> &mut f32;
    fn leader_binding(&self) -> &LeaderActionBinding;
    fn leader_binding_mut(&mut self) -> &mut LeaderActionBinding;
    fn leader_actions(&self) -> &Vec<LeaderAction>;
    fn leader_actions_mut(&mut self) -> &mut Vec<LeaderAction>;
    fn random_weight(&self) -> &f32;
    fn random_weight_mut(&mut self) -> &mut f32;
    fn can_see_weight(&self) -> &f32;
    fn can_see_weight_mut(&mut self) -> &mut f32;
    fn is_in_front_of_leader_weight(&self) -> &f32;
    fn is_in_front_of_leader_weight_mut(&mut self) -> &mut f32;
    fn forward_leader_angle_threshold(&self) -> &f32;
    fn forward_leader_angle_threshold_mut(&mut self) -> &mut f32;
    fn member_actions(&self) -> &Vec<MemberAction>;
    fn member_actions_mut(&mut self) -> &mut Vec<MemberAction>;
}

impl AIOrderCoordinatorComponentDataTrait for AIOrderCoordinatorComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn is_active(&self) -> &bool {
        &self.is_active
    }
    fn is_active_mut(&mut self) -> &mut bool {
        &mut self.is_active
    }
    fn is_leader(&self) -> &bool {
        &self.is_leader
    }
    fn is_leader_mut(&mut self) -> &mut bool {
        &mut self.is_leader
    }
    fn use_combat_group(&self) -> &bool {
        &self.use_combat_group
    }
    fn use_combat_group_mut(&mut self) -> &mut bool {
        &mut self.use_combat_group
    }
    fn must_be_alerted(&self) -> &bool {
        &self.must_be_alerted
    }
    fn must_be_alerted_mut(&mut self) -> &mut bool {
        &mut self.must_be_alerted
    }
    fn must_be_in_cover(&self) -> &bool {
        &self.must_be_in_cover
    }
    fn must_be_in_cover_mut(&mut self) -> &mut bool {
        &mut self.must_be_in_cover
    }
    fn must_have_seen_enemy(&self) -> &bool {
        &self.must_have_seen_enemy
    }
    fn must_have_seen_enemy_mut(&mut self) -> &mut bool {
        &mut self.must_have_seen_enemy
    }
    fn must_have_seen_enemy_for_self_orders(&self) -> &bool {
        &self.must_have_seen_enemy_for_self_orders
    }
    fn must_have_seen_enemy_for_self_orders_mut(&mut self) -> &mut bool {
        &mut self.must_have_seen_enemy_for_self_orders
    }
    fn order_abort_and_reset_action_cooldown(&self) -> &bool {
        &self.order_abort_and_reset_action_cooldown
    }
    fn order_abort_and_reset_action_cooldown_mut(&mut self) -> &mut bool {
        &mut self.order_abort_and_reset_action_cooldown
    }
    fn self_order_cooldown(&self) -> &f32 {
        &self.self_order_cooldown
    }
    fn self_order_cooldown_mut(&mut self) -> &mut f32 {
        &mut self.self_order_cooldown
    }
    fn self_order_buffer_time(&self) -> &f32 {
        &self.self_order_buffer_time
    }
    fn self_order_buffer_time_mut(&mut self) -> &mut f32 {
        &mut self.self_order_buffer_time
    }
    fn order_freq_min(&self) -> &f32 {
        &self.order_freq_min
    }
    fn order_freq_min_mut(&mut self) -> &mut f32 {
        &mut self.order_freq_min
    }
    fn order_freq_max(&self) -> &f32 {
        &self.order_freq_max
    }
    fn order_freq_max_mut(&mut self) -> &mut f32 {
        &mut self.order_freq_max
    }
    fn order_buffer_time(&self) -> &f32 {
        &self.order_buffer_time
    }
    fn order_buffer_time_mut(&mut self) -> &mut f32 {
        &mut self.order_buffer_time
    }
    fn leader_binding(&self) -> &LeaderActionBinding {
        &self.leader_binding
    }
    fn leader_binding_mut(&mut self) -> &mut LeaderActionBinding {
        &mut self.leader_binding
    }
    fn leader_actions(&self) -> &Vec<LeaderAction> {
        &self.leader_actions
    }
    fn leader_actions_mut(&mut self) -> &mut Vec<LeaderAction> {
        &mut self.leader_actions
    }
    fn random_weight(&self) -> &f32 {
        &self.random_weight
    }
    fn random_weight_mut(&mut self) -> &mut f32 {
        &mut self.random_weight
    }
    fn can_see_weight(&self) -> &f32 {
        &self.can_see_weight
    }
    fn can_see_weight_mut(&mut self) -> &mut f32 {
        &mut self.can_see_weight
    }
    fn is_in_front_of_leader_weight(&self) -> &f32 {
        &self.is_in_front_of_leader_weight
    }
    fn is_in_front_of_leader_weight_mut(&mut self) -> &mut f32 {
        &mut self.is_in_front_of_leader_weight
    }
    fn forward_leader_angle_threshold(&self) -> &f32 {
        &self.forward_leader_angle_threshold
    }
    fn forward_leader_angle_threshold_mut(&mut self) -> &mut f32 {
        &mut self.forward_leader_angle_threshold
    }
    fn member_actions(&self) -> &Vec<MemberAction> {
        &self.member_actions
    }
    fn member_actions_mut(&mut self) -> &mut Vec<MemberAction> {
        &mut self.member_actions
    }
}

impl super::entity::GameComponentDataTrait for AIOrderCoordinatorComponentData {
}

impl super::entity::ComponentDataTrait for AIOrderCoordinatorComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AIOrderCoordinatorComponentData {
}

impl super::core::DataBusPeerTrait for AIOrderCoordinatorComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIOrderCoordinatorComponentData {
}

impl super::core::DataContainerTrait for AIOrderCoordinatorComponentData {
}

pub static AIORDERCOORDINATORCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIOrderCoordinatorComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIOrderCoordinatorComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, realm),
            },
            FieldInfoData {
                name: "IsActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, is_active),
            },
            FieldInfoData {
                name: "IsLeader",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, is_leader),
            },
            FieldInfoData {
                name: "UseCombatGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, use_combat_group),
            },
            FieldInfoData {
                name: "MustBeAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, must_be_alerted),
            },
            FieldInfoData {
                name: "MustBeInCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, must_be_in_cover),
            },
            FieldInfoData {
                name: "MustHaveSeenEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, must_have_seen_enemy),
            },
            FieldInfoData {
                name: "MustHaveSeenEnemyForSelfOrders",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, must_have_seen_enemy_for_self_orders),
            },
            FieldInfoData {
                name: "OrderAbortAndResetActionCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, order_abort_and_reset_action_cooldown),
            },
            FieldInfoData {
                name: "SelfOrderCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, self_order_cooldown),
            },
            FieldInfoData {
                name: "SelfOrderBufferTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, self_order_buffer_time),
            },
            FieldInfoData {
                name: "OrderFreqMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, order_freq_min),
            },
            FieldInfoData {
                name: "OrderFreqMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, order_freq_max),
            },
            FieldInfoData {
                name: "OrderBufferTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, order_buffer_time),
            },
            FieldInfoData {
                name: "LeaderBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "LeaderActionBinding",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, leader_binding),
            },
            FieldInfoData {
                name: "LeaderActions",
                flags: MemberInfoFlags::new(144),
                field_type: "LeaderAction-Array",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, leader_actions),
            },
            FieldInfoData {
                name: "RandomWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, random_weight),
            },
            FieldInfoData {
                name: "CanSeeWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, can_see_weight),
            },
            FieldInfoData {
                name: "IsInFrontOfLeaderWeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, is_in_front_of_leader_weight),
            },
            FieldInfoData {
                name: "ForwardLeaderAngleThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, forward_leader_angle_threshold),
            },
            FieldInfoData {
                name: "MemberActions",
                flags: MemberInfoFlags::new(144),
                field_type: "MemberAction-Array",
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, member_actions),
            },
        ],
    }),
    array_type: Some(AIORDERCOORDINATORCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIOrderCoordinatorComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIORDERCOORDINATORCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIORDERCOORDINATORCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIOrderCoordinatorComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIOrderCoordinatorComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MemberAction {
    pub name: String,
    pub index: i32,
    pub must_be_in_cover: bool,
    pub min_distance: f32,
    pub max_distance: f32,
    pub min_distance_to_target: f32,
    pub max_distance_to_target: f32,
    pub score: f32,
    pub cooldown: f32,
    pub templates: Vec<String>,
}

pub trait MemberActionTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn index(&self) -> &i32;
    fn index_mut(&mut self) -> &mut i32;
    fn must_be_in_cover(&self) -> &bool;
    fn must_be_in_cover_mut(&mut self) -> &mut bool;
    fn min_distance(&self) -> &f32;
    fn min_distance_mut(&mut self) -> &mut f32;
    fn max_distance(&self) -> &f32;
    fn max_distance_mut(&mut self) -> &mut f32;
    fn min_distance_to_target(&self) -> &f32;
    fn min_distance_to_target_mut(&mut self) -> &mut f32;
    fn max_distance_to_target(&self) -> &f32;
    fn max_distance_to_target_mut(&mut self) -> &mut f32;
    fn score(&self) -> &f32;
    fn score_mut(&mut self) -> &mut f32;
    fn cooldown(&self) -> &f32;
    fn cooldown_mut(&mut self) -> &mut f32;
    fn templates(&self) -> &Vec<String>;
    fn templates_mut(&mut self) -> &mut Vec<String>;
}

impl MemberActionTrait for MemberAction {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn index(&self) -> &i32 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut i32 {
        &mut self.index
    }
    fn must_be_in_cover(&self) -> &bool {
        &self.must_be_in_cover
    }
    fn must_be_in_cover_mut(&mut self) -> &mut bool {
        &mut self.must_be_in_cover
    }
    fn min_distance(&self) -> &f32 {
        &self.min_distance
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_distance
    }
    fn max_distance(&self) -> &f32 {
        &self.max_distance
    }
    fn max_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_distance
    }
    fn min_distance_to_target(&self) -> &f32 {
        &self.min_distance_to_target
    }
    fn min_distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.min_distance_to_target
    }
    fn max_distance_to_target(&self) -> &f32 {
        &self.max_distance_to_target
    }
    fn max_distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_to_target
    }
    fn score(&self) -> &f32 {
        &self.score
    }
    fn score_mut(&mut self) -> &mut f32 {
        &mut self.score
    }
    fn cooldown(&self) -> &f32 {
        &self.cooldown
    }
    fn cooldown_mut(&mut self) -> &mut f32 {
        &mut self.cooldown
    }
    fn templates(&self) -> &Vec<String> {
        &self.templates
    }
    fn templates_mut(&mut self) -> &mut Vec<String> {
        &mut self.templates
    }
}

pub static MEMBERACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemberAction",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MemberAction as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MemberAction, name),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MemberAction, index),
            },
            FieldInfoData {
                name: "MustBeInCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MemberAction, must_be_in_cover),
            },
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MemberAction, min_distance),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MemberAction, max_distance),
            },
            FieldInfoData {
                name: "MinDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MemberAction, min_distance_to_target),
            },
            FieldInfoData {
                name: "MaxDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MemberAction, max_distance_to_target),
            },
            FieldInfoData {
                name: "Score",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MemberAction, score),
            },
            FieldInfoData {
                name: "Cooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MemberAction, cooldown),
            },
            FieldInfoData {
                name: "Templates",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(MemberAction, templates),
            },
        ],
    }),
    array_type: Some(MEMBERACTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MemberAction {
    fn type_info(&self) -> &'static TypeInfo {
        MEMBERACTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MEMBERACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemberAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MemberAction"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LeaderAction {
    pub name: String,
    pub index: i32,
    pub cooldown: f32,
    pub ant_game_state: Option<Arc<Mutex<dyn super::game_shared::WriteAntGameStateDataTrait>>>,
}

pub trait LeaderActionTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn index(&self) -> &i32;
    fn index_mut(&mut self) -> &mut i32;
    fn cooldown(&self) -> &f32;
    fn cooldown_mut(&mut self) -> &mut f32;
    fn ant_game_state(&self) -> &Option<Arc<Mutex<dyn super::game_shared::WriteAntGameStateDataTrait>>>;
    fn ant_game_state_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::WriteAntGameStateDataTrait>>>;
}

impl LeaderActionTrait for LeaderAction {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn index(&self) -> &i32 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut i32 {
        &mut self.index
    }
    fn cooldown(&self) -> &f32 {
        &self.cooldown
    }
    fn cooldown_mut(&mut self) -> &mut f32 {
        &mut self.cooldown
    }
    fn ant_game_state(&self) -> &Option<Arc<Mutex<dyn super::game_shared::WriteAntGameStateDataTrait>>> {
        &self.ant_game_state
    }
    fn ant_game_state_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::WriteAntGameStateDataTrait>>> {
        &mut self.ant_game_state
    }
}

pub static LEADERACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LeaderAction",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LeaderAction as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LeaderAction, name),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(LeaderAction, index),
            },
            FieldInfoData {
                name: "Cooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LeaderAction, cooldown),
            },
            FieldInfoData {
                name: "AntGameState",
                flags: MemberInfoFlags::new(0),
                field_type: "WriteAntGameStateData",
                rust_offset: offset_of!(LeaderAction, ant_game_state),
            },
        ],
    }),
    array_type: Some(LEADERACTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LeaderAction {
    fn type_info(&self) -> &'static TypeInfo {
        LEADERACTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LEADERACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LeaderAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LeaderAction"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LeaderActionBinding {
    pub leader_to_member_angle: super::ant::AntRef,
    pub send_order_ack: super::ant::AntRef,
}

pub trait LeaderActionBindingTrait: TypeObject {
    fn leader_to_member_angle(&self) -> &super::ant::AntRef;
    fn leader_to_member_angle_mut(&mut self) -> &mut super::ant::AntRef;
    fn send_order_ack(&self) -> &super::ant::AntRef;
    fn send_order_ack_mut(&mut self) -> &mut super::ant::AntRef;
}

impl LeaderActionBindingTrait for LeaderActionBinding {
    fn leader_to_member_angle(&self) -> &super::ant::AntRef {
        &self.leader_to_member_angle
    }
    fn leader_to_member_angle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.leader_to_member_angle
    }
    fn send_order_ack(&self) -> &super::ant::AntRef {
        &self.send_order_ack
    }
    fn send_order_ack_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.send_order_ack
    }
}

pub static LEADERACTIONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LeaderActionBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LeaderActionBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LeaderToMemberAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(LeaderActionBinding, leader_to_member_angle),
            },
            FieldInfoData {
                name: "SendOrderAck",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(LeaderActionBinding, send_order_ack),
            },
        ],
    }),
    array_type: Some(LEADERACTIONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LeaderActionBinding {
    fn type_info(&self) -> &'static TypeInfo {
        LEADERACTIONBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LEADERACTIONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LeaderActionBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LeaderActionBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIObstacleControllerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enabled_at_start: bool,
    pub penalty: AINavObstaclePenalty,
    pub affected_layers: Vec<AIPathfindingLayer>,
    pub entity_box_override: super::core::AxisAlignedBox,
}

pub trait AIObstacleControllerEntityDataTrait: super::entity::EntityDataTrait {
    fn enabled_at_start(&self) -> &bool;
    fn enabled_at_start_mut(&mut self) -> &mut bool;
    fn penalty(&self) -> &AINavObstaclePenalty;
    fn penalty_mut(&mut self) -> &mut AINavObstaclePenalty;
    fn affected_layers(&self) -> &Vec<AIPathfindingLayer>;
    fn affected_layers_mut(&mut self) -> &mut Vec<AIPathfindingLayer>;
    fn entity_box_override(&self) -> &super::core::AxisAlignedBox;
    fn entity_box_override_mut(&mut self) -> &mut super::core::AxisAlignedBox;
}

impl AIObstacleControllerEntityDataTrait for AIObstacleControllerEntityData {
    fn enabled_at_start(&self) -> &bool {
        &self.enabled_at_start
    }
    fn enabled_at_start_mut(&mut self) -> &mut bool {
        &mut self.enabled_at_start
    }
    fn penalty(&self) -> &AINavObstaclePenalty {
        &self.penalty
    }
    fn penalty_mut(&mut self) -> &mut AINavObstaclePenalty {
        &mut self.penalty
    }
    fn affected_layers(&self) -> &Vec<AIPathfindingLayer> {
        &self.affected_layers
    }
    fn affected_layers_mut(&mut self) -> &mut Vec<AIPathfindingLayer> {
        &mut self.affected_layers
    }
    fn entity_box_override(&self) -> &super::core::AxisAlignedBox {
        &self.entity_box_override
    }
    fn entity_box_override_mut(&mut self) -> &mut super::core::AxisAlignedBox {
        &mut self.entity_box_override
    }
}

impl super::entity::EntityDataTrait for AIObstacleControllerEntityData {
}

impl super::entity::GameObjectDataTrait for AIObstacleControllerEntityData {
}

impl super::core::DataBusPeerTrait for AIObstacleControllerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIObstacleControllerEntityData {
}

impl super::core::DataContainerTrait for AIObstacleControllerEntityData {
}

pub static AIOBSTACLECONTROLLERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIObstacleControllerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIObstacleControllerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnabledAtStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIObstacleControllerEntityData, enabled_at_start),
            },
            FieldInfoData {
                name: "Penalty",
                flags: MemberInfoFlags::new(0),
                field_type: "AINavObstaclePenalty",
                rust_offset: offset_of!(AIObstacleControllerEntityData, penalty),
            },
            FieldInfoData {
                name: "AffectedLayers",
                flags: MemberInfoFlags::new(144),
                field_type: "AIPathfindingLayer-Array",
                rust_offset: offset_of!(AIObstacleControllerEntityData, affected_layers),
            },
            FieldInfoData {
                name: "EntityBoxOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "AxisAlignedBox",
                rust_offset: offset_of!(AIObstacleControllerEntityData, entity_box_override),
            },
        ],
    }),
    array_type: Some(AIOBSTACLECONTROLLERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIObstacleControllerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIOBSTACLECONTROLLERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIOBSTACLECONTROLLERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIObstacleControllerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIObstacleControllerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BattleAINavObstacleComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub enable_on_init: bool,
    pub is_pathfinding: bool,
    pub enable_tracking: bool,
    pub enable_track_rotation: bool,
    pub penalty: AINavObstaclePenalty,
    pub bounding_volume_offset: super::core::Vec3,
    pub bounding_volume_extent_override: super::core::Vec3,
    pub affected_layers: Vec<AIPathfindingLayer>,
    pub enable_movement_obstacle: bool,
    pub extrapolate_distance: f32,
    pub replace_distance: f32,
    pub replace_angle: f32,
}

pub trait BattleAINavObstacleComponentDataTrait: super::entity::GameComponentDataTrait {
    fn enable_on_init(&self) -> &bool;
    fn enable_on_init_mut(&mut self) -> &mut bool;
    fn is_pathfinding(&self) -> &bool;
    fn is_pathfinding_mut(&mut self) -> &mut bool;
    fn enable_tracking(&self) -> &bool;
    fn enable_tracking_mut(&mut self) -> &mut bool;
    fn enable_track_rotation(&self) -> &bool;
    fn enable_track_rotation_mut(&mut self) -> &mut bool;
    fn penalty(&self) -> &AINavObstaclePenalty;
    fn penalty_mut(&mut self) -> &mut AINavObstaclePenalty;
    fn bounding_volume_offset(&self) -> &super::core::Vec3;
    fn bounding_volume_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn bounding_volume_extent_override(&self) -> &super::core::Vec3;
    fn bounding_volume_extent_override_mut(&mut self) -> &mut super::core::Vec3;
    fn affected_layers(&self) -> &Vec<AIPathfindingLayer>;
    fn affected_layers_mut(&mut self) -> &mut Vec<AIPathfindingLayer>;
    fn enable_movement_obstacle(&self) -> &bool;
    fn enable_movement_obstacle_mut(&mut self) -> &mut bool;
    fn extrapolate_distance(&self) -> &f32;
    fn extrapolate_distance_mut(&mut self) -> &mut f32;
    fn replace_distance(&self) -> &f32;
    fn replace_distance_mut(&mut self) -> &mut f32;
    fn replace_angle(&self) -> &f32;
    fn replace_angle_mut(&mut self) -> &mut f32;
}

impl BattleAINavObstacleComponentDataTrait for BattleAINavObstacleComponentData {
    fn enable_on_init(&self) -> &bool {
        &self.enable_on_init
    }
    fn enable_on_init_mut(&mut self) -> &mut bool {
        &mut self.enable_on_init
    }
    fn is_pathfinding(&self) -> &bool {
        &self.is_pathfinding
    }
    fn is_pathfinding_mut(&mut self) -> &mut bool {
        &mut self.is_pathfinding
    }
    fn enable_tracking(&self) -> &bool {
        &self.enable_tracking
    }
    fn enable_tracking_mut(&mut self) -> &mut bool {
        &mut self.enable_tracking
    }
    fn enable_track_rotation(&self) -> &bool {
        &self.enable_track_rotation
    }
    fn enable_track_rotation_mut(&mut self) -> &mut bool {
        &mut self.enable_track_rotation
    }
    fn penalty(&self) -> &AINavObstaclePenalty {
        &self.penalty
    }
    fn penalty_mut(&mut self) -> &mut AINavObstaclePenalty {
        &mut self.penalty
    }
    fn bounding_volume_offset(&self) -> &super::core::Vec3 {
        &self.bounding_volume_offset
    }
    fn bounding_volume_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.bounding_volume_offset
    }
    fn bounding_volume_extent_override(&self) -> &super::core::Vec3 {
        &self.bounding_volume_extent_override
    }
    fn bounding_volume_extent_override_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.bounding_volume_extent_override
    }
    fn affected_layers(&self) -> &Vec<AIPathfindingLayer> {
        &self.affected_layers
    }
    fn affected_layers_mut(&mut self) -> &mut Vec<AIPathfindingLayer> {
        &mut self.affected_layers
    }
    fn enable_movement_obstacle(&self) -> &bool {
        &self.enable_movement_obstacle
    }
    fn enable_movement_obstacle_mut(&mut self) -> &mut bool {
        &mut self.enable_movement_obstacle
    }
    fn extrapolate_distance(&self) -> &f32 {
        &self.extrapolate_distance
    }
    fn extrapolate_distance_mut(&mut self) -> &mut f32 {
        &mut self.extrapolate_distance
    }
    fn replace_distance(&self) -> &f32 {
        &self.replace_distance
    }
    fn replace_distance_mut(&mut self) -> &mut f32 {
        &mut self.replace_distance
    }
    fn replace_angle(&self) -> &f32 {
        &self.replace_angle
    }
    fn replace_angle_mut(&mut self) -> &mut f32 {
        &mut self.replace_angle
    }
}

impl super::entity::GameComponentDataTrait for BattleAINavObstacleComponentData {
}

impl super::entity::ComponentDataTrait for BattleAINavObstacleComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for BattleAINavObstacleComponentData {
}

impl super::core::DataBusPeerTrait for BattleAINavObstacleComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BattleAINavObstacleComponentData {
}

impl super::core::DataContainerTrait for BattleAINavObstacleComponentData {
}

pub static BATTLEAINAVOBSTACLECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAINavObstacleComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BattleAINavObstacleComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnableOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, enable_on_init),
            },
            FieldInfoData {
                name: "IsPathfinding",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, is_pathfinding),
            },
            FieldInfoData {
                name: "EnableTracking",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, enable_tracking),
            },
            FieldInfoData {
                name: "EnableTrackRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, enable_track_rotation),
            },
            FieldInfoData {
                name: "Penalty",
                flags: MemberInfoFlags::new(0),
                field_type: "AINavObstaclePenalty",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, penalty),
            },
            FieldInfoData {
                name: "BoundingVolumeOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, bounding_volume_offset),
            },
            FieldInfoData {
                name: "BoundingVolumeExtentOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, bounding_volume_extent_override),
            },
            FieldInfoData {
                name: "AffectedLayers",
                flags: MemberInfoFlags::new(144),
                field_type: "AIPathfindingLayer-Array",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, affected_layers),
            },
            FieldInfoData {
                name: "EnableMovementObstacle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, enable_movement_obstacle),
            },
            FieldInfoData {
                name: "ExtrapolateDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, extrapolate_distance),
            },
            FieldInfoData {
                name: "ReplaceDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, replace_distance),
            },
            FieldInfoData {
                name: "ReplaceAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BattleAINavObstacleComponentData, replace_angle),
            },
        ],
    }),
    array_type: Some(BATTLEAINAVOBSTACLECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BattleAINavObstacleComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        BATTLEAINAVOBSTACLECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BATTLEAINAVOBSTACLECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAINavObstacleComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAINavObstacleComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIMeleeComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
}

pub trait AIMeleeComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl AIMeleeComponentDataTrait for AIMeleeComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::GameComponentDataTrait for AIMeleeComponentData {
}

impl super::entity::ComponentDataTrait for AIMeleeComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AIMeleeComponentData {
}

impl super::core::DataBusPeerTrait for AIMeleeComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIMeleeComponentData {
}

impl super::core::DataContainerTrait for AIMeleeComponentData {
}

pub static AIMELEECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIMeleeComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIMeleeComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AIMeleeComponentData, realm),
            },
        ],
    }),
    array_type: Some(AIMELEECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIMeleeComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIMELEECOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIMELEECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIMeleeComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIMeleeComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AITeleportEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub check_below_ground: bool,
    pub new_position: super::core::LinearTransform,
}

pub trait AITeleportEntityDataTrait: super::entity::EntityDataTrait {
    fn check_below_ground(&self) -> &bool;
    fn check_below_ground_mut(&mut self) -> &mut bool;
    fn new_position(&self) -> &super::core::LinearTransform;
    fn new_position_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl AITeleportEntityDataTrait for AITeleportEntityData {
    fn check_below_ground(&self) -> &bool {
        &self.check_below_ground
    }
    fn check_below_ground_mut(&mut self) -> &mut bool {
        &mut self.check_below_ground
    }
    fn new_position(&self) -> &super::core::LinearTransform {
        &self.new_position
    }
    fn new_position_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.new_position
    }
}

impl super::entity::EntityDataTrait for AITeleportEntityData {
}

impl super::entity::GameObjectDataTrait for AITeleportEntityData {
}

impl super::core::DataBusPeerTrait for AITeleportEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AITeleportEntityData {
}

impl super::core::DataContainerTrait for AITeleportEntityData {
}

pub static AITELEPORTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITeleportEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AITeleportEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CheckBelowGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITeleportEntityData, check_below_ground),
            },
            FieldInfoData {
                name: "NewPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AITeleportEntityData, new_position),
            },
        ],
    }),
    array_type: Some(AITELEPORTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AITeleportEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AITELEPORTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AITELEPORTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITeleportEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITeleportEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaypointsWalkerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub circular: bool,
    pub speed: f32,
}

pub trait WaypointsWalkerEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn circular(&self) -> &bool;
    fn circular_mut(&mut self) -> &mut bool;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
}

impl WaypointsWalkerEntityDataTrait for WaypointsWalkerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn circular(&self) -> &bool {
        &self.circular
    }
    fn circular_mut(&mut self) -> &mut bool {
        &mut self.circular
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
}

impl super::entity::EntityDataTrait for WaypointsWalkerEntityData {
}

impl super::entity::GameObjectDataTrait for WaypointsWalkerEntityData {
}

impl super::core::DataBusPeerTrait for WaypointsWalkerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WaypointsWalkerEntityData {
}

impl super::core::DataContainerTrait for WaypointsWalkerEntityData {
}

pub static WAYPOINTSWALKERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointsWalkerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaypointsWalkerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WaypointsWalkerEntityData, realm),
            },
            FieldInfoData {
                name: "Circular",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaypointsWalkerEntityData, circular),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WaypointsWalkerEntityData, speed),
            },
        ],
    }),
    array_type: Some(WAYPOINTSWALKERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaypointsWalkerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WAYPOINTSWALKERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WAYPOINTSWALKERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointsWalkerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WaypointsWalkerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIFirePatternEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub wants_to_fire: bool,
    pub simple_patterns: Vec<SimpleFirePatternData>,
    pub pattern_to_use: i32,
}

pub trait AIFirePatternEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn wants_to_fire(&self) -> &bool;
    fn wants_to_fire_mut(&mut self) -> &mut bool;
    fn simple_patterns(&self) -> &Vec<SimpleFirePatternData>;
    fn simple_patterns_mut(&mut self) -> &mut Vec<SimpleFirePatternData>;
    fn pattern_to_use(&self) -> &i32;
    fn pattern_to_use_mut(&mut self) -> &mut i32;
}

impl AIFirePatternEntityDataTrait for AIFirePatternEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn wants_to_fire(&self) -> &bool {
        &self.wants_to_fire
    }
    fn wants_to_fire_mut(&mut self) -> &mut bool {
        &mut self.wants_to_fire
    }
    fn simple_patterns(&self) -> &Vec<SimpleFirePatternData> {
        &self.simple_patterns
    }
    fn simple_patterns_mut(&mut self) -> &mut Vec<SimpleFirePatternData> {
        &mut self.simple_patterns
    }
    fn pattern_to_use(&self) -> &i32 {
        &self.pattern_to_use
    }
    fn pattern_to_use_mut(&mut self) -> &mut i32 {
        &mut self.pattern_to_use
    }
}

impl super::entity::EntityDataTrait for AIFirePatternEntityData {
}

impl super::entity::GameObjectDataTrait for AIFirePatternEntityData {
}

impl super::core::DataBusPeerTrait for AIFirePatternEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIFirePatternEntityData {
}

impl super::core::DataContainerTrait for AIFirePatternEntityData {
}

pub static AIFIREPATTERNENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFirePatternEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIFirePatternEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AIFirePatternEntityData, realm),
            },
            FieldInfoData {
                name: "WantsToFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIFirePatternEntityData, wants_to_fire),
            },
            FieldInfoData {
                name: "SimplePatterns",
                flags: MemberInfoFlags::new(144),
                field_type: "SimpleFirePatternData-Array",
                rust_offset: offset_of!(AIFirePatternEntityData, simple_patterns),
            },
            FieldInfoData {
                name: "PatternToUse",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AIFirePatternEntityData, pattern_to_use),
            },
        ],
    }),
    array_type: Some(AIFIREPATTERNENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFirePatternEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFIREPATTERNENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIFIREPATTERNENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFirePatternEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFirePatternEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleFirePatternData {
    pub min_fire_interval: f32,
    pub max_fire_interval: f32,
    pub min_interval_between_fire: f32,
    pub max_interval_between_fire: f32,
}

pub trait SimpleFirePatternDataTrait: TypeObject {
    fn min_fire_interval(&self) -> &f32;
    fn min_fire_interval_mut(&mut self) -> &mut f32;
    fn max_fire_interval(&self) -> &f32;
    fn max_fire_interval_mut(&mut self) -> &mut f32;
    fn min_interval_between_fire(&self) -> &f32;
    fn min_interval_between_fire_mut(&mut self) -> &mut f32;
    fn max_interval_between_fire(&self) -> &f32;
    fn max_interval_between_fire_mut(&mut self) -> &mut f32;
}

impl SimpleFirePatternDataTrait for SimpleFirePatternData {
    fn min_fire_interval(&self) -> &f32 {
        &self.min_fire_interval
    }
    fn min_fire_interval_mut(&mut self) -> &mut f32 {
        &mut self.min_fire_interval
    }
    fn max_fire_interval(&self) -> &f32 {
        &self.max_fire_interval
    }
    fn max_fire_interval_mut(&mut self) -> &mut f32 {
        &mut self.max_fire_interval
    }
    fn min_interval_between_fire(&self) -> &f32 {
        &self.min_interval_between_fire
    }
    fn min_interval_between_fire_mut(&mut self) -> &mut f32 {
        &mut self.min_interval_between_fire
    }
    fn max_interval_between_fire(&self) -> &f32 {
        &self.max_interval_between_fire
    }
    fn max_interval_between_fire_mut(&mut self) -> &mut f32 {
        &mut self.max_interval_between_fire
    }
}

pub static SIMPLEFIREPATTERNDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleFirePatternData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleFirePatternData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinFireInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleFirePatternData, min_fire_interval),
            },
            FieldInfoData {
                name: "MaxFireInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleFirePatternData, max_fire_interval),
            },
            FieldInfoData {
                name: "MinIntervalBetweenFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleFirePatternData, min_interval_between_fire),
            },
            FieldInfoData {
                name: "MaxIntervalBetweenFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleFirePatternData, max_interval_between_fire),
            },
        ],
    }),
    array_type: Some(SIMPLEFIREPATTERNDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SimpleFirePatternData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEFIREPATTERNDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SIMPLEFIREPATTERNDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleFirePatternData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SimpleFirePatternData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AITemplateFilterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub templates: Vec<String>,
}

pub trait AITemplateFilterEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn templates(&self) -> &Vec<String>;
    fn templates_mut(&mut self) -> &mut Vec<String>;
}

impl AITemplateFilterEntityDataTrait for AITemplateFilterEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn templates(&self) -> &Vec<String> {
        &self.templates
    }
    fn templates_mut(&mut self) -> &mut Vec<String> {
        &mut self.templates
    }
}

impl super::entity::EntityDataTrait for AITemplateFilterEntityData {
}

impl super::entity::GameObjectDataTrait for AITemplateFilterEntityData {
}

impl super::core::DataBusPeerTrait for AITemplateFilterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AITemplateFilterEntityData {
}

impl super::core::DataContainerTrait for AITemplateFilterEntityData {
}

pub static AITEMPLATEFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITemplateFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AITemplateFilterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AITemplateFilterEntityData, realm),
            },
            FieldInfoData {
                name: "Templates",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(AITemplateFilterEntityData, templates),
            },
        ],
    }),
    array_type: Some(AITEMPLATEFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITemplateFilterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AITEMPLATEFILTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AITEMPLATEFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITemplateFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITemplateFilterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PointOfInterestComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub detection_radius: f32,
    pub time_to_live: f32,
}

pub trait PointOfInterestComponentDataTrait: super::entity::GameComponentDataTrait {
    fn detection_radius(&self) -> &f32;
    fn detection_radius_mut(&mut self) -> &mut f32;
    fn time_to_live(&self) -> &f32;
    fn time_to_live_mut(&mut self) -> &mut f32;
}

impl PointOfInterestComponentDataTrait for PointOfInterestComponentData {
    fn detection_radius(&self) -> &f32 {
        &self.detection_radius
    }
    fn detection_radius_mut(&mut self) -> &mut f32 {
        &mut self.detection_radius
    }
    fn time_to_live(&self) -> &f32 {
        &self.time_to_live
    }
    fn time_to_live_mut(&mut self) -> &mut f32 {
        &mut self.time_to_live
    }
}

impl super::entity::GameComponentDataTrait for PointOfInterestComponentData {
}

impl super::entity::ComponentDataTrait for PointOfInterestComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for PointOfInterestComponentData {
}

impl super::core::DataBusPeerTrait for PointOfInterestComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PointOfInterestComponentData {
}

impl super::core::DataContainerTrait for PointOfInterestComponentData {
}

pub static POINTOFINTERESTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointOfInterestComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PointOfInterestComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DetectionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointOfInterestComponentData, detection_radius),
            },
            FieldInfoData {
                name: "TimeToLive",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointOfInterestComponentData, time_to_live),
            },
        ],
    }),
    array_type: Some(POINTOFINTERESTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PointOfInterestComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        POINTOFINTERESTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static POINTOFINTERESTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointOfInterestComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PointOfInterestComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlayerVehicleProximityEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub enter_close_proximity_range: f32,
    pub exit_close_proximity_range: f32,
    pub player_previous_vehicle_range: f32,
}

pub trait PlayerVehicleProximityEntityDataTrait: super::entity::EntityDataTrait {
    fn enter_close_proximity_range(&self) -> &f32;
    fn enter_close_proximity_range_mut(&mut self) -> &mut f32;
    fn exit_close_proximity_range(&self) -> &f32;
    fn exit_close_proximity_range_mut(&mut self) -> &mut f32;
    fn player_previous_vehicle_range(&self) -> &f32;
    fn player_previous_vehicle_range_mut(&mut self) -> &mut f32;
}

impl PlayerVehicleProximityEntityDataTrait for PlayerVehicleProximityEntityData {
    fn enter_close_proximity_range(&self) -> &f32 {
        &self.enter_close_proximity_range
    }
    fn enter_close_proximity_range_mut(&mut self) -> &mut f32 {
        &mut self.enter_close_proximity_range
    }
    fn exit_close_proximity_range(&self) -> &f32 {
        &self.exit_close_proximity_range
    }
    fn exit_close_proximity_range_mut(&mut self) -> &mut f32 {
        &mut self.exit_close_proximity_range
    }
    fn player_previous_vehicle_range(&self) -> &f32 {
        &self.player_previous_vehicle_range
    }
    fn player_previous_vehicle_range_mut(&mut self) -> &mut f32 {
        &mut self.player_previous_vehicle_range
    }
}

impl super::entity::EntityDataTrait for PlayerVehicleProximityEntityData {
}

impl super::entity::GameObjectDataTrait for PlayerVehicleProximityEntityData {
}

impl super::core::DataBusPeerTrait for PlayerVehicleProximityEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PlayerVehicleProximityEntityData {
}

impl super::core::DataContainerTrait for PlayerVehicleProximityEntityData {
}

pub static PLAYERVEHICLEPROXIMITYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerVehicleProximityEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlayerVehicleProximityEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnterCloseProximityRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerVehicleProximityEntityData, enter_close_proximity_range),
            },
            FieldInfoData {
                name: "ExitCloseProximityRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerVehicleProximityEntityData, exit_close_proximity_range),
            },
            FieldInfoData {
                name: "PlayerPreviousVehicleRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PlayerVehicleProximityEntityData, player_previous_vehicle_range),
            },
        ],
    }),
    array_type: Some(PLAYERVEHICLEPROXIMITYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerVehicleProximityEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PLAYERVEHICLEPROXIMITYENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLAYERVEHICLEPROXIMITYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerVehicleProximityEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PlayerVehicleProximityEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HeavyPlanePilotEntityData {
    pub _glacier_base: PilotEntityData,
    pub max_roll_angle: f32,
    pub yaw_angle_diff_for_max_roll_angle: f32,
    pub squared_roll_angle_curve: bool,
}

pub trait HeavyPlanePilotEntityDataTrait: PilotEntityDataTrait {
    fn max_roll_angle(&self) -> &f32;
    fn max_roll_angle_mut(&mut self) -> &mut f32;
    fn yaw_angle_diff_for_max_roll_angle(&self) -> &f32;
    fn yaw_angle_diff_for_max_roll_angle_mut(&mut self) -> &mut f32;
    fn squared_roll_angle_curve(&self) -> &bool;
    fn squared_roll_angle_curve_mut(&mut self) -> &mut bool;
}

impl HeavyPlanePilotEntityDataTrait for HeavyPlanePilotEntityData {
    fn max_roll_angle(&self) -> &f32 {
        &self.max_roll_angle
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_roll_angle
    }
    fn yaw_angle_diff_for_max_roll_angle(&self) -> &f32 {
        &self.yaw_angle_diff_for_max_roll_angle
    }
    fn yaw_angle_diff_for_max_roll_angle_mut(&mut self) -> &mut f32 {
        &mut self.yaw_angle_diff_for_max_roll_angle
    }
    fn squared_roll_angle_curve(&self) -> &bool {
        &self.squared_roll_angle_curve
    }
    fn squared_roll_angle_curve_mut(&mut self) -> &mut bool {
        &mut self.squared_roll_angle_curve
    }
}

impl PilotEntityDataTrait for HeavyPlanePilotEntityData {
    fn pitch_p_i_d(&self) -> &super::game_shared::PID {
        self._glacier_base.pitch_p_i_d()
    }
    fn pitch_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        self._glacier_base.pitch_p_i_d_mut()
    }
    fn yaw_p_i_d(&self) -> &super::game_shared::PID {
        self._glacier_base.yaw_p_i_d()
    }
    fn yaw_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        self._glacier_base.yaw_p_i_d_mut()
    }
    fn roll_p_i_d(&self) -> &super::game_shared::PID {
        self._glacier_base.roll_p_i_d()
    }
    fn roll_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        self._glacier_base.roll_p_i_d_mut()
    }
    fn throttle_p_i_d(&self) -> &super::game_shared::PID {
        self._glacier_base.throttle_p_i_d()
    }
    fn throttle_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        self._glacier_base.throttle_p_i_d_mut()
    }
    fn auto_level_out_roll(&self) -> &bool {
        self._glacier_base.auto_level_out_roll()
    }
    fn auto_level_out_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.auto_level_out_roll_mut()
    }
    fn max_pitch_angle_diff(&self) -> &f32 {
        self._glacier_base.max_pitch_angle_diff()
    }
    fn max_pitch_angle_diff_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_pitch_angle_diff_mut()
    }
    fn max_yaw_angle_diff(&self) -> &f32 {
        self._glacier_base.max_yaw_angle_diff()
    }
    fn max_yaw_angle_diff_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_yaw_angle_diff_mut()
    }
    fn min_distance(&self) -> &f32 {
        self._glacier_base.min_distance()
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_distance_mut()
    }
    fn maximum_pitch_velocity(&self) -> &f32 {
        self._glacier_base.maximum_pitch_velocity()
    }
    fn maximum_pitch_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.maximum_pitch_velocity_mut()
    }
    fn maximum_yaw_velocity(&self) -> &f32 {
        self._glacier_base.maximum_yaw_velocity()
    }
    fn maximum_yaw_velocity_mut(&mut self) -> &mut f32 {
        self._glacier_base.maximum_yaw_velocity_mut()
    }
    fn dist0(&self) -> &f32 {
        self._glacier_base.dist0()
    }
    fn dist0_mut(&mut self) -> &mut f32 {
        self._glacier_base.dist0_mut()
    }
    fn y_offset0(&self) -> &f32 {
        self._glacier_base.y_offset0()
    }
    fn y_offset0_mut(&mut self) -> &mut f32 {
        self._glacier_base.y_offset0_mut()
    }
    fn dist1(&self) -> &f32 {
        self._glacier_base.dist1()
    }
    fn dist1_mut(&mut self) -> &mut f32 {
        self._glacier_base.dist1_mut()
    }
    fn y_offset1(&self) -> &f32 {
        self._glacier_base.y_offset1()
    }
    fn y_offset1_mut(&mut self) -> &mut f32 {
        self._glacier_base.y_offset1_mut()
    }
    fn dist2(&self) -> &f32 {
        self._glacier_base.dist2()
    }
    fn dist2_mut(&mut self) -> &mut f32 {
        self._glacier_base.dist2_mut()
    }
    fn y_offset2(&self) -> &f32 {
        self._glacier_base.y_offset2()
    }
    fn y_offset2_mut(&mut self) -> &mut f32 {
        self._glacier_base.y_offset2_mut()
    }
}

impl PilotEntityBaseDataTrait for HeavyPlanePilotEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::entity::EntityDataTrait for HeavyPlanePilotEntityData {
}

impl super::entity::GameObjectDataTrait for HeavyPlanePilotEntityData {
}

impl super::core::DataBusPeerTrait for HeavyPlanePilotEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for HeavyPlanePilotEntityData {
}

impl super::core::DataContainerTrait for HeavyPlanePilotEntityData {
}

pub static HEAVYPLANEPILOTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HeavyPlanePilotEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PILOTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HeavyPlanePilotEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxRollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HeavyPlanePilotEntityData, max_roll_angle),
            },
            FieldInfoData {
                name: "YawAngleDiffForMaxRollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HeavyPlanePilotEntityData, yaw_angle_diff_for_max_roll_angle),
            },
            FieldInfoData {
                name: "SquaredRollAngleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(HeavyPlanePilotEntityData, squared_roll_angle_curve),
            },
        ],
    }),
    array_type: Some(HEAVYPLANEPILOTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HeavyPlanePilotEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        HEAVYPLANEPILOTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HEAVYPLANEPILOTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HeavyPlanePilotEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("HeavyPlanePilotEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PilotEntityData {
    pub _glacier_base: PilotEntityBaseData,
    pub pitch_p_i_d: super::game_shared::PID,
    pub yaw_p_i_d: super::game_shared::PID,
    pub roll_p_i_d: super::game_shared::PID,
    pub throttle_p_i_d: super::game_shared::PID,
    pub auto_level_out_roll: bool,
    pub max_pitch_angle_diff: f32,
    pub max_yaw_angle_diff: f32,
    pub min_distance: f32,
    pub maximum_pitch_velocity: f32,
    pub maximum_yaw_velocity: f32,
    pub dist0: f32,
    pub y_offset0: f32,
    pub dist1: f32,
    pub y_offset1: f32,
    pub dist2: f32,
    pub y_offset2: f32,
}

pub trait PilotEntityDataTrait: PilotEntityBaseDataTrait {
    fn pitch_p_i_d(&self) -> &super::game_shared::PID;
    fn pitch_p_i_d_mut(&mut self) -> &mut super::game_shared::PID;
    fn yaw_p_i_d(&self) -> &super::game_shared::PID;
    fn yaw_p_i_d_mut(&mut self) -> &mut super::game_shared::PID;
    fn roll_p_i_d(&self) -> &super::game_shared::PID;
    fn roll_p_i_d_mut(&mut self) -> &mut super::game_shared::PID;
    fn throttle_p_i_d(&self) -> &super::game_shared::PID;
    fn throttle_p_i_d_mut(&mut self) -> &mut super::game_shared::PID;
    fn auto_level_out_roll(&self) -> &bool;
    fn auto_level_out_roll_mut(&mut self) -> &mut bool;
    fn max_pitch_angle_diff(&self) -> &f32;
    fn max_pitch_angle_diff_mut(&mut self) -> &mut f32;
    fn max_yaw_angle_diff(&self) -> &f32;
    fn max_yaw_angle_diff_mut(&mut self) -> &mut f32;
    fn min_distance(&self) -> &f32;
    fn min_distance_mut(&mut self) -> &mut f32;
    fn maximum_pitch_velocity(&self) -> &f32;
    fn maximum_pitch_velocity_mut(&mut self) -> &mut f32;
    fn maximum_yaw_velocity(&self) -> &f32;
    fn maximum_yaw_velocity_mut(&mut self) -> &mut f32;
    fn dist0(&self) -> &f32;
    fn dist0_mut(&mut self) -> &mut f32;
    fn y_offset0(&self) -> &f32;
    fn y_offset0_mut(&mut self) -> &mut f32;
    fn dist1(&self) -> &f32;
    fn dist1_mut(&mut self) -> &mut f32;
    fn y_offset1(&self) -> &f32;
    fn y_offset1_mut(&mut self) -> &mut f32;
    fn dist2(&self) -> &f32;
    fn dist2_mut(&mut self) -> &mut f32;
    fn y_offset2(&self) -> &f32;
    fn y_offset2_mut(&mut self) -> &mut f32;
}

impl PilotEntityDataTrait for PilotEntityData {
    fn pitch_p_i_d(&self) -> &super::game_shared::PID {
        &self.pitch_p_i_d
    }
    fn pitch_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        &mut self.pitch_p_i_d
    }
    fn yaw_p_i_d(&self) -> &super::game_shared::PID {
        &self.yaw_p_i_d
    }
    fn yaw_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        &mut self.yaw_p_i_d
    }
    fn roll_p_i_d(&self) -> &super::game_shared::PID {
        &self.roll_p_i_d
    }
    fn roll_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        &mut self.roll_p_i_d
    }
    fn throttle_p_i_d(&self) -> &super::game_shared::PID {
        &self.throttle_p_i_d
    }
    fn throttle_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        &mut self.throttle_p_i_d
    }
    fn auto_level_out_roll(&self) -> &bool {
        &self.auto_level_out_roll
    }
    fn auto_level_out_roll_mut(&mut self) -> &mut bool {
        &mut self.auto_level_out_roll
    }
    fn max_pitch_angle_diff(&self) -> &f32 {
        &self.max_pitch_angle_diff
    }
    fn max_pitch_angle_diff_mut(&mut self) -> &mut f32 {
        &mut self.max_pitch_angle_diff
    }
    fn max_yaw_angle_diff(&self) -> &f32 {
        &self.max_yaw_angle_diff
    }
    fn max_yaw_angle_diff_mut(&mut self) -> &mut f32 {
        &mut self.max_yaw_angle_diff
    }
    fn min_distance(&self) -> &f32 {
        &self.min_distance
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_distance
    }
    fn maximum_pitch_velocity(&self) -> &f32 {
        &self.maximum_pitch_velocity
    }
    fn maximum_pitch_velocity_mut(&mut self) -> &mut f32 {
        &mut self.maximum_pitch_velocity
    }
    fn maximum_yaw_velocity(&self) -> &f32 {
        &self.maximum_yaw_velocity
    }
    fn maximum_yaw_velocity_mut(&mut self) -> &mut f32 {
        &mut self.maximum_yaw_velocity
    }
    fn dist0(&self) -> &f32 {
        &self.dist0
    }
    fn dist0_mut(&mut self) -> &mut f32 {
        &mut self.dist0
    }
    fn y_offset0(&self) -> &f32 {
        &self.y_offset0
    }
    fn y_offset0_mut(&mut self) -> &mut f32 {
        &mut self.y_offset0
    }
    fn dist1(&self) -> &f32 {
        &self.dist1
    }
    fn dist1_mut(&mut self) -> &mut f32 {
        &mut self.dist1
    }
    fn y_offset1(&self) -> &f32 {
        &self.y_offset1
    }
    fn y_offset1_mut(&mut self) -> &mut f32 {
        &mut self.y_offset1
    }
    fn dist2(&self) -> &f32 {
        &self.dist2
    }
    fn dist2_mut(&mut self) -> &mut f32 {
        &mut self.dist2
    }
    fn y_offset2(&self) -> &f32 {
        &self.y_offset2
    }
    fn y_offset2_mut(&mut self) -> &mut f32 {
        &mut self.y_offset2
    }
}

impl PilotEntityBaseDataTrait for PilotEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::entity::EntityDataTrait for PilotEntityData {
}

impl super::entity::GameObjectDataTrait for PilotEntityData {
}

impl super::core::DataBusPeerTrait for PilotEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PilotEntityData {
}

impl super::core::DataContainerTrait for PilotEntityData {
}

pub static PILOTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PilotEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PILOTENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PilotEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PitchPID",
                flags: MemberInfoFlags::new(0),
                field_type: "PID",
                rust_offset: offset_of!(PilotEntityData, pitch_p_i_d),
            },
            FieldInfoData {
                name: "YawPID",
                flags: MemberInfoFlags::new(0),
                field_type: "PID",
                rust_offset: offset_of!(PilotEntityData, yaw_p_i_d),
            },
            FieldInfoData {
                name: "RollPID",
                flags: MemberInfoFlags::new(0),
                field_type: "PID",
                rust_offset: offset_of!(PilotEntityData, roll_p_i_d),
            },
            FieldInfoData {
                name: "ThrottlePID",
                flags: MemberInfoFlags::new(0),
                field_type: "PID",
                rust_offset: offset_of!(PilotEntityData, throttle_p_i_d),
            },
            FieldInfoData {
                name: "AutoLevelOutRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PilotEntityData, auto_level_out_roll),
            },
            FieldInfoData {
                name: "MaxPitchAngleDiff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, max_pitch_angle_diff),
            },
            FieldInfoData {
                name: "MaxYawAngleDiff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, max_yaw_angle_diff),
            },
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, min_distance),
            },
            FieldInfoData {
                name: "MaximumPitchVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, maximum_pitch_velocity),
            },
            FieldInfoData {
                name: "MaximumYawVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, maximum_yaw_velocity),
            },
            FieldInfoData {
                name: "Dist0",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, dist0),
            },
            FieldInfoData {
                name: "YOffset0",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, y_offset0),
            },
            FieldInfoData {
                name: "Dist1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, dist1),
            },
            FieldInfoData {
                name: "YOffset1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, y_offset1),
            },
            FieldInfoData {
                name: "Dist2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, dist2),
            },
            FieldInfoData {
                name: "YOffset2",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PilotEntityData, y_offset2),
            },
        ],
    }),
    array_type: Some(PILOTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PilotEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PILOTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PILOTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PilotEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PilotEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PilotEntityBaseData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
}

pub trait PilotEntityBaseDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl PilotEntityBaseDataTrait for PilotEntityBaseData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::entity::EntityDataTrait for PilotEntityBaseData {
}

impl super::entity::GameObjectDataTrait for PilotEntityBaseData {
}

impl super::core::DataBusPeerTrait for PilotEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PilotEntityBaseData {
}

impl super::core::DataContainerTrait for PilotEntityBaseData {
}

pub static PILOTENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PilotEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PilotEntityBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PilotEntityBaseData, realm),
            },
        ],
    }),
    array_type: Some(PILOTENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PilotEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        PILOTENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PILOTENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PilotEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PilotEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PathfindingOverrideData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub apply_from_start: bool,
    pub path_sharing_penalty: f32,
    pub max_path_sharing_penalty: f32,
}

pub trait PathfindingOverrideDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn apply_from_start(&self) -> &bool;
    fn apply_from_start_mut(&mut self) -> &mut bool;
    fn path_sharing_penalty(&self) -> &f32;
    fn path_sharing_penalty_mut(&mut self) -> &mut f32;
    fn max_path_sharing_penalty(&self) -> &f32;
    fn max_path_sharing_penalty_mut(&mut self) -> &mut f32;
}

impl PathfindingOverrideDataTrait for PathfindingOverrideData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn apply_from_start(&self) -> &bool {
        &self.apply_from_start
    }
    fn apply_from_start_mut(&mut self) -> &mut bool {
        &mut self.apply_from_start
    }
    fn path_sharing_penalty(&self) -> &f32 {
        &self.path_sharing_penalty
    }
    fn path_sharing_penalty_mut(&mut self) -> &mut f32 {
        &mut self.path_sharing_penalty
    }
    fn max_path_sharing_penalty(&self) -> &f32 {
        &self.max_path_sharing_penalty
    }
    fn max_path_sharing_penalty_mut(&mut self) -> &mut f32 {
        &mut self.max_path_sharing_penalty
    }
}

impl super::entity::EntityDataTrait for PathfindingOverrideData {
}

impl super::entity::GameObjectDataTrait for PathfindingOverrideData {
}

impl super::core::DataBusPeerTrait for PathfindingOverrideData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PathfindingOverrideData {
}

impl super::core::DataContainerTrait for PathfindingOverrideData {
}

pub static PATHFINDINGOVERRIDEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingOverrideData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PathfindingOverrideData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(PathfindingOverrideData, realm),
            },
            FieldInfoData {
                name: "ApplyFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PathfindingOverrideData, apply_from_start),
            },
            FieldInfoData {
                name: "PathSharingPenalty",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PathfindingOverrideData, path_sharing_penalty),
            },
            FieldInfoData {
                name: "MaxPathSharingPenalty",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PathfindingOverrideData, max_path_sharing_penalty),
            },
        ],
    }),
    array_type: Some(PATHFINDINGOVERRIDEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PathfindingOverrideData {
    fn type_info(&self) -> &'static TypeInfo {
        PATHFINDINGOVERRIDEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PATHFINDINGOVERRIDEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingOverrideData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PathfindingOverrideData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PathFollowingComponentData {
    pub _glacier_base: super::pathfinding_shared::PathFollowingComponentBaseData,
}

pub trait PathFollowingComponentDataTrait: super::pathfinding_shared::PathFollowingComponentBaseDataTrait {
}

impl PathFollowingComponentDataTrait for PathFollowingComponentData {
}

impl super::pathfinding_shared::PathFollowingComponentBaseDataTrait for PathFollowingComponentData {
    fn update_path_at_distance_percent(&self) -> &f32 {
        self._glacier_base.update_path_at_distance_percent()
    }
    fn update_path_at_distance_percent_mut(&mut self) -> &mut f32 {
        self._glacier_base.update_path_at_distance_percent_mut()
    }
    fn preferred_pathfinding_index(&self) -> &u32 {
        self._glacier_base.preferred_pathfinding_index()
    }
    fn preferred_pathfinding_index_mut(&mut self) -> &mut u32 {
        self._glacier_base.preferred_pathfinding_index_mut()
    }
    fn alternate_pathfinding_indices(&self) -> &Vec<u32> {
        self._glacier_base.alternate_pathfinding_indices()
    }
    fn alternate_pathfinding_indices_mut(&mut self) -> &mut Vec<u32> {
        self._glacier_base.alternate_pathfinding_indices_mut()
    }
    fn movement_corridor_radius(&self) -> &f32 {
        self._glacier_base.movement_corridor_radius()
    }
    fn movement_corridor_radius_mut(&mut self) -> &mut f32 {
        self._glacier_base.movement_corridor_radius_mut()
    }
}

impl super::entity::GameComponentDataTrait for PathFollowingComponentData {
}

impl super::entity::ComponentDataTrait for PathFollowingComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for PathFollowingComponentData {
}

impl super::core::DataBusPeerTrait for PathFollowingComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PathFollowingComponentData {
}

impl super::core::DataContainerTrait for PathFollowingComponentData {
}

pub static PATHFOLLOWINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathFollowingComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::pathfinding_shared::PATHFOLLOWINGCOMPONENTBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PathFollowingComponentData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PATHFOLLOWINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PathFollowingComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        PATHFOLLOWINGCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PATHFOLLOWINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathFollowingComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PathFollowingComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowWaypointsEntityData {
    pub _glacier_base: super::pathfinding_shared::FollowWaypointsEntityBaseData,
}

pub trait FollowWaypointsEntityDataTrait: super::pathfinding_shared::FollowWaypointsEntityBaseDataTrait {
}

impl FollowWaypointsEntityDataTrait for FollowWaypointsEntityData {
}

impl super::pathfinding_shared::FollowWaypointsEntityBaseDataTrait for FollowWaypointsEntityData {
    fn type_of_route(&self) -> &super::pathfinding_shared::RouteType {
        self._glacier_base.type_of_route()
    }
    fn type_of_route_mut(&mut self) -> &mut super::pathfinding_shared::RouteType {
        self._glacier_base.type_of_route_mut()
    }
    fn use_path_finding(&self) -> &bool {
        self._glacier_base.use_path_finding()
    }
    fn use_path_finding_mut(&mut self) -> &mut bool {
        self._glacier_base.use_path_finding_mut()
    }
    fn start_at_geometrically_closest_waypoint(&self) -> &bool {
        self._glacier_base.start_at_geometrically_closest_waypoint()
    }
    fn start_at_geometrically_closest_waypoint_mut(&mut self) -> &mut bool {
        self._glacier_base.start_at_geometrically_closest_waypoint_mut()
    }
}

impl super::entity::EntityDataTrait for FollowWaypointsEntityData {
}

impl super::entity::GameObjectDataTrait for FollowWaypointsEntityData {
}

impl super::core::DataBusPeerTrait for FollowWaypointsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FollowWaypointsEntityData {
}

impl super::core::DataContainerTrait for FollowWaypointsEntityData {
}

pub static FOLLOWWAYPOINTSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowWaypointsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::pathfinding_shared::FOLLOWWAYPOINTSENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowWaypointsEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FOLLOWWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowWaypointsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWWAYPOINTSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOLLOWWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowWaypointsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowWaypointsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowObjectEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub offset: super::core::Vec3,
    pub radius: f32,
    pub local_offset: bool,
    pub use_path_finding: bool,
    pub target_transform: super::core::LinearTransform,
}

pub trait FollowObjectEntityDataTrait: super::entity::EntityDataTrait {
    fn offset(&self) -> &super::core::Vec3;
    fn offset_mut(&mut self) -> &mut super::core::Vec3;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn local_offset(&self) -> &bool;
    fn local_offset_mut(&mut self) -> &mut bool;
    fn use_path_finding(&self) -> &bool;
    fn use_path_finding_mut(&mut self) -> &mut bool;
    fn target_transform(&self) -> &super::core::LinearTransform;
    fn target_transform_mut(&mut self) -> &mut super::core::LinearTransform;
}

impl FollowObjectEntityDataTrait for FollowObjectEntityData {
    fn offset(&self) -> &super::core::Vec3 {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.offset
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn local_offset(&self) -> &bool {
        &self.local_offset
    }
    fn local_offset_mut(&mut self) -> &mut bool {
        &mut self.local_offset
    }
    fn use_path_finding(&self) -> &bool {
        &self.use_path_finding
    }
    fn use_path_finding_mut(&mut self) -> &mut bool {
        &mut self.use_path_finding
    }
    fn target_transform(&self) -> &super::core::LinearTransform {
        &self.target_transform
    }
    fn target_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.target_transform
    }
}

impl super::entity::EntityDataTrait for FollowObjectEntityData {
}

impl super::entity::GameObjectDataTrait for FollowObjectEntityData {
}

impl super::core::DataBusPeerTrait for FollowObjectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FollowObjectEntityData {
}

impl super::core::DataContainerTrait for FollowObjectEntityData {
}

pub static FOLLOWOBJECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowObjectEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FollowObjectEntityData, offset),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowObjectEntityData, radius),
            },
            FieldInfoData {
                name: "LocalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FollowObjectEntityData, local_offset),
            },
            FieldInfoData {
                name: "UsePathFinding",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FollowObjectEntityData, use_path_finding),
            },
            FieldInfoData {
                name: "TargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(FollowObjectEntityData, target_transform),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FollowObjectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWOBJECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaypointTriggerEntityData {
    pub _glacier_base: super::game_shared::WaypointTriggerEntityBaseData,
    pub realm: super::core::Realm,
}

pub trait WaypointTriggerEntityDataTrait: super::game_shared::WaypointTriggerEntityBaseDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
}

impl WaypointTriggerEntityDataTrait for WaypointTriggerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
}

impl super::game_shared::WaypointTriggerEntityBaseDataTrait for WaypointTriggerEntityData {
}

impl super::entity::EntityDataTrait for WaypointTriggerEntityData {
}

impl super::entity::GameObjectDataTrait for WaypointTriggerEntityData {
}

impl super::core::DataBusPeerTrait for WaypointTriggerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WaypointTriggerEntityData {
}

impl super::core::DataContainerTrait for WaypointTriggerEntityData {
}

pub static WAYPOINTTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::WAYPOINTTRIGGERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaypointTriggerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(WaypointTriggerEntityData, realm),
            },
        ],
    }),
    array_type: Some(WAYPOINTTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaypointTriggerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WAYPOINTTRIGGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WAYPOINTTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WaypointTriggerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PathfindingStreamEntityData {
    pub _glacier_base: super::pathfinding_shared::PathfindingStreamEntityBaseData,
}

pub trait PathfindingStreamEntityDataTrait: super::pathfinding_shared::PathfindingStreamEntityBaseDataTrait {
}

impl PathfindingStreamEntityDataTrait for PathfindingStreamEntityData {
}

impl super::pathfinding_shared::PathfindingStreamEntityBaseDataTrait for PathfindingStreamEntityData {
    fn pathfinding_blobs(&self) -> &Option<Arc<Mutex<dyn super::pathfinding_shared::PathfindingBlobAssetTrait>>> {
        self._glacier_base.pathfinding_blobs()
    }
    fn pathfinding_blobs_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::pathfinding_shared::PathfindingBlobAssetTrait>>> {
        self._glacier_base.pathfinding_blobs_mut()
    }
    fn autoload(&self) -> &bool {
        self._glacier_base.autoload()
    }
    fn autoload_mut(&mut self) -> &mut bool {
        self._glacier_base.autoload_mut()
    }
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
}

impl super::entity::EntityDataTrait for PathfindingStreamEntityData {
}

impl super::entity::GameObjectDataTrait for PathfindingStreamEntityData {
}

impl super::core::DataBusPeerTrait for PathfindingStreamEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for PathfindingStreamEntityData {
}

impl super::core::DataContainerTrait for PathfindingStreamEntityData {
}

pub static PATHFINDINGSTREAMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingStreamEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::pathfinding_shared::PATHFINDINGSTREAMENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PathfindingStreamEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(PATHFINDINGSTREAMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PathfindingStreamEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PATHFINDINGSTREAMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PATHFINDINGSTREAMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingStreamEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PathfindingStreamEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BattleAIPathLinkEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub points: Vec<super::core::Vec3>,
    pub enable_on_init: bool,
    pub direction: AIPathLinkDirection,
    pub link_data: Option<Arc<Mutex<dyn AIPathLinkDataTrait>>>,
}

pub trait BattleAIPathLinkEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn points(&self) -> &Vec<super::core::Vec3>;
    fn points_mut(&mut self) -> &mut Vec<super::core::Vec3>;
    fn enable_on_init(&self) -> &bool;
    fn enable_on_init_mut(&mut self) -> &mut bool;
    fn direction(&self) -> &AIPathLinkDirection;
    fn direction_mut(&mut self) -> &mut AIPathLinkDirection;
    fn link_data(&self) -> &Option<Arc<Mutex<dyn AIPathLinkDataTrait>>>;
    fn link_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIPathLinkDataTrait>>>;
}

impl BattleAIPathLinkEntityDataTrait for BattleAIPathLinkEntityData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        &self.points
    }
    fn points_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        &mut self.points
    }
    fn enable_on_init(&self) -> &bool {
        &self.enable_on_init
    }
    fn enable_on_init_mut(&mut self) -> &mut bool {
        &mut self.enable_on_init
    }
    fn direction(&self) -> &AIPathLinkDirection {
        &self.direction
    }
    fn direction_mut(&mut self) -> &mut AIPathLinkDirection {
        &mut self.direction
    }
    fn link_data(&self) -> &Option<Arc<Mutex<dyn AIPathLinkDataTrait>>> {
        &self.link_data
    }
    fn link_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIPathLinkDataTrait>>> {
        &mut self.link_data
    }
}

impl super::entity::SpatialEntityDataTrait for BattleAIPathLinkEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for BattleAIPathLinkEntityData {
}

impl super::entity::GameObjectDataTrait for BattleAIPathLinkEntityData {
}

impl super::core::DataBusPeerTrait for BattleAIPathLinkEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BattleAIPathLinkEntityData {
}

impl super::core::DataContainerTrait for BattleAIPathLinkEntityData {
}

pub static BATTLEAIPATHLINKENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIPathLinkEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BattleAIPathLinkEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Points",
                flags: MemberInfoFlags::new(144),
                field_type: "Vec3-Array",
                rust_offset: offset_of!(BattleAIPathLinkEntityData, points),
            },
            FieldInfoData {
                name: "EnableOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAIPathLinkEntityData, enable_on_init),
            },
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: "AIPathLinkDirection",
                rust_offset: offset_of!(BattleAIPathLinkEntityData, direction),
            },
            FieldInfoData {
                name: "LinkData",
                flags: MemberInfoFlags::new(0),
                field_type: "AIPathLinkData",
                rust_offset: offset_of!(BattleAIPathLinkEntityData, link_data),
            },
        ],
    }),
    array_type: Some(BATTLEAIPATHLINKENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BattleAIPathLinkEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BATTLEAIPATHLINKENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BATTLEAIPATHLINKENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIPathLinkEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAIPathLinkEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StandardMovePathlinkData {
    pub _glacier_base: AIPathLinkData,
    pub move_data: AILocoMoveTaskData,
}

pub trait StandardMovePathlinkDataTrait: AIPathLinkDataTrait {
    fn move_data(&self) -> &AILocoMoveTaskData;
    fn move_data_mut(&mut self) -> &mut AILocoMoveTaskData;
}

impl StandardMovePathlinkDataTrait for StandardMovePathlinkData {
    fn move_data(&self) -> &AILocoMoveTaskData {
        &self.move_data
    }
    fn move_data_mut(&mut self) -> &mut AILocoMoveTaskData {
        &mut self.move_data
    }
}

impl AIPathLinkDataTrait for StandardMovePathlinkData {
    fn affected_layers(&self) -> &Vec<AIPathfindingLayer> {
        self._glacier_base.affected_layers()
    }
    fn affected_layers_mut(&mut self) -> &mut Vec<AIPathfindingLayer> {
        self._glacier_base.affected_layers_mut()
    }
    fn link_usage_flags(&self) -> &AIPathlinkUsageType {
        self._glacier_base.link_usage_flags()
    }
    fn link_usage_flags_mut(&mut self) -> &mut AIPathlinkUsageType {
        self._glacier_base.link_usage_flags_mut()
    }
    fn penalty(&self) -> &AIPathLinkPenalty {
        self._glacier_base.penalty()
    }
    fn penalty_mut(&mut self) -> &mut AIPathLinkPenalty {
        self._glacier_base.penalty_mut()
    }
    fn max_snap_dist(&self) -> &f32 {
        self._glacier_base.max_snap_dist()
    }
    fn max_snap_dist_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_snap_dist_mut()
    }
    fn may_use_dist(&self) -> &f32 {
        self._glacier_base.may_use_dist()
    }
    fn may_use_dist_mut(&mut self) -> &mut f32 {
        self._glacier_base.may_use_dist_mut()
    }
    fn must_use_dist(&self) -> &f32 {
        self._glacier_base.must_use_dist()
    }
    fn must_use_dist_mut(&mut self) -> &mut f32 {
        self._glacier_base.must_use_dist_mut()
    }
    fn stop_to_use_link(&self) -> &bool {
        self._glacier_base.stop_to_use_link()
    }
    fn stop_to_use_link_mut(&mut self) -> &mut bool {
        self._glacier_base.stop_to_use_link_mut()
    }
    fn max_simultaneous(&self) -> &u32 {
        self._glacier_base.max_simultaneous()
    }
    fn max_simultaneous_mut(&mut self) -> &mut u32 {
        self._glacier_base.max_simultaneous_mut()
    }
    fn base_data(&self) -> &AILocoBaseTaskData {
        self._glacier_base.base_data()
    }
    fn base_data_mut(&mut self) -> &mut AILocoBaseTaskData {
        self._glacier_base.base_data_mut()
    }
}

impl super::core::DataContainerTrait for StandardMovePathlinkData {
}

pub static STANDARDMOVEPATHLINKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StandardMovePathlinkData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPATHLINKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StandardMovePathlinkData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveData",
                flags: MemberInfoFlags::new(0),
                field_type: "AILocoMoveTaskData",
                rust_offset: offset_of!(StandardMovePathlinkData, move_data),
            },
        ],
    }),
    array_type: Some(STANDARDMOVEPATHLINKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StandardMovePathlinkData {
    fn type_info(&self) -> &'static TypeInfo {
        STANDARDMOVEPATHLINKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STANDARDMOVEPATHLINKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StandardMovePathlinkData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StandardMovePathlinkData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScenarioPathlinkData {
    pub _glacier_base: AIPathLinkData,
    pub play_animation: Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>>,
    pub scenario_task: ScenarioTaskData,
}

pub trait ScenarioPathlinkDataTrait: AIPathLinkDataTrait {
    fn play_animation(&self) -> &Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>>;
    fn play_animation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>>;
    fn scenario_task(&self) -> &ScenarioTaskData;
    fn scenario_task_mut(&mut self) -> &mut ScenarioTaskData;
}

impl ScenarioPathlinkDataTrait for ScenarioPathlinkData {
    fn play_animation(&self) -> &Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>> {
        &self.play_animation
    }
    fn play_animation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>> {
        &mut self.play_animation
    }
    fn scenario_task(&self) -> &ScenarioTaskData {
        &self.scenario_task
    }
    fn scenario_task_mut(&mut self) -> &mut ScenarioTaskData {
        &mut self.scenario_task
    }
}

impl AIPathLinkDataTrait for ScenarioPathlinkData {
    fn affected_layers(&self) -> &Vec<AIPathfindingLayer> {
        self._glacier_base.affected_layers()
    }
    fn affected_layers_mut(&mut self) -> &mut Vec<AIPathfindingLayer> {
        self._glacier_base.affected_layers_mut()
    }
    fn link_usage_flags(&self) -> &AIPathlinkUsageType {
        self._glacier_base.link_usage_flags()
    }
    fn link_usage_flags_mut(&mut self) -> &mut AIPathlinkUsageType {
        self._glacier_base.link_usage_flags_mut()
    }
    fn penalty(&self) -> &AIPathLinkPenalty {
        self._glacier_base.penalty()
    }
    fn penalty_mut(&mut self) -> &mut AIPathLinkPenalty {
        self._glacier_base.penalty_mut()
    }
    fn max_snap_dist(&self) -> &f32 {
        self._glacier_base.max_snap_dist()
    }
    fn max_snap_dist_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_snap_dist_mut()
    }
    fn may_use_dist(&self) -> &f32 {
        self._glacier_base.may_use_dist()
    }
    fn may_use_dist_mut(&mut self) -> &mut f32 {
        self._glacier_base.may_use_dist_mut()
    }
    fn must_use_dist(&self) -> &f32 {
        self._glacier_base.must_use_dist()
    }
    fn must_use_dist_mut(&mut self) -> &mut f32 {
        self._glacier_base.must_use_dist_mut()
    }
    fn stop_to_use_link(&self) -> &bool {
        self._glacier_base.stop_to_use_link()
    }
    fn stop_to_use_link_mut(&mut self) -> &mut bool {
        self._glacier_base.stop_to_use_link_mut()
    }
    fn max_simultaneous(&self) -> &u32 {
        self._glacier_base.max_simultaneous()
    }
    fn max_simultaneous_mut(&mut self) -> &mut u32 {
        self._glacier_base.max_simultaneous_mut()
    }
    fn base_data(&self) -> &AILocoBaseTaskData {
        self._glacier_base.base_data()
    }
    fn base_data_mut(&mut self) -> &mut AILocoBaseTaskData {
        self._glacier_base.base_data_mut()
    }
}

impl super::core::DataContainerTrait for ScenarioPathlinkData {
}

pub static SCENARIOPATHLINKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioPathlinkData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPATHLINKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScenarioPathlinkData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlayAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayAnimationData",
                rust_offset: offset_of!(ScenarioPathlinkData, play_animation),
            },
            FieldInfoData {
                name: "ScenarioTask",
                flags: MemberInfoFlags::new(0),
                field_type: "ScenarioTaskData",
                rust_offset: offset_of!(ScenarioPathlinkData, scenario_task),
            },
        ],
    }),
    array_type: Some(SCENARIOPATHLINKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScenarioPathlinkData {
    fn type_info(&self) -> &'static TypeInfo {
        SCENARIOPATHLINKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCENARIOPATHLINKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioPathlinkData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ScenarioPathlinkData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIPathLinkData {
    pub _glacier_base: super::core::DataContainer,
    pub affected_layers: Vec<AIPathfindingLayer>,
    pub link_usage_flags: AIPathlinkUsageType,
    pub penalty: AIPathLinkPenalty,
    pub max_snap_dist: f32,
    pub may_use_dist: f32,
    pub must_use_dist: f32,
    pub stop_to_use_link: bool,
    pub max_simultaneous: u32,
    pub base_data: AILocoBaseTaskData,
}

pub trait AIPathLinkDataTrait: super::core::DataContainerTrait {
    fn affected_layers(&self) -> &Vec<AIPathfindingLayer>;
    fn affected_layers_mut(&mut self) -> &mut Vec<AIPathfindingLayer>;
    fn link_usage_flags(&self) -> &AIPathlinkUsageType;
    fn link_usage_flags_mut(&mut self) -> &mut AIPathlinkUsageType;
    fn penalty(&self) -> &AIPathLinkPenalty;
    fn penalty_mut(&mut self) -> &mut AIPathLinkPenalty;
    fn max_snap_dist(&self) -> &f32;
    fn max_snap_dist_mut(&mut self) -> &mut f32;
    fn may_use_dist(&self) -> &f32;
    fn may_use_dist_mut(&mut self) -> &mut f32;
    fn must_use_dist(&self) -> &f32;
    fn must_use_dist_mut(&mut self) -> &mut f32;
    fn stop_to_use_link(&self) -> &bool;
    fn stop_to_use_link_mut(&mut self) -> &mut bool;
    fn max_simultaneous(&self) -> &u32;
    fn max_simultaneous_mut(&mut self) -> &mut u32;
    fn base_data(&self) -> &AILocoBaseTaskData;
    fn base_data_mut(&mut self) -> &mut AILocoBaseTaskData;
}

impl AIPathLinkDataTrait for AIPathLinkData {
    fn affected_layers(&self) -> &Vec<AIPathfindingLayer> {
        &self.affected_layers
    }
    fn affected_layers_mut(&mut self) -> &mut Vec<AIPathfindingLayer> {
        &mut self.affected_layers
    }
    fn link_usage_flags(&self) -> &AIPathlinkUsageType {
        &self.link_usage_flags
    }
    fn link_usage_flags_mut(&mut self) -> &mut AIPathlinkUsageType {
        &mut self.link_usage_flags
    }
    fn penalty(&self) -> &AIPathLinkPenalty {
        &self.penalty
    }
    fn penalty_mut(&mut self) -> &mut AIPathLinkPenalty {
        &mut self.penalty
    }
    fn max_snap_dist(&self) -> &f32 {
        &self.max_snap_dist
    }
    fn max_snap_dist_mut(&mut self) -> &mut f32 {
        &mut self.max_snap_dist
    }
    fn may_use_dist(&self) -> &f32 {
        &self.may_use_dist
    }
    fn may_use_dist_mut(&mut self) -> &mut f32 {
        &mut self.may_use_dist
    }
    fn must_use_dist(&self) -> &f32 {
        &self.must_use_dist
    }
    fn must_use_dist_mut(&mut self) -> &mut f32 {
        &mut self.must_use_dist
    }
    fn stop_to_use_link(&self) -> &bool {
        &self.stop_to_use_link
    }
    fn stop_to_use_link_mut(&mut self) -> &mut bool {
        &mut self.stop_to_use_link
    }
    fn max_simultaneous(&self) -> &u32 {
        &self.max_simultaneous
    }
    fn max_simultaneous_mut(&mut self) -> &mut u32 {
        &mut self.max_simultaneous
    }
    fn base_data(&self) -> &AILocoBaseTaskData {
        &self.base_data
    }
    fn base_data_mut(&mut self) -> &mut AILocoBaseTaskData {
        &mut self.base_data
    }
}

impl super::core::DataContainerTrait for AIPathLinkData {
}

pub static AIPATHLINKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIPathLinkData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AffectedLayers",
                flags: MemberInfoFlags::new(144),
                field_type: "AIPathfindingLayer-Array",
                rust_offset: offset_of!(AIPathLinkData, affected_layers),
            },
            FieldInfoData {
                name: "LinkUsageFlags",
                flags: MemberInfoFlags::new(0),
                field_type: "AIPathlinkUsageType",
                rust_offset: offset_of!(AIPathLinkData, link_usage_flags),
            },
            FieldInfoData {
                name: "Penalty",
                flags: MemberInfoFlags::new(0),
                field_type: "AIPathLinkPenalty",
                rust_offset: offset_of!(AIPathLinkData, penalty),
            },
            FieldInfoData {
                name: "MaxSnapDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPathLinkData, max_snap_dist),
            },
            FieldInfoData {
                name: "MayUseDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPathLinkData, may_use_dist),
            },
            FieldInfoData {
                name: "MustUseDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIPathLinkData, must_use_dist),
            },
            FieldInfoData {
                name: "StopToUseLink",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIPathLinkData, stop_to_use_link),
            },
            FieldInfoData {
                name: "MaxSimultaneous",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AIPathLinkData, max_simultaneous),
            },
            FieldInfoData {
                name: "BaseData",
                flags: MemberInfoFlags::new(0),
                field_type: "AILocoBaseTaskData",
                rust_offset: offset_of!(AIPathLinkData, base_data),
            },
        ],
    }),
    array_type: Some(AIPATHLINKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIPathLinkData {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHLINKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIPATHLINKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIPathLinkDirection {
    #[default]
    PathLinkDirection_Forward = 0,
    PathLinkDirection_Backward = 1,
    PathLinkDirection_Both = 2,
}

pub static AIPATHLINKDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkDirection",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathLinkDirection {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHLINKDIRECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIPATHLINKDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkDirection-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkDirection"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIPathLinkPenalty {
    #[default]
    PathLinkPenalty_None = 0,
    PathLinkPenalty_StronglyPrefer = 1,
    PathLinkPenalty_Prefer = 2,
    PathLinkPenalty_Light = 3,
    PathLinkPenalty_Moderate = 4,
    PathLinkPenalty_Heavy = 5,
    PathLinkPenalty_Max = 6,
    PathLinkPenalty_NumTypes = 7,
}

pub static AIPATHLINKPENALTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkPenalty",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKPENALTY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathLinkPenalty {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHLINKPENALTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIPATHLINKPENALTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkPenalty-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkPenalty"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIPathLinkType {
    #[default]
    PathLinkType_None = 0,
    PathLinkType_Move = 1,
    PathLinkType_Vault = 2,
    PathLinkType_Scenario = 3,
}

pub static AIPATHLINKTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathLinkType {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHLINKTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIPATHLINKTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIPathLinkGeometryType {
    #[default]
    PathLinkGeometryType_Line = 0,
    PathLinkGeometryType_4Sides = 1,
    PathLinkGeometryType_Rectangular = 2,
}

pub static AIPATHLINKGEOMETRYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkGeometryType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKGEOMETRYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathLinkGeometryType {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHLINKGEOMETRYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIPATHLINKGEOMETRYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkGeometryType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkGeometryType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MoveSettings {
    pub _glacier_base: super::core::DataContainer,
    pub move_style: Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>,
    pub move_speed: MoveSpeed,
    pub fire: bool,
    pub fire_target_distance: f32,
    pub aim_distance_outside_fire_target_distance: f32,
    pub walk: Option<Arc<Mutex<dyn WalkSettingsTrait>>>,
    pub sprint: Option<Arc<Mutex<dyn SprintSettingsTrait>>>,
    pub start_stop: Option<Arc<Mutex<dyn StartStopSettingsTrait>>>,
    pub is_evasive: bool,
    pub is_physics_driven_loco: bool,
    pub start_evasive_threshold: f32,
    pub stop_evasive_threshold: f32,
}

pub trait MoveSettingsTrait: super::core::DataContainerTrait {
    fn move_style(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn move_style_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>>;
    fn move_speed(&self) -> &MoveSpeed;
    fn move_speed_mut(&mut self) -> &mut MoveSpeed;
    fn fire(&self) -> &bool;
    fn fire_mut(&mut self) -> &mut bool;
    fn fire_target_distance(&self) -> &f32;
    fn fire_target_distance_mut(&mut self) -> &mut f32;
    fn aim_distance_outside_fire_target_distance(&self) -> &f32;
    fn aim_distance_outside_fire_target_distance_mut(&mut self) -> &mut f32;
    fn walk(&self) -> &Option<Arc<Mutex<dyn WalkSettingsTrait>>>;
    fn walk_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WalkSettingsTrait>>>;
    fn sprint(&self) -> &Option<Arc<Mutex<dyn SprintSettingsTrait>>>;
    fn sprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SprintSettingsTrait>>>;
    fn start_stop(&self) -> &Option<Arc<Mutex<dyn StartStopSettingsTrait>>>;
    fn start_stop_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StartStopSettingsTrait>>>;
    fn is_evasive(&self) -> &bool;
    fn is_evasive_mut(&mut self) -> &mut bool;
    fn is_physics_driven_loco(&self) -> &bool;
    fn is_physics_driven_loco_mut(&mut self) -> &mut bool;
    fn start_evasive_threshold(&self) -> &f32;
    fn start_evasive_threshold_mut(&mut self) -> &mut f32;
    fn stop_evasive_threshold(&self) -> &f32;
    fn stop_evasive_threshold_mut(&mut self) -> &mut f32;
}

impl MoveSettingsTrait for MoveSettings {
    fn move_style(&self) -> &Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &self.move_style
    }
    fn move_style_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::gameplay_sim::AntEnumerationTrait>>> {
        &mut self.move_style
    }
    fn move_speed(&self) -> &MoveSpeed {
        &self.move_speed
    }
    fn move_speed_mut(&mut self) -> &mut MoveSpeed {
        &mut self.move_speed
    }
    fn fire(&self) -> &bool {
        &self.fire
    }
    fn fire_mut(&mut self) -> &mut bool {
        &mut self.fire
    }
    fn fire_target_distance(&self) -> &f32 {
        &self.fire_target_distance
    }
    fn fire_target_distance_mut(&mut self) -> &mut f32 {
        &mut self.fire_target_distance
    }
    fn aim_distance_outside_fire_target_distance(&self) -> &f32 {
        &self.aim_distance_outside_fire_target_distance
    }
    fn aim_distance_outside_fire_target_distance_mut(&mut self) -> &mut f32 {
        &mut self.aim_distance_outside_fire_target_distance
    }
    fn walk(&self) -> &Option<Arc<Mutex<dyn WalkSettingsTrait>>> {
        &self.walk
    }
    fn walk_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WalkSettingsTrait>>> {
        &mut self.walk
    }
    fn sprint(&self) -> &Option<Arc<Mutex<dyn SprintSettingsTrait>>> {
        &self.sprint
    }
    fn sprint_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SprintSettingsTrait>>> {
        &mut self.sprint
    }
    fn start_stop(&self) -> &Option<Arc<Mutex<dyn StartStopSettingsTrait>>> {
        &self.start_stop
    }
    fn start_stop_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StartStopSettingsTrait>>> {
        &mut self.start_stop
    }
    fn is_evasive(&self) -> &bool {
        &self.is_evasive
    }
    fn is_evasive_mut(&mut self) -> &mut bool {
        &mut self.is_evasive
    }
    fn is_physics_driven_loco(&self) -> &bool {
        &self.is_physics_driven_loco
    }
    fn is_physics_driven_loco_mut(&mut self) -> &mut bool {
        &mut self.is_physics_driven_loco
    }
    fn start_evasive_threshold(&self) -> &f32 {
        &self.start_evasive_threshold
    }
    fn start_evasive_threshold_mut(&mut self) -> &mut f32 {
        &mut self.start_evasive_threshold
    }
    fn stop_evasive_threshold(&self) -> &f32 {
        &self.stop_evasive_threshold
    }
    fn stop_evasive_threshold_mut(&mut self) -> &mut f32 {
        &mut self.stop_evasive_threshold
    }
}

impl super::core::DataContainerTrait for MoveSettings {
}

pub static MOVESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MoveSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveStyle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntEnumeration",
                rust_offset: offset_of!(MoveSettings, move_style),
            },
            FieldInfoData {
                name: "MoveSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "MoveSpeed",
                rust_offset: offset_of!(MoveSettings, move_speed),
            },
            FieldInfoData {
                name: "Fire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MoveSettings, fire),
            },
            FieldInfoData {
                name: "FireTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveSettings, fire_target_distance),
            },
            FieldInfoData {
                name: "AimDistanceOutsideFireTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveSettings, aim_distance_outside_fire_target_distance),
            },
            FieldInfoData {
                name: "Walk",
                flags: MemberInfoFlags::new(0),
                field_type: "WalkSettings",
                rust_offset: offset_of!(MoveSettings, walk),
            },
            FieldInfoData {
                name: "Sprint",
                flags: MemberInfoFlags::new(0),
                field_type: "SprintSettings",
                rust_offset: offset_of!(MoveSettings, sprint),
            },
            FieldInfoData {
                name: "StartStop",
                flags: MemberInfoFlags::new(0),
                field_type: "StartStopSettings",
                rust_offset: offset_of!(MoveSettings, start_stop),
            },
            FieldInfoData {
                name: "IsEvasive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MoveSettings, is_evasive),
            },
            FieldInfoData {
                name: "IsPhysicsDrivenLoco",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MoveSettings, is_physics_driven_loco),
            },
            FieldInfoData {
                name: "StartEvasiveThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveSettings, start_evasive_threshold),
            },
            FieldInfoData {
                name: "StopEvasiveThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MoveSettings, stop_evasive_threshold),
            },
        ],
    }),
    array_type: Some(MOVESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MoveSettings {
    fn type_info(&self) -> &'static TypeInfo {
        MOVESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MOVESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MoveSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StartStopSettings {
    pub _glacier_base: super::core::DataContainer,
    pub upper_range: f32,
    pub lower_range: f32,
    pub ideal_range: f32,
    pub line_of_sight_time: f32,
    pub stop_pose: Pose,
}

pub trait StartStopSettingsTrait: super::core::DataContainerTrait {
    fn upper_range(&self) -> &f32;
    fn upper_range_mut(&mut self) -> &mut f32;
    fn lower_range(&self) -> &f32;
    fn lower_range_mut(&mut self) -> &mut f32;
    fn ideal_range(&self) -> &f32;
    fn ideal_range_mut(&mut self) -> &mut f32;
    fn line_of_sight_time(&self) -> &f32;
    fn line_of_sight_time_mut(&mut self) -> &mut f32;
    fn stop_pose(&self) -> &Pose;
    fn stop_pose_mut(&mut self) -> &mut Pose;
}

impl StartStopSettingsTrait for StartStopSettings {
    fn upper_range(&self) -> &f32 {
        &self.upper_range
    }
    fn upper_range_mut(&mut self) -> &mut f32 {
        &mut self.upper_range
    }
    fn lower_range(&self) -> &f32 {
        &self.lower_range
    }
    fn lower_range_mut(&mut self) -> &mut f32 {
        &mut self.lower_range
    }
    fn ideal_range(&self) -> &f32 {
        &self.ideal_range
    }
    fn ideal_range_mut(&mut self) -> &mut f32 {
        &mut self.ideal_range
    }
    fn line_of_sight_time(&self) -> &f32 {
        &self.line_of_sight_time
    }
    fn line_of_sight_time_mut(&mut self) -> &mut f32 {
        &mut self.line_of_sight_time
    }
    fn stop_pose(&self) -> &Pose {
        &self.stop_pose
    }
    fn stop_pose_mut(&mut self) -> &mut Pose {
        &mut self.stop_pose
    }
}

impl super::core::DataContainerTrait for StartStopSettings {
}

pub static STARTSTOPSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartStopSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StartStopSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UpperRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StartStopSettings, upper_range),
            },
            FieldInfoData {
                name: "LowerRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StartStopSettings, lower_range),
            },
            FieldInfoData {
                name: "IdealRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StartStopSettings, ideal_range),
            },
            FieldInfoData {
                name: "LineOfSightTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StartStopSettings, line_of_sight_time),
            },
            FieldInfoData {
                name: "StopPose",
                flags: MemberInfoFlags::new(0),
                field_type: "Pose",
                rust_offset: offset_of!(StartStopSettings, stop_pose),
            },
        ],
    }),
    array_type: Some(STARTSTOPSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StartStopSettings {
    fn type_info(&self) -> &'static TypeInfo {
        STARTSTOPSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STARTSTOPSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartStopSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StartStopSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WalkSettings {
    pub _glacier_base: super::core::DataContainer,
    pub start_walking_distance: f32,
    pub stop_walking_distance: f32,
    pub require_line_of_sight: bool,
}

pub trait WalkSettingsTrait: super::core::DataContainerTrait {
    fn start_walking_distance(&self) -> &f32;
    fn start_walking_distance_mut(&mut self) -> &mut f32;
    fn stop_walking_distance(&self) -> &f32;
    fn stop_walking_distance_mut(&mut self) -> &mut f32;
    fn require_line_of_sight(&self) -> &bool;
    fn require_line_of_sight_mut(&mut self) -> &mut bool;
}

impl WalkSettingsTrait for WalkSettings {
    fn start_walking_distance(&self) -> &f32 {
        &self.start_walking_distance
    }
    fn start_walking_distance_mut(&mut self) -> &mut f32 {
        &mut self.start_walking_distance
    }
    fn stop_walking_distance(&self) -> &f32 {
        &self.stop_walking_distance
    }
    fn stop_walking_distance_mut(&mut self) -> &mut f32 {
        &mut self.stop_walking_distance
    }
    fn require_line_of_sight(&self) -> &bool {
        &self.require_line_of_sight
    }
    fn require_line_of_sight_mut(&mut self) -> &mut bool {
        &mut self.require_line_of_sight
    }
}

impl super::core::DataContainerTrait for WalkSettings {
}

pub static WALKSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WalkSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WalkSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartWalkingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WalkSettings, start_walking_distance),
            },
            FieldInfoData {
                name: "StopWalkingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WalkSettings, stop_walking_distance),
            },
            FieldInfoData {
                name: "RequireLineOfSight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WalkSettings, require_line_of_sight),
            },
        ],
    }),
    array_type: Some(WALKSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WalkSettings {
    fn type_info(&self) -> &'static TypeInfo {
        WALKSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WALKSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WalkSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WalkSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SprintSettings {
    pub _glacier_base: super::core::DataContainer,
    pub start_sprinting_threshold: f32,
    pub stop_sprinting_threshold: f32,
    pub stop_sprinting_distance_to_target: f32,
    pub start_sprinting_distance_to_target: f32,
}

pub trait SprintSettingsTrait: super::core::DataContainerTrait {
    fn start_sprinting_threshold(&self) -> &f32;
    fn start_sprinting_threshold_mut(&mut self) -> &mut f32;
    fn stop_sprinting_threshold(&self) -> &f32;
    fn stop_sprinting_threshold_mut(&mut self) -> &mut f32;
    fn stop_sprinting_distance_to_target(&self) -> &f32;
    fn stop_sprinting_distance_to_target_mut(&mut self) -> &mut f32;
    fn start_sprinting_distance_to_target(&self) -> &f32;
    fn start_sprinting_distance_to_target_mut(&mut self) -> &mut f32;
}

impl SprintSettingsTrait for SprintSettings {
    fn start_sprinting_threshold(&self) -> &f32 {
        &self.start_sprinting_threshold
    }
    fn start_sprinting_threshold_mut(&mut self) -> &mut f32 {
        &mut self.start_sprinting_threshold
    }
    fn stop_sprinting_threshold(&self) -> &f32 {
        &self.stop_sprinting_threshold
    }
    fn stop_sprinting_threshold_mut(&mut self) -> &mut f32 {
        &mut self.stop_sprinting_threshold
    }
    fn stop_sprinting_distance_to_target(&self) -> &f32 {
        &self.stop_sprinting_distance_to_target
    }
    fn stop_sprinting_distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.stop_sprinting_distance_to_target
    }
    fn start_sprinting_distance_to_target(&self) -> &f32 {
        &self.start_sprinting_distance_to_target
    }
    fn start_sprinting_distance_to_target_mut(&mut self) -> &mut f32 {
        &mut self.start_sprinting_distance_to_target
    }
}

impl super::core::DataContainerTrait for SprintSettings {
}

pub static SPRINTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SprintSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SprintSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartSprintingThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SprintSettings, start_sprinting_threshold),
            },
            FieldInfoData {
                name: "StopSprintingThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SprintSettings, stop_sprinting_threshold),
            },
            FieldInfoData {
                name: "StopSprintingDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SprintSettings, stop_sprinting_distance_to_target),
            },
            FieldInfoData {
                name: "StartSprintingDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SprintSettings, start_sprinting_distance_to_target),
            },
        ],
    }),
    array_type: Some(SPRINTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SprintSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SPRINTSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPRINTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SprintSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SprintSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum Pose {
    #[default]
    Pose_Stand = 0,
    Pose_Crouch = 1,
    Pose_NoPreference = 2,
}

pub static POSE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pose",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(POSE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Pose {
    fn type_info(&self) -> &'static TypeInfo {
        POSE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static POSE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pose-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Pose"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MoveSpeed {
    #[default]
    MoveSpeed_Walk = 0,
    MoveSpeed_Run = 1,
    MoveSpeed_Sprint = 2,
}

pub static MOVESPEED_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveSpeed",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(MOVESPEED_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MoveSpeed {
    fn type_info(&self) -> &'static TypeInfo {
        MOVESPEED_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MOVESPEED_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveSpeed-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MoveSpeed"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateSettingsOverrideData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub apply_from_start: bool,
    pub investigate_type: InvestigateOverrideType,
    pub min_dist_from_investigate_pos: f32,
    pub max_dist_from_investigate_pos: f32,
    pub secondary_inspect_min_dist: f32,
    pub secondary_inspect_max_dist: f32,
}

pub trait InvestigateSettingsOverrideDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn apply_from_start(&self) -> &bool;
    fn apply_from_start_mut(&mut self) -> &mut bool;
    fn investigate_type(&self) -> &InvestigateOverrideType;
    fn investigate_type_mut(&mut self) -> &mut InvestigateOverrideType;
    fn min_dist_from_investigate_pos(&self) -> &f32;
    fn min_dist_from_investigate_pos_mut(&mut self) -> &mut f32;
    fn max_dist_from_investigate_pos(&self) -> &f32;
    fn max_dist_from_investigate_pos_mut(&mut self) -> &mut f32;
    fn secondary_inspect_min_dist(&self) -> &f32;
    fn secondary_inspect_min_dist_mut(&mut self) -> &mut f32;
    fn secondary_inspect_max_dist(&self) -> &f32;
    fn secondary_inspect_max_dist_mut(&mut self) -> &mut f32;
}

impl InvestigateSettingsOverrideDataTrait for InvestigateSettingsOverrideData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn apply_from_start(&self) -> &bool {
        &self.apply_from_start
    }
    fn apply_from_start_mut(&mut self) -> &mut bool {
        &mut self.apply_from_start
    }
    fn investigate_type(&self) -> &InvestigateOverrideType {
        &self.investigate_type
    }
    fn investigate_type_mut(&mut self) -> &mut InvestigateOverrideType {
        &mut self.investigate_type
    }
    fn min_dist_from_investigate_pos(&self) -> &f32 {
        &self.min_dist_from_investigate_pos
    }
    fn min_dist_from_investigate_pos_mut(&mut self) -> &mut f32 {
        &mut self.min_dist_from_investigate_pos
    }
    fn max_dist_from_investigate_pos(&self) -> &f32 {
        &self.max_dist_from_investigate_pos
    }
    fn max_dist_from_investigate_pos_mut(&mut self) -> &mut f32 {
        &mut self.max_dist_from_investigate_pos
    }
    fn secondary_inspect_min_dist(&self) -> &f32 {
        &self.secondary_inspect_min_dist
    }
    fn secondary_inspect_min_dist_mut(&mut self) -> &mut f32 {
        &mut self.secondary_inspect_min_dist
    }
    fn secondary_inspect_max_dist(&self) -> &f32 {
        &self.secondary_inspect_max_dist
    }
    fn secondary_inspect_max_dist_mut(&mut self) -> &mut f32 {
        &mut self.secondary_inspect_max_dist
    }
}

impl super::entity::EntityDataTrait for InvestigateSettingsOverrideData {
}

impl super::entity::GameObjectDataTrait for InvestigateSettingsOverrideData {
}

impl super::core::DataBusPeerTrait for InvestigateSettingsOverrideData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for InvestigateSettingsOverrideData {
}

impl super::core::DataContainerTrait for InvestigateSettingsOverrideData {
}

pub static INVESTIGATESETTINGSOVERRIDEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettingsOverrideData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateSettingsOverrideData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(InvestigateSettingsOverrideData, realm),
            },
            FieldInfoData {
                name: "ApplyFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettingsOverrideData, apply_from_start),
            },
            FieldInfoData {
                name: "InvestigateType",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateOverrideType",
                rust_offset: offset_of!(InvestigateSettingsOverrideData, investigate_type),
            },
            FieldInfoData {
                name: "MinDistFromInvestigatePos",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettingsOverrideData, min_dist_from_investigate_pos),
            },
            FieldInfoData {
                name: "MaxDistFromInvestigatePos",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettingsOverrideData, max_dist_from_investigate_pos),
            },
            FieldInfoData {
                name: "SecondaryInspectMinDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettingsOverrideData, secondary_inspect_min_dist),
            },
            FieldInfoData {
                name: "SecondaryInspectMaxDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettingsOverrideData, secondary_inspect_max_dist),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTINGSOVERRIDEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InvestigateSettingsOverrideData {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATESETTINGSOVERRIDEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static INVESTIGATESETTINGSOVERRIDEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettingsOverrideData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettingsOverrideData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum InvestigateOverrideType {
    #[default]
    InvestigateOverrideType_IdleInvestigate = 0,
    InvestigateOverrideType_CombatInvestigate = 1,
    InvestigateOverrideType_CombatSearchArea = 2,
    InvestigateOverrideType_SearchArea = 3,
    InvestigateOverrideType_Count = 4,
}

pub static INVESTIGATEOVERRIDETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateOverrideType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(INVESTIGATEOVERRIDETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for InvestigateOverrideType {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATEOVERRIDETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INVESTIGATEOVERRIDETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateOverrideType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateOverrideType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateSettignsCustomizations {
    pub enabled: bool,
    pub multiple_investigators_settings: InvestigateSettingsMultipleInvestigators,
    pub idle: InvestigateSettignsCustomization,
    pub combat: InvestigateSettignsCustomization,
    pub combat_search_area: InvestigateSettignsCustomization,
    pub search_area: InvestigateSettignsCustomization,
}

pub trait InvestigateSettignsCustomizationsTrait: TypeObject {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn multiple_investigators_settings(&self) -> &InvestigateSettingsMultipleInvestigators;
    fn multiple_investigators_settings_mut(&mut self) -> &mut InvestigateSettingsMultipleInvestigators;
    fn idle(&self) -> &InvestigateSettignsCustomization;
    fn idle_mut(&mut self) -> &mut InvestigateSettignsCustomization;
    fn combat(&self) -> &InvestigateSettignsCustomization;
    fn combat_mut(&mut self) -> &mut InvestigateSettignsCustomization;
    fn combat_search_area(&self) -> &InvestigateSettignsCustomization;
    fn combat_search_area_mut(&mut self) -> &mut InvestigateSettignsCustomization;
    fn search_area(&self) -> &InvestigateSettignsCustomization;
    fn search_area_mut(&mut self) -> &mut InvestigateSettignsCustomization;
}

impl InvestigateSettignsCustomizationsTrait for InvestigateSettignsCustomizations {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn multiple_investigators_settings(&self) -> &InvestigateSettingsMultipleInvestigators {
        &self.multiple_investigators_settings
    }
    fn multiple_investigators_settings_mut(&mut self) -> &mut InvestigateSettingsMultipleInvestigators {
        &mut self.multiple_investigators_settings
    }
    fn idle(&self) -> &InvestigateSettignsCustomization {
        &self.idle
    }
    fn idle_mut(&mut self) -> &mut InvestigateSettignsCustomization {
        &mut self.idle
    }
    fn combat(&self) -> &InvestigateSettignsCustomization {
        &self.combat
    }
    fn combat_mut(&mut self) -> &mut InvestigateSettignsCustomization {
        &mut self.combat
    }
    fn combat_search_area(&self) -> &InvestigateSettignsCustomization {
        &self.combat_search_area
    }
    fn combat_search_area_mut(&mut self) -> &mut InvestigateSettignsCustomization {
        &mut self.combat_search_area
    }
    fn search_area(&self) -> &InvestigateSettignsCustomization {
        &self.search_area
    }
    fn search_area_mut(&mut self) -> &mut InvestigateSettignsCustomization {
        &mut self.search_area
    }
}

pub static INVESTIGATESETTIGNSCUSTOMIZATIONS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsCustomizations",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateSettignsCustomizations as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettignsCustomizations, enabled),
            },
            FieldInfoData {
                name: "MultipleInvestigatorsSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettingsMultipleInvestigators",
                rust_offset: offset_of!(InvestigateSettignsCustomizations, multiple_investigators_settings),
            },
            FieldInfoData {
                name: "Idle",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettignsCustomization",
                rust_offset: offset_of!(InvestigateSettignsCustomizations, idle),
            },
            FieldInfoData {
                name: "Combat",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettignsCustomization",
                rust_offset: offset_of!(InvestigateSettignsCustomizations, combat),
            },
            FieldInfoData {
                name: "CombatSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettignsCustomization",
                rust_offset: offset_of!(InvestigateSettignsCustomizations, combat_search_area),
            },
            FieldInfoData {
                name: "SearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettignsCustomization",
                rust_offset: offset_of!(InvestigateSettignsCustomizations, search_area),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTIGNSCUSTOMIZATIONS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettignsCustomizations {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATESETTIGNSCUSTOMIZATIONS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INVESTIGATESETTIGNSCUSTOMIZATIONS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsCustomizations-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettignsCustomizations"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateSettignsCustomization {
    pub enabled: bool,
    pub min_time_before_reinvestigating_same_position: f32,
    pub settings: InvestigateSettigns,
}

pub trait InvestigateSettignsCustomizationTrait: TypeObject {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn min_time_before_reinvestigating_same_position(&self) -> &f32;
    fn min_time_before_reinvestigating_same_position_mut(&mut self) -> &mut f32;
    fn settings(&self) -> &InvestigateSettigns;
    fn settings_mut(&mut self) -> &mut InvestigateSettigns;
}

impl InvestigateSettignsCustomizationTrait for InvestigateSettignsCustomization {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn min_time_before_reinvestigating_same_position(&self) -> &f32 {
        &self.min_time_before_reinvestigating_same_position
    }
    fn min_time_before_reinvestigating_same_position_mut(&mut self) -> &mut f32 {
        &mut self.min_time_before_reinvestigating_same_position
    }
    fn settings(&self) -> &InvestigateSettigns {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut InvestigateSettigns {
        &mut self.settings
    }
}

pub static INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsCustomization",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateSettignsCustomization as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettignsCustomization, enabled),
            },
            FieldInfoData {
                name: "MinTimeBeforeReinvestigatingSamePosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettignsCustomization, min_time_before_reinvestigating_same_position),
            },
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettigns",
                rust_offset: offset_of!(InvestigateSettignsCustomization, settings),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTIGNSCUSTOMIZATION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettignsCustomization {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INVESTIGATESETTIGNSCUSTOMIZATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsCustomization-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettignsCustomization"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateSettigns {
    pub max_investigators: i32,
    pub can_stand_in_place_and_look: bool,
    pub can_get_closer_if_obstructed: bool,
    pub min_dist_if_obstruscted: f32,
    pub knowledge_share: InvestigateSettignsKnowledgeSharing,
    pub end_conditions: InvestigateEndConditions,
}

pub trait InvestigateSettignsTrait: TypeObject {
    fn max_investigators(&self) -> &i32;
    fn max_investigators_mut(&mut self) -> &mut i32;
    fn can_stand_in_place_and_look(&self) -> &bool;
    fn can_stand_in_place_and_look_mut(&mut self) -> &mut bool;
    fn can_get_closer_if_obstructed(&self) -> &bool;
    fn can_get_closer_if_obstructed_mut(&mut self) -> &mut bool;
    fn min_dist_if_obstruscted(&self) -> &f32;
    fn min_dist_if_obstruscted_mut(&mut self) -> &mut f32;
    fn knowledge_share(&self) -> &InvestigateSettignsKnowledgeSharing;
    fn knowledge_share_mut(&mut self) -> &mut InvestigateSettignsKnowledgeSharing;
    fn end_conditions(&self) -> &InvestigateEndConditions;
    fn end_conditions_mut(&mut self) -> &mut InvestigateEndConditions;
}

impl InvestigateSettignsTrait for InvestigateSettigns {
    fn max_investigators(&self) -> &i32 {
        &self.max_investigators
    }
    fn max_investigators_mut(&mut self) -> &mut i32 {
        &mut self.max_investigators
    }
    fn can_stand_in_place_and_look(&self) -> &bool {
        &self.can_stand_in_place_and_look
    }
    fn can_stand_in_place_and_look_mut(&mut self) -> &mut bool {
        &mut self.can_stand_in_place_and_look
    }
    fn can_get_closer_if_obstructed(&self) -> &bool {
        &self.can_get_closer_if_obstructed
    }
    fn can_get_closer_if_obstructed_mut(&mut self) -> &mut bool {
        &mut self.can_get_closer_if_obstructed
    }
    fn min_dist_if_obstruscted(&self) -> &f32 {
        &self.min_dist_if_obstruscted
    }
    fn min_dist_if_obstruscted_mut(&mut self) -> &mut f32 {
        &mut self.min_dist_if_obstruscted
    }
    fn knowledge_share(&self) -> &InvestigateSettignsKnowledgeSharing {
        &self.knowledge_share
    }
    fn knowledge_share_mut(&mut self) -> &mut InvestigateSettignsKnowledgeSharing {
        &mut self.knowledge_share
    }
    fn end_conditions(&self) -> &InvestigateEndConditions {
        &self.end_conditions
    }
    fn end_conditions_mut(&mut self) -> &mut InvestigateEndConditions {
        &mut self.end_conditions
    }
}

pub static INVESTIGATESETTIGNS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettigns",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateSettigns as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxInvestigators",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InvestigateSettigns, max_investigators),
            },
            FieldInfoData {
                name: "CanStandInPlaceAndLook",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettigns, can_stand_in_place_and_look),
            },
            FieldInfoData {
                name: "CanGetCloserIfObstructed",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettigns, can_get_closer_if_obstructed),
            },
            FieldInfoData {
                name: "MinDistIfObstruscted",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettigns, min_dist_if_obstruscted),
            },
            FieldInfoData {
                name: "KnowledgeShare",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettignsKnowledgeSharing",
                rust_offset: offset_of!(InvestigateSettigns, knowledge_share),
            },
            FieldInfoData {
                name: "EndConditions",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateEndConditions",
                rust_offset: offset_of!(InvestigateSettigns, end_conditions),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTIGNS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettigns {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATESETTIGNS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INVESTIGATESETTIGNS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettigns-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettigns"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateSettingsMultipleInvestigators {
    pub max_distance_from_investigate_point: f32,
    pub max_attempts: i32,
    pub dist_tolerance: f32,
}

pub trait InvestigateSettingsMultipleInvestigatorsTrait: TypeObject {
    fn max_distance_from_investigate_point(&self) -> &f32;
    fn max_distance_from_investigate_point_mut(&mut self) -> &mut f32;
    fn max_attempts(&self) -> &i32;
    fn max_attempts_mut(&mut self) -> &mut i32;
    fn dist_tolerance(&self) -> &f32;
    fn dist_tolerance_mut(&mut self) -> &mut f32;
}

impl InvestigateSettingsMultipleInvestigatorsTrait for InvestigateSettingsMultipleInvestigators {
    fn max_distance_from_investigate_point(&self) -> &f32 {
        &self.max_distance_from_investigate_point
    }
    fn max_distance_from_investigate_point_mut(&mut self) -> &mut f32 {
        &mut self.max_distance_from_investigate_point
    }
    fn max_attempts(&self) -> &i32 {
        &self.max_attempts
    }
    fn max_attempts_mut(&mut self) -> &mut i32 {
        &mut self.max_attempts
    }
    fn dist_tolerance(&self) -> &f32 {
        &self.dist_tolerance
    }
    fn dist_tolerance_mut(&mut self) -> &mut f32 {
        &mut self.dist_tolerance
    }
}

pub static INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettingsMultipleInvestigators",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateSettingsMultipleInvestigators as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxDistanceFromInvestigatePoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettingsMultipleInvestigators, max_distance_from_investigate_point),
            },
            FieldInfoData {
                name: "MaxAttempts",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(InvestigateSettingsMultipleInvestigators, max_attempts),
            },
            FieldInfoData {
                name: "DistTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettingsMultipleInvestigators, dist_tolerance),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettingsMultipleInvestigators {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettingsMultipleInvestigators-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettingsMultipleInvestigators"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateEndConditions {
    pub end_on_area_cleared: InvestigateEndOnAreaCleared,
}

pub trait InvestigateEndConditionsTrait: TypeObject {
    fn end_on_area_cleared(&self) -> &InvestigateEndOnAreaCleared;
    fn end_on_area_cleared_mut(&mut self) -> &mut InvestigateEndOnAreaCleared;
}

impl InvestigateEndConditionsTrait for InvestigateEndConditions {
    fn end_on_area_cleared(&self) -> &InvestigateEndOnAreaCleared {
        &self.end_on_area_cleared
    }
    fn end_on_area_cleared_mut(&mut self) -> &mut InvestigateEndOnAreaCleared {
        &mut self.end_on_area_cleared
    }
}

pub static INVESTIGATEENDCONDITIONS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateEndConditions",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateEndConditions as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EndOnAreaCleared",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateEndOnAreaCleared",
                rust_offset: offset_of!(InvestigateEndConditions, end_on_area_cleared),
            },
        ],
    }),
    array_type: Some(INVESTIGATEENDCONDITIONS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateEndConditions {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATEENDCONDITIONS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INVESTIGATEENDCONDITIONS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateEndConditions-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateEndConditions"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateEndOnAreaCleared {
    pub enable: bool,
    pub time_since_area_cleared: f32,
}

pub trait InvestigateEndOnAreaClearedTrait: TypeObject {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn time_since_area_cleared(&self) -> &f32;
    fn time_since_area_cleared_mut(&mut self) -> &mut f32;
}

impl InvestigateEndOnAreaClearedTrait for InvestigateEndOnAreaCleared {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn time_since_area_cleared(&self) -> &f32 {
        &self.time_since_area_cleared
    }
    fn time_since_area_cleared_mut(&mut self) -> &mut f32 {
        &mut self.time_since_area_cleared
    }
}

pub static INVESTIGATEENDONAREACLEARED_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateEndOnAreaCleared",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateEndOnAreaCleared as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateEndOnAreaCleared, enable),
            },
            FieldInfoData {
                name: "TimeSinceAreaCleared",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateEndOnAreaCleared, time_since_area_cleared),
            },
        ],
    }),
    array_type: Some(INVESTIGATEENDONAREACLEARED_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateEndOnAreaCleared {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATEENDONAREACLEARED_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INVESTIGATEENDONAREACLEARED_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateEndOnAreaCleared-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateEndOnAreaCleared"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateSettignsKnowledgeSharing {
    pub enabled: bool,
    pub max_share_distance: f32,
}

pub trait InvestigateSettignsKnowledgeSharingTrait: TypeObject {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn max_share_distance(&self) -> &f32;
    fn max_share_distance_mut(&mut self) -> &mut f32;
}

impl InvestigateSettignsKnowledgeSharingTrait for InvestigateSettignsKnowledgeSharing {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn max_share_distance(&self) -> &f32 {
        &self.max_share_distance
    }
    fn max_share_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_share_distance
    }
}

pub static INVESTIGATESETTIGNSKNOWLEDGESHARING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsKnowledgeSharing",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateSettignsKnowledgeSharing as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateSettignsKnowledgeSharing, enabled),
            },
            FieldInfoData {
                name: "MaxShareDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateSettignsKnowledgeSharing, max_share_distance),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTIGNSKNOWLEDGESHARING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettignsKnowledgeSharing {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATESETTIGNSKNOWLEDGESHARING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INVESTIGATESETTIGNSKNOWLEDGESHARING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsKnowledgeSharing-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettignsKnowledgeSharing"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameTweakData {
    pub _glacier_base: super::game_shared::GameAIDifficultyData,
    pub common: GameTweakCommon,
    pub a_i_targeting: GameTweakAITargeting,
    pub bucket_damage_ai_vs_human: GameTweakBucketDamage,
    pub bucket_damage_ai_vs_ai: GameTweakBucketDamage,
    pub sniper: GameTweakSniper,
    pub panic: GameTweakPanicBehavior,
    pub blinded: GameTweakBlindedBehavior,
    pub a_i_sound_defaults: AISoundDefaults,
    pub team_settings: Vec<TeamSettings>,
}

pub trait GameTweakDataTrait: super::game_shared::GameAIDifficultyDataTrait {
    fn common(&self) -> &GameTweakCommon;
    fn common_mut(&mut self) -> &mut GameTweakCommon;
    fn a_i_targeting(&self) -> &GameTweakAITargeting;
    fn a_i_targeting_mut(&mut self) -> &mut GameTweakAITargeting;
    fn bucket_damage_ai_vs_human(&self) -> &GameTweakBucketDamage;
    fn bucket_damage_ai_vs_human_mut(&mut self) -> &mut GameTweakBucketDamage;
    fn bucket_damage_ai_vs_ai(&self) -> &GameTweakBucketDamage;
    fn bucket_damage_ai_vs_ai_mut(&mut self) -> &mut GameTweakBucketDamage;
    fn sniper(&self) -> &GameTweakSniper;
    fn sniper_mut(&mut self) -> &mut GameTweakSniper;
    fn panic(&self) -> &GameTweakPanicBehavior;
    fn panic_mut(&mut self) -> &mut GameTweakPanicBehavior;
    fn blinded(&self) -> &GameTweakBlindedBehavior;
    fn blinded_mut(&mut self) -> &mut GameTweakBlindedBehavior;
    fn a_i_sound_defaults(&self) -> &AISoundDefaults;
    fn a_i_sound_defaults_mut(&mut self) -> &mut AISoundDefaults;
    fn team_settings(&self) -> &Vec<TeamSettings>;
    fn team_settings_mut(&mut self) -> &mut Vec<TeamSettings>;
}

impl GameTweakDataTrait for GameTweakData {
    fn common(&self) -> &GameTweakCommon {
        &self.common
    }
    fn common_mut(&mut self) -> &mut GameTweakCommon {
        &mut self.common
    }
    fn a_i_targeting(&self) -> &GameTweakAITargeting {
        &self.a_i_targeting
    }
    fn a_i_targeting_mut(&mut self) -> &mut GameTweakAITargeting {
        &mut self.a_i_targeting
    }
    fn bucket_damage_ai_vs_human(&self) -> &GameTweakBucketDamage {
        &self.bucket_damage_ai_vs_human
    }
    fn bucket_damage_ai_vs_human_mut(&mut self) -> &mut GameTweakBucketDamage {
        &mut self.bucket_damage_ai_vs_human
    }
    fn bucket_damage_ai_vs_ai(&self) -> &GameTweakBucketDamage {
        &self.bucket_damage_ai_vs_ai
    }
    fn bucket_damage_ai_vs_ai_mut(&mut self) -> &mut GameTweakBucketDamage {
        &mut self.bucket_damage_ai_vs_ai
    }
    fn sniper(&self) -> &GameTweakSniper {
        &self.sniper
    }
    fn sniper_mut(&mut self) -> &mut GameTweakSniper {
        &mut self.sniper
    }
    fn panic(&self) -> &GameTweakPanicBehavior {
        &self.panic
    }
    fn panic_mut(&mut self) -> &mut GameTweakPanicBehavior {
        &mut self.panic
    }
    fn blinded(&self) -> &GameTweakBlindedBehavior {
        &self.blinded
    }
    fn blinded_mut(&mut self) -> &mut GameTweakBlindedBehavior {
        &mut self.blinded
    }
    fn a_i_sound_defaults(&self) -> &AISoundDefaults {
        &self.a_i_sound_defaults
    }
    fn a_i_sound_defaults_mut(&mut self) -> &mut AISoundDefaults {
        &mut self.a_i_sound_defaults
    }
    fn team_settings(&self) -> &Vec<TeamSettings> {
        &self.team_settings
    }
    fn team_settings_mut(&mut self) -> &mut Vec<TeamSettings> {
        &mut self.team_settings
    }
}

impl super::game_shared::GameAIDifficultyDataTrait for GameTweakData {
}

impl super::core::DataContainerTrait for GameTweakData {
}

pub static GAMETWEAKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::game_shared::GAMEAIDIFFICULTYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameTweakData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Common",
                flags: MemberInfoFlags::new(0),
                field_type: "GameTweakCommon",
                rust_offset: offset_of!(GameTweakData, common),
            },
            FieldInfoData {
                name: "AITargeting",
                flags: MemberInfoFlags::new(0),
                field_type: "GameTweakAITargeting",
                rust_offset: offset_of!(GameTweakData, a_i_targeting),
            },
            FieldInfoData {
                name: "BucketDamageAiVsHuman",
                flags: MemberInfoFlags::new(0),
                field_type: "GameTweakBucketDamage",
                rust_offset: offset_of!(GameTweakData, bucket_damage_ai_vs_human),
            },
            FieldInfoData {
                name: "BucketDamageAiVsAi",
                flags: MemberInfoFlags::new(0),
                field_type: "GameTweakBucketDamage",
                rust_offset: offset_of!(GameTweakData, bucket_damage_ai_vs_ai),
            },
            FieldInfoData {
                name: "Sniper",
                flags: MemberInfoFlags::new(0),
                field_type: "GameTweakSniper",
                rust_offset: offset_of!(GameTweakData, sniper),
            },
            FieldInfoData {
                name: "Panic",
                flags: MemberInfoFlags::new(0),
                field_type: "GameTweakPanicBehavior",
                rust_offset: offset_of!(GameTweakData, panic),
            },
            FieldInfoData {
                name: "Blinded",
                flags: MemberInfoFlags::new(0),
                field_type: "GameTweakBlindedBehavior",
                rust_offset: offset_of!(GameTweakData, blinded),
            },
            FieldInfoData {
                name: "AISoundDefaults",
                flags: MemberInfoFlags::new(0),
                field_type: "AISoundDefaults",
                rust_offset: offset_of!(GameTweakData, a_i_sound_defaults),
            },
            FieldInfoData {
                name: "TeamSettings",
                flags: MemberInfoFlags::new(144),
                field_type: "TeamSettings-Array",
                rust_offset: offset_of!(GameTweakData, team_settings),
            },
        ],
    }),
    array_type: Some(GAMETWEAKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameTweakData {
    fn type_info(&self) -> &'static TypeInfo {
        GAMETWEAKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAMETWEAKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TeamSettings {
    pub team: super::gameplay_sim::TeamId,
    pub enemies: Vec<super::gameplay_sim::TeamId>,
    pub lightweight: bool,
}

pub trait TeamSettingsTrait: TypeObject {
    fn team(&self) -> &super::gameplay_sim::TeamId;
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn enemies(&self) -> &Vec<super::gameplay_sim::TeamId>;
    fn enemies_mut(&mut self) -> &mut Vec<super::gameplay_sim::TeamId>;
    fn lightweight(&self) -> &bool;
    fn lightweight_mut(&mut self) -> &mut bool;
}

impl TeamSettingsTrait for TeamSettings {
    fn team(&self) -> &super::gameplay_sim::TeamId {
        &self.team
    }
    fn team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.team
    }
    fn enemies(&self) -> &Vec<super::gameplay_sim::TeamId> {
        &self.enemies
    }
    fn enemies_mut(&mut self) -> &mut Vec<super::gameplay_sim::TeamId> {
        &mut self.enemies
    }
    fn lightweight(&self) -> &bool {
        &self.lightweight
    }
    fn lightweight_mut(&mut self) -> &mut bool {
        &mut self.lightweight
    }
}

pub static TEAMSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TeamSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(TeamSettings, team),
            },
            FieldInfoData {
                name: "Enemies",
                flags: MemberInfoFlags::new(144),
                field_type: "TeamId-Array",
                rust_offset: offset_of!(TeamSettings, enemies),
            },
            FieldInfoData {
                name: "Lightweight",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TeamSettings, lightweight),
            },
        ],
    }),
    array_type: Some(TEAMSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TeamSettings {
    fn type_info(&self) -> &'static TypeInfo {
        TEAMSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TEAMSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TeamSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameTweakBlindedBehavior {
    pub blinded_time: f32,
    pub blinded_radius: f32,
}

pub trait GameTweakBlindedBehaviorTrait: TypeObject {
    fn blinded_time(&self) -> &f32;
    fn blinded_time_mut(&mut self) -> &mut f32;
    fn blinded_radius(&self) -> &f32;
    fn blinded_radius_mut(&mut self) -> &mut f32;
}

impl GameTweakBlindedBehaviorTrait for GameTweakBlindedBehavior {
    fn blinded_time(&self) -> &f32 {
        &self.blinded_time
    }
    fn blinded_time_mut(&mut self) -> &mut f32 {
        &mut self.blinded_time
    }
    fn blinded_radius(&self) -> &f32 {
        &self.blinded_radius
    }
    fn blinded_radius_mut(&mut self) -> &mut f32 {
        &mut self.blinded_radius
    }
}

pub static GAMETWEAKBLINDEDBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakBlindedBehavior",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameTweakBlindedBehavior as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BlindedTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakBlindedBehavior, blinded_time),
            },
            FieldInfoData {
                name: "BlindedRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakBlindedBehavior, blinded_radius),
            },
        ],
    }),
    array_type: Some(GAMETWEAKBLINDEDBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GameTweakBlindedBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        GAMETWEAKBLINDEDBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GAMETWEAKBLINDEDBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakBlindedBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakBlindedBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameTweakPanicBehavior {
    pub pre_panic_time_min: f32,
    pub pre_panic_time_max: f32,
    pub total_panic_time: f32,
    pub panic_blast_radius_percentage: f32,
    pub panic_on_grenade: bool,
    pub panic_on_weapon_suppression: bool,
    pub panic_on_vehicle_suppression: bool,
}

pub trait GameTweakPanicBehaviorTrait: TypeObject {
    fn pre_panic_time_min(&self) -> &f32;
    fn pre_panic_time_min_mut(&mut self) -> &mut f32;
    fn pre_panic_time_max(&self) -> &f32;
    fn pre_panic_time_max_mut(&mut self) -> &mut f32;
    fn total_panic_time(&self) -> &f32;
    fn total_panic_time_mut(&mut self) -> &mut f32;
    fn panic_blast_radius_percentage(&self) -> &f32;
    fn panic_blast_radius_percentage_mut(&mut self) -> &mut f32;
    fn panic_on_grenade(&self) -> &bool;
    fn panic_on_grenade_mut(&mut self) -> &mut bool;
    fn panic_on_weapon_suppression(&self) -> &bool;
    fn panic_on_weapon_suppression_mut(&mut self) -> &mut bool;
    fn panic_on_vehicle_suppression(&self) -> &bool;
    fn panic_on_vehicle_suppression_mut(&mut self) -> &mut bool;
}

impl GameTweakPanicBehaviorTrait for GameTweakPanicBehavior {
    fn pre_panic_time_min(&self) -> &f32 {
        &self.pre_panic_time_min
    }
    fn pre_panic_time_min_mut(&mut self) -> &mut f32 {
        &mut self.pre_panic_time_min
    }
    fn pre_panic_time_max(&self) -> &f32 {
        &self.pre_panic_time_max
    }
    fn pre_panic_time_max_mut(&mut self) -> &mut f32 {
        &mut self.pre_panic_time_max
    }
    fn total_panic_time(&self) -> &f32 {
        &self.total_panic_time
    }
    fn total_panic_time_mut(&mut self) -> &mut f32 {
        &mut self.total_panic_time
    }
    fn panic_blast_radius_percentage(&self) -> &f32 {
        &self.panic_blast_radius_percentage
    }
    fn panic_blast_radius_percentage_mut(&mut self) -> &mut f32 {
        &mut self.panic_blast_radius_percentage
    }
    fn panic_on_grenade(&self) -> &bool {
        &self.panic_on_grenade
    }
    fn panic_on_grenade_mut(&mut self) -> &mut bool {
        &mut self.panic_on_grenade
    }
    fn panic_on_weapon_suppression(&self) -> &bool {
        &self.panic_on_weapon_suppression
    }
    fn panic_on_weapon_suppression_mut(&mut self) -> &mut bool {
        &mut self.panic_on_weapon_suppression
    }
    fn panic_on_vehicle_suppression(&self) -> &bool {
        &self.panic_on_vehicle_suppression
    }
    fn panic_on_vehicle_suppression_mut(&mut self) -> &mut bool {
        &mut self.panic_on_vehicle_suppression
    }
}

pub static GAMETWEAKPANICBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakPanicBehavior",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameTweakPanicBehavior as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PrePanicTimeMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakPanicBehavior, pre_panic_time_min),
            },
            FieldInfoData {
                name: "PrePanicTimeMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakPanicBehavior, pre_panic_time_max),
            },
            FieldInfoData {
                name: "TotalPanicTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakPanicBehavior, total_panic_time),
            },
            FieldInfoData {
                name: "PanicBlastRadiusPercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakPanicBehavior, panic_blast_radius_percentage),
            },
            FieldInfoData {
                name: "PanicOnGrenade",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakPanicBehavior, panic_on_grenade),
            },
            FieldInfoData {
                name: "PanicOnWeaponSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakPanicBehavior, panic_on_weapon_suppression),
            },
            FieldInfoData {
                name: "PanicOnVehicleSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakPanicBehavior, panic_on_vehicle_suppression),
            },
        ],
    }),
    array_type: Some(GAMETWEAKPANICBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GameTweakPanicBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        GAMETWEAKPANICBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GAMETWEAKPANICBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakPanicBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakPanicBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameTweakSniper {
    pub glint_to_shot_fired_delay: f32,
    pub hide_after_shot_delay: f32,
    pub time_up_before_scope_glint: f32,
    pub time_hidden: f32,
}

pub trait GameTweakSniperTrait: TypeObject {
    fn glint_to_shot_fired_delay(&self) -> &f32;
    fn glint_to_shot_fired_delay_mut(&mut self) -> &mut f32;
    fn hide_after_shot_delay(&self) -> &f32;
    fn hide_after_shot_delay_mut(&mut self) -> &mut f32;
    fn time_up_before_scope_glint(&self) -> &f32;
    fn time_up_before_scope_glint_mut(&mut self) -> &mut f32;
    fn time_hidden(&self) -> &f32;
    fn time_hidden_mut(&mut self) -> &mut f32;
}

impl GameTweakSniperTrait for GameTweakSniper {
    fn glint_to_shot_fired_delay(&self) -> &f32 {
        &self.glint_to_shot_fired_delay
    }
    fn glint_to_shot_fired_delay_mut(&mut self) -> &mut f32 {
        &mut self.glint_to_shot_fired_delay
    }
    fn hide_after_shot_delay(&self) -> &f32 {
        &self.hide_after_shot_delay
    }
    fn hide_after_shot_delay_mut(&mut self) -> &mut f32 {
        &mut self.hide_after_shot_delay
    }
    fn time_up_before_scope_glint(&self) -> &f32 {
        &self.time_up_before_scope_glint
    }
    fn time_up_before_scope_glint_mut(&mut self) -> &mut f32 {
        &mut self.time_up_before_scope_glint
    }
    fn time_hidden(&self) -> &f32 {
        &self.time_hidden
    }
    fn time_hidden_mut(&mut self) -> &mut f32 {
        &mut self.time_hidden
    }
}

pub static GAMETWEAKSNIPER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakSniper",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameTweakSniper as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GlintToShotFiredDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakSniper, glint_to_shot_fired_delay),
            },
            FieldInfoData {
                name: "HideAfterShotDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakSniper, hide_after_shot_delay),
            },
            FieldInfoData {
                name: "TimeUpBeforeScopeGlint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakSniper, time_up_before_scope_glint),
            },
            FieldInfoData {
                name: "TimeHidden",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakSniper, time_hidden),
            },
        ],
    }),
    array_type: Some(GAMETWEAKSNIPER_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GameTweakSniper {
    fn type_info(&self) -> &'static TypeInfo {
        GAMETWEAKSNIPER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GAMETWEAKSNIPER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakSniper-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakSniper"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameTweakBucketDamage {
    pub player_damage_bucket_times: Vec<f32>,
    pub evasive_bucket_time_settings: EvasiveBucketTimeSettings,
    pub damage_multiplier: f32,
}

pub trait GameTweakBucketDamageTrait: TypeObject {
    fn player_damage_bucket_times(&self) -> &Vec<f32>;
    fn player_damage_bucket_times_mut(&mut self) -> &mut Vec<f32>;
    fn evasive_bucket_time_settings(&self) -> &EvasiveBucketTimeSettings;
    fn evasive_bucket_time_settings_mut(&mut self) -> &mut EvasiveBucketTimeSettings;
    fn damage_multiplier(&self) -> &f32;
    fn damage_multiplier_mut(&mut self) -> &mut f32;
}

impl GameTweakBucketDamageTrait for GameTweakBucketDamage {
    fn player_damage_bucket_times(&self) -> &Vec<f32> {
        &self.player_damage_bucket_times
    }
    fn player_damage_bucket_times_mut(&mut self) -> &mut Vec<f32> {
        &mut self.player_damage_bucket_times
    }
    fn evasive_bucket_time_settings(&self) -> &EvasiveBucketTimeSettings {
        &self.evasive_bucket_time_settings
    }
    fn evasive_bucket_time_settings_mut(&mut self) -> &mut EvasiveBucketTimeSettings {
        &mut self.evasive_bucket_time_settings
    }
    fn damage_multiplier(&self) -> &f32 {
        &self.damage_multiplier
    }
    fn damage_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.damage_multiplier
    }
}

pub static GAMETWEAKBUCKETDAMAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakBucketDamage",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameTweakBucketDamage as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlayerDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(GameTweakBucketDamage, player_damage_bucket_times),
            },
            FieldInfoData {
                name: "EvasiveBucketTimeSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "EvasiveBucketTimeSettings",
                rust_offset: offset_of!(GameTweakBucketDamage, evasive_bucket_time_settings),
            },
            FieldInfoData {
                name: "DamageMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakBucketDamage, damage_multiplier),
            },
        ],
    }),
    array_type: Some(GAMETWEAKBUCKETDAMAGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameTweakBucketDamage {
    fn type_info(&self) -> &'static TypeInfo {
        GAMETWEAKBUCKETDAMAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GAMETWEAKBUCKETDAMAGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakBucketDamage-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakBucketDamage"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameTweakAITargeting {
    pub firing_delay_after_aquiring_target: TinyPiecewiseLinearCurve,
    pub reaquire_target_distance_threshold: f32,
    pub firing_delay_after_reaquiring_target: TinyPiecewiseLinearCurve,
    pub time_until_damage_from_start_of_first_burst: TinyPiecewiseLinearCurve,
    pub time_until_damage_time_is_fully_restored: TinyPiecewiseLinearCurve,
    pub time_until_accurate_from_start_of_first_damage: TinyPiecewiseLinearCurve,
    pub time_until_accurate_time_is_fully_restored: TinyPiecewiseLinearCurve,
    pub accuracy_penalty_settings: AccuracyPenaltySettings,
    pub aiming_at_angle_threshold: i32,
    pub max_attackers_frequency_modifier: f32,
}

pub trait GameTweakAITargetingTrait: TypeObject {
    fn firing_delay_after_aquiring_target(&self) -> &TinyPiecewiseLinearCurve;
    fn firing_delay_after_aquiring_target_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn reaquire_target_distance_threshold(&self) -> &f32;
    fn reaquire_target_distance_threshold_mut(&mut self) -> &mut f32;
    fn firing_delay_after_reaquiring_target(&self) -> &TinyPiecewiseLinearCurve;
    fn firing_delay_after_reaquiring_target_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn time_until_damage_from_start_of_first_burst(&self) -> &TinyPiecewiseLinearCurve;
    fn time_until_damage_from_start_of_first_burst_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn time_until_damage_time_is_fully_restored(&self) -> &TinyPiecewiseLinearCurve;
    fn time_until_damage_time_is_fully_restored_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn time_until_accurate_from_start_of_first_damage(&self) -> &TinyPiecewiseLinearCurve;
    fn time_until_accurate_from_start_of_first_damage_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn time_until_accurate_time_is_fully_restored(&self) -> &TinyPiecewiseLinearCurve;
    fn time_until_accurate_time_is_fully_restored_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn accuracy_penalty_settings(&self) -> &AccuracyPenaltySettings;
    fn accuracy_penalty_settings_mut(&mut self) -> &mut AccuracyPenaltySettings;
    fn aiming_at_angle_threshold(&self) -> &i32;
    fn aiming_at_angle_threshold_mut(&mut self) -> &mut i32;
    fn max_attackers_frequency_modifier(&self) -> &f32;
    fn max_attackers_frequency_modifier_mut(&mut self) -> &mut f32;
}

impl GameTweakAITargetingTrait for GameTweakAITargeting {
    fn firing_delay_after_aquiring_target(&self) -> &TinyPiecewiseLinearCurve {
        &self.firing_delay_after_aquiring_target
    }
    fn firing_delay_after_aquiring_target_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.firing_delay_after_aquiring_target
    }
    fn reaquire_target_distance_threshold(&self) -> &f32 {
        &self.reaquire_target_distance_threshold
    }
    fn reaquire_target_distance_threshold_mut(&mut self) -> &mut f32 {
        &mut self.reaquire_target_distance_threshold
    }
    fn firing_delay_after_reaquiring_target(&self) -> &TinyPiecewiseLinearCurve {
        &self.firing_delay_after_reaquiring_target
    }
    fn firing_delay_after_reaquiring_target_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.firing_delay_after_reaquiring_target
    }
    fn time_until_damage_from_start_of_first_burst(&self) -> &TinyPiecewiseLinearCurve {
        &self.time_until_damage_from_start_of_first_burst
    }
    fn time_until_damage_from_start_of_first_burst_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.time_until_damage_from_start_of_first_burst
    }
    fn time_until_damage_time_is_fully_restored(&self) -> &TinyPiecewiseLinearCurve {
        &self.time_until_damage_time_is_fully_restored
    }
    fn time_until_damage_time_is_fully_restored_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.time_until_damage_time_is_fully_restored
    }
    fn time_until_accurate_from_start_of_first_damage(&self) -> &TinyPiecewiseLinearCurve {
        &self.time_until_accurate_from_start_of_first_damage
    }
    fn time_until_accurate_from_start_of_first_damage_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.time_until_accurate_from_start_of_first_damage
    }
    fn time_until_accurate_time_is_fully_restored(&self) -> &TinyPiecewiseLinearCurve {
        &self.time_until_accurate_time_is_fully_restored
    }
    fn time_until_accurate_time_is_fully_restored_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.time_until_accurate_time_is_fully_restored
    }
    fn accuracy_penalty_settings(&self) -> &AccuracyPenaltySettings {
        &self.accuracy_penalty_settings
    }
    fn accuracy_penalty_settings_mut(&mut self) -> &mut AccuracyPenaltySettings {
        &mut self.accuracy_penalty_settings
    }
    fn aiming_at_angle_threshold(&self) -> &i32 {
        &self.aiming_at_angle_threshold
    }
    fn aiming_at_angle_threshold_mut(&mut self) -> &mut i32 {
        &mut self.aiming_at_angle_threshold
    }
    fn max_attackers_frequency_modifier(&self) -> &f32 {
        &self.max_attackers_frequency_modifier
    }
    fn max_attackers_frequency_modifier_mut(&mut self) -> &mut f32 {
        &mut self.max_attackers_frequency_modifier
    }
}

pub static GAMETWEAKAITARGETING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakAITargeting",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameTweakAITargeting as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FiringDelayAfterAquiringTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(GameTweakAITargeting, firing_delay_after_aquiring_target),
            },
            FieldInfoData {
                name: "ReaquireTargetDistanceThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakAITargeting, reaquire_target_distance_threshold),
            },
            FieldInfoData {
                name: "FiringDelayAfterReaquiringTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(GameTweakAITargeting, firing_delay_after_reaquiring_target),
            },
            FieldInfoData {
                name: "TimeUntilDamageFromStartOfFirstBurst",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(GameTweakAITargeting, time_until_damage_from_start_of_first_burst),
            },
            FieldInfoData {
                name: "TimeUntilDamageTimeIsFullyRestored",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(GameTweakAITargeting, time_until_damage_time_is_fully_restored),
            },
            FieldInfoData {
                name: "TimeUntilAccurateFromStartOfFirstDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(GameTweakAITargeting, time_until_accurate_from_start_of_first_damage),
            },
            FieldInfoData {
                name: "TimeUntilAccurateTimeIsFullyRestored",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(GameTweakAITargeting, time_until_accurate_time_is_fully_restored),
            },
            FieldInfoData {
                name: "AccuracyPenaltySettings",
                flags: MemberInfoFlags::new(0),
                field_type: "AccuracyPenaltySettings",
                rust_offset: offset_of!(GameTweakAITargeting, accuracy_penalty_settings),
            },
            FieldInfoData {
                name: "AimingAtAngleThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(GameTweakAITargeting, aiming_at_angle_threshold),
            },
            FieldInfoData {
                name: "MaxAttackersFrequencyModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakAITargeting, max_attackers_frequency_modifier),
            },
        ],
    }),
    array_type: Some(GAMETWEAKAITARGETING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GameTweakAITargeting {
    fn type_info(&self) -> &'static TypeInfo {
        GAMETWEAKAITARGETING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GAMETWEAKAITARGETING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakAITargeting-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakAITargeting"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EvasiveBucketTimeSettings {
    pub sprint_damage_bucket_times: Vec<f32>,
    pub crouch_damage_bucket_times: Vec<f32>,
    pub prone_damage_bucket_times: Vec<f32>,
    pub moving_vehicle_damage_bucket_times: Vec<f32>,
    pub vehicle_still_damage_bucket_times: Vec<f32>,
    pub sprint_speed: f32,
    pub moving_vehicle_speed: f32,
}

pub trait EvasiveBucketTimeSettingsTrait: TypeObject {
    fn sprint_damage_bucket_times(&self) -> &Vec<f32>;
    fn sprint_damage_bucket_times_mut(&mut self) -> &mut Vec<f32>;
    fn crouch_damage_bucket_times(&self) -> &Vec<f32>;
    fn crouch_damage_bucket_times_mut(&mut self) -> &mut Vec<f32>;
    fn prone_damage_bucket_times(&self) -> &Vec<f32>;
    fn prone_damage_bucket_times_mut(&mut self) -> &mut Vec<f32>;
    fn moving_vehicle_damage_bucket_times(&self) -> &Vec<f32>;
    fn moving_vehicle_damage_bucket_times_mut(&mut self) -> &mut Vec<f32>;
    fn vehicle_still_damage_bucket_times(&self) -> &Vec<f32>;
    fn vehicle_still_damage_bucket_times_mut(&mut self) -> &mut Vec<f32>;
    fn sprint_speed(&self) -> &f32;
    fn sprint_speed_mut(&mut self) -> &mut f32;
    fn moving_vehicle_speed(&self) -> &f32;
    fn moving_vehicle_speed_mut(&mut self) -> &mut f32;
}

impl EvasiveBucketTimeSettingsTrait for EvasiveBucketTimeSettings {
    fn sprint_damage_bucket_times(&self) -> &Vec<f32> {
        &self.sprint_damage_bucket_times
    }
    fn sprint_damage_bucket_times_mut(&mut self) -> &mut Vec<f32> {
        &mut self.sprint_damage_bucket_times
    }
    fn crouch_damage_bucket_times(&self) -> &Vec<f32> {
        &self.crouch_damage_bucket_times
    }
    fn crouch_damage_bucket_times_mut(&mut self) -> &mut Vec<f32> {
        &mut self.crouch_damage_bucket_times
    }
    fn prone_damage_bucket_times(&self) -> &Vec<f32> {
        &self.prone_damage_bucket_times
    }
    fn prone_damage_bucket_times_mut(&mut self) -> &mut Vec<f32> {
        &mut self.prone_damage_bucket_times
    }
    fn moving_vehicle_damage_bucket_times(&self) -> &Vec<f32> {
        &self.moving_vehicle_damage_bucket_times
    }
    fn moving_vehicle_damage_bucket_times_mut(&mut self) -> &mut Vec<f32> {
        &mut self.moving_vehicle_damage_bucket_times
    }
    fn vehicle_still_damage_bucket_times(&self) -> &Vec<f32> {
        &self.vehicle_still_damage_bucket_times
    }
    fn vehicle_still_damage_bucket_times_mut(&mut self) -> &mut Vec<f32> {
        &mut self.vehicle_still_damage_bucket_times
    }
    fn sprint_speed(&self) -> &f32 {
        &self.sprint_speed
    }
    fn sprint_speed_mut(&mut self) -> &mut f32 {
        &mut self.sprint_speed
    }
    fn moving_vehicle_speed(&self) -> &f32 {
        &self.moving_vehicle_speed
    }
    fn moving_vehicle_speed_mut(&mut self) -> &mut f32 {
        &mut self.moving_vehicle_speed
    }
}

pub static EVASIVEBUCKETTIMESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvasiveBucketTimeSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EvasiveBucketTimeSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SprintDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(EvasiveBucketTimeSettings, sprint_damage_bucket_times),
            },
            FieldInfoData {
                name: "CrouchDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(EvasiveBucketTimeSettings, crouch_damage_bucket_times),
            },
            FieldInfoData {
                name: "ProneDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(EvasiveBucketTimeSettings, prone_damage_bucket_times),
            },
            FieldInfoData {
                name: "MovingVehicleDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(EvasiveBucketTimeSettings, moving_vehicle_damage_bucket_times),
            },
            FieldInfoData {
                name: "VehicleStillDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(EvasiveBucketTimeSettings, vehicle_still_damage_bucket_times),
            },
            FieldInfoData {
                name: "SprintSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvasiveBucketTimeSettings, sprint_speed),
            },
            FieldInfoData {
                name: "MovingVehicleSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvasiveBucketTimeSettings, moving_vehicle_speed),
            },
        ],
    }),
    array_type: Some(EVASIVEBUCKETTIMESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EvasiveBucketTimeSettings {
    fn type_info(&self) -> &'static TypeInfo {
        EVASIVEBUCKETTIMESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVASIVEBUCKETTIMESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvasiveBucketTimeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EvasiveBucketTimeSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AccuracyPenaltySettings {
    pub sprint_multiplier: f32,
    pub crouch_multiplier: f32,
    pub prone_multiplier: f32,
    pub moving_vehicle_multiplier: f32,
    pub vehicle_still_multiplier: f32,
    pub sprint_speed: f32,
    pub moving_vehicle_speed: f32,
}

pub trait AccuracyPenaltySettingsTrait: TypeObject {
    fn sprint_multiplier(&self) -> &f32;
    fn sprint_multiplier_mut(&mut self) -> &mut f32;
    fn crouch_multiplier(&self) -> &f32;
    fn crouch_multiplier_mut(&mut self) -> &mut f32;
    fn prone_multiplier(&self) -> &f32;
    fn prone_multiplier_mut(&mut self) -> &mut f32;
    fn moving_vehicle_multiplier(&self) -> &f32;
    fn moving_vehicle_multiplier_mut(&mut self) -> &mut f32;
    fn vehicle_still_multiplier(&self) -> &f32;
    fn vehicle_still_multiplier_mut(&mut self) -> &mut f32;
    fn sprint_speed(&self) -> &f32;
    fn sprint_speed_mut(&mut self) -> &mut f32;
    fn moving_vehicle_speed(&self) -> &f32;
    fn moving_vehicle_speed_mut(&mut self) -> &mut f32;
}

impl AccuracyPenaltySettingsTrait for AccuracyPenaltySettings {
    fn sprint_multiplier(&self) -> &f32 {
        &self.sprint_multiplier
    }
    fn sprint_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.sprint_multiplier
    }
    fn crouch_multiplier(&self) -> &f32 {
        &self.crouch_multiplier
    }
    fn crouch_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.crouch_multiplier
    }
    fn prone_multiplier(&self) -> &f32 {
        &self.prone_multiplier
    }
    fn prone_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.prone_multiplier
    }
    fn moving_vehicle_multiplier(&self) -> &f32 {
        &self.moving_vehicle_multiplier
    }
    fn moving_vehicle_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.moving_vehicle_multiplier
    }
    fn vehicle_still_multiplier(&self) -> &f32 {
        &self.vehicle_still_multiplier
    }
    fn vehicle_still_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_still_multiplier
    }
    fn sprint_speed(&self) -> &f32 {
        &self.sprint_speed
    }
    fn sprint_speed_mut(&mut self) -> &mut f32 {
        &mut self.sprint_speed
    }
    fn moving_vehicle_speed(&self) -> &f32 {
        &self.moving_vehicle_speed
    }
    fn moving_vehicle_speed_mut(&mut self) -> &mut f32 {
        &mut self.moving_vehicle_speed
    }
}

pub static ACCURACYPENALTYSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AccuracyPenaltySettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AccuracyPenaltySettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SprintMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyPenaltySettings, sprint_multiplier),
            },
            FieldInfoData {
                name: "CrouchMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyPenaltySettings, crouch_multiplier),
            },
            FieldInfoData {
                name: "ProneMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyPenaltySettings, prone_multiplier),
            },
            FieldInfoData {
                name: "MovingVehicleMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyPenaltySettings, moving_vehicle_multiplier),
            },
            FieldInfoData {
                name: "VehicleStillMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyPenaltySettings, vehicle_still_multiplier),
            },
            FieldInfoData {
                name: "SprintSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyPenaltySettings, sprint_speed),
            },
            FieldInfoData {
                name: "MovingVehicleSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyPenaltySettings, moving_vehicle_speed),
            },
        ],
    }),
    array_type: Some(ACCURACYPENALTYSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AccuracyPenaltySettings {
    fn type_info(&self) -> &'static TypeInfo {
        ACCURACYPENALTYSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ACCURACYPENALTYSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AccuracyPenaltySettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AccuracyPenaltySettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GameTweakCommon {
    pub use_new_sensing_areas: bool,
    pub sensing_areas: Vec<SensingArea>,
    pub sensing_areas_alerted_modifier: SensingAreaModifier,
    pub sensing_cone_range: f32,
    pub sensing_cone_range_when_alerted: f32,
    pub sensing_cone_angle: f32,
    pub sensing_cone_angle_when_alerted: f32,
    pub sensing_cone_angle_above: f32,
    pub sensing_cone_angle_below: f32,
    pub sensing_shot_fired_distance: f32,
    pub sensing_human_driven_vehicle_distance: f32,
    pub sensing_explosion_distance: f32,
    pub sensing_grenade_distance: f32,
    pub sensing_static_target_object_distance: f32,
    pub sensing_moving_target_object_distance: f32,
    pub distance_to_aware_time_curve_central: TinyPiecewiseLinearCurve,
    pub aware_curve_central_angle: f32,
    pub distance_to_aware_time_curve_peripheral: TinyPiecewiseLinearCurve,
    pub aware_standing_penalty_multiplier: f32,
    pub aware_to_alert_time: f32,
    pub corpse: CorpseData,
    pub enable_visibility_acummulation: bool,
    pub visibility_acummulation_time: f32,
    pub high_intensity_radius: f32,
    pub investigate_seen_enemy_alert_percent: f32,
    pub ignore_sound_when_alerted: bool,
    pub concealment_cool_down_time: f32,
    pub concealment_disable_at_distance: f32,
    pub passivity: PassivityData,
    pub grenade_tokens: Vec<GrenadeTokenList>,
    pub melee_charge: MeleeChargeData,
    pub creature_melee_charge: MeleeChargeData,
    pub simultaneous_vehicle_usage: i32,
    pub min_vehicle_booking_delay_on_token_available: f32,
    pub max_vehicle_booking_delay_on_token_available: f32,
    pub min_vehicle_entry_available_delay_after_death: f32,
    pub max_vehicle_entry_available_delay_after_death: f32,
    pub enemy_min_time_in_medium_intensity: f32,
    pub investigate: InvestigateData,
    pub include_terrain_in_vision_tests: bool,
    pub use_cover_approx_fire_position_for_vision: bool,
    pub teams_with_awareness: Vec<super::gameplay_sim::TeamId>,
    pub enable_last_known_position_sharing: bool,
    pub max_last_known_position_share_distance: f32,
    pub alerted_by_friendly_combat_actions: bool,
    pub being_charged_causes_alert: bool,
    pub being_charged_detect_distance: f32,
    pub being_charged_angle_limit: f32,
    pub use_visible_l_k_p_sharing: bool,
    pub use_sound_l_k_p_update: bool,
    pub aim_at_l_k_p_when_target_lost: bool,
    pub max_last_seen_distance_for_l_k_p_lost: f32,
    pub min_reaction_time_for_l_k_p_reaqcuire: f32,
    pub max_reaction_time_for_l_k_p_reaqcuire: f32,
    pub target_coordination: TargetCoordinationGlobalSettings,
    pub temperature: TemperatureData,
}

pub trait GameTweakCommonTrait: TypeObject {
    fn use_new_sensing_areas(&self) -> &bool;
    fn use_new_sensing_areas_mut(&mut self) -> &mut bool;
    fn sensing_areas(&self) -> &Vec<SensingArea>;
    fn sensing_areas_mut(&mut self) -> &mut Vec<SensingArea>;
    fn sensing_areas_alerted_modifier(&self) -> &SensingAreaModifier;
    fn sensing_areas_alerted_modifier_mut(&mut self) -> &mut SensingAreaModifier;
    fn sensing_cone_range(&self) -> &f32;
    fn sensing_cone_range_mut(&mut self) -> &mut f32;
    fn sensing_cone_range_when_alerted(&self) -> &f32;
    fn sensing_cone_range_when_alerted_mut(&mut self) -> &mut f32;
    fn sensing_cone_angle(&self) -> &f32;
    fn sensing_cone_angle_mut(&mut self) -> &mut f32;
    fn sensing_cone_angle_when_alerted(&self) -> &f32;
    fn sensing_cone_angle_when_alerted_mut(&mut self) -> &mut f32;
    fn sensing_cone_angle_above(&self) -> &f32;
    fn sensing_cone_angle_above_mut(&mut self) -> &mut f32;
    fn sensing_cone_angle_below(&self) -> &f32;
    fn sensing_cone_angle_below_mut(&mut self) -> &mut f32;
    fn sensing_shot_fired_distance(&self) -> &f32;
    fn sensing_shot_fired_distance_mut(&mut self) -> &mut f32;
    fn sensing_human_driven_vehicle_distance(&self) -> &f32;
    fn sensing_human_driven_vehicle_distance_mut(&mut self) -> &mut f32;
    fn sensing_explosion_distance(&self) -> &f32;
    fn sensing_explosion_distance_mut(&mut self) -> &mut f32;
    fn sensing_grenade_distance(&self) -> &f32;
    fn sensing_grenade_distance_mut(&mut self) -> &mut f32;
    fn sensing_static_target_object_distance(&self) -> &f32;
    fn sensing_static_target_object_distance_mut(&mut self) -> &mut f32;
    fn sensing_moving_target_object_distance(&self) -> &f32;
    fn sensing_moving_target_object_distance_mut(&mut self) -> &mut f32;
    fn distance_to_aware_time_curve_central(&self) -> &TinyPiecewiseLinearCurve;
    fn distance_to_aware_time_curve_central_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn aware_curve_central_angle(&self) -> &f32;
    fn aware_curve_central_angle_mut(&mut self) -> &mut f32;
    fn distance_to_aware_time_curve_peripheral(&self) -> &TinyPiecewiseLinearCurve;
    fn distance_to_aware_time_curve_peripheral_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn aware_standing_penalty_multiplier(&self) -> &f32;
    fn aware_standing_penalty_multiplier_mut(&mut self) -> &mut f32;
    fn aware_to_alert_time(&self) -> &f32;
    fn aware_to_alert_time_mut(&mut self) -> &mut f32;
    fn corpse(&self) -> &CorpseData;
    fn corpse_mut(&mut self) -> &mut CorpseData;
    fn enable_visibility_acummulation(&self) -> &bool;
    fn enable_visibility_acummulation_mut(&mut self) -> &mut bool;
    fn visibility_acummulation_time(&self) -> &f32;
    fn visibility_acummulation_time_mut(&mut self) -> &mut f32;
    fn high_intensity_radius(&self) -> &f32;
    fn high_intensity_radius_mut(&mut self) -> &mut f32;
    fn investigate_seen_enemy_alert_percent(&self) -> &f32;
    fn investigate_seen_enemy_alert_percent_mut(&mut self) -> &mut f32;
    fn ignore_sound_when_alerted(&self) -> &bool;
    fn ignore_sound_when_alerted_mut(&mut self) -> &mut bool;
    fn concealment_cool_down_time(&self) -> &f32;
    fn concealment_cool_down_time_mut(&mut self) -> &mut f32;
    fn concealment_disable_at_distance(&self) -> &f32;
    fn concealment_disable_at_distance_mut(&mut self) -> &mut f32;
    fn passivity(&self) -> &PassivityData;
    fn passivity_mut(&mut self) -> &mut PassivityData;
    fn grenade_tokens(&self) -> &Vec<GrenadeTokenList>;
    fn grenade_tokens_mut(&mut self) -> &mut Vec<GrenadeTokenList>;
    fn melee_charge(&self) -> &MeleeChargeData;
    fn melee_charge_mut(&mut self) -> &mut MeleeChargeData;
    fn creature_melee_charge(&self) -> &MeleeChargeData;
    fn creature_melee_charge_mut(&mut self) -> &mut MeleeChargeData;
    fn simultaneous_vehicle_usage(&self) -> &i32;
    fn simultaneous_vehicle_usage_mut(&mut self) -> &mut i32;
    fn min_vehicle_booking_delay_on_token_available(&self) -> &f32;
    fn min_vehicle_booking_delay_on_token_available_mut(&mut self) -> &mut f32;
    fn max_vehicle_booking_delay_on_token_available(&self) -> &f32;
    fn max_vehicle_booking_delay_on_token_available_mut(&mut self) -> &mut f32;
    fn min_vehicle_entry_available_delay_after_death(&self) -> &f32;
    fn min_vehicle_entry_available_delay_after_death_mut(&mut self) -> &mut f32;
    fn max_vehicle_entry_available_delay_after_death(&self) -> &f32;
    fn max_vehicle_entry_available_delay_after_death_mut(&mut self) -> &mut f32;
    fn enemy_min_time_in_medium_intensity(&self) -> &f32;
    fn enemy_min_time_in_medium_intensity_mut(&mut self) -> &mut f32;
    fn investigate(&self) -> &InvestigateData;
    fn investigate_mut(&mut self) -> &mut InvestigateData;
    fn include_terrain_in_vision_tests(&self) -> &bool;
    fn include_terrain_in_vision_tests_mut(&mut self) -> &mut bool;
    fn use_cover_approx_fire_position_for_vision(&self) -> &bool;
    fn use_cover_approx_fire_position_for_vision_mut(&mut self) -> &mut bool;
    fn teams_with_awareness(&self) -> &Vec<super::gameplay_sim::TeamId>;
    fn teams_with_awareness_mut(&mut self) -> &mut Vec<super::gameplay_sim::TeamId>;
    fn enable_last_known_position_sharing(&self) -> &bool;
    fn enable_last_known_position_sharing_mut(&mut self) -> &mut bool;
    fn max_last_known_position_share_distance(&self) -> &f32;
    fn max_last_known_position_share_distance_mut(&mut self) -> &mut f32;
    fn alerted_by_friendly_combat_actions(&self) -> &bool;
    fn alerted_by_friendly_combat_actions_mut(&mut self) -> &mut bool;
    fn being_charged_causes_alert(&self) -> &bool;
    fn being_charged_causes_alert_mut(&mut self) -> &mut bool;
    fn being_charged_detect_distance(&self) -> &f32;
    fn being_charged_detect_distance_mut(&mut self) -> &mut f32;
    fn being_charged_angle_limit(&self) -> &f32;
    fn being_charged_angle_limit_mut(&mut self) -> &mut f32;
    fn use_visible_l_k_p_sharing(&self) -> &bool;
    fn use_visible_l_k_p_sharing_mut(&mut self) -> &mut bool;
    fn use_sound_l_k_p_update(&self) -> &bool;
    fn use_sound_l_k_p_update_mut(&mut self) -> &mut bool;
    fn aim_at_l_k_p_when_target_lost(&self) -> &bool;
    fn aim_at_l_k_p_when_target_lost_mut(&mut self) -> &mut bool;
    fn max_last_seen_distance_for_l_k_p_lost(&self) -> &f32;
    fn max_last_seen_distance_for_l_k_p_lost_mut(&mut self) -> &mut f32;
    fn min_reaction_time_for_l_k_p_reaqcuire(&self) -> &f32;
    fn min_reaction_time_for_l_k_p_reaqcuire_mut(&mut self) -> &mut f32;
    fn max_reaction_time_for_l_k_p_reaqcuire(&self) -> &f32;
    fn max_reaction_time_for_l_k_p_reaqcuire_mut(&mut self) -> &mut f32;
    fn target_coordination(&self) -> &TargetCoordinationGlobalSettings;
    fn target_coordination_mut(&mut self) -> &mut TargetCoordinationGlobalSettings;
    fn temperature(&self) -> &TemperatureData;
    fn temperature_mut(&mut self) -> &mut TemperatureData;
}

impl GameTweakCommonTrait for GameTweakCommon {
    fn use_new_sensing_areas(&self) -> &bool {
        &self.use_new_sensing_areas
    }
    fn use_new_sensing_areas_mut(&mut self) -> &mut bool {
        &mut self.use_new_sensing_areas
    }
    fn sensing_areas(&self) -> &Vec<SensingArea> {
        &self.sensing_areas
    }
    fn sensing_areas_mut(&mut self) -> &mut Vec<SensingArea> {
        &mut self.sensing_areas
    }
    fn sensing_areas_alerted_modifier(&self) -> &SensingAreaModifier {
        &self.sensing_areas_alerted_modifier
    }
    fn sensing_areas_alerted_modifier_mut(&mut self) -> &mut SensingAreaModifier {
        &mut self.sensing_areas_alerted_modifier
    }
    fn sensing_cone_range(&self) -> &f32 {
        &self.sensing_cone_range
    }
    fn sensing_cone_range_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_range
    }
    fn sensing_cone_range_when_alerted(&self) -> &f32 {
        &self.sensing_cone_range_when_alerted
    }
    fn sensing_cone_range_when_alerted_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_range_when_alerted
    }
    fn sensing_cone_angle(&self) -> &f32 {
        &self.sensing_cone_angle
    }
    fn sensing_cone_angle_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_angle
    }
    fn sensing_cone_angle_when_alerted(&self) -> &f32 {
        &self.sensing_cone_angle_when_alerted
    }
    fn sensing_cone_angle_when_alerted_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_angle_when_alerted
    }
    fn sensing_cone_angle_above(&self) -> &f32 {
        &self.sensing_cone_angle_above
    }
    fn sensing_cone_angle_above_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_angle_above
    }
    fn sensing_cone_angle_below(&self) -> &f32 {
        &self.sensing_cone_angle_below
    }
    fn sensing_cone_angle_below_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_angle_below
    }
    fn sensing_shot_fired_distance(&self) -> &f32 {
        &self.sensing_shot_fired_distance
    }
    fn sensing_shot_fired_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_shot_fired_distance
    }
    fn sensing_human_driven_vehicle_distance(&self) -> &f32 {
        &self.sensing_human_driven_vehicle_distance
    }
    fn sensing_human_driven_vehicle_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_human_driven_vehicle_distance
    }
    fn sensing_explosion_distance(&self) -> &f32 {
        &self.sensing_explosion_distance
    }
    fn sensing_explosion_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_explosion_distance
    }
    fn sensing_grenade_distance(&self) -> &f32 {
        &self.sensing_grenade_distance
    }
    fn sensing_grenade_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_grenade_distance
    }
    fn sensing_static_target_object_distance(&self) -> &f32 {
        &self.sensing_static_target_object_distance
    }
    fn sensing_static_target_object_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_static_target_object_distance
    }
    fn sensing_moving_target_object_distance(&self) -> &f32 {
        &self.sensing_moving_target_object_distance
    }
    fn sensing_moving_target_object_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_moving_target_object_distance
    }
    fn distance_to_aware_time_curve_central(&self) -> &TinyPiecewiseLinearCurve {
        &self.distance_to_aware_time_curve_central
    }
    fn distance_to_aware_time_curve_central_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.distance_to_aware_time_curve_central
    }
    fn aware_curve_central_angle(&self) -> &f32 {
        &self.aware_curve_central_angle
    }
    fn aware_curve_central_angle_mut(&mut self) -> &mut f32 {
        &mut self.aware_curve_central_angle
    }
    fn distance_to_aware_time_curve_peripheral(&self) -> &TinyPiecewiseLinearCurve {
        &self.distance_to_aware_time_curve_peripheral
    }
    fn distance_to_aware_time_curve_peripheral_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.distance_to_aware_time_curve_peripheral
    }
    fn aware_standing_penalty_multiplier(&self) -> &f32 {
        &self.aware_standing_penalty_multiplier
    }
    fn aware_standing_penalty_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.aware_standing_penalty_multiplier
    }
    fn aware_to_alert_time(&self) -> &f32 {
        &self.aware_to_alert_time
    }
    fn aware_to_alert_time_mut(&mut self) -> &mut f32 {
        &mut self.aware_to_alert_time
    }
    fn corpse(&self) -> &CorpseData {
        &self.corpse
    }
    fn corpse_mut(&mut self) -> &mut CorpseData {
        &mut self.corpse
    }
    fn enable_visibility_acummulation(&self) -> &bool {
        &self.enable_visibility_acummulation
    }
    fn enable_visibility_acummulation_mut(&mut self) -> &mut bool {
        &mut self.enable_visibility_acummulation
    }
    fn visibility_acummulation_time(&self) -> &f32 {
        &self.visibility_acummulation_time
    }
    fn visibility_acummulation_time_mut(&mut self) -> &mut f32 {
        &mut self.visibility_acummulation_time
    }
    fn high_intensity_radius(&self) -> &f32 {
        &self.high_intensity_radius
    }
    fn high_intensity_radius_mut(&mut self) -> &mut f32 {
        &mut self.high_intensity_radius
    }
    fn investigate_seen_enemy_alert_percent(&self) -> &f32 {
        &self.investigate_seen_enemy_alert_percent
    }
    fn investigate_seen_enemy_alert_percent_mut(&mut self) -> &mut f32 {
        &mut self.investigate_seen_enemy_alert_percent
    }
    fn ignore_sound_when_alerted(&self) -> &bool {
        &self.ignore_sound_when_alerted
    }
    fn ignore_sound_when_alerted_mut(&mut self) -> &mut bool {
        &mut self.ignore_sound_when_alerted
    }
    fn concealment_cool_down_time(&self) -> &f32 {
        &self.concealment_cool_down_time
    }
    fn concealment_cool_down_time_mut(&mut self) -> &mut f32 {
        &mut self.concealment_cool_down_time
    }
    fn concealment_disable_at_distance(&self) -> &f32 {
        &self.concealment_disable_at_distance
    }
    fn concealment_disable_at_distance_mut(&mut self) -> &mut f32 {
        &mut self.concealment_disable_at_distance
    }
    fn passivity(&self) -> &PassivityData {
        &self.passivity
    }
    fn passivity_mut(&mut self) -> &mut PassivityData {
        &mut self.passivity
    }
    fn grenade_tokens(&self) -> &Vec<GrenadeTokenList> {
        &self.grenade_tokens
    }
    fn grenade_tokens_mut(&mut self) -> &mut Vec<GrenadeTokenList> {
        &mut self.grenade_tokens
    }
    fn melee_charge(&self) -> &MeleeChargeData {
        &self.melee_charge
    }
    fn melee_charge_mut(&mut self) -> &mut MeleeChargeData {
        &mut self.melee_charge
    }
    fn creature_melee_charge(&self) -> &MeleeChargeData {
        &self.creature_melee_charge
    }
    fn creature_melee_charge_mut(&mut self) -> &mut MeleeChargeData {
        &mut self.creature_melee_charge
    }
    fn simultaneous_vehicle_usage(&self) -> &i32 {
        &self.simultaneous_vehicle_usage
    }
    fn simultaneous_vehicle_usage_mut(&mut self) -> &mut i32 {
        &mut self.simultaneous_vehicle_usage
    }
    fn min_vehicle_booking_delay_on_token_available(&self) -> &f32 {
        &self.min_vehicle_booking_delay_on_token_available
    }
    fn min_vehicle_booking_delay_on_token_available_mut(&mut self) -> &mut f32 {
        &mut self.min_vehicle_booking_delay_on_token_available
    }
    fn max_vehicle_booking_delay_on_token_available(&self) -> &f32 {
        &self.max_vehicle_booking_delay_on_token_available
    }
    fn max_vehicle_booking_delay_on_token_available_mut(&mut self) -> &mut f32 {
        &mut self.max_vehicle_booking_delay_on_token_available
    }
    fn min_vehicle_entry_available_delay_after_death(&self) -> &f32 {
        &self.min_vehicle_entry_available_delay_after_death
    }
    fn min_vehicle_entry_available_delay_after_death_mut(&mut self) -> &mut f32 {
        &mut self.min_vehicle_entry_available_delay_after_death
    }
    fn max_vehicle_entry_available_delay_after_death(&self) -> &f32 {
        &self.max_vehicle_entry_available_delay_after_death
    }
    fn max_vehicle_entry_available_delay_after_death_mut(&mut self) -> &mut f32 {
        &mut self.max_vehicle_entry_available_delay_after_death
    }
    fn enemy_min_time_in_medium_intensity(&self) -> &f32 {
        &self.enemy_min_time_in_medium_intensity
    }
    fn enemy_min_time_in_medium_intensity_mut(&mut self) -> &mut f32 {
        &mut self.enemy_min_time_in_medium_intensity
    }
    fn investigate(&self) -> &InvestigateData {
        &self.investigate
    }
    fn investigate_mut(&mut self) -> &mut InvestigateData {
        &mut self.investigate
    }
    fn include_terrain_in_vision_tests(&self) -> &bool {
        &self.include_terrain_in_vision_tests
    }
    fn include_terrain_in_vision_tests_mut(&mut self) -> &mut bool {
        &mut self.include_terrain_in_vision_tests
    }
    fn use_cover_approx_fire_position_for_vision(&self) -> &bool {
        &self.use_cover_approx_fire_position_for_vision
    }
    fn use_cover_approx_fire_position_for_vision_mut(&mut self) -> &mut bool {
        &mut self.use_cover_approx_fire_position_for_vision
    }
    fn teams_with_awareness(&self) -> &Vec<super::gameplay_sim::TeamId> {
        &self.teams_with_awareness
    }
    fn teams_with_awareness_mut(&mut self) -> &mut Vec<super::gameplay_sim::TeamId> {
        &mut self.teams_with_awareness
    }
    fn enable_last_known_position_sharing(&self) -> &bool {
        &self.enable_last_known_position_sharing
    }
    fn enable_last_known_position_sharing_mut(&mut self) -> &mut bool {
        &mut self.enable_last_known_position_sharing
    }
    fn max_last_known_position_share_distance(&self) -> &f32 {
        &self.max_last_known_position_share_distance
    }
    fn max_last_known_position_share_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_last_known_position_share_distance
    }
    fn alerted_by_friendly_combat_actions(&self) -> &bool {
        &self.alerted_by_friendly_combat_actions
    }
    fn alerted_by_friendly_combat_actions_mut(&mut self) -> &mut bool {
        &mut self.alerted_by_friendly_combat_actions
    }
    fn being_charged_causes_alert(&self) -> &bool {
        &self.being_charged_causes_alert
    }
    fn being_charged_causes_alert_mut(&mut self) -> &mut bool {
        &mut self.being_charged_causes_alert
    }
    fn being_charged_detect_distance(&self) -> &f32 {
        &self.being_charged_detect_distance
    }
    fn being_charged_detect_distance_mut(&mut self) -> &mut f32 {
        &mut self.being_charged_detect_distance
    }
    fn being_charged_angle_limit(&self) -> &f32 {
        &self.being_charged_angle_limit
    }
    fn being_charged_angle_limit_mut(&mut self) -> &mut f32 {
        &mut self.being_charged_angle_limit
    }
    fn use_visible_l_k_p_sharing(&self) -> &bool {
        &self.use_visible_l_k_p_sharing
    }
    fn use_visible_l_k_p_sharing_mut(&mut self) -> &mut bool {
        &mut self.use_visible_l_k_p_sharing
    }
    fn use_sound_l_k_p_update(&self) -> &bool {
        &self.use_sound_l_k_p_update
    }
    fn use_sound_l_k_p_update_mut(&mut self) -> &mut bool {
        &mut self.use_sound_l_k_p_update
    }
    fn aim_at_l_k_p_when_target_lost(&self) -> &bool {
        &self.aim_at_l_k_p_when_target_lost
    }
    fn aim_at_l_k_p_when_target_lost_mut(&mut self) -> &mut bool {
        &mut self.aim_at_l_k_p_when_target_lost
    }
    fn max_last_seen_distance_for_l_k_p_lost(&self) -> &f32 {
        &self.max_last_seen_distance_for_l_k_p_lost
    }
    fn max_last_seen_distance_for_l_k_p_lost_mut(&mut self) -> &mut f32 {
        &mut self.max_last_seen_distance_for_l_k_p_lost
    }
    fn min_reaction_time_for_l_k_p_reaqcuire(&self) -> &f32 {
        &self.min_reaction_time_for_l_k_p_reaqcuire
    }
    fn min_reaction_time_for_l_k_p_reaqcuire_mut(&mut self) -> &mut f32 {
        &mut self.min_reaction_time_for_l_k_p_reaqcuire
    }
    fn max_reaction_time_for_l_k_p_reaqcuire(&self) -> &f32 {
        &self.max_reaction_time_for_l_k_p_reaqcuire
    }
    fn max_reaction_time_for_l_k_p_reaqcuire_mut(&mut self) -> &mut f32 {
        &mut self.max_reaction_time_for_l_k_p_reaqcuire
    }
    fn target_coordination(&self) -> &TargetCoordinationGlobalSettings {
        &self.target_coordination
    }
    fn target_coordination_mut(&mut self) -> &mut TargetCoordinationGlobalSettings {
        &mut self.target_coordination
    }
    fn temperature(&self) -> &TemperatureData {
        &self.temperature
    }
    fn temperature_mut(&mut self) -> &mut TemperatureData {
        &mut self.temperature
    }
}

pub static GAMETWEAKCOMMON_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakCommon",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GameTweakCommon as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseNewSensingAreas",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, use_new_sensing_areas),
            },
            FieldInfoData {
                name: "SensingAreas",
                flags: MemberInfoFlags::new(144),
                field_type: "SensingArea-Array",
                rust_offset: offset_of!(GameTweakCommon, sensing_areas),
            },
            FieldInfoData {
                name: "SensingAreasAlertedModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "SensingAreaModifier",
                rust_offset: offset_of!(GameTweakCommon, sensing_areas_alerted_modifier),
            },
            FieldInfoData {
                name: "SensingConeRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_range),
            },
            FieldInfoData {
                name: "SensingConeRangeWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_range_when_alerted),
            },
            FieldInfoData {
                name: "SensingConeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_angle),
            },
            FieldInfoData {
                name: "SensingConeAngleWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_angle_when_alerted),
            },
            FieldInfoData {
                name: "SensingConeAngleAbove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_angle_above),
            },
            FieldInfoData {
                name: "SensingConeAngleBelow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_angle_below),
            },
            FieldInfoData {
                name: "SensingShotFiredDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_shot_fired_distance),
            },
            FieldInfoData {
                name: "SensingHumanDrivenVehicleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_human_driven_vehicle_distance),
            },
            FieldInfoData {
                name: "SensingExplosionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_explosion_distance),
            },
            FieldInfoData {
                name: "SensingGrenadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_grenade_distance),
            },
            FieldInfoData {
                name: "SensingStaticTargetObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_static_target_object_distance),
            },
            FieldInfoData {
                name: "SensingMovingTargetObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, sensing_moving_target_object_distance),
            },
            FieldInfoData {
                name: "DistanceToAwareTimeCurveCentral",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(GameTweakCommon, distance_to_aware_time_curve_central),
            },
            FieldInfoData {
                name: "AwareCurveCentralAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, aware_curve_central_angle),
            },
            FieldInfoData {
                name: "DistanceToAwareTimeCurvePeripheral",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(GameTweakCommon, distance_to_aware_time_curve_peripheral),
            },
            FieldInfoData {
                name: "AwareStandingPenaltyMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, aware_standing_penalty_multiplier),
            },
            FieldInfoData {
                name: "AwareToAlertTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, aware_to_alert_time),
            },
            FieldInfoData {
                name: "Corpse",
                flags: MemberInfoFlags::new(0),
                field_type: "CorpseData",
                rust_offset: offset_of!(GameTweakCommon, corpse),
            },
            FieldInfoData {
                name: "EnableVisibilityAcummulation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, enable_visibility_acummulation),
            },
            FieldInfoData {
                name: "VisibilityAcummulationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, visibility_acummulation_time),
            },
            FieldInfoData {
                name: "HighIntensityRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, high_intensity_radius),
            },
            FieldInfoData {
                name: "InvestigateSeenEnemyAlertPercent",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, investigate_seen_enemy_alert_percent),
            },
            FieldInfoData {
                name: "IgnoreSoundWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, ignore_sound_when_alerted),
            },
            FieldInfoData {
                name: "ConcealmentCoolDownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, concealment_cool_down_time),
            },
            FieldInfoData {
                name: "ConcealmentDisableAtDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, concealment_disable_at_distance),
            },
            FieldInfoData {
                name: "Passivity",
                flags: MemberInfoFlags::new(0),
                field_type: "PassivityData",
                rust_offset: offset_of!(GameTweakCommon, passivity),
            },
            FieldInfoData {
                name: "GrenadeTokens",
                flags: MemberInfoFlags::new(144),
                field_type: "GrenadeTokenList-Array",
                rust_offset: offset_of!(GameTweakCommon, grenade_tokens),
            },
            FieldInfoData {
                name: "MeleeCharge",
                flags: MemberInfoFlags::new(0),
                field_type: "MeleeChargeData",
                rust_offset: offset_of!(GameTweakCommon, melee_charge),
            },
            FieldInfoData {
                name: "CreatureMeleeCharge",
                flags: MemberInfoFlags::new(0),
                field_type: "MeleeChargeData",
                rust_offset: offset_of!(GameTweakCommon, creature_melee_charge),
            },
            FieldInfoData {
                name: "SimultaneousVehicleUsage",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(GameTweakCommon, simultaneous_vehicle_usage),
            },
            FieldInfoData {
                name: "MinVehicleBookingDelayOnTokenAvailable",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, min_vehicle_booking_delay_on_token_available),
            },
            FieldInfoData {
                name: "MaxVehicleBookingDelayOnTokenAvailable",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, max_vehicle_booking_delay_on_token_available),
            },
            FieldInfoData {
                name: "MinVehicleEntryAvailableDelayAfterDeath",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, min_vehicle_entry_available_delay_after_death),
            },
            FieldInfoData {
                name: "MaxVehicleEntryAvailableDelayAfterDeath",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, max_vehicle_entry_available_delay_after_death),
            },
            FieldInfoData {
                name: "EnemyMinTimeInMediumIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, enemy_min_time_in_medium_intensity),
            },
            FieldInfoData {
                name: "Investigate",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateData",
                rust_offset: offset_of!(GameTweakCommon, investigate),
            },
            FieldInfoData {
                name: "IncludeTerrainInVisionTests",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, include_terrain_in_vision_tests),
            },
            FieldInfoData {
                name: "UseCoverApproxFirePositionForVision",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, use_cover_approx_fire_position_for_vision),
            },
            FieldInfoData {
                name: "TeamsWithAwareness",
                flags: MemberInfoFlags::new(144),
                field_type: "TeamId-Array",
                rust_offset: offset_of!(GameTweakCommon, teams_with_awareness),
            },
            FieldInfoData {
                name: "EnableLastKnownPositionSharing",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, enable_last_known_position_sharing),
            },
            FieldInfoData {
                name: "MaxLastKnownPositionShareDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, max_last_known_position_share_distance),
            },
            FieldInfoData {
                name: "AlertedByFriendlyCombatActions",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, alerted_by_friendly_combat_actions),
            },
            FieldInfoData {
                name: "BeingChargedCausesAlert",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, being_charged_causes_alert),
            },
            FieldInfoData {
                name: "BeingChargedDetectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, being_charged_detect_distance),
            },
            FieldInfoData {
                name: "BeingChargedAngleLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, being_charged_angle_limit),
            },
            FieldInfoData {
                name: "UseVisibleLKPSharing",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, use_visible_l_k_p_sharing),
            },
            FieldInfoData {
                name: "UseSoundLKPUpdate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, use_sound_l_k_p_update),
            },
            FieldInfoData {
                name: "AimAtLKPWhenTargetLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(GameTweakCommon, aim_at_l_k_p_when_target_lost),
            },
            FieldInfoData {
                name: "MaxLastSeenDistanceForLKPLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, max_last_seen_distance_for_l_k_p_lost),
            },
            FieldInfoData {
                name: "MinReactionTimeForLKPReaqcuire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, min_reaction_time_for_l_k_p_reaqcuire),
            },
            FieldInfoData {
                name: "MaxReactionTimeForLKPReaqcuire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GameTweakCommon, max_reaction_time_for_l_k_p_reaqcuire),
            },
            FieldInfoData {
                name: "TargetCoordination",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetCoordinationGlobalSettings",
                rust_offset: offset_of!(GameTweakCommon, target_coordination),
            },
            FieldInfoData {
                name: "Temperature",
                flags: MemberInfoFlags::new(0),
                field_type: "TemperatureData",
                rust_offset: offset_of!(GameTweakCommon, temperature),
            },
        ],
    }),
    array_type: Some(GAMETWEAKCOMMON_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameTweakCommon {
    fn type_info(&self) -> &'static TypeInfo {
        GAMETWEAKCOMMON_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GAMETWEAKCOMMON_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakCommon-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakCommon"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CorpseData {
    pub instantly_alerted_by_corpse: bool,
    pub corpse_alert_distance: f32,
    pub allow_multiple_corpse_investigators: bool,
    pub corpses_cause_alertness_increase: bool,
    pub corpses_trigger_search_area: bool,
}

pub trait CorpseDataTrait: TypeObject {
    fn instantly_alerted_by_corpse(&self) -> &bool;
    fn instantly_alerted_by_corpse_mut(&mut self) -> &mut bool;
    fn corpse_alert_distance(&self) -> &f32;
    fn corpse_alert_distance_mut(&mut self) -> &mut f32;
    fn allow_multiple_corpse_investigators(&self) -> &bool;
    fn allow_multiple_corpse_investigators_mut(&mut self) -> &mut bool;
    fn corpses_cause_alertness_increase(&self) -> &bool;
    fn corpses_cause_alertness_increase_mut(&mut self) -> &mut bool;
    fn corpses_trigger_search_area(&self) -> &bool;
    fn corpses_trigger_search_area_mut(&mut self) -> &mut bool;
}

impl CorpseDataTrait for CorpseData {
    fn instantly_alerted_by_corpse(&self) -> &bool {
        &self.instantly_alerted_by_corpse
    }
    fn instantly_alerted_by_corpse_mut(&mut self) -> &mut bool {
        &mut self.instantly_alerted_by_corpse
    }
    fn corpse_alert_distance(&self) -> &f32 {
        &self.corpse_alert_distance
    }
    fn corpse_alert_distance_mut(&mut self) -> &mut f32 {
        &mut self.corpse_alert_distance
    }
    fn allow_multiple_corpse_investigators(&self) -> &bool {
        &self.allow_multiple_corpse_investigators
    }
    fn allow_multiple_corpse_investigators_mut(&mut self) -> &mut bool {
        &mut self.allow_multiple_corpse_investigators
    }
    fn corpses_cause_alertness_increase(&self) -> &bool {
        &self.corpses_cause_alertness_increase
    }
    fn corpses_cause_alertness_increase_mut(&mut self) -> &mut bool {
        &mut self.corpses_cause_alertness_increase
    }
    fn corpses_trigger_search_area(&self) -> &bool {
        &self.corpses_trigger_search_area
    }
    fn corpses_trigger_search_area_mut(&mut self) -> &mut bool {
        &mut self.corpses_trigger_search_area
    }
}

pub static CORPSEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorpseData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CorpseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InstantlyAlertedByCorpse",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorpseData, instantly_alerted_by_corpse),
            },
            FieldInfoData {
                name: "CorpseAlertDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CorpseData, corpse_alert_distance),
            },
            FieldInfoData {
                name: "AllowMultipleCorpseInvestigators",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorpseData, allow_multiple_corpse_investigators),
            },
            FieldInfoData {
                name: "CorpsesCauseAlertnessIncrease",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorpseData, corpses_cause_alertness_increase),
            },
            FieldInfoData {
                name: "CorpsesTriggerSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CorpseData, corpses_trigger_search_area),
            },
        ],
    }),
    array_type: Some(CORPSEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CorpseData {
    fn type_info(&self) -> &'static TypeInfo {
        CORPSEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CORPSEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorpseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CorpseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TemperatureData {
    pub use_temperature_settings: bool,
    pub search_threshold: f32,
    pub alert_threshold: f32,
    pub cooldown_timer: f32,
    pub cooldown_per_second: f32,
    pub broadcast_react_cooldown: f32,
    pub visual_temperature: u8,
    pub aware_modifier: Option<Arc<Mutex<dyn AwareModifierSettingsTrait>>>,
}

pub trait TemperatureDataTrait: TypeObject {
    fn use_temperature_settings(&self) -> &bool;
    fn use_temperature_settings_mut(&mut self) -> &mut bool;
    fn search_threshold(&self) -> &f32;
    fn search_threshold_mut(&mut self) -> &mut f32;
    fn alert_threshold(&self) -> &f32;
    fn alert_threshold_mut(&mut self) -> &mut f32;
    fn cooldown_timer(&self) -> &f32;
    fn cooldown_timer_mut(&mut self) -> &mut f32;
    fn cooldown_per_second(&self) -> &f32;
    fn cooldown_per_second_mut(&mut self) -> &mut f32;
    fn broadcast_react_cooldown(&self) -> &f32;
    fn broadcast_react_cooldown_mut(&mut self) -> &mut f32;
    fn visual_temperature(&self) -> &u8;
    fn visual_temperature_mut(&mut self) -> &mut u8;
    fn aware_modifier(&self) -> &Option<Arc<Mutex<dyn AwareModifierSettingsTrait>>>;
    fn aware_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AwareModifierSettingsTrait>>>;
}

impl TemperatureDataTrait for TemperatureData {
    fn use_temperature_settings(&self) -> &bool {
        &self.use_temperature_settings
    }
    fn use_temperature_settings_mut(&mut self) -> &mut bool {
        &mut self.use_temperature_settings
    }
    fn search_threshold(&self) -> &f32 {
        &self.search_threshold
    }
    fn search_threshold_mut(&mut self) -> &mut f32 {
        &mut self.search_threshold
    }
    fn alert_threshold(&self) -> &f32 {
        &self.alert_threshold
    }
    fn alert_threshold_mut(&mut self) -> &mut f32 {
        &mut self.alert_threshold
    }
    fn cooldown_timer(&self) -> &f32 {
        &self.cooldown_timer
    }
    fn cooldown_timer_mut(&mut self) -> &mut f32 {
        &mut self.cooldown_timer
    }
    fn cooldown_per_second(&self) -> &f32 {
        &self.cooldown_per_second
    }
    fn cooldown_per_second_mut(&mut self) -> &mut f32 {
        &mut self.cooldown_per_second
    }
    fn broadcast_react_cooldown(&self) -> &f32 {
        &self.broadcast_react_cooldown
    }
    fn broadcast_react_cooldown_mut(&mut self) -> &mut f32 {
        &mut self.broadcast_react_cooldown
    }
    fn visual_temperature(&self) -> &u8 {
        &self.visual_temperature
    }
    fn visual_temperature_mut(&mut self) -> &mut u8 {
        &mut self.visual_temperature
    }
    fn aware_modifier(&self) -> &Option<Arc<Mutex<dyn AwareModifierSettingsTrait>>> {
        &self.aware_modifier
    }
    fn aware_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AwareModifierSettingsTrait>>> {
        &mut self.aware_modifier
    }
}

pub static TEMPERATUREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TemperatureData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TemperatureData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseTemperatureSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TemperatureData, use_temperature_settings),
            },
            FieldInfoData {
                name: "SearchThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TemperatureData, search_threshold),
            },
            FieldInfoData {
                name: "AlertThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TemperatureData, alert_threshold),
            },
            FieldInfoData {
                name: "CooldownTimer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TemperatureData, cooldown_timer),
            },
            FieldInfoData {
                name: "CooldownPerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TemperatureData, cooldown_per_second),
            },
            FieldInfoData {
                name: "BroadcastReactCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TemperatureData, broadcast_react_cooldown),
            },
            FieldInfoData {
                name: "VisualTemperature",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(TemperatureData, visual_temperature),
            },
            FieldInfoData {
                name: "AwareModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "AwareModifierSettings",
                rust_offset: offset_of!(TemperatureData, aware_modifier),
            },
        ],
    }),
    array_type: Some(TEMPERATUREDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TemperatureData {
    fn type_info(&self) -> &'static TypeInfo {
        TEMPERATUREDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TEMPERATUREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TemperatureData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TemperatureData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct InvestigateData {
    pub max_time_since_enemy_lost_to_start_combat_investigate: f32,
    pub max_time_since_enemy_lost_to_search: f32,
    pub combat_investigate_can_exceed_max_search_time: bool,
    pub min_time_to_stay_alert_when_alerted_by_something_other_than_sighting: f32,
    pub area_search_without_combat_investigate: bool,
    pub investigate_latest_sound: bool,
    pub fallback_to_search_area_when_never_seen_enemy_time: f32,
    pub min_time_from_recent_threat_to_search_area: f32,
    pub use_investigation_priorities: bool,
    pub investigate_customization: InvestigateSettignsCustomizations,
}

pub trait InvestigateDataTrait: TypeObject {
    fn max_time_since_enemy_lost_to_start_combat_investigate(&self) -> &f32;
    fn max_time_since_enemy_lost_to_start_combat_investigate_mut(&mut self) -> &mut f32;
    fn max_time_since_enemy_lost_to_search(&self) -> &f32;
    fn max_time_since_enemy_lost_to_search_mut(&mut self) -> &mut f32;
    fn combat_investigate_can_exceed_max_search_time(&self) -> &bool;
    fn combat_investigate_can_exceed_max_search_time_mut(&mut self) -> &mut bool;
    fn min_time_to_stay_alert_when_alerted_by_something_other_than_sighting(&self) -> &f32;
    fn min_time_to_stay_alert_when_alerted_by_something_other_than_sighting_mut(&mut self) -> &mut f32;
    fn area_search_without_combat_investigate(&self) -> &bool;
    fn area_search_without_combat_investigate_mut(&mut self) -> &mut bool;
    fn investigate_latest_sound(&self) -> &bool;
    fn investigate_latest_sound_mut(&mut self) -> &mut bool;
    fn fallback_to_search_area_when_never_seen_enemy_time(&self) -> &f32;
    fn fallback_to_search_area_when_never_seen_enemy_time_mut(&mut self) -> &mut f32;
    fn min_time_from_recent_threat_to_search_area(&self) -> &f32;
    fn min_time_from_recent_threat_to_search_area_mut(&mut self) -> &mut f32;
    fn use_investigation_priorities(&self) -> &bool;
    fn use_investigation_priorities_mut(&mut self) -> &mut bool;
    fn investigate_customization(&self) -> &InvestigateSettignsCustomizations;
    fn investigate_customization_mut(&mut self) -> &mut InvestigateSettignsCustomizations;
}

impl InvestigateDataTrait for InvestigateData {
    fn max_time_since_enemy_lost_to_start_combat_investigate(&self) -> &f32 {
        &self.max_time_since_enemy_lost_to_start_combat_investigate
    }
    fn max_time_since_enemy_lost_to_start_combat_investigate_mut(&mut self) -> &mut f32 {
        &mut self.max_time_since_enemy_lost_to_start_combat_investigate
    }
    fn max_time_since_enemy_lost_to_search(&self) -> &f32 {
        &self.max_time_since_enemy_lost_to_search
    }
    fn max_time_since_enemy_lost_to_search_mut(&mut self) -> &mut f32 {
        &mut self.max_time_since_enemy_lost_to_search
    }
    fn combat_investigate_can_exceed_max_search_time(&self) -> &bool {
        &self.combat_investigate_can_exceed_max_search_time
    }
    fn combat_investigate_can_exceed_max_search_time_mut(&mut self) -> &mut bool {
        &mut self.combat_investigate_can_exceed_max_search_time
    }
    fn min_time_to_stay_alert_when_alerted_by_something_other_than_sighting(&self) -> &f32 {
        &self.min_time_to_stay_alert_when_alerted_by_something_other_than_sighting
    }
    fn min_time_to_stay_alert_when_alerted_by_something_other_than_sighting_mut(&mut self) -> &mut f32 {
        &mut self.min_time_to_stay_alert_when_alerted_by_something_other_than_sighting
    }
    fn area_search_without_combat_investigate(&self) -> &bool {
        &self.area_search_without_combat_investigate
    }
    fn area_search_without_combat_investigate_mut(&mut self) -> &mut bool {
        &mut self.area_search_without_combat_investigate
    }
    fn investigate_latest_sound(&self) -> &bool {
        &self.investigate_latest_sound
    }
    fn investigate_latest_sound_mut(&mut self) -> &mut bool {
        &mut self.investigate_latest_sound
    }
    fn fallback_to_search_area_when_never_seen_enemy_time(&self) -> &f32 {
        &self.fallback_to_search_area_when_never_seen_enemy_time
    }
    fn fallback_to_search_area_when_never_seen_enemy_time_mut(&mut self) -> &mut f32 {
        &mut self.fallback_to_search_area_when_never_seen_enemy_time
    }
    fn min_time_from_recent_threat_to_search_area(&self) -> &f32 {
        &self.min_time_from_recent_threat_to_search_area
    }
    fn min_time_from_recent_threat_to_search_area_mut(&mut self) -> &mut f32 {
        &mut self.min_time_from_recent_threat_to_search_area
    }
    fn use_investigation_priorities(&self) -> &bool {
        &self.use_investigation_priorities
    }
    fn use_investigation_priorities_mut(&mut self) -> &mut bool {
        &mut self.use_investigation_priorities
    }
    fn investigate_customization(&self) -> &InvestigateSettignsCustomizations {
        &self.investigate_customization
    }
    fn investigate_customization_mut(&mut self) -> &mut InvestigateSettignsCustomizations {
        &mut self.investigate_customization
    }
}

pub static INVESTIGATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<InvestigateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxTimeSinceEnemyLostToStartCombatInvestigate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateData, max_time_since_enemy_lost_to_start_combat_investigate),
            },
            FieldInfoData {
                name: "MaxTimeSinceEnemyLostToSearch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateData, max_time_since_enemy_lost_to_search),
            },
            FieldInfoData {
                name: "CombatInvestigateCanExceedMaxSearchTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateData, combat_investigate_can_exceed_max_search_time),
            },
            FieldInfoData {
                name: "MinTimeToStayAlertWhenAlertedBySomethingOtherThanSighting",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateData, min_time_to_stay_alert_when_alerted_by_something_other_than_sighting),
            },
            FieldInfoData {
                name: "AreaSearchWithoutCombatInvestigate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateData, area_search_without_combat_investigate),
            },
            FieldInfoData {
                name: "InvestigateLatestSound",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateData, investigate_latest_sound),
            },
            FieldInfoData {
                name: "FallbackToSearchAreaWhenNeverSeenEnemyTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateData, fallback_to_search_area_when_never_seen_enemy_time),
            },
            FieldInfoData {
                name: "MinTimeFromRecentThreatToSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(InvestigateData, min_time_from_recent_threat_to_search_area),
            },
            FieldInfoData {
                name: "UseInvestigationPriorities",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(InvestigateData, use_investigation_priorities),
            },
            FieldInfoData {
                name: "InvestigateCustomization",
                flags: MemberInfoFlags::new(0),
                field_type: "InvestigateSettignsCustomizations",
                rust_offset: offset_of!(InvestigateData, investigate_customization),
            },
        ],
    }),
    array_type: Some(INVESTIGATEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateData {
    fn type_info(&self) -> &'static TypeInfo {
        INVESTIGATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INVESTIGATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MeleeChargeData {
    pub melee_slot_count: i32,
    pub melee_slot_radius: f32,
    pub melee_slot_extrapolate_distance: f32,
    pub melee_charge_token_minimum_time: f32,
    pub melee_charge_token_maximum_time: f32,
    pub melee_charge_token_count: i32,
    pub melee_charge_minimum_cooldown_timer: f32,
    pub simultaneous_charge_count: i32,
}

pub trait MeleeChargeDataTrait: TypeObject {
    fn melee_slot_count(&self) -> &i32;
    fn melee_slot_count_mut(&mut self) -> &mut i32;
    fn melee_slot_radius(&self) -> &f32;
    fn melee_slot_radius_mut(&mut self) -> &mut f32;
    fn melee_slot_extrapolate_distance(&self) -> &f32;
    fn melee_slot_extrapolate_distance_mut(&mut self) -> &mut f32;
    fn melee_charge_token_minimum_time(&self) -> &f32;
    fn melee_charge_token_minimum_time_mut(&mut self) -> &mut f32;
    fn melee_charge_token_maximum_time(&self) -> &f32;
    fn melee_charge_token_maximum_time_mut(&mut self) -> &mut f32;
    fn melee_charge_token_count(&self) -> &i32;
    fn melee_charge_token_count_mut(&mut self) -> &mut i32;
    fn melee_charge_minimum_cooldown_timer(&self) -> &f32;
    fn melee_charge_minimum_cooldown_timer_mut(&mut self) -> &mut f32;
    fn simultaneous_charge_count(&self) -> &i32;
    fn simultaneous_charge_count_mut(&mut self) -> &mut i32;
}

impl MeleeChargeDataTrait for MeleeChargeData {
    fn melee_slot_count(&self) -> &i32 {
        &self.melee_slot_count
    }
    fn melee_slot_count_mut(&mut self) -> &mut i32 {
        &mut self.melee_slot_count
    }
    fn melee_slot_radius(&self) -> &f32 {
        &self.melee_slot_radius
    }
    fn melee_slot_radius_mut(&mut self) -> &mut f32 {
        &mut self.melee_slot_radius
    }
    fn melee_slot_extrapolate_distance(&self) -> &f32 {
        &self.melee_slot_extrapolate_distance
    }
    fn melee_slot_extrapolate_distance_mut(&mut self) -> &mut f32 {
        &mut self.melee_slot_extrapolate_distance
    }
    fn melee_charge_token_minimum_time(&self) -> &f32 {
        &self.melee_charge_token_minimum_time
    }
    fn melee_charge_token_minimum_time_mut(&mut self) -> &mut f32 {
        &mut self.melee_charge_token_minimum_time
    }
    fn melee_charge_token_maximum_time(&self) -> &f32 {
        &self.melee_charge_token_maximum_time
    }
    fn melee_charge_token_maximum_time_mut(&mut self) -> &mut f32 {
        &mut self.melee_charge_token_maximum_time
    }
    fn melee_charge_token_count(&self) -> &i32 {
        &self.melee_charge_token_count
    }
    fn melee_charge_token_count_mut(&mut self) -> &mut i32 {
        &mut self.melee_charge_token_count
    }
    fn melee_charge_minimum_cooldown_timer(&self) -> &f32 {
        &self.melee_charge_minimum_cooldown_timer
    }
    fn melee_charge_minimum_cooldown_timer_mut(&mut self) -> &mut f32 {
        &mut self.melee_charge_minimum_cooldown_timer
    }
    fn simultaneous_charge_count(&self) -> &i32 {
        &self.simultaneous_charge_count
    }
    fn simultaneous_charge_count_mut(&mut self) -> &mut i32 {
        &mut self.simultaneous_charge_count
    }
}

pub static MELEECHARGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeChargeData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MeleeChargeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MeleeSlotCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MeleeChargeData, melee_slot_count),
            },
            FieldInfoData {
                name: "MeleeSlotRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeData, melee_slot_radius),
            },
            FieldInfoData {
                name: "MeleeSlotExtrapolateDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeData, melee_slot_extrapolate_distance),
            },
            FieldInfoData {
                name: "MeleeChargeTokenMinimumTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeData, melee_charge_token_minimum_time),
            },
            FieldInfoData {
                name: "MeleeChargeTokenMaximumTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeData, melee_charge_token_maximum_time),
            },
            FieldInfoData {
                name: "MeleeChargeTokenCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MeleeChargeData, melee_charge_token_count),
            },
            FieldInfoData {
                name: "MeleeChargeMinimumCooldownTimer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MeleeChargeData, melee_charge_minimum_cooldown_timer),
            },
            FieldInfoData {
                name: "SimultaneousChargeCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MeleeChargeData, simultaneous_charge_count),
            },
        ],
    }),
    array_type: Some(MELEECHARGEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MeleeChargeData {
    fn type_info(&self) -> &'static TypeInfo {
        MELEECHARGEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MELEECHARGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeChargeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MeleeChargeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PassivityData {
    pub passive_damage_time: PiecewiseLinearCurve,
    pub passive_movement_time: PiecewiseLinearCurve,
    pub passive_movement_dist: f32,
}

pub trait PassivityDataTrait: TypeObject {
    fn passive_damage_time(&self) -> &PiecewiseLinearCurve;
    fn passive_damage_time_mut(&mut self) -> &mut PiecewiseLinearCurve;
    fn passive_movement_time(&self) -> &PiecewiseLinearCurve;
    fn passive_movement_time_mut(&mut self) -> &mut PiecewiseLinearCurve;
    fn passive_movement_dist(&self) -> &f32;
    fn passive_movement_dist_mut(&mut self) -> &mut f32;
}

impl PassivityDataTrait for PassivityData {
    fn passive_damage_time(&self) -> &PiecewiseLinearCurve {
        &self.passive_damage_time
    }
    fn passive_damage_time_mut(&mut self) -> &mut PiecewiseLinearCurve {
        &mut self.passive_damage_time
    }
    fn passive_movement_time(&self) -> &PiecewiseLinearCurve {
        &self.passive_movement_time
    }
    fn passive_movement_time_mut(&mut self) -> &mut PiecewiseLinearCurve {
        &mut self.passive_movement_time
    }
    fn passive_movement_dist(&self) -> &f32 {
        &self.passive_movement_dist
    }
    fn passive_movement_dist_mut(&mut self) -> &mut f32 {
        &mut self.passive_movement_dist
    }
}

pub static PASSIVITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PassivityData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PassivityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PassiveDamageTime",
                flags: MemberInfoFlags::new(0),
                field_type: "PiecewiseLinearCurve",
                rust_offset: offset_of!(PassivityData, passive_damage_time),
            },
            FieldInfoData {
                name: "PassiveMovementTime",
                flags: MemberInfoFlags::new(0),
                field_type: "PiecewiseLinearCurve",
                rust_offset: offset_of!(PassivityData, passive_movement_time),
            },
            FieldInfoData {
                name: "PassiveMovementDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PassivityData, passive_movement_dist),
            },
        ],
    }),
    array_type: Some(PASSIVITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PassivityData {
    fn type_info(&self) -> &'static TypeInfo {
        PASSIVITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PASSIVITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PassivityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PassivityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AwareModifierSettings {
    pub _glacier_base: super::core::DataContainer,
    pub curve: PiecewiseLinearCurve,
}

pub trait AwareModifierSettingsTrait: super::core::DataContainerTrait {
    fn curve(&self) -> &PiecewiseLinearCurve;
    fn curve_mut(&mut self) -> &mut PiecewiseLinearCurve;
}

impl AwareModifierSettingsTrait for AwareModifierSettings {
    fn curve(&self) -> &PiecewiseLinearCurve {
        &self.curve
    }
    fn curve_mut(&mut self) -> &mut PiecewiseLinearCurve {
        &mut self.curve
    }
}

impl super::core::DataContainerTrait for AwareModifierSettings {
}

pub static AWAREMODIFIERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwareModifierSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AwareModifierSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(0),
                field_type: "PiecewiseLinearCurve",
                rust_offset: offset_of!(AwareModifierSettings, curve),
            },
        ],
    }),
    array_type: Some(AWAREMODIFIERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AwareModifierSettings {
    fn type_info(&self) -> &'static TypeInfo {
        AWAREMODIFIERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AWAREMODIFIERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwareModifierSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AwareModifierSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SensingAreaModifier {
    pub settings: Vec<SensingAreaModifierSettings>,
}

pub trait SensingAreaModifierTrait: TypeObject {
    fn settings(&self) -> &Vec<SensingAreaModifierSettings>;
    fn settings_mut(&mut self) -> &mut Vec<SensingAreaModifierSettings>;
}

impl SensingAreaModifierTrait for SensingAreaModifier {
    fn settings(&self) -> &Vec<SensingAreaModifierSettings> {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut Vec<SensingAreaModifierSettings> {
        &mut self.settings
    }
}

pub static SENSINGAREAMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifier",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SensingAreaModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(144),
                field_type: "SensingAreaModifierSettings-Array",
                rust_offset: offset_of!(SensingAreaModifier, settings),
            },
        ],
    }),
    array_type: Some(SENSINGAREAMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SensingAreaModifier {
    fn type_info(&self) -> &'static TypeInfo {
        SENSINGAREAMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SENSINGAREAMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingAreaModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SensingAreaModifierSettings {
    pub affected_areas: Vec<SensingAreaId>,
    pub required_tactics: Vec<Tactics>,
    pub set_enabled: bool,
    pub set_disabled: bool,
    pub range_scale: f32,
    pub angle_scale: f32,
    pub angle_above_scale: f32,
    pub angle_below_scale: f32,
    pub time_scale: f32,
}

pub trait SensingAreaModifierSettingsTrait: TypeObject {
    fn affected_areas(&self) -> &Vec<SensingAreaId>;
    fn affected_areas_mut(&mut self) -> &mut Vec<SensingAreaId>;
    fn required_tactics(&self) -> &Vec<Tactics>;
    fn required_tactics_mut(&mut self) -> &mut Vec<Tactics>;
    fn set_enabled(&self) -> &bool;
    fn set_enabled_mut(&mut self) -> &mut bool;
    fn set_disabled(&self) -> &bool;
    fn set_disabled_mut(&mut self) -> &mut bool;
    fn range_scale(&self) -> &f32;
    fn range_scale_mut(&mut self) -> &mut f32;
    fn angle_scale(&self) -> &f32;
    fn angle_scale_mut(&mut self) -> &mut f32;
    fn angle_above_scale(&self) -> &f32;
    fn angle_above_scale_mut(&mut self) -> &mut f32;
    fn angle_below_scale(&self) -> &f32;
    fn angle_below_scale_mut(&mut self) -> &mut f32;
    fn time_scale(&self) -> &f32;
    fn time_scale_mut(&mut self) -> &mut f32;
}

impl SensingAreaModifierSettingsTrait for SensingAreaModifierSettings {
    fn affected_areas(&self) -> &Vec<SensingAreaId> {
        &self.affected_areas
    }
    fn affected_areas_mut(&mut self) -> &mut Vec<SensingAreaId> {
        &mut self.affected_areas
    }
    fn required_tactics(&self) -> &Vec<Tactics> {
        &self.required_tactics
    }
    fn required_tactics_mut(&mut self) -> &mut Vec<Tactics> {
        &mut self.required_tactics
    }
    fn set_enabled(&self) -> &bool {
        &self.set_enabled
    }
    fn set_enabled_mut(&mut self) -> &mut bool {
        &mut self.set_enabled
    }
    fn set_disabled(&self) -> &bool {
        &self.set_disabled
    }
    fn set_disabled_mut(&mut self) -> &mut bool {
        &mut self.set_disabled
    }
    fn range_scale(&self) -> &f32 {
        &self.range_scale
    }
    fn range_scale_mut(&mut self) -> &mut f32 {
        &mut self.range_scale
    }
    fn angle_scale(&self) -> &f32 {
        &self.angle_scale
    }
    fn angle_scale_mut(&mut self) -> &mut f32 {
        &mut self.angle_scale
    }
    fn angle_above_scale(&self) -> &f32 {
        &self.angle_above_scale
    }
    fn angle_above_scale_mut(&mut self) -> &mut f32 {
        &mut self.angle_above_scale
    }
    fn angle_below_scale(&self) -> &f32 {
        &self.angle_below_scale
    }
    fn angle_below_scale_mut(&mut self) -> &mut f32 {
        &mut self.angle_below_scale
    }
    fn time_scale(&self) -> &f32 {
        &self.time_scale
    }
    fn time_scale_mut(&mut self) -> &mut f32 {
        &mut self.time_scale
    }
}

pub static SENSINGAREAMODIFIERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifierSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SensingAreaModifierSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AffectedAreas",
                flags: MemberInfoFlags::new(144),
                field_type: "SensingAreaId-Array",
                rust_offset: offset_of!(SensingAreaModifierSettings, affected_areas),
            },
            FieldInfoData {
                name: "RequiredTactics",
                flags: MemberInfoFlags::new(144),
                field_type: "Tactics-Array",
                rust_offset: offset_of!(SensingAreaModifierSettings, required_tactics),
            },
            FieldInfoData {
                name: "SetEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SensingAreaModifierSettings, set_enabled),
            },
            FieldInfoData {
                name: "SetDisabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SensingAreaModifierSettings, set_disabled),
            },
            FieldInfoData {
                name: "RangeScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingAreaModifierSettings, range_scale),
            },
            FieldInfoData {
                name: "AngleScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingAreaModifierSettings, angle_scale),
            },
            FieldInfoData {
                name: "AngleAboveScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingAreaModifierSettings, angle_above_scale),
            },
            FieldInfoData {
                name: "AngleBelowScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingAreaModifierSettings, angle_below_scale),
            },
            FieldInfoData {
                name: "TimeScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingAreaModifierSettings, time_scale),
            },
        ],
    }),
    array_type: Some(SENSINGAREAMODIFIERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SensingAreaModifierSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SENSINGAREAMODIFIERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SENSINGAREAMODIFIERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifierSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingAreaModifierSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SensingArea {
    pub area_id: SensingAreaId,
    pub enabled: bool,
    pub range: f32,
    pub angle: f32,
    pub angle_above: f32,
    pub angle_below: f32,
    pub aware_time_distance_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub aware_time_angle_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub time_scale: f32,
    pub enabled_ref_count: i32,
}

pub trait SensingAreaTrait: TypeObject {
    fn area_id(&self) -> &SensingAreaId;
    fn area_id_mut(&mut self) -> &mut SensingAreaId;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn range(&self) -> &f32;
    fn range_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
    fn angle_above(&self) -> &f32;
    fn angle_above_mut(&mut self) -> &mut f32;
    fn angle_below(&self) -> &f32;
    fn angle_below_mut(&mut self) -> &mut f32;
    fn aware_time_distance_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn aware_time_distance_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn aware_time_angle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn aware_time_angle_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn time_scale(&self) -> &f32;
    fn time_scale_mut(&mut self) -> &mut f32;
    fn enabled_ref_count(&self) -> &i32;
    fn enabled_ref_count_mut(&mut self) -> &mut i32;
}

impl SensingAreaTrait for SensingArea {
    fn area_id(&self) -> &SensingAreaId {
        &self.area_id
    }
    fn area_id_mut(&mut self) -> &mut SensingAreaId {
        &mut self.area_id
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn range(&self) -> &f32 {
        &self.range
    }
    fn range_mut(&mut self) -> &mut f32 {
        &mut self.range
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
    fn angle_above(&self) -> &f32 {
        &self.angle_above
    }
    fn angle_above_mut(&mut self) -> &mut f32 {
        &mut self.angle_above
    }
    fn angle_below(&self) -> &f32 {
        &self.angle_below
    }
    fn angle_below_mut(&mut self) -> &mut f32 {
        &mut self.angle_below
    }
    fn aware_time_distance_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.aware_time_distance_curve
    }
    fn aware_time_distance_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.aware_time_distance_curve
    }
    fn aware_time_angle_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.aware_time_angle_curve
    }
    fn aware_time_angle_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.aware_time_angle_curve
    }
    fn time_scale(&self) -> &f32 {
        &self.time_scale
    }
    fn time_scale_mut(&mut self) -> &mut f32 {
        &mut self.time_scale
    }
    fn enabled_ref_count(&self) -> &i32 {
        &self.enabled_ref_count
    }
    fn enabled_ref_count_mut(&mut self) -> &mut i32 {
        &mut self.enabled_ref_count
    }
}

pub static SENSINGAREA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingArea",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SensingArea as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AreaId",
                flags: MemberInfoFlags::new(0),
                field_type: "SensingAreaId",
                rust_offset: offset_of!(SensingArea, area_id),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SensingArea, enabled),
            },
            FieldInfoData {
                name: "Range",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingArea, range),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingArea, angle),
            },
            FieldInfoData {
                name: "AngleAbove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingArea, angle_above),
            },
            FieldInfoData {
                name: "AngleBelow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingArea, angle_below),
            },
            FieldInfoData {
                name: "AwareTimeDistanceCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(SensingArea, aware_time_distance_curve),
            },
            FieldInfoData {
                name: "AwareTimeAngleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(SensingArea, aware_time_angle_curve),
            },
            FieldInfoData {
                name: "TimeScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SensingArea, time_scale),
            },
            FieldInfoData {
                name: "EnabledRefCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SensingArea, enabled_ref_count),
            },
        ],
    }),
    array_type: Some(SENSINGAREA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SensingArea {
    fn type_info(&self) -> &'static TypeInfo {
        SENSINGAREA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SENSINGAREA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingArea-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingArea"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SensingAreaId {
    pub area_category: i32,
    pub area_type: i32,
}

pub trait SensingAreaIdTrait: TypeObject {
    fn area_category(&self) -> &i32;
    fn area_category_mut(&mut self) -> &mut i32;
    fn area_type(&self) -> &i32;
    fn area_type_mut(&mut self) -> &mut i32;
}

impl SensingAreaIdTrait for SensingAreaId {
    fn area_category(&self) -> &i32 {
        &self.area_category
    }
    fn area_category_mut(&mut self) -> &mut i32 {
        &mut self.area_category
    }
    fn area_type(&self) -> &i32 {
        &self.area_type
    }
    fn area_type_mut(&mut self) -> &mut i32 {
        &mut self.area_type
    }
}

pub static SENSINGAREAID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaId",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SensingAreaId as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AreaCategory",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SensingAreaId, area_category),
            },
            FieldInfoData {
                name: "AreaType",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SensingAreaId, area_type),
            },
        ],
    }),
    array_type: Some(SENSINGAREAID_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SensingAreaId {
    fn type_info(&self) -> &'static TypeInfo {
        SENSINGAREAID_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SENSINGAREAID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaId-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingAreaId"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GrenadeTokenList {
    pub token_type: GrenadeTokenType,
    pub grenade_minimum_time: f32,
    pub grenade_maximum_time: f32,
    pub max_simultaneous_grenades: i32,
}

pub trait GrenadeTokenListTrait: TypeObject {
    fn token_type(&self) -> &GrenadeTokenType;
    fn token_type_mut(&mut self) -> &mut GrenadeTokenType;
    fn grenade_minimum_time(&self) -> &f32;
    fn grenade_minimum_time_mut(&mut self) -> &mut f32;
    fn grenade_maximum_time(&self) -> &f32;
    fn grenade_maximum_time_mut(&mut self) -> &mut f32;
    fn max_simultaneous_grenades(&self) -> &i32;
    fn max_simultaneous_grenades_mut(&mut self) -> &mut i32;
}

impl GrenadeTokenListTrait for GrenadeTokenList {
    fn token_type(&self) -> &GrenadeTokenType {
        &self.token_type
    }
    fn token_type_mut(&mut self) -> &mut GrenadeTokenType {
        &mut self.token_type
    }
    fn grenade_minimum_time(&self) -> &f32 {
        &self.grenade_minimum_time
    }
    fn grenade_minimum_time_mut(&mut self) -> &mut f32 {
        &mut self.grenade_minimum_time
    }
    fn grenade_maximum_time(&self) -> &f32 {
        &self.grenade_maximum_time
    }
    fn grenade_maximum_time_mut(&mut self) -> &mut f32 {
        &mut self.grenade_maximum_time
    }
    fn max_simultaneous_grenades(&self) -> &i32 {
        &self.max_simultaneous_grenades
    }
    fn max_simultaneous_grenades_mut(&mut self) -> &mut i32 {
        &mut self.max_simultaneous_grenades
    }
}

pub static GRENADETOKENLIST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTokenList",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GrenadeTokenList as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TokenType",
                flags: MemberInfoFlags::new(0),
                field_type: "GrenadeTokenType",
                rust_offset: offset_of!(GrenadeTokenList, token_type),
            },
            FieldInfoData {
                name: "GrenadeMinimumTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeTokenList, grenade_minimum_time),
            },
            FieldInfoData {
                name: "GrenadeMaximumTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(GrenadeTokenList, grenade_maximum_time),
            },
            FieldInfoData {
                name: "MaxSimultaneousGrenades",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(GrenadeTokenList, max_simultaneous_grenades),
            },
        ],
    }),
    array_type: Some(GRENADETOKENLIST_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GrenadeTokenList {
    fn type_info(&self) -> &'static TypeInfo {
        GRENADETOKENLIST_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GRENADETOKENLIST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTokenList-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GrenadeTokenList"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PiecewiseLinearCurve {
    pub points: Vec<CurvePoint>,
    pub interpolate_curve: bool,
}

pub trait PiecewiseLinearCurveTrait: TypeObject {
    fn points(&self) -> &Vec<CurvePoint>;
    fn points_mut(&mut self) -> &mut Vec<CurvePoint>;
    fn interpolate_curve(&self) -> &bool;
    fn interpolate_curve_mut(&mut self) -> &mut bool;
}

impl PiecewiseLinearCurveTrait for PiecewiseLinearCurve {
    fn points(&self) -> &Vec<CurvePoint> {
        &self.points
    }
    fn points_mut(&mut self) -> &mut Vec<CurvePoint> {
        &mut self.points
    }
    fn interpolate_curve(&self) -> &bool {
        &self.interpolate_curve
    }
    fn interpolate_curve_mut(&mut self) -> &mut bool {
        &mut self.interpolate_curve
    }
}

pub static PIECEWISELINEARCURVE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PiecewiseLinearCurve",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PiecewiseLinearCurve as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Points",
                flags: MemberInfoFlags::new(144),
                field_type: "CurvePoint-Array",
                rust_offset: offset_of!(PiecewiseLinearCurve, points),
            },
            FieldInfoData {
                name: "InterpolateCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(PiecewiseLinearCurve, interpolate_curve),
            },
        ],
    }),
    array_type: Some(PIECEWISELINEARCURVE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PiecewiseLinearCurve {
    fn type_info(&self) -> &'static TypeInfo {
        PIECEWISELINEARCURVE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PIECEWISELINEARCURVE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PiecewiseLinearCurve-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PiecewiseLinearCurve"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CurvePoint {
    pub x: f32,
    pub y: f32,
}

pub trait CurvePointTrait: TypeObject {
    fn x(&self) -> &f32;
    fn x_mut(&mut self) -> &mut f32;
    fn y(&self) -> &f32;
    fn y_mut(&mut self) -> &mut f32;
}

impl CurvePointTrait for CurvePoint {
    fn x(&self) -> &f32 {
        &self.x
    }
    fn x_mut(&mut self) -> &mut f32 {
        &mut self.x
    }
    fn y(&self) -> &f32 {
        &self.y
    }
    fn y_mut(&mut self) -> &mut f32 {
        &mut self.y
    }
}

pub static CURVEPOINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CurvePoint",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CurvePoint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CurvePoint, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CurvePoint, y),
            },
        ],
    }),
    array_type: Some(CURVEPOINT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CurvePoint {
    fn type_info(&self) -> &'static TypeInfo {
        CURVEPOINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CURVEPOINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CurvePoint-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CurvePoint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TinyPiecewiseLinearCurve {
    pub x0: f32,
    pub y0: f32,
    pub x1: f32,
    pub y1: f32,
}

pub trait TinyPiecewiseLinearCurveTrait: TypeObject {
    fn x0(&self) -> &f32;
    fn x0_mut(&mut self) -> &mut f32;
    fn y0(&self) -> &f32;
    fn y0_mut(&mut self) -> &mut f32;
    fn x1(&self) -> &f32;
    fn x1_mut(&mut self) -> &mut f32;
    fn y1(&self) -> &f32;
    fn y1_mut(&mut self) -> &mut f32;
}

impl TinyPiecewiseLinearCurveTrait for TinyPiecewiseLinearCurve {
    fn x0(&self) -> &f32 {
        &self.x0
    }
    fn x0_mut(&mut self) -> &mut f32 {
        &mut self.x0
    }
    fn y0(&self) -> &f32 {
        &self.y0
    }
    fn y0_mut(&mut self) -> &mut f32 {
        &mut self.y0
    }
    fn x1(&self) -> &f32 {
        &self.x1
    }
    fn x1_mut(&mut self) -> &mut f32 {
        &mut self.x1
    }
    fn y1(&self) -> &f32 {
        &self.y1
    }
    fn y1_mut(&mut self) -> &mut f32 {
        &mut self.y1
    }
}

pub static TINYPIECEWISELINEARCURVE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TinyPiecewiseLinearCurve",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TinyPiecewiseLinearCurve as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X0",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TinyPiecewiseLinearCurve, x0),
            },
            FieldInfoData {
                name: "Y0",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TinyPiecewiseLinearCurve, y0),
            },
            FieldInfoData {
                name: "X1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TinyPiecewiseLinearCurve, x1),
            },
            FieldInfoData {
                name: "Y1",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TinyPiecewiseLinearCurve, y1),
            },
        ],
    }),
    array_type: Some(TINYPIECEWISELINEARCURVE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TinyPiecewiseLinearCurve {
    fn type_info(&self) -> &'static TypeInfo {
        TINYPIECEWISELINEARCURVE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TINYPIECEWISELINEARCURVE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TinyPiecewiseLinearCurve-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TinyPiecewiseLinearCurve"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FiringPatternCollectionData {
    pub _glacier_base: super::core::Asset,
    pub patterns: Vec<FiringPatternData>,
}

pub trait FiringPatternCollectionDataTrait: super::core::AssetTrait {
    fn patterns(&self) -> &Vec<FiringPatternData>;
    fn patterns_mut(&mut self) -> &mut Vec<FiringPatternData>;
}

impl FiringPatternCollectionDataTrait for FiringPatternCollectionData {
    fn patterns(&self) -> &Vec<FiringPatternData> {
        &self.patterns
    }
    fn patterns_mut(&mut self) -> &mut Vec<FiringPatternData> {
        &mut self.patterns
    }
}

impl super::core::AssetTrait for FiringPatternCollectionData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for FiringPatternCollectionData {
}

pub static FIRINGPATTERNCOLLECTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringPatternCollectionData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FiringPatternCollectionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Patterns",
                flags: MemberInfoFlags::new(144),
                field_type: "FiringPatternData-Array",
                rust_offset: offset_of!(FiringPatternCollectionData, patterns),
            },
        ],
    }),
    array_type: Some(FIRINGPATTERNCOLLECTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FiringPatternCollectionData {
    fn type_info(&self) -> &'static TypeInfo {
        FIRINGPATTERNCOLLECTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FIRINGPATTERNCOLLECTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringPatternCollectionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FiringPatternCollectionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FiringPatternData {
    pub id: i32,
    pub pattern: u64,
    pub single_shot: bool,
    pub weapon_class: FiringWeaponClass,
    pub intensity: IntensityClass,
    pub delay: i32,
}

pub trait FiringPatternDataTrait: TypeObject {
    fn id(&self) -> &i32;
    fn id_mut(&mut self) -> &mut i32;
    fn pattern(&self) -> &u64;
    fn pattern_mut(&mut self) -> &mut u64;
    fn single_shot(&self) -> &bool;
    fn single_shot_mut(&mut self) -> &mut bool;
    fn weapon_class(&self) -> &FiringWeaponClass;
    fn weapon_class_mut(&mut self) -> &mut FiringWeaponClass;
    fn intensity(&self) -> &IntensityClass;
    fn intensity_mut(&mut self) -> &mut IntensityClass;
    fn delay(&self) -> &i32;
    fn delay_mut(&mut self) -> &mut i32;
}

impl FiringPatternDataTrait for FiringPatternData {
    fn id(&self) -> &i32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut i32 {
        &mut self.id
    }
    fn pattern(&self) -> &u64 {
        &self.pattern
    }
    fn pattern_mut(&mut self) -> &mut u64 {
        &mut self.pattern
    }
    fn single_shot(&self) -> &bool {
        &self.single_shot
    }
    fn single_shot_mut(&mut self) -> &mut bool {
        &mut self.single_shot
    }
    fn weapon_class(&self) -> &FiringWeaponClass {
        &self.weapon_class
    }
    fn weapon_class_mut(&mut self) -> &mut FiringWeaponClass {
        &mut self.weapon_class
    }
    fn intensity(&self) -> &IntensityClass {
        &self.intensity
    }
    fn intensity_mut(&mut self) -> &mut IntensityClass {
        &mut self.intensity
    }
    fn delay(&self) -> &i32 {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut i32 {
        &mut self.delay
    }
}

pub static FIRINGPATTERNDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringPatternData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FiringPatternData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FiringPatternData, id),
            },
            FieldInfoData {
                name: "Pattern",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint64",
                rust_offset: offset_of!(FiringPatternData, pattern),
            },
            FieldInfoData {
                name: "SingleShot",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FiringPatternData, single_shot),
            },
            FieldInfoData {
                name: "WeaponClass",
                flags: MemberInfoFlags::new(0),
                field_type: "FiringWeaponClass",
                rust_offset: offset_of!(FiringPatternData, weapon_class),
            },
            FieldInfoData {
                name: "Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: "IntensityClass",
                rust_offset: offset_of!(FiringPatternData, intensity),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(FiringPatternData, delay),
            },
        ],
    }),
    array_type: Some(FIRINGPATTERNDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FiringPatternData {
    fn type_info(&self) -> &'static TypeInfo {
        FIRINGPATTERNDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FIRINGPATTERNDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringPatternData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FiringPatternData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum IntensityClass {
    #[default]
    IntensityClass_Low = 0,
    IntensityClass_Medium = 1,
    IntensityClass_High = 2,
    IntensityClass_Engaging = 3,
}

pub static INTENSITYCLASS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntensityClass",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(INTENSITYCLASS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for IntensityClass {
    fn type_info(&self) -> &'static TypeInfo {
        INTENSITYCLASS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INTENSITYCLASS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntensityClass-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("IntensityClass"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum FiringWeaponClass {
    #[default]
    WeaponClass_AssaultRifle = 0,
    WeaponClass_MachineGun = 1,
    WeaponClass_Pistol = 2,
    WeaponClass_SniperRifle = 3,
    WeaponClass_SMG = 4,
    WeaponClass_Shotgun = 5,
}

pub static FIRINGWEAPONCLASS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringWeaponClass",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(FIRINGWEAPONCLASS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FiringWeaponClass {
    fn type_info(&self) -> &'static TypeInfo {
        FIRINGWEAPONCLASS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FIRINGWEAPONCLASS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringWeaponClass-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FiringWeaponClass"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProtectBaseManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub base_position: super::core::Vec3,
    pub radius: f32,
}

pub trait ProtectBaseManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn base_position(&self) -> &super::core::Vec3;
    fn base_position_mut(&mut self) -> &mut super::core::Vec3;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
}

impl ProtectBaseManeuverEntityDataTrait for ProtectBaseManeuverEntityData {
    fn base_position(&self) -> &super::core::Vec3 {
        &self.base_position
    }
    fn base_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.base_position
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
}

impl DogFightManeuverEntityBaseDataTrait for ProtectBaseManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for ProtectBaseManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for ProtectBaseManeuverEntityData {
}

impl super::core::DataBusPeerTrait for ProtectBaseManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ProtectBaseManeuverEntityData {
}

impl super::core::DataContainerTrait for ProtectBaseManeuverEntityData {
}

pub static PROTECTBASEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProtectBaseManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProtectBaseManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BasePosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ProtectBaseManeuverEntityData, base_position),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProtectBaseManeuverEntityData, radius),
            },
        ],
    }),
    array_type: Some(PROTECTBASEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ProtectBaseManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        PROTECTBASEMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROTECTBASEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProtectBaseManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ProtectBaseManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CreateDistanceManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub distance: f32,
    pub min_distance_to_break_out: f32,
    pub min_altitude: f32,
}

pub trait CreateDistanceManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn distance(&self) -> &f32;
    fn distance_mut(&mut self) -> &mut f32;
    fn min_distance_to_break_out(&self) -> &f32;
    fn min_distance_to_break_out_mut(&mut self) -> &mut f32;
    fn min_altitude(&self) -> &f32;
    fn min_altitude_mut(&mut self) -> &mut f32;
}

impl CreateDistanceManeuverEntityDataTrait for CreateDistanceManeuverEntityData {
    fn distance(&self) -> &f32 {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut f32 {
        &mut self.distance
    }
    fn min_distance_to_break_out(&self) -> &f32 {
        &self.min_distance_to_break_out
    }
    fn min_distance_to_break_out_mut(&mut self) -> &mut f32 {
        &mut self.min_distance_to_break_out
    }
    fn min_altitude(&self) -> &f32 {
        &self.min_altitude
    }
    fn min_altitude_mut(&mut self) -> &mut f32 {
        &mut self.min_altitude
    }
}

impl DogFightManeuverEntityBaseDataTrait for CreateDistanceManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for CreateDistanceManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for CreateDistanceManeuverEntityData {
}

impl super::core::DataBusPeerTrait for CreateDistanceManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CreateDistanceManeuverEntityData {
}

impl super::core::DataContainerTrait for CreateDistanceManeuverEntityData {
}

pub static CREATEDISTANCEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateDistanceManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CreateDistanceManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CreateDistanceManeuverEntityData, distance),
            },
            FieldInfoData {
                name: "MinDistanceToBreakOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CreateDistanceManeuverEntityData, min_distance_to_break_out),
            },
            FieldInfoData {
                name: "MinAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CreateDistanceManeuverEntityData, min_altitude),
            },
        ],
    }),
    array_type: Some(CREATEDISTANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CreateDistanceManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        CREATEDISTANCEMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CREATEDISTANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateDistanceManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CreateDistanceManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SetWaypointsEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub speed: f32,
    pub looping: bool,
    pub start_at_geometrically_closest_waypoint: bool,
}

pub trait SetWaypointsEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
    fn looping(&self) -> &bool;
    fn looping_mut(&mut self) -> &mut bool;
    fn start_at_geometrically_closest_waypoint(&self) -> &bool;
    fn start_at_geometrically_closest_waypoint_mut(&mut self) -> &mut bool;
}

impl SetWaypointsEntityDataTrait for SetWaypointsEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn looping_mut(&mut self) -> &mut bool {
        &mut self.looping
    }
    fn start_at_geometrically_closest_waypoint(&self) -> &bool {
        &self.start_at_geometrically_closest_waypoint
    }
    fn start_at_geometrically_closest_waypoint_mut(&mut self) -> &mut bool {
        &mut self.start_at_geometrically_closest_waypoint
    }
}

impl super::entity::EntityDataTrait for SetWaypointsEntityData {
}

impl super::entity::GameObjectDataTrait for SetWaypointsEntityData {
}

impl super::core::DataBusPeerTrait for SetWaypointsEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SetWaypointsEntityData {
}

impl super::core::DataContainerTrait for SetWaypointsEntityData {
}

pub static SETWAYPOINTSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetWaypointsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SetWaypointsEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(SetWaypointsEntityData, realm),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SetWaypointsEntityData, speed),
            },
            FieldInfoData {
                name: "Looping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SetWaypointsEntityData, looping),
            },
            FieldInfoData {
                name: "StartAtGeometricallyClosestWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SetWaypointsEntityData, start_at_geometrically_closest_waypoint),
            },
        ],
    }),
    array_type: Some(SETWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SetWaypointsEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SETWAYPOINTSENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SETWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetWaypointsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SetWaypointsEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowWaypointsManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub look_ahead_time: f32,
    pub physics_extrapolation_time: f32,
    pub extrapolate_rotation: bool,
}

pub trait FollowWaypointsManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn look_ahead_time(&self) -> &f32;
    fn look_ahead_time_mut(&mut self) -> &mut f32;
    fn physics_extrapolation_time(&self) -> &f32;
    fn physics_extrapolation_time_mut(&mut self) -> &mut f32;
    fn extrapolate_rotation(&self) -> &bool;
    fn extrapolate_rotation_mut(&mut self) -> &mut bool;
}

impl FollowWaypointsManeuverEntityDataTrait for FollowWaypointsManeuverEntityData {
    fn look_ahead_time(&self) -> &f32 {
        &self.look_ahead_time
    }
    fn look_ahead_time_mut(&mut self) -> &mut f32 {
        &mut self.look_ahead_time
    }
    fn physics_extrapolation_time(&self) -> &f32 {
        &self.physics_extrapolation_time
    }
    fn physics_extrapolation_time_mut(&mut self) -> &mut f32 {
        &mut self.physics_extrapolation_time
    }
    fn extrapolate_rotation(&self) -> &bool {
        &self.extrapolate_rotation
    }
    fn extrapolate_rotation_mut(&mut self) -> &mut bool {
        &mut self.extrapolate_rotation
    }
}

impl DogFightManeuverEntityBaseDataTrait for FollowWaypointsManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for FollowWaypointsManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for FollowWaypointsManeuverEntityData {
}

impl super::core::DataBusPeerTrait for FollowWaypointsManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FollowWaypointsManeuverEntityData {
}

impl super::core::DataContainerTrait for FollowWaypointsManeuverEntityData {
}

pub static FOLLOWWAYPOINTSMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowWaypointsManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowWaypointsManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowWaypointsManeuverEntityData, look_ahead_time),
            },
            FieldInfoData {
                name: "PhysicsExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowWaypointsManeuverEntityData, physics_extrapolation_time),
            },
            FieldInfoData {
                name: "ExtrapolateRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FollowWaypointsManeuverEntityData, extrapolate_rotation),
            },
        ],
    }),
    array_type: Some(FOLLOWWAYPOINTSMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowWaypointsManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWWAYPOINTSMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOLLOWWAYPOINTSMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowWaypointsManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowWaypointsManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FlyToManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub destination: super::core::Vec3,
    pub arrived_distance: f32,
    pub speed: f32,
    pub should_chase_destination: bool,
    pub extrapolation_time: f32,
    pub extrapolation_delta_time: f32,
    pub extrapolate_rotation: bool,
    pub extrapolate_target_position: bool,
    pub chase_distance: f32,
    pub throttle_p_i_d: super::game_shared::PID,
}

pub trait FlyToManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn destination(&self) -> &super::core::Vec3;
    fn destination_mut(&mut self) -> &mut super::core::Vec3;
    fn arrived_distance(&self) -> &f32;
    fn arrived_distance_mut(&mut self) -> &mut f32;
    fn speed(&self) -> &f32;
    fn speed_mut(&mut self) -> &mut f32;
    fn should_chase_destination(&self) -> &bool;
    fn should_chase_destination_mut(&mut self) -> &mut bool;
    fn extrapolation_time(&self) -> &f32;
    fn extrapolation_time_mut(&mut self) -> &mut f32;
    fn extrapolation_delta_time(&self) -> &f32;
    fn extrapolation_delta_time_mut(&mut self) -> &mut f32;
    fn extrapolate_rotation(&self) -> &bool;
    fn extrapolate_rotation_mut(&mut self) -> &mut bool;
    fn extrapolate_target_position(&self) -> &bool;
    fn extrapolate_target_position_mut(&mut self) -> &mut bool;
    fn chase_distance(&self) -> &f32;
    fn chase_distance_mut(&mut self) -> &mut f32;
    fn throttle_p_i_d(&self) -> &super::game_shared::PID;
    fn throttle_p_i_d_mut(&mut self) -> &mut super::game_shared::PID;
}

impl FlyToManeuverEntityDataTrait for FlyToManeuverEntityData {
    fn destination(&self) -> &super::core::Vec3 {
        &self.destination
    }
    fn destination_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.destination
    }
    fn arrived_distance(&self) -> &f32 {
        &self.arrived_distance
    }
    fn arrived_distance_mut(&mut self) -> &mut f32 {
        &mut self.arrived_distance
    }
    fn speed(&self) -> &f32 {
        &self.speed
    }
    fn speed_mut(&mut self) -> &mut f32 {
        &mut self.speed
    }
    fn should_chase_destination(&self) -> &bool {
        &self.should_chase_destination
    }
    fn should_chase_destination_mut(&mut self) -> &mut bool {
        &mut self.should_chase_destination
    }
    fn extrapolation_time(&self) -> &f32 {
        &self.extrapolation_time
    }
    fn extrapolation_time_mut(&mut self) -> &mut f32 {
        &mut self.extrapolation_time
    }
    fn extrapolation_delta_time(&self) -> &f32 {
        &self.extrapolation_delta_time
    }
    fn extrapolation_delta_time_mut(&mut self) -> &mut f32 {
        &mut self.extrapolation_delta_time
    }
    fn extrapolate_rotation(&self) -> &bool {
        &self.extrapolate_rotation
    }
    fn extrapolate_rotation_mut(&mut self) -> &mut bool {
        &mut self.extrapolate_rotation
    }
    fn extrapolate_target_position(&self) -> &bool {
        &self.extrapolate_target_position
    }
    fn extrapolate_target_position_mut(&mut self) -> &mut bool {
        &mut self.extrapolate_target_position
    }
    fn chase_distance(&self) -> &f32 {
        &self.chase_distance
    }
    fn chase_distance_mut(&mut self) -> &mut f32 {
        &mut self.chase_distance
    }
    fn throttle_p_i_d(&self) -> &super::game_shared::PID {
        &self.throttle_p_i_d
    }
    fn throttle_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        &mut self.throttle_p_i_d
    }
}

impl DogFightManeuverEntityBaseDataTrait for FlyToManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for FlyToManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for FlyToManeuverEntityData {
}

impl super::core::DataBusPeerTrait for FlyToManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for FlyToManeuverEntityData {
}

impl super::core::DataContainerTrait for FlyToManeuverEntityData {
}

pub static FLYTOMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlyToManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FlyToManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Destination",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(FlyToManeuverEntityData, destination),
            },
            FieldInfoData {
                name: "ArrivedDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlyToManeuverEntityData, arrived_distance),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlyToManeuverEntityData, speed),
            },
            FieldInfoData {
                name: "ShouldChaseDestination",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FlyToManeuverEntityData, should_chase_destination),
            },
            FieldInfoData {
                name: "ExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlyToManeuverEntityData, extrapolation_time),
            },
            FieldInfoData {
                name: "ExtrapolationDeltaTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlyToManeuverEntityData, extrapolation_delta_time),
            },
            FieldInfoData {
                name: "ExtrapolateRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FlyToManeuverEntityData, extrapolate_rotation),
            },
            FieldInfoData {
                name: "ExtrapolateTargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FlyToManeuverEntityData, extrapolate_target_position),
            },
            FieldInfoData {
                name: "ChaseDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlyToManeuverEntityData, chase_distance),
            },
            FieldInfoData {
                name: "ThrottlePID",
                flags: MemberInfoFlags::new(0),
                field_type: "PID",
                rust_offset: offset_of!(FlyToManeuverEntityData, throttle_p_i_d),
            },
        ],
    }),
    array_type: Some(FLYTOMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FlyToManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        FLYTOMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLYTOMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlyToManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FlyToManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StallTurnManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub max_altitude_to_run: f32,
    pub climb: f32,
    pub substate_duration_scale: f32,
}

pub trait StallTurnManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn max_altitude_to_run(&self) -> &f32;
    fn max_altitude_to_run_mut(&mut self) -> &mut f32;
    fn climb(&self) -> &f32;
    fn climb_mut(&mut self) -> &mut f32;
    fn substate_duration_scale(&self) -> &f32;
    fn substate_duration_scale_mut(&mut self) -> &mut f32;
}

impl StallTurnManeuverEntityDataTrait for StallTurnManeuverEntityData {
    fn max_altitude_to_run(&self) -> &f32 {
        &self.max_altitude_to_run
    }
    fn max_altitude_to_run_mut(&mut self) -> &mut f32 {
        &mut self.max_altitude_to_run
    }
    fn climb(&self) -> &f32 {
        &self.climb
    }
    fn climb_mut(&mut self) -> &mut f32 {
        &mut self.climb
    }
    fn substate_duration_scale(&self) -> &f32 {
        &self.substate_duration_scale
    }
    fn substate_duration_scale_mut(&mut self) -> &mut f32 {
        &mut self.substate_duration_scale
    }
}

impl DogFightManeuverEntityBaseDataTrait for StallTurnManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for StallTurnManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for StallTurnManeuverEntityData {
}

impl super::core::DataBusPeerTrait for StallTurnManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StallTurnManeuverEntityData {
}

impl super::core::DataContainerTrait for StallTurnManeuverEntityData {
}

pub static STALLTURNMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StallTurnManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StallTurnManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StallTurnManeuverEntityData, max_altitude_to_run),
            },
            FieldInfoData {
                name: "Climb",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StallTurnManeuverEntityData, climb),
            },
            FieldInfoData {
                name: "SubstateDurationScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StallTurnManeuverEntityData, substate_duration_scale),
            },
        ],
    }),
    array_type: Some(STALLTURNMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StallTurnManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STALLTURNMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STALLTURNMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StallTurnManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StallTurnManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpinDescentManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub min_altitude_to_run: f32,
    pub break_out_altitude: f32,
    pub break_out_on_collision_avoidance: bool,
    pub max_duration: f32,
    pub local_fly_to_pos: super::core::Vec3,
}

pub trait SpinDescentManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn min_altitude_to_run(&self) -> &f32;
    fn min_altitude_to_run_mut(&mut self) -> &mut f32;
    fn break_out_altitude(&self) -> &f32;
    fn break_out_altitude_mut(&mut self) -> &mut f32;
    fn break_out_on_collision_avoidance(&self) -> &bool;
    fn break_out_on_collision_avoidance_mut(&mut self) -> &mut bool;
    fn max_duration(&self) -> &f32;
    fn max_duration_mut(&mut self) -> &mut f32;
    fn local_fly_to_pos(&self) -> &super::core::Vec3;
    fn local_fly_to_pos_mut(&mut self) -> &mut super::core::Vec3;
}

impl SpinDescentManeuverEntityDataTrait for SpinDescentManeuverEntityData {
    fn min_altitude_to_run(&self) -> &f32 {
        &self.min_altitude_to_run
    }
    fn min_altitude_to_run_mut(&mut self) -> &mut f32 {
        &mut self.min_altitude_to_run
    }
    fn break_out_altitude(&self) -> &f32 {
        &self.break_out_altitude
    }
    fn break_out_altitude_mut(&mut self) -> &mut f32 {
        &mut self.break_out_altitude
    }
    fn break_out_on_collision_avoidance(&self) -> &bool {
        &self.break_out_on_collision_avoidance
    }
    fn break_out_on_collision_avoidance_mut(&mut self) -> &mut bool {
        &mut self.break_out_on_collision_avoidance
    }
    fn max_duration(&self) -> &f32 {
        &self.max_duration
    }
    fn max_duration_mut(&mut self) -> &mut f32 {
        &mut self.max_duration
    }
    fn local_fly_to_pos(&self) -> &super::core::Vec3 {
        &self.local_fly_to_pos
    }
    fn local_fly_to_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.local_fly_to_pos
    }
}

impl DogFightManeuverEntityBaseDataTrait for SpinDescentManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for SpinDescentManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for SpinDescentManeuverEntityData {
}

impl super::core::DataBusPeerTrait for SpinDescentManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SpinDescentManeuverEntityData {
}

impl super::core::DataContainerTrait for SpinDescentManeuverEntityData {
}

pub static SPINDESCENTMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpinDescentManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpinDescentManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpinDescentManeuverEntityData, min_altitude_to_run),
            },
            FieldInfoData {
                name: "BreakOutAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpinDescentManeuverEntityData, break_out_altitude),
            },
            FieldInfoData {
                name: "BreakOutOnCollisionAvoidance",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpinDescentManeuverEntityData, break_out_on_collision_avoidance),
            },
            FieldInfoData {
                name: "MaxDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SpinDescentManeuverEntityData, max_duration),
            },
            FieldInfoData {
                name: "LocalFlyToPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SpinDescentManeuverEntityData, local_fly_to_pos),
            },
        ],
    }),
    array_type: Some(SPINDESCENTMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpinDescentManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPINDESCENTMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPINDESCENTMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpinDescentManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SpinDescentManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SideToSideManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub duration: f32,
    pub oscillation_frequency: f32,
}

pub trait SideToSideManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn duration(&self) -> &f32;
    fn duration_mut(&mut self) -> &mut f32;
    fn oscillation_frequency(&self) -> &f32;
    fn oscillation_frequency_mut(&mut self) -> &mut f32;
}

impl SideToSideManeuverEntityDataTrait for SideToSideManeuverEntityData {
    fn duration(&self) -> &f32 {
        &self.duration
    }
    fn duration_mut(&mut self) -> &mut f32 {
        &mut self.duration
    }
    fn oscillation_frequency(&self) -> &f32 {
        &self.oscillation_frequency
    }
    fn oscillation_frequency_mut(&mut self) -> &mut f32 {
        &mut self.oscillation_frequency
    }
}

impl DogFightManeuverEntityBaseDataTrait for SideToSideManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for SideToSideManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for SideToSideManeuverEntityData {
}

impl super::core::DataBusPeerTrait for SideToSideManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SideToSideManeuverEntityData {
}

impl super::core::DataContainerTrait for SideToSideManeuverEntityData {
}

pub static SIDETOSIDEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SideToSideManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SideToSideManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Duration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SideToSideManeuverEntityData, duration),
            },
            FieldInfoData {
                name: "OscillationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SideToSideManeuverEntityData, oscillation_frequency),
            },
        ],
    }),
    array_type: Some(SIDETOSIDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SideToSideManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SIDETOSIDEMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIDETOSIDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SideToSideManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SideToSideManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ImmelmannManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub max_altitude_to_run: f32,
    pub substate_duration_scale: f32,
}

pub trait ImmelmannManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn max_altitude_to_run(&self) -> &f32;
    fn max_altitude_to_run_mut(&mut self) -> &mut f32;
    fn substate_duration_scale(&self) -> &f32;
    fn substate_duration_scale_mut(&mut self) -> &mut f32;
}

impl ImmelmannManeuverEntityDataTrait for ImmelmannManeuverEntityData {
    fn max_altitude_to_run(&self) -> &f32 {
        &self.max_altitude_to_run
    }
    fn max_altitude_to_run_mut(&mut self) -> &mut f32 {
        &mut self.max_altitude_to_run
    }
    fn substate_duration_scale(&self) -> &f32 {
        &self.substate_duration_scale
    }
    fn substate_duration_scale_mut(&mut self) -> &mut f32 {
        &mut self.substate_duration_scale
    }
}

impl DogFightManeuverEntityBaseDataTrait for ImmelmannManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for ImmelmannManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for ImmelmannManeuverEntityData {
}

impl super::core::DataBusPeerTrait for ImmelmannManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ImmelmannManeuverEntityData {
}

impl super::core::DataContainerTrait for ImmelmannManeuverEntityData {
}

pub static IMMELMANNMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImmelmannManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ImmelmannManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ImmelmannManeuverEntityData, max_altitude_to_run),
            },
            FieldInfoData {
                name: "SubstateDurationScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ImmelmannManeuverEntityData, substate_duration_scale),
            },
        ],
    }),
    array_type: Some(IMMELMANNMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ImmelmannManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        IMMELMANNMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IMMELMANNMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImmelmannManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ImmelmannManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BarrelRollManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub duration: f32,
    pub radius: f32,
    pub distance: f32,
    pub rotation_velocity: f32,
    pub min_altitude_to_run: f32,
    pub max_altitude_to_run: f32,
}

pub trait BarrelRollManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn duration(&self) -> &f32;
    fn duration_mut(&mut self) -> &mut f32;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn distance(&self) -> &f32;
    fn distance_mut(&mut self) -> &mut f32;
    fn rotation_velocity(&self) -> &f32;
    fn rotation_velocity_mut(&mut self) -> &mut f32;
    fn min_altitude_to_run(&self) -> &f32;
    fn min_altitude_to_run_mut(&mut self) -> &mut f32;
    fn max_altitude_to_run(&self) -> &f32;
    fn max_altitude_to_run_mut(&mut self) -> &mut f32;
}

impl BarrelRollManeuverEntityDataTrait for BarrelRollManeuverEntityData {
    fn duration(&self) -> &f32 {
        &self.duration
    }
    fn duration_mut(&mut self) -> &mut f32 {
        &mut self.duration
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn distance(&self) -> &f32 {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut f32 {
        &mut self.distance
    }
    fn rotation_velocity(&self) -> &f32 {
        &self.rotation_velocity
    }
    fn rotation_velocity_mut(&mut self) -> &mut f32 {
        &mut self.rotation_velocity
    }
    fn min_altitude_to_run(&self) -> &f32 {
        &self.min_altitude_to_run
    }
    fn min_altitude_to_run_mut(&mut self) -> &mut f32 {
        &mut self.min_altitude_to_run
    }
    fn max_altitude_to_run(&self) -> &f32 {
        &self.max_altitude_to_run
    }
    fn max_altitude_to_run_mut(&mut self) -> &mut f32 {
        &mut self.max_altitude_to_run
    }
}

impl DogFightManeuverEntityBaseDataTrait for BarrelRollManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for BarrelRollManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for BarrelRollManeuverEntityData {
}

impl super::core::DataBusPeerTrait for BarrelRollManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BarrelRollManeuverEntityData {
}

impl super::core::DataContainerTrait for BarrelRollManeuverEntityData {
}

pub static BARRELROLLMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BarrelRollManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BarrelRollManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Duration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrelRollManeuverEntityData, duration),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrelRollManeuverEntityData, radius),
            },
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrelRollManeuverEntityData, distance),
            },
            FieldInfoData {
                name: "RotationVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrelRollManeuverEntityData, rotation_velocity),
            },
            FieldInfoData {
                name: "MinAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrelRollManeuverEntityData, min_altitude_to_run),
            },
            FieldInfoData {
                name: "MaxAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BarrelRollManeuverEntityData, max_altitude_to_run),
            },
        ],
    }),
    array_type: Some(BARRELROLLMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BarrelRollManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BARRELROLLMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BARRELROLLMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BarrelRollManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BarrelRollManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SplitSManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub climb: f32,
    pub max_altitude_to_run: f32,
    pub min_altitude_to_run: f32,
    pub substate_duration_scale: f32,
}

pub trait SplitSManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn climb(&self) -> &f32;
    fn climb_mut(&mut self) -> &mut f32;
    fn max_altitude_to_run(&self) -> &f32;
    fn max_altitude_to_run_mut(&mut self) -> &mut f32;
    fn min_altitude_to_run(&self) -> &f32;
    fn min_altitude_to_run_mut(&mut self) -> &mut f32;
    fn substate_duration_scale(&self) -> &f32;
    fn substate_duration_scale_mut(&mut self) -> &mut f32;
}

impl SplitSManeuverEntityDataTrait for SplitSManeuverEntityData {
    fn climb(&self) -> &f32 {
        &self.climb
    }
    fn climb_mut(&mut self) -> &mut f32 {
        &mut self.climb
    }
    fn max_altitude_to_run(&self) -> &f32 {
        &self.max_altitude_to_run
    }
    fn max_altitude_to_run_mut(&mut self) -> &mut f32 {
        &mut self.max_altitude_to_run
    }
    fn min_altitude_to_run(&self) -> &f32 {
        &self.min_altitude_to_run
    }
    fn min_altitude_to_run_mut(&mut self) -> &mut f32 {
        &mut self.min_altitude_to_run
    }
    fn substate_duration_scale(&self) -> &f32 {
        &self.substate_duration_scale
    }
    fn substate_duration_scale_mut(&mut self) -> &mut f32 {
        &mut self.substate_duration_scale
    }
}

impl DogFightManeuverEntityBaseDataTrait for SplitSManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for SplitSManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for SplitSManeuverEntityData {
}

impl super::core::DataBusPeerTrait for SplitSManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SplitSManeuverEntityData {
}

impl super::core::DataContainerTrait for SplitSManeuverEntityData {
}

pub static SPLITSMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SplitSManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SplitSManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Climb",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SplitSManeuverEntityData, climb),
            },
            FieldInfoData {
                name: "MaxAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SplitSManeuverEntityData, max_altitude_to_run),
            },
            FieldInfoData {
                name: "MinAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SplitSManeuverEntityData, min_altitude_to_run),
            },
            FieldInfoData {
                name: "SubstateDurationScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SplitSManeuverEntityData, substate_duration_scale),
            },
        ],
    }),
    array_type: Some(SPLITSMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SplitSManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SPLITSMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPLITSMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SplitSManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SplitSManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BasicDefensiveManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub target_max_distance: f32,
    pub target_max_distance_slack: f32,
    pub fly_straight_time: f32,
    pub oscillate_time: f32,
    pub oscillation_frequency: f32,
    pub sharp_turn_time: f32,
    pub dive_time: f32,
    pub looping_time: f32,
}

pub trait BasicDefensiveManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn target_max_distance(&self) -> &f32;
    fn target_max_distance_mut(&mut self) -> &mut f32;
    fn target_max_distance_slack(&self) -> &f32;
    fn target_max_distance_slack_mut(&mut self) -> &mut f32;
    fn fly_straight_time(&self) -> &f32;
    fn fly_straight_time_mut(&mut self) -> &mut f32;
    fn oscillate_time(&self) -> &f32;
    fn oscillate_time_mut(&mut self) -> &mut f32;
    fn oscillation_frequency(&self) -> &f32;
    fn oscillation_frequency_mut(&mut self) -> &mut f32;
    fn sharp_turn_time(&self) -> &f32;
    fn sharp_turn_time_mut(&mut self) -> &mut f32;
    fn dive_time(&self) -> &f32;
    fn dive_time_mut(&mut self) -> &mut f32;
    fn looping_time(&self) -> &f32;
    fn looping_time_mut(&mut self) -> &mut f32;
}

impl BasicDefensiveManeuverEntityDataTrait for BasicDefensiveManeuverEntityData {
    fn target_max_distance(&self) -> &f32 {
        &self.target_max_distance
    }
    fn target_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.target_max_distance
    }
    fn target_max_distance_slack(&self) -> &f32 {
        &self.target_max_distance_slack
    }
    fn target_max_distance_slack_mut(&mut self) -> &mut f32 {
        &mut self.target_max_distance_slack
    }
    fn fly_straight_time(&self) -> &f32 {
        &self.fly_straight_time
    }
    fn fly_straight_time_mut(&mut self) -> &mut f32 {
        &mut self.fly_straight_time
    }
    fn oscillate_time(&self) -> &f32 {
        &self.oscillate_time
    }
    fn oscillate_time_mut(&mut self) -> &mut f32 {
        &mut self.oscillate_time
    }
    fn oscillation_frequency(&self) -> &f32 {
        &self.oscillation_frequency
    }
    fn oscillation_frequency_mut(&mut self) -> &mut f32 {
        &mut self.oscillation_frequency
    }
    fn sharp_turn_time(&self) -> &f32 {
        &self.sharp_turn_time
    }
    fn sharp_turn_time_mut(&mut self) -> &mut f32 {
        &mut self.sharp_turn_time
    }
    fn dive_time(&self) -> &f32 {
        &self.dive_time
    }
    fn dive_time_mut(&mut self) -> &mut f32 {
        &mut self.dive_time
    }
    fn looping_time(&self) -> &f32 {
        &self.looping_time
    }
    fn looping_time_mut(&mut self) -> &mut f32 {
        &mut self.looping_time
    }
}

impl DogFightManeuverEntityBaseDataTrait for BasicDefensiveManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for BasicDefensiveManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for BasicDefensiveManeuverEntityData {
}

impl super::core::DataBusPeerTrait for BasicDefensiveManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BasicDefensiveManeuverEntityData {
}

impl super::core::DataContainerTrait for BasicDefensiveManeuverEntityData {
}

pub static BASICDEFENSIVEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicDefensiveManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BasicDefensiveManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, target_max_distance),
            },
            FieldInfoData {
                name: "TargetMaxDistanceSlack",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, target_max_distance_slack),
            },
            FieldInfoData {
                name: "FlyStraightTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, fly_straight_time),
            },
            FieldInfoData {
                name: "OscillateTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, oscillate_time),
            },
            FieldInfoData {
                name: "OscillationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, oscillation_frequency),
            },
            FieldInfoData {
                name: "SharpTurnTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, sharp_turn_time),
            },
            FieldInfoData {
                name: "DiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, dive_time),
            },
            FieldInfoData {
                name: "LoopingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, looping_time),
            },
        ],
    }),
    array_type: Some(BASICDEFENSIVEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicDefensiveManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BASICDEFENSIVEMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BASICDEFENSIVEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicDefensiveManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BasicDefensiveManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StrafeRunManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub altitude_difference_to_attack: f32,
    pub dive_angle: f32,
    pub attack_speed: f32,
    pub break_off_angle: f32,
    pub break_off_at_time_to_collision: f32,
    pub break_off_height_difference: f32,
    pub bullet_speed: f32,
    pub extrapolate_target_rotation: bool,
    pub extrapolation_delta_time: f32,
}

pub trait StrafeRunManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn altitude_difference_to_attack(&self) -> &f32;
    fn altitude_difference_to_attack_mut(&mut self) -> &mut f32;
    fn dive_angle(&self) -> &f32;
    fn dive_angle_mut(&mut self) -> &mut f32;
    fn attack_speed(&self) -> &f32;
    fn attack_speed_mut(&mut self) -> &mut f32;
    fn break_off_angle(&self) -> &f32;
    fn break_off_angle_mut(&mut self) -> &mut f32;
    fn break_off_at_time_to_collision(&self) -> &f32;
    fn break_off_at_time_to_collision_mut(&mut self) -> &mut f32;
    fn break_off_height_difference(&self) -> &f32;
    fn break_off_height_difference_mut(&mut self) -> &mut f32;
    fn bullet_speed(&self) -> &f32;
    fn bullet_speed_mut(&mut self) -> &mut f32;
    fn extrapolate_target_rotation(&self) -> &bool;
    fn extrapolate_target_rotation_mut(&mut self) -> &mut bool;
    fn extrapolation_delta_time(&self) -> &f32;
    fn extrapolation_delta_time_mut(&mut self) -> &mut f32;
}

impl StrafeRunManeuverEntityDataTrait for StrafeRunManeuverEntityData {
    fn altitude_difference_to_attack(&self) -> &f32 {
        &self.altitude_difference_to_attack
    }
    fn altitude_difference_to_attack_mut(&mut self) -> &mut f32 {
        &mut self.altitude_difference_to_attack
    }
    fn dive_angle(&self) -> &f32 {
        &self.dive_angle
    }
    fn dive_angle_mut(&mut self) -> &mut f32 {
        &mut self.dive_angle
    }
    fn attack_speed(&self) -> &f32 {
        &self.attack_speed
    }
    fn attack_speed_mut(&mut self) -> &mut f32 {
        &mut self.attack_speed
    }
    fn break_off_angle(&self) -> &f32 {
        &self.break_off_angle
    }
    fn break_off_angle_mut(&mut self) -> &mut f32 {
        &mut self.break_off_angle
    }
    fn break_off_at_time_to_collision(&self) -> &f32 {
        &self.break_off_at_time_to_collision
    }
    fn break_off_at_time_to_collision_mut(&mut self) -> &mut f32 {
        &mut self.break_off_at_time_to_collision
    }
    fn break_off_height_difference(&self) -> &f32 {
        &self.break_off_height_difference
    }
    fn break_off_height_difference_mut(&mut self) -> &mut f32 {
        &mut self.break_off_height_difference
    }
    fn bullet_speed(&self) -> &f32 {
        &self.bullet_speed
    }
    fn bullet_speed_mut(&mut self) -> &mut f32 {
        &mut self.bullet_speed
    }
    fn extrapolate_target_rotation(&self) -> &bool {
        &self.extrapolate_target_rotation
    }
    fn extrapolate_target_rotation_mut(&mut self) -> &mut bool {
        &mut self.extrapolate_target_rotation
    }
    fn extrapolation_delta_time(&self) -> &f32 {
        &self.extrapolation_delta_time
    }
    fn extrapolation_delta_time_mut(&mut self) -> &mut f32 {
        &mut self.extrapolation_delta_time
    }
}

impl DogFightManeuverEntityBaseDataTrait for StrafeRunManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for StrafeRunManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for StrafeRunManeuverEntityData {
}

impl super::core::DataBusPeerTrait for StrafeRunManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for StrafeRunManeuverEntityData {
}

impl super::core::DataContainerTrait for StrafeRunManeuverEntityData {
}

pub static STRAFERUNMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StrafeRunManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StrafeRunManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AltitudeDifferenceToAttack",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StrafeRunManeuverEntityData, altitude_difference_to_attack),
            },
            FieldInfoData {
                name: "DiveAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StrafeRunManeuverEntityData, dive_angle),
            },
            FieldInfoData {
                name: "AttackSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StrafeRunManeuverEntityData, attack_speed),
            },
            FieldInfoData {
                name: "BreakOffAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StrafeRunManeuverEntityData, break_off_angle),
            },
            FieldInfoData {
                name: "BreakOffAtTimeToCollision",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StrafeRunManeuverEntityData, break_off_at_time_to_collision),
            },
            FieldInfoData {
                name: "BreakOffHeightDifference",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StrafeRunManeuverEntityData, break_off_height_difference),
            },
            FieldInfoData {
                name: "BulletSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StrafeRunManeuverEntityData, bullet_speed),
            },
            FieldInfoData {
                name: "ExtrapolateTargetRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(StrafeRunManeuverEntityData, extrapolate_target_rotation),
            },
            FieldInfoData {
                name: "ExtrapolationDeltaTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(StrafeRunManeuverEntityData, extrapolation_delta_time),
            },
        ],
    }),
    array_type: Some(STRAFERUNMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StrafeRunManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        STRAFERUNMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STRAFERUNMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StrafeRunManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StrafeRunManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BasicAttackManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub distance_for_max_extrapolation_time: f32,
    pub distance_for_no_extrapolation_time: f32,
    pub max_extrapolation_time: f32,
    pub physics_extrapolation_time: f32,
    pub extrapolation_delta_time: f32,
    pub extrapolate_rotation: bool,
    pub max_roll_angle_against_slow_targets: f32,
    pub wanted_distance: f32,
    pub wanted_distance_offset_between_multiple_attackers: f32,
    pub throttle_p_i_d: super::game_shared::PID,
}

pub trait BasicAttackManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn distance_for_max_extrapolation_time(&self) -> &f32;
    fn distance_for_max_extrapolation_time_mut(&mut self) -> &mut f32;
    fn distance_for_no_extrapolation_time(&self) -> &f32;
    fn distance_for_no_extrapolation_time_mut(&mut self) -> &mut f32;
    fn max_extrapolation_time(&self) -> &f32;
    fn max_extrapolation_time_mut(&mut self) -> &mut f32;
    fn physics_extrapolation_time(&self) -> &f32;
    fn physics_extrapolation_time_mut(&mut self) -> &mut f32;
    fn extrapolation_delta_time(&self) -> &f32;
    fn extrapolation_delta_time_mut(&mut self) -> &mut f32;
    fn extrapolate_rotation(&self) -> &bool;
    fn extrapolate_rotation_mut(&mut self) -> &mut bool;
    fn max_roll_angle_against_slow_targets(&self) -> &f32;
    fn max_roll_angle_against_slow_targets_mut(&mut self) -> &mut f32;
    fn wanted_distance(&self) -> &f32;
    fn wanted_distance_mut(&mut self) -> &mut f32;
    fn wanted_distance_offset_between_multiple_attackers(&self) -> &f32;
    fn wanted_distance_offset_between_multiple_attackers_mut(&mut self) -> &mut f32;
    fn throttle_p_i_d(&self) -> &super::game_shared::PID;
    fn throttle_p_i_d_mut(&mut self) -> &mut super::game_shared::PID;
}

impl BasicAttackManeuverEntityDataTrait for BasicAttackManeuverEntityData {
    fn distance_for_max_extrapolation_time(&self) -> &f32 {
        &self.distance_for_max_extrapolation_time
    }
    fn distance_for_max_extrapolation_time_mut(&mut self) -> &mut f32 {
        &mut self.distance_for_max_extrapolation_time
    }
    fn distance_for_no_extrapolation_time(&self) -> &f32 {
        &self.distance_for_no_extrapolation_time
    }
    fn distance_for_no_extrapolation_time_mut(&mut self) -> &mut f32 {
        &mut self.distance_for_no_extrapolation_time
    }
    fn max_extrapolation_time(&self) -> &f32 {
        &self.max_extrapolation_time
    }
    fn max_extrapolation_time_mut(&mut self) -> &mut f32 {
        &mut self.max_extrapolation_time
    }
    fn physics_extrapolation_time(&self) -> &f32 {
        &self.physics_extrapolation_time
    }
    fn physics_extrapolation_time_mut(&mut self) -> &mut f32 {
        &mut self.physics_extrapolation_time
    }
    fn extrapolation_delta_time(&self) -> &f32 {
        &self.extrapolation_delta_time
    }
    fn extrapolation_delta_time_mut(&mut self) -> &mut f32 {
        &mut self.extrapolation_delta_time
    }
    fn extrapolate_rotation(&self) -> &bool {
        &self.extrapolate_rotation
    }
    fn extrapolate_rotation_mut(&mut self) -> &mut bool {
        &mut self.extrapolate_rotation
    }
    fn max_roll_angle_against_slow_targets(&self) -> &f32 {
        &self.max_roll_angle_against_slow_targets
    }
    fn max_roll_angle_against_slow_targets_mut(&mut self) -> &mut f32 {
        &mut self.max_roll_angle_against_slow_targets
    }
    fn wanted_distance(&self) -> &f32 {
        &self.wanted_distance
    }
    fn wanted_distance_mut(&mut self) -> &mut f32 {
        &mut self.wanted_distance
    }
    fn wanted_distance_offset_between_multiple_attackers(&self) -> &f32 {
        &self.wanted_distance_offset_between_multiple_attackers
    }
    fn wanted_distance_offset_between_multiple_attackers_mut(&mut self) -> &mut f32 {
        &mut self.wanted_distance_offset_between_multiple_attackers
    }
    fn throttle_p_i_d(&self) -> &super::game_shared::PID {
        &self.throttle_p_i_d
    }
    fn throttle_p_i_d_mut(&mut self) -> &mut super::game_shared::PID {
        &mut self.throttle_p_i_d
    }
}

impl DogFightManeuverEntityBaseDataTrait for BasicAttackManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for BasicAttackManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for BasicAttackManeuverEntityData {
}

impl super::core::DataBusPeerTrait for BasicAttackManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BasicAttackManeuverEntityData {
}

impl super::core::DataContainerTrait for BasicAttackManeuverEntityData {
}

pub static BASICATTACKMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicAttackManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BasicAttackManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DistanceForMaxExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, distance_for_max_extrapolation_time),
            },
            FieldInfoData {
                name: "DistanceForNoExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, distance_for_no_extrapolation_time),
            },
            FieldInfoData {
                name: "MaxExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, max_extrapolation_time),
            },
            FieldInfoData {
                name: "PhysicsExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, physics_extrapolation_time),
            },
            FieldInfoData {
                name: "ExtrapolationDeltaTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, extrapolation_delta_time),
            },
            FieldInfoData {
                name: "ExtrapolateRotation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, extrapolate_rotation),
            },
            FieldInfoData {
                name: "MaxRollAngleAgainstSlowTargets",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, max_roll_angle_against_slow_targets),
            },
            FieldInfoData {
                name: "WantedDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, wanted_distance),
            },
            FieldInfoData {
                name: "WantedDistanceOffsetBetweenMultipleAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, wanted_distance_offset_between_multiple_attackers),
            },
            FieldInfoData {
                name: "ThrottlePID",
                flags: MemberInfoFlags::new(0),
                field_type: "PID",
                rust_offset: offset_of!(BasicAttackManeuverEntityData, throttle_p_i_d),
            },
        ],
    }),
    array_type: Some(BASICATTACKMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicAttackManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BASICATTACKMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BASICATTACKMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicAttackManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BasicAttackManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CollisionAvoidanceManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub min_altitude: f32,
    pub look_ahead_time: f32,
    pub near_collision_time: f32,
    pub near_collision_throttle: f32,
    pub ignore_target: bool,
    pub ignore_all_collisions_except_humans: bool,
    pub ignore_humans: bool,
    pub use_velocity_dir_for_raycast: bool,
    pub keep_heading_time_after_hit: f32,
}

pub trait CollisionAvoidanceManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn min_altitude(&self) -> &f32;
    fn min_altitude_mut(&mut self) -> &mut f32;
    fn look_ahead_time(&self) -> &f32;
    fn look_ahead_time_mut(&mut self) -> &mut f32;
    fn near_collision_time(&self) -> &f32;
    fn near_collision_time_mut(&mut self) -> &mut f32;
    fn near_collision_throttle(&self) -> &f32;
    fn near_collision_throttle_mut(&mut self) -> &mut f32;
    fn ignore_target(&self) -> &bool;
    fn ignore_target_mut(&mut self) -> &mut bool;
    fn ignore_all_collisions_except_humans(&self) -> &bool;
    fn ignore_all_collisions_except_humans_mut(&mut self) -> &mut bool;
    fn ignore_humans(&self) -> &bool;
    fn ignore_humans_mut(&mut self) -> &mut bool;
    fn use_velocity_dir_for_raycast(&self) -> &bool;
    fn use_velocity_dir_for_raycast_mut(&mut self) -> &mut bool;
    fn keep_heading_time_after_hit(&self) -> &f32;
    fn keep_heading_time_after_hit_mut(&mut self) -> &mut f32;
}

impl CollisionAvoidanceManeuverEntityDataTrait for CollisionAvoidanceManeuverEntityData {
    fn min_altitude(&self) -> &f32 {
        &self.min_altitude
    }
    fn min_altitude_mut(&mut self) -> &mut f32 {
        &mut self.min_altitude
    }
    fn look_ahead_time(&self) -> &f32 {
        &self.look_ahead_time
    }
    fn look_ahead_time_mut(&mut self) -> &mut f32 {
        &mut self.look_ahead_time
    }
    fn near_collision_time(&self) -> &f32 {
        &self.near_collision_time
    }
    fn near_collision_time_mut(&mut self) -> &mut f32 {
        &mut self.near_collision_time
    }
    fn near_collision_throttle(&self) -> &f32 {
        &self.near_collision_throttle
    }
    fn near_collision_throttle_mut(&mut self) -> &mut f32 {
        &mut self.near_collision_throttle
    }
    fn ignore_target(&self) -> &bool {
        &self.ignore_target
    }
    fn ignore_target_mut(&mut self) -> &mut bool {
        &mut self.ignore_target
    }
    fn ignore_all_collisions_except_humans(&self) -> &bool {
        &self.ignore_all_collisions_except_humans
    }
    fn ignore_all_collisions_except_humans_mut(&mut self) -> &mut bool {
        &mut self.ignore_all_collisions_except_humans
    }
    fn ignore_humans(&self) -> &bool {
        &self.ignore_humans
    }
    fn ignore_humans_mut(&mut self) -> &mut bool {
        &mut self.ignore_humans
    }
    fn use_velocity_dir_for_raycast(&self) -> &bool {
        &self.use_velocity_dir_for_raycast
    }
    fn use_velocity_dir_for_raycast_mut(&mut self) -> &mut bool {
        &mut self.use_velocity_dir_for_raycast
    }
    fn keep_heading_time_after_hit(&self) -> &f32 {
        &self.keep_heading_time_after_hit
    }
    fn keep_heading_time_after_hit_mut(&mut self) -> &mut f32 {
        &mut self.keep_heading_time_after_hit
    }
}

impl DogFightManeuverEntityBaseDataTrait for CollisionAvoidanceManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for CollisionAvoidanceManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for CollisionAvoidanceManeuverEntityData {
}

impl super::core::DataBusPeerTrait for CollisionAvoidanceManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CollisionAvoidanceManeuverEntityData {
}

impl super::core::DataContainerTrait for CollisionAvoidanceManeuverEntityData {
}

pub static COLLISIONAVOIDANCEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionAvoidanceManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CollisionAvoidanceManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, min_altitude),
            },
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, look_ahead_time),
            },
            FieldInfoData {
                name: "NearCollisionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, near_collision_time),
            },
            FieldInfoData {
                name: "NearCollisionThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, near_collision_throttle),
            },
            FieldInfoData {
                name: "IgnoreTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, ignore_target),
            },
            FieldInfoData {
                name: "IgnoreAllCollisionsExceptHumans",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, ignore_all_collisions_except_humans),
            },
            FieldInfoData {
                name: "IgnoreHumans",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, ignore_humans),
            },
            FieldInfoData {
                name: "UseVelocityDirForRaycast",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, use_velocity_dir_for_raycast),
            },
            FieldInfoData {
                name: "KeepHeadingTimeAfterHit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, keep_heading_time_after_hit),
            },
        ],
    }),
    array_type: Some(COLLISIONAVOIDANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CollisionAvoidanceManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COLLISIONAVOIDANCEMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COLLISIONAVOIDANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionAvoidanceManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CollisionAvoidanceManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnforceAltitudeManeuverEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub min_altitude: f32,
    pub max_altitude: f32,
    pub look_ahead_time: f32,
    pub safety_distance: f32,
}

pub trait EnforceAltitudeManeuverEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn min_altitude(&self) -> &f32;
    fn min_altitude_mut(&mut self) -> &mut f32;
    fn max_altitude(&self) -> &f32;
    fn max_altitude_mut(&mut self) -> &mut f32;
    fn look_ahead_time(&self) -> &f32;
    fn look_ahead_time_mut(&mut self) -> &mut f32;
    fn safety_distance(&self) -> &f32;
    fn safety_distance_mut(&mut self) -> &mut f32;
}

impl EnforceAltitudeManeuverEntityDataTrait for EnforceAltitudeManeuverEntityData {
    fn min_altitude(&self) -> &f32 {
        &self.min_altitude
    }
    fn min_altitude_mut(&mut self) -> &mut f32 {
        &mut self.min_altitude
    }
    fn max_altitude(&self) -> &f32 {
        &self.max_altitude
    }
    fn max_altitude_mut(&mut self) -> &mut f32 {
        &mut self.max_altitude
    }
    fn look_ahead_time(&self) -> &f32 {
        &self.look_ahead_time
    }
    fn look_ahead_time_mut(&mut self) -> &mut f32 {
        &mut self.look_ahead_time
    }
    fn safety_distance(&self) -> &f32 {
        &self.safety_distance
    }
    fn safety_distance_mut(&mut self) -> &mut f32 {
        &mut self.safety_distance
    }
}

impl DogFightManeuverEntityBaseDataTrait for EnforceAltitudeManeuverEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for EnforceAltitudeManeuverEntityData {
}

impl super::entity::GameObjectDataTrait for EnforceAltitudeManeuverEntityData {
}

impl super::core::DataBusPeerTrait for EnforceAltitudeManeuverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for EnforceAltitudeManeuverEntityData {
}

impl super::core::DataContainerTrait for EnforceAltitudeManeuverEntityData {
}

pub static ENFORCEALTITUDEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnforceAltitudeManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnforceAltitudeManeuverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnforceAltitudeManeuverEntityData, min_altitude),
            },
            FieldInfoData {
                name: "MaxAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnforceAltitudeManeuverEntityData, max_altitude),
            },
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnforceAltitudeManeuverEntityData, look_ahead_time),
            },
            FieldInfoData {
                name: "SafetyDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EnforceAltitudeManeuverEntityData, safety_distance),
            },
        ],
    }),
    array_type: Some(ENFORCEALTITUDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnforceAltitudeManeuverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        ENFORCEALTITUDEMANEUVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENFORCEALTITUDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnforceAltitudeManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EnforceAltitudeManeuverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DefensiveManeuverSelectorEntityData {
    pub _glacier_base: ManeuverSelectorEntityData,
    pub minimum_target_velocity: f32,
    pub target_max_distance: f32,
    pub target_max_distance_slack: f32,
}

pub trait DefensiveManeuverSelectorEntityDataTrait: ManeuverSelectorEntityDataTrait {
    fn minimum_target_velocity(&self) -> &f32;
    fn minimum_target_velocity_mut(&mut self) -> &mut f32;
    fn target_max_distance(&self) -> &f32;
    fn target_max_distance_mut(&mut self) -> &mut f32;
    fn target_max_distance_slack(&self) -> &f32;
    fn target_max_distance_slack_mut(&mut self) -> &mut f32;
}

impl DefensiveManeuverSelectorEntityDataTrait for DefensiveManeuverSelectorEntityData {
    fn minimum_target_velocity(&self) -> &f32 {
        &self.minimum_target_velocity
    }
    fn minimum_target_velocity_mut(&mut self) -> &mut f32 {
        &mut self.minimum_target_velocity
    }
    fn target_max_distance(&self) -> &f32 {
        &self.target_max_distance
    }
    fn target_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.target_max_distance
    }
    fn target_max_distance_slack(&self) -> &f32 {
        &self.target_max_distance_slack
    }
    fn target_max_distance_slack_mut(&mut self) -> &mut f32 {
        &mut self.target_max_distance_slack
    }
}

impl ManeuverSelectorEntityDataTrait for DefensiveManeuverSelectorEntityData {
    fn selector_type(&self) -> &SelectorType {
        self._glacier_base.selector_type()
    }
    fn selector_type_mut(&mut self) -> &mut SelectorType {
        self._glacier_base.selector_type_mut()
    }
}

impl DogFightManeuverEntityBaseDataTrait for DefensiveManeuverSelectorEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for DefensiveManeuverSelectorEntityData {
}

impl super::entity::GameObjectDataTrait for DefensiveManeuverSelectorEntityData {
}

impl super::core::DataBusPeerTrait for DefensiveManeuverSelectorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DefensiveManeuverSelectorEntityData {
}

impl super::core::DataContainerTrait for DefensiveManeuverSelectorEntityData {
}

pub static DEFENSIVEMANEUVERSELECTORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefensiveManeuverSelectorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MANEUVERSELECTORENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DefensiveManeuverSelectorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinimumTargetVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefensiveManeuverSelectorEntityData, minimum_target_velocity),
            },
            FieldInfoData {
                name: "TargetMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefensiveManeuverSelectorEntityData, target_max_distance),
            },
            FieldInfoData {
                name: "TargetMaxDistanceSlack",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DefensiveManeuverSelectorEntityData, target_max_distance_slack),
            },
        ],
    }),
    array_type: Some(DEFENSIVEMANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DefensiveManeuverSelectorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DEFENSIVEMANEUVERSELECTORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEFENSIVEMANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefensiveManeuverSelectorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DefensiveManeuverSelectorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ManeuverSelectorEntityData {
    pub _glacier_base: DogFightManeuverEntityBaseData,
    pub selector_type: SelectorType,
}

pub trait ManeuverSelectorEntityDataTrait: DogFightManeuverEntityBaseDataTrait {
    fn selector_type(&self) -> &SelectorType;
    fn selector_type_mut(&mut self) -> &mut SelectorType;
}

impl ManeuverSelectorEntityDataTrait for ManeuverSelectorEntityData {
    fn selector_type(&self) -> &SelectorType {
        &self.selector_type
    }
    fn selector_type_mut(&mut self) -> &mut SelectorType {
        &mut self.selector_type
    }
}

impl DogFightManeuverEntityBaseDataTrait for ManeuverSelectorEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn enabled(&self) -> &bool {
        self._glacier_base.enabled()
    }
    fn enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.enabled_mut()
    }
    fn max_roll_angle(&self) -> &f32 {
        self._glacier_base.max_roll_angle()
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_roll_angle_mut()
    }
}

impl super::entity::EntityDataTrait for ManeuverSelectorEntityData {
}

impl super::entity::GameObjectDataTrait for ManeuverSelectorEntityData {
}

impl super::core::DataBusPeerTrait for ManeuverSelectorEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for ManeuverSelectorEntityData {
}

impl super::core::DataContainerTrait for ManeuverSelectorEntityData {
}

pub static MANEUVERSELECTORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ManeuverSelectorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ManeuverSelectorEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SelectorType",
                flags: MemberInfoFlags::new(0),
                field_type: "SelectorType",
                rust_offset: offset_of!(ManeuverSelectorEntityData, selector_type),
            },
        ],
    }),
    array_type: Some(MANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ManeuverSelectorEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MANEUVERSELECTORENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ManeuverSelectorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ManeuverSelectorEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SelectorType {
    #[default]
    SelectorType_Random = 0,
    SelectorType_Priority = 1,
    SelectorType_Sequential = 2,
}

pub static SELECTORTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectorType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SELECTORTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SelectorType {
    fn type_info(&self) -> &'static TypeInfo {
        SELECTORTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SELECTORTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectorType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SelectorType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DogFightManeuverEntityBaseData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub enabled: bool,
    pub max_roll_angle: f32,
}

pub trait DogFightManeuverEntityBaseDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn max_roll_angle(&self) -> &f32;
    fn max_roll_angle_mut(&mut self) -> &mut f32;
}

impl DogFightManeuverEntityBaseDataTrait for DogFightManeuverEntityBaseData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn max_roll_angle(&self) -> &f32 {
        &self.max_roll_angle
    }
    fn max_roll_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_roll_angle
    }
}

impl super::entity::EntityDataTrait for DogFightManeuverEntityBaseData {
}

impl super::entity::GameObjectDataTrait for DogFightManeuverEntityBaseData {
}

impl super::core::DataBusPeerTrait for DogFightManeuverEntityBaseData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DogFightManeuverEntityBaseData {
}

impl super::core::DataContainerTrait for DogFightManeuverEntityBaseData {
}

pub static DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DogFightManeuverEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DogFightManeuverEntityBaseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DogFightManeuverEntityBaseData, realm),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DogFightManeuverEntityBaseData, enabled),
            },
            FieldInfoData {
                name: "MaxRollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DogFightManeuverEntityBaseData, max_roll_angle),
            },
        ],
    }),
    array_type: Some(DOGFIGHTMANEUVERENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DogFightManeuverEntityBaseData {
    fn type_info(&self) -> &'static TypeInfo {
        DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DOGFIGHTMANEUVERENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DogFightManeuverEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DogFightManeuverEntityBaseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WSDogFightingEntityData {
    pub _glacier_base: DogFightingEntityData,
}

pub trait WSDogFightingEntityDataTrait: DogFightingEntityDataTrait {
}

impl WSDogFightingEntityDataTrait for WSDogFightingEntityData {
}

impl DogFightingEntityDataTrait for WSDogFightingEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn take_control_entry_index(&self) -> &i32 {
        self._glacier_base.take_control_entry_index()
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.take_control_entry_index_mut()
    }
    fn draw_debug_info(&self) -> &bool {
        self._glacier_base.draw_debug_info()
    }
    fn draw_debug_info_mut(&mut self) -> &mut bool {
        self._glacier_base.draw_debug_info_mut()
    }
    fn max_target_distance_to_fire(&self) -> &f32 {
        self._glacier_base.max_target_distance_to_fire()
    }
    fn max_target_distance_to_fire_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_target_distance_to_fire_mut()
    }
    fn max_aim_angle_fault_to_fire(&self) -> &f32 {
        self._glacier_base.max_aim_angle_fault_to_fire()
    }
    fn max_aim_angle_fault_to_fire_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_aim_angle_fault_to_fire_mut()
    }
    fn default_speed(&self) -> &f32 {
        self._glacier_base.default_speed()
    }
    fn default_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.default_speed_mut()
    }
    fn max_speed(&self) -> &f32 {
        self._glacier_base.max_speed()
    }
    fn max_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_speed_mut()
    }
    fn collision_radius_modifier(&self) -> &f32 {
        self._glacier_base.collision_radius_modifier()
    }
    fn collision_radius_modifier_mut(&mut self) -> &mut f32 {
        self._glacier_base.collision_radius_modifier_mut()
    }
    fn most_agile_speed(&self) -> &f32 {
        self._glacier_base.most_agile_speed()
    }
    fn most_agile_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.most_agile_speed_mut()
    }
    fn should_select_target(&self) -> &bool {
        self._glacier_base.should_select_target()
    }
    fn should_select_target_mut(&mut self) -> &mut bool {
        self._glacier_base.should_select_target_mut()
    }
    fn is_target(&self) -> &bool {
        self._glacier_base.is_target()
    }
    fn is_target_mut(&mut self) -> &mut bool {
        self._glacier_base.is_target_mut()
    }
    fn priority_as_target(&self) -> &i32 {
        self._glacier_base.priority_as_target()
    }
    fn priority_as_target_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_as_target_mut()
    }
}

impl super::entity::EntityDataTrait for WSDogFightingEntityData {
}

impl super::entity::GameObjectDataTrait for WSDogFightingEntityData {
}

impl super::core::DataBusPeerTrait for WSDogFightingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for WSDogFightingEntityData {
}

impl super::core::DataContainerTrait for WSDogFightingEntityData {
}

pub static WSDOGFIGHTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WSDogFightingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTINGENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WSDogFightingEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(WSDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WSDogFightingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        WSDOGFIGHTINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WSDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WSDogFightingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WSDogFightingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BFDogFightingEntityData {
    pub _glacier_base: DogFightingEntityData,
}

pub trait BFDogFightingEntityDataTrait: DogFightingEntityDataTrait {
}

impl BFDogFightingEntityDataTrait for BFDogFightingEntityData {
}

impl DogFightingEntityDataTrait for BFDogFightingEntityData {
    fn realm(&self) -> &super::core::Realm {
        self._glacier_base.realm()
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        self._glacier_base.realm_mut()
    }
    fn take_control_entry_index(&self) -> &i32 {
        self._glacier_base.take_control_entry_index()
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        self._glacier_base.take_control_entry_index_mut()
    }
    fn draw_debug_info(&self) -> &bool {
        self._glacier_base.draw_debug_info()
    }
    fn draw_debug_info_mut(&mut self) -> &mut bool {
        self._glacier_base.draw_debug_info_mut()
    }
    fn max_target_distance_to_fire(&self) -> &f32 {
        self._glacier_base.max_target_distance_to_fire()
    }
    fn max_target_distance_to_fire_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_target_distance_to_fire_mut()
    }
    fn max_aim_angle_fault_to_fire(&self) -> &f32 {
        self._glacier_base.max_aim_angle_fault_to_fire()
    }
    fn max_aim_angle_fault_to_fire_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_aim_angle_fault_to_fire_mut()
    }
    fn default_speed(&self) -> &f32 {
        self._glacier_base.default_speed()
    }
    fn default_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.default_speed_mut()
    }
    fn max_speed(&self) -> &f32 {
        self._glacier_base.max_speed()
    }
    fn max_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_speed_mut()
    }
    fn collision_radius_modifier(&self) -> &f32 {
        self._glacier_base.collision_radius_modifier()
    }
    fn collision_radius_modifier_mut(&mut self) -> &mut f32 {
        self._glacier_base.collision_radius_modifier_mut()
    }
    fn most_agile_speed(&self) -> &f32 {
        self._glacier_base.most_agile_speed()
    }
    fn most_agile_speed_mut(&mut self) -> &mut f32 {
        self._glacier_base.most_agile_speed_mut()
    }
    fn should_select_target(&self) -> &bool {
        self._glacier_base.should_select_target()
    }
    fn should_select_target_mut(&mut self) -> &mut bool {
        self._glacier_base.should_select_target_mut()
    }
    fn is_target(&self) -> &bool {
        self._glacier_base.is_target()
    }
    fn is_target_mut(&mut self) -> &mut bool {
        self._glacier_base.is_target_mut()
    }
    fn priority_as_target(&self) -> &i32 {
        self._glacier_base.priority_as_target()
    }
    fn priority_as_target_mut(&mut self) -> &mut i32 {
        self._glacier_base.priority_as_target_mut()
    }
}

impl super::entity::EntityDataTrait for BFDogFightingEntityData {
}

impl super::entity::GameObjectDataTrait for BFDogFightingEntityData {
}

impl super::core::DataBusPeerTrait for BFDogFightingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for BFDogFightingEntityData {
}

impl super::core::DataContainerTrait for BFDogFightingEntityData {
}

pub static BFDOGFIGHTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BFDogFightingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTINGENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BFDogFightingEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BFDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BFDogFightingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        BFDOGFIGHTINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BFDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BFDogFightingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BFDogFightingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DogFightingEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub take_control_entry_index: i32,
    pub draw_debug_info: bool,
    pub max_target_distance_to_fire: f32,
    pub max_aim_angle_fault_to_fire: f32,
    pub default_speed: f32,
    pub max_speed: f32,
    pub collision_radius_modifier: f32,
    pub most_agile_speed: f32,
    pub should_select_target: bool,
    pub is_target: bool,
    pub priority_as_target: i32,
}

pub trait DogFightingEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn take_control_entry_index(&self) -> &i32;
    fn take_control_entry_index_mut(&mut self) -> &mut i32;
    fn draw_debug_info(&self) -> &bool;
    fn draw_debug_info_mut(&mut self) -> &mut bool;
    fn max_target_distance_to_fire(&self) -> &f32;
    fn max_target_distance_to_fire_mut(&mut self) -> &mut f32;
    fn max_aim_angle_fault_to_fire(&self) -> &f32;
    fn max_aim_angle_fault_to_fire_mut(&mut self) -> &mut f32;
    fn default_speed(&self) -> &f32;
    fn default_speed_mut(&mut self) -> &mut f32;
    fn max_speed(&self) -> &f32;
    fn max_speed_mut(&mut self) -> &mut f32;
    fn collision_radius_modifier(&self) -> &f32;
    fn collision_radius_modifier_mut(&mut self) -> &mut f32;
    fn most_agile_speed(&self) -> &f32;
    fn most_agile_speed_mut(&mut self) -> &mut f32;
    fn should_select_target(&self) -> &bool;
    fn should_select_target_mut(&mut self) -> &mut bool;
    fn is_target(&self) -> &bool;
    fn is_target_mut(&mut self) -> &mut bool;
    fn priority_as_target(&self) -> &i32;
    fn priority_as_target_mut(&mut self) -> &mut i32;
}

impl DogFightingEntityDataTrait for DogFightingEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn take_control_entry_index(&self) -> &i32 {
        &self.take_control_entry_index
    }
    fn take_control_entry_index_mut(&mut self) -> &mut i32 {
        &mut self.take_control_entry_index
    }
    fn draw_debug_info(&self) -> &bool {
        &self.draw_debug_info
    }
    fn draw_debug_info_mut(&mut self) -> &mut bool {
        &mut self.draw_debug_info
    }
    fn max_target_distance_to_fire(&self) -> &f32 {
        &self.max_target_distance_to_fire
    }
    fn max_target_distance_to_fire_mut(&mut self) -> &mut f32 {
        &mut self.max_target_distance_to_fire
    }
    fn max_aim_angle_fault_to_fire(&self) -> &f32 {
        &self.max_aim_angle_fault_to_fire
    }
    fn max_aim_angle_fault_to_fire_mut(&mut self) -> &mut f32 {
        &mut self.max_aim_angle_fault_to_fire
    }
    fn default_speed(&self) -> &f32 {
        &self.default_speed
    }
    fn default_speed_mut(&mut self) -> &mut f32 {
        &mut self.default_speed
    }
    fn max_speed(&self) -> &f32 {
        &self.max_speed
    }
    fn max_speed_mut(&mut self) -> &mut f32 {
        &mut self.max_speed
    }
    fn collision_radius_modifier(&self) -> &f32 {
        &self.collision_radius_modifier
    }
    fn collision_radius_modifier_mut(&mut self) -> &mut f32 {
        &mut self.collision_radius_modifier
    }
    fn most_agile_speed(&self) -> &f32 {
        &self.most_agile_speed
    }
    fn most_agile_speed_mut(&mut self) -> &mut f32 {
        &mut self.most_agile_speed
    }
    fn should_select_target(&self) -> &bool {
        &self.should_select_target
    }
    fn should_select_target_mut(&mut self) -> &mut bool {
        &mut self.should_select_target
    }
    fn is_target(&self) -> &bool {
        &self.is_target
    }
    fn is_target_mut(&mut self) -> &mut bool {
        &mut self.is_target
    }
    fn priority_as_target(&self) -> &i32 {
        &self.priority_as_target
    }
    fn priority_as_target_mut(&mut self) -> &mut i32 {
        &mut self.priority_as_target
    }
}

impl super::entity::EntityDataTrait for DogFightingEntityData {
}

impl super::entity::GameObjectDataTrait for DogFightingEntityData {
}

impl super::core::DataBusPeerTrait for DogFightingEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DogFightingEntityData {
}

impl super::core::DataContainerTrait for DogFightingEntityData {
}

pub static DOGFIGHTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DogFightingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DogFightingEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DogFightingEntityData, realm),
            },
            FieldInfoData {
                name: "TakeControlEntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DogFightingEntityData, take_control_entry_index),
            },
            FieldInfoData {
                name: "DrawDebugInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DogFightingEntityData, draw_debug_info),
            },
            FieldInfoData {
                name: "MaxTargetDistanceToFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DogFightingEntityData, max_target_distance_to_fire),
            },
            FieldInfoData {
                name: "MaxAimAngleFaultToFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DogFightingEntityData, max_aim_angle_fault_to_fire),
            },
            FieldInfoData {
                name: "DefaultSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DogFightingEntityData, default_speed),
            },
            FieldInfoData {
                name: "MaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DogFightingEntityData, max_speed),
            },
            FieldInfoData {
                name: "CollisionRadiusModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DogFightingEntityData, collision_radius_modifier),
            },
            FieldInfoData {
                name: "MostAgileSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DogFightingEntityData, most_agile_speed),
            },
            FieldInfoData {
                name: "ShouldSelectTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DogFightingEntityData, should_select_target),
            },
            FieldInfoData {
                name: "IsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DogFightingEntityData, is_target),
            },
            FieldInfoData {
                name: "PriorityAsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DogFightingEntityData, priority_as_target),
            },
        ],
    }),
    array_type: Some(DOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DogFightingEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DOGFIGHTINGENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DogFightingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DogFightingEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DamageModifierEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub enable_from_start: bool,
    pub damage_multiplier_a_ivs_human: f32,
}

pub trait DamageModifierEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn enable_from_start(&self) -> &bool;
    fn enable_from_start_mut(&mut self) -> &mut bool;
    fn damage_multiplier_a_ivs_human(&self) -> &f32;
    fn damage_multiplier_a_ivs_human_mut(&mut self) -> &mut f32;
}

impl DamageModifierEntityDataTrait for DamageModifierEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn enable_from_start(&self) -> &bool {
        &self.enable_from_start
    }
    fn enable_from_start_mut(&mut self) -> &mut bool {
        &mut self.enable_from_start
    }
    fn damage_multiplier_a_ivs_human(&self) -> &f32 {
        &self.damage_multiplier_a_ivs_human
    }
    fn damage_multiplier_a_ivs_human_mut(&mut self) -> &mut f32 {
        &mut self.damage_multiplier_a_ivs_human
    }
}

impl super::entity::EntityDataTrait for DamageModifierEntityData {
}

impl super::entity::GameObjectDataTrait for DamageModifierEntityData {
}

impl super::core::DataBusPeerTrait for DamageModifierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for DamageModifierEntityData {
}

impl super::core::DataContainerTrait for DamageModifierEntityData {
}

pub static DAMAGEMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DamageModifierEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(DamageModifierEntityData, realm),
            },
            FieldInfoData {
                name: "EnableFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DamageModifierEntityData, enable_from_start),
            },
            FieldInfoData {
                name: "DamageMultiplierAIvsHuman",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DamageModifierEntityData, damage_multiplier_a_ivs_human),
            },
        ],
    }),
    array_type: Some(DAMAGEMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DamageModifierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEMODIFIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DAMAGEMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DamageModifierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverEntityData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub min_hover_height: f32,
    pub max_hover_height: f32,
    pub max_side_step_radius: f32,
    pub covers: Vec<CoverData>,
}

pub trait CoverEntityDataTrait: super::entity::SpatialEntityDataTrait {
    fn min_hover_height(&self) -> &f32;
    fn min_hover_height_mut(&mut self) -> &mut f32;
    fn max_hover_height(&self) -> &f32;
    fn max_hover_height_mut(&mut self) -> &mut f32;
    fn max_side_step_radius(&self) -> &f32;
    fn max_side_step_radius_mut(&mut self) -> &mut f32;
    fn covers(&self) -> &Vec<CoverData>;
    fn covers_mut(&mut self) -> &mut Vec<CoverData>;
}

impl CoverEntityDataTrait for CoverEntityData {
    fn min_hover_height(&self) -> &f32 {
        &self.min_hover_height
    }
    fn min_hover_height_mut(&mut self) -> &mut f32 {
        &mut self.min_hover_height
    }
    fn max_hover_height(&self) -> &f32 {
        &self.max_hover_height
    }
    fn max_hover_height_mut(&mut self) -> &mut f32 {
        &mut self.max_hover_height
    }
    fn max_side_step_radius(&self) -> &f32 {
        &self.max_side_step_radius
    }
    fn max_side_step_radius_mut(&mut self) -> &mut f32 {
        &mut self.max_side_step_radius
    }
    fn covers(&self) -> &Vec<CoverData> {
        &self.covers
    }
    fn covers_mut(&mut self) -> &mut Vec<CoverData> {
        &mut self.covers
    }
}

impl super::entity::SpatialEntityDataTrait for CoverEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for CoverEntityData {
}

impl super::entity::GameObjectDataTrait for CoverEntityData {
}

impl super::core::DataBusPeerTrait for CoverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CoverEntityData {
}

impl super::core::DataContainerTrait for CoverEntityData {
}

pub static COVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverEntityData, min_hover_height),
            },
            FieldInfoData {
                name: "MaxHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverEntityData, max_hover_height),
            },
            FieldInfoData {
                name: "MaxSideStepRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverEntityData, max_side_step_radius),
            },
            FieldInfoData {
                name: "Covers",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverData-Array",
                rust_offset: offset_of!(CoverEntityData, covers),
            },
        ],
    }),
    array_type: Some(COVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CoverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverPreviewAnimType {
    #[default]
    CoverPreviewAnimType_Stand_Left = 0,
    CoverPreviewAnimType_Stand_Right = 1,
    CoverPreviewAnimType_Crouch_Left = 2,
    CoverPreviewAnimType_Crouch_Right = 3,
    CoverPreviewAnimType_Count = 4,
}

pub static COVERPREVIEWANIMTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPreviewAnimType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERPREVIEWANIMTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverPreviewAnimType {
    fn type_info(&self) -> &'static TypeInfo {
        COVERPREVIEWANIMTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERPREVIEWANIMTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPreviewAnimType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverPreviewAnimType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverSlot {
    pub position: super::core::Vec3,
}

pub trait CoverSlotTrait: TypeObject {
    fn position(&self) -> &super::core::Vec3;
    fn position_mut(&mut self) -> &mut super::core::Vec3;
}

impl CoverSlotTrait for CoverSlot {
    fn position(&self) -> &super::core::Vec3 {
        &self.position
    }
    fn position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.position
    }
}

pub static COVERSLOT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSlot",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverSlot as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(CoverSlot, position),
            },
        ],
    }),
    array_type: Some(COVERSLOT_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CoverSlot {
    fn type_info(&self) -> &'static TypeInfo {
        COVERSLOT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERSLOT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSlot-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSlot"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverType {
    #[default]
    CoverType_Stand = 0,
    CoverType_Medium = 1,
    CoverType_Crouch = 2,
    CoverType_Prone = 3,
    CoverType_Open = 4,
    CoverType_OpenDirectional = 5,
}

pub static COVERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverType {
    fn type_info(&self) -> &'static TypeInfo {
        COVERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OldCoverQueryData {
    pub _glacier_base: super::core::Asset,
    pub line_of_fire_score: f32,
    pub max_target_distance_for_rejected_by_line_of_fire: f32,
    pub navigation_score: f32,
    pub pathfinding_score: f32,
    pub distance_to_target: Vec<f32>,
    pub pathfinding_thresholds: Vec<f32>,
    pub default_pathfinding_threshold: f32,
    pub pathfinding_lower_limit: f32,
    pub pathfinding_upper_limit: f32,
    pub reject_invalid_paths: bool,
    pub reject_unreachable_covers: bool,
    pub cover_query_path_enemy_avoidance: CoverQueryPathEnemyAvoidanceData,
    pub max_rejected_time: f32,
    pub min_count_for_secondary_filter: i32,
    pub spatial_filter: Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>>,
    pub secondary_spatial_filter: Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>>,
    pub scores: Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>>,
    pub runtime_scores: Vec<CoverQueryScoreRuntime>,
}

pub trait OldCoverQueryDataTrait: super::core::AssetTrait {
    fn line_of_fire_score(&self) -> &f32;
    fn line_of_fire_score_mut(&mut self) -> &mut f32;
    fn max_target_distance_for_rejected_by_line_of_fire(&self) -> &f32;
    fn max_target_distance_for_rejected_by_line_of_fire_mut(&mut self) -> &mut f32;
    fn navigation_score(&self) -> &f32;
    fn navigation_score_mut(&mut self) -> &mut f32;
    fn pathfinding_score(&self) -> &f32;
    fn pathfinding_score_mut(&mut self) -> &mut f32;
    fn distance_to_target(&self) -> &Vec<f32>;
    fn distance_to_target_mut(&mut self) -> &mut Vec<f32>;
    fn pathfinding_thresholds(&self) -> &Vec<f32>;
    fn pathfinding_thresholds_mut(&mut self) -> &mut Vec<f32>;
    fn default_pathfinding_threshold(&self) -> &f32;
    fn default_pathfinding_threshold_mut(&mut self) -> &mut f32;
    fn pathfinding_lower_limit(&self) -> &f32;
    fn pathfinding_lower_limit_mut(&mut self) -> &mut f32;
    fn pathfinding_upper_limit(&self) -> &f32;
    fn pathfinding_upper_limit_mut(&mut self) -> &mut f32;
    fn reject_invalid_paths(&self) -> &bool;
    fn reject_invalid_paths_mut(&mut self) -> &mut bool;
    fn reject_unreachable_covers(&self) -> &bool;
    fn reject_unreachable_covers_mut(&mut self) -> &mut bool;
    fn cover_query_path_enemy_avoidance(&self) -> &CoverQueryPathEnemyAvoidanceData;
    fn cover_query_path_enemy_avoidance_mut(&mut self) -> &mut CoverQueryPathEnemyAvoidanceData;
    fn max_rejected_time(&self) -> &f32;
    fn max_rejected_time_mut(&mut self) -> &mut f32;
    fn min_count_for_secondary_filter(&self) -> &i32;
    fn min_count_for_secondary_filter_mut(&mut self) -> &mut i32;
    fn spatial_filter(&self) -> &Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>>;
    fn spatial_filter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>>;
    fn secondary_spatial_filter(&self) -> &Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>>;
    fn secondary_spatial_filter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>>;
    fn scores(&self) -> &Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>>;
    fn scores_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>>;
    fn runtime_scores(&self) -> &Vec<CoverQueryScoreRuntime>;
    fn runtime_scores_mut(&mut self) -> &mut Vec<CoverQueryScoreRuntime>;
}

impl OldCoverQueryDataTrait for OldCoverQueryData {
    fn line_of_fire_score(&self) -> &f32 {
        &self.line_of_fire_score
    }
    fn line_of_fire_score_mut(&mut self) -> &mut f32 {
        &mut self.line_of_fire_score
    }
    fn max_target_distance_for_rejected_by_line_of_fire(&self) -> &f32 {
        &self.max_target_distance_for_rejected_by_line_of_fire
    }
    fn max_target_distance_for_rejected_by_line_of_fire_mut(&mut self) -> &mut f32 {
        &mut self.max_target_distance_for_rejected_by_line_of_fire
    }
    fn navigation_score(&self) -> &f32 {
        &self.navigation_score
    }
    fn navigation_score_mut(&mut self) -> &mut f32 {
        &mut self.navigation_score
    }
    fn pathfinding_score(&self) -> &f32 {
        &self.pathfinding_score
    }
    fn pathfinding_score_mut(&mut self) -> &mut f32 {
        &mut self.pathfinding_score
    }
    fn distance_to_target(&self) -> &Vec<f32> {
        &self.distance_to_target
    }
    fn distance_to_target_mut(&mut self) -> &mut Vec<f32> {
        &mut self.distance_to_target
    }
    fn pathfinding_thresholds(&self) -> &Vec<f32> {
        &self.pathfinding_thresholds
    }
    fn pathfinding_thresholds_mut(&mut self) -> &mut Vec<f32> {
        &mut self.pathfinding_thresholds
    }
    fn default_pathfinding_threshold(&self) -> &f32 {
        &self.default_pathfinding_threshold
    }
    fn default_pathfinding_threshold_mut(&mut self) -> &mut f32 {
        &mut self.default_pathfinding_threshold
    }
    fn pathfinding_lower_limit(&self) -> &f32 {
        &self.pathfinding_lower_limit
    }
    fn pathfinding_lower_limit_mut(&mut self) -> &mut f32 {
        &mut self.pathfinding_lower_limit
    }
    fn pathfinding_upper_limit(&self) -> &f32 {
        &self.pathfinding_upper_limit
    }
    fn pathfinding_upper_limit_mut(&mut self) -> &mut f32 {
        &mut self.pathfinding_upper_limit
    }
    fn reject_invalid_paths(&self) -> &bool {
        &self.reject_invalid_paths
    }
    fn reject_invalid_paths_mut(&mut self) -> &mut bool {
        &mut self.reject_invalid_paths
    }
    fn reject_unreachable_covers(&self) -> &bool {
        &self.reject_unreachable_covers
    }
    fn reject_unreachable_covers_mut(&mut self) -> &mut bool {
        &mut self.reject_unreachable_covers
    }
    fn cover_query_path_enemy_avoidance(&self) -> &CoverQueryPathEnemyAvoidanceData {
        &self.cover_query_path_enemy_avoidance
    }
    fn cover_query_path_enemy_avoidance_mut(&mut self) -> &mut CoverQueryPathEnemyAvoidanceData {
        &mut self.cover_query_path_enemy_avoidance
    }
    fn max_rejected_time(&self) -> &f32 {
        &self.max_rejected_time
    }
    fn max_rejected_time_mut(&mut self) -> &mut f32 {
        &mut self.max_rejected_time
    }
    fn min_count_for_secondary_filter(&self) -> &i32 {
        &self.min_count_for_secondary_filter
    }
    fn min_count_for_secondary_filter_mut(&mut self) -> &mut i32 {
        &mut self.min_count_for_secondary_filter
    }
    fn spatial_filter(&self) -> &Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>> {
        &self.spatial_filter
    }
    fn spatial_filter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>> {
        &mut self.spatial_filter
    }
    fn secondary_spatial_filter(&self) -> &Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>> {
        &self.secondary_spatial_filter
    }
    fn secondary_spatial_filter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>> {
        &mut self.secondary_spatial_filter
    }
    fn scores(&self) -> &Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>> {
        &self.scores
    }
    fn scores_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>> {
        &mut self.scores
    }
    fn runtime_scores(&self) -> &Vec<CoverQueryScoreRuntime> {
        &self.runtime_scores
    }
    fn runtime_scores_mut(&mut self) -> &mut Vec<CoverQueryScoreRuntime> {
        &mut self.runtime_scores
    }
}

impl super::core::AssetTrait for OldCoverQueryData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for OldCoverQueryData {
}

pub static OLDCOVERQUERYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldCoverQueryData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OldCoverQueryData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LineOfFireScore",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OldCoverQueryData, line_of_fire_score),
            },
            FieldInfoData {
                name: "MaxTargetDistanceForRejectedByLineOfFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OldCoverQueryData, max_target_distance_for_rejected_by_line_of_fire),
            },
            FieldInfoData {
                name: "NavigationScore",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OldCoverQueryData, navigation_score),
            },
            FieldInfoData {
                name: "PathfindingScore",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OldCoverQueryData, pathfinding_score),
            },
            FieldInfoData {
                name: "DistanceToTarget",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(OldCoverQueryData, distance_to_target),
            },
            FieldInfoData {
                name: "PathfindingThresholds",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(OldCoverQueryData, pathfinding_thresholds),
            },
            FieldInfoData {
                name: "DefaultPathfindingThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OldCoverQueryData, default_pathfinding_threshold),
            },
            FieldInfoData {
                name: "PathfindingLowerLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OldCoverQueryData, pathfinding_lower_limit),
            },
            FieldInfoData {
                name: "PathfindingUpperLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OldCoverQueryData, pathfinding_upper_limit),
            },
            FieldInfoData {
                name: "RejectInvalidPaths",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OldCoverQueryData, reject_invalid_paths),
            },
            FieldInfoData {
                name: "RejectUnreachableCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OldCoverQueryData, reject_unreachable_covers),
            },
            FieldInfoData {
                name: "CoverQueryPathEnemyAvoidance",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPathEnemyAvoidanceData",
                rust_offset: offset_of!(OldCoverQueryData, cover_query_path_enemy_avoidance),
            },
            FieldInfoData {
                name: "MaxRejectedTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OldCoverQueryData, max_rejected_time),
            },
            FieldInfoData {
                name: "MinCountForSecondaryFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(OldCoverQueryData, min_count_for_secondary_filter),
            },
            FieldInfoData {
                name: "SpatialFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQuerySpatialBase",
                rust_offset: offset_of!(OldCoverQueryData, spatial_filter),
            },
            FieldInfoData {
                name: "SecondarySpatialFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQuerySpatialBase",
                rust_offset: offset_of!(OldCoverQueryData, secondary_spatial_filter),
            },
            FieldInfoData {
                name: "Scores",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverQueryScoreBase-Array",
                rust_offset: offset_of!(OldCoverQueryData, scores),
            },
            FieldInfoData {
                name: "RuntimeScores",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverQueryScoreRuntime-Array",
                rust_offset: offset_of!(OldCoverQueryData, runtime_scores),
            },
        ],
    }),
    array_type: Some(OLDCOVERQUERYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OldCoverQueryData {
    fn type_info(&self) -> &'static TypeInfo {
        OLDCOVERQUERYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OLDCOVERQUERYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldCoverQueryData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("OldCoverQueryData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverQueryScoreData {
    pub _glacier_base: super::core::Asset,
    pub scores: Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>>,
    pub runtime_scores: Vec<CoverQueryScoreRuntime>,
}

pub trait CoverQueryScoreDataTrait: super::core::AssetTrait {
    fn scores(&self) -> &Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>>;
    fn scores_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>>;
    fn runtime_scores(&self) -> &Vec<CoverQueryScoreRuntime>;
    fn runtime_scores_mut(&mut self) -> &mut Vec<CoverQueryScoreRuntime>;
}

impl CoverQueryScoreDataTrait for CoverQueryScoreData {
    fn scores(&self) -> &Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>> {
        &self.scores
    }
    fn scores_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverQueryScoreBaseTrait>>>> {
        &mut self.scores
    }
    fn runtime_scores(&self) -> &Vec<CoverQueryScoreRuntime> {
        &self.runtime_scores
    }
    fn runtime_scores_mut(&mut self) -> &mut Vec<CoverQueryScoreRuntime> {
        &mut self.runtime_scores
    }
}

impl super::core::AssetTrait for CoverQueryScoreData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CoverQueryScoreData {
}

pub static COVERQUERYSCOREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverQueryScoreData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Scores",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverQueryScoreBase-Array",
                rust_offset: offset_of!(CoverQueryScoreData, scores),
            },
            FieldInfoData {
                name: "RuntimeScores",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverQueryScoreRuntime-Array",
                rust_offset: offset_of!(CoverQueryScoreData, runtime_scores),
            },
        ],
    }),
    array_type: Some(COVERQUERYSCOREDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQueryScoreData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYSCOREDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERQUERYSCOREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverQueryScoreRuntime {
    pub relation_mask: i32,
    pub flags: i32,
    pub filter: i32,
    pub x_style: CoverQueryStyle,
    pub from_position: CoverQueryPosition,
    pub to_position: CoverQueryPosition,
    pub reference_direction: CoverQueryDirection,
    pub secondary_parameters: CoverQueryScoreSecondaryData,
    pub curve_x_source: CoverQueryCurveXSource,
    pub curve: Vec<f32>,
    pub base_score_index: u32,
}

pub trait CoverQueryScoreRuntimeTrait: TypeObject {
    fn relation_mask(&self) -> &i32;
    fn relation_mask_mut(&mut self) -> &mut i32;
    fn flags(&self) -> &i32;
    fn flags_mut(&mut self) -> &mut i32;
    fn filter(&self) -> &i32;
    fn filter_mut(&mut self) -> &mut i32;
    fn x_style(&self) -> &CoverQueryStyle;
    fn x_style_mut(&mut self) -> &mut CoverQueryStyle;
    fn from_position(&self) -> &CoverQueryPosition;
    fn from_position_mut(&mut self) -> &mut CoverQueryPosition;
    fn to_position(&self) -> &CoverQueryPosition;
    fn to_position_mut(&mut self) -> &mut CoverQueryPosition;
    fn reference_direction(&self) -> &CoverQueryDirection;
    fn reference_direction_mut(&mut self) -> &mut CoverQueryDirection;
    fn secondary_parameters(&self) -> &CoverQueryScoreSecondaryData;
    fn secondary_parameters_mut(&mut self) -> &mut CoverQueryScoreSecondaryData;
    fn curve_x_source(&self) -> &CoverQueryCurveXSource;
    fn curve_x_source_mut(&mut self) -> &mut CoverQueryCurveXSource;
    fn curve(&self) -> &Vec<f32>;
    fn curve_mut(&mut self) -> &mut Vec<f32>;
    fn base_score_index(&self) -> &u32;
    fn base_score_index_mut(&mut self) -> &mut u32;
}

impl CoverQueryScoreRuntimeTrait for CoverQueryScoreRuntime {
    fn relation_mask(&self) -> &i32 {
        &self.relation_mask
    }
    fn relation_mask_mut(&mut self) -> &mut i32 {
        &mut self.relation_mask
    }
    fn flags(&self) -> &i32 {
        &self.flags
    }
    fn flags_mut(&mut self) -> &mut i32 {
        &mut self.flags
    }
    fn filter(&self) -> &i32 {
        &self.filter
    }
    fn filter_mut(&mut self) -> &mut i32 {
        &mut self.filter
    }
    fn x_style(&self) -> &CoverQueryStyle {
        &self.x_style
    }
    fn x_style_mut(&mut self) -> &mut CoverQueryStyle {
        &mut self.x_style
    }
    fn from_position(&self) -> &CoverQueryPosition {
        &self.from_position
    }
    fn from_position_mut(&mut self) -> &mut CoverQueryPosition {
        &mut self.from_position
    }
    fn to_position(&self) -> &CoverQueryPosition {
        &self.to_position
    }
    fn to_position_mut(&mut self) -> &mut CoverQueryPosition {
        &mut self.to_position
    }
    fn reference_direction(&self) -> &CoverQueryDirection {
        &self.reference_direction
    }
    fn reference_direction_mut(&mut self) -> &mut CoverQueryDirection {
        &mut self.reference_direction
    }
    fn secondary_parameters(&self) -> &CoverQueryScoreSecondaryData {
        &self.secondary_parameters
    }
    fn secondary_parameters_mut(&mut self) -> &mut CoverQueryScoreSecondaryData {
        &mut self.secondary_parameters
    }
    fn curve_x_source(&self) -> &CoverQueryCurveXSource {
        &self.curve_x_source
    }
    fn curve_x_source_mut(&mut self) -> &mut CoverQueryCurveXSource {
        &mut self.curve_x_source
    }
    fn curve(&self) -> &Vec<f32> {
        &self.curve
    }
    fn curve_mut(&mut self) -> &mut Vec<f32> {
        &mut self.curve
    }
    fn base_score_index(&self) -> &u32 {
        &self.base_score_index
    }
    fn base_score_index_mut(&mut self) -> &mut u32 {
        &mut self.base_score_index
    }
}

pub static COVERQUERYSCORERUNTIME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreRuntime",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverQueryScoreRuntime as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RelationMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverQueryScoreRuntime, relation_mask),
            },
            FieldInfoData {
                name: "Flags",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverQueryScoreRuntime, flags),
            },
            FieldInfoData {
                name: "Filter",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverQueryScoreRuntime, filter),
            },
            FieldInfoData {
                name: "XStyle",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryStyle",
                rust_offset: offset_of!(CoverQueryScoreRuntime, x_style),
            },
            FieldInfoData {
                name: "FromPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPosition",
                rust_offset: offset_of!(CoverQueryScoreRuntime, from_position),
            },
            FieldInfoData {
                name: "ToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPosition",
                rust_offset: offset_of!(CoverQueryScoreRuntime, to_position),
            },
            FieldInfoData {
                name: "ReferenceDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryDirection",
                rust_offset: offset_of!(CoverQueryScoreRuntime, reference_direction),
            },
            FieldInfoData {
                name: "SecondaryParameters",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryScoreSecondaryData",
                rust_offset: offset_of!(CoverQueryScoreRuntime, secondary_parameters),
            },
            FieldInfoData {
                name: "CurveXSource",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryCurveXSource",
                rust_offset: offset_of!(CoverQueryScoreRuntime, curve_x_source),
            },
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(CoverQueryScoreRuntime, curve),
            },
            FieldInfoData {
                name: "BaseScoreIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CoverQueryScoreRuntime, base_score_index),
            },
        ],
    }),
    array_type: Some(COVERQUERYSCORERUNTIME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQueryScoreRuntime {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYSCORERUNTIME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYSCORERUNTIME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreRuntime-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreRuntime"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverQueryScoreRuntimeFlags {
    #[default]
    CoverQueryScoreRuntimeFlags_NeedTarget = 1,
    CoverQueryScoreRuntimeFlags_NeedSquad = 2,
}

pub static COVERQUERYSCORERUNTIMEFLAGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreRuntimeFlags",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYSCORERUNTIMEFLAGS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryScoreRuntimeFlags {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYSCORERUNTIMEFLAGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYSCORERUNTIMEFLAGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreRuntimeFlags-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreRuntimeFlags"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverQueryScoreBase {
    pub _glacier_base: super::core::DataContainer,
    pub enabled: bool,
    pub filter: CoverQueryFilter,
    pub x_style: CoverQueryStyle,
    pub from_position: CoverQueryPosition,
    pub to_position: CoverQueryPosition,
    pub reference_direction: CoverQueryDirection,
    pub secondary_parameters: CoverQueryScoreSecondaryData,
    pub curve_x_source: CoverQueryCurveXSource,
    pub x: Vec<f32>,
    pub score: Vec<f32>,
}

pub trait CoverQueryScoreBaseTrait: super::core::DataContainerTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn filter(&self) -> &CoverQueryFilter;
    fn filter_mut(&mut self) -> &mut CoverQueryFilter;
    fn x_style(&self) -> &CoverQueryStyle;
    fn x_style_mut(&mut self) -> &mut CoverQueryStyle;
    fn from_position(&self) -> &CoverQueryPosition;
    fn from_position_mut(&mut self) -> &mut CoverQueryPosition;
    fn to_position(&self) -> &CoverQueryPosition;
    fn to_position_mut(&mut self) -> &mut CoverQueryPosition;
    fn reference_direction(&self) -> &CoverQueryDirection;
    fn reference_direction_mut(&mut self) -> &mut CoverQueryDirection;
    fn secondary_parameters(&self) -> &CoverQueryScoreSecondaryData;
    fn secondary_parameters_mut(&mut self) -> &mut CoverQueryScoreSecondaryData;
    fn curve_x_source(&self) -> &CoverQueryCurveXSource;
    fn curve_x_source_mut(&mut self) -> &mut CoverQueryCurveXSource;
    fn x(&self) -> &Vec<f32>;
    fn x_mut(&mut self) -> &mut Vec<f32>;
    fn score(&self) -> &Vec<f32>;
    fn score_mut(&mut self) -> &mut Vec<f32>;
}

impl CoverQueryScoreBaseTrait for CoverQueryScoreBase {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn filter(&self) -> &CoverQueryFilter {
        &self.filter
    }
    fn filter_mut(&mut self) -> &mut CoverQueryFilter {
        &mut self.filter
    }
    fn x_style(&self) -> &CoverQueryStyle {
        &self.x_style
    }
    fn x_style_mut(&mut self) -> &mut CoverQueryStyle {
        &mut self.x_style
    }
    fn from_position(&self) -> &CoverQueryPosition {
        &self.from_position
    }
    fn from_position_mut(&mut self) -> &mut CoverQueryPosition {
        &mut self.from_position
    }
    fn to_position(&self) -> &CoverQueryPosition {
        &self.to_position
    }
    fn to_position_mut(&mut self) -> &mut CoverQueryPosition {
        &mut self.to_position
    }
    fn reference_direction(&self) -> &CoverQueryDirection {
        &self.reference_direction
    }
    fn reference_direction_mut(&mut self) -> &mut CoverQueryDirection {
        &mut self.reference_direction
    }
    fn secondary_parameters(&self) -> &CoverQueryScoreSecondaryData {
        &self.secondary_parameters
    }
    fn secondary_parameters_mut(&mut self) -> &mut CoverQueryScoreSecondaryData {
        &mut self.secondary_parameters
    }
    fn curve_x_source(&self) -> &CoverQueryCurveXSource {
        &self.curve_x_source
    }
    fn curve_x_source_mut(&mut self) -> &mut CoverQueryCurveXSource {
        &mut self.curve_x_source
    }
    fn x(&self) -> &Vec<f32> {
        &self.x
    }
    fn x_mut(&mut self) -> &mut Vec<f32> {
        &mut self.x
    }
    fn score(&self) -> &Vec<f32> {
        &self.score
    }
    fn score_mut(&mut self) -> &mut Vec<f32> {
        &mut self.score
    }
}

impl super::core::DataContainerTrait for CoverQueryScoreBase {
}

pub static COVERQUERYSCOREBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreBase",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverQueryScoreBase as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryScoreBase, enabled),
            },
            FieldInfoData {
                name: "Filter",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryFilter",
                rust_offset: offset_of!(CoverQueryScoreBase, filter),
            },
            FieldInfoData {
                name: "XStyle",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryStyle",
                rust_offset: offset_of!(CoverQueryScoreBase, x_style),
            },
            FieldInfoData {
                name: "FromPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPosition",
                rust_offset: offset_of!(CoverQueryScoreBase, from_position),
            },
            FieldInfoData {
                name: "ToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPosition",
                rust_offset: offset_of!(CoverQueryScoreBase, to_position),
            },
            FieldInfoData {
                name: "ReferenceDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryDirection",
                rust_offset: offset_of!(CoverQueryScoreBase, reference_direction),
            },
            FieldInfoData {
                name: "SecondaryParameters",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryScoreSecondaryData",
                rust_offset: offset_of!(CoverQueryScoreBase, secondary_parameters),
            },
            FieldInfoData {
                name: "CurveXSource",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryCurveXSource",
                rust_offset: offset_of!(CoverQueryScoreBase, curve_x_source),
            },
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(CoverQueryScoreBase, x),
            },
            FieldInfoData {
                name: "Score",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(CoverQueryScoreBase, score),
            },
        ],
    }),
    array_type: Some(COVERQUERYSCOREBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQueryScoreBase {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYSCOREBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERQUERYSCOREBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverQueryScoreSecondaryData {
    pub from_position: CoverQueryPosition,
    pub to_position: CoverQueryPosition,
    pub reference_direction: CoverQueryDirection,
}

pub trait CoverQueryScoreSecondaryDataTrait: TypeObject {
    fn from_position(&self) -> &CoverQueryPosition;
    fn from_position_mut(&mut self) -> &mut CoverQueryPosition;
    fn to_position(&self) -> &CoverQueryPosition;
    fn to_position_mut(&mut self) -> &mut CoverQueryPosition;
    fn reference_direction(&self) -> &CoverQueryDirection;
    fn reference_direction_mut(&mut self) -> &mut CoverQueryDirection;
}

impl CoverQueryScoreSecondaryDataTrait for CoverQueryScoreSecondaryData {
    fn from_position(&self) -> &CoverQueryPosition {
        &self.from_position
    }
    fn from_position_mut(&mut self) -> &mut CoverQueryPosition {
        &mut self.from_position
    }
    fn to_position(&self) -> &CoverQueryPosition {
        &self.to_position
    }
    fn to_position_mut(&mut self) -> &mut CoverQueryPosition {
        &mut self.to_position
    }
    fn reference_direction(&self) -> &CoverQueryDirection {
        &self.reference_direction
    }
    fn reference_direction_mut(&mut self) -> &mut CoverQueryDirection {
        &mut self.reference_direction
    }
}

pub static COVERQUERYSCORESECONDARYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreSecondaryData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverQueryScoreSecondaryData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FromPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPosition",
                rust_offset: offset_of!(CoverQueryScoreSecondaryData, from_position),
            },
            FieldInfoData {
                name: "ToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPosition",
                rust_offset: offset_of!(CoverQueryScoreSecondaryData, to_position),
            },
            FieldInfoData {
                name: "ReferenceDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryDirection",
                rust_offset: offset_of!(CoverQueryScoreSecondaryData, reference_direction),
            },
        ],
    }),
    array_type: Some(COVERQUERYSCORESECONDARYDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverQueryScoreSecondaryData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYSCORESECONDARYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYSCORESECONDARYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreSecondaryData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreSecondaryData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverQueryDirection {
    #[default]
    CoverQueryDirection_CoverDirection = 0,
    CoverQueryDirection_WorldUpDirection = 1,
    CoverQueryDirection_ActorToHumanDirection = 2,
    CoverQueryDirection_HumanToActorDirection = 3,
    CoverQueryDirection_SquadToHumanDirection = 4,
    CoverQueryDirection_HumanToSquadDirection = 5,
    CoverQueryDirection_ActorToTargetDirection = 6,
    CoverQueryDirection_TargetToActorDirection = 7,
    CoverQueryDirection_ActorFacingDirection = 8,
    CoverQueryDirection_TargetFacingDirection = 9,
    CoverQueryDirection_ActorMoveDirection = 10,
    CoverQueryDirection_TargetMoveDirection = 11,
}

pub static COVERQUERYDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryDirection",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryDirection {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYDIRECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryDirection-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryDirection"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverQueryStyle {
    #[default]
    CoverQueryStyle_Distance = 0,
    CoverQueryStyle_ProjectedDistance = 1,
    CoverQueryStyle_Angle = 2,
    CoverQueryStyle_DistanceDelta = 3,
}

pub static COVERQUERYSTYLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryStyle",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYSTYLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryStyle {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYSTYLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYSTYLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryStyle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryStyle"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverQueryCurveXSource {
    #[default]
    CoverQueryCurveXSource_Custom = 0,
    CoverQueryCurveXSource_WeaponPreferredRange = 1,
}

pub static COVERQUERYCURVEXSOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryCurveXSource",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYCURVEXSOURCE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryCurveXSource {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYCURVEXSOURCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYCURVEXSOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryCurveXSource-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryCurveXSource"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverValidateData {
    pub _glacier_base: super::core::DataContainer,
    pub validators: Vec<Option<Arc<Mutex<dyn CoverValidationScoreDataTrait>>>>,
    pub execution_params: CoverScoreExecutionParams,
}

pub trait CoverValidateDataTrait: super::core::DataContainerTrait {
    fn validators(&self) -> &Vec<Option<Arc<Mutex<dyn CoverValidationScoreDataTrait>>>>;
    fn validators_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverValidationScoreDataTrait>>>>;
    fn execution_params(&self) -> &CoverScoreExecutionParams;
    fn execution_params_mut(&mut self) -> &mut CoverScoreExecutionParams;
}

impl CoverValidateDataTrait for CoverValidateData {
    fn validators(&self) -> &Vec<Option<Arc<Mutex<dyn CoverValidationScoreDataTrait>>>> {
        &self.validators
    }
    fn validators_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverValidationScoreDataTrait>>>> {
        &mut self.validators
    }
    fn execution_params(&self) -> &CoverScoreExecutionParams {
        &self.execution_params
    }
    fn execution_params_mut(&mut self) -> &mut CoverScoreExecutionParams {
        &mut self.execution_params
    }
}

impl super::core::DataContainerTrait for CoverValidateData {
}

pub static COVERVALIDATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidateData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverValidateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Validators",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverValidationScoreData-Array",
                rust_offset: offset_of!(CoverValidateData, validators),
            },
            FieldInfoData {
                name: "ExecutionParams",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverScoreExecutionParams",
                rust_offset: offset_of!(CoverValidateData, execution_params),
            },
        ],
    }),
    array_type: Some(COVERVALIDATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverValidateData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERVALIDATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERVALIDATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverValidateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverValidationScoreData {
    pub _glacier_base: super::core::DataContainer,
    pub scorer: Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>,
    pub active_when_moving_to_cover: bool,
    pub active_when_reached_cover: bool,
    pub active_when_target_l_k_p_lost: bool,
    pub min_time_to_invalidate: f32,
    pub invalidation_reason: CoverValidationStatus,
    pub exit_invalidated_cover: bool,
}

pub trait CoverValidationScoreDataTrait: super::core::DataContainerTrait {
    fn scorer(&self) -> &Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>;
    fn scorer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>;
    fn active_when_moving_to_cover(&self) -> &bool;
    fn active_when_moving_to_cover_mut(&mut self) -> &mut bool;
    fn active_when_reached_cover(&self) -> &bool;
    fn active_when_reached_cover_mut(&mut self) -> &mut bool;
    fn active_when_target_l_k_p_lost(&self) -> &bool;
    fn active_when_target_l_k_p_lost_mut(&mut self) -> &mut bool;
    fn min_time_to_invalidate(&self) -> &f32;
    fn min_time_to_invalidate_mut(&mut self) -> &mut f32;
    fn invalidation_reason(&self) -> &CoverValidationStatus;
    fn invalidation_reason_mut(&mut self) -> &mut CoverValidationStatus;
    fn exit_invalidated_cover(&self) -> &bool;
    fn exit_invalidated_cover_mut(&mut self) -> &mut bool;
}

impl CoverValidationScoreDataTrait for CoverValidationScoreData {
    fn scorer(&self) -> &Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>> {
        &self.scorer
    }
    fn scorer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>> {
        &mut self.scorer
    }
    fn active_when_moving_to_cover(&self) -> &bool {
        &self.active_when_moving_to_cover
    }
    fn active_when_moving_to_cover_mut(&mut self) -> &mut bool {
        &mut self.active_when_moving_to_cover
    }
    fn active_when_reached_cover(&self) -> &bool {
        &self.active_when_reached_cover
    }
    fn active_when_reached_cover_mut(&mut self) -> &mut bool {
        &mut self.active_when_reached_cover
    }
    fn active_when_target_l_k_p_lost(&self) -> &bool {
        &self.active_when_target_l_k_p_lost
    }
    fn active_when_target_l_k_p_lost_mut(&mut self) -> &mut bool {
        &mut self.active_when_target_l_k_p_lost
    }
    fn min_time_to_invalidate(&self) -> &f32 {
        &self.min_time_to_invalidate
    }
    fn min_time_to_invalidate_mut(&mut self) -> &mut f32 {
        &mut self.min_time_to_invalidate
    }
    fn invalidation_reason(&self) -> &CoverValidationStatus {
        &self.invalidation_reason
    }
    fn invalidation_reason_mut(&mut self) -> &mut CoverValidationStatus {
        &mut self.invalidation_reason
    }
    fn exit_invalidated_cover(&self) -> &bool {
        &self.exit_invalidated_cover
    }
    fn exit_invalidated_cover_mut(&mut self) -> &mut bool {
        &mut self.exit_invalidated_cover
    }
}

impl super::core::DataContainerTrait for CoverValidationScoreData {
}

pub static COVERVALIDATIONSCOREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidationScoreData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverValidationScoreData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Scorer",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverScoreDataBase",
                rust_offset: offset_of!(CoverValidationScoreData, scorer),
            },
            FieldInfoData {
                name: "ActiveWhenMovingToCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverValidationScoreData, active_when_moving_to_cover),
            },
            FieldInfoData {
                name: "ActiveWhenReachedCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverValidationScoreData, active_when_reached_cover),
            },
            FieldInfoData {
                name: "ActiveWhenTargetLKPLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverValidationScoreData, active_when_target_l_k_p_lost),
            },
            FieldInfoData {
                name: "MinTimeToInvalidate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverValidationScoreData, min_time_to_invalidate),
            },
            FieldInfoData {
                name: "InvalidationReason",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverValidationStatus",
                rust_offset: offset_of!(CoverValidationScoreData, invalidation_reason),
            },
            FieldInfoData {
                name: "ExitInvalidatedCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverValidationScoreData, exit_invalidated_cover),
            },
        ],
    }),
    array_type: Some(COVERVALIDATIONSCOREDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverValidationScoreData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERVALIDATIONSCOREDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERVALIDATIONSCOREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidationScoreData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverValidationScoreData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverValidationStatus {
    #[default]
    CoverValidationStatus_Valid = 0,
    CoverValidationStatus_Invalidated = 1,
    CoverValidationStatus_Compromised = 2,
}

pub static COVERVALIDATIONSTATUS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidationStatus",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERVALIDATIONSTATUS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverValidationStatus {
    fn type_info(&self) -> &'static TypeInfo {
        COVERVALIDATIONSTATUS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERVALIDATIONSTATUS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidationStatus-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverValidationStatus"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverSelectData {
    pub _glacier_base: super::core::DataContainer,
    pub restrict_to_defend_area: bool,
    pub spatial_filter: Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>>,
    pub include_fully_blocked_covers: bool,
    pub common_scores: Option<Arc<Mutex<dyn CoverScoreAssetTrait>>>,
    pub scores: Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>>,
    pub execution_params: CoverScoreExecutionParams,
}

pub trait CoverSelectDataTrait: super::core::DataContainerTrait {
    fn restrict_to_defend_area(&self) -> &bool;
    fn restrict_to_defend_area_mut(&mut self) -> &mut bool;
    fn spatial_filter(&self) -> &Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>>;
    fn spatial_filter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>>;
    fn include_fully_blocked_covers(&self) -> &bool;
    fn include_fully_blocked_covers_mut(&mut self) -> &mut bool;
    fn common_scores(&self) -> &Option<Arc<Mutex<dyn CoverScoreAssetTrait>>>;
    fn common_scores_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverScoreAssetTrait>>>;
    fn scores(&self) -> &Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>>;
    fn scores_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>>;
    fn execution_params(&self) -> &CoverScoreExecutionParams;
    fn execution_params_mut(&mut self) -> &mut CoverScoreExecutionParams;
}

impl CoverSelectDataTrait for CoverSelectData {
    fn restrict_to_defend_area(&self) -> &bool {
        &self.restrict_to_defend_area
    }
    fn restrict_to_defend_area_mut(&mut self) -> &mut bool {
        &mut self.restrict_to_defend_area
    }
    fn spatial_filter(&self) -> &Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>> {
        &self.spatial_filter
    }
    fn spatial_filter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQuerySpatialBaseTrait>>> {
        &mut self.spatial_filter
    }
    fn include_fully_blocked_covers(&self) -> &bool {
        &self.include_fully_blocked_covers
    }
    fn include_fully_blocked_covers_mut(&mut self) -> &mut bool {
        &mut self.include_fully_blocked_covers
    }
    fn common_scores(&self) -> &Option<Arc<Mutex<dyn CoverScoreAssetTrait>>> {
        &self.common_scores
    }
    fn common_scores_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverScoreAssetTrait>>> {
        &mut self.common_scores
    }
    fn scores(&self) -> &Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>> {
        &self.scores
    }
    fn scores_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>> {
        &mut self.scores
    }
    fn execution_params(&self) -> &CoverScoreExecutionParams {
        &self.execution_params
    }
    fn execution_params_mut(&mut self) -> &mut CoverScoreExecutionParams {
        &mut self.execution_params
    }
}

impl super::core::DataContainerTrait for CoverSelectData {
}

pub static COVERSELECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSelectData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverSelectData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RestrictToDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverSelectData, restrict_to_defend_area),
            },
            FieldInfoData {
                name: "SpatialFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQuerySpatialBase",
                rust_offset: offset_of!(CoverSelectData, spatial_filter),
            },
            FieldInfoData {
                name: "IncludeFullyBlockedCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverSelectData, include_fully_blocked_covers),
            },
            FieldInfoData {
                name: "CommonScores",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverScoreAsset",
                rust_offset: offset_of!(CoverSelectData, common_scores),
            },
            FieldInfoData {
                name: "Scores",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverScoreDataBase-Array",
                rust_offset: offset_of!(CoverSelectData, scores),
            },
            FieldInfoData {
                name: "ExecutionParams",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverScoreExecutionParams",
                rust_offset: offset_of!(CoverSelectData, execution_params),
            },
        ],
    }),
    array_type: Some(COVERSELECTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverSelectData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERSELECTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERSELECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSelectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSelectData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverScoreAsset {
    pub _glacier_base: super::core::Asset,
    pub scores: Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>>,
}

pub trait CoverScoreAssetTrait: super::core::AssetTrait {
    fn scores(&self) -> &Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>>;
    fn scores_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>>;
}

impl CoverScoreAssetTrait for CoverScoreAsset {
    fn scores(&self) -> &Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>> {
        &self.scores
    }
    fn scores_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn CoverScoreDataBaseTrait>>>> {
        &mut self.scores
    }
}

impl super::core::AssetTrait for CoverScoreAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CoverScoreAsset {
}

pub static COVERSCOREASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreAsset",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverScoreAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Scores",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverScoreDataBase-Array",
                rust_offset: offset_of!(CoverScoreAsset, scores),
            },
        ],
    }),
    array_type: Some(COVERSCOREASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverScoreAsset {
    fn type_info(&self) -> &'static TypeInfo {
        COVERSCOREASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERSCOREASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverScoreAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverScoreExecutionParams {
    pub fact_mask: u32,
    pub path_spec_type_mask: u32,
    pub path_specs: Vec<CoverPathSpec>,
    pub post_path_request_start_idx: u32,
    pub high_cost_scorer_start_idx: u32,
    pub max_score_from_high_cost_scorers: f32,
    pub has_line_of_fire_rejection: bool,
}

pub trait CoverScoreExecutionParamsTrait: TypeObject {
    fn fact_mask(&self) -> &u32;
    fn fact_mask_mut(&mut self) -> &mut u32;
    fn path_spec_type_mask(&self) -> &u32;
    fn path_spec_type_mask_mut(&mut self) -> &mut u32;
    fn path_specs(&self) -> &Vec<CoverPathSpec>;
    fn path_specs_mut(&mut self) -> &mut Vec<CoverPathSpec>;
    fn post_path_request_start_idx(&self) -> &u32;
    fn post_path_request_start_idx_mut(&mut self) -> &mut u32;
    fn high_cost_scorer_start_idx(&self) -> &u32;
    fn high_cost_scorer_start_idx_mut(&mut self) -> &mut u32;
    fn max_score_from_high_cost_scorers(&self) -> &f32;
    fn max_score_from_high_cost_scorers_mut(&mut self) -> &mut f32;
    fn has_line_of_fire_rejection(&self) -> &bool;
    fn has_line_of_fire_rejection_mut(&mut self) -> &mut bool;
}

impl CoverScoreExecutionParamsTrait for CoverScoreExecutionParams {
    fn fact_mask(&self) -> &u32 {
        &self.fact_mask
    }
    fn fact_mask_mut(&mut self) -> &mut u32 {
        &mut self.fact_mask
    }
    fn path_spec_type_mask(&self) -> &u32 {
        &self.path_spec_type_mask
    }
    fn path_spec_type_mask_mut(&mut self) -> &mut u32 {
        &mut self.path_spec_type_mask
    }
    fn path_specs(&self) -> &Vec<CoverPathSpec> {
        &self.path_specs
    }
    fn path_specs_mut(&mut self) -> &mut Vec<CoverPathSpec> {
        &mut self.path_specs
    }
    fn post_path_request_start_idx(&self) -> &u32 {
        &self.post_path_request_start_idx
    }
    fn post_path_request_start_idx_mut(&mut self) -> &mut u32 {
        &mut self.post_path_request_start_idx
    }
    fn high_cost_scorer_start_idx(&self) -> &u32 {
        &self.high_cost_scorer_start_idx
    }
    fn high_cost_scorer_start_idx_mut(&mut self) -> &mut u32 {
        &mut self.high_cost_scorer_start_idx
    }
    fn max_score_from_high_cost_scorers(&self) -> &f32 {
        &self.max_score_from_high_cost_scorers
    }
    fn max_score_from_high_cost_scorers_mut(&mut self) -> &mut f32 {
        &mut self.max_score_from_high_cost_scorers
    }
    fn has_line_of_fire_rejection(&self) -> &bool {
        &self.has_line_of_fire_rejection
    }
    fn has_line_of_fire_rejection_mut(&mut self) -> &mut bool {
        &mut self.has_line_of_fire_rejection
    }
}

pub static COVERSCOREEXECUTIONPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreExecutionParams",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverScoreExecutionParams as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FactMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CoverScoreExecutionParams, fact_mask),
            },
            FieldInfoData {
                name: "PathSpecTypeMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CoverScoreExecutionParams, path_spec_type_mask),
            },
            FieldInfoData {
                name: "PathSpecs",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverPathSpec-Array",
                rust_offset: offset_of!(CoverScoreExecutionParams, path_specs),
            },
            FieldInfoData {
                name: "PostPathRequestStartIdx",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CoverScoreExecutionParams, post_path_request_start_idx),
            },
            FieldInfoData {
                name: "HighCostScorerStartIdx",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CoverScoreExecutionParams, high_cost_scorer_start_idx),
            },
            FieldInfoData {
                name: "MaxScoreFromHighCostScorers",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverScoreExecutionParams, max_score_from_high_cost_scorers),
            },
            FieldInfoData {
                name: "HasLineOfFireRejection",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverScoreExecutionParams, has_line_of_fire_rejection),
            },
        ],
    }),
    array_type: Some(COVERSCOREEXECUTIONPARAMS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverScoreExecutionParams {
    fn type_info(&self) -> &'static TypeInfo {
        COVERSCOREEXECUTIONPARAMS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERSCOREEXECUTIONPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreExecutionParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverScoreExecutionParams"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverPathSpec {
    pub path_mode: CoverPathMode,
    pub max_search_dist: f32,
    pub precise_path: bool,
    pub store_path: bool,
}

pub trait CoverPathSpecTrait: TypeObject {
    fn path_mode(&self) -> &CoverPathMode;
    fn path_mode_mut(&mut self) -> &mut CoverPathMode;
    fn max_search_dist(&self) -> &f32;
    fn max_search_dist_mut(&mut self) -> &mut f32;
    fn precise_path(&self) -> &bool;
    fn precise_path_mut(&mut self) -> &mut bool;
    fn store_path(&self) -> &bool;
    fn store_path_mut(&mut self) -> &mut bool;
}

impl CoverPathSpecTrait for CoverPathSpec {
    fn path_mode(&self) -> &CoverPathMode {
        &self.path_mode
    }
    fn path_mode_mut(&mut self) -> &mut CoverPathMode {
        &mut self.path_mode
    }
    fn max_search_dist(&self) -> &f32 {
        &self.max_search_dist
    }
    fn max_search_dist_mut(&mut self) -> &mut f32 {
        &mut self.max_search_dist
    }
    fn precise_path(&self) -> &bool {
        &self.precise_path
    }
    fn precise_path_mut(&mut self) -> &mut bool {
        &mut self.precise_path
    }
    fn store_path(&self) -> &bool {
        &self.store_path
    }
    fn store_path_mut(&mut self) -> &mut bool {
        &mut self.store_path
    }
}

pub static COVERPATHSPEC_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPathSpec",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverPathSpec as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PathMode",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverPathMode",
                rust_offset: offset_of!(CoverPathSpec, path_mode),
            },
            FieldInfoData {
                name: "MaxSearchDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverPathSpec, max_search_dist),
            },
            FieldInfoData {
                name: "PrecisePath",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverPathSpec, precise_path),
            },
            FieldInfoData {
                name: "StorePath",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverPathSpec, store_path),
            },
        ],
    }),
    array_type: Some(COVERPATHSPEC_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverPathSpec {
    fn type_info(&self) -> &'static TypeInfo {
        COVERPATHSPEC_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERPATHSPEC_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPathSpec-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverPathSpec"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverPathMode {
    #[default]
    CoverPathMode_None = 0,
    CoverPathMode_CheckReachable = 1,
    CoverPathMode_FindPath = 2,
}

pub static COVERPATHMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPathMode",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERPATHMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverPathMode {
    fn type_info(&self) -> &'static TypeInfo {
        COVERPATHMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERPATHMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPathMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverPathMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverScoreDataBase {
    pub _glacier_base: super::core::DataContainer,
    pub id: u32,
    pub runtime_filter: u32,
}

pub trait CoverScoreDataBaseTrait: super::core::DataContainerTrait {
    fn id(&self) -> &u32;
    fn id_mut(&mut self) -> &mut u32;
    fn runtime_filter(&self) -> &u32;
    fn runtime_filter_mut(&mut self) -> &mut u32;
}

impl CoverScoreDataBaseTrait for CoverScoreDataBase {
    fn id(&self) -> &u32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut u32 {
        &mut self.id
    }
    fn runtime_filter(&self) -> &u32 {
        &self.runtime_filter
    }
    fn runtime_filter_mut(&mut self) -> &mut u32 {
        &mut self.runtime_filter
    }
}

impl super::core::DataContainerTrait for CoverScoreDataBase {
}

pub static COVERSCOREDATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreDataBase",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverScoreDataBase as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CoverScoreDataBase, id),
            },
            FieldInfoData {
                name: "RuntimeFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(CoverScoreDataBase, runtime_filter),
            },
        ],
    }),
    array_type: Some(COVERSCOREDATABASE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CoverScoreDataBase {
    fn type_info(&self) -> &'static TypeInfo {
        COVERSCOREDATABASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERSCOREDATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreDataBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverScoreDataBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverExclusionVolumeShapeData {
    pub _glacier_base: super::entity::VolumeVectorShapeData,
}

pub trait CoverExclusionVolumeShapeDataTrait: super::entity::VolumeVectorShapeDataTrait {
}

impl CoverExclusionVolumeShapeDataTrait for CoverExclusionVolumeShapeData {
}

impl super::entity::VolumeVectorShapeDataTrait for CoverExclusionVolumeShapeData {
    fn height(&self) -> &f32 {
        self._glacier_base.height()
    }
    fn height_mut(&mut self) -> &mut f32 {
        self._glacier_base.height_mut()
    }
}

impl super::entity::VectorShapeDataTrait for CoverExclusionVolumeShapeData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        self._glacier_base.points()
    }
    fn points_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        self._glacier_base.points_mut()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn tension_mut(&mut self) -> &mut f32 {
        self._glacier_base.tension_mut()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_closed_mut()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_roll_mut()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_yaw_pitch_mut()
    }
}

impl super::entity::BaseShapeDataTrait for CoverExclusionVolumeShapeData {
}

impl super::entity::BaseShapeDataBaseTrait for CoverExclusionVolumeShapeData {
}

impl super::entity::GameObjectDataTrait for CoverExclusionVolumeShapeData {
}

impl super::core::DataBusPeerTrait for CoverExclusionVolumeShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CoverExclusionVolumeShapeData {
}

impl super::core::DataContainerTrait for CoverExclusionVolumeShapeData {
}

pub static COVEREXCLUSIONVOLUMESHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverExclusionVolumeShapeData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::VOLUMEVECTORSHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverExclusionVolumeShapeData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COVEREXCLUSIONVOLUMESHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverExclusionVolumeShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        COVEREXCLUSIONVOLUMESHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVEREXCLUSIONVOLUMESHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverExclusionVolumeShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverExclusionVolumeShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverAutoGenVolumeShapeData {
    pub _glacier_base: super::entity::VolumeVectorShapeData,
    pub generate_open_covers: bool,
    pub generate_real_covers: bool,
    pub generate_ledge_covers: bool,
    pub generate_vault_over_links: bool,
    pub generate_ledge_jump_down_links: bool,
    pub open_cover_placement_step_override: f32,
    pub open_cover_voxel_erosion_distance_override: f32,
}

pub trait CoverAutoGenVolumeShapeDataTrait: super::entity::VolumeVectorShapeDataTrait {
    fn generate_open_covers(&self) -> &bool;
    fn generate_open_covers_mut(&mut self) -> &mut bool;
    fn generate_real_covers(&self) -> &bool;
    fn generate_real_covers_mut(&mut self) -> &mut bool;
    fn generate_ledge_covers(&self) -> &bool;
    fn generate_ledge_covers_mut(&mut self) -> &mut bool;
    fn generate_vault_over_links(&self) -> &bool;
    fn generate_vault_over_links_mut(&mut self) -> &mut bool;
    fn generate_ledge_jump_down_links(&self) -> &bool;
    fn generate_ledge_jump_down_links_mut(&mut self) -> &mut bool;
    fn open_cover_placement_step_override(&self) -> &f32;
    fn open_cover_placement_step_override_mut(&mut self) -> &mut f32;
    fn open_cover_voxel_erosion_distance_override(&self) -> &f32;
    fn open_cover_voxel_erosion_distance_override_mut(&mut self) -> &mut f32;
}

impl CoverAutoGenVolumeShapeDataTrait for CoverAutoGenVolumeShapeData {
    fn generate_open_covers(&self) -> &bool {
        &self.generate_open_covers
    }
    fn generate_open_covers_mut(&mut self) -> &mut bool {
        &mut self.generate_open_covers
    }
    fn generate_real_covers(&self) -> &bool {
        &self.generate_real_covers
    }
    fn generate_real_covers_mut(&mut self) -> &mut bool {
        &mut self.generate_real_covers
    }
    fn generate_ledge_covers(&self) -> &bool {
        &self.generate_ledge_covers
    }
    fn generate_ledge_covers_mut(&mut self) -> &mut bool {
        &mut self.generate_ledge_covers
    }
    fn generate_vault_over_links(&self) -> &bool {
        &self.generate_vault_over_links
    }
    fn generate_vault_over_links_mut(&mut self) -> &mut bool {
        &mut self.generate_vault_over_links
    }
    fn generate_ledge_jump_down_links(&self) -> &bool {
        &self.generate_ledge_jump_down_links
    }
    fn generate_ledge_jump_down_links_mut(&mut self) -> &mut bool {
        &mut self.generate_ledge_jump_down_links
    }
    fn open_cover_placement_step_override(&self) -> &f32 {
        &self.open_cover_placement_step_override
    }
    fn open_cover_placement_step_override_mut(&mut self) -> &mut f32 {
        &mut self.open_cover_placement_step_override
    }
    fn open_cover_voxel_erosion_distance_override(&self) -> &f32 {
        &self.open_cover_voxel_erosion_distance_override
    }
    fn open_cover_voxel_erosion_distance_override_mut(&mut self) -> &mut f32 {
        &mut self.open_cover_voxel_erosion_distance_override
    }
}

impl super::entity::VolumeVectorShapeDataTrait for CoverAutoGenVolumeShapeData {
    fn height(&self) -> &f32 {
        self._glacier_base.height()
    }
    fn height_mut(&mut self) -> &mut f32 {
        self._glacier_base.height_mut()
    }
}

impl super::entity::VectorShapeDataTrait for CoverAutoGenVolumeShapeData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        self._glacier_base.points()
    }
    fn points_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        self._glacier_base.points_mut()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn tension_mut(&mut self) -> &mut f32 {
        self._glacier_base.tension_mut()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_closed_mut()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_roll_mut()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_yaw_pitch_mut()
    }
}

impl super::entity::BaseShapeDataTrait for CoverAutoGenVolumeShapeData {
}

impl super::entity::BaseShapeDataBaseTrait for CoverAutoGenVolumeShapeData {
}

impl super::entity::GameObjectDataTrait for CoverAutoGenVolumeShapeData {
}

impl super::core::DataBusPeerTrait for CoverAutoGenVolumeShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CoverAutoGenVolumeShapeData {
}

impl super::core::DataContainerTrait for CoverAutoGenVolumeShapeData {
}

pub static COVERAUTOGENVOLUMESHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverAutoGenVolumeShapeData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::VOLUMEVECTORSHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverAutoGenVolumeShapeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GenerateOpenCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_open_covers),
            },
            FieldInfoData {
                name: "GenerateRealCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_real_covers),
            },
            FieldInfoData {
                name: "GenerateLedgeCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_ledge_covers),
            },
            FieldInfoData {
                name: "GenerateVaultOverLinks",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_vault_over_links),
            },
            FieldInfoData {
                name: "GenerateLedgeJumpDownLinks",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_ledge_jump_down_links),
            },
            FieldInfoData {
                name: "OpenCoverPlacementStepOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, open_cover_placement_step_override),
            },
            FieldInfoData {
                name: "OpenCoverVoxelErosionDistanceOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, open_cover_voxel_erosion_distance_override),
            },
        ],
    }),
    array_type: Some(COVERAUTOGENVOLUMESHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverAutoGenVolumeShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERAUTOGENVOLUMESHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERAUTOGENVOLUMESHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverAutoGenVolumeShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverAutoGenVolumeShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AICoverScoreModifierRemoveMessage {
}

pub trait AICoverScoreModifierRemoveMessageTrait: TypeObject {
}

impl AICoverScoreModifierRemoveMessageTrait for AICoverScoreModifierRemoveMessage {
}

pub static AICOVERSCOREMODIFIERREMOVEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverScoreModifierRemoveMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AICoverScoreModifierRemoveMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AICoverScoreModifierRemoveMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AICOVERSCOREMODIFIERREMOVEMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AICoverScoreModifierAddMessage {
}

pub trait AICoverScoreModifierAddMessageTrait: TypeObject {
}

impl AICoverScoreModifierAddMessageTrait for AICoverScoreModifierAddMessage {
}

pub static AICOVERSCOREMODIFIERADDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverScoreModifierAddMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AICoverScoreModifierAddMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for AICoverScoreModifierAddMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AICOVERSCOREMODIFIERADDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct CoverScoreModifierEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub score_buff: f32,
    pub sphere_radius: f32,
}

pub trait CoverScoreModifierEntityDataTrait: super::entity::EntityDataTrait {
    fn score_buff(&self) -> &f32;
    fn score_buff_mut(&mut self) -> &mut f32;
    fn sphere_radius(&self) -> &f32;
    fn sphere_radius_mut(&mut self) -> &mut f32;
}

impl CoverScoreModifierEntityDataTrait for CoverScoreModifierEntityData {
    fn score_buff(&self) -> &f32 {
        &self.score_buff
    }
    fn score_buff_mut(&mut self) -> &mut f32 {
        &mut self.score_buff
    }
    fn sphere_radius(&self) -> &f32 {
        &self.sphere_radius
    }
    fn sphere_radius_mut(&mut self) -> &mut f32 {
        &mut self.sphere_radius
    }
}

impl super::entity::EntityDataTrait for CoverScoreModifierEntityData {
}

impl super::entity::GameObjectDataTrait for CoverScoreModifierEntityData {
}

impl super::core::DataBusPeerTrait for CoverScoreModifierEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CoverScoreModifierEntityData {
}

impl super::core::DataContainerTrait for CoverScoreModifierEntityData {
}

pub static COVERSCOREMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverScoreModifierEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ScoreBuff",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverScoreModifierEntityData, score_buff),
            },
            FieldInfoData {
                name: "SphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverScoreModifierEntityData, sphere_radius),
            },
        ],
    }),
    array_type: Some(COVERSCOREMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverScoreModifierEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERSCOREMODIFIERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERSCOREMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverScoreModifierEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverGroupEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub covers: Vec<CoverData>,
}

pub trait CoverGroupEntityDataTrait: super::entity::EntityDataTrait {
    fn covers(&self) -> &Vec<CoverData>;
    fn covers_mut(&mut self) -> &mut Vec<CoverData>;
}

impl CoverGroupEntityDataTrait for CoverGroupEntityData {
    fn covers(&self) -> &Vec<CoverData> {
        &self.covers
    }
    fn covers_mut(&mut self) -> &mut Vec<CoverData> {
        &mut self.covers
    }
}

impl super::entity::EntityDataTrait for CoverGroupEntityData {
}

impl super::entity::GameObjectDataTrait for CoverGroupEntityData {
}

impl super::core::DataBusPeerTrait for CoverGroupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for CoverGroupEntityData {
}

impl super::core::DataContainerTrait for CoverGroupEntityData {
}

pub static COVERGROUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverGroupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverGroupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Covers",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverData-Array",
                rust_offset: offset_of!(CoverGroupEntityData, covers),
            },
        ],
    }),
    array_type: Some(COVERGROUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverGroupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERGROUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERGROUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverGroupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverGroupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverData {
    pub pos_and_extra0: super::core::Vec4,
    pub direction_and_extra1: super::core::Vec4,
    pub min_hover_height: f32,
    pub max_hover_height: f32,
    pub max_side_step_radius: f32,
}

pub trait CoverDataTrait: TypeObject {
    fn pos_and_extra0(&self) -> &super::core::Vec4;
    fn pos_and_extra0_mut(&mut self) -> &mut super::core::Vec4;
    fn direction_and_extra1(&self) -> &super::core::Vec4;
    fn direction_and_extra1_mut(&mut self) -> &mut super::core::Vec4;
    fn min_hover_height(&self) -> &f32;
    fn min_hover_height_mut(&mut self) -> &mut f32;
    fn max_hover_height(&self) -> &f32;
    fn max_hover_height_mut(&mut self) -> &mut f32;
    fn max_side_step_radius(&self) -> &f32;
    fn max_side_step_radius_mut(&mut self) -> &mut f32;
}

impl CoverDataTrait for CoverData {
    fn pos_and_extra0(&self) -> &super::core::Vec4 {
        &self.pos_and_extra0
    }
    fn pos_and_extra0_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.pos_and_extra0
    }
    fn direction_and_extra1(&self) -> &super::core::Vec4 {
        &self.direction_and_extra1
    }
    fn direction_and_extra1_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.direction_and_extra1
    }
    fn min_hover_height(&self) -> &f32 {
        &self.min_hover_height
    }
    fn min_hover_height_mut(&mut self) -> &mut f32 {
        &mut self.min_hover_height
    }
    fn max_hover_height(&self) -> &f32 {
        &self.max_hover_height
    }
    fn max_hover_height_mut(&mut self) -> &mut f32 {
        &mut self.max_hover_height
    }
    fn max_side_step_radius(&self) -> &f32 {
        &self.max_side_step_radius
    }
    fn max_side_step_radius_mut(&mut self) -> &mut f32 {
        &mut self.max_side_step_radius
    }
}

pub static COVERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PosAndExtra0",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(CoverData, pos_and_extra0),
            },
            FieldInfoData {
                name: "DirectionAndExtra1",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(CoverData, direction_and_extra1),
            },
            FieldInfoData {
                name: "MinHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverData, min_hover_height),
            },
            FieldInfoData {
                name: "MaxHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverData, max_hover_height),
            },
            FieldInfoData {
                name: "MaxSideStepRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverData, max_side_step_radius),
            },
        ],
    }),
    array_type: Some(COVERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CoverData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverQueryData {
    pub _glacier_base: super::core::DataContainerPolicyAsset,
    pub selection_data: Option<Arc<Mutex<dyn CoverSelectDataTrait>>>,
    pub validation_data: Option<Arc<Mutex<dyn CoverValidateDataTrait>>>,
}

pub trait CoverQueryDataTrait: super::core::DataContainerPolicyAssetTrait {
    fn selection_data(&self) -> &Option<Arc<Mutex<dyn CoverSelectDataTrait>>>;
    fn selection_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverSelectDataTrait>>>;
    fn validation_data(&self) -> &Option<Arc<Mutex<dyn CoverValidateDataTrait>>>;
    fn validation_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverValidateDataTrait>>>;
}

impl CoverQueryDataTrait for CoverQueryData {
    fn selection_data(&self) -> &Option<Arc<Mutex<dyn CoverSelectDataTrait>>> {
        &self.selection_data
    }
    fn selection_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverSelectDataTrait>>> {
        &mut self.selection_data
    }
    fn validation_data(&self) -> &Option<Arc<Mutex<dyn CoverValidateDataTrait>>> {
        &self.validation_data
    }
    fn validation_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverValidateDataTrait>>> {
        &mut self.validation_data
    }
}

impl super::core::DataContainerPolicyAssetTrait for CoverQueryData {
}

impl super::core::AssetTrait for CoverQueryData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CoverQueryData {
}

pub static COVERQUERYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINERPOLICYASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverQueryData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SelectionData",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverSelectData",
                rust_offset: offset_of!(CoverQueryData, selection_data),
            },
            FieldInfoData {
                name: "ValidationData",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverValidateData",
                rust_offset: offset_of!(CoverQueryData, validation_data),
            },
        ],
    }),
    array_type: Some(COVERQUERYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQueryData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERQUERYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverQueryPathEnemyAvoidanceData {
    pub avoid_humans: CoverQueryPathEnemyAvoidanceByTypeData,
    pub avoid_a_i: CoverQueryPathEnemyAvoidanceByTypeData,
    pub inner_zone_score: f32,
    pub outer_zone_score: f32,
    pub not_passing_avoidance_area_score: f32,
}

pub trait CoverQueryPathEnemyAvoidanceDataTrait: TypeObject {
    fn avoid_humans(&self) -> &CoverQueryPathEnemyAvoidanceByTypeData;
    fn avoid_humans_mut(&mut self) -> &mut CoverQueryPathEnemyAvoidanceByTypeData;
    fn avoid_a_i(&self) -> &CoverQueryPathEnemyAvoidanceByTypeData;
    fn avoid_a_i_mut(&mut self) -> &mut CoverQueryPathEnemyAvoidanceByTypeData;
    fn inner_zone_score(&self) -> &f32;
    fn inner_zone_score_mut(&mut self) -> &mut f32;
    fn outer_zone_score(&self) -> &f32;
    fn outer_zone_score_mut(&mut self) -> &mut f32;
    fn not_passing_avoidance_area_score(&self) -> &f32;
    fn not_passing_avoidance_area_score_mut(&mut self) -> &mut f32;
}

impl CoverQueryPathEnemyAvoidanceDataTrait for CoverQueryPathEnemyAvoidanceData {
    fn avoid_humans(&self) -> &CoverQueryPathEnemyAvoidanceByTypeData {
        &self.avoid_humans
    }
    fn avoid_humans_mut(&mut self) -> &mut CoverQueryPathEnemyAvoidanceByTypeData {
        &mut self.avoid_humans
    }
    fn avoid_a_i(&self) -> &CoverQueryPathEnemyAvoidanceByTypeData {
        &self.avoid_a_i
    }
    fn avoid_a_i_mut(&mut self) -> &mut CoverQueryPathEnemyAvoidanceByTypeData {
        &mut self.avoid_a_i
    }
    fn inner_zone_score(&self) -> &f32 {
        &self.inner_zone_score
    }
    fn inner_zone_score_mut(&mut self) -> &mut f32 {
        &mut self.inner_zone_score
    }
    fn outer_zone_score(&self) -> &f32 {
        &self.outer_zone_score
    }
    fn outer_zone_score_mut(&mut self) -> &mut f32 {
        &mut self.outer_zone_score
    }
    fn not_passing_avoidance_area_score(&self) -> &f32 {
        &self.not_passing_avoidance_area_score
    }
    fn not_passing_avoidance_area_score_mut(&mut self) -> &mut f32 {
        &mut self.not_passing_avoidance_area_score
    }
}

pub static COVERQUERYPATHENEMYAVOIDANCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathEnemyAvoidanceData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverQueryPathEnemyAvoidanceData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AvoidHumans",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPathEnemyAvoidanceByTypeData",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, avoid_humans),
            },
            FieldInfoData {
                name: "AvoidAI",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPathEnemyAvoidanceByTypeData",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, avoid_a_i),
            },
            FieldInfoData {
                name: "InnerZoneScore",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, inner_zone_score),
            },
            FieldInfoData {
                name: "OuterZoneScore",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, outer_zone_score),
            },
            FieldInfoData {
                name: "NotPassingAvoidanceAreaScore",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, not_passing_avoidance_area_score),
            },
        ],
    }),
    array_type: Some(COVERQUERYPATHENEMYAVOIDANCEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverQueryPathEnemyAvoidanceData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYPATHENEMYAVOIDANCEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYPATHENEMYAVOIDANCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathEnemyAvoidanceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPathEnemyAvoidanceData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverQueryPathEnemyAvoidanceByTypeData {
    pub avoidance_type: CoverQueryPathAvoidanceType,
    pub enabled: bool,
    pub avoidance_inner_radius: f32,
    pub avoidance_outer_radius: f32,
    pub avoidance_height: f32,
    pub look_ahead_distance: f32,
    pub check_nav_raycast: bool,
}

pub trait CoverQueryPathEnemyAvoidanceByTypeDataTrait: TypeObject {
    fn avoidance_type(&self) -> &CoverQueryPathAvoidanceType;
    fn avoidance_type_mut(&mut self) -> &mut CoverQueryPathAvoidanceType;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn avoidance_inner_radius(&self) -> &f32;
    fn avoidance_inner_radius_mut(&mut self) -> &mut f32;
    fn avoidance_outer_radius(&self) -> &f32;
    fn avoidance_outer_radius_mut(&mut self) -> &mut f32;
    fn avoidance_height(&self) -> &f32;
    fn avoidance_height_mut(&mut self) -> &mut f32;
    fn look_ahead_distance(&self) -> &f32;
    fn look_ahead_distance_mut(&mut self) -> &mut f32;
    fn check_nav_raycast(&self) -> &bool;
    fn check_nav_raycast_mut(&mut self) -> &mut bool;
}

impl CoverQueryPathEnemyAvoidanceByTypeDataTrait for CoverQueryPathEnemyAvoidanceByTypeData {
    fn avoidance_type(&self) -> &CoverQueryPathAvoidanceType {
        &self.avoidance_type
    }
    fn avoidance_type_mut(&mut self) -> &mut CoverQueryPathAvoidanceType {
        &mut self.avoidance_type
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn avoidance_inner_radius(&self) -> &f32 {
        &self.avoidance_inner_radius
    }
    fn avoidance_inner_radius_mut(&mut self) -> &mut f32 {
        &mut self.avoidance_inner_radius
    }
    fn avoidance_outer_radius(&self) -> &f32 {
        &self.avoidance_outer_radius
    }
    fn avoidance_outer_radius_mut(&mut self) -> &mut f32 {
        &mut self.avoidance_outer_radius
    }
    fn avoidance_height(&self) -> &f32 {
        &self.avoidance_height
    }
    fn avoidance_height_mut(&mut self) -> &mut f32 {
        &mut self.avoidance_height
    }
    fn look_ahead_distance(&self) -> &f32 {
        &self.look_ahead_distance
    }
    fn look_ahead_distance_mut(&mut self) -> &mut f32 {
        &mut self.look_ahead_distance
    }
    fn check_nav_raycast(&self) -> &bool {
        &self.check_nav_raycast
    }
    fn check_nav_raycast_mut(&mut self) -> &mut bool {
        &mut self.check_nav_raycast
    }
}

pub static COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathEnemyAvoidanceByTypeData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverQueryPathEnemyAvoidanceByTypeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AvoidanceType",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPathAvoidanceType",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, avoidance_type),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, enabled),
            },
            FieldInfoData {
                name: "AvoidanceInnerRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, avoidance_inner_radius),
            },
            FieldInfoData {
                name: "AvoidanceOuterRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, avoidance_outer_radius),
            },
            FieldInfoData {
                name: "AvoidanceHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, avoidance_height),
            },
            FieldInfoData {
                name: "LookAheadDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, look_ahead_distance),
            },
            FieldInfoData {
                name: "CheckNavRaycast",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, check_nav_raycast),
            },
        ],
    }),
    array_type: Some(COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverQueryPathEnemyAvoidanceByTypeData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathEnemyAvoidanceByTypeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPathEnemyAvoidanceByTypeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverQueryPathAvoidanceZone {
    #[default]
    CoverQueryPathAvoidanceZone_Inner = 0,
    CoverQueryPathAvoidanceZone_Outer = 1,
    CoverQueryPathAvoidanceZone_None = 2,
    CoverQueryPathAvoidanceZone_Count = 3,
}

pub static COVERQUERYPATHAVOIDANCEZONE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathAvoidanceZone",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYPATHAVOIDANCEZONE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryPathAvoidanceZone {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYPATHAVOIDANCEZONE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYPATHAVOIDANCEZONE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathAvoidanceZone-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPathAvoidanceZone"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverQueryPathAvoidanceType {
    #[default]
    CoverQueryPathAvoidanceType_AIEnemy = 0,
    CoverQueryPathAvoidanceType_AIFriendly = 1,
    CoverQueryPathAvoidanceType_HumanEnemy = 2,
    CoverQueryPathAvoidanceType_HumanFriendly = 3,
    CoverQueryPathAvoidanceType_CriticalThreat = 4,
    CoverQueryPathAvoidanceType_Count = 5,
}

pub static COVERQUERYPATHAVOIDANCETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathAvoidanceType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYPATHAVOIDANCETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryPathAvoidanceType {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYPATHAVOIDANCETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYPATHAVOIDANCETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathAvoidanceType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPathAvoidanceType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverQueryFilter {
    pub left_blocked: bool,
    pub left_not_blocked: bool,
    pub right_blocked: bool,
    pub right_not_blocked: bool,
    pub top_blocked: bool,
    pub top_not_blocked: bool,
    pub crouch_blocked: bool,
    pub crouch_not_blocked: bool,
    pub hover_blocked: bool,
    pub hover_not_blocked: bool,
    pub stand_covers: bool,
    pub medium_covers: bool,
    pub crouch_covers: bool,
    pub prone_covers: bool,
    pub open_covers: bool,
    pub open_directional_covers: bool,
}

pub trait CoverQueryFilterTrait: TypeObject {
    fn left_blocked(&self) -> &bool;
    fn left_blocked_mut(&mut self) -> &mut bool;
    fn left_not_blocked(&self) -> &bool;
    fn left_not_blocked_mut(&mut self) -> &mut bool;
    fn right_blocked(&self) -> &bool;
    fn right_blocked_mut(&mut self) -> &mut bool;
    fn right_not_blocked(&self) -> &bool;
    fn right_not_blocked_mut(&mut self) -> &mut bool;
    fn top_blocked(&self) -> &bool;
    fn top_blocked_mut(&mut self) -> &mut bool;
    fn top_not_blocked(&self) -> &bool;
    fn top_not_blocked_mut(&mut self) -> &mut bool;
    fn crouch_blocked(&self) -> &bool;
    fn crouch_blocked_mut(&mut self) -> &mut bool;
    fn crouch_not_blocked(&self) -> &bool;
    fn crouch_not_blocked_mut(&mut self) -> &mut bool;
    fn hover_blocked(&self) -> &bool;
    fn hover_blocked_mut(&mut self) -> &mut bool;
    fn hover_not_blocked(&self) -> &bool;
    fn hover_not_blocked_mut(&mut self) -> &mut bool;
    fn stand_covers(&self) -> &bool;
    fn stand_covers_mut(&mut self) -> &mut bool;
    fn medium_covers(&self) -> &bool;
    fn medium_covers_mut(&mut self) -> &mut bool;
    fn crouch_covers(&self) -> &bool;
    fn crouch_covers_mut(&mut self) -> &mut bool;
    fn prone_covers(&self) -> &bool;
    fn prone_covers_mut(&mut self) -> &mut bool;
    fn open_covers(&self) -> &bool;
    fn open_covers_mut(&mut self) -> &mut bool;
    fn open_directional_covers(&self) -> &bool;
    fn open_directional_covers_mut(&mut self) -> &mut bool;
}

impl CoverQueryFilterTrait for CoverQueryFilter {
    fn left_blocked(&self) -> &bool {
        &self.left_blocked
    }
    fn left_blocked_mut(&mut self) -> &mut bool {
        &mut self.left_blocked
    }
    fn left_not_blocked(&self) -> &bool {
        &self.left_not_blocked
    }
    fn left_not_blocked_mut(&mut self) -> &mut bool {
        &mut self.left_not_blocked
    }
    fn right_blocked(&self) -> &bool {
        &self.right_blocked
    }
    fn right_blocked_mut(&mut self) -> &mut bool {
        &mut self.right_blocked
    }
    fn right_not_blocked(&self) -> &bool {
        &self.right_not_blocked
    }
    fn right_not_blocked_mut(&mut self) -> &mut bool {
        &mut self.right_not_blocked
    }
    fn top_blocked(&self) -> &bool {
        &self.top_blocked
    }
    fn top_blocked_mut(&mut self) -> &mut bool {
        &mut self.top_blocked
    }
    fn top_not_blocked(&self) -> &bool {
        &self.top_not_blocked
    }
    fn top_not_blocked_mut(&mut self) -> &mut bool {
        &mut self.top_not_blocked
    }
    fn crouch_blocked(&self) -> &bool {
        &self.crouch_blocked
    }
    fn crouch_blocked_mut(&mut self) -> &mut bool {
        &mut self.crouch_blocked
    }
    fn crouch_not_blocked(&self) -> &bool {
        &self.crouch_not_blocked
    }
    fn crouch_not_blocked_mut(&mut self) -> &mut bool {
        &mut self.crouch_not_blocked
    }
    fn hover_blocked(&self) -> &bool {
        &self.hover_blocked
    }
    fn hover_blocked_mut(&mut self) -> &mut bool {
        &mut self.hover_blocked
    }
    fn hover_not_blocked(&self) -> &bool {
        &self.hover_not_blocked
    }
    fn hover_not_blocked_mut(&mut self) -> &mut bool {
        &mut self.hover_not_blocked
    }
    fn stand_covers(&self) -> &bool {
        &self.stand_covers
    }
    fn stand_covers_mut(&mut self) -> &mut bool {
        &mut self.stand_covers
    }
    fn medium_covers(&self) -> &bool {
        &self.medium_covers
    }
    fn medium_covers_mut(&mut self) -> &mut bool {
        &mut self.medium_covers
    }
    fn crouch_covers(&self) -> &bool {
        &self.crouch_covers
    }
    fn crouch_covers_mut(&mut self) -> &mut bool {
        &mut self.crouch_covers
    }
    fn prone_covers(&self) -> &bool {
        &self.prone_covers
    }
    fn prone_covers_mut(&mut self) -> &mut bool {
        &mut self.prone_covers
    }
    fn open_covers(&self) -> &bool {
        &self.open_covers
    }
    fn open_covers_mut(&mut self) -> &mut bool {
        &mut self.open_covers
    }
    fn open_directional_covers(&self) -> &bool {
        &self.open_directional_covers
    }
    fn open_directional_covers_mut(&mut self) -> &mut bool {
        &mut self.open_directional_covers
    }
}

pub static COVERQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryFilter",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverQueryFilter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LeftBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, left_blocked),
            },
            FieldInfoData {
                name: "LeftNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, left_not_blocked),
            },
            FieldInfoData {
                name: "RightBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, right_blocked),
            },
            FieldInfoData {
                name: "RightNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, right_not_blocked),
            },
            FieldInfoData {
                name: "TopBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, top_blocked),
            },
            FieldInfoData {
                name: "TopNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, top_not_blocked),
            },
            FieldInfoData {
                name: "CrouchBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, crouch_blocked),
            },
            FieldInfoData {
                name: "CrouchNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, crouch_not_blocked),
            },
            FieldInfoData {
                name: "HoverBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, hover_blocked),
            },
            FieldInfoData {
                name: "HoverNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, hover_not_blocked),
            },
            FieldInfoData {
                name: "StandCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, stand_covers),
            },
            FieldInfoData {
                name: "MediumCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, medium_covers),
            },
            FieldInfoData {
                name: "CrouchCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, crouch_covers),
            },
            FieldInfoData {
                name: "ProneCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, prone_covers),
            },
            FieldInfoData {
                name: "OpenCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, open_covers),
            },
            FieldInfoData {
                name: "OpenDirectionalCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverQueryFilter, open_directional_covers),
            },
        ],
    }),
    array_type: Some(COVERQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryFilter {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FilterCoversByWeaponRange {
    pub _glacier_base: CoverQuerySpatialBase,
    pub target: CoverQueryPosition,
    pub height_tolerance: f32,
}

pub trait FilterCoversByWeaponRangeTrait: CoverQuerySpatialBaseTrait {
    fn target(&self) -> &CoverQueryPosition;
    fn target_mut(&mut self) -> &mut CoverQueryPosition;
    fn height_tolerance(&self) -> &f32;
    fn height_tolerance_mut(&mut self) -> &mut f32;
}

impl FilterCoversByWeaponRangeTrait for FilterCoversByWeaponRange {
    fn target(&self) -> &CoverQueryPosition {
        &self.target
    }
    fn target_mut(&mut self) -> &mut CoverQueryPosition {
        &mut self.target
    }
    fn height_tolerance(&self) -> &f32 {
        &self.height_tolerance
    }
    fn height_tolerance_mut(&mut self) -> &mut f32 {
        &mut self.height_tolerance
    }
}

impl CoverQuerySpatialBaseTrait for FilterCoversByWeaponRange {
}

impl super::core::DataContainerTrait for FilterCoversByWeaponRange {
}

pub static FILTERCOVERSBYWEAPONRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByWeaponRange",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COVERQUERYSPATIALBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FilterCoversByWeaponRange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPosition",
                rust_offset: offset_of!(FilterCoversByWeaponRange, target),
            },
            FieldInfoData {
                name: "HeightTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilterCoversByWeaponRange, height_tolerance),
            },
        ],
    }),
    array_type: Some(FILTERCOVERSBYWEAPONRANGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FilterCoversByWeaponRange {
    fn type_info(&self) -> &'static TypeInfo {
        FILTERCOVERSBYWEAPONRANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FILTERCOVERSBYWEAPONRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByWeaponRange-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FilterCoversByWeaponRange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FilterCoversByDefendArea {
    pub _glacier_base: CoverQuerySpatialBase,
    pub reference: CoverQueryPosition,
}

pub trait FilterCoversByDefendAreaTrait: CoverQuerySpatialBaseTrait {
    fn reference(&self) -> &CoverQueryPosition;
    fn reference_mut(&mut self) -> &mut CoverQueryPosition;
}

impl FilterCoversByDefendAreaTrait for FilterCoversByDefendArea {
    fn reference(&self) -> &CoverQueryPosition {
        &self.reference
    }
    fn reference_mut(&mut self) -> &mut CoverQueryPosition {
        &mut self.reference
    }
}

impl CoverQuerySpatialBaseTrait for FilterCoversByDefendArea {
}

impl super::core::DataContainerTrait for FilterCoversByDefendArea {
}

pub static FILTERCOVERSBYDEFENDAREA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByDefendArea",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COVERQUERYSPATIALBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FilterCoversByDefendArea as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Reference",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPosition",
                rust_offset: offset_of!(FilterCoversByDefendArea, reference),
            },
        ],
    }),
    array_type: Some(FILTERCOVERSBYDEFENDAREA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FilterCoversByDefendArea {
    fn type_info(&self) -> &'static TypeInfo {
        FILTERCOVERSBYDEFENDAREA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FILTERCOVERSBYDEFENDAREA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByDefendArea-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FilterCoversByDefendArea"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FilterCoversByRadius {
    pub _glacier_base: CoverQuerySpatialBase,
    pub center: CoverQueryPosition,
    pub radius: f32,
    pub height_tolerance: f32,
}

pub trait FilterCoversByRadiusTrait: CoverQuerySpatialBaseTrait {
    fn center(&self) -> &CoverQueryPosition;
    fn center_mut(&mut self) -> &mut CoverQueryPosition;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn height_tolerance(&self) -> &f32;
    fn height_tolerance_mut(&mut self) -> &mut f32;
}

impl FilterCoversByRadiusTrait for FilterCoversByRadius {
    fn center(&self) -> &CoverQueryPosition {
        &self.center
    }
    fn center_mut(&mut self) -> &mut CoverQueryPosition {
        &mut self.center
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn height_tolerance(&self) -> &f32 {
        &self.height_tolerance
    }
    fn height_tolerance_mut(&mut self) -> &mut f32 {
        &mut self.height_tolerance
    }
}

impl CoverQuerySpatialBaseTrait for FilterCoversByRadius {
}

impl super::core::DataContainerTrait for FilterCoversByRadius {
}

pub static FILTERCOVERSBYRADIUS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByRadius",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COVERQUERYSPATIALBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FilterCoversByRadius as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryPosition",
                rust_offset: offset_of!(FilterCoversByRadius, center),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilterCoversByRadius, radius),
            },
            FieldInfoData {
                name: "HeightTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FilterCoversByRadius, height_tolerance),
            },
        ],
    }),
    array_type: Some(FILTERCOVERSBYRADIUS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FilterCoversByRadius {
    fn type_info(&self) -> &'static TypeInfo {
        FILTERCOVERSBYRADIUS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FILTERCOVERSBYRADIUS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByRadius-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FilterCoversByRadius"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverQuerySpatialBase {
    pub _glacier_base: super::core::DataContainer,
}

pub trait CoverQuerySpatialBaseTrait: super::core::DataContainerTrait {
}

impl CoverQuerySpatialBaseTrait for CoverQuerySpatialBase {
}

impl super::core::DataContainerTrait for CoverQuerySpatialBase {
}

pub static COVERQUERYSPATIALBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQuerySpatialBase",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverQuerySpatialBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(COVERQUERYSPATIALBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQuerySpatialBase {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYSPATIALBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERQUERYSPATIALBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQuerySpatialBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQuerySpatialBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverQueryPosition {
    #[default]
    CoverQueryPosition_ActorPosition = 0,
    CoverQueryPosition_CoverPosition = 1,
    CoverQueryPosition_SquadPosition = 2,
    CoverQueryPosition_HumanPosition = 3,
    CoverQueryPosition_FollowObjectPosition = 4,
    CoverQueryPosition_TargetPosition = 5,
    CoverQueryPosition_Count = 6,
}

pub static COVERQUERYPOSITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPosition",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYPOSITION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryPosition {
    fn type_info(&self) -> &'static TypeInfo {
        COVERQUERYPOSITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERQUERYPOSITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPosition-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPosition"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverConstantData {
    pub _glacier_base: super::core::Asset,
    pub slot_size: f32,
    pub slot_spacing: f32,
    pub slot_edge_distance: f32,
    pub slot_blocked_edge_distance: f32,
    pub minimum_protected_cover_width: f32,
    pub prone_allow_fire_height: f32,
    pub open_allow_fire_height: f32,
    pub crouch_height: f32,
    pub crouch_allow_fire_height: f32,
    pub medium_height: f32,
    pub medium_allow_fire_height: f32,
    pub stand_height: f32,
    pub fire_height_prone: f32,
    pub fire_height_open: f32,
    pub fire_height_crouch: f32,
    pub fire_height_medium: f32,
    pub fire_height_standing: f32,
    pub min_free_shoot_dist: f32,
    pub fire_step_out_dist: f32,
    pub max_fire_side_test_angle: f32,
    pub fire_side_sample_count: i32,
    pub pathfinding_reference_layer: i32,
    pub terrain_height_sampling_step: f32,
    pub chunk_size: f32,
    pub voxel_size: f32,
    pub voxel_height: f32,
    pub voxel_span_merge_threshold: i32,
    pub voxel_span_merging_max_separation: i32,
    pub max_step_height_override: f32,
    pub min_island_surface_area_extra: f32,
    pub contour_simplification_max_area_delta: f32,
    pub contour_simplification_x_z_error_in: f32,
    pub contour_simplification_x_z_error_out: f32,
    pub contour_simplification_y_error: f32,
    pub open_cover_min_spacing_dist: f32,
    pub open_cover_voxel_sampling_step: i32,
    pub open_cover_voxel_erosion_distance: f32,
    pub open_cover_min_dist_to_manual_cover: f32,
    pub min_hover_clearance: f32,
    pub hovering_min_dist_to_ceiling: f32,
    pub max_real_cover_contour_slope: f32,
    pub edge_probe_sample_spacing: f32,
    pub crouch_cover_occlusion_settings: ProtectiveCoverWallOcclusionSettings,
    pub stand_cover_occlusion_settings: ProtectiveCoverWallOcclusionSettings,
    pub free_shoot_height_range: f32,
    pub generate_fully_blocked_covers: bool,
    pub fully_blocked_cover_max_dist_from_valid_cover: f32,
    pub ledge_forward_clearance_dist: f32,
    pub ledge_downward_clearance_dist: f32,
    pub ledge_downward_clearance_test_range: f32,
    pub ledge_cover_placement_start_dist_on_edge: f32,
    pub ledge_cover_placement_step: f32,
    pub ledge_cover_placement_dist_from_ledge: f32,
    pub vault_over_path_link_config: VaultOverPathLinkConfig,
    pub ledge_jump_down_path_link_config: LedgeJumpDownPathLinkConfig,
    pub max_covers_in_memory: i32,
    pub cover_zones: Option<Arc<Mutex<dyn CoverZonesTrait>>>,
}

pub trait CoverConstantDataTrait: super::core::AssetTrait {
    fn slot_size(&self) -> &f32;
    fn slot_size_mut(&mut self) -> &mut f32;
    fn slot_spacing(&self) -> &f32;
    fn slot_spacing_mut(&mut self) -> &mut f32;
    fn slot_edge_distance(&self) -> &f32;
    fn slot_edge_distance_mut(&mut self) -> &mut f32;
    fn slot_blocked_edge_distance(&self) -> &f32;
    fn slot_blocked_edge_distance_mut(&mut self) -> &mut f32;
    fn minimum_protected_cover_width(&self) -> &f32;
    fn minimum_protected_cover_width_mut(&mut self) -> &mut f32;
    fn prone_allow_fire_height(&self) -> &f32;
    fn prone_allow_fire_height_mut(&mut self) -> &mut f32;
    fn open_allow_fire_height(&self) -> &f32;
    fn open_allow_fire_height_mut(&mut self) -> &mut f32;
    fn crouch_height(&self) -> &f32;
    fn crouch_height_mut(&mut self) -> &mut f32;
    fn crouch_allow_fire_height(&self) -> &f32;
    fn crouch_allow_fire_height_mut(&mut self) -> &mut f32;
    fn medium_height(&self) -> &f32;
    fn medium_height_mut(&mut self) -> &mut f32;
    fn medium_allow_fire_height(&self) -> &f32;
    fn medium_allow_fire_height_mut(&mut self) -> &mut f32;
    fn stand_height(&self) -> &f32;
    fn stand_height_mut(&mut self) -> &mut f32;
    fn fire_height_prone(&self) -> &f32;
    fn fire_height_prone_mut(&mut self) -> &mut f32;
    fn fire_height_open(&self) -> &f32;
    fn fire_height_open_mut(&mut self) -> &mut f32;
    fn fire_height_crouch(&self) -> &f32;
    fn fire_height_crouch_mut(&mut self) -> &mut f32;
    fn fire_height_medium(&self) -> &f32;
    fn fire_height_medium_mut(&mut self) -> &mut f32;
    fn fire_height_standing(&self) -> &f32;
    fn fire_height_standing_mut(&mut self) -> &mut f32;
    fn min_free_shoot_dist(&self) -> &f32;
    fn min_free_shoot_dist_mut(&mut self) -> &mut f32;
    fn fire_step_out_dist(&self) -> &f32;
    fn fire_step_out_dist_mut(&mut self) -> &mut f32;
    fn max_fire_side_test_angle(&self) -> &f32;
    fn max_fire_side_test_angle_mut(&mut self) -> &mut f32;
    fn fire_side_sample_count(&self) -> &i32;
    fn fire_side_sample_count_mut(&mut self) -> &mut i32;
    fn pathfinding_reference_layer(&self) -> &i32;
    fn pathfinding_reference_layer_mut(&mut self) -> &mut i32;
    fn terrain_height_sampling_step(&self) -> &f32;
    fn terrain_height_sampling_step_mut(&mut self) -> &mut f32;
    fn chunk_size(&self) -> &f32;
    fn chunk_size_mut(&mut self) -> &mut f32;
    fn voxel_size(&self) -> &f32;
    fn voxel_size_mut(&mut self) -> &mut f32;
    fn voxel_height(&self) -> &f32;
    fn voxel_height_mut(&mut self) -> &mut f32;
    fn voxel_span_merge_threshold(&self) -> &i32;
    fn voxel_span_merge_threshold_mut(&mut self) -> &mut i32;
    fn voxel_span_merging_max_separation(&self) -> &i32;
    fn voxel_span_merging_max_separation_mut(&mut self) -> &mut i32;
    fn max_step_height_override(&self) -> &f32;
    fn max_step_height_override_mut(&mut self) -> &mut f32;
    fn min_island_surface_area_extra(&self) -> &f32;
    fn min_island_surface_area_extra_mut(&mut self) -> &mut f32;
    fn contour_simplification_max_area_delta(&self) -> &f32;
    fn contour_simplification_max_area_delta_mut(&mut self) -> &mut f32;
    fn contour_simplification_x_z_error_in(&self) -> &f32;
    fn contour_simplification_x_z_error_in_mut(&mut self) -> &mut f32;
    fn contour_simplification_x_z_error_out(&self) -> &f32;
    fn contour_simplification_x_z_error_out_mut(&mut self) -> &mut f32;
    fn contour_simplification_y_error(&self) -> &f32;
    fn contour_simplification_y_error_mut(&mut self) -> &mut f32;
    fn open_cover_min_spacing_dist(&self) -> &f32;
    fn open_cover_min_spacing_dist_mut(&mut self) -> &mut f32;
    fn open_cover_voxel_sampling_step(&self) -> &i32;
    fn open_cover_voxel_sampling_step_mut(&mut self) -> &mut i32;
    fn open_cover_voxel_erosion_distance(&self) -> &f32;
    fn open_cover_voxel_erosion_distance_mut(&mut self) -> &mut f32;
    fn open_cover_min_dist_to_manual_cover(&self) -> &f32;
    fn open_cover_min_dist_to_manual_cover_mut(&mut self) -> &mut f32;
    fn min_hover_clearance(&self) -> &f32;
    fn min_hover_clearance_mut(&mut self) -> &mut f32;
    fn hovering_min_dist_to_ceiling(&self) -> &f32;
    fn hovering_min_dist_to_ceiling_mut(&mut self) -> &mut f32;
    fn max_real_cover_contour_slope(&self) -> &f32;
    fn max_real_cover_contour_slope_mut(&mut self) -> &mut f32;
    fn edge_probe_sample_spacing(&self) -> &f32;
    fn edge_probe_sample_spacing_mut(&mut self) -> &mut f32;
    fn crouch_cover_occlusion_settings(&self) -> &ProtectiveCoverWallOcclusionSettings;
    fn crouch_cover_occlusion_settings_mut(&mut self) -> &mut ProtectiveCoverWallOcclusionSettings;
    fn stand_cover_occlusion_settings(&self) -> &ProtectiveCoverWallOcclusionSettings;
    fn stand_cover_occlusion_settings_mut(&mut self) -> &mut ProtectiveCoverWallOcclusionSettings;
    fn free_shoot_height_range(&self) -> &f32;
    fn free_shoot_height_range_mut(&mut self) -> &mut f32;
    fn generate_fully_blocked_covers(&self) -> &bool;
    fn generate_fully_blocked_covers_mut(&mut self) -> &mut bool;
    fn fully_blocked_cover_max_dist_from_valid_cover(&self) -> &f32;
    fn fully_blocked_cover_max_dist_from_valid_cover_mut(&mut self) -> &mut f32;
    fn ledge_forward_clearance_dist(&self) -> &f32;
    fn ledge_forward_clearance_dist_mut(&mut self) -> &mut f32;
    fn ledge_downward_clearance_dist(&self) -> &f32;
    fn ledge_downward_clearance_dist_mut(&mut self) -> &mut f32;
    fn ledge_downward_clearance_test_range(&self) -> &f32;
    fn ledge_downward_clearance_test_range_mut(&mut self) -> &mut f32;
    fn ledge_cover_placement_start_dist_on_edge(&self) -> &f32;
    fn ledge_cover_placement_start_dist_on_edge_mut(&mut self) -> &mut f32;
    fn ledge_cover_placement_step(&self) -> &f32;
    fn ledge_cover_placement_step_mut(&mut self) -> &mut f32;
    fn ledge_cover_placement_dist_from_ledge(&self) -> &f32;
    fn ledge_cover_placement_dist_from_ledge_mut(&mut self) -> &mut f32;
    fn vault_over_path_link_config(&self) -> &VaultOverPathLinkConfig;
    fn vault_over_path_link_config_mut(&mut self) -> &mut VaultOverPathLinkConfig;
    fn ledge_jump_down_path_link_config(&self) -> &LedgeJumpDownPathLinkConfig;
    fn ledge_jump_down_path_link_config_mut(&mut self) -> &mut LedgeJumpDownPathLinkConfig;
    fn max_covers_in_memory(&self) -> &i32;
    fn max_covers_in_memory_mut(&mut self) -> &mut i32;
    fn cover_zones(&self) -> &Option<Arc<Mutex<dyn CoverZonesTrait>>>;
    fn cover_zones_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZonesTrait>>>;
}

impl CoverConstantDataTrait for CoverConstantData {
    fn slot_size(&self) -> &f32 {
        &self.slot_size
    }
    fn slot_size_mut(&mut self) -> &mut f32 {
        &mut self.slot_size
    }
    fn slot_spacing(&self) -> &f32 {
        &self.slot_spacing
    }
    fn slot_spacing_mut(&mut self) -> &mut f32 {
        &mut self.slot_spacing
    }
    fn slot_edge_distance(&self) -> &f32 {
        &self.slot_edge_distance
    }
    fn slot_edge_distance_mut(&mut self) -> &mut f32 {
        &mut self.slot_edge_distance
    }
    fn slot_blocked_edge_distance(&self) -> &f32 {
        &self.slot_blocked_edge_distance
    }
    fn slot_blocked_edge_distance_mut(&mut self) -> &mut f32 {
        &mut self.slot_blocked_edge_distance
    }
    fn minimum_protected_cover_width(&self) -> &f32 {
        &self.minimum_protected_cover_width
    }
    fn minimum_protected_cover_width_mut(&mut self) -> &mut f32 {
        &mut self.minimum_protected_cover_width
    }
    fn prone_allow_fire_height(&self) -> &f32 {
        &self.prone_allow_fire_height
    }
    fn prone_allow_fire_height_mut(&mut self) -> &mut f32 {
        &mut self.prone_allow_fire_height
    }
    fn open_allow_fire_height(&self) -> &f32 {
        &self.open_allow_fire_height
    }
    fn open_allow_fire_height_mut(&mut self) -> &mut f32 {
        &mut self.open_allow_fire_height
    }
    fn crouch_height(&self) -> &f32 {
        &self.crouch_height
    }
    fn crouch_height_mut(&mut self) -> &mut f32 {
        &mut self.crouch_height
    }
    fn crouch_allow_fire_height(&self) -> &f32 {
        &self.crouch_allow_fire_height
    }
    fn crouch_allow_fire_height_mut(&mut self) -> &mut f32 {
        &mut self.crouch_allow_fire_height
    }
    fn medium_height(&self) -> &f32 {
        &self.medium_height
    }
    fn medium_height_mut(&mut self) -> &mut f32 {
        &mut self.medium_height
    }
    fn medium_allow_fire_height(&self) -> &f32 {
        &self.medium_allow_fire_height
    }
    fn medium_allow_fire_height_mut(&mut self) -> &mut f32 {
        &mut self.medium_allow_fire_height
    }
    fn stand_height(&self) -> &f32 {
        &self.stand_height
    }
    fn stand_height_mut(&mut self) -> &mut f32 {
        &mut self.stand_height
    }
    fn fire_height_prone(&self) -> &f32 {
        &self.fire_height_prone
    }
    fn fire_height_prone_mut(&mut self) -> &mut f32 {
        &mut self.fire_height_prone
    }
    fn fire_height_open(&self) -> &f32 {
        &self.fire_height_open
    }
    fn fire_height_open_mut(&mut self) -> &mut f32 {
        &mut self.fire_height_open
    }
    fn fire_height_crouch(&self) -> &f32 {
        &self.fire_height_crouch
    }
    fn fire_height_crouch_mut(&mut self) -> &mut f32 {
        &mut self.fire_height_crouch
    }
    fn fire_height_medium(&self) -> &f32 {
        &self.fire_height_medium
    }
    fn fire_height_medium_mut(&mut self) -> &mut f32 {
        &mut self.fire_height_medium
    }
    fn fire_height_standing(&self) -> &f32 {
        &self.fire_height_standing
    }
    fn fire_height_standing_mut(&mut self) -> &mut f32 {
        &mut self.fire_height_standing
    }
    fn min_free_shoot_dist(&self) -> &f32 {
        &self.min_free_shoot_dist
    }
    fn min_free_shoot_dist_mut(&mut self) -> &mut f32 {
        &mut self.min_free_shoot_dist
    }
    fn fire_step_out_dist(&self) -> &f32 {
        &self.fire_step_out_dist
    }
    fn fire_step_out_dist_mut(&mut self) -> &mut f32 {
        &mut self.fire_step_out_dist
    }
    fn max_fire_side_test_angle(&self) -> &f32 {
        &self.max_fire_side_test_angle
    }
    fn max_fire_side_test_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_fire_side_test_angle
    }
    fn fire_side_sample_count(&self) -> &i32 {
        &self.fire_side_sample_count
    }
    fn fire_side_sample_count_mut(&mut self) -> &mut i32 {
        &mut self.fire_side_sample_count
    }
    fn pathfinding_reference_layer(&self) -> &i32 {
        &self.pathfinding_reference_layer
    }
    fn pathfinding_reference_layer_mut(&mut self) -> &mut i32 {
        &mut self.pathfinding_reference_layer
    }
    fn terrain_height_sampling_step(&self) -> &f32 {
        &self.terrain_height_sampling_step
    }
    fn terrain_height_sampling_step_mut(&mut self) -> &mut f32 {
        &mut self.terrain_height_sampling_step
    }
    fn chunk_size(&self) -> &f32 {
        &self.chunk_size
    }
    fn chunk_size_mut(&mut self) -> &mut f32 {
        &mut self.chunk_size
    }
    fn voxel_size(&self) -> &f32 {
        &self.voxel_size
    }
    fn voxel_size_mut(&mut self) -> &mut f32 {
        &mut self.voxel_size
    }
    fn voxel_height(&self) -> &f32 {
        &self.voxel_height
    }
    fn voxel_height_mut(&mut self) -> &mut f32 {
        &mut self.voxel_height
    }
    fn voxel_span_merge_threshold(&self) -> &i32 {
        &self.voxel_span_merge_threshold
    }
    fn voxel_span_merge_threshold_mut(&mut self) -> &mut i32 {
        &mut self.voxel_span_merge_threshold
    }
    fn voxel_span_merging_max_separation(&self) -> &i32 {
        &self.voxel_span_merging_max_separation
    }
    fn voxel_span_merging_max_separation_mut(&mut self) -> &mut i32 {
        &mut self.voxel_span_merging_max_separation
    }
    fn max_step_height_override(&self) -> &f32 {
        &self.max_step_height_override
    }
    fn max_step_height_override_mut(&mut self) -> &mut f32 {
        &mut self.max_step_height_override
    }
    fn min_island_surface_area_extra(&self) -> &f32 {
        &self.min_island_surface_area_extra
    }
    fn min_island_surface_area_extra_mut(&mut self) -> &mut f32 {
        &mut self.min_island_surface_area_extra
    }
    fn contour_simplification_max_area_delta(&self) -> &f32 {
        &self.contour_simplification_max_area_delta
    }
    fn contour_simplification_max_area_delta_mut(&mut self) -> &mut f32 {
        &mut self.contour_simplification_max_area_delta
    }
    fn contour_simplification_x_z_error_in(&self) -> &f32 {
        &self.contour_simplification_x_z_error_in
    }
    fn contour_simplification_x_z_error_in_mut(&mut self) -> &mut f32 {
        &mut self.contour_simplification_x_z_error_in
    }
    fn contour_simplification_x_z_error_out(&self) -> &f32 {
        &self.contour_simplification_x_z_error_out
    }
    fn contour_simplification_x_z_error_out_mut(&mut self) -> &mut f32 {
        &mut self.contour_simplification_x_z_error_out
    }
    fn contour_simplification_y_error(&self) -> &f32 {
        &self.contour_simplification_y_error
    }
    fn contour_simplification_y_error_mut(&mut self) -> &mut f32 {
        &mut self.contour_simplification_y_error
    }
    fn open_cover_min_spacing_dist(&self) -> &f32 {
        &self.open_cover_min_spacing_dist
    }
    fn open_cover_min_spacing_dist_mut(&mut self) -> &mut f32 {
        &mut self.open_cover_min_spacing_dist
    }
    fn open_cover_voxel_sampling_step(&self) -> &i32 {
        &self.open_cover_voxel_sampling_step
    }
    fn open_cover_voxel_sampling_step_mut(&mut self) -> &mut i32 {
        &mut self.open_cover_voxel_sampling_step
    }
    fn open_cover_voxel_erosion_distance(&self) -> &f32 {
        &self.open_cover_voxel_erosion_distance
    }
    fn open_cover_voxel_erosion_distance_mut(&mut self) -> &mut f32 {
        &mut self.open_cover_voxel_erosion_distance
    }
    fn open_cover_min_dist_to_manual_cover(&self) -> &f32 {
        &self.open_cover_min_dist_to_manual_cover
    }
    fn open_cover_min_dist_to_manual_cover_mut(&mut self) -> &mut f32 {
        &mut self.open_cover_min_dist_to_manual_cover
    }
    fn min_hover_clearance(&self) -> &f32 {
        &self.min_hover_clearance
    }
    fn min_hover_clearance_mut(&mut self) -> &mut f32 {
        &mut self.min_hover_clearance
    }
    fn hovering_min_dist_to_ceiling(&self) -> &f32 {
        &self.hovering_min_dist_to_ceiling
    }
    fn hovering_min_dist_to_ceiling_mut(&mut self) -> &mut f32 {
        &mut self.hovering_min_dist_to_ceiling
    }
    fn max_real_cover_contour_slope(&self) -> &f32 {
        &self.max_real_cover_contour_slope
    }
    fn max_real_cover_contour_slope_mut(&mut self) -> &mut f32 {
        &mut self.max_real_cover_contour_slope
    }
    fn edge_probe_sample_spacing(&self) -> &f32 {
        &self.edge_probe_sample_spacing
    }
    fn edge_probe_sample_spacing_mut(&mut self) -> &mut f32 {
        &mut self.edge_probe_sample_spacing
    }
    fn crouch_cover_occlusion_settings(&self) -> &ProtectiveCoverWallOcclusionSettings {
        &self.crouch_cover_occlusion_settings
    }
    fn crouch_cover_occlusion_settings_mut(&mut self) -> &mut ProtectiveCoverWallOcclusionSettings {
        &mut self.crouch_cover_occlusion_settings
    }
    fn stand_cover_occlusion_settings(&self) -> &ProtectiveCoverWallOcclusionSettings {
        &self.stand_cover_occlusion_settings
    }
    fn stand_cover_occlusion_settings_mut(&mut self) -> &mut ProtectiveCoverWallOcclusionSettings {
        &mut self.stand_cover_occlusion_settings
    }
    fn free_shoot_height_range(&self) -> &f32 {
        &self.free_shoot_height_range
    }
    fn free_shoot_height_range_mut(&mut self) -> &mut f32 {
        &mut self.free_shoot_height_range
    }
    fn generate_fully_blocked_covers(&self) -> &bool {
        &self.generate_fully_blocked_covers
    }
    fn generate_fully_blocked_covers_mut(&mut self) -> &mut bool {
        &mut self.generate_fully_blocked_covers
    }
    fn fully_blocked_cover_max_dist_from_valid_cover(&self) -> &f32 {
        &self.fully_blocked_cover_max_dist_from_valid_cover
    }
    fn fully_blocked_cover_max_dist_from_valid_cover_mut(&mut self) -> &mut f32 {
        &mut self.fully_blocked_cover_max_dist_from_valid_cover
    }
    fn ledge_forward_clearance_dist(&self) -> &f32 {
        &self.ledge_forward_clearance_dist
    }
    fn ledge_forward_clearance_dist_mut(&mut self) -> &mut f32 {
        &mut self.ledge_forward_clearance_dist
    }
    fn ledge_downward_clearance_dist(&self) -> &f32 {
        &self.ledge_downward_clearance_dist
    }
    fn ledge_downward_clearance_dist_mut(&mut self) -> &mut f32 {
        &mut self.ledge_downward_clearance_dist
    }
    fn ledge_downward_clearance_test_range(&self) -> &f32 {
        &self.ledge_downward_clearance_test_range
    }
    fn ledge_downward_clearance_test_range_mut(&mut self) -> &mut f32 {
        &mut self.ledge_downward_clearance_test_range
    }
    fn ledge_cover_placement_start_dist_on_edge(&self) -> &f32 {
        &self.ledge_cover_placement_start_dist_on_edge
    }
    fn ledge_cover_placement_start_dist_on_edge_mut(&mut self) -> &mut f32 {
        &mut self.ledge_cover_placement_start_dist_on_edge
    }
    fn ledge_cover_placement_step(&self) -> &f32 {
        &self.ledge_cover_placement_step
    }
    fn ledge_cover_placement_step_mut(&mut self) -> &mut f32 {
        &mut self.ledge_cover_placement_step
    }
    fn ledge_cover_placement_dist_from_ledge(&self) -> &f32 {
        &self.ledge_cover_placement_dist_from_ledge
    }
    fn ledge_cover_placement_dist_from_ledge_mut(&mut self) -> &mut f32 {
        &mut self.ledge_cover_placement_dist_from_ledge
    }
    fn vault_over_path_link_config(&self) -> &VaultOverPathLinkConfig {
        &self.vault_over_path_link_config
    }
    fn vault_over_path_link_config_mut(&mut self) -> &mut VaultOverPathLinkConfig {
        &mut self.vault_over_path_link_config
    }
    fn ledge_jump_down_path_link_config(&self) -> &LedgeJumpDownPathLinkConfig {
        &self.ledge_jump_down_path_link_config
    }
    fn ledge_jump_down_path_link_config_mut(&mut self) -> &mut LedgeJumpDownPathLinkConfig {
        &mut self.ledge_jump_down_path_link_config
    }
    fn max_covers_in_memory(&self) -> &i32 {
        &self.max_covers_in_memory
    }
    fn max_covers_in_memory_mut(&mut self) -> &mut i32 {
        &mut self.max_covers_in_memory
    }
    fn cover_zones(&self) -> &Option<Arc<Mutex<dyn CoverZonesTrait>>> {
        &self.cover_zones
    }
    fn cover_zones_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZonesTrait>>> {
        &mut self.cover_zones
    }
}

impl super::core::AssetTrait for CoverConstantData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CoverConstantData {
}

pub static COVERCONSTANTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverConstantData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverConstantData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SlotSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, slot_size),
            },
            FieldInfoData {
                name: "SlotSpacing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, slot_spacing),
            },
            FieldInfoData {
                name: "SlotEdgeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, slot_edge_distance),
            },
            FieldInfoData {
                name: "SlotBlockedEdgeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, slot_blocked_edge_distance),
            },
            FieldInfoData {
                name: "MinimumProtectedCoverWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, minimum_protected_cover_width),
            },
            FieldInfoData {
                name: "ProneAllowFireHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, prone_allow_fire_height),
            },
            FieldInfoData {
                name: "OpenAllowFireHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, open_allow_fire_height),
            },
            FieldInfoData {
                name: "CrouchHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, crouch_height),
            },
            FieldInfoData {
                name: "CrouchAllowFireHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, crouch_allow_fire_height),
            },
            FieldInfoData {
                name: "MediumHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, medium_height),
            },
            FieldInfoData {
                name: "MediumAllowFireHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, medium_allow_fire_height),
            },
            FieldInfoData {
                name: "StandHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, stand_height),
            },
            FieldInfoData {
                name: "FireHeightProne",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, fire_height_prone),
            },
            FieldInfoData {
                name: "FireHeightOpen",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, fire_height_open),
            },
            FieldInfoData {
                name: "FireHeightCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, fire_height_crouch),
            },
            FieldInfoData {
                name: "FireHeightMedium",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, fire_height_medium),
            },
            FieldInfoData {
                name: "FireHeightStanding",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, fire_height_standing),
            },
            FieldInfoData {
                name: "MinFreeShootDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, min_free_shoot_dist),
            },
            FieldInfoData {
                name: "FireStepOutDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, fire_step_out_dist),
            },
            FieldInfoData {
                name: "MaxFireSideTestAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, max_fire_side_test_angle),
            },
            FieldInfoData {
                name: "FireSideSampleCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverConstantData, fire_side_sample_count),
            },
            FieldInfoData {
                name: "PathfindingReferenceLayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverConstantData, pathfinding_reference_layer),
            },
            FieldInfoData {
                name: "TerrainHeightSamplingStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, terrain_height_sampling_step),
            },
            FieldInfoData {
                name: "ChunkSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, chunk_size),
            },
            FieldInfoData {
                name: "VoxelSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, voxel_size),
            },
            FieldInfoData {
                name: "VoxelHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, voxel_height),
            },
            FieldInfoData {
                name: "voxelSpanMergeThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverConstantData, voxel_span_merge_threshold),
            },
            FieldInfoData {
                name: "VoxelSpanMergingMaxSeparation",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverConstantData, voxel_span_merging_max_separation),
            },
            FieldInfoData {
                name: "MaxStepHeightOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, max_step_height_override),
            },
            FieldInfoData {
                name: "MinIslandSurfaceAreaExtra",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, min_island_surface_area_extra),
            },
            FieldInfoData {
                name: "ContourSimplificationMaxAreaDelta",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, contour_simplification_max_area_delta),
            },
            FieldInfoData {
                name: "ContourSimplificationXZErrorIn",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, contour_simplification_x_z_error_in),
            },
            FieldInfoData {
                name: "ContourSimplificationXZErrorOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, contour_simplification_x_z_error_out),
            },
            FieldInfoData {
                name: "ContourSimplificationYError",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, contour_simplification_y_error),
            },
            FieldInfoData {
                name: "OpenCoverMinSpacingDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, open_cover_min_spacing_dist),
            },
            FieldInfoData {
                name: "OpenCoverVoxelSamplingStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverConstantData, open_cover_voxel_sampling_step),
            },
            FieldInfoData {
                name: "OpenCoverVoxelErosionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, open_cover_voxel_erosion_distance),
            },
            FieldInfoData {
                name: "OpenCoverMinDistToManualCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, open_cover_min_dist_to_manual_cover),
            },
            FieldInfoData {
                name: "MinHoverClearance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, min_hover_clearance),
            },
            FieldInfoData {
                name: "HoveringMinDistToCeiling",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, hovering_min_dist_to_ceiling),
            },
            FieldInfoData {
                name: "MaxRealCoverContourSlope",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, max_real_cover_contour_slope),
            },
            FieldInfoData {
                name: "EdgeProbeSampleSpacing",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, edge_probe_sample_spacing),
            },
            FieldInfoData {
                name: "CrouchCoverOcclusionSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "ProtectiveCoverWallOcclusionSettings",
                rust_offset: offset_of!(CoverConstantData, crouch_cover_occlusion_settings),
            },
            FieldInfoData {
                name: "StandCoverOcclusionSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "ProtectiveCoverWallOcclusionSettings",
                rust_offset: offset_of!(CoverConstantData, stand_cover_occlusion_settings),
            },
            FieldInfoData {
                name: "FreeShootHeightRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, free_shoot_height_range),
            },
            FieldInfoData {
                name: "GenerateFullyBlockedCovers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverConstantData, generate_fully_blocked_covers),
            },
            FieldInfoData {
                name: "FullyBlockedCoverMaxDistFromValidCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, fully_blocked_cover_max_dist_from_valid_cover),
            },
            FieldInfoData {
                name: "LedgeForwardClearanceDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, ledge_forward_clearance_dist),
            },
            FieldInfoData {
                name: "LedgeDownwardClearanceDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, ledge_downward_clearance_dist),
            },
            FieldInfoData {
                name: "LedgeDownwardClearanceTestRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, ledge_downward_clearance_test_range),
            },
            FieldInfoData {
                name: "LedgeCoverPlacementStartDistOnEdge",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, ledge_cover_placement_start_dist_on_edge),
            },
            FieldInfoData {
                name: "LedgeCoverPlacementStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, ledge_cover_placement_step),
            },
            FieldInfoData {
                name: "LedgeCoverPlacementDistFromLedge",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverConstantData, ledge_cover_placement_dist_from_ledge),
            },
            FieldInfoData {
                name: "VaultOverPathLinkConfig",
                flags: MemberInfoFlags::new(0),
                field_type: "VaultOverPathLinkConfig",
                rust_offset: offset_of!(CoverConstantData, vault_over_path_link_config),
            },
            FieldInfoData {
                name: "LedgeJumpDownPathLinkConfig",
                flags: MemberInfoFlags::new(0),
                field_type: "LedgeJumpDownPathLinkConfig",
                rust_offset: offset_of!(CoverConstantData, ledge_jump_down_path_link_config),
            },
            FieldInfoData {
                name: "MaxCoversInMemory",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CoverConstantData, max_covers_in_memory),
            },
            FieldInfoData {
                name: "CoverZones",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverZones",
                rust_offset: offset_of!(CoverConstantData, cover_zones),
            },
        ],
    }),
    array_type: Some(COVERCONSTANTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverConstantData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERCONSTANTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERCONSTANTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverConstantData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverConstantData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProtectiveCoverWallOcclusionSettings {
    pub occlusion_check_dist: f32,
    pub min_occlusion_ratio: f32,
    pub max_hole_size: f32,
    pub occlusion_checking_ground_distance_offset: f32,
}

pub trait ProtectiveCoverWallOcclusionSettingsTrait: TypeObject {
    fn occlusion_check_dist(&self) -> &f32;
    fn occlusion_check_dist_mut(&mut self) -> &mut f32;
    fn min_occlusion_ratio(&self) -> &f32;
    fn min_occlusion_ratio_mut(&mut self) -> &mut f32;
    fn max_hole_size(&self) -> &f32;
    fn max_hole_size_mut(&mut self) -> &mut f32;
    fn occlusion_checking_ground_distance_offset(&self) -> &f32;
    fn occlusion_checking_ground_distance_offset_mut(&mut self) -> &mut f32;
}

impl ProtectiveCoverWallOcclusionSettingsTrait for ProtectiveCoverWallOcclusionSettings {
    fn occlusion_check_dist(&self) -> &f32 {
        &self.occlusion_check_dist
    }
    fn occlusion_check_dist_mut(&mut self) -> &mut f32 {
        &mut self.occlusion_check_dist
    }
    fn min_occlusion_ratio(&self) -> &f32 {
        &self.min_occlusion_ratio
    }
    fn min_occlusion_ratio_mut(&mut self) -> &mut f32 {
        &mut self.min_occlusion_ratio
    }
    fn max_hole_size(&self) -> &f32 {
        &self.max_hole_size
    }
    fn max_hole_size_mut(&mut self) -> &mut f32 {
        &mut self.max_hole_size
    }
    fn occlusion_checking_ground_distance_offset(&self) -> &f32 {
        &self.occlusion_checking_ground_distance_offset
    }
    fn occlusion_checking_ground_distance_offset_mut(&mut self) -> &mut f32 {
        &mut self.occlusion_checking_ground_distance_offset
    }
}

pub static PROTECTIVECOVERWALLOCCLUSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProtectiveCoverWallOcclusionSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProtectiveCoverWallOcclusionSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OcclusionCheckDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProtectiveCoverWallOcclusionSettings, occlusion_check_dist),
            },
            FieldInfoData {
                name: "MinOcclusionRatio",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProtectiveCoverWallOcclusionSettings, min_occlusion_ratio),
            },
            FieldInfoData {
                name: "MaxHoleSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProtectiveCoverWallOcclusionSettings, max_hole_size),
            },
            FieldInfoData {
                name: "OcclusionCheckingGroundDistanceOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ProtectiveCoverWallOcclusionSettings, occlusion_checking_ground_distance_offset),
            },
        ],
    }),
    array_type: Some(PROTECTIVECOVERWALLOCCLUSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ProtectiveCoverWallOcclusionSettings {
    fn type_info(&self) -> &'static TypeInfo {
        PROTECTIVECOVERWALLOCCLUSIONSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PROTECTIVECOVERWALLOCCLUSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProtectiveCoverWallOcclusionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ProtectiveCoverWallOcclusionSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LedgeJumpDownPathLinkConfig {
    pub floor_clearance_dist_top: f32,
    pub forward_clearance_dist: f32,
    pub forward_clearance_range: f32,
    pub forward_jump_dist: f32,
    pub min_drop_distance: f32,
    pub max_drop_distance: f32,
    pub clearance_offset_from_ground: f32,
    pub max_ground_height_delta_at_base: f32,
    pub min_link_width: f32,
    pub path_link_data: Option<Arc<Mutex<dyn AIPathLinkDataTrait>>>,
}

pub trait LedgeJumpDownPathLinkConfigTrait: TypeObject {
    fn floor_clearance_dist_top(&self) -> &f32;
    fn floor_clearance_dist_top_mut(&mut self) -> &mut f32;
    fn forward_clearance_dist(&self) -> &f32;
    fn forward_clearance_dist_mut(&mut self) -> &mut f32;
    fn forward_clearance_range(&self) -> &f32;
    fn forward_clearance_range_mut(&mut self) -> &mut f32;
    fn forward_jump_dist(&self) -> &f32;
    fn forward_jump_dist_mut(&mut self) -> &mut f32;
    fn min_drop_distance(&self) -> &f32;
    fn min_drop_distance_mut(&mut self) -> &mut f32;
    fn max_drop_distance(&self) -> &f32;
    fn max_drop_distance_mut(&mut self) -> &mut f32;
    fn clearance_offset_from_ground(&self) -> &f32;
    fn clearance_offset_from_ground_mut(&mut self) -> &mut f32;
    fn max_ground_height_delta_at_base(&self) -> &f32;
    fn max_ground_height_delta_at_base_mut(&mut self) -> &mut f32;
    fn min_link_width(&self) -> &f32;
    fn min_link_width_mut(&mut self) -> &mut f32;
    fn path_link_data(&self) -> &Option<Arc<Mutex<dyn AIPathLinkDataTrait>>>;
    fn path_link_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIPathLinkDataTrait>>>;
}

impl LedgeJumpDownPathLinkConfigTrait for LedgeJumpDownPathLinkConfig {
    fn floor_clearance_dist_top(&self) -> &f32 {
        &self.floor_clearance_dist_top
    }
    fn floor_clearance_dist_top_mut(&mut self) -> &mut f32 {
        &mut self.floor_clearance_dist_top
    }
    fn forward_clearance_dist(&self) -> &f32 {
        &self.forward_clearance_dist
    }
    fn forward_clearance_dist_mut(&mut self) -> &mut f32 {
        &mut self.forward_clearance_dist
    }
    fn forward_clearance_range(&self) -> &f32 {
        &self.forward_clearance_range
    }
    fn forward_clearance_range_mut(&mut self) -> &mut f32 {
        &mut self.forward_clearance_range
    }
    fn forward_jump_dist(&self) -> &f32 {
        &self.forward_jump_dist
    }
    fn forward_jump_dist_mut(&mut self) -> &mut f32 {
        &mut self.forward_jump_dist
    }
    fn min_drop_distance(&self) -> &f32 {
        &self.min_drop_distance
    }
    fn min_drop_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_drop_distance
    }
    fn max_drop_distance(&self) -> &f32 {
        &self.max_drop_distance
    }
    fn max_drop_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_drop_distance
    }
    fn clearance_offset_from_ground(&self) -> &f32 {
        &self.clearance_offset_from_ground
    }
    fn clearance_offset_from_ground_mut(&mut self) -> &mut f32 {
        &mut self.clearance_offset_from_ground
    }
    fn max_ground_height_delta_at_base(&self) -> &f32 {
        &self.max_ground_height_delta_at_base
    }
    fn max_ground_height_delta_at_base_mut(&mut self) -> &mut f32 {
        &mut self.max_ground_height_delta_at_base
    }
    fn min_link_width(&self) -> &f32 {
        &self.min_link_width
    }
    fn min_link_width_mut(&mut self) -> &mut f32 {
        &mut self.min_link_width
    }
    fn path_link_data(&self) -> &Option<Arc<Mutex<dyn AIPathLinkDataTrait>>> {
        &self.path_link_data
    }
    fn path_link_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIPathLinkDataTrait>>> {
        &mut self.path_link_data
    }
}

pub static LEDGEJUMPDOWNPATHLINKCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LedgeJumpDownPathLinkConfig",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LedgeJumpDownPathLinkConfig as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FloorClearanceDistTop",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, floor_clearance_dist_top),
            },
            FieldInfoData {
                name: "ForwardClearanceDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, forward_clearance_dist),
            },
            FieldInfoData {
                name: "ForwardClearanceRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, forward_clearance_range),
            },
            FieldInfoData {
                name: "ForwardJumpDist",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, forward_jump_dist),
            },
            FieldInfoData {
                name: "MinDropDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, min_drop_distance),
            },
            FieldInfoData {
                name: "MaxDropDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, max_drop_distance),
            },
            FieldInfoData {
                name: "ClearanceOffsetFromGround",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, clearance_offset_from_ground),
            },
            FieldInfoData {
                name: "MaxGroundHeightDeltaAtBase",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, max_ground_height_delta_at_base),
            },
            FieldInfoData {
                name: "minLinkWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, min_link_width),
            },
            FieldInfoData {
                name: "PathLinkData",
                flags: MemberInfoFlags::new(0),
                field_type: "AIPathLinkData",
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, path_link_data),
            },
        ],
    }),
    array_type: Some(LEDGEJUMPDOWNPATHLINKCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LedgeJumpDownPathLinkConfig {
    fn type_info(&self) -> &'static TypeInfo {
        LEDGEJUMPDOWNPATHLINKCONFIG_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LEDGEJUMPDOWNPATHLINKCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LedgeJumpDownPathLinkConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LedgeJumpDownPathLinkConfig"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VaultOverPathLinkConfig {
    pub vault_start_distance: f32,
    pub vault_end_distance: f32,
    pub extra_clearance_distance: f32,
    pub max_cover_panel_slope: f32,
    pub max_cover_panel_separation: f32,
    pub max_cover_panel_alignment_angle: f32,
    pub max_ground_height_deviation: f32,
    pub max_ground_height_step_between_wall_sides: f32,
    pub min_path_link_width: f32,
    pub edge_retraction_distance: f32,
    pub clearance_dist_above_wall: f32,
    pub path_link_data: Option<Arc<Mutex<dyn AIPathLinkDataTrait>>>,
}

pub trait VaultOverPathLinkConfigTrait: TypeObject {
    fn vault_start_distance(&self) -> &f32;
    fn vault_start_distance_mut(&mut self) -> &mut f32;
    fn vault_end_distance(&self) -> &f32;
    fn vault_end_distance_mut(&mut self) -> &mut f32;
    fn extra_clearance_distance(&self) -> &f32;
    fn extra_clearance_distance_mut(&mut self) -> &mut f32;
    fn max_cover_panel_slope(&self) -> &f32;
    fn max_cover_panel_slope_mut(&mut self) -> &mut f32;
    fn max_cover_panel_separation(&self) -> &f32;
    fn max_cover_panel_separation_mut(&mut self) -> &mut f32;
    fn max_cover_panel_alignment_angle(&self) -> &f32;
    fn max_cover_panel_alignment_angle_mut(&mut self) -> &mut f32;
    fn max_ground_height_deviation(&self) -> &f32;
    fn max_ground_height_deviation_mut(&mut self) -> &mut f32;
    fn max_ground_height_step_between_wall_sides(&self) -> &f32;
    fn max_ground_height_step_between_wall_sides_mut(&mut self) -> &mut f32;
    fn min_path_link_width(&self) -> &f32;
    fn min_path_link_width_mut(&mut self) -> &mut f32;
    fn edge_retraction_distance(&self) -> &f32;
    fn edge_retraction_distance_mut(&mut self) -> &mut f32;
    fn clearance_dist_above_wall(&self) -> &f32;
    fn clearance_dist_above_wall_mut(&mut self) -> &mut f32;
    fn path_link_data(&self) -> &Option<Arc<Mutex<dyn AIPathLinkDataTrait>>>;
    fn path_link_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIPathLinkDataTrait>>>;
}

impl VaultOverPathLinkConfigTrait for VaultOverPathLinkConfig {
    fn vault_start_distance(&self) -> &f32 {
        &self.vault_start_distance
    }
    fn vault_start_distance_mut(&mut self) -> &mut f32 {
        &mut self.vault_start_distance
    }
    fn vault_end_distance(&self) -> &f32 {
        &self.vault_end_distance
    }
    fn vault_end_distance_mut(&mut self) -> &mut f32 {
        &mut self.vault_end_distance
    }
    fn extra_clearance_distance(&self) -> &f32 {
        &self.extra_clearance_distance
    }
    fn extra_clearance_distance_mut(&mut self) -> &mut f32 {
        &mut self.extra_clearance_distance
    }
    fn max_cover_panel_slope(&self) -> &f32 {
        &self.max_cover_panel_slope
    }
    fn max_cover_panel_slope_mut(&mut self) -> &mut f32 {
        &mut self.max_cover_panel_slope
    }
    fn max_cover_panel_separation(&self) -> &f32 {
        &self.max_cover_panel_separation
    }
    fn max_cover_panel_separation_mut(&mut self) -> &mut f32 {
        &mut self.max_cover_panel_separation
    }
    fn max_cover_panel_alignment_angle(&self) -> &f32 {
        &self.max_cover_panel_alignment_angle
    }
    fn max_cover_panel_alignment_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_cover_panel_alignment_angle
    }
    fn max_ground_height_deviation(&self) -> &f32 {
        &self.max_ground_height_deviation
    }
    fn max_ground_height_deviation_mut(&mut self) -> &mut f32 {
        &mut self.max_ground_height_deviation
    }
    fn max_ground_height_step_between_wall_sides(&self) -> &f32 {
        &self.max_ground_height_step_between_wall_sides
    }
    fn max_ground_height_step_between_wall_sides_mut(&mut self) -> &mut f32 {
        &mut self.max_ground_height_step_between_wall_sides
    }
    fn min_path_link_width(&self) -> &f32 {
        &self.min_path_link_width
    }
    fn min_path_link_width_mut(&mut self) -> &mut f32 {
        &mut self.min_path_link_width
    }
    fn edge_retraction_distance(&self) -> &f32 {
        &self.edge_retraction_distance
    }
    fn edge_retraction_distance_mut(&mut self) -> &mut f32 {
        &mut self.edge_retraction_distance
    }
    fn clearance_dist_above_wall(&self) -> &f32 {
        &self.clearance_dist_above_wall
    }
    fn clearance_dist_above_wall_mut(&mut self) -> &mut f32 {
        &mut self.clearance_dist_above_wall
    }
    fn path_link_data(&self) -> &Option<Arc<Mutex<dyn AIPathLinkDataTrait>>> {
        &self.path_link_data
    }
    fn path_link_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AIPathLinkDataTrait>>> {
        &mut self.path_link_data
    }
}

pub static VAULTOVERPATHLINKCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultOverPathLinkConfig",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VaultOverPathLinkConfig as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VaultStartDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, vault_start_distance),
            },
            FieldInfoData {
                name: "VaultEndDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, vault_end_distance),
            },
            FieldInfoData {
                name: "ExtraClearanceDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, extra_clearance_distance),
            },
            FieldInfoData {
                name: "MaxCoverPanelSlope",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_cover_panel_slope),
            },
            FieldInfoData {
                name: "MaxCoverPanelSeparation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_cover_panel_separation),
            },
            FieldInfoData {
                name: "MaxCoverPanelAlignmentAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_cover_panel_alignment_angle),
            },
            FieldInfoData {
                name: "MaxGroundHeightDeviation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_ground_height_deviation),
            },
            FieldInfoData {
                name: "MaxGroundHeightStepBetweenWallSides",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_ground_height_step_between_wall_sides),
            },
            FieldInfoData {
                name: "MinPathLinkWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, min_path_link_width),
            },
            FieldInfoData {
                name: "EdgeRetractionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, edge_retraction_distance),
            },
            FieldInfoData {
                name: "ClearanceDistAboveWall",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VaultOverPathLinkConfig, clearance_dist_above_wall),
            },
            FieldInfoData {
                name: "PathLinkData",
                flags: MemberInfoFlags::new(0),
                field_type: "AIPathLinkData",
                rust_offset: offset_of!(VaultOverPathLinkConfig, path_link_data),
            },
        ],
    }),
    array_type: Some(VAULTOVERPATHLINKCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VaultOverPathLinkConfig {
    fn type_info(&self) -> &'static TypeInfo {
        VAULTOVERPATHLINKCONFIG_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VAULTOVERPATHLINKCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultOverPathLinkConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VaultOverPathLinkConfig"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverZones {
    pub _glacier_base: super::core::Asset,
    pub cover_zones_over_and_out: Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>,
    pub cover_zones_over: Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>,
    pub cover_zones_out: Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>,
    pub cover_zones_open: Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>,
    pub cover_zones_open_directional: Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>,
}

pub trait CoverZonesTrait: super::core::AssetTrait {
    fn cover_zones_over_and_out(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
    fn cover_zones_over_and_out_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
    fn cover_zones_over(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
    fn cover_zones_over_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
    fn cover_zones_out(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
    fn cover_zones_out_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
    fn cover_zones_open(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
    fn cover_zones_open_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
    fn cover_zones_open_directional(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
    fn cover_zones_open_directional_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>>;
}

impl CoverZonesTrait for CoverZones {
    fn cover_zones_over_and_out(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &self.cover_zones_over_and_out
    }
    fn cover_zones_over_and_out_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &mut self.cover_zones_over_and_out
    }
    fn cover_zones_over(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &self.cover_zones_over
    }
    fn cover_zones_over_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &mut self.cover_zones_over
    }
    fn cover_zones_out(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &self.cover_zones_out
    }
    fn cover_zones_out_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &mut self.cover_zones_out
    }
    fn cover_zones_open(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &self.cover_zones_open
    }
    fn cover_zones_open_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &mut self.cover_zones_open
    }
    fn cover_zones_open_directional(&self) -> &Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &self.cover_zones_open_directional
    }
    fn cover_zones_open_directional_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverZoneDefinitionTrait>>> {
        &mut self.cover_zones_open_directional
    }
}

impl super::core::AssetTrait for CoverZones {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CoverZones {
}

pub static COVERZONES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZones",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverZones as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverZonesOverAndOut",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverZoneDefinition",
                rust_offset: offset_of!(CoverZones, cover_zones_over_and_out),
            },
            FieldInfoData {
                name: "CoverZonesOver",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverZoneDefinition",
                rust_offset: offset_of!(CoverZones, cover_zones_over),
            },
            FieldInfoData {
                name: "CoverZonesOut",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverZoneDefinition",
                rust_offset: offset_of!(CoverZones, cover_zones_out),
            },
            FieldInfoData {
                name: "CoverZonesOpen",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverZoneDefinition",
                rust_offset: offset_of!(CoverZones, cover_zones_open),
            },
            FieldInfoData {
                name: "CoverZonesOpenDirectional",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverZoneDefinition",
                rust_offset: offset_of!(CoverZones, cover_zones_open_directional),
            },
        ],
    }),
    array_type: Some(COVERZONES_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverZones {
    fn type_info(&self) -> &'static TypeInfo {
        COVERZONES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERZONES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZones-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverZones"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverZoneDefinition {
    pub _glacier_base: super::core::Asset,
    pub zones: Vec<CoverZone>,
}

pub trait CoverZoneDefinitionTrait: super::core::AssetTrait {
    fn zones(&self) -> &Vec<CoverZone>;
    fn zones_mut(&mut self) -> &mut Vec<CoverZone>;
}

impl CoverZoneDefinitionTrait for CoverZoneDefinition {
    fn zones(&self) -> &Vec<CoverZone> {
        &self.zones
    }
    fn zones_mut(&mut self) -> &mut Vec<CoverZone> {
        &mut self.zones
    }
}

impl super::core::AssetTrait for CoverZoneDefinition {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for CoverZoneDefinition {
}

pub static COVERZONEDEFINITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZoneDefinition",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverZoneDefinition as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Zones",
                flags: MemberInfoFlags::new(144),
                field_type: "CoverZone-Array",
                rust_offset: offset_of!(CoverZoneDefinition, zones),
            },
        ],
    }),
    array_type: Some(COVERZONEDEFINITION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverZoneDefinition {
    fn type_info(&self) -> &'static TypeInfo {
        COVERZONEDEFINITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERZONEDEFINITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZoneDefinition-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverZoneDefinition"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverZone {
    pub first_angle: f32,
    pub second_angle: f32,
    pub close_distance: f32,
    pub far_distance: f32,
    pub peek: bool,
    pub over: bool,
    pub out: bool,
    pub flanked: bool,
    pub always_request_cover: bool,
    pub request_cover_if_under_fire: bool,
    pub force_out_firing: bool,
    pub trigger_flanked: bool,
    pub suppressed_by_enemy_bullets: bool,
    pub allow_projectile_fire: bool,
    pub allow_hover_fire: bool,
}

pub trait CoverZoneTrait: TypeObject {
    fn first_angle(&self) -> &f32;
    fn first_angle_mut(&mut self) -> &mut f32;
    fn second_angle(&self) -> &f32;
    fn second_angle_mut(&mut self) -> &mut f32;
    fn close_distance(&self) -> &f32;
    fn close_distance_mut(&mut self) -> &mut f32;
    fn far_distance(&self) -> &f32;
    fn far_distance_mut(&mut self) -> &mut f32;
    fn peek(&self) -> &bool;
    fn peek_mut(&mut self) -> &mut bool;
    fn over(&self) -> &bool;
    fn over_mut(&mut self) -> &mut bool;
    fn out(&self) -> &bool;
    fn out_mut(&mut self) -> &mut bool;
    fn flanked(&self) -> &bool;
    fn flanked_mut(&mut self) -> &mut bool;
    fn always_request_cover(&self) -> &bool;
    fn always_request_cover_mut(&mut self) -> &mut bool;
    fn request_cover_if_under_fire(&self) -> &bool;
    fn request_cover_if_under_fire_mut(&mut self) -> &mut bool;
    fn force_out_firing(&self) -> &bool;
    fn force_out_firing_mut(&mut self) -> &mut bool;
    fn trigger_flanked(&self) -> &bool;
    fn trigger_flanked_mut(&mut self) -> &mut bool;
    fn suppressed_by_enemy_bullets(&self) -> &bool;
    fn suppressed_by_enemy_bullets_mut(&mut self) -> &mut bool;
    fn allow_projectile_fire(&self) -> &bool;
    fn allow_projectile_fire_mut(&mut self) -> &mut bool;
    fn allow_hover_fire(&self) -> &bool;
    fn allow_hover_fire_mut(&mut self) -> &mut bool;
}

impl CoverZoneTrait for CoverZone {
    fn first_angle(&self) -> &f32 {
        &self.first_angle
    }
    fn first_angle_mut(&mut self) -> &mut f32 {
        &mut self.first_angle
    }
    fn second_angle(&self) -> &f32 {
        &self.second_angle
    }
    fn second_angle_mut(&mut self) -> &mut f32 {
        &mut self.second_angle
    }
    fn close_distance(&self) -> &f32 {
        &self.close_distance
    }
    fn close_distance_mut(&mut self) -> &mut f32 {
        &mut self.close_distance
    }
    fn far_distance(&self) -> &f32 {
        &self.far_distance
    }
    fn far_distance_mut(&mut self) -> &mut f32 {
        &mut self.far_distance
    }
    fn peek(&self) -> &bool {
        &self.peek
    }
    fn peek_mut(&mut self) -> &mut bool {
        &mut self.peek
    }
    fn over(&self) -> &bool {
        &self.over
    }
    fn over_mut(&mut self) -> &mut bool {
        &mut self.over
    }
    fn out(&self) -> &bool {
        &self.out
    }
    fn out_mut(&mut self) -> &mut bool {
        &mut self.out
    }
    fn flanked(&self) -> &bool {
        &self.flanked
    }
    fn flanked_mut(&mut self) -> &mut bool {
        &mut self.flanked
    }
    fn always_request_cover(&self) -> &bool {
        &self.always_request_cover
    }
    fn always_request_cover_mut(&mut self) -> &mut bool {
        &mut self.always_request_cover
    }
    fn request_cover_if_under_fire(&self) -> &bool {
        &self.request_cover_if_under_fire
    }
    fn request_cover_if_under_fire_mut(&mut self) -> &mut bool {
        &mut self.request_cover_if_under_fire
    }
    fn force_out_firing(&self) -> &bool {
        &self.force_out_firing
    }
    fn force_out_firing_mut(&mut self) -> &mut bool {
        &mut self.force_out_firing
    }
    fn trigger_flanked(&self) -> &bool {
        &self.trigger_flanked
    }
    fn trigger_flanked_mut(&mut self) -> &mut bool {
        &mut self.trigger_flanked
    }
    fn suppressed_by_enemy_bullets(&self) -> &bool {
        &self.suppressed_by_enemy_bullets
    }
    fn suppressed_by_enemy_bullets_mut(&mut self) -> &mut bool {
        &mut self.suppressed_by_enemy_bullets
    }
    fn allow_projectile_fire(&self) -> &bool {
        &self.allow_projectile_fire
    }
    fn allow_projectile_fire_mut(&mut self) -> &mut bool {
        &mut self.allow_projectile_fire
    }
    fn allow_hover_fire(&self) -> &bool {
        &self.allow_hover_fire
    }
    fn allow_hover_fire_mut(&mut self) -> &mut bool {
        &mut self.allow_hover_fire
    }
}

pub static COVERZONE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZone",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverZone as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FirstAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverZone, first_angle),
            },
            FieldInfoData {
                name: "SecondAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverZone, second_angle),
            },
            FieldInfoData {
                name: "CloseDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverZone, close_distance),
            },
            FieldInfoData {
                name: "FarDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CoverZone, far_distance),
            },
            FieldInfoData {
                name: "Peek",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, peek),
            },
            FieldInfoData {
                name: "Over",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, over),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, out),
            },
            FieldInfoData {
                name: "Flanked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, flanked),
            },
            FieldInfoData {
                name: "AlwaysRequestCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, always_request_cover),
            },
            FieldInfoData {
                name: "RequestCoverIfUnderFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, request_cover_if_under_fire),
            },
            FieldInfoData {
                name: "ForceOutFiring",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, force_out_firing),
            },
            FieldInfoData {
                name: "TriggerFlanked",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, trigger_flanked),
            },
            FieldInfoData {
                name: "SuppressedByEnemyBullets",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, suppressed_by_enemy_bullets),
            },
            FieldInfoData {
                name: "AllowProjectileFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, allow_projectile_fire),
            },
            FieldInfoData {
                name: "AllowHoverFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CoverZone, allow_hover_fire),
            },
        ],
    }),
    array_type: Some(COVERZONE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverZone {
    fn type_info(&self) -> &'static TypeInfo {
        COVERZONE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERZONE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZone-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverZone"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIConcealmentVolumeEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait AIConcealmentVolumeEntityDataTrait: super::entity::EntityDataTrait {
}

impl AIConcealmentVolumeEntityDataTrait for AIConcealmentVolumeEntityData {
}

impl super::entity::EntityDataTrait for AIConcealmentVolumeEntityData {
}

impl super::entity::GameObjectDataTrait for AIConcealmentVolumeEntityData {
}

impl super::core::DataBusPeerTrait for AIConcealmentVolumeEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIConcealmentVolumeEntityData {
}

impl super::core::DataContainerTrait for AIConcealmentVolumeEntityData {
}

pub static AICONCEALMENTVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIConcealmentVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIConcealmentVolumeEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AICONCEALMENTVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIConcealmentVolumeEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AICONCEALMENTVOLUMEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AICONCEALMENTVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIConcealmentVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIConcealmentVolumeEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIWeaponData {
    pub _glacier_base: super::gameplay_sim::GameAIWeaponData,
    pub firing_weapon_class: FiringWeaponClass,
    pub vo_primary_fire_type: VoPrimaryFireType,
    pub weapon_range: f32,
    pub minimum_usage_distance: f32,
    pub maximum_usage_distance: f32,
    pub vehicle_max_target_l_o_s_lost: f32,
    pub min_enter_vehicle_distance: f32,
    pub exit_vehicle_disable_time: f32,
    pub use_target_extrapolation: bool,
    pub causes_evasion_on_fire: bool,
    pub create_evasion_nav_obstacle: bool,
    pub evasion_volume: Option<Arc<Mutex<dyn EvasionVolumeTrait>>>,
    pub preferred_range: Option<Arc<Mutex<dyn PreferredRangeTrait>>>,
    pub indoor_preferred_range: Option<Arc<Mutex<dyn PreferredRangeTrait>>>,
    pub outdoor_preferred_range: Option<Arc<Mutex<dyn PreferredRangeTrait>>>,
    pub firing_interval_pattern: Option<Arc<Mutex<dyn FiringIntervalPatternTrait>>>,
    pub sustain_firing_data: Option<Arc<Mutex<dyn SustainFiringDataTrait>>>,
    pub burst_interval_pattern: Option<Arc<Mutex<dyn BurstIntervalPatternTrait>>>,
    pub creeping_air_barrage: Option<Arc<Mutex<dyn CreepingAirBarrageTrait>>>,
    pub spray_pattern: Option<Arc<Mutex<dyn SprayPatternTrait>>>,
    pub accuracy_hit_box: Option<Arc<Mutex<dyn AccuracyHitBoxTrait>>>,
    pub vehicle_aimer_settings: Option<Arc<Mutex<dyn VehicleAimerSettingsTrait>>>,
    pub vision_modifier: Option<Arc<Mutex<dyn VisionModifierTrait>>>,
    pub hearing_modifier: Option<Arc<Mutex<dyn HearingModifierTrait>>>,
    pub target_modifier: Option<Arc<Mutex<dyn TargetModifierTrait>>>,
    pub targeting_settings_override: Option<Arc<Mutex<dyn TargetingDataTrait>>>,
    pub vehicle_inaccuracy_settings: Option<Arc<Mutex<dyn VehicleInaccuracySettingsTrait>>>,
    pub suppressed_behavior: Option<Arc<Mutex<dyn SuppressedBehaviorTrait>>>,
    pub damage_modifier: Option<Arc<Mutex<dyn DamageModifierTrait>>>,
    pub damage_modifier_extended: Option<Arc<Mutex<dyn DamageModifierExtendedTrait>>>,
    pub friendly_weapon_restrictions: Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>>,
    pub enemy_weapon_restrictions: Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>>,
    pub special_behavior: Option<Arc<Mutex<dyn SpecialBehaviorTrait>>>,
    pub human_target_hit_probability: Option<Arc<Mutex<dyn WeaponHitProbabilityTrait>>>,
    pub distance_to_aware_curve_override: Option<Arc<Mutex<dyn DistanceToAwareCurveOverrideTrait>>>,
    pub valid_against: ValidAgainst,
    pub target_preference: TargetPreference,
    pub use_shootspace_for_vision: bool,
    pub target_coordination_priority: f32,
    pub exclude_from_target_coordinator: bool,
    pub force_use_target_position: bool,
    pub require_line_of_fire: bool,
    pub min_precision_to_fire: f32,
    pub consider_explosion_rounds: bool,
    pub aim_high_for_explosion_rounds: bool,
    pub consider_target_offset: bool,
    pub cancel_explosion_round_if_out_of_range: bool,
    pub weapon_threat_scale: f32,
    pub valid_weapon_scale: f32,
    pub in_valid_weapon_scale: f32,
}

pub trait AIWeaponDataTrait: super::gameplay_sim::GameAIWeaponDataTrait {
    fn firing_weapon_class(&self) -> &FiringWeaponClass;
    fn firing_weapon_class_mut(&mut self) -> &mut FiringWeaponClass;
    fn vo_primary_fire_type(&self) -> &VoPrimaryFireType;
    fn vo_primary_fire_type_mut(&mut self) -> &mut VoPrimaryFireType;
    fn weapon_range(&self) -> &f32;
    fn weapon_range_mut(&mut self) -> &mut f32;
    fn minimum_usage_distance(&self) -> &f32;
    fn minimum_usage_distance_mut(&mut self) -> &mut f32;
    fn maximum_usage_distance(&self) -> &f32;
    fn maximum_usage_distance_mut(&mut self) -> &mut f32;
    fn vehicle_max_target_l_o_s_lost(&self) -> &f32;
    fn vehicle_max_target_l_o_s_lost_mut(&mut self) -> &mut f32;
    fn min_enter_vehicle_distance(&self) -> &f32;
    fn min_enter_vehicle_distance_mut(&mut self) -> &mut f32;
    fn exit_vehicle_disable_time(&self) -> &f32;
    fn exit_vehicle_disable_time_mut(&mut self) -> &mut f32;
    fn use_target_extrapolation(&self) -> &bool;
    fn use_target_extrapolation_mut(&mut self) -> &mut bool;
    fn causes_evasion_on_fire(&self) -> &bool;
    fn causes_evasion_on_fire_mut(&mut self) -> &mut bool;
    fn create_evasion_nav_obstacle(&self) -> &bool;
    fn create_evasion_nav_obstacle_mut(&mut self) -> &mut bool;
    fn evasion_volume(&self) -> &Option<Arc<Mutex<dyn EvasionVolumeTrait>>>;
    fn evasion_volume_mut(&mut self) -> &mut Option<Arc<Mutex<dyn EvasionVolumeTrait>>>;
    fn preferred_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
    fn preferred_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
    fn indoor_preferred_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
    fn indoor_preferred_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
    fn outdoor_preferred_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
    fn outdoor_preferred_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
    fn firing_interval_pattern(&self) -> &Option<Arc<Mutex<dyn FiringIntervalPatternTrait>>>;
    fn firing_interval_pattern_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FiringIntervalPatternTrait>>>;
    fn sustain_firing_data(&self) -> &Option<Arc<Mutex<dyn SustainFiringDataTrait>>>;
    fn sustain_firing_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SustainFiringDataTrait>>>;
    fn burst_interval_pattern(&self) -> &Option<Arc<Mutex<dyn BurstIntervalPatternTrait>>>;
    fn burst_interval_pattern_mut(&mut self) -> &mut Option<Arc<Mutex<dyn BurstIntervalPatternTrait>>>;
    fn creeping_air_barrage(&self) -> &Option<Arc<Mutex<dyn CreepingAirBarrageTrait>>>;
    fn creeping_air_barrage_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CreepingAirBarrageTrait>>>;
    fn spray_pattern(&self) -> &Option<Arc<Mutex<dyn SprayPatternTrait>>>;
    fn spray_pattern_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SprayPatternTrait>>>;
    fn accuracy_hit_box(&self) -> &Option<Arc<Mutex<dyn AccuracyHitBoxTrait>>>;
    fn accuracy_hit_box_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AccuracyHitBoxTrait>>>;
    fn vehicle_aimer_settings(&self) -> &Option<Arc<Mutex<dyn VehicleAimerSettingsTrait>>>;
    fn vehicle_aimer_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleAimerSettingsTrait>>>;
    fn vision_modifier(&self) -> &Option<Arc<Mutex<dyn VisionModifierTrait>>>;
    fn vision_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VisionModifierTrait>>>;
    fn hearing_modifier(&self) -> &Option<Arc<Mutex<dyn HearingModifierTrait>>>;
    fn hearing_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HearingModifierTrait>>>;
    fn target_modifier(&self) -> &Option<Arc<Mutex<dyn TargetModifierTrait>>>;
    fn target_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TargetModifierTrait>>>;
    fn targeting_settings_override(&self) -> &Option<Arc<Mutex<dyn TargetingDataTrait>>>;
    fn targeting_settings_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TargetingDataTrait>>>;
    fn vehicle_inaccuracy_settings(&self) -> &Option<Arc<Mutex<dyn VehicleInaccuracySettingsTrait>>>;
    fn vehicle_inaccuracy_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleInaccuracySettingsTrait>>>;
    fn suppressed_behavior(&self) -> &Option<Arc<Mutex<dyn SuppressedBehaviorTrait>>>;
    fn suppressed_behavior_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SuppressedBehaviorTrait>>>;
    fn damage_modifier(&self) -> &Option<Arc<Mutex<dyn DamageModifierTrait>>>;
    fn damage_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DamageModifierTrait>>>;
    fn damage_modifier_extended(&self) -> &Option<Arc<Mutex<dyn DamageModifierExtendedTrait>>>;
    fn damage_modifier_extended_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DamageModifierExtendedTrait>>>;
    fn friendly_weapon_restrictions(&self) -> &Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>>;
    fn friendly_weapon_restrictions_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>>;
    fn enemy_weapon_restrictions(&self) -> &Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>>;
    fn enemy_weapon_restrictions_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>>;
    fn special_behavior(&self) -> &Option<Arc<Mutex<dyn SpecialBehaviorTrait>>>;
    fn special_behavior_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SpecialBehaviorTrait>>>;
    fn human_target_hit_probability(&self) -> &Option<Arc<Mutex<dyn WeaponHitProbabilityTrait>>>;
    fn human_target_hit_probability_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponHitProbabilityTrait>>>;
    fn distance_to_aware_curve_override(&self) -> &Option<Arc<Mutex<dyn DistanceToAwareCurveOverrideTrait>>>;
    fn distance_to_aware_curve_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DistanceToAwareCurveOverrideTrait>>>;
    fn valid_against(&self) -> &ValidAgainst;
    fn valid_against_mut(&mut self) -> &mut ValidAgainst;
    fn target_preference(&self) -> &TargetPreference;
    fn target_preference_mut(&mut self) -> &mut TargetPreference;
    fn use_shootspace_for_vision(&self) -> &bool;
    fn use_shootspace_for_vision_mut(&mut self) -> &mut bool;
    fn target_coordination_priority(&self) -> &f32;
    fn target_coordination_priority_mut(&mut self) -> &mut f32;
    fn exclude_from_target_coordinator(&self) -> &bool;
    fn exclude_from_target_coordinator_mut(&mut self) -> &mut bool;
    fn force_use_target_position(&self) -> &bool;
    fn force_use_target_position_mut(&mut self) -> &mut bool;
    fn require_line_of_fire(&self) -> &bool;
    fn require_line_of_fire_mut(&mut self) -> &mut bool;
    fn min_precision_to_fire(&self) -> &f32;
    fn min_precision_to_fire_mut(&mut self) -> &mut f32;
    fn consider_explosion_rounds(&self) -> &bool;
    fn consider_explosion_rounds_mut(&mut self) -> &mut bool;
    fn aim_high_for_explosion_rounds(&self) -> &bool;
    fn aim_high_for_explosion_rounds_mut(&mut self) -> &mut bool;
    fn consider_target_offset(&self) -> &bool;
    fn consider_target_offset_mut(&mut self) -> &mut bool;
    fn cancel_explosion_round_if_out_of_range(&self) -> &bool;
    fn cancel_explosion_round_if_out_of_range_mut(&mut self) -> &mut bool;
    fn weapon_threat_scale(&self) -> &f32;
    fn weapon_threat_scale_mut(&mut self) -> &mut f32;
    fn valid_weapon_scale(&self) -> &f32;
    fn valid_weapon_scale_mut(&mut self) -> &mut f32;
    fn in_valid_weapon_scale(&self) -> &f32;
    fn in_valid_weapon_scale_mut(&mut self) -> &mut f32;
}

impl AIWeaponDataTrait for AIWeaponData {
    fn firing_weapon_class(&self) -> &FiringWeaponClass {
        &self.firing_weapon_class
    }
    fn firing_weapon_class_mut(&mut self) -> &mut FiringWeaponClass {
        &mut self.firing_weapon_class
    }
    fn vo_primary_fire_type(&self) -> &VoPrimaryFireType {
        &self.vo_primary_fire_type
    }
    fn vo_primary_fire_type_mut(&mut self) -> &mut VoPrimaryFireType {
        &mut self.vo_primary_fire_type
    }
    fn weapon_range(&self) -> &f32 {
        &self.weapon_range
    }
    fn weapon_range_mut(&mut self) -> &mut f32 {
        &mut self.weapon_range
    }
    fn minimum_usage_distance(&self) -> &f32 {
        &self.minimum_usage_distance
    }
    fn minimum_usage_distance_mut(&mut self) -> &mut f32 {
        &mut self.minimum_usage_distance
    }
    fn maximum_usage_distance(&self) -> &f32 {
        &self.maximum_usage_distance
    }
    fn maximum_usage_distance_mut(&mut self) -> &mut f32 {
        &mut self.maximum_usage_distance
    }
    fn vehicle_max_target_l_o_s_lost(&self) -> &f32 {
        &self.vehicle_max_target_l_o_s_lost
    }
    fn vehicle_max_target_l_o_s_lost_mut(&mut self) -> &mut f32 {
        &mut self.vehicle_max_target_l_o_s_lost
    }
    fn min_enter_vehicle_distance(&self) -> &f32 {
        &self.min_enter_vehicle_distance
    }
    fn min_enter_vehicle_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_enter_vehicle_distance
    }
    fn exit_vehicle_disable_time(&self) -> &f32 {
        &self.exit_vehicle_disable_time
    }
    fn exit_vehicle_disable_time_mut(&mut self) -> &mut f32 {
        &mut self.exit_vehicle_disable_time
    }
    fn use_target_extrapolation(&self) -> &bool {
        &self.use_target_extrapolation
    }
    fn use_target_extrapolation_mut(&mut self) -> &mut bool {
        &mut self.use_target_extrapolation
    }
    fn causes_evasion_on_fire(&self) -> &bool {
        &self.causes_evasion_on_fire
    }
    fn causes_evasion_on_fire_mut(&mut self) -> &mut bool {
        &mut self.causes_evasion_on_fire
    }
    fn create_evasion_nav_obstacle(&self) -> &bool {
        &self.create_evasion_nav_obstacle
    }
    fn create_evasion_nav_obstacle_mut(&mut self) -> &mut bool {
        &mut self.create_evasion_nav_obstacle
    }
    fn evasion_volume(&self) -> &Option<Arc<Mutex<dyn EvasionVolumeTrait>>> {
        &self.evasion_volume
    }
    fn evasion_volume_mut(&mut self) -> &mut Option<Arc<Mutex<dyn EvasionVolumeTrait>>> {
        &mut self.evasion_volume
    }
    fn preferred_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &self.preferred_range
    }
    fn preferred_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &mut self.preferred_range
    }
    fn indoor_preferred_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &self.indoor_preferred_range
    }
    fn indoor_preferred_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &mut self.indoor_preferred_range
    }
    fn outdoor_preferred_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &self.outdoor_preferred_range
    }
    fn outdoor_preferred_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &mut self.outdoor_preferred_range
    }
    fn firing_interval_pattern(&self) -> &Option<Arc<Mutex<dyn FiringIntervalPatternTrait>>> {
        &self.firing_interval_pattern
    }
    fn firing_interval_pattern_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FiringIntervalPatternTrait>>> {
        &mut self.firing_interval_pattern
    }
    fn sustain_firing_data(&self) -> &Option<Arc<Mutex<dyn SustainFiringDataTrait>>> {
        &self.sustain_firing_data
    }
    fn sustain_firing_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SustainFiringDataTrait>>> {
        &mut self.sustain_firing_data
    }
    fn burst_interval_pattern(&self) -> &Option<Arc<Mutex<dyn BurstIntervalPatternTrait>>> {
        &self.burst_interval_pattern
    }
    fn burst_interval_pattern_mut(&mut self) -> &mut Option<Arc<Mutex<dyn BurstIntervalPatternTrait>>> {
        &mut self.burst_interval_pattern
    }
    fn creeping_air_barrage(&self) -> &Option<Arc<Mutex<dyn CreepingAirBarrageTrait>>> {
        &self.creeping_air_barrage
    }
    fn creeping_air_barrage_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CreepingAirBarrageTrait>>> {
        &mut self.creeping_air_barrage
    }
    fn spray_pattern(&self) -> &Option<Arc<Mutex<dyn SprayPatternTrait>>> {
        &self.spray_pattern
    }
    fn spray_pattern_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SprayPatternTrait>>> {
        &mut self.spray_pattern
    }
    fn accuracy_hit_box(&self) -> &Option<Arc<Mutex<dyn AccuracyHitBoxTrait>>> {
        &self.accuracy_hit_box
    }
    fn accuracy_hit_box_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AccuracyHitBoxTrait>>> {
        &mut self.accuracy_hit_box
    }
    fn vehicle_aimer_settings(&self) -> &Option<Arc<Mutex<dyn VehicleAimerSettingsTrait>>> {
        &self.vehicle_aimer_settings
    }
    fn vehicle_aimer_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleAimerSettingsTrait>>> {
        &mut self.vehicle_aimer_settings
    }
    fn vision_modifier(&self) -> &Option<Arc<Mutex<dyn VisionModifierTrait>>> {
        &self.vision_modifier
    }
    fn vision_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VisionModifierTrait>>> {
        &mut self.vision_modifier
    }
    fn hearing_modifier(&self) -> &Option<Arc<Mutex<dyn HearingModifierTrait>>> {
        &self.hearing_modifier
    }
    fn hearing_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HearingModifierTrait>>> {
        &mut self.hearing_modifier
    }
    fn target_modifier(&self) -> &Option<Arc<Mutex<dyn TargetModifierTrait>>> {
        &self.target_modifier
    }
    fn target_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TargetModifierTrait>>> {
        &mut self.target_modifier
    }
    fn targeting_settings_override(&self) -> &Option<Arc<Mutex<dyn TargetingDataTrait>>> {
        &self.targeting_settings_override
    }
    fn targeting_settings_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TargetingDataTrait>>> {
        &mut self.targeting_settings_override
    }
    fn vehicle_inaccuracy_settings(&self) -> &Option<Arc<Mutex<dyn VehicleInaccuracySettingsTrait>>> {
        &self.vehicle_inaccuracy_settings
    }
    fn vehicle_inaccuracy_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleInaccuracySettingsTrait>>> {
        &mut self.vehicle_inaccuracy_settings
    }
    fn suppressed_behavior(&self) -> &Option<Arc<Mutex<dyn SuppressedBehaviorTrait>>> {
        &self.suppressed_behavior
    }
    fn suppressed_behavior_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SuppressedBehaviorTrait>>> {
        &mut self.suppressed_behavior
    }
    fn damage_modifier(&self) -> &Option<Arc<Mutex<dyn DamageModifierTrait>>> {
        &self.damage_modifier
    }
    fn damage_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DamageModifierTrait>>> {
        &mut self.damage_modifier
    }
    fn damage_modifier_extended(&self) -> &Option<Arc<Mutex<dyn DamageModifierExtendedTrait>>> {
        &self.damage_modifier_extended
    }
    fn damage_modifier_extended_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DamageModifierExtendedTrait>>> {
        &mut self.damage_modifier_extended
    }
    fn friendly_weapon_restrictions(&self) -> &Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>> {
        &self.friendly_weapon_restrictions
    }
    fn friendly_weapon_restrictions_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>> {
        &mut self.friendly_weapon_restrictions
    }
    fn enemy_weapon_restrictions(&self) -> &Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>> {
        &self.enemy_weapon_restrictions
    }
    fn enemy_weapon_restrictions_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponRestrictionsTrait>>> {
        &mut self.enemy_weapon_restrictions
    }
    fn special_behavior(&self) -> &Option<Arc<Mutex<dyn SpecialBehaviorTrait>>> {
        &self.special_behavior
    }
    fn special_behavior_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SpecialBehaviorTrait>>> {
        &mut self.special_behavior
    }
    fn human_target_hit_probability(&self) -> &Option<Arc<Mutex<dyn WeaponHitProbabilityTrait>>> {
        &self.human_target_hit_probability
    }
    fn human_target_hit_probability_mut(&mut self) -> &mut Option<Arc<Mutex<dyn WeaponHitProbabilityTrait>>> {
        &mut self.human_target_hit_probability
    }
    fn distance_to_aware_curve_override(&self) -> &Option<Arc<Mutex<dyn DistanceToAwareCurveOverrideTrait>>> {
        &self.distance_to_aware_curve_override
    }
    fn distance_to_aware_curve_override_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DistanceToAwareCurveOverrideTrait>>> {
        &mut self.distance_to_aware_curve_override
    }
    fn valid_against(&self) -> &ValidAgainst {
        &self.valid_against
    }
    fn valid_against_mut(&mut self) -> &mut ValidAgainst {
        &mut self.valid_against
    }
    fn target_preference(&self) -> &TargetPreference {
        &self.target_preference
    }
    fn target_preference_mut(&mut self) -> &mut TargetPreference {
        &mut self.target_preference
    }
    fn use_shootspace_for_vision(&self) -> &bool {
        &self.use_shootspace_for_vision
    }
    fn use_shootspace_for_vision_mut(&mut self) -> &mut bool {
        &mut self.use_shootspace_for_vision
    }
    fn target_coordination_priority(&self) -> &f32 {
        &self.target_coordination_priority
    }
    fn target_coordination_priority_mut(&mut self) -> &mut f32 {
        &mut self.target_coordination_priority
    }
    fn exclude_from_target_coordinator(&self) -> &bool {
        &self.exclude_from_target_coordinator
    }
    fn exclude_from_target_coordinator_mut(&mut self) -> &mut bool {
        &mut self.exclude_from_target_coordinator
    }
    fn force_use_target_position(&self) -> &bool {
        &self.force_use_target_position
    }
    fn force_use_target_position_mut(&mut self) -> &mut bool {
        &mut self.force_use_target_position
    }
    fn require_line_of_fire(&self) -> &bool {
        &self.require_line_of_fire
    }
    fn require_line_of_fire_mut(&mut self) -> &mut bool {
        &mut self.require_line_of_fire
    }
    fn min_precision_to_fire(&self) -> &f32 {
        &self.min_precision_to_fire
    }
    fn min_precision_to_fire_mut(&mut self) -> &mut f32 {
        &mut self.min_precision_to_fire
    }
    fn consider_explosion_rounds(&self) -> &bool {
        &self.consider_explosion_rounds
    }
    fn consider_explosion_rounds_mut(&mut self) -> &mut bool {
        &mut self.consider_explosion_rounds
    }
    fn aim_high_for_explosion_rounds(&self) -> &bool {
        &self.aim_high_for_explosion_rounds
    }
    fn aim_high_for_explosion_rounds_mut(&mut self) -> &mut bool {
        &mut self.aim_high_for_explosion_rounds
    }
    fn consider_target_offset(&self) -> &bool {
        &self.consider_target_offset
    }
    fn consider_target_offset_mut(&mut self) -> &mut bool {
        &mut self.consider_target_offset
    }
    fn cancel_explosion_round_if_out_of_range(&self) -> &bool {
        &self.cancel_explosion_round_if_out_of_range
    }
    fn cancel_explosion_round_if_out_of_range_mut(&mut self) -> &mut bool {
        &mut self.cancel_explosion_round_if_out_of_range
    }
    fn weapon_threat_scale(&self) -> &f32 {
        &self.weapon_threat_scale
    }
    fn weapon_threat_scale_mut(&mut self) -> &mut f32 {
        &mut self.weapon_threat_scale
    }
    fn valid_weapon_scale(&self) -> &f32 {
        &self.valid_weapon_scale
    }
    fn valid_weapon_scale_mut(&mut self) -> &mut f32 {
        &mut self.valid_weapon_scale
    }
    fn in_valid_weapon_scale(&self) -> &f32 {
        &self.in_valid_weapon_scale
    }
    fn in_valid_weapon_scale_mut(&mut self) -> &mut f32 {
        &mut self.in_valid_weapon_scale
    }
}

impl super::gameplay_sim::GameAIWeaponDataTrait for AIWeaponData {
}

impl super::core::AssetTrait for AIWeaponData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AIWeaponData {
}

pub static AIWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEAIWEAPONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIWeaponData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FiringWeaponClass",
                flags: MemberInfoFlags::new(0),
                field_type: "FiringWeaponClass",
                rust_offset: offset_of!(AIWeaponData, firing_weapon_class),
            },
            FieldInfoData {
                name: "VoPrimaryFireType",
                flags: MemberInfoFlags::new(0),
                field_type: "VoPrimaryFireType",
                rust_offset: offset_of!(AIWeaponData, vo_primary_fire_type),
            },
            FieldInfoData {
                name: "WeaponRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, weapon_range),
            },
            FieldInfoData {
                name: "MinimumUsageDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, minimum_usage_distance),
            },
            FieldInfoData {
                name: "MaximumUsageDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, maximum_usage_distance),
            },
            FieldInfoData {
                name: "VehicleMaxTargetLOSLost",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, vehicle_max_target_l_o_s_lost),
            },
            FieldInfoData {
                name: "MinEnterVehicleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, min_enter_vehicle_distance),
            },
            FieldInfoData {
                name: "ExitVehicleDisableTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, exit_vehicle_disable_time),
            },
            FieldInfoData {
                name: "UseTargetExtrapolation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, use_target_extrapolation),
            },
            FieldInfoData {
                name: "CausesEvasionOnFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, causes_evasion_on_fire),
            },
            FieldInfoData {
                name: "CreateEvasionNavObstacle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, create_evasion_nav_obstacle),
            },
            FieldInfoData {
                name: "EvasionVolume",
                flags: MemberInfoFlags::new(0),
                field_type: "EvasionVolume",
                rust_offset: offset_of!(AIWeaponData, evasion_volume),
            },
            FieldInfoData {
                name: "PreferredRange",
                flags: MemberInfoFlags::new(0),
                field_type: "PreferredRange",
                rust_offset: offset_of!(AIWeaponData, preferred_range),
            },
            FieldInfoData {
                name: "IndoorPreferredRange",
                flags: MemberInfoFlags::new(0),
                field_type: "PreferredRange",
                rust_offset: offset_of!(AIWeaponData, indoor_preferred_range),
            },
            FieldInfoData {
                name: "OutdoorPreferredRange",
                flags: MemberInfoFlags::new(0),
                field_type: "PreferredRange",
                rust_offset: offset_of!(AIWeaponData, outdoor_preferred_range),
            },
            FieldInfoData {
                name: "FiringIntervalPattern",
                flags: MemberInfoFlags::new(0),
                field_type: "FiringIntervalPattern",
                rust_offset: offset_of!(AIWeaponData, firing_interval_pattern),
            },
            FieldInfoData {
                name: "SustainFiringData",
                flags: MemberInfoFlags::new(0),
                field_type: "SustainFiringData",
                rust_offset: offset_of!(AIWeaponData, sustain_firing_data),
            },
            FieldInfoData {
                name: "BurstIntervalPattern",
                flags: MemberInfoFlags::new(0),
                field_type: "BurstIntervalPattern",
                rust_offset: offset_of!(AIWeaponData, burst_interval_pattern),
            },
            FieldInfoData {
                name: "CreepingAirBarrage",
                flags: MemberInfoFlags::new(0),
                field_type: "CreepingAirBarrage",
                rust_offset: offset_of!(AIWeaponData, creeping_air_barrage),
            },
            FieldInfoData {
                name: "SprayPattern",
                flags: MemberInfoFlags::new(0),
                field_type: "SprayPattern",
                rust_offset: offset_of!(AIWeaponData, spray_pattern),
            },
            FieldInfoData {
                name: "AccuracyHitBox",
                flags: MemberInfoFlags::new(0),
                field_type: "AccuracyHitBox",
                rust_offset: offset_of!(AIWeaponData, accuracy_hit_box),
            },
            FieldInfoData {
                name: "VehicleAimerSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleAimerSettings",
                rust_offset: offset_of!(AIWeaponData, vehicle_aimer_settings),
            },
            FieldInfoData {
                name: "VisionModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "VisionModifier",
                rust_offset: offset_of!(AIWeaponData, vision_modifier),
            },
            FieldInfoData {
                name: "HearingModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "HearingModifier",
                rust_offset: offset_of!(AIWeaponData, hearing_modifier),
            },
            FieldInfoData {
                name: "TargetModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetModifier",
                rust_offset: offset_of!(AIWeaponData, target_modifier),
            },
            FieldInfoData {
                name: "TargetingSettingsOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetingData",
                rust_offset: offset_of!(AIWeaponData, targeting_settings_override),
            },
            FieldInfoData {
                name: "VehicleInaccuracySettings",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleInaccuracySettings",
                rust_offset: offset_of!(AIWeaponData, vehicle_inaccuracy_settings),
            },
            FieldInfoData {
                name: "SuppressedBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "SuppressedBehavior",
                rust_offset: offset_of!(AIWeaponData, suppressed_behavior),
            },
            FieldInfoData {
                name: "DamageModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "DamageModifier",
                rust_offset: offset_of!(AIWeaponData, damage_modifier),
            },
            FieldInfoData {
                name: "DamageModifierExtended",
                flags: MemberInfoFlags::new(0),
                field_type: "DamageModifierExtended",
                rust_offset: offset_of!(AIWeaponData, damage_modifier_extended),
            },
            FieldInfoData {
                name: "FriendlyWeaponRestrictions",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponRestrictions",
                rust_offset: offset_of!(AIWeaponData, friendly_weapon_restrictions),
            },
            FieldInfoData {
                name: "EnemyWeaponRestrictions",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponRestrictions",
                rust_offset: offset_of!(AIWeaponData, enemy_weapon_restrictions),
            },
            FieldInfoData {
                name: "SpecialBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "SpecialBehavior",
                rust_offset: offset_of!(AIWeaponData, special_behavior),
            },
            FieldInfoData {
                name: "HumanTargetHitProbability",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponHitProbability",
                rust_offset: offset_of!(AIWeaponData, human_target_hit_probability),
            },
            FieldInfoData {
                name: "DistanceToAwareCurveOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "DistanceToAwareCurveOverride",
                rust_offset: offset_of!(AIWeaponData, distance_to_aware_curve_override),
            },
            FieldInfoData {
                name: "ValidAgainst",
                flags: MemberInfoFlags::new(0),
                field_type: "ValidAgainst",
                rust_offset: offset_of!(AIWeaponData, valid_against),
            },
            FieldInfoData {
                name: "TargetPreference",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetPreference",
                rust_offset: offset_of!(AIWeaponData, target_preference),
            },
            FieldInfoData {
                name: "UseShootspaceForVision",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, use_shootspace_for_vision),
            },
            FieldInfoData {
                name: "TargetCoordinationPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, target_coordination_priority),
            },
            FieldInfoData {
                name: "ExcludeFromTargetCoordinator",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, exclude_from_target_coordinator),
            },
            FieldInfoData {
                name: "ForceUseTargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, force_use_target_position),
            },
            FieldInfoData {
                name: "RequireLineOfFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, require_line_of_fire),
            },
            FieldInfoData {
                name: "MinPrecisionToFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, min_precision_to_fire),
            },
            FieldInfoData {
                name: "ConsiderExplosionRounds",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, consider_explosion_rounds),
            },
            FieldInfoData {
                name: "AimHighForExplosionRounds",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, aim_high_for_explosion_rounds),
            },
            FieldInfoData {
                name: "ConsiderTargetOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, consider_target_offset),
            },
            FieldInfoData {
                name: "CancelExplosionRoundIfOutOfRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIWeaponData, cancel_explosion_round_if_out_of_range),
            },
            FieldInfoData {
                name: "WeaponThreatScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, weapon_threat_scale),
            },
            FieldInfoData {
                name: "ValidWeaponScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, valid_weapon_scale),
            },
            FieldInfoData {
                name: "InValidWeaponScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIWeaponData, in_valid_weapon_scale),
            },
        ],
    }),
    array_type: Some(AIWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIWeaponData {
    fn type_info(&self) -> &'static TypeInfo {
        AIWEAPONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIWeaponData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TargetingData {
    pub _glacier_base: super::core::DataContainer,
    pub aim_offset_y: f32,
    pub visible_target_limit: f32,
    pub target_lost_timer: f32,
    pub target_distance_evaluation: TinyPiecewiseLinearCurve,
    pub suppression_score: SuppressionValues,
    pub human_suppression_score_multiplier: f32,
    pub suppression_time_limit: f32,
    pub aquired_timer: f32,
    pub aquired_object_timer: f32,
    pub aquired_dist_scale: f32,
    pub target_aiming_timer: f32,
    pub current_human_target_aiming_dist_scale: f32,
    pub low_health_percentage: f32,
    pub current_human_target_low_health_dist_scale: f32,
    pub elevation_above_threshold: f32,
    pub elevation_dist_scale_y: f32,
    pub current_target_dist_scale: f32,
    pub target_visible_dist_scale: f32,
    pub human_preference_scale: f32,
    pub target_object_dist_scale: f32,
    pub balance_distribution: bool,
    pub enable_target_coordinator: bool,
}

pub trait TargetingDataTrait: super::core::DataContainerTrait {
    fn aim_offset_y(&self) -> &f32;
    fn aim_offset_y_mut(&mut self) -> &mut f32;
    fn visible_target_limit(&self) -> &f32;
    fn visible_target_limit_mut(&mut self) -> &mut f32;
    fn target_lost_timer(&self) -> &f32;
    fn target_lost_timer_mut(&mut self) -> &mut f32;
    fn target_distance_evaluation(&self) -> &TinyPiecewiseLinearCurve;
    fn target_distance_evaluation_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn suppression_score(&self) -> &SuppressionValues;
    fn suppression_score_mut(&mut self) -> &mut SuppressionValues;
    fn human_suppression_score_multiplier(&self) -> &f32;
    fn human_suppression_score_multiplier_mut(&mut self) -> &mut f32;
    fn suppression_time_limit(&self) -> &f32;
    fn suppression_time_limit_mut(&mut self) -> &mut f32;
    fn aquired_timer(&self) -> &f32;
    fn aquired_timer_mut(&mut self) -> &mut f32;
    fn aquired_object_timer(&self) -> &f32;
    fn aquired_object_timer_mut(&mut self) -> &mut f32;
    fn aquired_dist_scale(&self) -> &f32;
    fn aquired_dist_scale_mut(&mut self) -> &mut f32;
    fn target_aiming_timer(&self) -> &f32;
    fn target_aiming_timer_mut(&mut self) -> &mut f32;
    fn current_human_target_aiming_dist_scale(&self) -> &f32;
    fn current_human_target_aiming_dist_scale_mut(&mut self) -> &mut f32;
    fn low_health_percentage(&self) -> &f32;
    fn low_health_percentage_mut(&mut self) -> &mut f32;
    fn current_human_target_low_health_dist_scale(&self) -> &f32;
    fn current_human_target_low_health_dist_scale_mut(&mut self) -> &mut f32;
    fn elevation_above_threshold(&self) -> &f32;
    fn elevation_above_threshold_mut(&mut self) -> &mut f32;
    fn elevation_dist_scale_y(&self) -> &f32;
    fn elevation_dist_scale_y_mut(&mut self) -> &mut f32;
    fn current_target_dist_scale(&self) -> &f32;
    fn current_target_dist_scale_mut(&mut self) -> &mut f32;
    fn target_visible_dist_scale(&self) -> &f32;
    fn target_visible_dist_scale_mut(&mut self) -> &mut f32;
    fn human_preference_scale(&self) -> &f32;
    fn human_preference_scale_mut(&mut self) -> &mut f32;
    fn target_object_dist_scale(&self) -> &f32;
    fn target_object_dist_scale_mut(&mut self) -> &mut f32;
    fn balance_distribution(&self) -> &bool;
    fn balance_distribution_mut(&mut self) -> &mut bool;
    fn enable_target_coordinator(&self) -> &bool;
    fn enable_target_coordinator_mut(&mut self) -> &mut bool;
}

impl TargetingDataTrait for TargetingData {
    fn aim_offset_y(&self) -> &f32 {
        &self.aim_offset_y
    }
    fn aim_offset_y_mut(&mut self) -> &mut f32 {
        &mut self.aim_offset_y
    }
    fn visible_target_limit(&self) -> &f32 {
        &self.visible_target_limit
    }
    fn visible_target_limit_mut(&mut self) -> &mut f32 {
        &mut self.visible_target_limit
    }
    fn target_lost_timer(&self) -> &f32 {
        &self.target_lost_timer
    }
    fn target_lost_timer_mut(&mut self) -> &mut f32 {
        &mut self.target_lost_timer
    }
    fn target_distance_evaluation(&self) -> &TinyPiecewiseLinearCurve {
        &self.target_distance_evaluation
    }
    fn target_distance_evaluation_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.target_distance_evaluation
    }
    fn suppression_score(&self) -> &SuppressionValues {
        &self.suppression_score
    }
    fn suppression_score_mut(&mut self) -> &mut SuppressionValues {
        &mut self.suppression_score
    }
    fn human_suppression_score_multiplier(&self) -> &f32 {
        &self.human_suppression_score_multiplier
    }
    fn human_suppression_score_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.human_suppression_score_multiplier
    }
    fn suppression_time_limit(&self) -> &f32 {
        &self.suppression_time_limit
    }
    fn suppression_time_limit_mut(&mut self) -> &mut f32 {
        &mut self.suppression_time_limit
    }
    fn aquired_timer(&self) -> &f32 {
        &self.aquired_timer
    }
    fn aquired_timer_mut(&mut self) -> &mut f32 {
        &mut self.aquired_timer
    }
    fn aquired_object_timer(&self) -> &f32 {
        &self.aquired_object_timer
    }
    fn aquired_object_timer_mut(&mut self) -> &mut f32 {
        &mut self.aquired_object_timer
    }
    fn aquired_dist_scale(&self) -> &f32 {
        &self.aquired_dist_scale
    }
    fn aquired_dist_scale_mut(&mut self) -> &mut f32 {
        &mut self.aquired_dist_scale
    }
    fn target_aiming_timer(&self) -> &f32 {
        &self.target_aiming_timer
    }
    fn target_aiming_timer_mut(&mut self) -> &mut f32 {
        &mut self.target_aiming_timer
    }
    fn current_human_target_aiming_dist_scale(&self) -> &f32 {
        &self.current_human_target_aiming_dist_scale
    }
    fn current_human_target_aiming_dist_scale_mut(&mut self) -> &mut f32 {
        &mut self.current_human_target_aiming_dist_scale
    }
    fn low_health_percentage(&self) -> &f32 {
        &self.low_health_percentage
    }
    fn low_health_percentage_mut(&mut self) -> &mut f32 {
        &mut self.low_health_percentage
    }
    fn current_human_target_low_health_dist_scale(&self) -> &f32 {
        &self.current_human_target_low_health_dist_scale
    }
    fn current_human_target_low_health_dist_scale_mut(&mut self) -> &mut f32 {
        &mut self.current_human_target_low_health_dist_scale
    }
    fn elevation_above_threshold(&self) -> &f32 {
        &self.elevation_above_threshold
    }
    fn elevation_above_threshold_mut(&mut self) -> &mut f32 {
        &mut self.elevation_above_threshold
    }
    fn elevation_dist_scale_y(&self) -> &f32 {
        &self.elevation_dist_scale_y
    }
    fn elevation_dist_scale_y_mut(&mut self) -> &mut f32 {
        &mut self.elevation_dist_scale_y
    }
    fn current_target_dist_scale(&self) -> &f32 {
        &self.current_target_dist_scale
    }
    fn current_target_dist_scale_mut(&mut self) -> &mut f32 {
        &mut self.current_target_dist_scale
    }
    fn target_visible_dist_scale(&self) -> &f32 {
        &self.target_visible_dist_scale
    }
    fn target_visible_dist_scale_mut(&mut self) -> &mut f32 {
        &mut self.target_visible_dist_scale
    }
    fn human_preference_scale(&self) -> &f32 {
        &self.human_preference_scale
    }
    fn human_preference_scale_mut(&mut self) -> &mut f32 {
        &mut self.human_preference_scale
    }
    fn target_object_dist_scale(&self) -> &f32 {
        &self.target_object_dist_scale
    }
    fn target_object_dist_scale_mut(&mut self) -> &mut f32 {
        &mut self.target_object_dist_scale
    }
    fn balance_distribution(&self) -> &bool {
        &self.balance_distribution
    }
    fn balance_distribution_mut(&mut self) -> &mut bool {
        &mut self.balance_distribution
    }
    fn enable_target_coordinator(&self) -> &bool {
        &self.enable_target_coordinator
    }
    fn enable_target_coordinator_mut(&mut self) -> &mut bool {
        &mut self.enable_target_coordinator
    }
}

impl super::core::DataContainerTrait for TargetingData {
}

pub static TARGETINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetingData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TargetingData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AimOffsetY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, aim_offset_y),
            },
            FieldInfoData {
                name: "VisibleTargetLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, visible_target_limit),
            },
            FieldInfoData {
                name: "TargetLostTimer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, target_lost_timer),
            },
            FieldInfoData {
                name: "TargetDistanceEvaluation",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(TargetingData, target_distance_evaluation),
            },
            FieldInfoData {
                name: "SuppressionScore",
                flags: MemberInfoFlags::new(0),
                field_type: "SuppressionValues",
                rust_offset: offset_of!(TargetingData, suppression_score),
            },
            FieldInfoData {
                name: "HumanSuppressionScoreMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, human_suppression_score_multiplier),
            },
            FieldInfoData {
                name: "SuppressionTimeLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, suppression_time_limit),
            },
            FieldInfoData {
                name: "AquiredTimer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, aquired_timer),
            },
            FieldInfoData {
                name: "AquiredObjectTimer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, aquired_object_timer),
            },
            FieldInfoData {
                name: "AquiredDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, aquired_dist_scale),
            },
            FieldInfoData {
                name: "TargetAimingTimer",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, target_aiming_timer),
            },
            FieldInfoData {
                name: "CurrentHumanTargetAimingDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, current_human_target_aiming_dist_scale),
            },
            FieldInfoData {
                name: "LowHealthPercentage",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, low_health_percentage),
            },
            FieldInfoData {
                name: "CurrentHumanTargetLowHealthDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, current_human_target_low_health_dist_scale),
            },
            FieldInfoData {
                name: "ElevationAboveThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, elevation_above_threshold),
            },
            FieldInfoData {
                name: "ElevationDistScaleY",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, elevation_dist_scale_y),
            },
            FieldInfoData {
                name: "CurrentTargetDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, current_target_dist_scale),
            },
            FieldInfoData {
                name: "TargetVisibleDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, target_visible_dist_scale),
            },
            FieldInfoData {
                name: "HumanPreferenceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, human_preference_scale),
            },
            FieldInfoData {
                name: "TargetObjectDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetingData, target_object_dist_scale),
            },
            FieldInfoData {
                name: "BalanceDistribution",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TargetingData, balance_distribution),
            },
            FieldInfoData {
                name: "EnableTargetCoordinator",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TargetingData, enable_target_coordinator),
            },
        ],
    }),
    array_type: Some(TARGETINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TargetingData {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TARGETINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DistanceToAwareCurveOverride {
    pub _glacier_base: super::core::DataContainer,
    pub distance_to_aware_time_curve_central: TinyPiecewiseLinearCurve,
    pub distance_to_aware_time_curve_peripheral: TinyPiecewiseLinearCurve,
}

pub trait DistanceToAwareCurveOverrideTrait: super::core::DataContainerTrait {
    fn distance_to_aware_time_curve_central(&self) -> &TinyPiecewiseLinearCurve;
    fn distance_to_aware_time_curve_central_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
    fn distance_to_aware_time_curve_peripheral(&self) -> &TinyPiecewiseLinearCurve;
    fn distance_to_aware_time_curve_peripheral_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
}

impl DistanceToAwareCurveOverrideTrait for DistanceToAwareCurveOverride {
    fn distance_to_aware_time_curve_central(&self) -> &TinyPiecewiseLinearCurve {
        &self.distance_to_aware_time_curve_central
    }
    fn distance_to_aware_time_curve_central_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.distance_to_aware_time_curve_central
    }
    fn distance_to_aware_time_curve_peripheral(&self) -> &TinyPiecewiseLinearCurve {
        &self.distance_to_aware_time_curve_peripheral
    }
    fn distance_to_aware_time_curve_peripheral_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.distance_to_aware_time_curve_peripheral
    }
}

impl super::core::DataContainerTrait for DistanceToAwareCurveOverride {
}

pub static DISTANCETOAWARECURVEOVERRIDE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistanceToAwareCurveOverride",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DistanceToAwareCurveOverride as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DistanceToAwareTimeCurveCentral",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(DistanceToAwareCurveOverride, distance_to_aware_time_curve_central),
            },
            FieldInfoData {
                name: "DistanceToAwareTimeCurvePeripheral",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(DistanceToAwareCurveOverride, distance_to_aware_time_curve_peripheral),
            },
        ],
    }),
    array_type: Some(DISTANCETOAWARECURVEOVERRIDE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DistanceToAwareCurveOverride {
    fn type_info(&self) -> &'static TypeInfo {
        DISTANCETOAWARECURVEOVERRIDE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DISTANCETOAWARECURVEOVERRIDE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistanceToAwareCurveOverride-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DistanceToAwareCurveOverride"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SuppressionValues {
    pub front: f32,
    pub back: f32,
}

pub trait SuppressionValuesTrait: TypeObject {
    fn front(&self) -> &f32;
    fn front_mut(&mut self) -> &mut f32;
    fn back(&self) -> &f32;
    fn back_mut(&mut self) -> &mut f32;
}

impl SuppressionValuesTrait for SuppressionValues {
    fn front(&self) -> &f32 {
        &self.front
    }
    fn front_mut(&mut self) -> &mut f32 {
        &mut self.front
    }
    fn back(&self) -> &f32 {
        &self.back
    }
    fn back_mut(&mut self) -> &mut f32 {
        &mut self.back
    }
}

pub static SUPPRESSIONVALUES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionValues",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SuppressionValues as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Front",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SuppressionValues, front),
            },
            FieldInfoData {
                name: "Back",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SuppressionValues, back),
            },
        ],
    }),
    array_type: Some(SUPPRESSIONVALUES_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SuppressionValues {
    fn type_info(&self) -> &'static TypeInfo {
        SUPPRESSIONVALUES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SUPPRESSIONVALUES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionValues-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SuppressionValues"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponHitProbability {
    pub _glacier_base: super::core::DataContainer,
    pub distance_to_target: Vec<f32>,
    pub distance_probability: Vec<f32>,
    pub target_visibility: Vec<f32>,
    pub visible_probability: Vec<f32>,
}

pub trait WeaponHitProbabilityTrait: super::core::DataContainerTrait {
    fn distance_to_target(&self) -> &Vec<f32>;
    fn distance_to_target_mut(&mut self) -> &mut Vec<f32>;
    fn distance_probability(&self) -> &Vec<f32>;
    fn distance_probability_mut(&mut self) -> &mut Vec<f32>;
    fn target_visibility(&self) -> &Vec<f32>;
    fn target_visibility_mut(&mut self) -> &mut Vec<f32>;
    fn visible_probability(&self) -> &Vec<f32>;
    fn visible_probability_mut(&mut self) -> &mut Vec<f32>;
}

impl WeaponHitProbabilityTrait for WeaponHitProbability {
    fn distance_to_target(&self) -> &Vec<f32> {
        &self.distance_to_target
    }
    fn distance_to_target_mut(&mut self) -> &mut Vec<f32> {
        &mut self.distance_to_target
    }
    fn distance_probability(&self) -> &Vec<f32> {
        &self.distance_probability
    }
    fn distance_probability_mut(&mut self) -> &mut Vec<f32> {
        &mut self.distance_probability
    }
    fn target_visibility(&self) -> &Vec<f32> {
        &self.target_visibility
    }
    fn target_visibility_mut(&mut self) -> &mut Vec<f32> {
        &mut self.target_visibility
    }
    fn visible_probability(&self) -> &Vec<f32> {
        &self.visible_probability
    }
    fn visible_probability_mut(&mut self) -> &mut Vec<f32> {
        &mut self.visible_probability
    }
}

impl super::core::DataContainerTrait for WeaponHitProbability {
}

pub static WEAPONHITPROBABILITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponHitProbability",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponHitProbability as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DistanceToTarget",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(WeaponHitProbability, distance_to_target),
            },
            FieldInfoData {
                name: "DistanceProbability",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(WeaponHitProbability, distance_probability),
            },
            FieldInfoData {
                name: "TargetVisibility",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(WeaponHitProbability, target_visibility),
            },
            FieldInfoData {
                name: "VisibleProbability",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(WeaponHitProbability, visible_probability),
            },
        ],
    }),
    array_type: Some(WEAPONHITPROBABILITY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponHitProbability {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONHITPROBABILITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONHITPROBABILITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponHitProbability-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WeaponHitProbability"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpecialBehavior {
    pub _glacier_base: super::core::DataContainer,
    pub allow_fire_while_target_is_hidden: bool,
}

pub trait SpecialBehaviorTrait: super::core::DataContainerTrait {
    fn allow_fire_while_target_is_hidden(&self) -> &bool;
    fn allow_fire_while_target_is_hidden_mut(&mut self) -> &mut bool;
}

impl SpecialBehaviorTrait for SpecialBehavior {
    fn allow_fire_while_target_is_hidden(&self) -> &bool {
        &self.allow_fire_while_target_is_hidden
    }
    fn allow_fire_while_target_is_hidden_mut(&mut self) -> &mut bool {
        &mut self.allow_fire_while_target_is_hidden
    }
}

impl super::core::DataContainerTrait for SpecialBehavior {
}

pub static SPECIALBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpecialBehavior",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpecialBehavior as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AllowFireWhileTargetIsHidden",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpecialBehavior, allow_fire_while_target_is_hidden),
            },
        ],
    }),
    array_type: Some(SPECIALBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpecialBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        SPECIALBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPECIALBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpecialBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SpecialBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PreferredRange {
    pub _glacier_base: super::core::DataContainer,
    pub start: f32,
    pub ideal: f32,
    pub end: f32,
}

pub trait PreferredRangeTrait: super::core::DataContainerTrait {
    fn start(&self) -> &f32;
    fn start_mut(&mut self) -> &mut f32;
    fn ideal(&self) -> &f32;
    fn ideal_mut(&mut self) -> &mut f32;
    fn end(&self) -> &f32;
    fn end_mut(&mut self) -> &mut f32;
}

impl PreferredRangeTrait for PreferredRange {
    fn start(&self) -> &f32 {
        &self.start
    }
    fn start_mut(&mut self) -> &mut f32 {
        &mut self.start
    }
    fn ideal(&self) -> &f32 {
        &self.ideal
    }
    fn ideal_mut(&mut self) -> &mut f32 {
        &mut self.ideal
    }
    fn end(&self) -> &f32 {
        &self.end
    }
    fn end_mut(&mut self) -> &mut f32 {
        &mut self.end
    }
}

impl super::core::DataContainerTrait for PreferredRange {
}

pub static PREFERREDRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PreferredRange",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PreferredRange as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PreferredRange, start),
            },
            FieldInfoData {
                name: "Ideal",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PreferredRange, ideal),
            },
            FieldInfoData {
                name: "End",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PreferredRange, end),
            },
        ],
    }),
    array_type: Some(PREFERREDRANGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PreferredRange {
    fn type_info(&self) -> &'static TypeInfo {
        PREFERREDRANGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PREFERREDRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PreferredRange-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PreferredRange"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WeaponRestrictions {
    pub _glacier_base: super::core::DataContainer,
    pub fire_delay_min: f32,
    pub fire_delay_max: f32,
}

pub trait WeaponRestrictionsTrait: super::core::DataContainerTrait {
    fn fire_delay_min(&self) -> &f32;
    fn fire_delay_min_mut(&mut self) -> &mut f32;
    fn fire_delay_max(&self) -> &f32;
    fn fire_delay_max_mut(&mut self) -> &mut f32;
}

impl WeaponRestrictionsTrait for WeaponRestrictions {
    fn fire_delay_min(&self) -> &f32 {
        &self.fire_delay_min
    }
    fn fire_delay_min_mut(&mut self) -> &mut f32 {
        &mut self.fire_delay_min
    }
    fn fire_delay_max(&self) -> &f32 {
        &self.fire_delay_max
    }
    fn fire_delay_max_mut(&mut self) -> &mut f32 {
        &mut self.fire_delay_max
    }
}

impl super::core::DataContainerTrait for WeaponRestrictions {
}

pub static WEAPONRESTRICTIONS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponRestrictions",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WeaponRestrictions as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FireDelayMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponRestrictions, fire_delay_min),
            },
            FieldInfoData {
                name: "FireDelayMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WeaponRestrictions, fire_delay_max),
            },
        ],
    }),
    array_type: Some(WEAPONRESTRICTIONS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponRestrictions {
    fn type_info(&self) -> &'static TypeInfo {
        WEAPONRESTRICTIONS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WEAPONRESTRICTIONS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponRestrictions-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WeaponRestrictions"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DamageModifierExtended {
    pub _glacier_base: super::core::DataContainer,
    pub damage: PiecewiseLinearCurve,
}

pub trait DamageModifierExtendedTrait: super::core::DataContainerTrait {
    fn damage(&self) -> &PiecewiseLinearCurve;
    fn damage_mut(&mut self) -> &mut PiecewiseLinearCurve;
}

impl DamageModifierExtendedTrait for DamageModifierExtended {
    fn damage(&self) -> &PiecewiseLinearCurve {
        &self.damage
    }
    fn damage_mut(&mut self) -> &mut PiecewiseLinearCurve {
        &mut self.damage
    }
}

impl super::core::DataContainerTrait for DamageModifierExtended {
}

pub static DAMAGEMODIFIEREXTENDED_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifierExtended",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DamageModifierExtended as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Damage",
                flags: MemberInfoFlags::new(0),
                field_type: "PiecewiseLinearCurve",
                rust_offset: offset_of!(DamageModifierExtended, damage),
            },
        ],
    }),
    array_type: Some(DAMAGEMODIFIEREXTENDED_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DamageModifierExtended {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEMODIFIEREXTENDED_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DAMAGEMODIFIEREXTENDED_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifierExtended-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DamageModifierExtended"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DamageModifier {
    pub _glacier_base: super::core::DataContainer,
    pub damage: TinyPiecewiseLinearCurve,
}

pub trait DamageModifierTrait: super::core::DataContainerTrait {
    fn damage(&self) -> &TinyPiecewiseLinearCurve;
    fn damage_mut(&mut self) -> &mut TinyPiecewiseLinearCurve;
}

impl DamageModifierTrait for DamageModifier {
    fn damage(&self) -> &TinyPiecewiseLinearCurve {
        &self.damage
    }
    fn damage_mut(&mut self) -> &mut TinyPiecewiseLinearCurve {
        &mut self.damage
    }
}

impl super::core::DataContainerTrait for DamageModifier {
}

pub static DAMAGEMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DamageModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Damage",
                flags: MemberInfoFlags::new(0),
                field_type: "TinyPiecewiseLinearCurve",
                rust_offset: offset_of!(DamageModifier, damage),
            },
        ],
    }),
    array_type: Some(DAMAGEMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DamageModifier {
    fn type_info(&self) -> &'static TypeInfo {
        DAMAGEMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DAMAGEMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DamageModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SuppressedBehavior {
    pub _glacier_base: super::core::DataContainer,
    pub suppressed_time: f32,
    pub target_squad_time: f32,
}

pub trait SuppressedBehaviorTrait: super::core::DataContainerTrait {
    fn suppressed_time(&self) -> &f32;
    fn suppressed_time_mut(&mut self) -> &mut f32;
    fn target_squad_time(&self) -> &f32;
    fn target_squad_time_mut(&mut self) -> &mut f32;
}

impl SuppressedBehaviorTrait for SuppressedBehavior {
    fn suppressed_time(&self) -> &f32 {
        &self.suppressed_time
    }
    fn suppressed_time_mut(&mut self) -> &mut f32 {
        &mut self.suppressed_time
    }
    fn target_squad_time(&self) -> &f32 {
        &self.target_squad_time
    }
    fn target_squad_time_mut(&mut self) -> &mut f32 {
        &mut self.target_squad_time
    }
}

impl super::core::DataContainerTrait for SuppressedBehavior {
}

pub static SUPPRESSEDBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressedBehavior",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SuppressedBehavior as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SuppressedTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SuppressedBehavior, suppressed_time),
            },
            FieldInfoData {
                name: "TargetSquadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SuppressedBehavior, target_squad_time),
            },
        ],
    }),
    array_type: Some(SUPPRESSEDBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SuppressedBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        SUPPRESSEDBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUPPRESSEDBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressedBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SuppressedBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleInaccuracySettings {
    pub _glacier_base: super::core::DataContainer,
    pub reset_on_re_target: bool,
    pub min_aim_angle: f32,
    pub max_aim_angle: f32,
    pub accuracy_increase_speed: f32,
    pub accuracy_decrease_speed: f32,
}

pub trait VehicleInaccuracySettingsTrait: super::core::DataContainerTrait {
    fn reset_on_re_target(&self) -> &bool;
    fn reset_on_re_target_mut(&mut self) -> &mut bool;
    fn min_aim_angle(&self) -> &f32;
    fn min_aim_angle_mut(&mut self) -> &mut f32;
    fn max_aim_angle(&self) -> &f32;
    fn max_aim_angle_mut(&mut self) -> &mut f32;
    fn accuracy_increase_speed(&self) -> &f32;
    fn accuracy_increase_speed_mut(&mut self) -> &mut f32;
    fn accuracy_decrease_speed(&self) -> &f32;
    fn accuracy_decrease_speed_mut(&mut self) -> &mut f32;
}

impl VehicleInaccuracySettingsTrait for VehicleInaccuracySettings {
    fn reset_on_re_target(&self) -> &bool {
        &self.reset_on_re_target
    }
    fn reset_on_re_target_mut(&mut self) -> &mut bool {
        &mut self.reset_on_re_target
    }
    fn min_aim_angle(&self) -> &f32 {
        &self.min_aim_angle
    }
    fn min_aim_angle_mut(&mut self) -> &mut f32 {
        &mut self.min_aim_angle
    }
    fn max_aim_angle(&self) -> &f32 {
        &self.max_aim_angle
    }
    fn max_aim_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_aim_angle
    }
    fn accuracy_increase_speed(&self) -> &f32 {
        &self.accuracy_increase_speed
    }
    fn accuracy_increase_speed_mut(&mut self) -> &mut f32 {
        &mut self.accuracy_increase_speed
    }
    fn accuracy_decrease_speed(&self) -> &f32 {
        &self.accuracy_decrease_speed
    }
    fn accuracy_decrease_speed_mut(&mut self) -> &mut f32 {
        &mut self.accuracy_decrease_speed
    }
}

impl super::core::DataContainerTrait for VehicleInaccuracySettings {
}

pub static VEHICLEINACCURACYSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleInaccuracySettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleInaccuracySettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ResetOnReTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleInaccuracySettings, reset_on_re_target),
            },
            FieldInfoData {
                name: "MinAimAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleInaccuracySettings, min_aim_angle),
            },
            FieldInfoData {
                name: "MaxAimAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleInaccuracySettings, max_aim_angle),
            },
            FieldInfoData {
                name: "AccuracyIncreaseSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleInaccuracySettings, accuracy_increase_speed),
            },
            FieldInfoData {
                name: "AccuracyDecreaseSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleInaccuracySettings, accuracy_decrease_speed),
            },
        ],
    }),
    array_type: Some(VEHICLEINACCURACYSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleInaccuracySettings {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEINACCURACYSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEINACCURACYSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleInaccuracySettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleInaccuracySettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TargetModifier {
    pub _glacier_base: super::core::DataContainer,
    pub squad_suppression: bool,
    pub always_target_human: bool,
}

pub trait TargetModifierTrait: super::core::DataContainerTrait {
    fn squad_suppression(&self) -> &bool;
    fn squad_suppression_mut(&mut self) -> &mut bool;
    fn always_target_human(&self) -> &bool;
    fn always_target_human_mut(&mut self) -> &mut bool;
}

impl TargetModifierTrait for TargetModifier {
    fn squad_suppression(&self) -> &bool {
        &self.squad_suppression
    }
    fn squad_suppression_mut(&mut self) -> &mut bool {
        &mut self.squad_suppression
    }
    fn always_target_human(&self) -> &bool {
        &self.always_target_human
    }
    fn always_target_human_mut(&mut self) -> &mut bool {
        &mut self.always_target_human
    }
}

impl super::core::DataContainerTrait for TargetModifier {
}

pub static TARGETMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TargetModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SquadSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TargetModifier, squad_suppression),
            },
            FieldInfoData {
                name: "AlwaysTargetHuman",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TargetModifier, always_target_human),
            },
        ],
    }),
    array_type: Some(TARGETMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TargetModifier {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TARGETMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FlashlightModifier {
    pub _glacier_base: super::core::DataContainer,
    pub flashlight_cone_range: f32,
    pub flashlight_cone_angle: f32,
}

pub trait FlashlightModifierTrait: super::core::DataContainerTrait {
    fn flashlight_cone_range(&self) -> &f32;
    fn flashlight_cone_range_mut(&mut self) -> &mut f32;
    fn flashlight_cone_angle(&self) -> &f32;
    fn flashlight_cone_angle_mut(&mut self) -> &mut f32;
}

impl FlashlightModifierTrait for FlashlightModifier {
    fn flashlight_cone_range(&self) -> &f32 {
        &self.flashlight_cone_range
    }
    fn flashlight_cone_range_mut(&mut self) -> &mut f32 {
        &mut self.flashlight_cone_range
    }
    fn flashlight_cone_angle(&self) -> &f32 {
        &self.flashlight_cone_angle
    }
    fn flashlight_cone_angle_mut(&mut self) -> &mut f32 {
        &mut self.flashlight_cone_angle
    }
}

impl super::core::DataContainerTrait for FlashlightModifier {
}

pub static FLASHLIGHTMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlashlightModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FlashlightModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FlashlightConeRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlashlightModifier, flashlight_cone_range),
            },
            FieldInfoData {
                name: "FlashlightConeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlashlightModifier, flashlight_cone_angle),
            },
        ],
    }),
    array_type: Some(FLASHLIGHTMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FlashlightModifier {
    fn type_info(&self) -> &'static TypeInfo {
        FLASHLIGHTMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLASHLIGHTMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlashlightModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FlashlightModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HearingModifier {
    pub _glacier_base: super::core::DataContainer,
    pub sensing_shot_fired_distance: f32,
    pub sensing_human_driven_vehicle_distance: f32,
    pub sensing_explosion_distance: f32,
    pub sensing_grenade_distance: f32,
}

pub trait HearingModifierTrait: super::core::DataContainerTrait {
    fn sensing_shot_fired_distance(&self) -> &f32;
    fn sensing_shot_fired_distance_mut(&mut self) -> &mut f32;
    fn sensing_human_driven_vehicle_distance(&self) -> &f32;
    fn sensing_human_driven_vehicle_distance_mut(&mut self) -> &mut f32;
    fn sensing_explosion_distance(&self) -> &f32;
    fn sensing_explosion_distance_mut(&mut self) -> &mut f32;
    fn sensing_grenade_distance(&self) -> &f32;
    fn sensing_grenade_distance_mut(&mut self) -> &mut f32;
}

impl HearingModifierTrait for HearingModifier {
    fn sensing_shot_fired_distance(&self) -> &f32 {
        &self.sensing_shot_fired_distance
    }
    fn sensing_shot_fired_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_shot_fired_distance
    }
    fn sensing_human_driven_vehicle_distance(&self) -> &f32 {
        &self.sensing_human_driven_vehicle_distance
    }
    fn sensing_human_driven_vehicle_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_human_driven_vehicle_distance
    }
    fn sensing_explosion_distance(&self) -> &f32 {
        &self.sensing_explosion_distance
    }
    fn sensing_explosion_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_explosion_distance
    }
    fn sensing_grenade_distance(&self) -> &f32 {
        &self.sensing_grenade_distance
    }
    fn sensing_grenade_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_grenade_distance
    }
}

impl super::core::DataContainerTrait for HearingModifier {
}

pub static HEARINGMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HearingModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HearingModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SensingShotFiredDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HearingModifier, sensing_shot_fired_distance),
            },
            FieldInfoData {
                name: "SensingHumanDrivenVehicleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HearingModifier, sensing_human_driven_vehicle_distance),
            },
            FieldInfoData {
                name: "SensingExplosionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HearingModifier, sensing_explosion_distance),
            },
            FieldInfoData {
                name: "SensingGrenadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HearingModifier, sensing_grenade_distance),
            },
        ],
    }),
    array_type: Some(HEARINGMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HearingModifier {
    fn type_info(&self) -> &'static TypeInfo {
        HEARINGMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HEARINGMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HearingModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("HearingModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VisionModifier {
    pub _glacier_base: super::core::DataContainer,
    pub sensing_cone_range: f32,
    pub sensing_cone_range_when_alerted: f32,
    pub sensing_cone_angle: f32,
    pub sensing_cone_angle_when_alerted: f32,
    pub sensing_cone_angle_above: f32,
    pub sensing_cone_angle_below: f32,
    pub always_see_human: bool,
    pub sensing_static_target_object_distance: f32,
    pub sensing_moving_target_object_distance: f32,
    pub flashlight_modifier: Option<Arc<Mutex<dyn FlashlightModifierTrait>>>,
}

pub trait VisionModifierTrait: super::core::DataContainerTrait {
    fn sensing_cone_range(&self) -> &f32;
    fn sensing_cone_range_mut(&mut self) -> &mut f32;
    fn sensing_cone_range_when_alerted(&self) -> &f32;
    fn sensing_cone_range_when_alerted_mut(&mut self) -> &mut f32;
    fn sensing_cone_angle(&self) -> &f32;
    fn sensing_cone_angle_mut(&mut self) -> &mut f32;
    fn sensing_cone_angle_when_alerted(&self) -> &f32;
    fn sensing_cone_angle_when_alerted_mut(&mut self) -> &mut f32;
    fn sensing_cone_angle_above(&self) -> &f32;
    fn sensing_cone_angle_above_mut(&mut self) -> &mut f32;
    fn sensing_cone_angle_below(&self) -> &f32;
    fn sensing_cone_angle_below_mut(&mut self) -> &mut f32;
    fn always_see_human(&self) -> &bool;
    fn always_see_human_mut(&mut self) -> &mut bool;
    fn sensing_static_target_object_distance(&self) -> &f32;
    fn sensing_static_target_object_distance_mut(&mut self) -> &mut f32;
    fn sensing_moving_target_object_distance(&self) -> &f32;
    fn sensing_moving_target_object_distance_mut(&mut self) -> &mut f32;
    fn flashlight_modifier(&self) -> &Option<Arc<Mutex<dyn FlashlightModifierTrait>>>;
    fn flashlight_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FlashlightModifierTrait>>>;
}

impl VisionModifierTrait for VisionModifier {
    fn sensing_cone_range(&self) -> &f32 {
        &self.sensing_cone_range
    }
    fn sensing_cone_range_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_range
    }
    fn sensing_cone_range_when_alerted(&self) -> &f32 {
        &self.sensing_cone_range_when_alerted
    }
    fn sensing_cone_range_when_alerted_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_range_when_alerted
    }
    fn sensing_cone_angle(&self) -> &f32 {
        &self.sensing_cone_angle
    }
    fn sensing_cone_angle_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_angle
    }
    fn sensing_cone_angle_when_alerted(&self) -> &f32 {
        &self.sensing_cone_angle_when_alerted
    }
    fn sensing_cone_angle_when_alerted_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_angle_when_alerted
    }
    fn sensing_cone_angle_above(&self) -> &f32 {
        &self.sensing_cone_angle_above
    }
    fn sensing_cone_angle_above_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_angle_above
    }
    fn sensing_cone_angle_below(&self) -> &f32 {
        &self.sensing_cone_angle_below
    }
    fn sensing_cone_angle_below_mut(&mut self) -> &mut f32 {
        &mut self.sensing_cone_angle_below
    }
    fn always_see_human(&self) -> &bool {
        &self.always_see_human
    }
    fn always_see_human_mut(&mut self) -> &mut bool {
        &mut self.always_see_human
    }
    fn sensing_static_target_object_distance(&self) -> &f32 {
        &self.sensing_static_target_object_distance
    }
    fn sensing_static_target_object_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_static_target_object_distance
    }
    fn sensing_moving_target_object_distance(&self) -> &f32 {
        &self.sensing_moving_target_object_distance
    }
    fn sensing_moving_target_object_distance_mut(&mut self) -> &mut f32 {
        &mut self.sensing_moving_target_object_distance
    }
    fn flashlight_modifier(&self) -> &Option<Arc<Mutex<dyn FlashlightModifierTrait>>> {
        &self.flashlight_modifier
    }
    fn flashlight_modifier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FlashlightModifierTrait>>> {
        &mut self.flashlight_modifier
    }
}

impl super::core::DataContainerTrait for VisionModifier {
}

pub static VISIONMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisionModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VisionModifier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SensingConeRange",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisionModifier, sensing_cone_range),
            },
            FieldInfoData {
                name: "SensingConeRangeWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisionModifier, sensing_cone_range_when_alerted),
            },
            FieldInfoData {
                name: "SensingConeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisionModifier, sensing_cone_angle),
            },
            FieldInfoData {
                name: "SensingConeAngleWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisionModifier, sensing_cone_angle_when_alerted),
            },
            FieldInfoData {
                name: "SensingConeAngleAbove",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisionModifier, sensing_cone_angle_above),
            },
            FieldInfoData {
                name: "SensingConeAngleBelow",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisionModifier, sensing_cone_angle_below),
            },
            FieldInfoData {
                name: "AlwaysSeeHuman",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VisionModifier, always_see_human),
            },
            FieldInfoData {
                name: "SensingStaticTargetObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisionModifier, sensing_static_target_object_distance),
            },
            FieldInfoData {
                name: "SensingMovingTargetObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VisionModifier, sensing_moving_target_object_distance),
            },
            FieldInfoData {
                name: "FlashlightModifier",
                flags: MemberInfoFlags::new(0),
                field_type: "FlashlightModifier",
                rust_offset: offset_of!(VisionModifier, flashlight_modifier),
            },
        ],
    }),
    array_type: Some(VISIONMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VisionModifier {
    fn type_info(&self) -> &'static TypeInfo {
        VISIONMODIFIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VISIONMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisionModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VisionModifier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EvasionVolume {
    pub _glacier_base: super::core::DataContainer,
    pub volume_width: f32,
    pub volume_height: f32,
    pub volume_depth: f32,
    pub offset_from_center: super::core::Vec3,
}

pub trait EvasionVolumeTrait: super::core::DataContainerTrait {
    fn volume_width(&self) -> &f32;
    fn volume_width_mut(&mut self) -> &mut f32;
    fn volume_height(&self) -> &f32;
    fn volume_height_mut(&mut self) -> &mut f32;
    fn volume_depth(&self) -> &f32;
    fn volume_depth_mut(&mut self) -> &mut f32;
    fn offset_from_center(&self) -> &super::core::Vec3;
    fn offset_from_center_mut(&mut self) -> &mut super::core::Vec3;
}

impl EvasionVolumeTrait for EvasionVolume {
    fn volume_width(&self) -> &f32 {
        &self.volume_width
    }
    fn volume_width_mut(&mut self) -> &mut f32 {
        &mut self.volume_width
    }
    fn volume_height(&self) -> &f32 {
        &self.volume_height
    }
    fn volume_height_mut(&mut self) -> &mut f32 {
        &mut self.volume_height
    }
    fn volume_depth(&self) -> &f32 {
        &self.volume_depth
    }
    fn volume_depth_mut(&mut self) -> &mut f32 {
        &mut self.volume_depth
    }
    fn offset_from_center(&self) -> &super::core::Vec3 {
        &self.offset_from_center
    }
    fn offset_from_center_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.offset_from_center
    }
}

impl super::core::DataContainerTrait for EvasionVolume {
}

pub static EVASIONVOLUME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvasionVolume",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EvasionVolume as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VolumeWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvasionVolume, volume_width),
            },
            FieldInfoData {
                name: "VolumeHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvasionVolume, volume_height),
            },
            FieldInfoData {
                name: "VolumeDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvasionVolume, volume_depth),
            },
            FieldInfoData {
                name: "OffsetFromCenter",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(EvasionVolume, offset_from_center),
            },
        ],
    }),
    array_type: Some(EVASIONVOLUME_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EvasionVolume {
    fn type_info(&self) -> &'static TypeInfo {
        EVASIONVOLUME_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVASIONVOLUME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvasionVolume-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EvasionVolume"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AccuracyHitBox {
    pub _glacier_base: super::core::DataContainer,
    pub aim_box_dist_min: f32,
    pub aim_box_dist_max: f32,
    pub aim_box_dist_far_start: f32,
    pub aim_box_dist_far_end: f32,
    pub aim_box_width_min_dist_min: f32,
    pub aim_box_width_max_dist_min: f32,
    pub aim_box_height_min_dist_min: f32,
    pub aim_box_height_max_dist_min: f32,
    pub aim_box_width_min_dist_max: f32,
    pub aim_box_width_max_dist_max: f32,
    pub aim_box_height_min_dist_max: f32,
    pub aim_box_height_max_dist_max: f32,
    pub aim_box_width_min_dist_far: f32,
    pub aim_box_width_max_dist_far: f32,
    pub aim_box_height_min_dist_far: f32,
    pub aim_box_height_max_dist_far: f32,
}

pub trait AccuracyHitBoxTrait: super::core::DataContainerTrait {
    fn aim_box_dist_min(&self) -> &f32;
    fn aim_box_dist_min_mut(&mut self) -> &mut f32;
    fn aim_box_dist_max(&self) -> &f32;
    fn aim_box_dist_max_mut(&mut self) -> &mut f32;
    fn aim_box_dist_far_start(&self) -> &f32;
    fn aim_box_dist_far_start_mut(&mut self) -> &mut f32;
    fn aim_box_dist_far_end(&self) -> &f32;
    fn aim_box_dist_far_end_mut(&mut self) -> &mut f32;
    fn aim_box_width_min_dist_min(&self) -> &f32;
    fn aim_box_width_min_dist_min_mut(&mut self) -> &mut f32;
    fn aim_box_width_max_dist_min(&self) -> &f32;
    fn aim_box_width_max_dist_min_mut(&mut self) -> &mut f32;
    fn aim_box_height_min_dist_min(&self) -> &f32;
    fn aim_box_height_min_dist_min_mut(&mut self) -> &mut f32;
    fn aim_box_height_max_dist_min(&self) -> &f32;
    fn aim_box_height_max_dist_min_mut(&mut self) -> &mut f32;
    fn aim_box_width_min_dist_max(&self) -> &f32;
    fn aim_box_width_min_dist_max_mut(&mut self) -> &mut f32;
    fn aim_box_width_max_dist_max(&self) -> &f32;
    fn aim_box_width_max_dist_max_mut(&mut self) -> &mut f32;
    fn aim_box_height_min_dist_max(&self) -> &f32;
    fn aim_box_height_min_dist_max_mut(&mut self) -> &mut f32;
    fn aim_box_height_max_dist_max(&self) -> &f32;
    fn aim_box_height_max_dist_max_mut(&mut self) -> &mut f32;
    fn aim_box_width_min_dist_far(&self) -> &f32;
    fn aim_box_width_min_dist_far_mut(&mut self) -> &mut f32;
    fn aim_box_width_max_dist_far(&self) -> &f32;
    fn aim_box_width_max_dist_far_mut(&mut self) -> &mut f32;
    fn aim_box_height_min_dist_far(&self) -> &f32;
    fn aim_box_height_min_dist_far_mut(&mut self) -> &mut f32;
    fn aim_box_height_max_dist_far(&self) -> &f32;
    fn aim_box_height_max_dist_far_mut(&mut self) -> &mut f32;
}

impl AccuracyHitBoxTrait for AccuracyHitBox {
    fn aim_box_dist_min(&self) -> &f32 {
        &self.aim_box_dist_min
    }
    fn aim_box_dist_min_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_dist_min
    }
    fn aim_box_dist_max(&self) -> &f32 {
        &self.aim_box_dist_max
    }
    fn aim_box_dist_max_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_dist_max
    }
    fn aim_box_dist_far_start(&self) -> &f32 {
        &self.aim_box_dist_far_start
    }
    fn aim_box_dist_far_start_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_dist_far_start
    }
    fn aim_box_dist_far_end(&self) -> &f32 {
        &self.aim_box_dist_far_end
    }
    fn aim_box_dist_far_end_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_dist_far_end
    }
    fn aim_box_width_min_dist_min(&self) -> &f32 {
        &self.aim_box_width_min_dist_min
    }
    fn aim_box_width_min_dist_min_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_width_min_dist_min
    }
    fn aim_box_width_max_dist_min(&self) -> &f32 {
        &self.aim_box_width_max_dist_min
    }
    fn aim_box_width_max_dist_min_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_width_max_dist_min
    }
    fn aim_box_height_min_dist_min(&self) -> &f32 {
        &self.aim_box_height_min_dist_min
    }
    fn aim_box_height_min_dist_min_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_height_min_dist_min
    }
    fn aim_box_height_max_dist_min(&self) -> &f32 {
        &self.aim_box_height_max_dist_min
    }
    fn aim_box_height_max_dist_min_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_height_max_dist_min
    }
    fn aim_box_width_min_dist_max(&self) -> &f32 {
        &self.aim_box_width_min_dist_max
    }
    fn aim_box_width_min_dist_max_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_width_min_dist_max
    }
    fn aim_box_width_max_dist_max(&self) -> &f32 {
        &self.aim_box_width_max_dist_max
    }
    fn aim_box_width_max_dist_max_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_width_max_dist_max
    }
    fn aim_box_height_min_dist_max(&self) -> &f32 {
        &self.aim_box_height_min_dist_max
    }
    fn aim_box_height_min_dist_max_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_height_min_dist_max
    }
    fn aim_box_height_max_dist_max(&self) -> &f32 {
        &self.aim_box_height_max_dist_max
    }
    fn aim_box_height_max_dist_max_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_height_max_dist_max
    }
    fn aim_box_width_min_dist_far(&self) -> &f32 {
        &self.aim_box_width_min_dist_far
    }
    fn aim_box_width_min_dist_far_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_width_min_dist_far
    }
    fn aim_box_width_max_dist_far(&self) -> &f32 {
        &self.aim_box_width_max_dist_far
    }
    fn aim_box_width_max_dist_far_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_width_max_dist_far
    }
    fn aim_box_height_min_dist_far(&self) -> &f32 {
        &self.aim_box_height_min_dist_far
    }
    fn aim_box_height_min_dist_far_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_height_min_dist_far
    }
    fn aim_box_height_max_dist_far(&self) -> &f32 {
        &self.aim_box_height_max_dist_far
    }
    fn aim_box_height_max_dist_far_mut(&mut self) -> &mut f32 {
        &mut self.aim_box_height_max_dist_far
    }
}

impl super::core::DataContainerTrait for AccuracyHitBox {
}

pub static ACCURACYHITBOX_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AccuracyHitBox",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AccuracyHitBox as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AimBoxDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_dist_min),
            },
            FieldInfoData {
                name: "AimBoxDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_dist_max),
            },
            FieldInfoData {
                name: "AimBoxDistFarStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_dist_far_start),
            },
            FieldInfoData {
                name: "AimBoxDistFarEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_dist_far_end),
            },
            FieldInfoData {
                name: "AimBoxWidthMinDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_min_dist_min),
            },
            FieldInfoData {
                name: "AimBoxWidthMaxDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_max_dist_min),
            },
            FieldInfoData {
                name: "AimBoxHeightMinDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_min_dist_min),
            },
            FieldInfoData {
                name: "AimBoxHeightMaxDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_max_dist_min),
            },
            FieldInfoData {
                name: "AimBoxWidthMinDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_min_dist_max),
            },
            FieldInfoData {
                name: "AimBoxWidthMaxDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_max_dist_max),
            },
            FieldInfoData {
                name: "AimBoxHeightMinDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_min_dist_max),
            },
            FieldInfoData {
                name: "AimBoxHeightMaxDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_max_dist_max),
            },
            FieldInfoData {
                name: "AimBoxWidthMinDistFar",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_min_dist_far),
            },
            FieldInfoData {
                name: "AimBoxWidthMaxDistFar",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_max_dist_far),
            },
            FieldInfoData {
                name: "AimBoxHeightMinDistFar",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_min_dist_far),
            },
            FieldInfoData {
                name: "AimBoxHeightMaxDistFar",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_max_dist_far),
            },
        ],
    }),
    array_type: Some(ACCURACYHITBOX_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AccuracyHitBox {
    fn type_info(&self) -> &'static TypeInfo {
        ACCURACYHITBOX_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ACCURACYHITBOX_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AccuracyHitBox-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AccuracyHitBox"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SprayPattern {
    pub _glacier_base: super::core::DataContainer,
    pub area_height: f32,
    pub sweep_time_pitch: f32,
    pub area_width: f32,
    pub sweep_time_yaw: f32,
}

pub trait SprayPatternTrait: super::core::DataContainerTrait {
    fn area_height(&self) -> &f32;
    fn area_height_mut(&mut self) -> &mut f32;
    fn sweep_time_pitch(&self) -> &f32;
    fn sweep_time_pitch_mut(&mut self) -> &mut f32;
    fn area_width(&self) -> &f32;
    fn area_width_mut(&mut self) -> &mut f32;
    fn sweep_time_yaw(&self) -> &f32;
    fn sweep_time_yaw_mut(&mut self) -> &mut f32;
}

impl SprayPatternTrait for SprayPattern {
    fn area_height(&self) -> &f32 {
        &self.area_height
    }
    fn area_height_mut(&mut self) -> &mut f32 {
        &mut self.area_height
    }
    fn sweep_time_pitch(&self) -> &f32 {
        &self.sweep_time_pitch
    }
    fn sweep_time_pitch_mut(&mut self) -> &mut f32 {
        &mut self.sweep_time_pitch
    }
    fn area_width(&self) -> &f32 {
        &self.area_width
    }
    fn area_width_mut(&mut self) -> &mut f32 {
        &mut self.area_width
    }
    fn sweep_time_yaw(&self) -> &f32 {
        &self.sweep_time_yaw
    }
    fn sweep_time_yaw_mut(&mut self) -> &mut f32 {
        &mut self.sweep_time_yaw
    }
}

impl super::core::DataContainerTrait for SprayPattern {
}

pub static SPRAYPATTERN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SprayPattern",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SprayPattern as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AreaHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SprayPattern, area_height),
            },
            FieldInfoData {
                name: "SweepTimePitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SprayPattern, sweep_time_pitch),
            },
            FieldInfoData {
                name: "AreaWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SprayPattern, area_width),
            },
            FieldInfoData {
                name: "SweepTimeYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SprayPattern, sweep_time_yaw),
            },
        ],
    }),
    array_type: Some(SPRAYPATTERN_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SprayPattern {
    fn type_info(&self) -> &'static TypeInfo {
        SPRAYPATTERN_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPRAYPATTERN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SprayPattern-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SprayPattern"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CreepingAirBarrage {
    pub _glacier_base: super::core::DataContainer,
    pub start_distance: f32,
    pub time_to_interception_point: f32,
    pub time_at_interception_point: f32,
    pub cooldown: f32,
    pub ahead_of_player_multiplier: f32,
}

pub trait CreepingAirBarrageTrait: super::core::DataContainerTrait {
    fn start_distance(&self) -> &f32;
    fn start_distance_mut(&mut self) -> &mut f32;
    fn time_to_interception_point(&self) -> &f32;
    fn time_to_interception_point_mut(&mut self) -> &mut f32;
    fn time_at_interception_point(&self) -> &f32;
    fn time_at_interception_point_mut(&mut self) -> &mut f32;
    fn cooldown(&self) -> &f32;
    fn cooldown_mut(&mut self) -> &mut f32;
    fn ahead_of_player_multiplier(&self) -> &f32;
    fn ahead_of_player_multiplier_mut(&mut self) -> &mut f32;
}

impl CreepingAirBarrageTrait for CreepingAirBarrage {
    fn start_distance(&self) -> &f32 {
        &self.start_distance
    }
    fn start_distance_mut(&mut self) -> &mut f32 {
        &mut self.start_distance
    }
    fn time_to_interception_point(&self) -> &f32 {
        &self.time_to_interception_point
    }
    fn time_to_interception_point_mut(&mut self) -> &mut f32 {
        &mut self.time_to_interception_point
    }
    fn time_at_interception_point(&self) -> &f32 {
        &self.time_at_interception_point
    }
    fn time_at_interception_point_mut(&mut self) -> &mut f32 {
        &mut self.time_at_interception_point
    }
    fn cooldown(&self) -> &f32 {
        &self.cooldown
    }
    fn cooldown_mut(&mut self) -> &mut f32 {
        &mut self.cooldown
    }
    fn ahead_of_player_multiplier(&self) -> &f32 {
        &self.ahead_of_player_multiplier
    }
    fn ahead_of_player_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.ahead_of_player_multiplier
    }
}

impl super::core::DataContainerTrait for CreepingAirBarrage {
}

pub static CREEPINGAIRBARRAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreepingAirBarrage",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CreepingAirBarrage as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CreepingAirBarrage, start_distance),
            },
            FieldInfoData {
                name: "TimeToInterceptionPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CreepingAirBarrage, time_to_interception_point),
            },
            FieldInfoData {
                name: "TimeAtInterceptionPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CreepingAirBarrage, time_at_interception_point),
            },
            FieldInfoData {
                name: "Cooldown",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CreepingAirBarrage, cooldown),
            },
            FieldInfoData {
                name: "AheadOfPlayerMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CreepingAirBarrage, ahead_of_player_multiplier),
            },
        ],
    }),
    array_type: Some(CREEPINGAIRBARRAGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CreepingAirBarrage {
    fn type_info(&self) -> &'static TypeInfo {
        CREEPINGAIRBARRAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CREEPINGAIRBARRAGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreepingAirBarrage-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CreepingAirBarrage"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BurstIntervalPattern {
    pub _glacier_base: super::core::DataContainer,
    pub burst_interval: Vec<BurstInterval>,
}

pub trait BurstIntervalPatternTrait: super::core::DataContainerTrait {
    fn burst_interval(&self) -> &Vec<BurstInterval>;
    fn burst_interval_mut(&mut self) -> &mut Vec<BurstInterval>;
}

impl BurstIntervalPatternTrait for BurstIntervalPattern {
    fn burst_interval(&self) -> &Vec<BurstInterval> {
        &self.burst_interval
    }
    fn burst_interval_mut(&mut self) -> &mut Vec<BurstInterval> {
        &mut self.burst_interval
    }
}

impl super::core::DataContainerTrait for BurstIntervalPattern {
}

pub static BURSTINTERVALPATTERN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BurstIntervalPattern",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BurstIntervalPattern as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BurstInterval",
                flags: MemberInfoFlags::new(144),
                field_type: "BurstInterval-Array",
                rust_offset: offset_of!(BurstIntervalPattern, burst_interval),
            },
        ],
    }),
    array_type: Some(BURSTINTERVALPATTERN_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BurstIntervalPattern {
    fn type_info(&self) -> &'static TypeInfo {
        BURSTINTERVALPATTERN_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BURSTINTERVALPATTERN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BurstIntervalPattern-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BurstIntervalPattern"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BurstInterval {
    pub burst_length: f32,
    pub burst_length_variation: f32,
    pub time_between_bursts: f32,
    pub time_between_bursts_variation: f32,
}

pub trait BurstIntervalTrait: TypeObject {
    fn burst_length(&self) -> &f32;
    fn burst_length_mut(&mut self) -> &mut f32;
    fn burst_length_variation(&self) -> &f32;
    fn burst_length_variation_mut(&mut self) -> &mut f32;
    fn time_between_bursts(&self) -> &f32;
    fn time_between_bursts_mut(&mut self) -> &mut f32;
    fn time_between_bursts_variation(&self) -> &f32;
    fn time_between_bursts_variation_mut(&mut self) -> &mut f32;
}

impl BurstIntervalTrait for BurstInterval {
    fn burst_length(&self) -> &f32 {
        &self.burst_length
    }
    fn burst_length_mut(&mut self) -> &mut f32 {
        &mut self.burst_length
    }
    fn burst_length_variation(&self) -> &f32 {
        &self.burst_length_variation
    }
    fn burst_length_variation_mut(&mut self) -> &mut f32 {
        &mut self.burst_length_variation
    }
    fn time_between_bursts(&self) -> &f32 {
        &self.time_between_bursts
    }
    fn time_between_bursts_mut(&mut self) -> &mut f32 {
        &mut self.time_between_bursts
    }
    fn time_between_bursts_variation(&self) -> &f32 {
        &self.time_between_bursts_variation
    }
    fn time_between_bursts_variation_mut(&mut self) -> &mut f32 {
        &mut self.time_between_bursts_variation
    }
}

pub static BURSTINTERVAL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BurstInterval",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BurstInterval as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BurstLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BurstInterval, burst_length),
            },
            FieldInfoData {
                name: "BurstLengthVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BurstInterval, burst_length_variation),
            },
            FieldInfoData {
                name: "TimeBetweenBursts",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BurstInterval, time_between_bursts),
            },
            FieldInfoData {
                name: "TimeBetweenBurstsVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BurstInterval, time_between_bursts_variation),
            },
        ],
    }),
    array_type: Some(BURSTINTERVAL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BurstInterval {
    fn type_info(&self) -> &'static TypeInfo {
        BURSTINTERVAL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BURSTINTERVAL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BurstInterval-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BurstInterval"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SustainFiringData {
    pub _glacier_base: super::core::DataContainer,
    pub fire_style: SustainFiringFireStyle,
    pub spin_up_duration: f32,
    pub sustain_fire_time_min: f32,
    pub sustain_fire_time_max: f32,
    pub cooldown_duration_min: f32,
    pub cooldown_duration_max: f32,
    pub tracking_rate: f32,
    pub sweep_area_settings: Option<Arc<Mutex<dyn SustainFiringSweepAreaSettingsTrait>>>,
    pub stop_sustain_fire_when_shot_at: bool,
    pub is_allowed_to_move: bool,
}

pub trait SustainFiringDataTrait: super::core::DataContainerTrait {
    fn fire_style(&self) -> &SustainFiringFireStyle;
    fn fire_style_mut(&mut self) -> &mut SustainFiringFireStyle;
    fn spin_up_duration(&self) -> &f32;
    fn spin_up_duration_mut(&mut self) -> &mut f32;
    fn sustain_fire_time_min(&self) -> &f32;
    fn sustain_fire_time_min_mut(&mut self) -> &mut f32;
    fn sustain_fire_time_max(&self) -> &f32;
    fn sustain_fire_time_max_mut(&mut self) -> &mut f32;
    fn cooldown_duration_min(&self) -> &f32;
    fn cooldown_duration_min_mut(&mut self) -> &mut f32;
    fn cooldown_duration_max(&self) -> &f32;
    fn cooldown_duration_max_mut(&mut self) -> &mut f32;
    fn tracking_rate(&self) -> &f32;
    fn tracking_rate_mut(&mut self) -> &mut f32;
    fn sweep_area_settings(&self) -> &Option<Arc<Mutex<dyn SustainFiringSweepAreaSettingsTrait>>>;
    fn sweep_area_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SustainFiringSweepAreaSettingsTrait>>>;
    fn stop_sustain_fire_when_shot_at(&self) -> &bool;
    fn stop_sustain_fire_when_shot_at_mut(&mut self) -> &mut bool;
    fn is_allowed_to_move(&self) -> &bool;
    fn is_allowed_to_move_mut(&mut self) -> &mut bool;
}

impl SustainFiringDataTrait for SustainFiringData {
    fn fire_style(&self) -> &SustainFiringFireStyle {
        &self.fire_style
    }
    fn fire_style_mut(&mut self) -> &mut SustainFiringFireStyle {
        &mut self.fire_style
    }
    fn spin_up_duration(&self) -> &f32 {
        &self.spin_up_duration
    }
    fn spin_up_duration_mut(&mut self) -> &mut f32 {
        &mut self.spin_up_duration
    }
    fn sustain_fire_time_min(&self) -> &f32 {
        &self.sustain_fire_time_min
    }
    fn sustain_fire_time_min_mut(&mut self) -> &mut f32 {
        &mut self.sustain_fire_time_min
    }
    fn sustain_fire_time_max(&self) -> &f32 {
        &self.sustain_fire_time_max
    }
    fn sustain_fire_time_max_mut(&mut self) -> &mut f32 {
        &mut self.sustain_fire_time_max
    }
    fn cooldown_duration_min(&self) -> &f32 {
        &self.cooldown_duration_min
    }
    fn cooldown_duration_min_mut(&mut self) -> &mut f32 {
        &mut self.cooldown_duration_min
    }
    fn cooldown_duration_max(&self) -> &f32 {
        &self.cooldown_duration_max
    }
    fn cooldown_duration_max_mut(&mut self) -> &mut f32 {
        &mut self.cooldown_duration_max
    }
    fn tracking_rate(&self) -> &f32 {
        &self.tracking_rate
    }
    fn tracking_rate_mut(&mut self) -> &mut f32 {
        &mut self.tracking_rate
    }
    fn sweep_area_settings(&self) -> &Option<Arc<Mutex<dyn SustainFiringSweepAreaSettingsTrait>>> {
        &self.sweep_area_settings
    }
    fn sweep_area_settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SustainFiringSweepAreaSettingsTrait>>> {
        &mut self.sweep_area_settings
    }
    fn stop_sustain_fire_when_shot_at(&self) -> &bool {
        &self.stop_sustain_fire_when_shot_at
    }
    fn stop_sustain_fire_when_shot_at_mut(&mut self) -> &mut bool {
        &mut self.stop_sustain_fire_when_shot_at
    }
    fn is_allowed_to_move(&self) -> &bool {
        &self.is_allowed_to_move
    }
    fn is_allowed_to_move_mut(&mut self) -> &mut bool {
        &mut self.is_allowed_to_move
    }
}

impl super::core::DataContainerTrait for SustainFiringData {
}

pub static SUSTAINFIRINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SustainFiringData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FireStyle",
                flags: MemberInfoFlags::new(0),
                field_type: "SustainFiringFireStyle",
                rust_offset: offset_of!(SustainFiringData, fire_style),
            },
            FieldInfoData {
                name: "SpinUpDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringData, spin_up_duration),
            },
            FieldInfoData {
                name: "SustainFireTimeMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringData, sustain_fire_time_min),
            },
            FieldInfoData {
                name: "SustainFireTimeMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringData, sustain_fire_time_max),
            },
            FieldInfoData {
                name: "CooldownDurationMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringData, cooldown_duration_min),
            },
            FieldInfoData {
                name: "CooldownDurationMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringData, cooldown_duration_max),
            },
            FieldInfoData {
                name: "TrackingRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringData, tracking_rate),
            },
            FieldInfoData {
                name: "SweepAreaSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "SustainFiringSweepAreaSettings",
                rust_offset: offset_of!(SustainFiringData, sweep_area_settings),
            },
            FieldInfoData {
                name: "StopSustainFireWhenShotAt",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SustainFiringData, stop_sustain_fire_when_shot_at),
            },
            FieldInfoData {
                name: "IsAllowedToMove",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SustainFiringData, is_allowed_to_move),
            },
        ],
    }),
    array_type: Some(SUSTAINFIRINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SustainFiringData {
    fn type_info(&self) -> &'static TypeInfo {
        SUSTAINFIRINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUSTAINFIRINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SustainFiringSweepAreaSettings {
    pub _glacier_base: super::core::DataContainer,
    pub sweep_arc_width: f32,
    pub minimum_sweep_movement: f32,
    pub sweep_rate: f32,
    pub post_sweep_pause_duration: f32,
    pub start_sweep_from_edge_of_arc: bool,
}

pub trait SustainFiringSweepAreaSettingsTrait: super::core::DataContainerTrait {
    fn sweep_arc_width(&self) -> &f32;
    fn sweep_arc_width_mut(&mut self) -> &mut f32;
    fn minimum_sweep_movement(&self) -> &f32;
    fn minimum_sweep_movement_mut(&mut self) -> &mut f32;
    fn sweep_rate(&self) -> &f32;
    fn sweep_rate_mut(&mut self) -> &mut f32;
    fn post_sweep_pause_duration(&self) -> &f32;
    fn post_sweep_pause_duration_mut(&mut self) -> &mut f32;
    fn start_sweep_from_edge_of_arc(&self) -> &bool;
    fn start_sweep_from_edge_of_arc_mut(&mut self) -> &mut bool;
}

impl SustainFiringSweepAreaSettingsTrait for SustainFiringSweepAreaSettings {
    fn sweep_arc_width(&self) -> &f32 {
        &self.sweep_arc_width
    }
    fn sweep_arc_width_mut(&mut self) -> &mut f32 {
        &mut self.sweep_arc_width
    }
    fn minimum_sweep_movement(&self) -> &f32 {
        &self.minimum_sweep_movement
    }
    fn minimum_sweep_movement_mut(&mut self) -> &mut f32 {
        &mut self.minimum_sweep_movement
    }
    fn sweep_rate(&self) -> &f32 {
        &self.sweep_rate
    }
    fn sweep_rate_mut(&mut self) -> &mut f32 {
        &mut self.sweep_rate
    }
    fn post_sweep_pause_duration(&self) -> &f32 {
        &self.post_sweep_pause_duration
    }
    fn post_sweep_pause_duration_mut(&mut self) -> &mut f32 {
        &mut self.post_sweep_pause_duration
    }
    fn start_sweep_from_edge_of_arc(&self) -> &bool {
        &self.start_sweep_from_edge_of_arc
    }
    fn start_sweep_from_edge_of_arc_mut(&mut self) -> &mut bool {
        &mut self.start_sweep_from_edge_of_arc
    }
}

impl super::core::DataContainerTrait for SustainFiringSweepAreaSettings {
}

pub static SUSTAINFIRINGSWEEPAREASETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringSweepAreaSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SustainFiringSweepAreaSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SweepArcWidth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, sweep_arc_width),
            },
            FieldInfoData {
                name: "MinimumSweepMovement",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, minimum_sweep_movement),
            },
            FieldInfoData {
                name: "SweepRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, sweep_rate),
            },
            FieldInfoData {
                name: "PostSweepPauseDuration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, post_sweep_pause_duration),
            },
            FieldInfoData {
                name: "StartSweepFromEdgeOfArc",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, start_sweep_from_edge_of_arc),
            },
        ],
    }),
    array_type: Some(SUSTAINFIRINGSWEEPAREASETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SustainFiringSweepAreaSettings {
    fn type_info(&self) -> &'static TypeInfo {
        SUSTAINFIRINGSWEEPAREASETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SUSTAINFIRINGSWEEPAREASETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringSweepAreaSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringSweepAreaSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SustainFiringState {
    #[default]
    SustainFiringState_Ready = 0,
    SustainFiringState_SpinUp = 1,
    SustainFiringState_BeginFiring = 2,
    SustainFiringState_Sustain = 3,
    SustainFiringState_Cooldown = 4,
}

pub static SUSTAINFIRINGSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SUSTAINFIRINGSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SustainFiringState {
    fn type_info(&self) -> &'static TypeInfo {
        SUSTAINFIRINGSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SUSTAINFIRINGSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringState"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SustainFiringFireStyle {
    #[default]
    SustainFiringFireStyle_TrackTarget = 0,
    SustainFiringFireStyle_SweepArea = 1,
}

pub static SUSTAINFIRINGFIRESTYLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringFireStyle",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SUSTAINFIRINGFIRESTYLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SustainFiringFireStyle {
    fn type_info(&self) -> &'static TypeInfo {
        SUSTAINFIRINGFIRESTYLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SUSTAINFIRINGFIRESTYLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringFireStyle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringFireStyle"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SustainFiringSweepAreaState {
    #[default]
    SweepAreaState_Init = 0,
    SweepAreaState_Ready = 1,
    SweepAreaState_Begin = 2,
    SweepAreaState_Moving = 3,
}

pub static SUSTAINFIRINGSWEEPAREASTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringSweepAreaState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SUSTAINFIRINGSWEEPAREASTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SustainFiringSweepAreaState {
    fn type_info(&self) -> &'static TypeInfo {
        SUSTAINFIRINGSWEEPAREASTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SUSTAINFIRINGSWEEPAREASTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringSweepAreaState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringSweepAreaState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FiringIntervalPattern {
    pub _glacier_base: super::core::DataContainer,
    pub interval: Vec<Interval>,
}

pub trait FiringIntervalPatternTrait: super::core::DataContainerTrait {
    fn interval(&self) -> &Vec<Interval>;
    fn interval_mut(&mut self) -> &mut Vec<Interval>;
}

impl FiringIntervalPatternTrait for FiringIntervalPattern {
    fn interval(&self) -> &Vec<Interval> {
        &self.interval
    }
    fn interval_mut(&mut self) -> &mut Vec<Interval> {
        &mut self.interval
    }
}

impl super::core::DataContainerTrait for FiringIntervalPattern {
}

pub static FIRINGINTERVALPATTERN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringIntervalPattern",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FiringIntervalPattern as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Interval",
                flags: MemberInfoFlags::new(144),
                field_type: "Interval-Array",
                rust_offset: offset_of!(FiringIntervalPattern, interval),
            },
        ],
    }),
    array_type: Some(FIRINGINTERVALPATTERN_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FiringIntervalPattern {
    fn type_info(&self) -> &'static TypeInfo {
        FIRINGINTERVALPATTERN_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FIRINGINTERVALPATTERN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringIntervalPattern-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FiringIntervalPattern"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleAimerSettings {
    pub _glacier_base: super::core::DataContainer,
    pub is_parabolic: bool,
    pub aim_high: bool,
    pub min_precision_to_fire: f32,
    pub track_towards_target: bool,
    pub track_beyond_target: bool,
}

pub trait VehicleAimerSettingsTrait: super::core::DataContainerTrait {
    fn is_parabolic(&self) -> &bool;
    fn is_parabolic_mut(&mut self) -> &mut bool;
    fn aim_high(&self) -> &bool;
    fn aim_high_mut(&mut self) -> &mut bool;
    fn min_precision_to_fire(&self) -> &f32;
    fn min_precision_to_fire_mut(&mut self) -> &mut f32;
    fn track_towards_target(&self) -> &bool;
    fn track_towards_target_mut(&mut self) -> &mut bool;
    fn track_beyond_target(&self) -> &bool;
    fn track_beyond_target_mut(&mut self) -> &mut bool;
}

impl VehicleAimerSettingsTrait for VehicleAimerSettings {
    fn is_parabolic(&self) -> &bool {
        &self.is_parabolic
    }
    fn is_parabolic_mut(&mut self) -> &mut bool {
        &mut self.is_parabolic
    }
    fn aim_high(&self) -> &bool {
        &self.aim_high
    }
    fn aim_high_mut(&mut self) -> &mut bool {
        &mut self.aim_high
    }
    fn min_precision_to_fire(&self) -> &f32 {
        &self.min_precision_to_fire
    }
    fn min_precision_to_fire_mut(&mut self) -> &mut f32 {
        &mut self.min_precision_to_fire
    }
    fn track_towards_target(&self) -> &bool {
        &self.track_towards_target
    }
    fn track_towards_target_mut(&mut self) -> &mut bool {
        &mut self.track_towards_target
    }
    fn track_beyond_target(&self) -> &bool {
        &self.track_beyond_target
    }
    fn track_beyond_target_mut(&mut self) -> &mut bool {
        &mut self.track_beyond_target
    }
}

impl super::core::DataContainerTrait for VehicleAimerSettings {
}

pub static VEHICLEAIMERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleAimerSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleAimerSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsParabolic",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleAimerSettings, is_parabolic),
            },
            FieldInfoData {
                name: "AimHigh",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleAimerSettings, aim_high),
            },
            FieldInfoData {
                name: "MinPrecisionToFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleAimerSettings, min_precision_to_fire),
            },
            FieldInfoData {
                name: "TrackTowardsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleAimerSettings, track_towards_target),
            },
            FieldInfoData {
                name: "TrackBeyondTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleAimerSettings, track_beyond_target),
            },
        ],
    }),
    array_type: Some(VEHICLEAIMERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleAimerSettings {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEAIMERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLEAIMERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleAimerSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleAimerSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Interval {
    pub minimum_time: f32,
    pub maximum_time: f32,
}

pub trait IntervalTrait: TypeObject {
    fn minimum_time(&self) -> &f32;
    fn minimum_time_mut(&mut self) -> &mut f32;
    fn maximum_time(&self) -> &f32;
    fn maximum_time_mut(&mut self) -> &mut f32;
}

impl IntervalTrait for Interval {
    fn minimum_time(&self) -> &f32 {
        &self.minimum_time
    }
    fn minimum_time_mut(&mut self) -> &mut f32 {
        &mut self.minimum_time
    }
    fn maximum_time(&self) -> &f32 {
        &self.maximum_time
    }
    fn maximum_time_mut(&mut self) -> &mut f32 {
        &mut self.maximum_time
    }
}

pub static INTERVAL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Interval",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Interval as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinimumTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Interval, minimum_time),
            },
            FieldInfoData {
                name: "MaximumTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Interval, maximum_time),
            },
        ],
    }),
    array_type: Some(INTERVAL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Interval {
    fn type_info(&self) -> &'static TypeInfo {
        INTERVAL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static INTERVAL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Interval-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Interval"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoPrimaryFireType {
    #[default]
    VoPrimaryFireType_AssaultRifle = 4294967295,
    VoPrimaryFireType_MachineGun = 4294967294,
    VoPrimaryFireType_Pistol = 4294967293,
    VoPrimaryFireType_SniperRifle = 4294967292,
    VoPrimaryFireType_SMG = 4294967291,
}

pub static VOPRIMARYFIRETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoPrimaryFireType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(VOPRIMARYFIRETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoPrimaryFireType {
    fn type_info(&self) -> &'static TypeInfo {
        VOPRIMARYFIRETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOPRIMARYFIRETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoPrimaryFireType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VoPrimaryFireType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CombatEnvironment {
    #[default]
    CombatEnvironment_Default = 0,
    CombatEnvironment_Indoor = 1,
    CombatEnvironment_Outdoor = 2,
}

pub static COMBATENVIRONMENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatEnvironment",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COMBATENVIRONMENT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CombatEnvironment {
    fn type_info(&self) -> &'static TypeInfo {
        COMBATENVIRONMENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COMBATENVIRONMENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatEnvironment-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CombatEnvironment"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TargetPreference {
    #[default]
    TargetPreference_Soldiers = 0,
    TargetPreference_Vehicles = 1,
}

pub static TARGETPREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetPreference",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(TARGETPREFERENCE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TargetPreference {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETPREFERENCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TARGETPREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetPreference-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetPreference"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ValidAgainst {
    #[default]
    ValidAgainst_Nothing = 0,
    ValidAgainst_Soldiers = 1,
    ValidAgainst_SoldiersAndUnshieldedVehicles = 2,
    ValidAgainst_UnshieldedVehicles = 3,
    ValidAgainst_ShieldedVehicles = 4,
    ValidAgainst_AllVehicles = 5,
    ValidAgainst_All = 6,
    ValidAgainst_HumanSoldiers = 7,
}

pub static VALIDAGAINST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidAgainst",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(VALIDAGAINST_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ValidAgainst {
    fn type_info(&self) -> &'static TypeInfo {
        VALIDAGAINST_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VALIDAGAINST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidAgainst-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ValidAgainst"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIVehicleCombatEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub use_path_finding: bool,
    pub exclusive_combat_zones: bool,
    pub settings: Option<Arc<Mutex<dyn VehicleCombatSettingsTrait>>>,
    pub is_alerted: bool,
    pub occupying_ai_id: i32,
    pub last_known_location: super::core::Vec3,
    pub actual_location: super::core::Vec3,
    pub time_since_visible: f32,
    pub best_target_angle: f32,
    pub is_vehicle_target: bool,
    pub patrol_speed: f32,
    pub combat_speed: f32,
    pub allow_fire_while_following: bool,
}

pub trait AIVehicleCombatEntityDataTrait: super::entity::EntityDataTrait {
    fn use_path_finding(&self) -> &bool;
    fn use_path_finding_mut(&mut self) -> &mut bool;
    fn exclusive_combat_zones(&self) -> &bool;
    fn exclusive_combat_zones_mut(&mut self) -> &mut bool;
    fn settings(&self) -> &Option<Arc<Mutex<dyn VehicleCombatSettingsTrait>>>;
    fn settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleCombatSettingsTrait>>>;
    fn is_alerted(&self) -> &bool;
    fn is_alerted_mut(&mut self) -> &mut bool;
    fn occupying_ai_id(&self) -> &i32;
    fn occupying_ai_id_mut(&mut self) -> &mut i32;
    fn last_known_location(&self) -> &super::core::Vec3;
    fn last_known_location_mut(&mut self) -> &mut super::core::Vec3;
    fn actual_location(&self) -> &super::core::Vec3;
    fn actual_location_mut(&mut self) -> &mut super::core::Vec3;
    fn time_since_visible(&self) -> &f32;
    fn time_since_visible_mut(&mut self) -> &mut f32;
    fn best_target_angle(&self) -> &f32;
    fn best_target_angle_mut(&mut self) -> &mut f32;
    fn is_vehicle_target(&self) -> &bool;
    fn is_vehicle_target_mut(&mut self) -> &mut bool;
    fn patrol_speed(&self) -> &f32;
    fn patrol_speed_mut(&mut self) -> &mut f32;
    fn combat_speed(&self) -> &f32;
    fn combat_speed_mut(&mut self) -> &mut f32;
    fn allow_fire_while_following(&self) -> &bool;
    fn allow_fire_while_following_mut(&mut self) -> &mut bool;
}

impl AIVehicleCombatEntityDataTrait for AIVehicleCombatEntityData {
    fn use_path_finding(&self) -> &bool {
        &self.use_path_finding
    }
    fn use_path_finding_mut(&mut self) -> &mut bool {
        &mut self.use_path_finding
    }
    fn exclusive_combat_zones(&self) -> &bool {
        &self.exclusive_combat_zones
    }
    fn exclusive_combat_zones_mut(&mut self) -> &mut bool {
        &mut self.exclusive_combat_zones
    }
    fn settings(&self) -> &Option<Arc<Mutex<dyn VehicleCombatSettingsTrait>>> {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VehicleCombatSettingsTrait>>> {
        &mut self.settings
    }
    fn is_alerted(&self) -> &bool {
        &self.is_alerted
    }
    fn is_alerted_mut(&mut self) -> &mut bool {
        &mut self.is_alerted
    }
    fn occupying_ai_id(&self) -> &i32 {
        &self.occupying_ai_id
    }
    fn occupying_ai_id_mut(&mut self) -> &mut i32 {
        &mut self.occupying_ai_id
    }
    fn last_known_location(&self) -> &super::core::Vec3 {
        &self.last_known_location
    }
    fn last_known_location_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.last_known_location
    }
    fn actual_location(&self) -> &super::core::Vec3 {
        &self.actual_location
    }
    fn actual_location_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.actual_location
    }
    fn time_since_visible(&self) -> &f32 {
        &self.time_since_visible
    }
    fn time_since_visible_mut(&mut self) -> &mut f32 {
        &mut self.time_since_visible
    }
    fn best_target_angle(&self) -> &f32 {
        &self.best_target_angle
    }
    fn best_target_angle_mut(&mut self) -> &mut f32 {
        &mut self.best_target_angle
    }
    fn is_vehicle_target(&self) -> &bool {
        &self.is_vehicle_target
    }
    fn is_vehicle_target_mut(&mut self) -> &mut bool {
        &mut self.is_vehicle_target
    }
    fn patrol_speed(&self) -> &f32 {
        &self.patrol_speed
    }
    fn patrol_speed_mut(&mut self) -> &mut f32 {
        &mut self.patrol_speed
    }
    fn combat_speed(&self) -> &f32 {
        &self.combat_speed
    }
    fn combat_speed_mut(&mut self) -> &mut f32 {
        &mut self.combat_speed
    }
    fn allow_fire_while_following(&self) -> &bool {
        &self.allow_fire_while_following
    }
    fn allow_fire_while_following_mut(&mut self) -> &mut bool {
        &mut self.allow_fire_while_following
    }
}

impl super::entity::EntityDataTrait for AIVehicleCombatEntityData {
}

impl super::entity::GameObjectDataTrait for AIVehicleCombatEntityData {
}

impl super::core::DataBusPeerTrait for AIVehicleCombatEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIVehicleCombatEntityData {
}

impl super::core::DataContainerTrait for AIVehicleCombatEntityData {
}

pub static AIVEHICLECOMBATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleCombatEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIVehicleCombatEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UsePathFinding",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIVehicleCombatEntityData, use_path_finding),
            },
            FieldInfoData {
                name: "ExclusiveCombatZones",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIVehicleCombatEntityData, exclusive_combat_zones),
            },
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleCombatSettings",
                rust_offset: offset_of!(AIVehicleCombatEntityData, settings),
            },
            FieldInfoData {
                name: "IsAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIVehicleCombatEntityData, is_alerted),
            },
            FieldInfoData {
                name: "OccupyingAiId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AIVehicleCombatEntityData, occupying_ai_id),
            },
            FieldInfoData {
                name: "LastKnownLocation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AIVehicleCombatEntityData, last_known_location),
            },
            FieldInfoData {
                name: "ActualLocation",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AIVehicleCombatEntityData, actual_location),
            },
            FieldInfoData {
                name: "TimeSinceVisible",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleCombatEntityData, time_since_visible),
            },
            FieldInfoData {
                name: "BestTargetAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleCombatEntityData, best_target_angle),
            },
            FieldInfoData {
                name: "IsVehicleTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIVehicleCombatEntityData, is_vehicle_target),
            },
            FieldInfoData {
                name: "PatrolSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleCombatEntityData, patrol_speed),
            },
            FieldInfoData {
                name: "CombatSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleCombatEntityData, combat_speed),
            },
            FieldInfoData {
                name: "AllowFireWhileFollowing",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIVehicleCombatEntityData, allow_fire_while_following),
            },
        ],
    }),
    array_type: Some(AIVEHICLECOMBATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIVehicleCombatEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIVEHICLECOMBATENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIVEHICLECOMBATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleCombatEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIVehicleCombatEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleCombatSettings {
    pub _glacier_base: super::core::Asset,
    pub use_simple_behavior: bool,
    pub distances: Distances,
    pub never_lose_interest_distance: f32,
    pub lose_interest_time: f32,
    pub sixth_sense_radius: f32,
    pub forget_target_distance: f32,
    pub interrupt_on_damage: bool,
    pub stop_and_fire_timeout: f32,
    pub move_timeout: f32,
    pub combat_settings: CombatSettings,
    pub evade_settings: EvadeSettings,
    pub vehicle_vs_vehicle: VehicleVsVehicle,
    pub vehicle_vs_soldier: VehicleVsSoldier,
    pub turn_to_align_weapons: bool,
}

pub trait VehicleCombatSettingsTrait: super::core::AssetTrait {
    fn use_simple_behavior(&self) -> &bool;
    fn use_simple_behavior_mut(&mut self) -> &mut bool;
    fn distances(&self) -> &Distances;
    fn distances_mut(&mut self) -> &mut Distances;
    fn never_lose_interest_distance(&self) -> &f32;
    fn never_lose_interest_distance_mut(&mut self) -> &mut f32;
    fn lose_interest_time(&self) -> &f32;
    fn lose_interest_time_mut(&mut self) -> &mut f32;
    fn sixth_sense_radius(&self) -> &f32;
    fn sixth_sense_radius_mut(&mut self) -> &mut f32;
    fn forget_target_distance(&self) -> &f32;
    fn forget_target_distance_mut(&mut self) -> &mut f32;
    fn interrupt_on_damage(&self) -> &bool;
    fn interrupt_on_damage_mut(&mut self) -> &mut bool;
    fn stop_and_fire_timeout(&self) -> &f32;
    fn stop_and_fire_timeout_mut(&mut self) -> &mut f32;
    fn move_timeout(&self) -> &f32;
    fn move_timeout_mut(&mut self) -> &mut f32;
    fn combat_settings(&self) -> &CombatSettings;
    fn combat_settings_mut(&mut self) -> &mut CombatSettings;
    fn evade_settings(&self) -> &EvadeSettings;
    fn evade_settings_mut(&mut self) -> &mut EvadeSettings;
    fn vehicle_vs_vehicle(&self) -> &VehicleVsVehicle;
    fn vehicle_vs_vehicle_mut(&mut self) -> &mut VehicleVsVehicle;
    fn vehicle_vs_soldier(&self) -> &VehicleVsSoldier;
    fn vehicle_vs_soldier_mut(&mut self) -> &mut VehicleVsSoldier;
    fn turn_to_align_weapons(&self) -> &bool;
    fn turn_to_align_weapons_mut(&mut self) -> &mut bool;
}

impl VehicleCombatSettingsTrait for VehicleCombatSettings {
    fn use_simple_behavior(&self) -> &bool {
        &self.use_simple_behavior
    }
    fn use_simple_behavior_mut(&mut self) -> &mut bool {
        &mut self.use_simple_behavior
    }
    fn distances(&self) -> &Distances {
        &self.distances
    }
    fn distances_mut(&mut self) -> &mut Distances {
        &mut self.distances
    }
    fn never_lose_interest_distance(&self) -> &f32 {
        &self.never_lose_interest_distance
    }
    fn never_lose_interest_distance_mut(&mut self) -> &mut f32 {
        &mut self.never_lose_interest_distance
    }
    fn lose_interest_time(&self) -> &f32 {
        &self.lose_interest_time
    }
    fn lose_interest_time_mut(&mut self) -> &mut f32 {
        &mut self.lose_interest_time
    }
    fn sixth_sense_radius(&self) -> &f32 {
        &self.sixth_sense_radius
    }
    fn sixth_sense_radius_mut(&mut self) -> &mut f32 {
        &mut self.sixth_sense_radius
    }
    fn forget_target_distance(&self) -> &f32 {
        &self.forget_target_distance
    }
    fn forget_target_distance_mut(&mut self) -> &mut f32 {
        &mut self.forget_target_distance
    }
    fn interrupt_on_damage(&self) -> &bool {
        &self.interrupt_on_damage
    }
    fn interrupt_on_damage_mut(&mut self) -> &mut bool {
        &mut self.interrupt_on_damage
    }
    fn stop_and_fire_timeout(&self) -> &f32 {
        &self.stop_and_fire_timeout
    }
    fn stop_and_fire_timeout_mut(&mut self) -> &mut f32 {
        &mut self.stop_and_fire_timeout
    }
    fn move_timeout(&self) -> &f32 {
        &self.move_timeout
    }
    fn move_timeout_mut(&mut self) -> &mut f32 {
        &mut self.move_timeout
    }
    fn combat_settings(&self) -> &CombatSettings {
        &self.combat_settings
    }
    fn combat_settings_mut(&mut self) -> &mut CombatSettings {
        &mut self.combat_settings
    }
    fn evade_settings(&self) -> &EvadeSettings {
        &self.evade_settings
    }
    fn evade_settings_mut(&mut self) -> &mut EvadeSettings {
        &mut self.evade_settings
    }
    fn vehicle_vs_vehicle(&self) -> &VehicleVsVehicle {
        &self.vehicle_vs_vehicle
    }
    fn vehicle_vs_vehicle_mut(&mut self) -> &mut VehicleVsVehicle {
        &mut self.vehicle_vs_vehicle
    }
    fn vehicle_vs_soldier(&self) -> &VehicleVsSoldier {
        &self.vehicle_vs_soldier
    }
    fn vehicle_vs_soldier_mut(&mut self) -> &mut VehicleVsSoldier {
        &mut self.vehicle_vs_soldier
    }
    fn turn_to_align_weapons(&self) -> &bool {
        &self.turn_to_align_weapons
    }
    fn turn_to_align_weapons_mut(&mut self) -> &mut bool {
        &mut self.turn_to_align_weapons
    }
}

impl super::core::AssetTrait for VehicleCombatSettings {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VehicleCombatSettings {
}

pub static VEHICLECOMBATSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCombatSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleCombatSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseSimpleBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCombatSettings, use_simple_behavior),
            },
            FieldInfoData {
                name: "Distances",
                flags: MemberInfoFlags::new(0),
                field_type: "Distances",
                rust_offset: offset_of!(VehicleCombatSettings, distances),
            },
            FieldInfoData {
                name: "NeverLoseInterestDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCombatSettings, never_lose_interest_distance),
            },
            FieldInfoData {
                name: "LoseInterestTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCombatSettings, lose_interest_time),
            },
            FieldInfoData {
                name: "SixthSenseRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCombatSettings, sixth_sense_radius),
            },
            FieldInfoData {
                name: "ForgetTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCombatSettings, forget_target_distance),
            },
            FieldInfoData {
                name: "InterruptOnDamage",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCombatSettings, interrupt_on_damage),
            },
            FieldInfoData {
                name: "StopAndFireTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCombatSettings, stop_and_fire_timeout),
            },
            FieldInfoData {
                name: "MoveTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleCombatSettings, move_timeout),
            },
            FieldInfoData {
                name: "CombatSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "CombatSettings",
                rust_offset: offset_of!(VehicleCombatSettings, combat_settings),
            },
            FieldInfoData {
                name: "EvadeSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "EvadeSettings",
                rust_offset: offset_of!(VehicleCombatSettings, evade_settings),
            },
            FieldInfoData {
                name: "VehicleVsVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleVsVehicle",
                rust_offset: offset_of!(VehicleCombatSettings, vehicle_vs_vehicle),
            },
            FieldInfoData {
                name: "VehicleVsSoldier",
                flags: MemberInfoFlags::new(0),
                field_type: "VehicleVsSoldier",
                rust_offset: offset_of!(VehicleCombatSettings, vehicle_vs_soldier),
            },
            FieldInfoData {
                name: "TurnToAlignWeapons",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VehicleCombatSettings, turn_to_align_weapons),
            },
        ],
    }),
    array_type: Some(VEHICLECOMBATSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleCombatSettings {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLECOMBATSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VEHICLECOMBATSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCombatSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleCombatSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleVsVehicle {
    pub distances: Distances,
    pub search_time: f32,
    pub keep_focus_while_searching_time: f32,
}

pub trait VehicleVsVehicleTrait: TypeObject {
    fn distances(&self) -> &Distances;
    fn distances_mut(&mut self) -> &mut Distances;
    fn search_time(&self) -> &f32;
    fn search_time_mut(&mut self) -> &mut f32;
    fn keep_focus_while_searching_time(&self) -> &f32;
    fn keep_focus_while_searching_time_mut(&mut self) -> &mut f32;
}

impl VehicleVsVehicleTrait for VehicleVsVehicle {
    fn distances(&self) -> &Distances {
        &self.distances
    }
    fn distances_mut(&mut self) -> &mut Distances {
        &mut self.distances
    }
    fn search_time(&self) -> &f32 {
        &self.search_time
    }
    fn search_time_mut(&mut self) -> &mut f32 {
        &mut self.search_time
    }
    fn keep_focus_while_searching_time(&self) -> &f32 {
        &self.keep_focus_while_searching_time
    }
    fn keep_focus_while_searching_time_mut(&mut self) -> &mut f32 {
        &mut self.keep_focus_while_searching_time
    }
}

pub static VEHICLEVSVEHICLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVsVehicle",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleVsVehicle as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Distances",
                flags: MemberInfoFlags::new(0),
                field_type: "Distances",
                rust_offset: offset_of!(VehicleVsVehicle, distances),
            },
            FieldInfoData {
                name: "SearchTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleVsVehicle, search_time),
            },
            FieldInfoData {
                name: "KeepFocusWhileSearchingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleVsVehicle, keep_focus_while_searching_time),
            },
        ],
    }),
    array_type: Some(VEHICLEVSVEHICLE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleVsVehicle {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEVSVEHICLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEVSVEHICLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVsVehicle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleVsVehicle"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VehicleVsSoldier {
    pub distances: Distances,
    pub num_repositions: i32,
    pub flush_out_time: f32,
}

pub trait VehicleVsSoldierTrait: TypeObject {
    fn distances(&self) -> &Distances;
    fn distances_mut(&mut self) -> &mut Distances;
    fn num_repositions(&self) -> &i32;
    fn num_repositions_mut(&mut self) -> &mut i32;
    fn flush_out_time(&self) -> &f32;
    fn flush_out_time_mut(&mut self) -> &mut f32;
}

impl VehicleVsSoldierTrait for VehicleVsSoldier {
    fn distances(&self) -> &Distances {
        &self.distances
    }
    fn distances_mut(&mut self) -> &mut Distances {
        &mut self.distances
    }
    fn num_repositions(&self) -> &i32 {
        &self.num_repositions
    }
    fn num_repositions_mut(&mut self) -> &mut i32 {
        &mut self.num_repositions
    }
    fn flush_out_time(&self) -> &f32 {
        &self.flush_out_time
    }
    fn flush_out_time_mut(&mut self) -> &mut f32 {
        &mut self.flush_out_time
    }
}

pub static VEHICLEVSSOLDIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVsSoldier",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VehicleVsSoldier as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Distances",
                flags: MemberInfoFlags::new(0),
                field_type: "Distances",
                rust_offset: offset_of!(VehicleVsSoldier, distances),
            },
            FieldInfoData {
                name: "NumRepositions",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VehicleVsSoldier, num_repositions),
            },
            FieldInfoData {
                name: "FlushOutTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VehicleVsSoldier, flush_out_time),
            },
        ],
    }),
    array_type: Some(VEHICLEVSSOLDIER_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleVsSoldier {
    fn type_info(&self) -> &'static TypeInfo {
        VEHICLEVSSOLDIER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VEHICLEVSSOLDIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVsSoldier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleVsSoldier"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EvadeSettings {
    pub hold_evade_time: f32,
    pub max_evade_search_time: f32,
    pub iteration_count: i32,
    pub angle_step: f32,
    pub test_length: f32,
    pub straight_only: bool,
    pub evade_speed: f32,
}

pub trait EvadeSettingsTrait: TypeObject {
    fn hold_evade_time(&self) -> &f32;
    fn hold_evade_time_mut(&mut self) -> &mut f32;
    fn max_evade_search_time(&self) -> &f32;
    fn max_evade_search_time_mut(&mut self) -> &mut f32;
    fn iteration_count(&self) -> &i32;
    fn iteration_count_mut(&mut self) -> &mut i32;
    fn angle_step(&self) -> &f32;
    fn angle_step_mut(&mut self) -> &mut f32;
    fn test_length(&self) -> &f32;
    fn test_length_mut(&mut self) -> &mut f32;
    fn straight_only(&self) -> &bool;
    fn straight_only_mut(&mut self) -> &mut bool;
    fn evade_speed(&self) -> &f32;
    fn evade_speed_mut(&mut self) -> &mut f32;
}

impl EvadeSettingsTrait for EvadeSettings {
    fn hold_evade_time(&self) -> &f32 {
        &self.hold_evade_time
    }
    fn hold_evade_time_mut(&mut self) -> &mut f32 {
        &mut self.hold_evade_time
    }
    fn max_evade_search_time(&self) -> &f32 {
        &self.max_evade_search_time
    }
    fn max_evade_search_time_mut(&mut self) -> &mut f32 {
        &mut self.max_evade_search_time
    }
    fn iteration_count(&self) -> &i32 {
        &self.iteration_count
    }
    fn iteration_count_mut(&mut self) -> &mut i32 {
        &mut self.iteration_count
    }
    fn angle_step(&self) -> &f32 {
        &self.angle_step
    }
    fn angle_step_mut(&mut self) -> &mut f32 {
        &mut self.angle_step
    }
    fn test_length(&self) -> &f32 {
        &self.test_length
    }
    fn test_length_mut(&mut self) -> &mut f32 {
        &mut self.test_length
    }
    fn straight_only(&self) -> &bool {
        &self.straight_only
    }
    fn straight_only_mut(&mut self) -> &mut bool {
        &mut self.straight_only
    }
    fn evade_speed(&self) -> &f32 {
        &self.evade_speed
    }
    fn evade_speed_mut(&mut self) -> &mut f32 {
        &mut self.evade_speed
    }
}

pub static EVADESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvadeSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EvadeSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HoldEvadeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvadeSettings, hold_evade_time),
            },
            FieldInfoData {
                name: "MaxEvadeSearchTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvadeSettings, max_evade_search_time),
            },
            FieldInfoData {
                name: "IterationCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(EvadeSettings, iteration_count),
            },
            FieldInfoData {
                name: "AngleStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvadeSettings, angle_step),
            },
            FieldInfoData {
                name: "TestLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvadeSettings, test_length),
            },
            FieldInfoData {
                name: "StraightOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EvadeSettings, straight_only),
            },
            FieldInfoData {
                name: "EvadeSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EvadeSettings, evade_speed),
            },
        ],
    }),
    array_type: Some(EVADESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EvadeSettings {
    fn type_info(&self) -> &'static TypeInfo {
        EVADESETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVADESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvadeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EvadeSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CombatSettings {
    pub move_time: f32,
    pub update_time: f32,
    pub iteration_count: i32,
    pub angle_step: f32,
    pub test_length: f32,
    pub straight_only: bool,
}

pub trait CombatSettingsTrait: TypeObject {
    fn move_time(&self) -> &f32;
    fn move_time_mut(&mut self) -> &mut f32;
    fn update_time(&self) -> &f32;
    fn update_time_mut(&mut self) -> &mut f32;
    fn iteration_count(&self) -> &i32;
    fn iteration_count_mut(&mut self) -> &mut i32;
    fn angle_step(&self) -> &f32;
    fn angle_step_mut(&mut self) -> &mut f32;
    fn test_length(&self) -> &f32;
    fn test_length_mut(&mut self) -> &mut f32;
    fn straight_only(&self) -> &bool;
    fn straight_only_mut(&mut self) -> &mut bool;
}

impl CombatSettingsTrait for CombatSettings {
    fn move_time(&self) -> &f32 {
        &self.move_time
    }
    fn move_time_mut(&mut self) -> &mut f32 {
        &mut self.move_time
    }
    fn update_time(&self) -> &f32 {
        &self.update_time
    }
    fn update_time_mut(&mut self) -> &mut f32 {
        &mut self.update_time
    }
    fn iteration_count(&self) -> &i32 {
        &self.iteration_count
    }
    fn iteration_count_mut(&mut self) -> &mut i32 {
        &mut self.iteration_count
    }
    fn angle_step(&self) -> &f32 {
        &self.angle_step
    }
    fn angle_step_mut(&mut self) -> &mut f32 {
        &mut self.angle_step
    }
    fn test_length(&self) -> &f32 {
        &self.test_length
    }
    fn test_length_mut(&mut self) -> &mut f32 {
        &mut self.test_length
    }
    fn straight_only(&self) -> &bool {
        &self.straight_only
    }
    fn straight_only_mut(&mut self) -> &mut bool {
        &mut self.straight_only
    }
}

pub static COMBATSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CombatSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatSettings, move_time),
            },
            FieldInfoData {
                name: "UpdateTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatSettings, update_time),
            },
            FieldInfoData {
                name: "IterationCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(CombatSettings, iteration_count),
            },
            FieldInfoData {
                name: "AngleStep",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatSettings, angle_step),
            },
            FieldInfoData {
                name: "TestLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CombatSettings, test_length),
            },
            FieldInfoData {
                name: "StraightOnly",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(CombatSettings, straight_only),
            },
        ],
    }),
    array_type: Some(COMBATSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CombatSettings {
    fn type_info(&self) -> &'static TypeInfo {
        COMBATSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COMBATSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CombatSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Distances {
    pub min: f32,
    pub max: f32,
}

pub trait DistancesTrait: TypeObject {
    fn min(&self) -> &f32;
    fn min_mut(&mut self) -> &mut f32;
    fn max(&self) -> &f32;
    fn max_mut(&mut self) -> &mut f32;
}

impl DistancesTrait for Distances {
    fn min(&self) -> &f32 {
        &self.min
    }
    fn min_mut(&mut self) -> &mut f32 {
        &mut self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
    fn max_mut(&mut self) -> &mut f32 {
        &mut self.max
    }
}

pub static DISTANCES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Distances",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Distances as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Distances, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(Distances, max),
            },
        ],
    }),
    array_type: Some(DISTANCES_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Distances {
    fn type_info(&self) -> &'static TypeInfo {
        DISTANCES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DISTANCES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Distances-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Distances"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIVehicleAimingComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub weapon_rotation_world_transform: super::core::LinearTransform,
    pub weapon_pitch_local_offset: super::core::Vec3,
    pub pitch_constraints: AIVehicleAimingConstraints,
    pub yaw_constraints: AIVehicleAimingConstraints,
    pub use_target_position_override: bool,
    pub target_position_override: super::core::Vec3,
    pub lose_interest_time: f32,
    pub pitch_offset: f32,
    pub yaw_offset: f32,
    pub use_child_components: bool,
    pub pitch_velocity: f32,
    pub yaw_velocity: f32,
    pub max_pitch: f32,
    pub max_yaw: f32,
}

pub trait AIVehicleAimingComponentDataTrait: super::entity::GameComponentDataTrait {
    fn weapon_rotation_world_transform(&self) -> &super::core::LinearTransform;
    fn weapon_rotation_world_transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn weapon_pitch_local_offset(&self) -> &super::core::Vec3;
    fn weapon_pitch_local_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn pitch_constraints(&self) -> &AIVehicleAimingConstraints;
    fn pitch_constraints_mut(&mut self) -> &mut AIVehicleAimingConstraints;
    fn yaw_constraints(&self) -> &AIVehicleAimingConstraints;
    fn yaw_constraints_mut(&mut self) -> &mut AIVehicleAimingConstraints;
    fn use_target_position_override(&self) -> &bool;
    fn use_target_position_override_mut(&mut self) -> &mut bool;
    fn target_position_override(&self) -> &super::core::Vec3;
    fn target_position_override_mut(&mut self) -> &mut super::core::Vec3;
    fn lose_interest_time(&self) -> &f32;
    fn lose_interest_time_mut(&mut self) -> &mut f32;
    fn pitch_offset(&self) -> &f32;
    fn pitch_offset_mut(&mut self) -> &mut f32;
    fn yaw_offset(&self) -> &f32;
    fn yaw_offset_mut(&mut self) -> &mut f32;
    fn use_child_components(&self) -> &bool;
    fn use_child_components_mut(&mut self) -> &mut bool;
    fn pitch_velocity(&self) -> &f32;
    fn pitch_velocity_mut(&mut self) -> &mut f32;
    fn yaw_velocity(&self) -> &f32;
    fn yaw_velocity_mut(&mut self) -> &mut f32;
    fn max_pitch(&self) -> &f32;
    fn max_pitch_mut(&mut self) -> &mut f32;
    fn max_yaw(&self) -> &f32;
    fn max_yaw_mut(&mut self) -> &mut f32;
}

impl AIVehicleAimingComponentDataTrait for AIVehicleAimingComponentData {
    fn weapon_rotation_world_transform(&self) -> &super::core::LinearTransform {
        &self.weapon_rotation_world_transform
    }
    fn weapon_rotation_world_transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.weapon_rotation_world_transform
    }
    fn weapon_pitch_local_offset(&self) -> &super::core::Vec3 {
        &self.weapon_pitch_local_offset
    }
    fn weapon_pitch_local_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.weapon_pitch_local_offset
    }
    fn pitch_constraints(&self) -> &AIVehicleAimingConstraints {
        &self.pitch_constraints
    }
    fn pitch_constraints_mut(&mut self) -> &mut AIVehicleAimingConstraints {
        &mut self.pitch_constraints
    }
    fn yaw_constraints(&self) -> &AIVehicleAimingConstraints {
        &self.yaw_constraints
    }
    fn yaw_constraints_mut(&mut self) -> &mut AIVehicleAimingConstraints {
        &mut self.yaw_constraints
    }
    fn use_target_position_override(&self) -> &bool {
        &self.use_target_position_override
    }
    fn use_target_position_override_mut(&mut self) -> &mut bool {
        &mut self.use_target_position_override
    }
    fn target_position_override(&self) -> &super::core::Vec3 {
        &self.target_position_override
    }
    fn target_position_override_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_position_override
    }
    fn lose_interest_time(&self) -> &f32 {
        &self.lose_interest_time
    }
    fn lose_interest_time_mut(&mut self) -> &mut f32 {
        &mut self.lose_interest_time
    }
    fn pitch_offset(&self) -> &f32 {
        &self.pitch_offset
    }
    fn pitch_offset_mut(&mut self) -> &mut f32 {
        &mut self.pitch_offset
    }
    fn yaw_offset(&self) -> &f32 {
        &self.yaw_offset
    }
    fn yaw_offset_mut(&mut self) -> &mut f32 {
        &mut self.yaw_offset
    }
    fn use_child_components(&self) -> &bool {
        &self.use_child_components
    }
    fn use_child_components_mut(&mut self) -> &mut bool {
        &mut self.use_child_components
    }
    fn pitch_velocity(&self) -> &f32 {
        &self.pitch_velocity
    }
    fn pitch_velocity_mut(&mut self) -> &mut f32 {
        &mut self.pitch_velocity
    }
    fn yaw_velocity(&self) -> &f32 {
        &self.yaw_velocity
    }
    fn yaw_velocity_mut(&mut self) -> &mut f32 {
        &mut self.yaw_velocity
    }
    fn max_pitch(&self) -> &f32 {
        &self.max_pitch
    }
    fn max_pitch_mut(&mut self) -> &mut f32 {
        &mut self.max_pitch
    }
    fn max_yaw(&self) -> &f32 {
        &self.max_yaw
    }
    fn max_yaw_mut(&mut self) -> &mut f32 {
        &mut self.max_yaw
    }
}

impl super::entity::GameComponentDataTrait for AIVehicleAimingComponentData {
}

impl super::entity::ComponentDataTrait for AIVehicleAimingComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AIVehicleAimingComponentData {
}

impl super::core::DataBusPeerTrait for AIVehicleAimingComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIVehicleAimingComponentData {
}

impl super::core::DataContainerTrait for AIVehicleAimingComponentData {
}

pub static AIVEHICLEAIMINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleAimingComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIVehicleAimingComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WeaponRotationWorldTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(AIVehicleAimingComponentData, weapon_rotation_world_transform),
            },
            FieldInfoData {
                name: "WeaponPitchLocalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AIVehicleAimingComponentData, weapon_pitch_local_offset),
            },
            FieldInfoData {
                name: "PitchConstraints",
                flags: MemberInfoFlags::new(0),
                field_type: "AIVehicleAimingConstraints",
                rust_offset: offset_of!(AIVehicleAimingComponentData, pitch_constraints),
            },
            FieldInfoData {
                name: "YawConstraints",
                flags: MemberInfoFlags::new(0),
                field_type: "AIVehicleAimingConstraints",
                rust_offset: offset_of!(AIVehicleAimingComponentData, yaw_constraints),
            },
            FieldInfoData {
                name: "UseTargetPositionOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIVehicleAimingComponentData, use_target_position_override),
            },
            FieldInfoData {
                name: "TargetPositionOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AIVehicleAimingComponentData, target_position_override),
            },
            FieldInfoData {
                name: "LoseInterestTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingComponentData, lose_interest_time),
            },
            FieldInfoData {
                name: "PitchOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingComponentData, pitch_offset),
            },
            FieldInfoData {
                name: "YawOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingComponentData, yaw_offset),
            },
            FieldInfoData {
                name: "UseChildComponents",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIVehicleAimingComponentData, use_child_components),
            },
            FieldInfoData {
                name: "PitchVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingComponentData, pitch_velocity),
            },
            FieldInfoData {
                name: "YawVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingComponentData, yaw_velocity),
            },
            FieldInfoData {
                name: "MaxPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingComponentData, max_pitch),
            },
            FieldInfoData {
                name: "MaxYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingComponentData, max_yaw),
            },
        ],
    }),
    array_type: Some(AIVEHICLEAIMINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIVehicleAimingComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIVEHICLEAIMINGCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIVEHICLEAIMINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleAimingComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIVehicleAimingComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIVehicleAimingConstraints {
    pub min_angle: f32,
    pub max_angle: f32,
    pub offset: f32,
    pub max_delta: f32,
}

pub trait AIVehicleAimingConstraintsTrait: TypeObject {
    fn min_angle(&self) -> &f32;
    fn min_angle_mut(&mut self) -> &mut f32;
    fn max_angle(&self) -> &f32;
    fn max_angle_mut(&mut self) -> &mut f32;
    fn offset(&self) -> &f32;
    fn offset_mut(&mut self) -> &mut f32;
    fn max_delta(&self) -> &f32;
    fn max_delta_mut(&mut self) -> &mut f32;
}

impl AIVehicleAimingConstraintsTrait for AIVehicleAimingConstraints {
    fn min_angle(&self) -> &f32 {
        &self.min_angle
    }
    fn min_angle_mut(&mut self) -> &mut f32 {
        &mut self.min_angle
    }
    fn max_angle(&self) -> &f32 {
        &self.max_angle
    }
    fn max_angle_mut(&mut self) -> &mut f32 {
        &mut self.max_angle
    }
    fn offset(&self) -> &f32 {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut f32 {
        &mut self.offset
    }
    fn max_delta(&self) -> &f32 {
        &self.max_delta
    }
    fn max_delta_mut(&mut self) -> &mut f32 {
        &mut self.max_delta
    }
}

pub static AIVEHICLEAIMINGCONSTRAINTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleAimingConstraints",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIVehicleAimingConstraints as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingConstraints, min_angle),
            },
            FieldInfoData {
                name: "MaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingConstraints, max_angle),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingConstraints, offset),
            },
            FieldInfoData {
                name: "MaxDelta",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIVehicleAimingConstraints, max_delta),
            },
        ],
    }),
    array_type: Some(AIVEHICLEAIMINGCONSTRAINTS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIVehicleAimingConstraints {
    fn type_info(&self) -> &'static TypeInfo {
        AIVEHICLEAIMINGCONSTRAINTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIVEHICLEAIMINGCONSTRAINTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleAimingConstraints-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIVehicleAimingConstraints"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIServerTargetComponentTeamChangedMessage {
}

pub trait AIServerTargetComponentTeamChangedMessageTrait: TypeObject {
}

impl AIServerTargetComponentTeamChangedMessageTrait for AIServerTargetComponentTeamChangedMessage {
}

pub static AISERVERTARGETCOMPONENTTEAMCHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIServerTargetComponentTeamChangedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIServerTargetComponentTeamChangedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIServerTargetComponentTeamChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AISERVERTARGETCOMPONENTTEAMCHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AIServerTargetComponentDestroyedMessage {
}

pub trait AIServerTargetComponentDestroyedMessageTrait: TypeObject {
}

impl AIServerTargetComponentDestroyedMessageTrait for AIServerTargetComponentDestroyedMessage {
}

pub static AISERVERTARGETCOMPONENTDESTROYEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIServerTargetComponentDestroyedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIServerTargetComponentDestroyedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIServerTargetComponentDestroyedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AISERVERTARGETCOMPONENTDESTROYEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AIServerTargetComponentSpawnedMessage {
}

pub trait AIServerTargetComponentSpawnedMessageTrait: TypeObject {
}

impl AIServerTargetComponentSpawnedMessageTrait for AIServerTargetComponentSpawnedMessage {
}

pub static AISERVERTARGETCOMPONENTSPAWNEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIServerTargetComponentSpawnedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIServerTargetComponentSpawnedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIServerTargetComponentSpawnedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AISERVERTARGETCOMPONENTSPAWNEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AITargetComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub register_as_target: bool,
    pub register_as_stand_alone: bool,
    pub stand_alone_team: super::gameplay_sim::TeamId,
    pub human_target_preference: f32,
    pub accept_immortal_target: bool,
    pub threat_distance_multiplier: f32,
    pub hit_box_distance_multiplier: f32,
    pub is_target: bool,
    pub book_area: bool,
    pub target_object_locomotion_sound: AISoundType,
}

pub trait AITargetComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn register_as_target(&self) -> &bool;
    fn register_as_target_mut(&mut self) -> &mut bool;
    fn register_as_stand_alone(&self) -> &bool;
    fn register_as_stand_alone_mut(&mut self) -> &mut bool;
    fn stand_alone_team(&self) -> &super::gameplay_sim::TeamId;
    fn stand_alone_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId;
    fn human_target_preference(&self) -> &f32;
    fn human_target_preference_mut(&mut self) -> &mut f32;
    fn accept_immortal_target(&self) -> &bool;
    fn accept_immortal_target_mut(&mut self) -> &mut bool;
    fn threat_distance_multiplier(&self) -> &f32;
    fn threat_distance_multiplier_mut(&mut self) -> &mut f32;
    fn hit_box_distance_multiplier(&self) -> &f32;
    fn hit_box_distance_multiplier_mut(&mut self) -> &mut f32;
    fn is_target(&self) -> &bool;
    fn is_target_mut(&mut self) -> &mut bool;
    fn book_area(&self) -> &bool;
    fn book_area_mut(&mut self) -> &mut bool;
    fn target_object_locomotion_sound(&self) -> &AISoundType;
    fn target_object_locomotion_sound_mut(&mut self) -> &mut AISoundType;
}

impl AITargetComponentDataTrait for AITargetComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn register_as_target(&self) -> &bool {
        &self.register_as_target
    }
    fn register_as_target_mut(&mut self) -> &mut bool {
        &mut self.register_as_target
    }
    fn register_as_stand_alone(&self) -> &bool {
        &self.register_as_stand_alone
    }
    fn register_as_stand_alone_mut(&mut self) -> &mut bool {
        &mut self.register_as_stand_alone
    }
    fn stand_alone_team(&self) -> &super::gameplay_sim::TeamId {
        &self.stand_alone_team
    }
    fn stand_alone_team_mut(&mut self) -> &mut super::gameplay_sim::TeamId {
        &mut self.stand_alone_team
    }
    fn human_target_preference(&self) -> &f32 {
        &self.human_target_preference
    }
    fn human_target_preference_mut(&mut self) -> &mut f32 {
        &mut self.human_target_preference
    }
    fn accept_immortal_target(&self) -> &bool {
        &self.accept_immortal_target
    }
    fn accept_immortal_target_mut(&mut self) -> &mut bool {
        &mut self.accept_immortal_target
    }
    fn threat_distance_multiplier(&self) -> &f32 {
        &self.threat_distance_multiplier
    }
    fn threat_distance_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.threat_distance_multiplier
    }
    fn hit_box_distance_multiplier(&self) -> &f32 {
        &self.hit_box_distance_multiplier
    }
    fn hit_box_distance_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.hit_box_distance_multiplier
    }
    fn is_target(&self) -> &bool {
        &self.is_target
    }
    fn is_target_mut(&mut self) -> &mut bool {
        &mut self.is_target
    }
    fn book_area(&self) -> &bool {
        &self.book_area
    }
    fn book_area_mut(&mut self) -> &mut bool {
        &mut self.book_area
    }
    fn target_object_locomotion_sound(&self) -> &AISoundType {
        &self.target_object_locomotion_sound
    }
    fn target_object_locomotion_sound_mut(&mut self) -> &mut AISoundType {
        &mut self.target_object_locomotion_sound
    }
}

impl super::entity::GameComponentDataTrait for AITargetComponentData {
}

impl super::entity::ComponentDataTrait for AITargetComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AITargetComponentData {
}

impl super::core::DataBusPeerTrait for AITargetComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AITargetComponentData {
}

impl super::core::DataContainerTrait for AITargetComponentData {
}

pub static AITARGETCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AITargetComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AITargetComponentData, realm),
            },
            FieldInfoData {
                name: "RegisterAsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITargetComponentData, register_as_target),
            },
            FieldInfoData {
                name: "RegisterAsStandAlone",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITargetComponentData, register_as_stand_alone),
            },
            FieldInfoData {
                name: "StandAloneTeam",
                flags: MemberInfoFlags::new(0),
                field_type: "TeamId",
                rust_offset: offset_of!(AITargetComponentData, stand_alone_team),
            },
            FieldInfoData {
                name: "HumanTargetPreference",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AITargetComponentData, human_target_preference),
            },
            FieldInfoData {
                name: "AcceptImmortalTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITargetComponentData, accept_immortal_target),
            },
            FieldInfoData {
                name: "ThreatDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AITargetComponentData, threat_distance_multiplier),
            },
            FieldInfoData {
                name: "HitBoxDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AITargetComponentData, hit_box_distance_multiplier),
            },
            FieldInfoData {
                name: "IsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITargetComponentData, is_target),
            },
            FieldInfoData {
                name: "BookArea",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AITargetComponentData, book_area),
            },
            FieldInfoData {
                name: "TargetObjectLocomotionSound",
                flags: MemberInfoFlags::new(0),
                field_type: "AISoundType",
                rust_offset: offset_of!(AITargetComponentData, target_object_locomotion_sound),
            },
        ],
    }),
    array_type: Some(AITARGETCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AITargetComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AITARGETCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AITARGETCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITargetComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISystemEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait AISystemEntityDataTrait: super::entity::EntityDataTrait {
}

impl AISystemEntityDataTrait for AISystemEntityData {
}

impl super::entity::EntityDataTrait for AISystemEntityData {
}

impl super::entity::GameObjectDataTrait for AISystemEntityData {
}

impl super::core::DataBusPeerTrait for AISystemEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AISystemEntityData {
}

impl super::core::DataContainerTrait for AISystemEntityData {
}

pub static AISYSTEMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISystemEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISystemEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AISYSTEMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISystemEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AISYSTEMENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISYSTEMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISystemEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISystemEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIPathfindingRepathRequiredMessage {
}

pub trait AIPathfindingRepathRequiredMessageTrait: TypeObject {
}

impl AIPathfindingRepathRequiredMessageTrait for AIPathfindingRepathRequiredMessage {
}

pub static AIPATHFINDINGREPATHREQUIREDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingRepathRequiredMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIPathfindingRepathRequiredMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for AIPathfindingRepathRequiredMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHFINDINGREPATHREQUIREDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AIPathfindingPathfindersRegisteredMessage {
}

pub trait AIPathfindingPathfindersRegisteredMessageTrait: TypeObject {
}

impl AIPathfindingPathfindersRegisteredMessageTrait for AIPathfindingPathfindersRegisteredMessage {
}

pub static AIPATHFINDINGPATHFINDERSREGISTEREDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingPathfindersRegisteredMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIPathfindingPathfindersRegisteredMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIPathfindingPathfindersRegisteredMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHFINDINGPATHFINDERSREGISTEREDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AIPathfindingInitializedMessage {
}

pub trait AIPathfindingInitializedMessageTrait: TypeObject {
}

impl AIPathfindingInitializedMessageTrait for AIPathfindingInitializedMessage {
}

pub static AIPATHFINDINGINITIALIZEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingInitializedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIPathfindingInitializedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIPathfindingInitializedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AIPATHFINDINGINITIALIZEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct BattleAISettings {
    pub _glacier_base: super::core::SystemSettings,
    pub use_nav_power_fixed_heap: bool,
    pub nav_power_fixed_heap_size_kb: u32,
}

pub trait BattleAISettingsTrait: super::core::SystemSettingsTrait {
    fn use_nav_power_fixed_heap(&self) -> &bool;
    fn use_nav_power_fixed_heap_mut(&mut self) -> &mut bool;
    fn nav_power_fixed_heap_size_kb(&self) -> &u32;
    fn nav_power_fixed_heap_size_kb_mut(&mut self) -> &mut u32;
}

impl BattleAISettingsTrait for BattleAISettings {
    fn use_nav_power_fixed_heap(&self) -> &bool {
        &self.use_nav_power_fixed_heap
    }
    fn use_nav_power_fixed_heap_mut(&mut self) -> &mut bool {
        &mut self.use_nav_power_fixed_heap
    }
    fn nav_power_fixed_heap_size_kb(&self) -> &u32 {
        &self.nav_power_fixed_heap_size_kb
    }
    fn nav_power_fixed_heap_size_kb_mut(&mut self) -> &mut u32 {
        &mut self.nav_power_fixed_heap_size_kb
    }
}

impl super::core::SystemSettingsTrait for BattleAISettings {
    fn platform(&self) -> &super::core::GamePlatform {
        self._glacier_base.platform()
    }
    fn platform_mut(&mut self) -> &mut super::core::GamePlatform {
        self._glacier_base.platform_mut()
    }
}

impl super::core::DataContainerTrait for BattleAISettings {
}

pub static BATTLEAISETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAISettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::SYSTEMSETTINGS_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BattleAISettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseNavPowerFixedHeap",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(BattleAISettings, use_nav_power_fixed_heap),
            },
            FieldInfoData {
                name: "NavPowerFixedHeapSizeKb",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(BattleAISettings, nav_power_fixed_heap_size_kb),
            },
        ],
    }),
    array_type: Some(BATTLEAISETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BattleAISettings {
    fn type_info(&self) -> &'static TypeInfo {
        BATTLEAISETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BATTLEAISETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAISettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAISettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BattleAISystemData {
    pub _glacier_base: super::gameplay_sim::GameAISystem,
    pub cover_constants: Option<Arc<Mutex<dyn CoverConstantDataTrait>>>,
    pub firing_pattern_collection: Option<Arc<Mutex<dyn FiringPatternCollectionDataTrait>>>,
    pub targeting: Option<Arc<Mutex<dyn TargetingDataTrait>>>,
    pub shooting: ShootingData,
    pub squad_engage_data: SquadEngageData,
    pub area_booking_settings: AreaBookingSettings,
    pub projectile_data: ProjectileData,
    pub alertness_data: AlertnessData,
    pub preferred_range: Option<Arc<Mutex<dyn PreferredRangeTrait>>>,
}

pub trait BattleAISystemDataTrait: super::gameplay_sim::GameAISystemTrait {
    fn cover_constants(&self) -> &Option<Arc<Mutex<dyn CoverConstantDataTrait>>>;
    fn cover_constants_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverConstantDataTrait>>>;
    fn firing_pattern_collection(&self) -> &Option<Arc<Mutex<dyn FiringPatternCollectionDataTrait>>>;
    fn firing_pattern_collection_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FiringPatternCollectionDataTrait>>>;
    fn targeting(&self) -> &Option<Arc<Mutex<dyn TargetingDataTrait>>>;
    fn targeting_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TargetingDataTrait>>>;
    fn shooting(&self) -> &ShootingData;
    fn shooting_mut(&mut self) -> &mut ShootingData;
    fn squad_engage_data(&self) -> &SquadEngageData;
    fn squad_engage_data_mut(&mut self) -> &mut SquadEngageData;
    fn area_booking_settings(&self) -> &AreaBookingSettings;
    fn area_booking_settings_mut(&mut self) -> &mut AreaBookingSettings;
    fn projectile_data(&self) -> &ProjectileData;
    fn projectile_data_mut(&mut self) -> &mut ProjectileData;
    fn alertness_data(&self) -> &AlertnessData;
    fn alertness_data_mut(&mut self) -> &mut AlertnessData;
    fn preferred_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
    fn preferred_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
}

impl BattleAISystemDataTrait for BattleAISystemData {
    fn cover_constants(&self) -> &Option<Arc<Mutex<dyn CoverConstantDataTrait>>> {
        &self.cover_constants
    }
    fn cover_constants_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverConstantDataTrait>>> {
        &mut self.cover_constants
    }
    fn firing_pattern_collection(&self) -> &Option<Arc<Mutex<dyn FiringPatternCollectionDataTrait>>> {
        &self.firing_pattern_collection
    }
    fn firing_pattern_collection_mut(&mut self) -> &mut Option<Arc<Mutex<dyn FiringPatternCollectionDataTrait>>> {
        &mut self.firing_pattern_collection
    }
    fn targeting(&self) -> &Option<Arc<Mutex<dyn TargetingDataTrait>>> {
        &self.targeting
    }
    fn targeting_mut(&mut self) -> &mut Option<Arc<Mutex<dyn TargetingDataTrait>>> {
        &mut self.targeting
    }
    fn shooting(&self) -> &ShootingData {
        &self.shooting
    }
    fn shooting_mut(&mut self) -> &mut ShootingData {
        &mut self.shooting
    }
    fn squad_engage_data(&self) -> &SquadEngageData {
        &self.squad_engage_data
    }
    fn squad_engage_data_mut(&mut self) -> &mut SquadEngageData {
        &mut self.squad_engage_data
    }
    fn area_booking_settings(&self) -> &AreaBookingSettings {
        &self.area_booking_settings
    }
    fn area_booking_settings_mut(&mut self) -> &mut AreaBookingSettings {
        &mut self.area_booking_settings
    }
    fn projectile_data(&self) -> &ProjectileData {
        &self.projectile_data
    }
    fn projectile_data_mut(&mut self) -> &mut ProjectileData {
        &mut self.projectile_data
    }
    fn alertness_data(&self) -> &AlertnessData {
        &self.alertness_data
    }
    fn alertness_data_mut(&mut self) -> &mut AlertnessData {
        &mut self.alertness_data
    }
    fn preferred_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &self.preferred_range
    }
    fn preferred_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &mut self.preferred_range
    }
}

impl super::gameplay_sim::GameAISystemTrait for BattleAISystemData {
    fn excluded_game_mode_list(&self) -> &Vec<String> {
        self._glacier_base.excluded_game_mode_list()
    }
    fn excluded_game_mode_list_mut(&mut self) -> &mut Vec<String> {
        self._glacier_base.excluded_game_mode_list_mut()
    }
}

impl super::core::AssetTrait for BattleAISystemData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for BattleAISystemData {
}

pub static BATTLEAISYSTEMDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAISystemData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::gameplay_sim::GAMEAISYSTEM_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BattleAISystemData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverConstants",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverConstantData",
                rust_offset: offset_of!(BattleAISystemData, cover_constants),
            },
            FieldInfoData {
                name: "FiringPatternCollection",
                flags: MemberInfoFlags::new(0),
                field_type: "FiringPatternCollectionData",
                rust_offset: offset_of!(BattleAISystemData, firing_pattern_collection),
            },
            FieldInfoData {
                name: "Targeting",
                flags: MemberInfoFlags::new(0),
                field_type: "TargetingData",
                rust_offset: offset_of!(BattleAISystemData, targeting),
            },
            FieldInfoData {
                name: "Shooting",
                flags: MemberInfoFlags::new(0),
                field_type: "ShootingData",
                rust_offset: offset_of!(BattleAISystemData, shooting),
            },
            FieldInfoData {
                name: "SquadEngageData",
                flags: MemberInfoFlags::new(0),
                field_type: "SquadEngageData",
                rust_offset: offset_of!(BattleAISystemData, squad_engage_data),
            },
            FieldInfoData {
                name: "AreaBookingSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "AreaBookingSettings",
                rust_offset: offset_of!(BattleAISystemData, area_booking_settings),
            },
            FieldInfoData {
                name: "ProjectileData",
                flags: MemberInfoFlags::new(0),
                field_type: "ProjectileData",
                rust_offset: offset_of!(BattleAISystemData, projectile_data),
            },
            FieldInfoData {
                name: "AlertnessData",
                flags: MemberInfoFlags::new(0),
                field_type: "AlertnessData",
                rust_offset: offset_of!(BattleAISystemData, alertness_data),
            },
            FieldInfoData {
                name: "PreferredRange",
                flags: MemberInfoFlags::new(0),
                field_type: "PreferredRange",
                rust_offset: offset_of!(BattleAISystemData, preferred_range),
            },
        ],
    }),
    array_type: Some(BATTLEAISYSTEMDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BattleAISystemData {
    fn type_info(&self) -> &'static TypeInfo {
        BATTLEAISYSTEMDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BATTLEAISYSTEMDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAISystemData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAISystemData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AlertnessData {
    pub enable_alertness_states: bool,
    pub enable_alert_by_suppression: bool,
}

pub trait AlertnessDataTrait: TypeObject {
    fn enable_alertness_states(&self) -> &bool;
    fn enable_alertness_states_mut(&mut self) -> &mut bool;
    fn enable_alert_by_suppression(&self) -> &bool;
    fn enable_alert_by_suppression_mut(&mut self) -> &mut bool;
}

impl AlertnessDataTrait for AlertnessData {
    fn enable_alertness_states(&self) -> &bool {
        &self.enable_alertness_states
    }
    fn enable_alertness_states_mut(&mut self) -> &mut bool {
        &mut self.enable_alertness_states
    }
    fn enable_alert_by_suppression(&self) -> &bool {
        &self.enable_alert_by_suppression
    }
    fn enable_alert_by_suppression_mut(&mut self) -> &mut bool {
        &mut self.enable_alert_by_suppression
    }
}

pub static ALERTNESSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlertnessData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AlertnessData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnableAlertnessStates",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlertnessData, enable_alertness_states),
            },
            FieldInfoData {
                name: "EnableAlertBySuppression",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AlertnessData, enable_alert_by_suppression),
            },
        ],
    }),
    array_type: Some(ALERTNESSDATA_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AlertnessData {
    fn type_info(&self) -> &'static TypeInfo {
        ALERTNESSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ALERTNESSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlertnessData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AlertnessData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ProjectileData {
    pub enable_flee_from_friendly_grenades: bool,
}

pub trait ProjectileDataTrait: TypeObject {
    fn enable_flee_from_friendly_grenades(&self) -> &bool;
    fn enable_flee_from_friendly_grenades_mut(&mut self) -> &mut bool;
}

impl ProjectileDataTrait for ProjectileData {
    fn enable_flee_from_friendly_grenades(&self) -> &bool {
        &self.enable_flee_from_friendly_grenades
    }
    fn enable_flee_from_friendly_grenades_mut(&mut self) -> &mut bool {
        &mut self.enable_flee_from_friendly_grenades
    }
}

pub static PROJECTILEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProjectileData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ProjectileData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnableFleeFromFriendlyGrenades",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ProjectileData, enable_flee_from_friendly_grenades),
            },
        ],
    }),
    array_type: Some(PROJECTILEDATA_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ProjectileData {
    fn type_info(&self) -> &'static TypeInfo {
        PROJECTILEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PROJECTILEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProjectileData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ProjectileData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AreaBookingSettings {
    pub enemy_team_booking_radius: f32,
    pub friendly_team_booking_radius: f32,
    pub corpse_booking_time: f32,
}

pub trait AreaBookingSettingsTrait: TypeObject {
    fn enemy_team_booking_radius(&self) -> &f32;
    fn enemy_team_booking_radius_mut(&mut self) -> &mut f32;
    fn friendly_team_booking_radius(&self) -> &f32;
    fn friendly_team_booking_radius_mut(&mut self) -> &mut f32;
    fn corpse_booking_time(&self) -> &f32;
    fn corpse_booking_time_mut(&mut self) -> &mut f32;
}

impl AreaBookingSettingsTrait for AreaBookingSettings {
    fn enemy_team_booking_radius(&self) -> &f32 {
        &self.enemy_team_booking_radius
    }
    fn enemy_team_booking_radius_mut(&mut self) -> &mut f32 {
        &mut self.enemy_team_booking_radius
    }
    fn friendly_team_booking_radius(&self) -> &f32 {
        &self.friendly_team_booking_radius
    }
    fn friendly_team_booking_radius_mut(&mut self) -> &mut f32 {
        &mut self.friendly_team_booking_radius
    }
    fn corpse_booking_time(&self) -> &f32 {
        &self.corpse_booking_time
    }
    fn corpse_booking_time_mut(&mut self) -> &mut f32 {
        &mut self.corpse_booking_time
    }
}

pub static AREABOOKINGSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaBookingSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AreaBookingSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnemyTeamBookingRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaBookingSettings, enemy_team_booking_radius),
            },
            FieldInfoData {
                name: "FriendlyTeamBookingRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaBookingSettings, friendly_team_booking_radius),
            },
            FieldInfoData {
                name: "CorpseBookingTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AreaBookingSettings, corpse_booking_time),
            },
        ],
    }),
    array_type: Some(AREABOOKINGSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AreaBookingSettings {
    fn type_info(&self) -> &'static TypeInfo {
        AREABOOKINGSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AREABOOKINGSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaBookingSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AreaBookingSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SquadEngageData {
    pub engage_time: f32,
    pub find_cover_time: f32,
    pub failure_cooldown_time: f32,
    pub cooldown_time: f32,
    pub secondary_target_radius: f32,
    pub cover_fire_target_radius: f32,
    pub allowed_target_hidden_time: f32,
    pub waiting_to_fire_time: f32,
    pub enable_a_i_record_system: bool,
}

pub trait SquadEngageDataTrait: TypeObject {
    fn engage_time(&self) -> &f32;
    fn engage_time_mut(&mut self) -> &mut f32;
    fn find_cover_time(&self) -> &f32;
    fn find_cover_time_mut(&mut self) -> &mut f32;
    fn failure_cooldown_time(&self) -> &f32;
    fn failure_cooldown_time_mut(&mut self) -> &mut f32;
    fn cooldown_time(&self) -> &f32;
    fn cooldown_time_mut(&mut self) -> &mut f32;
    fn secondary_target_radius(&self) -> &f32;
    fn secondary_target_radius_mut(&mut self) -> &mut f32;
    fn cover_fire_target_radius(&self) -> &f32;
    fn cover_fire_target_radius_mut(&mut self) -> &mut f32;
    fn allowed_target_hidden_time(&self) -> &f32;
    fn allowed_target_hidden_time_mut(&mut self) -> &mut f32;
    fn waiting_to_fire_time(&self) -> &f32;
    fn waiting_to_fire_time_mut(&mut self) -> &mut f32;
    fn enable_a_i_record_system(&self) -> &bool;
    fn enable_a_i_record_system_mut(&mut self) -> &mut bool;
}

impl SquadEngageDataTrait for SquadEngageData {
    fn engage_time(&self) -> &f32 {
        &self.engage_time
    }
    fn engage_time_mut(&mut self) -> &mut f32 {
        &mut self.engage_time
    }
    fn find_cover_time(&self) -> &f32 {
        &self.find_cover_time
    }
    fn find_cover_time_mut(&mut self) -> &mut f32 {
        &mut self.find_cover_time
    }
    fn failure_cooldown_time(&self) -> &f32 {
        &self.failure_cooldown_time
    }
    fn failure_cooldown_time_mut(&mut self) -> &mut f32 {
        &mut self.failure_cooldown_time
    }
    fn cooldown_time(&self) -> &f32 {
        &self.cooldown_time
    }
    fn cooldown_time_mut(&mut self) -> &mut f32 {
        &mut self.cooldown_time
    }
    fn secondary_target_radius(&self) -> &f32 {
        &self.secondary_target_radius
    }
    fn secondary_target_radius_mut(&mut self) -> &mut f32 {
        &mut self.secondary_target_radius
    }
    fn cover_fire_target_radius(&self) -> &f32 {
        &self.cover_fire_target_radius
    }
    fn cover_fire_target_radius_mut(&mut self) -> &mut f32 {
        &mut self.cover_fire_target_radius
    }
    fn allowed_target_hidden_time(&self) -> &f32 {
        &self.allowed_target_hidden_time
    }
    fn allowed_target_hidden_time_mut(&mut self) -> &mut f32 {
        &mut self.allowed_target_hidden_time
    }
    fn waiting_to_fire_time(&self) -> &f32 {
        &self.waiting_to_fire_time
    }
    fn waiting_to_fire_time_mut(&mut self) -> &mut f32 {
        &mut self.waiting_to_fire_time
    }
    fn enable_a_i_record_system(&self) -> &bool {
        &self.enable_a_i_record_system
    }
    fn enable_a_i_record_system_mut(&mut self) -> &mut bool {
        &mut self.enable_a_i_record_system
    }
}

pub static SQUADENGAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadEngageData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SquadEngageData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EngageTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadEngageData, engage_time),
            },
            FieldInfoData {
                name: "FindCoverTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadEngageData, find_cover_time),
            },
            FieldInfoData {
                name: "FailureCooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadEngageData, failure_cooldown_time),
            },
            FieldInfoData {
                name: "CooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadEngageData, cooldown_time),
            },
            FieldInfoData {
                name: "SecondaryTargetRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadEngageData, secondary_target_radius),
            },
            FieldInfoData {
                name: "CoverFireTargetRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadEngageData, cover_fire_target_radius),
            },
            FieldInfoData {
                name: "AllowedTargetHiddenTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadEngageData, allowed_target_hidden_time),
            },
            FieldInfoData {
                name: "WaitingToFireTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SquadEngageData, waiting_to_fire_time),
            },
            FieldInfoData {
                name: "EnableAIRecordSystem",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SquadEngageData, enable_a_i_record_system),
            },
        ],
    }),
    array_type: Some(SQUADENGAGEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SquadEngageData {
    fn type_info(&self) -> &'static TypeInfo {
        SQUADENGAGEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SQUADENGAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadEngageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SquadEngageData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ShootingData {
    pub keep_firing_at_player_time: f32,
    pub keep_firing_at_a_i_time: f32,
}

pub trait ShootingDataTrait: TypeObject {
    fn keep_firing_at_player_time(&self) -> &f32;
    fn keep_firing_at_player_time_mut(&mut self) -> &mut f32;
    fn keep_firing_at_a_i_time(&self) -> &f32;
    fn keep_firing_at_a_i_time_mut(&mut self) -> &mut f32;
}

impl ShootingDataTrait for ShootingData {
    fn keep_firing_at_player_time(&self) -> &f32 {
        &self.keep_firing_at_player_time
    }
    fn keep_firing_at_player_time_mut(&mut self) -> &mut f32 {
        &mut self.keep_firing_at_player_time
    }
    fn keep_firing_at_a_i_time(&self) -> &f32 {
        &self.keep_firing_at_a_i_time
    }
    fn keep_firing_at_a_i_time_mut(&mut self) -> &mut f32 {
        &mut self.keep_firing_at_a_i_time
    }
}

pub static SHOOTINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShootingData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ShootingData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "KeepFiringAtPlayerTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShootingData, keep_firing_at_player_time),
            },
            FieldInfoData {
                name: "KeepFiringAtAITime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ShootingData, keep_firing_at_a_i_time),
            },
        ],
    }),
    array_type: Some(SHOOTINGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ShootingData {
    fn type_info(&self) -> &'static TypeInfo {
        SHOOTINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SHOOTINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShootingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ShootingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISuppressWeaponFiringComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub radius: f32,
}

pub trait AISuppressWeaponFiringComponentDataTrait: super::entity::GameComponentDataTrait {
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
}

impl AISuppressWeaponFiringComponentDataTrait for AISuppressWeaponFiringComponentData {
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
}

impl super::entity::GameComponentDataTrait for AISuppressWeaponFiringComponentData {
}

impl super::entity::ComponentDataTrait for AISuppressWeaponFiringComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AISuppressWeaponFiringComponentData {
}

impl super::core::DataBusPeerTrait for AISuppressWeaponFiringComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AISuppressWeaponFiringComponentData {
}

impl super::core::DataContainerTrait for AISuppressWeaponFiringComponentData {
}

pub static AISUPPRESSWEAPONFIRINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISuppressWeaponFiringComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISuppressWeaponFiringComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISuppressWeaponFiringComponentData, radius),
            },
        ],
    }),
    array_type: Some(AISUPPRESSWEAPONFIRINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AISuppressWeaponFiringComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AISUPPRESSWEAPONFIRINGCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISUPPRESSWEAPONFIRINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISuppressWeaponFiringComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISuppressWeaponFiringComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIGlobalEngageState {
    #[default]
    AIGlobalEngageState_Unavailable = 0,
    AIGlobalEngageState_Ready = 1,
    AIGlobalEngageState_Active = 2,
    AIGlobalEngageState_Cooldown = 3,
}

pub static AIGLOBALENGAGESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIGlobalEngageState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIGLOBALENGAGESTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIGlobalEngageState {
    fn type_info(&self) -> &'static TypeInfo {
        AIGLOBALENGAGESTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIGLOBALENGAGESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIGlobalEngageState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIGlobalEngageState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIStateEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait AIStateEntityDataTrait: super::entity::EntityDataTrait {
}

impl AIStateEntityDataTrait for AIStateEntityData {
}

impl super::entity::EntityDataTrait for AIStateEntityData {
}

impl super::entity::GameObjectDataTrait for AIStateEntityData {
}

impl super::core::DataBusPeerTrait for AIStateEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIStateEntityData {
}

impl super::core::DataContainerTrait for AIStateEntityData {
}

pub static AISTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIStateEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AISTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIStateEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AISTATEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIStateEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AISuppressionState {
    #[default]
    AISuppressionState_None = 0,
    AISuppressionState_Active = 1,
    AISuppressionState_Potential = 2,
    AISuppressionState_CoolDown = 3,
    AISuppressionState_Count = 4,
}

pub static AISUPPRESSIONSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISuppressionState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AISUPPRESSIONSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AISuppressionState {
    fn type_info(&self) -> &'static TypeInfo {
        AISUPPRESSIONSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AISUPPRESSIONSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISuppressionState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISuppressionState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AISpottingPotentialMessage {
}

pub trait AISpottingPotentialMessageTrait: TypeObject {
}

impl AISpottingPotentialMessageTrait for AISpottingPotentialMessage {
}

pub static AISPOTTINGPOTENTIALMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpottingPotentialMessage",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISpottingPotentialMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AISpottingPotentialMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AISPOTTINGPOTENTIALMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AISpottingFoundMessage {
}

pub trait AISpottingFoundMessageTrait: TypeObject {
}

impl AISpottingFoundMessageTrait for AISpottingFoundMessage {
}

pub static AISPOTTINGFOUNDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpottingFoundMessage",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISpottingFoundMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AISpottingFoundMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AISPOTTINGFOUNDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AISpottingComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub enabled: bool,
    pub spotting_fov: f32,
    pub spotting_distance: f32,
    pub visor_equip_hold_time: f32,
    pub visor_weapon_index: i32,
}

pub trait AISpottingComponentDataTrait: super::entity::GameComponentDataTrait {
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
    fn spotting_fov(&self) -> &f32;
    fn spotting_fov_mut(&mut self) -> &mut f32;
    fn spotting_distance(&self) -> &f32;
    fn spotting_distance_mut(&mut self) -> &mut f32;
    fn visor_equip_hold_time(&self) -> &f32;
    fn visor_equip_hold_time_mut(&mut self) -> &mut f32;
    fn visor_weapon_index(&self) -> &i32;
    fn visor_weapon_index_mut(&mut self) -> &mut i32;
}

impl AISpottingComponentDataTrait for AISpottingComponentData {
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
    fn spotting_fov(&self) -> &f32 {
        &self.spotting_fov
    }
    fn spotting_fov_mut(&mut self) -> &mut f32 {
        &mut self.spotting_fov
    }
    fn spotting_distance(&self) -> &f32 {
        &self.spotting_distance
    }
    fn spotting_distance_mut(&mut self) -> &mut f32 {
        &mut self.spotting_distance
    }
    fn visor_equip_hold_time(&self) -> &f32 {
        &self.visor_equip_hold_time
    }
    fn visor_equip_hold_time_mut(&mut self) -> &mut f32 {
        &mut self.visor_equip_hold_time
    }
    fn visor_weapon_index(&self) -> &i32 {
        &self.visor_weapon_index
    }
    fn visor_weapon_index_mut(&mut self) -> &mut i32 {
        &mut self.visor_weapon_index
    }
}

impl super::entity::GameComponentDataTrait for AISpottingComponentData {
}

impl super::entity::ComponentDataTrait for AISpottingComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AISpottingComponentData {
}

impl super::core::DataBusPeerTrait for AISpottingComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AISpottingComponentData {
}

impl super::core::DataContainerTrait for AISpottingComponentData {
}

pub static AISPOTTINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpottingComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AISpottingComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AISpottingComponentData, enabled),
            },
            FieldInfoData {
                name: "SpottingFov",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISpottingComponentData, spotting_fov),
            },
            FieldInfoData {
                name: "SpottingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISpottingComponentData, spotting_distance),
            },
            FieldInfoData {
                name: "VisorEquipHoldTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AISpottingComponentData, visor_equip_hold_time),
            },
            FieldInfoData {
                name: "VisorWeaponIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AISpottingComponentData, visor_weapon_index),
            },
        ],
    }),
    array_type: Some(AISPOTTINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AISpottingComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AISPOTTINGCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AISPOTTINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpottingComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISpottingComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AILocoCompActionSignalMessage {
}

pub trait AILocoCompActionSignalMessageTrait: TypeObject {
}

impl AILocoCompActionSignalMessageTrait for AILocoCompActionSignalMessage {
}

pub static AILOCOCOMPACTIONSIGNALMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCompActionSignalMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoCompActionSignalMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AILocoCompActionSignalMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOCOMPACTIONSIGNALMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AILocoCompExitAnimationMessage {
}

pub trait AILocoCompExitAnimationMessageTrait: TypeObject {
}

impl AILocoCompExitAnimationMessageTrait for AILocoCompExitAnimationMessage {
}

pub static AILOCOCOMPEXITANIMATIONMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCompExitAnimationMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoCompExitAnimationMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AILocoCompExitAnimationMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOCOMPEXITANIMATIONMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AILocoCompEnterAnimationMessage {
}

pub trait AILocoCompEnterAnimationMessageTrait: TypeObject {
}

impl AILocoCompEnterAnimationMessageTrait for AILocoCompEnterAnimationMessage {
}

pub static AILOCOCOMPENTERANIMATIONMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCompEnterAnimationMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoCompEnterAnimationMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AILocoCompEnterAnimationMessage {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOCOMPENTERANIMATIONMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AIWaypointsShapeData {
    pub _glacier_base: super::pathfinding_shared::WaypointsShapeData,
}

pub trait AIWaypointsShapeDataTrait: super::pathfinding_shared::WaypointsShapeDataTrait {
}

impl AIWaypointsShapeDataTrait for AIWaypointsShapeData {
}

impl super::pathfinding_shared::WaypointsShapeDataTrait for AIWaypointsShapeData {
    fn waypoints(&self) -> &Vec<Option<Arc<Mutex<dyn super::pathfinding_shared::WaypointDataTrait>>>> {
        self._glacier_base.waypoints()
    }
    fn waypoints_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::pathfinding_shared::WaypointDataTrait>>>> {
        self._glacier_base.waypoints_mut()
    }
}

impl super::entity::VectorShapeDataTrait for AIWaypointsShapeData {
    fn points(&self) -> &Vec<super::core::Vec3> {
        self._glacier_base.points()
    }
    fn points_mut(&mut self) -> &mut Vec<super::core::Vec3> {
        self._glacier_base.points_mut()
    }
    fn tension(&self) -> &f32 {
        self._glacier_base.tension()
    }
    fn tension_mut(&mut self) -> &mut f32 {
        self._glacier_base.tension_mut()
    }
    fn is_closed(&self) -> &bool {
        self._glacier_base.is_closed()
    }
    fn is_closed_mut(&mut self) -> &mut bool {
        self._glacier_base.is_closed_mut()
    }
    fn allow_roll(&self) -> &bool {
        self._glacier_base.allow_roll()
    }
    fn allow_roll_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_roll_mut()
    }
    fn allow_yaw_pitch(&self) -> &bool {
        self._glacier_base.allow_yaw_pitch()
    }
    fn allow_yaw_pitch_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_yaw_pitch_mut()
    }
}

impl super::entity::BaseShapeDataTrait for AIWaypointsShapeData {
}

impl super::entity::BaseShapeDataBaseTrait for AIWaypointsShapeData {
}

impl super::entity::GameObjectDataTrait for AIWaypointsShapeData {
}

impl super::core::DataBusPeerTrait for AIWaypointsShapeData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIWaypointsShapeData {
}

impl super::core::DataContainerTrait for AIWaypointsShapeData {
}

pub static AIWAYPOINTSSHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWaypointsShapeData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::pathfinding_shared::WAYPOINTSSHAPEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIWaypointsShapeData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AIWAYPOINTSSHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIWaypointsShapeData {
    fn type_info(&self) -> &'static TypeInfo {
        AIWAYPOINTSSHAPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIWAYPOINTSSHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWaypointsShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIWaypointsShapeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AILocoComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub binding: AILocoBinding,
    pub vault_binding: AILocoVaultBinding,
    pub cover_binding: AILocoCoverBinding,
    pub animation_entity_space_priority: i32,
    pub aim_with_fifa_loco: bool,
    pub fetch_target_from_comp: bool,
    pub canned_turns_check_distance: f32,
    pub wanted_yaw: f32,
    pub wanted_pitch: f32,
    pub facing_target_position: super::core::Vec3,
    pub enable_hover: bool,
}

pub trait AILocoComponentDataTrait: super::entity::GameComponentDataTrait {
    fn binding(&self) -> &AILocoBinding;
    fn binding_mut(&mut self) -> &mut AILocoBinding;
    fn vault_binding(&self) -> &AILocoVaultBinding;
    fn vault_binding_mut(&mut self) -> &mut AILocoVaultBinding;
    fn cover_binding(&self) -> &AILocoCoverBinding;
    fn cover_binding_mut(&mut self) -> &mut AILocoCoverBinding;
    fn animation_entity_space_priority(&self) -> &i32;
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32;
    fn aim_with_fifa_loco(&self) -> &bool;
    fn aim_with_fifa_loco_mut(&mut self) -> &mut bool;
    fn fetch_target_from_comp(&self) -> &bool;
    fn fetch_target_from_comp_mut(&mut self) -> &mut bool;
    fn canned_turns_check_distance(&self) -> &f32;
    fn canned_turns_check_distance_mut(&mut self) -> &mut f32;
    fn wanted_yaw(&self) -> &f32;
    fn wanted_yaw_mut(&mut self) -> &mut f32;
    fn wanted_pitch(&self) -> &f32;
    fn wanted_pitch_mut(&mut self) -> &mut f32;
    fn facing_target_position(&self) -> &super::core::Vec3;
    fn facing_target_position_mut(&mut self) -> &mut super::core::Vec3;
    fn enable_hover(&self) -> &bool;
    fn enable_hover_mut(&mut self) -> &mut bool;
}

impl AILocoComponentDataTrait for AILocoComponentData {
    fn binding(&self) -> &AILocoBinding {
        &self.binding
    }
    fn binding_mut(&mut self) -> &mut AILocoBinding {
        &mut self.binding
    }
    fn vault_binding(&self) -> &AILocoVaultBinding {
        &self.vault_binding
    }
    fn vault_binding_mut(&mut self) -> &mut AILocoVaultBinding {
        &mut self.vault_binding
    }
    fn cover_binding(&self) -> &AILocoCoverBinding {
        &self.cover_binding
    }
    fn cover_binding_mut(&mut self) -> &mut AILocoCoverBinding {
        &mut self.cover_binding
    }
    fn animation_entity_space_priority(&self) -> &i32 {
        &self.animation_entity_space_priority
    }
    fn animation_entity_space_priority_mut(&mut self) -> &mut i32 {
        &mut self.animation_entity_space_priority
    }
    fn aim_with_fifa_loco(&self) -> &bool {
        &self.aim_with_fifa_loco
    }
    fn aim_with_fifa_loco_mut(&mut self) -> &mut bool {
        &mut self.aim_with_fifa_loco
    }
    fn fetch_target_from_comp(&self) -> &bool {
        &self.fetch_target_from_comp
    }
    fn fetch_target_from_comp_mut(&mut self) -> &mut bool {
        &mut self.fetch_target_from_comp
    }
    fn canned_turns_check_distance(&self) -> &f32 {
        &self.canned_turns_check_distance
    }
    fn canned_turns_check_distance_mut(&mut self) -> &mut f32 {
        &mut self.canned_turns_check_distance
    }
    fn wanted_yaw(&self) -> &f32 {
        &self.wanted_yaw
    }
    fn wanted_yaw_mut(&mut self) -> &mut f32 {
        &mut self.wanted_yaw
    }
    fn wanted_pitch(&self) -> &f32 {
        &self.wanted_pitch
    }
    fn wanted_pitch_mut(&mut self) -> &mut f32 {
        &mut self.wanted_pitch
    }
    fn facing_target_position(&self) -> &super::core::Vec3 {
        &self.facing_target_position
    }
    fn facing_target_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.facing_target_position
    }
    fn enable_hover(&self) -> &bool {
        &self.enable_hover
    }
    fn enable_hover_mut(&mut self) -> &mut bool {
        &mut self.enable_hover
    }
}

impl super::entity::GameComponentDataTrait for AILocoComponentData {
}

impl super::entity::ComponentDataTrait for AILocoComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AILocoComponentData {
}

impl super::core::DataBusPeerTrait for AILocoComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AILocoComponentData {
}

impl super::core::DataContainerTrait for AILocoComponentData {
}

pub static AILOCOCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: "AILocoBinding",
                rust_offset: offset_of!(AILocoComponentData, binding),
            },
            FieldInfoData {
                name: "VaultBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "AILocoVaultBinding",
                rust_offset: offset_of!(AILocoComponentData, vault_binding),
            },
            FieldInfoData {
                name: "CoverBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "AILocoCoverBinding",
                rust_offset: offset_of!(AILocoComponentData, cover_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AILocoComponentData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "AimWithFifaLoco",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoComponentData, aim_with_fifa_loco),
            },
            FieldInfoData {
                name: "FetchTargetFromComp",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoComponentData, fetch_target_from_comp),
            },
            FieldInfoData {
                name: "CannedTurnsCheckDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoComponentData, canned_turns_check_distance),
            },
            FieldInfoData {
                name: "WantedYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoComponentData, wanted_yaw),
            },
            FieldInfoData {
                name: "WantedPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoComponentData, wanted_pitch),
            },
            FieldInfoData {
                name: "FacingTargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AILocoComponentData, facing_target_position),
            },
            FieldInfoData {
                name: "EnableHover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoComponentData, enable_hover),
            },
        ],
    }),
    array_type: Some(AILOCOCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AILocoComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AILOCOCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StandardMoveWaypointData {
    pub _glacier_base: AbstractLocoWaypointData,
    pub move_task: AILocoMoveTaskData,
}

pub trait StandardMoveWaypointDataTrait: AbstractLocoWaypointDataTrait {
    fn move_task(&self) -> &AILocoMoveTaskData;
    fn move_task_mut(&mut self) -> &mut AILocoMoveTaskData;
}

impl StandardMoveWaypointDataTrait for StandardMoveWaypointData {
    fn move_task(&self) -> &AILocoMoveTaskData {
        &self.move_task
    }
    fn move_task_mut(&mut self) -> &mut AILocoMoveTaskData {
        &mut self.move_task
    }
}

impl AbstractLocoWaypointDataTrait for StandardMoveWaypointData {
    fn base_task(&self) -> &AILocoBaseTaskData {
        self._glacier_base.base_task()
    }
    fn base_task_mut(&mut self) -> &mut AILocoBaseTaskData {
        self._glacier_base.base_task_mut()
    }
}

impl super::pathfinding_shared::WaypointDataTrait for StandardMoveWaypointData {
    fn use_clients_position(&self) -> &bool {
        self._glacier_base.use_clients_position()
    }
    fn use_clients_position_mut(&mut self) -> &mut bool {
        self._glacier_base.use_clients_position_mut()
    }
    fn schematics_name_hash(&self) -> &i32 {
        self._glacier_base.schematics_name_hash()
    }
    fn schematics_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.schematics_name_hash_mut()
    }
    fn waypoint_id(&self) -> &u32 {
        self._glacier_base.waypoint_id()
    }
    fn waypoint_id_mut(&mut self) -> &mut u32 {
        self._glacier_base.waypoint_id_mut()
    }
}

impl super::core::DataContainerTrait for StandardMoveWaypointData {
}

pub static STANDARDMOVEWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StandardMoveWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StandardMoveWaypointData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MoveTask",
                flags: MemberInfoFlags::new(0),
                field_type: "AILocoMoveTaskData",
                rust_offset: offset_of!(StandardMoveWaypointData, move_task),
            },
        ],
    }),
    array_type: Some(STANDARDMOVEWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StandardMoveWaypointData {
    fn type_info(&self) -> &'static TypeInfo {
        STANDARDMOVEWAYPOINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STANDARDMOVEWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StandardMoveWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StandardMoveWaypointData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VaultWaypointData {
    pub _glacier_base: AbstractLocoWaypointData,
    pub vault_task: AILocoVaultTaskData,
}

pub trait VaultWaypointDataTrait: AbstractLocoWaypointDataTrait {
    fn vault_task(&self) -> &AILocoVaultTaskData;
    fn vault_task_mut(&mut self) -> &mut AILocoVaultTaskData;
}

impl VaultWaypointDataTrait for VaultWaypointData {
    fn vault_task(&self) -> &AILocoVaultTaskData {
        &self.vault_task
    }
    fn vault_task_mut(&mut self) -> &mut AILocoVaultTaskData {
        &mut self.vault_task
    }
}

impl AbstractLocoWaypointDataTrait for VaultWaypointData {
    fn base_task(&self) -> &AILocoBaseTaskData {
        self._glacier_base.base_task()
    }
    fn base_task_mut(&mut self) -> &mut AILocoBaseTaskData {
        self._glacier_base.base_task_mut()
    }
}

impl super::pathfinding_shared::WaypointDataTrait for VaultWaypointData {
    fn use_clients_position(&self) -> &bool {
        self._glacier_base.use_clients_position()
    }
    fn use_clients_position_mut(&mut self) -> &mut bool {
        self._glacier_base.use_clients_position_mut()
    }
    fn schematics_name_hash(&self) -> &i32 {
        self._glacier_base.schematics_name_hash()
    }
    fn schematics_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.schematics_name_hash_mut()
    }
    fn waypoint_id(&self) -> &u32 {
        self._glacier_base.waypoint_id()
    }
    fn waypoint_id_mut(&mut self) -> &mut u32 {
        self._glacier_base.waypoint_id_mut()
    }
}

impl super::core::DataContainerTrait for VaultWaypointData {
}

pub static VAULTWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VaultWaypointData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VaultTask",
                flags: MemberInfoFlags::new(0),
                field_type: "AILocoVaultTaskData",
                rust_offset: offset_of!(VaultWaypointData, vault_task),
            },
        ],
    }),
    array_type: Some(VAULTWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VaultWaypointData {
    fn type_info(&self) -> &'static TypeInfo {
        VAULTWAYPOINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VAULTWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VaultWaypointData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CoverWaypointData {
    pub _glacier_base: AbstractLocoWaypointData,
    pub cover_task: AILocoCoverTaskData,
}

pub trait CoverWaypointDataTrait: AbstractLocoWaypointDataTrait {
    fn cover_task(&self) -> &AILocoCoverTaskData;
    fn cover_task_mut(&mut self) -> &mut AILocoCoverTaskData;
}

impl CoverWaypointDataTrait for CoverWaypointData {
    fn cover_task(&self) -> &AILocoCoverTaskData {
        &self.cover_task
    }
    fn cover_task_mut(&mut self) -> &mut AILocoCoverTaskData {
        &mut self.cover_task
    }
}

impl AbstractLocoWaypointDataTrait for CoverWaypointData {
    fn base_task(&self) -> &AILocoBaseTaskData {
        self._glacier_base.base_task()
    }
    fn base_task_mut(&mut self) -> &mut AILocoBaseTaskData {
        self._glacier_base.base_task_mut()
    }
}

impl super::pathfinding_shared::WaypointDataTrait for CoverWaypointData {
    fn use_clients_position(&self) -> &bool {
        self._glacier_base.use_clients_position()
    }
    fn use_clients_position_mut(&mut self) -> &mut bool {
        self._glacier_base.use_clients_position_mut()
    }
    fn schematics_name_hash(&self) -> &i32 {
        self._glacier_base.schematics_name_hash()
    }
    fn schematics_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.schematics_name_hash_mut()
    }
    fn waypoint_id(&self) -> &u32 {
        self._glacier_base.waypoint_id()
    }
    fn waypoint_id_mut(&mut self) -> &mut u32 {
        self._glacier_base.waypoint_id_mut()
    }
}

impl super::core::DataContainerTrait for CoverWaypointData {
}

pub static COVERWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CoverWaypointData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverTask",
                flags: MemberInfoFlags::new(0),
                field_type: "AILocoCoverTaskData",
                rust_offset: offset_of!(CoverWaypointData, cover_task),
            },
        ],
    }),
    array_type: Some(COVERWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CoverWaypointData {
    fn type_info(&self) -> &'static TypeInfo {
        COVERWAYPOINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COVERWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverWaypointData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScenarioWaypointData {
    pub _glacier_base: AbstractLocoWaypointData,
    pub play_animation: Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>>,
    pub scenario_ant_ref: super::ant::AntRef,
    pub scenario_task: ScenarioTaskData,
}

pub trait ScenarioWaypointDataTrait: AbstractLocoWaypointDataTrait {
    fn play_animation(&self) -> &Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>>;
    fn play_animation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>>;
    fn scenario_ant_ref(&self) -> &super::ant::AntRef;
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef;
    fn scenario_task(&self) -> &ScenarioTaskData;
    fn scenario_task_mut(&mut self) -> &mut ScenarioTaskData;
}

impl ScenarioWaypointDataTrait for ScenarioWaypointData {
    fn play_animation(&self) -> &Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>> {
        &self.play_animation
    }
    fn play_animation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>> {
        &mut self.play_animation
    }
    fn scenario_ant_ref(&self) -> &super::ant::AntRef {
        &self.scenario_ant_ref
    }
    fn scenario_ant_ref_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.scenario_ant_ref
    }
    fn scenario_task(&self) -> &ScenarioTaskData {
        &self.scenario_task
    }
    fn scenario_task_mut(&mut self) -> &mut ScenarioTaskData {
        &mut self.scenario_task
    }
}

impl AbstractLocoWaypointDataTrait for ScenarioWaypointData {
    fn base_task(&self) -> &AILocoBaseTaskData {
        self._glacier_base.base_task()
    }
    fn base_task_mut(&mut self) -> &mut AILocoBaseTaskData {
        self._glacier_base.base_task_mut()
    }
}

impl super::pathfinding_shared::WaypointDataTrait for ScenarioWaypointData {
    fn use_clients_position(&self) -> &bool {
        self._glacier_base.use_clients_position()
    }
    fn use_clients_position_mut(&mut self) -> &mut bool {
        self._glacier_base.use_clients_position_mut()
    }
    fn schematics_name_hash(&self) -> &i32 {
        self._glacier_base.schematics_name_hash()
    }
    fn schematics_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.schematics_name_hash_mut()
    }
    fn waypoint_id(&self) -> &u32 {
        self._glacier_base.waypoint_id()
    }
    fn waypoint_id_mut(&mut self) -> &mut u32 {
        self._glacier_base.waypoint_id_mut()
    }
}

impl super::core::DataContainerTrait for ScenarioWaypointData {
}

pub static SCENARIOWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScenarioWaypointData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlayAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayAnimationData",
                rust_offset: offset_of!(ScenarioWaypointData, play_animation),
            },
            FieldInfoData {
                name: "ScenarioAntRef",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(ScenarioWaypointData, scenario_ant_ref),
            },
            FieldInfoData {
                name: "ScenarioTask",
                flags: MemberInfoFlags::new(0),
                field_type: "ScenarioTaskData",
                rust_offset: offset_of!(ScenarioWaypointData, scenario_task),
            },
        ],
    }),
    array_type: Some(SCENARIOWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScenarioWaypointData {
    fn type_info(&self) -> &'static TypeInfo {
        SCENARIOWAYPOINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCENARIOWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ScenarioWaypointData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AbstractLocoWaypointData {
    pub _glacier_base: super::pathfinding_shared::WaypointData,
    pub base_task: AILocoBaseTaskData,
}

pub trait AbstractLocoWaypointDataTrait: super::pathfinding_shared::WaypointDataTrait {
    fn base_task(&self) -> &AILocoBaseTaskData;
    fn base_task_mut(&mut self) -> &mut AILocoBaseTaskData;
}

impl AbstractLocoWaypointDataTrait for AbstractLocoWaypointData {
    fn base_task(&self) -> &AILocoBaseTaskData {
        &self.base_task
    }
    fn base_task_mut(&mut self) -> &mut AILocoBaseTaskData {
        &mut self.base_task
    }
}

impl super::pathfinding_shared::WaypointDataTrait for AbstractLocoWaypointData {
    fn use_clients_position(&self) -> &bool {
        self._glacier_base.use_clients_position()
    }
    fn use_clients_position_mut(&mut self) -> &mut bool {
        self._glacier_base.use_clients_position_mut()
    }
    fn schematics_name_hash(&self) -> &i32 {
        self._glacier_base.schematics_name_hash()
    }
    fn schematics_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.schematics_name_hash_mut()
    }
    fn waypoint_id(&self) -> &u32 {
        self._glacier_base.waypoint_id()
    }
    fn waypoint_id_mut(&mut self) -> &mut u32 {
        self._glacier_base.waypoint_id_mut()
    }
}

impl super::core::DataContainerTrait for AbstractLocoWaypointData {
}

pub static ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractLocoWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::pathfinding_shared::WAYPOINTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AbstractLocoWaypointData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BaseTask",
                flags: MemberInfoFlags::new(0),
                field_type: "AILocoBaseTaskData",
                rust_offset: offset_of!(AbstractLocoWaypointData, base_task),
            },
        ],
    }),
    array_type: Some(ABSTRACTLOCOWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbstractLocoWaypointData {
    fn type_info(&self) -> &'static TypeInfo {
        ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ABSTRACTLOCOWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractLocoWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AbstractLocoWaypointData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScenarioTaskData {
    pub play_animation: Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>>,
    pub world_angle: f32,
    pub start_point: super::core::Vec3,
    pub scenario_id: i32,
    pub actor_id: i32,
    pub part_id: i32,
    pub level_id: i32,
    pub connect_transforms: Vec<super::core::LinearTransform>,
    pub end_point_world_offset: super::core::Vec3,
    pub trigger_scenario: bool,
    pub start_turn_distance: f32,
    pub start_timer_distance: f32,
    pub trigger_scenario_delay: f32,
    pub still_turn_precision: f32,
    pub use_client_position: bool,
    pub force_wait_for_animation: bool,
    pub overshoot_waypoint: bool,
    pub animation_guid: glacier_util::guid::Guid,
    pub animation_is_looping: bool,
    pub animation_blend_in_time: f32,
    pub animation_blend_out_time: f32,
}

pub trait ScenarioTaskDataTrait: TypeObject {
    fn play_animation(&self) -> &Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>>;
    fn play_animation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>>;
    fn world_angle(&self) -> &f32;
    fn world_angle_mut(&mut self) -> &mut f32;
    fn start_point(&self) -> &super::core::Vec3;
    fn start_point_mut(&mut self) -> &mut super::core::Vec3;
    fn scenario_id(&self) -> &i32;
    fn scenario_id_mut(&mut self) -> &mut i32;
    fn actor_id(&self) -> &i32;
    fn actor_id_mut(&mut self) -> &mut i32;
    fn part_id(&self) -> &i32;
    fn part_id_mut(&mut self) -> &mut i32;
    fn level_id(&self) -> &i32;
    fn level_id_mut(&mut self) -> &mut i32;
    fn connect_transforms(&self) -> &Vec<super::core::LinearTransform>;
    fn connect_transforms_mut(&mut self) -> &mut Vec<super::core::LinearTransform>;
    fn end_point_world_offset(&self) -> &super::core::Vec3;
    fn end_point_world_offset_mut(&mut self) -> &mut super::core::Vec3;
    fn trigger_scenario(&self) -> &bool;
    fn trigger_scenario_mut(&mut self) -> &mut bool;
    fn start_turn_distance(&self) -> &f32;
    fn start_turn_distance_mut(&mut self) -> &mut f32;
    fn start_timer_distance(&self) -> &f32;
    fn start_timer_distance_mut(&mut self) -> &mut f32;
    fn trigger_scenario_delay(&self) -> &f32;
    fn trigger_scenario_delay_mut(&mut self) -> &mut f32;
    fn still_turn_precision(&self) -> &f32;
    fn still_turn_precision_mut(&mut self) -> &mut f32;
    fn use_client_position(&self) -> &bool;
    fn use_client_position_mut(&mut self) -> &mut bool;
    fn force_wait_for_animation(&self) -> &bool;
    fn force_wait_for_animation_mut(&mut self) -> &mut bool;
    fn overshoot_waypoint(&self) -> &bool;
    fn overshoot_waypoint_mut(&mut self) -> &mut bool;
    fn animation_guid(&self) -> &glacier_util::guid::Guid;
    fn animation_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn animation_is_looping(&self) -> &bool;
    fn animation_is_looping_mut(&mut self) -> &mut bool;
    fn animation_blend_in_time(&self) -> &f32;
    fn animation_blend_in_time_mut(&mut self) -> &mut f32;
    fn animation_blend_out_time(&self) -> &f32;
    fn animation_blend_out_time_mut(&mut self) -> &mut f32;
}

impl ScenarioTaskDataTrait for ScenarioTaskData {
    fn play_animation(&self) -> &Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>> {
        &self.play_animation
    }
    fn play_animation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::game_shared::PlayAnimationDataTrait>>> {
        &mut self.play_animation
    }
    fn world_angle(&self) -> &f32 {
        &self.world_angle
    }
    fn world_angle_mut(&mut self) -> &mut f32 {
        &mut self.world_angle
    }
    fn start_point(&self) -> &super::core::Vec3 {
        &self.start_point
    }
    fn start_point_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.start_point
    }
    fn scenario_id(&self) -> &i32 {
        &self.scenario_id
    }
    fn scenario_id_mut(&mut self) -> &mut i32 {
        &mut self.scenario_id
    }
    fn actor_id(&self) -> &i32 {
        &self.actor_id
    }
    fn actor_id_mut(&mut self) -> &mut i32 {
        &mut self.actor_id
    }
    fn part_id(&self) -> &i32 {
        &self.part_id
    }
    fn part_id_mut(&mut self) -> &mut i32 {
        &mut self.part_id
    }
    fn level_id(&self) -> &i32 {
        &self.level_id
    }
    fn level_id_mut(&mut self) -> &mut i32 {
        &mut self.level_id
    }
    fn connect_transforms(&self) -> &Vec<super::core::LinearTransform> {
        &self.connect_transforms
    }
    fn connect_transforms_mut(&mut self) -> &mut Vec<super::core::LinearTransform> {
        &mut self.connect_transforms
    }
    fn end_point_world_offset(&self) -> &super::core::Vec3 {
        &self.end_point_world_offset
    }
    fn end_point_world_offset_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.end_point_world_offset
    }
    fn trigger_scenario(&self) -> &bool {
        &self.trigger_scenario
    }
    fn trigger_scenario_mut(&mut self) -> &mut bool {
        &mut self.trigger_scenario
    }
    fn start_turn_distance(&self) -> &f32 {
        &self.start_turn_distance
    }
    fn start_turn_distance_mut(&mut self) -> &mut f32 {
        &mut self.start_turn_distance
    }
    fn start_timer_distance(&self) -> &f32 {
        &self.start_timer_distance
    }
    fn start_timer_distance_mut(&mut self) -> &mut f32 {
        &mut self.start_timer_distance
    }
    fn trigger_scenario_delay(&self) -> &f32 {
        &self.trigger_scenario_delay
    }
    fn trigger_scenario_delay_mut(&mut self) -> &mut f32 {
        &mut self.trigger_scenario_delay
    }
    fn still_turn_precision(&self) -> &f32 {
        &self.still_turn_precision
    }
    fn still_turn_precision_mut(&mut self) -> &mut f32 {
        &mut self.still_turn_precision
    }
    fn use_client_position(&self) -> &bool {
        &self.use_client_position
    }
    fn use_client_position_mut(&mut self) -> &mut bool {
        &mut self.use_client_position
    }
    fn force_wait_for_animation(&self) -> &bool {
        &self.force_wait_for_animation
    }
    fn force_wait_for_animation_mut(&mut self) -> &mut bool {
        &mut self.force_wait_for_animation
    }
    fn overshoot_waypoint(&self) -> &bool {
        &self.overshoot_waypoint
    }
    fn overshoot_waypoint_mut(&mut self) -> &mut bool {
        &mut self.overshoot_waypoint
    }
    fn animation_guid(&self) -> &glacier_util::guid::Guid {
        &self.animation_guid
    }
    fn animation_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.animation_guid
    }
    fn animation_is_looping(&self) -> &bool {
        &self.animation_is_looping
    }
    fn animation_is_looping_mut(&mut self) -> &mut bool {
        &mut self.animation_is_looping
    }
    fn animation_blend_in_time(&self) -> &f32 {
        &self.animation_blend_in_time
    }
    fn animation_blend_in_time_mut(&mut self) -> &mut f32 {
        &mut self.animation_blend_in_time
    }
    fn animation_blend_out_time(&self) -> &f32 {
        &self.animation_blend_out_time
    }
    fn animation_blend_out_time_mut(&mut self) -> &mut f32 {
        &mut self.animation_blend_out_time
    }
}

pub static SCENARIOTASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioTaskData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScenarioTaskData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlayAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "PlayAnimationData",
                rust_offset: offset_of!(ScenarioTaskData, play_animation),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScenarioTaskData, world_angle),
            },
            FieldInfoData {
                name: "StartPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ScenarioTaskData, start_point),
            },
            FieldInfoData {
                name: "ScenarioId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScenarioTaskData, scenario_id),
            },
            FieldInfoData {
                name: "ActorId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScenarioTaskData, actor_id),
            },
            FieldInfoData {
                name: "PartId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScenarioTaskData, part_id),
            },
            FieldInfoData {
                name: "LevelId",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(ScenarioTaskData, level_id),
            },
            FieldInfoData {
                name: "ConnectTransforms",
                flags: MemberInfoFlags::new(144),
                field_type: "LinearTransform-Array",
                rust_offset: offset_of!(ScenarioTaskData, connect_transforms),
            },
            FieldInfoData {
                name: "EndPointWorldOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ScenarioTaskData, end_point_world_offset),
            },
            FieldInfoData {
                name: "TriggerScenario",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScenarioTaskData, trigger_scenario),
            },
            FieldInfoData {
                name: "StartTurnDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScenarioTaskData, start_turn_distance),
            },
            FieldInfoData {
                name: "StartTimerDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScenarioTaskData, start_timer_distance),
            },
            FieldInfoData {
                name: "TriggerScenarioDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScenarioTaskData, trigger_scenario_delay),
            },
            FieldInfoData {
                name: "StillTurnPrecision",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScenarioTaskData, still_turn_precision),
            },
            FieldInfoData {
                name: "UseClientPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScenarioTaskData, use_client_position),
            },
            FieldInfoData {
                name: "ForceWaitForAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScenarioTaskData, force_wait_for_animation),
            },
            FieldInfoData {
                name: "OvershootWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScenarioTaskData, overshoot_waypoint),
            },
            FieldInfoData {
                name: "AnimationGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(ScenarioTaskData, animation_guid),
            },
            FieldInfoData {
                name: "AnimationIsLooping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ScenarioTaskData, animation_is_looping),
            },
            FieldInfoData {
                name: "AnimationBlendInTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScenarioTaskData, animation_blend_in_time),
            },
            FieldInfoData {
                name: "AnimationBlendOutTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScenarioTaskData, animation_blend_out_time),
            },
        ],
    }),
    array_type: Some(SCENARIOTASKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScenarioTaskData {
    fn type_info(&self) -> &'static TypeInfo {
        SCENARIOTASKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SCENARIOTASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ScenarioTaskData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AILocoCoverTaskData {
    pub cover_type: AntCoverEnum,
    pub cover_pose: AntPoseEnum,
    pub wait_time: f32,
    pub world_angle: f32,
    pub peek_out: CoverPeekType,
    pub idle_behavior: CoverIdleType,
    pub exit_pose: AntPoseEnum,
    pub offset_length: f32,
    pub enter_strategy: CoverEnterStrategy,
    pub exit_angle: f32,
    pub distance_to_next_waypoint: f32,
    pub wanted_pos: super::core::Vec3,
    pub extra_params: AIExtraCoverAnimationData,
    pub align_offset_along: f32,
    pub align_offset_perpendicular: f32,
    pub threat_position: super::core::Vec3,
    pub force_exit_cover: bool,
    pub exit_style: CoverExitStyle,
    pub prepare_fire_type: CoverFireType,
    pub use_client_position: bool,
    pub side_step_direction: CoverSideStepDirection,
    pub hover_direction: CoverHoverDirection,
}

pub trait AILocoCoverTaskDataTrait: TypeObject {
    fn cover_type(&self) -> &AntCoverEnum;
    fn cover_type_mut(&mut self) -> &mut AntCoverEnum;
    fn cover_pose(&self) -> &AntPoseEnum;
    fn cover_pose_mut(&mut self) -> &mut AntPoseEnum;
    fn wait_time(&self) -> &f32;
    fn wait_time_mut(&mut self) -> &mut f32;
    fn world_angle(&self) -> &f32;
    fn world_angle_mut(&mut self) -> &mut f32;
    fn peek_out(&self) -> &CoverPeekType;
    fn peek_out_mut(&mut self) -> &mut CoverPeekType;
    fn idle_behavior(&self) -> &CoverIdleType;
    fn idle_behavior_mut(&mut self) -> &mut CoverIdleType;
    fn exit_pose(&self) -> &AntPoseEnum;
    fn exit_pose_mut(&mut self) -> &mut AntPoseEnum;
    fn offset_length(&self) -> &f32;
    fn offset_length_mut(&mut self) -> &mut f32;
    fn enter_strategy(&self) -> &CoverEnterStrategy;
    fn enter_strategy_mut(&mut self) -> &mut CoverEnterStrategy;
    fn exit_angle(&self) -> &f32;
    fn exit_angle_mut(&mut self) -> &mut f32;
    fn distance_to_next_waypoint(&self) -> &f32;
    fn distance_to_next_waypoint_mut(&mut self) -> &mut f32;
    fn wanted_pos(&self) -> &super::core::Vec3;
    fn wanted_pos_mut(&mut self) -> &mut super::core::Vec3;
    fn extra_params(&self) -> &AIExtraCoverAnimationData;
    fn extra_params_mut(&mut self) -> &mut AIExtraCoverAnimationData;
    fn align_offset_along(&self) -> &f32;
    fn align_offset_along_mut(&mut self) -> &mut f32;
    fn align_offset_perpendicular(&self) -> &f32;
    fn align_offset_perpendicular_mut(&mut self) -> &mut f32;
    fn threat_position(&self) -> &super::core::Vec3;
    fn threat_position_mut(&mut self) -> &mut super::core::Vec3;
    fn force_exit_cover(&self) -> &bool;
    fn force_exit_cover_mut(&mut self) -> &mut bool;
    fn exit_style(&self) -> &CoverExitStyle;
    fn exit_style_mut(&mut self) -> &mut CoverExitStyle;
    fn prepare_fire_type(&self) -> &CoverFireType;
    fn prepare_fire_type_mut(&mut self) -> &mut CoverFireType;
    fn use_client_position(&self) -> &bool;
    fn use_client_position_mut(&mut self) -> &mut bool;
    fn side_step_direction(&self) -> &CoverSideStepDirection;
    fn side_step_direction_mut(&mut self) -> &mut CoverSideStepDirection;
    fn hover_direction(&self) -> &CoverHoverDirection;
    fn hover_direction_mut(&mut self) -> &mut CoverHoverDirection;
}

impl AILocoCoverTaskDataTrait for AILocoCoverTaskData {
    fn cover_type(&self) -> &AntCoverEnum {
        &self.cover_type
    }
    fn cover_type_mut(&mut self) -> &mut AntCoverEnum {
        &mut self.cover_type
    }
    fn cover_pose(&self) -> &AntPoseEnum {
        &self.cover_pose
    }
    fn cover_pose_mut(&mut self) -> &mut AntPoseEnum {
        &mut self.cover_pose
    }
    fn wait_time(&self) -> &f32 {
        &self.wait_time
    }
    fn wait_time_mut(&mut self) -> &mut f32 {
        &mut self.wait_time
    }
    fn world_angle(&self) -> &f32 {
        &self.world_angle
    }
    fn world_angle_mut(&mut self) -> &mut f32 {
        &mut self.world_angle
    }
    fn peek_out(&self) -> &CoverPeekType {
        &self.peek_out
    }
    fn peek_out_mut(&mut self) -> &mut CoverPeekType {
        &mut self.peek_out
    }
    fn idle_behavior(&self) -> &CoverIdleType {
        &self.idle_behavior
    }
    fn idle_behavior_mut(&mut self) -> &mut CoverIdleType {
        &mut self.idle_behavior
    }
    fn exit_pose(&self) -> &AntPoseEnum {
        &self.exit_pose
    }
    fn exit_pose_mut(&mut self) -> &mut AntPoseEnum {
        &mut self.exit_pose
    }
    fn offset_length(&self) -> &f32 {
        &self.offset_length
    }
    fn offset_length_mut(&mut self) -> &mut f32 {
        &mut self.offset_length
    }
    fn enter_strategy(&self) -> &CoverEnterStrategy {
        &self.enter_strategy
    }
    fn enter_strategy_mut(&mut self) -> &mut CoverEnterStrategy {
        &mut self.enter_strategy
    }
    fn exit_angle(&self) -> &f32 {
        &self.exit_angle
    }
    fn exit_angle_mut(&mut self) -> &mut f32 {
        &mut self.exit_angle
    }
    fn distance_to_next_waypoint(&self) -> &f32 {
        &self.distance_to_next_waypoint
    }
    fn distance_to_next_waypoint_mut(&mut self) -> &mut f32 {
        &mut self.distance_to_next_waypoint
    }
    fn wanted_pos(&self) -> &super::core::Vec3 {
        &self.wanted_pos
    }
    fn wanted_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.wanted_pos
    }
    fn extra_params(&self) -> &AIExtraCoverAnimationData {
        &self.extra_params
    }
    fn extra_params_mut(&mut self) -> &mut AIExtraCoverAnimationData {
        &mut self.extra_params
    }
    fn align_offset_along(&self) -> &f32 {
        &self.align_offset_along
    }
    fn align_offset_along_mut(&mut self) -> &mut f32 {
        &mut self.align_offset_along
    }
    fn align_offset_perpendicular(&self) -> &f32 {
        &self.align_offset_perpendicular
    }
    fn align_offset_perpendicular_mut(&mut self) -> &mut f32 {
        &mut self.align_offset_perpendicular
    }
    fn threat_position(&self) -> &super::core::Vec3 {
        &self.threat_position
    }
    fn threat_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.threat_position
    }
    fn force_exit_cover(&self) -> &bool {
        &self.force_exit_cover
    }
    fn force_exit_cover_mut(&mut self) -> &mut bool {
        &mut self.force_exit_cover
    }
    fn exit_style(&self) -> &CoverExitStyle {
        &self.exit_style
    }
    fn exit_style_mut(&mut self) -> &mut CoverExitStyle {
        &mut self.exit_style
    }
    fn prepare_fire_type(&self) -> &CoverFireType {
        &self.prepare_fire_type
    }
    fn prepare_fire_type_mut(&mut self) -> &mut CoverFireType {
        &mut self.prepare_fire_type
    }
    fn use_client_position(&self) -> &bool {
        &self.use_client_position
    }
    fn use_client_position_mut(&mut self) -> &mut bool {
        &mut self.use_client_position
    }
    fn side_step_direction(&self) -> &CoverSideStepDirection {
        &self.side_step_direction
    }
    fn side_step_direction_mut(&mut self) -> &mut CoverSideStepDirection {
        &mut self.side_step_direction
    }
    fn hover_direction(&self) -> &CoverHoverDirection {
        &self.hover_direction
    }
    fn hover_direction_mut(&mut self) -> &mut CoverHoverDirection {
        &mut self.hover_direction
    }
}

pub static AILOCOCOVERTASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCoverTaskData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoCoverTaskData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CoverType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntCoverEnum",
                rust_offset: offset_of!(AILocoCoverTaskData, cover_type),
            },
            FieldInfoData {
                name: "CoverPose",
                flags: MemberInfoFlags::new(0),
                field_type: "AntPoseEnum",
                rust_offset: offset_of!(AILocoCoverTaskData, cover_pose),
            },
            FieldInfoData {
                name: "WaitTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoCoverTaskData, wait_time),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoCoverTaskData, world_angle),
            },
            FieldInfoData {
                name: "PeekOut",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverPeekType",
                rust_offset: offset_of!(AILocoCoverTaskData, peek_out),
            },
            FieldInfoData {
                name: "IdleBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverIdleType",
                rust_offset: offset_of!(AILocoCoverTaskData, idle_behavior),
            },
            FieldInfoData {
                name: "ExitPose",
                flags: MemberInfoFlags::new(0),
                field_type: "AntPoseEnum",
                rust_offset: offset_of!(AILocoCoverTaskData, exit_pose),
            },
            FieldInfoData {
                name: "OffsetLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoCoverTaskData, offset_length),
            },
            FieldInfoData {
                name: "EnterStrategy",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverEnterStrategy",
                rust_offset: offset_of!(AILocoCoverTaskData, enter_strategy),
            },
            FieldInfoData {
                name: "ExitAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoCoverTaskData, exit_angle),
            },
            FieldInfoData {
                name: "DistanceToNextWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoCoverTaskData, distance_to_next_waypoint),
            },
            FieldInfoData {
                name: "WantedPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AILocoCoverTaskData, wanted_pos),
            },
            FieldInfoData {
                name: "ExtraParams",
                flags: MemberInfoFlags::new(0),
                field_type: "AIExtraCoverAnimationData",
                rust_offset: offset_of!(AILocoCoverTaskData, extra_params),
            },
            FieldInfoData {
                name: "AlignOffsetAlong",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoCoverTaskData, align_offset_along),
            },
            FieldInfoData {
                name: "AlignOffsetPerpendicular",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoCoverTaskData, align_offset_perpendicular),
            },
            FieldInfoData {
                name: "ThreatPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AILocoCoverTaskData, threat_position),
            },
            FieldInfoData {
                name: "ForceExitCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoCoverTaskData, force_exit_cover),
            },
            FieldInfoData {
                name: "ExitStyle",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverExitStyle",
                rust_offset: offset_of!(AILocoCoverTaskData, exit_style),
            },
            FieldInfoData {
                name: "PrepareFireType",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverFireType",
                rust_offset: offset_of!(AILocoCoverTaskData, prepare_fire_type),
            },
            FieldInfoData {
                name: "UseClientPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoCoverTaskData, use_client_position),
            },
            FieldInfoData {
                name: "SideStepDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverSideStepDirection",
                rust_offset: offset_of!(AILocoCoverTaskData, side_step_direction),
            },
            FieldInfoData {
                name: "HoverDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverHoverDirection",
                rust_offset: offset_of!(AILocoCoverTaskData, hover_direction),
            },
        ],
    }),
    array_type: Some(AILOCOCOVERTASKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AILocoCoverTaskData {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOCOVERTASKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AILOCOCOVERTASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCoverTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoCoverTaskData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverSideStepFuturePose {
    #[default]
    CoverSideStepFuturePose_Stand = 0,
    CoverSideStepFuturePose_Crouch = 1,
}

pub static COVERSIDESTEPFUTUREPOSE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepFuturePose",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERSIDESTEPFUTUREPOSE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverSideStepFuturePose {
    fn type_info(&self) -> &'static TypeInfo {
        COVERSIDESTEPFUTUREPOSE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERSIDESTEPFUTUREPOSE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepFuturePose-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSideStepFuturePose"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverSideStepDirection {
    #[default]
    CoverSideStepDirection_None = 0,
    CoverSideStepDirection_Left_1m = 1,
    CoverSideStepDirection_Right_1m = 2,
    CoverSideStepDirection_Left_2m = 3,
    CoverSideStepDirection_Right_2m = 4,
    CoverSideStepDirection_Offset_Crouch = 5,
    CoverSideStepDirection_Left_1m_Crouch = 6,
    CoverSideStepDirection_Right_1m_Crouch = 7,
    CoverSideStepDirection_Left_2m_Crouch = 8,
    CoverSideStepDirection_Right_2m_Crouch = 9,
}

pub static COVERSIDESTEPDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepDirection",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERSIDESTEPDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverSideStepDirection {
    fn type_info(&self) -> &'static TypeInfo {
        COVERSIDESTEPDIRECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERSIDESTEPDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepDirection-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSideStepDirection"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverHoverDirection {
    #[default]
    CoverHoverDirection_None = 0,
    CoverHoverDirection_Left = 1,
    CoverHoverDirection_Right = 2,
}

pub static COVERHOVERDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverHoverDirection",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERHOVERDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverHoverDirection {
    fn type_info(&self) -> &'static TypeInfo {
        COVERHOVERDIRECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERHOVERDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverHoverDirection-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverHoverDirection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIExtraCoverAnimationData {
    pub animation_time: f32,
    pub animation_height: f32,
}

pub trait AIExtraCoverAnimationDataTrait: TypeObject {
    fn animation_time(&self) -> &f32;
    fn animation_time_mut(&mut self) -> &mut f32;
    fn animation_height(&self) -> &f32;
    fn animation_height_mut(&mut self) -> &mut f32;
}

impl AIExtraCoverAnimationDataTrait for AIExtraCoverAnimationData {
    fn animation_time(&self) -> &f32 {
        &self.animation_time
    }
    fn animation_time_mut(&mut self) -> &mut f32 {
        &mut self.animation_time
    }
    fn animation_height(&self) -> &f32 {
        &self.animation_height
    }
    fn animation_height_mut(&mut self) -> &mut f32 {
        &mut self.animation_height
    }
}

pub static AIEXTRACOVERANIMATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIExtraCoverAnimationData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIExtraCoverAnimationData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AnimationTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIExtraCoverAnimationData, animation_time),
            },
            FieldInfoData {
                name: "AnimationHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIExtraCoverAnimationData, animation_height),
            },
        ],
    }),
    array_type: Some(AIEXTRACOVERANIMATIONDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIExtraCoverAnimationData {
    fn type_info(&self) -> &'static TypeInfo {
        AIEXTRACOVERANIMATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIEXTRACOVERANIMATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIExtraCoverAnimationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIExtraCoverAnimationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverExitStyle {
    #[default]
    CoverExitStyle_ExitCover = 0,
    CoverExitStyle_VaultFromCrouchCover = 1,
    CoverExitStyle_StrafeFire = 2,
    CoverExitStyle_Surprised = 3,
    CoverExitStyle_Sprint = 4,
}

pub static COVEREXITSTYLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverExitStyle",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVEREXITSTYLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverExitStyle {
    fn type_info(&self) -> &'static TypeInfo {
        COVEREXITSTYLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVEREXITSTYLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverExitStyle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverExitStyle"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverEnterStrategy {
    #[default]
    CoverEnterStrategy_EnterNormally = 0,
    CoverEnterStrategy_SkipEnterButAlign = 1,
    CoverEnterStrategy_SkipEnterDontAlign = 2,
}

pub static COVERENTERSTRATEGY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverEnterStrategy",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERENTERSTRATEGY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverEnterStrategy {
    fn type_info(&self) -> &'static TypeInfo {
        COVERENTERSTRATEGY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERENTERSTRATEGY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverEnterStrategy-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverEnterStrategy"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverIdleType {
    #[default]
    CoverIdleType_Calm = 0,
    CoverIdleType_SearchForEnemy = 1,
    CoverIdleType_PeekOut = 2,
    CoverIdleType_PeekOver = 3,
    CoverIdleType_UnderFire = 4,
    CoverIdleType_Suppressed = 5,
}

pub static COVERIDLETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverIdleType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERIDLETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverIdleType {
    fn type_info(&self) -> &'static TypeInfo {
        COVERIDLETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERIDLETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverIdleType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverIdleType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverPeekType {
    #[default]
    CoverPeekType_Out = 0,
    CoverPeekType_Over = 1,
    CoverPeekType_None = 2,
}

pub static COVERPEEKTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPeekType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERPEEKTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverPeekType {
    fn type_info(&self) -> &'static TypeInfo {
        COVERPEEKTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERPEEKTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPeekType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverPeekType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AntCoverFireType {
    #[default]
    AntCoverFireType_PeekFire = 0,
    AntCoverFireType_FireStepOut = 1,
    AntCoverFireType_FireOver = 2,
    AntCoverFireType_BlindFireAround = 3,
    AntCoverFireType_BlindFireOver = 4,
    AntCoverFireType_FlankedWhileFiring = 8,
    AntCoverFireType_FireStepOutSlow = 10,
    AntCoverFireType_FireStepOutUrgent = 11,
    AntCoverFireType_FireStepOut_Crouched = 12,
    AntCoverFireType_FireLmg = 13,
    AntCoverFireType_FireFromHipStepOut = 14,
}

pub static ANTCOVERFIRETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntCoverFireType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTCOVERFIRETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntCoverFireType {
    fn type_info(&self) -> &'static TypeInfo {
        ANTCOVERFIRETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTCOVERFIRETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntCoverFireType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntCoverFireType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CoverFireType {
    #[default]
    CoverFireType_NoFire = 7,
    CoverFireType_Peek = 0,
    CoverFireType_Out = 1,
    CoverFireType_Over = 2,
    CoverFireType_BlindOut = 3,
    CoverFireType_BlindOver = 4,
    CoverFireType_GrenadeOut = 5,
    CoverFireType_GrenadeBlindOver = 6,
    CoverFireType_Flanked = 8,
    CoverFireType_OutSlow = 10,
    CoverFireType_OutUrgent = 11,
    CoverFireType_OutStandToCrouch = 12,
    CoverFireType_Lmg = 13,
    CoverFireType_OutFireFromHip = 14,
    CoverFireType_FlankedSurprised = 15,
    CoverFireType_Hover = 16,
}

pub static COVERFIRETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverFireType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERFIRETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverFireType {
    fn type_info(&self) -> &'static TypeInfo {
        COVERFIRETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COVERFIRETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverFireType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverFireType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AILocoBaseTaskData {
    pub pose_change_moving_towards: AntPoseEnum,
    pub attention_change_moving_towards: AntAttentionStateEnum,
    pub speed_change_moving_towards: AntSpeedLevel,
    pub pose_change: AntPoseEnum,
    pub attention_state_change: AntAttentionStateEnum,
    pub speed_level_change: AntSpeedLevel,
    pub is_scripted: bool,
    pub disable_canned_turn_by_environment: bool,
    pub radius: f32,
}

pub trait AILocoBaseTaskDataTrait: TypeObject {
    fn pose_change_moving_towards(&self) -> &AntPoseEnum;
    fn pose_change_moving_towards_mut(&mut self) -> &mut AntPoseEnum;
    fn attention_change_moving_towards(&self) -> &AntAttentionStateEnum;
    fn attention_change_moving_towards_mut(&mut self) -> &mut AntAttentionStateEnum;
    fn speed_change_moving_towards(&self) -> &AntSpeedLevel;
    fn speed_change_moving_towards_mut(&mut self) -> &mut AntSpeedLevel;
    fn pose_change(&self) -> &AntPoseEnum;
    fn pose_change_mut(&mut self) -> &mut AntPoseEnum;
    fn attention_state_change(&self) -> &AntAttentionStateEnum;
    fn attention_state_change_mut(&mut self) -> &mut AntAttentionStateEnum;
    fn speed_level_change(&self) -> &AntSpeedLevel;
    fn speed_level_change_mut(&mut self) -> &mut AntSpeedLevel;
    fn is_scripted(&self) -> &bool;
    fn is_scripted_mut(&mut self) -> &mut bool;
    fn disable_canned_turn_by_environment(&self) -> &bool;
    fn disable_canned_turn_by_environment_mut(&mut self) -> &mut bool;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
}

impl AILocoBaseTaskDataTrait for AILocoBaseTaskData {
    fn pose_change_moving_towards(&self) -> &AntPoseEnum {
        &self.pose_change_moving_towards
    }
    fn pose_change_moving_towards_mut(&mut self) -> &mut AntPoseEnum {
        &mut self.pose_change_moving_towards
    }
    fn attention_change_moving_towards(&self) -> &AntAttentionStateEnum {
        &self.attention_change_moving_towards
    }
    fn attention_change_moving_towards_mut(&mut self) -> &mut AntAttentionStateEnum {
        &mut self.attention_change_moving_towards
    }
    fn speed_change_moving_towards(&self) -> &AntSpeedLevel {
        &self.speed_change_moving_towards
    }
    fn speed_change_moving_towards_mut(&mut self) -> &mut AntSpeedLevel {
        &mut self.speed_change_moving_towards
    }
    fn pose_change(&self) -> &AntPoseEnum {
        &self.pose_change
    }
    fn pose_change_mut(&mut self) -> &mut AntPoseEnum {
        &mut self.pose_change
    }
    fn attention_state_change(&self) -> &AntAttentionStateEnum {
        &self.attention_state_change
    }
    fn attention_state_change_mut(&mut self) -> &mut AntAttentionStateEnum {
        &mut self.attention_state_change
    }
    fn speed_level_change(&self) -> &AntSpeedLevel {
        &self.speed_level_change
    }
    fn speed_level_change_mut(&mut self) -> &mut AntSpeedLevel {
        &mut self.speed_level_change
    }
    fn is_scripted(&self) -> &bool {
        &self.is_scripted
    }
    fn is_scripted_mut(&mut self) -> &mut bool {
        &mut self.is_scripted
    }
    fn disable_canned_turn_by_environment(&self) -> &bool {
        &self.disable_canned_turn_by_environment
    }
    fn disable_canned_turn_by_environment_mut(&mut self) -> &mut bool {
        &mut self.disable_canned_turn_by_environment
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
}

pub static AILOCOBASETASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoBaseTaskData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoBaseTaskData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PoseChangeMovingTowards",
                flags: MemberInfoFlags::new(0),
                field_type: "AntPoseEnum",
                rust_offset: offset_of!(AILocoBaseTaskData, pose_change_moving_towards),
            },
            FieldInfoData {
                name: "AttentionChangeMovingTowards",
                flags: MemberInfoFlags::new(0),
                field_type: "AntAttentionStateEnum",
                rust_offset: offset_of!(AILocoBaseTaskData, attention_change_moving_towards),
            },
            FieldInfoData {
                name: "SpeedChangeMovingTowards",
                flags: MemberInfoFlags::new(0),
                field_type: "AntSpeedLevel",
                rust_offset: offset_of!(AILocoBaseTaskData, speed_change_moving_towards),
            },
            FieldInfoData {
                name: "PoseChange",
                flags: MemberInfoFlags::new(0),
                field_type: "AntPoseEnum",
                rust_offset: offset_of!(AILocoBaseTaskData, pose_change),
            },
            FieldInfoData {
                name: "AttentionStateChange",
                flags: MemberInfoFlags::new(0),
                field_type: "AntAttentionStateEnum",
                rust_offset: offset_of!(AILocoBaseTaskData, attention_state_change),
            },
            FieldInfoData {
                name: "SpeedLevelChange",
                flags: MemberInfoFlags::new(0),
                field_type: "AntSpeedLevel",
                rust_offset: offset_of!(AILocoBaseTaskData, speed_level_change),
            },
            FieldInfoData {
                name: "IsScripted",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoBaseTaskData, is_scripted),
            },
            FieldInfoData {
                name: "DisableCannedTurnByEnvironment",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoBaseTaskData, disable_canned_turn_by_environment),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoBaseTaskData, radius),
            },
        ],
    }),
    array_type: Some(AILOCOBASETASKDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AILocoBaseTaskData {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOBASETASKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AILOCOBASETASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoBaseTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoBaseTaskData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AILocoMoveTaskData {
    pub wait_time: f32,
    pub world_angle: f32,
    pub override_angle: bool,
    pub still_turn_precision: f32,
    pub enter_pose: AntPoseEnum,
    pub exit_pose: AntPoseEnum,
    pub wanted_pos: super::core::Vec3,
    pub use_client_position: bool,
    pub only_signal_almost_finished_when_moving_towards_waypoint: bool,
    pub almost_finished_distance: f32,
    pub align_to_end: bool,
}

pub trait AILocoMoveTaskDataTrait: TypeObject {
    fn wait_time(&self) -> &f32;
    fn wait_time_mut(&mut self) -> &mut f32;
    fn world_angle(&self) -> &f32;
    fn world_angle_mut(&mut self) -> &mut f32;
    fn override_angle(&self) -> &bool;
    fn override_angle_mut(&mut self) -> &mut bool;
    fn still_turn_precision(&self) -> &f32;
    fn still_turn_precision_mut(&mut self) -> &mut f32;
    fn enter_pose(&self) -> &AntPoseEnum;
    fn enter_pose_mut(&mut self) -> &mut AntPoseEnum;
    fn exit_pose(&self) -> &AntPoseEnum;
    fn exit_pose_mut(&mut self) -> &mut AntPoseEnum;
    fn wanted_pos(&self) -> &super::core::Vec3;
    fn wanted_pos_mut(&mut self) -> &mut super::core::Vec3;
    fn use_client_position(&self) -> &bool;
    fn use_client_position_mut(&mut self) -> &mut bool;
    fn only_signal_almost_finished_when_moving_towards_waypoint(&self) -> &bool;
    fn only_signal_almost_finished_when_moving_towards_waypoint_mut(&mut self) -> &mut bool;
    fn almost_finished_distance(&self) -> &f32;
    fn almost_finished_distance_mut(&mut self) -> &mut f32;
    fn align_to_end(&self) -> &bool;
    fn align_to_end_mut(&mut self) -> &mut bool;
}

impl AILocoMoveTaskDataTrait for AILocoMoveTaskData {
    fn wait_time(&self) -> &f32 {
        &self.wait_time
    }
    fn wait_time_mut(&mut self) -> &mut f32 {
        &mut self.wait_time
    }
    fn world_angle(&self) -> &f32 {
        &self.world_angle
    }
    fn world_angle_mut(&mut self) -> &mut f32 {
        &mut self.world_angle
    }
    fn override_angle(&self) -> &bool {
        &self.override_angle
    }
    fn override_angle_mut(&mut self) -> &mut bool {
        &mut self.override_angle
    }
    fn still_turn_precision(&self) -> &f32 {
        &self.still_turn_precision
    }
    fn still_turn_precision_mut(&mut self) -> &mut f32 {
        &mut self.still_turn_precision
    }
    fn enter_pose(&self) -> &AntPoseEnum {
        &self.enter_pose
    }
    fn enter_pose_mut(&mut self) -> &mut AntPoseEnum {
        &mut self.enter_pose
    }
    fn exit_pose(&self) -> &AntPoseEnum {
        &self.exit_pose
    }
    fn exit_pose_mut(&mut self) -> &mut AntPoseEnum {
        &mut self.exit_pose
    }
    fn wanted_pos(&self) -> &super::core::Vec3 {
        &self.wanted_pos
    }
    fn wanted_pos_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.wanted_pos
    }
    fn use_client_position(&self) -> &bool {
        &self.use_client_position
    }
    fn use_client_position_mut(&mut self) -> &mut bool {
        &mut self.use_client_position
    }
    fn only_signal_almost_finished_when_moving_towards_waypoint(&self) -> &bool {
        &self.only_signal_almost_finished_when_moving_towards_waypoint
    }
    fn only_signal_almost_finished_when_moving_towards_waypoint_mut(&mut self) -> &mut bool {
        &mut self.only_signal_almost_finished_when_moving_towards_waypoint
    }
    fn almost_finished_distance(&self) -> &f32 {
        &self.almost_finished_distance
    }
    fn almost_finished_distance_mut(&mut self) -> &mut f32 {
        &mut self.almost_finished_distance
    }
    fn align_to_end(&self) -> &bool {
        &self.align_to_end
    }
    fn align_to_end_mut(&mut self) -> &mut bool {
        &mut self.align_to_end
    }
}

pub static AILOCOMOVETASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoMoveTaskData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoMoveTaskData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WaitTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoMoveTaskData, wait_time),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoMoveTaskData, world_angle),
            },
            FieldInfoData {
                name: "OverrideAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoMoveTaskData, override_angle),
            },
            FieldInfoData {
                name: "StillTurnPrecision",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoMoveTaskData, still_turn_precision),
            },
            FieldInfoData {
                name: "EnterPose",
                flags: MemberInfoFlags::new(0),
                field_type: "AntPoseEnum",
                rust_offset: offset_of!(AILocoMoveTaskData, enter_pose),
            },
            FieldInfoData {
                name: "ExitPose",
                flags: MemberInfoFlags::new(0),
                field_type: "AntPoseEnum",
                rust_offset: offset_of!(AILocoMoveTaskData, exit_pose),
            },
            FieldInfoData {
                name: "WantedPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AILocoMoveTaskData, wanted_pos),
            },
            FieldInfoData {
                name: "UseClientPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoMoveTaskData, use_client_position),
            },
            FieldInfoData {
                name: "OnlySignalAlmostFinishedWhenMovingTowardsWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoMoveTaskData, only_signal_almost_finished_when_moving_towards_waypoint),
            },
            FieldInfoData {
                name: "AlmostFinishedDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoMoveTaskData, almost_finished_distance),
            },
            FieldInfoData {
                name: "AlignToEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoMoveTaskData, align_to_end),
            },
        ],
    }),
    array_type: Some(AILOCOMOVETASKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AILocoMoveTaskData {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOMOVETASKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AILOCOMOVETASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoMoveTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoMoveTaskData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AILocoVaultTaskData {
    pub distance_before_vault: f32,
    pub height_before_vault: f32,
    pub length_of_vaultable_object: f32,
    pub height_after_vault: f32,
    pub distance_after_vault: f32,
    pub world_angle: f32,
    pub start_point: super::core::Vec3,
    pub use_client_position: bool,
    pub vault_type: super::ant::WaypointVaultType,
}

pub trait AILocoVaultTaskDataTrait: TypeObject {
    fn distance_before_vault(&self) -> &f32;
    fn distance_before_vault_mut(&mut self) -> &mut f32;
    fn height_before_vault(&self) -> &f32;
    fn height_before_vault_mut(&mut self) -> &mut f32;
    fn length_of_vaultable_object(&self) -> &f32;
    fn length_of_vaultable_object_mut(&mut self) -> &mut f32;
    fn height_after_vault(&self) -> &f32;
    fn height_after_vault_mut(&mut self) -> &mut f32;
    fn distance_after_vault(&self) -> &f32;
    fn distance_after_vault_mut(&mut self) -> &mut f32;
    fn world_angle(&self) -> &f32;
    fn world_angle_mut(&mut self) -> &mut f32;
    fn start_point(&self) -> &super::core::Vec3;
    fn start_point_mut(&mut self) -> &mut super::core::Vec3;
    fn use_client_position(&self) -> &bool;
    fn use_client_position_mut(&mut self) -> &mut bool;
    fn vault_type(&self) -> &super::ant::WaypointVaultType;
    fn vault_type_mut(&mut self) -> &mut super::ant::WaypointVaultType;
}

impl AILocoVaultTaskDataTrait for AILocoVaultTaskData {
    fn distance_before_vault(&self) -> &f32 {
        &self.distance_before_vault
    }
    fn distance_before_vault_mut(&mut self) -> &mut f32 {
        &mut self.distance_before_vault
    }
    fn height_before_vault(&self) -> &f32 {
        &self.height_before_vault
    }
    fn height_before_vault_mut(&mut self) -> &mut f32 {
        &mut self.height_before_vault
    }
    fn length_of_vaultable_object(&self) -> &f32 {
        &self.length_of_vaultable_object
    }
    fn length_of_vaultable_object_mut(&mut self) -> &mut f32 {
        &mut self.length_of_vaultable_object
    }
    fn height_after_vault(&self) -> &f32 {
        &self.height_after_vault
    }
    fn height_after_vault_mut(&mut self) -> &mut f32 {
        &mut self.height_after_vault
    }
    fn distance_after_vault(&self) -> &f32 {
        &self.distance_after_vault
    }
    fn distance_after_vault_mut(&mut self) -> &mut f32 {
        &mut self.distance_after_vault
    }
    fn world_angle(&self) -> &f32 {
        &self.world_angle
    }
    fn world_angle_mut(&mut self) -> &mut f32 {
        &mut self.world_angle
    }
    fn start_point(&self) -> &super::core::Vec3 {
        &self.start_point
    }
    fn start_point_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.start_point
    }
    fn use_client_position(&self) -> &bool {
        &self.use_client_position
    }
    fn use_client_position_mut(&mut self) -> &mut bool {
        &mut self.use_client_position
    }
    fn vault_type(&self) -> &super::ant::WaypointVaultType {
        &self.vault_type
    }
    fn vault_type_mut(&mut self) -> &mut super::ant::WaypointVaultType {
        &mut self.vault_type
    }
}

pub static AILOCOVAULTTASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoVaultTaskData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoVaultTaskData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DistanceBeforeVault",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoVaultTaskData, distance_before_vault),
            },
            FieldInfoData {
                name: "HeightBeforeVault",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoVaultTaskData, height_before_vault),
            },
            FieldInfoData {
                name: "LengthOfVaultableObject",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoVaultTaskData, length_of_vaultable_object),
            },
            FieldInfoData {
                name: "HeightAfterVault",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoVaultTaskData, height_after_vault),
            },
            FieldInfoData {
                name: "DistanceAfterVault",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoVaultTaskData, distance_after_vault),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AILocoVaultTaskData, world_angle),
            },
            FieldInfoData {
                name: "StartPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AILocoVaultTaskData, start_point),
            },
            FieldInfoData {
                name: "UseClientPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AILocoVaultTaskData, use_client_position),
            },
            FieldInfoData {
                name: "VaultType",
                flags: MemberInfoFlags::new(0),
                field_type: "WaypointVaultType",
                rust_offset: offset_of!(AILocoVaultTaskData, vault_type),
            },
        ],
    }),
    array_type: Some(AILOCOVAULTTASKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AILocoVaultTaskData {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOVAULTTASKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AILOCOVAULTTASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoVaultTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoVaultTaskData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AntSpeedLevel {
    #[default]
    AntSpeedLevel_Still = 0,
    AntSpeedLevel_Walk = 1,
    AntSpeedLevel_Jog = 2,
    AntSpeedLevel_Sneak = 3,
    AntSpeedLevel_Run = 4,
    AntSpeedLevel_Sprint = 5,
    AntSpeedLevel_Stairs_Walk_Up = 6,
    AntSpeedLevel_Stairs_Walk_Down = 7,
    AntSpeedLevel_Stairs_Run_Up = 8,
    AntSpeedLevel_Stairs_Run_Down = 9,
    AntSpeedLevel_Stairs_Sprint_Up = 10,
    AntSpeedLevel_Stairs_Sprint_Down = 11,
    AntSpeedLevel_AntEnumCount = 12,
    AntSpeedLevel_NoChange = 13,
    AntSpeedLevel_Count = 14,
}

pub static ANTSPEEDLEVEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntSpeedLevel",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTSPEEDLEVEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntSpeedLevel {
    fn type_info(&self) -> &'static TypeInfo {
        ANTSPEEDLEVEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTSPEEDLEVEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntSpeedLevel-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntSpeedLevel"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AntAttentionStateEnum {
    #[default]
    AntAttentionStateEnum_Patrol = 0,
    AntAttentionStateEnum_Ready = 1,
    AntAttentionStateEnum_Combat = 2,
    AntAttentionStateEnum_Evasive = 3,
    AntAttentionStateEnum_AntEnumCount = 4,
    AntAttentionStateEnum_NoChange = 5,
    AntAttentionStateEnum_Count = 6,
    AntAttentionStateEnum_Dummy1 = 7,
}

pub static ANTATTENTIONSTATEENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntAttentionStateEnum",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTATTENTIONSTATEENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntAttentionStateEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ANTATTENTIONSTATEENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTATTENTIONSTATEENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntAttentionStateEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntAttentionStateEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AntCoverEnum {
    #[default]
    AntCoverEnum_RightCover = 0,
    AntCoverEnum_LeftCover = 1,
    AntCoverEnum_MiddleCover = 2,
    AntCoverEnum_MediumLeftCover = 3,
    AntCoverEnum_MediumRightCover = 4,
    AntCoverEnum_Prone = 5,
    AntCoverEnum_OpenCover = 6,
    AntCoverEnum_Count = 7,
}

pub static ANTCOVERENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntCoverEnum",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTCOVERENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntCoverEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ANTCOVERENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTCOVERENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntCoverEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntCoverEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AntPoseEnum {
    #[default]
    AntPoseEnum_Stand = 0,
    AntPoseEnum_Crouch = 1,
    AntPoseEnum_AntEnumCount = 2,
    AntPoseEnum_NoChange = 3,
    AntPoseEnum_Count = 4,
}

pub static ANTPOSEENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntPoseEnum",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTPOSEENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntPoseEnum {
    fn type_info(&self) -> &'static TypeInfo {
        ANTPOSEENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANTPOSEENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntPoseEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntPoseEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AILocoCoverBinding {
    pub prepare_fire: super::ant::AntRef,
    pub prepare_changed_to_true: super::ant::AntRef,
    pub throw_grenade: super::ant::AntRef,
    pub peek_out: super::ant::AntRef,
    pub idle_behind_cover: super::ant::AntRef,
    pub peek_type: super::ant::AntRef,
    pub idle_type_previous: super::ant::AntRef,
    pub idle_type: super::ant::AntRef,
    pub idle_type_changed: super::ant::AntRef,
    pub cover_type_enum: super::ant::AntRef,
    pub cover_fire_style: super::ant::AntRef,
    pub enter_cover: super::ant::AntRef,
    pub exit_cover: super::ant::AntRef,
    pub cover_distance_small: super::ant::AntRef,
    pub cover_distance_medium: super::ant::AntRef,
    pub distance_scale: super::ant::AntRef,
    pub absolute_distance: super::ant::AntRef,
    pub angle_to_normal: super::ant::AntRef,
    pub direction_to_cover_vs_a_i_trajectory: super::ant::AntRef,
    pub cover_normal_vs_a_i_trajectory: super::ant::AntRef,
    pub out_angle: super::ant::AntRef,
    pub exit_cover_distance: super::ant::AntRef,
    pub threat_angle: super::ant::AntRef,
    pub stop_exit_cover_out_around: super::ant::AntRef,
    pub enter_strategy: super::ant::AntRef,
    pub exit_style: super::ant::AntRef,
    pub cover_hover_animation_blocked: super::ant::AntRef,
    pub cover_enable_hover: super::ant::AntRef,
    pub cover_hover_height: super::ant::AntRef,
    pub cover_hover_left: super::ant::AntRef,
    pub cover_hover_right: super::ant::AntRef,
    pub cover_hover_in_sidefly: super::ant::AntRef,
    pub cover_hover_done: super::ant::AntRef,
    pub trigger_step: super::ant::AntRef,
    pub is_stepping: super::ant::AntRef,
    pub side_step_direction: super::ant::AntRef,
    pub side_step_future_pose: super::ant::AntRef,
}

pub trait AILocoCoverBindingTrait: TypeObject {
    fn prepare_fire(&self) -> &super::ant::AntRef;
    fn prepare_fire_mut(&mut self) -> &mut super::ant::AntRef;
    fn prepare_changed_to_true(&self) -> &super::ant::AntRef;
    fn prepare_changed_to_true_mut(&mut self) -> &mut super::ant::AntRef;
    fn throw_grenade(&self) -> &super::ant::AntRef;
    fn throw_grenade_mut(&mut self) -> &mut super::ant::AntRef;
    fn peek_out(&self) -> &super::ant::AntRef;
    fn peek_out_mut(&mut self) -> &mut super::ant::AntRef;
    fn idle_behind_cover(&self) -> &super::ant::AntRef;
    fn idle_behind_cover_mut(&mut self) -> &mut super::ant::AntRef;
    fn peek_type(&self) -> &super::ant::AntRef;
    fn peek_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn idle_type_previous(&self) -> &super::ant::AntRef;
    fn idle_type_previous_mut(&mut self) -> &mut super::ant::AntRef;
    fn idle_type(&self) -> &super::ant::AntRef;
    fn idle_type_mut(&mut self) -> &mut super::ant::AntRef;
    fn idle_type_changed(&self) -> &super::ant::AntRef;
    fn idle_type_changed_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_type_enum(&self) -> &super::ant::AntRef;
    fn cover_type_enum_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_fire_style(&self) -> &super::ant::AntRef;
    fn cover_fire_style_mut(&mut self) -> &mut super::ant::AntRef;
    fn enter_cover(&self) -> &super::ant::AntRef;
    fn enter_cover_mut(&mut self) -> &mut super::ant::AntRef;
    fn exit_cover(&self) -> &super::ant::AntRef;
    fn exit_cover_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_distance_small(&self) -> &super::ant::AntRef;
    fn cover_distance_small_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_distance_medium(&self) -> &super::ant::AntRef;
    fn cover_distance_medium_mut(&mut self) -> &mut super::ant::AntRef;
    fn distance_scale(&self) -> &super::ant::AntRef;
    fn distance_scale_mut(&mut self) -> &mut super::ant::AntRef;
    fn absolute_distance(&self) -> &super::ant::AntRef;
    fn absolute_distance_mut(&mut self) -> &mut super::ant::AntRef;
    fn angle_to_normal(&self) -> &super::ant::AntRef;
    fn angle_to_normal_mut(&mut self) -> &mut super::ant::AntRef;
    fn direction_to_cover_vs_a_i_trajectory(&self) -> &super::ant::AntRef;
    fn direction_to_cover_vs_a_i_trajectory_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_normal_vs_a_i_trajectory(&self) -> &super::ant::AntRef;
    fn cover_normal_vs_a_i_trajectory_mut(&mut self) -> &mut super::ant::AntRef;
    fn out_angle(&self) -> &super::ant::AntRef;
    fn out_angle_mut(&mut self) -> &mut super::ant::AntRef;
    fn exit_cover_distance(&self) -> &super::ant::AntRef;
    fn exit_cover_distance_mut(&mut self) -> &mut super::ant::AntRef;
    fn threat_angle(&self) -> &super::ant::AntRef;
    fn threat_angle_mut(&mut self) -> &mut super::ant::AntRef;
    fn stop_exit_cover_out_around(&self) -> &super::ant::AntRef;
    fn stop_exit_cover_out_around_mut(&mut self) -> &mut super::ant::AntRef;
    fn enter_strategy(&self) -> &super::ant::AntRef;
    fn enter_strategy_mut(&mut self) -> &mut super::ant::AntRef;
    fn exit_style(&self) -> &super::ant::AntRef;
    fn exit_style_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_hover_animation_blocked(&self) -> &super::ant::AntRef;
    fn cover_hover_animation_blocked_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_enable_hover(&self) -> &super::ant::AntRef;
    fn cover_enable_hover_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_hover_height(&self) -> &super::ant::AntRef;
    fn cover_hover_height_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_hover_left(&self) -> &super::ant::AntRef;
    fn cover_hover_left_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_hover_right(&self) -> &super::ant::AntRef;
    fn cover_hover_right_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_hover_in_sidefly(&self) -> &super::ant::AntRef;
    fn cover_hover_in_sidefly_mut(&mut self) -> &mut super::ant::AntRef;
    fn cover_hover_done(&self) -> &super::ant::AntRef;
    fn cover_hover_done_mut(&mut self) -> &mut super::ant::AntRef;
    fn trigger_step(&self) -> &super::ant::AntRef;
    fn trigger_step_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_stepping(&self) -> &super::ant::AntRef;
    fn is_stepping_mut(&mut self) -> &mut super::ant::AntRef;
    fn side_step_direction(&self) -> &super::ant::AntRef;
    fn side_step_direction_mut(&mut self) -> &mut super::ant::AntRef;
    fn side_step_future_pose(&self) -> &super::ant::AntRef;
    fn side_step_future_pose_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AILocoCoverBindingTrait for AILocoCoverBinding {
    fn prepare_fire(&self) -> &super::ant::AntRef {
        &self.prepare_fire
    }
    fn prepare_fire_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.prepare_fire
    }
    fn prepare_changed_to_true(&self) -> &super::ant::AntRef {
        &self.prepare_changed_to_true
    }
    fn prepare_changed_to_true_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.prepare_changed_to_true
    }
    fn throw_grenade(&self) -> &super::ant::AntRef {
        &self.throw_grenade
    }
    fn throw_grenade_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.throw_grenade
    }
    fn peek_out(&self) -> &super::ant::AntRef {
        &self.peek_out
    }
    fn peek_out_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.peek_out
    }
    fn idle_behind_cover(&self) -> &super::ant::AntRef {
        &self.idle_behind_cover
    }
    fn idle_behind_cover_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.idle_behind_cover
    }
    fn peek_type(&self) -> &super::ant::AntRef {
        &self.peek_type
    }
    fn peek_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.peek_type
    }
    fn idle_type_previous(&self) -> &super::ant::AntRef {
        &self.idle_type_previous
    }
    fn idle_type_previous_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.idle_type_previous
    }
    fn idle_type(&self) -> &super::ant::AntRef {
        &self.idle_type
    }
    fn idle_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.idle_type
    }
    fn idle_type_changed(&self) -> &super::ant::AntRef {
        &self.idle_type_changed
    }
    fn idle_type_changed_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.idle_type_changed
    }
    fn cover_type_enum(&self) -> &super::ant::AntRef {
        &self.cover_type_enum
    }
    fn cover_type_enum_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_type_enum
    }
    fn cover_fire_style(&self) -> &super::ant::AntRef {
        &self.cover_fire_style
    }
    fn cover_fire_style_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_fire_style
    }
    fn enter_cover(&self) -> &super::ant::AntRef {
        &self.enter_cover
    }
    fn enter_cover_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enter_cover
    }
    fn exit_cover(&self) -> &super::ant::AntRef {
        &self.exit_cover
    }
    fn exit_cover_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.exit_cover
    }
    fn cover_distance_small(&self) -> &super::ant::AntRef {
        &self.cover_distance_small
    }
    fn cover_distance_small_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_distance_small
    }
    fn cover_distance_medium(&self) -> &super::ant::AntRef {
        &self.cover_distance_medium
    }
    fn cover_distance_medium_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_distance_medium
    }
    fn distance_scale(&self) -> &super::ant::AntRef {
        &self.distance_scale
    }
    fn distance_scale_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.distance_scale
    }
    fn absolute_distance(&self) -> &super::ant::AntRef {
        &self.absolute_distance
    }
    fn absolute_distance_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.absolute_distance
    }
    fn angle_to_normal(&self) -> &super::ant::AntRef {
        &self.angle_to_normal
    }
    fn angle_to_normal_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.angle_to_normal
    }
    fn direction_to_cover_vs_a_i_trajectory(&self) -> &super::ant::AntRef {
        &self.direction_to_cover_vs_a_i_trajectory
    }
    fn direction_to_cover_vs_a_i_trajectory_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.direction_to_cover_vs_a_i_trajectory
    }
    fn cover_normal_vs_a_i_trajectory(&self) -> &super::ant::AntRef {
        &self.cover_normal_vs_a_i_trajectory
    }
    fn cover_normal_vs_a_i_trajectory_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_normal_vs_a_i_trajectory
    }
    fn out_angle(&self) -> &super::ant::AntRef {
        &self.out_angle
    }
    fn out_angle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.out_angle
    }
    fn exit_cover_distance(&self) -> &super::ant::AntRef {
        &self.exit_cover_distance
    }
    fn exit_cover_distance_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.exit_cover_distance
    }
    fn threat_angle(&self) -> &super::ant::AntRef {
        &self.threat_angle
    }
    fn threat_angle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.threat_angle
    }
    fn stop_exit_cover_out_around(&self) -> &super::ant::AntRef {
        &self.stop_exit_cover_out_around
    }
    fn stop_exit_cover_out_around_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.stop_exit_cover_out_around
    }
    fn enter_strategy(&self) -> &super::ant::AntRef {
        &self.enter_strategy
    }
    fn enter_strategy_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enter_strategy
    }
    fn exit_style(&self) -> &super::ant::AntRef {
        &self.exit_style
    }
    fn exit_style_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.exit_style
    }
    fn cover_hover_animation_blocked(&self) -> &super::ant::AntRef {
        &self.cover_hover_animation_blocked
    }
    fn cover_hover_animation_blocked_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_hover_animation_blocked
    }
    fn cover_enable_hover(&self) -> &super::ant::AntRef {
        &self.cover_enable_hover
    }
    fn cover_enable_hover_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_enable_hover
    }
    fn cover_hover_height(&self) -> &super::ant::AntRef {
        &self.cover_hover_height
    }
    fn cover_hover_height_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_hover_height
    }
    fn cover_hover_left(&self) -> &super::ant::AntRef {
        &self.cover_hover_left
    }
    fn cover_hover_left_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_hover_left
    }
    fn cover_hover_right(&self) -> &super::ant::AntRef {
        &self.cover_hover_right
    }
    fn cover_hover_right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_hover_right
    }
    fn cover_hover_in_sidefly(&self) -> &super::ant::AntRef {
        &self.cover_hover_in_sidefly
    }
    fn cover_hover_in_sidefly_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_hover_in_sidefly
    }
    fn cover_hover_done(&self) -> &super::ant::AntRef {
        &self.cover_hover_done
    }
    fn cover_hover_done_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cover_hover_done
    }
    fn trigger_step(&self) -> &super::ant::AntRef {
        &self.trigger_step
    }
    fn trigger_step_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.trigger_step
    }
    fn is_stepping(&self) -> &super::ant::AntRef {
        &self.is_stepping
    }
    fn is_stepping_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_stepping
    }
    fn side_step_direction(&self) -> &super::ant::AntRef {
        &self.side_step_direction
    }
    fn side_step_direction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.side_step_direction
    }
    fn side_step_future_pose(&self) -> &super::ant::AntRef {
        &self.side_step_future_pose
    }
    fn side_step_future_pose_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.side_step_future_pose
    }
}

pub static AILOCOCOVERBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCoverBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoCoverBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PrepareFire",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, prepare_fire),
            },
            FieldInfoData {
                name: "PrepareChangedToTrue",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, prepare_changed_to_true),
            },
            FieldInfoData {
                name: "ThrowGrenade",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, throw_grenade),
            },
            FieldInfoData {
                name: "PeekOut",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, peek_out),
            },
            FieldInfoData {
                name: "IdleBehindCover",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, idle_behind_cover),
            },
            FieldInfoData {
                name: "PeekType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, peek_type),
            },
            FieldInfoData {
                name: "IdleTypePrevious",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, idle_type_previous),
            },
            FieldInfoData {
                name: "IdleType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, idle_type),
            },
            FieldInfoData {
                name: "IdleTypeChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, idle_type_changed),
            },
            FieldInfoData {
                name: "CoverTypeEnum",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_type_enum),
            },
            FieldInfoData {
                name: "CoverFireStyle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_fire_style),
            },
            FieldInfoData {
                name: "EnterCover",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, enter_cover),
            },
            FieldInfoData {
                name: "ExitCover",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, exit_cover),
            },
            FieldInfoData {
                name: "CoverDistanceSmall",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_distance_small),
            },
            FieldInfoData {
                name: "CoverDistanceMedium",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_distance_medium),
            },
            FieldInfoData {
                name: "DistanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, distance_scale),
            },
            FieldInfoData {
                name: "AbsoluteDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, absolute_distance),
            },
            FieldInfoData {
                name: "AngleToNormal",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, angle_to_normal),
            },
            FieldInfoData {
                name: "DirectionToCoverVsAITrajectory",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, direction_to_cover_vs_a_i_trajectory),
            },
            FieldInfoData {
                name: "CoverNormalVsAITrajectory",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_normal_vs_a_i_trajectory),
            },
            FieldInfoData {
                name: "OutAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, out_angle),
            },
            FieldInfoData {
                name: "ExitCoverDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, exit_cover_distance),
            },
            FieldInfoData {
                name: "ThreatAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, threat_angle),
            },
            FieldInfoData {
                name: "StopExitCoverOutAround",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, stop_exit_cover_out_around),
            },
            FieldInfoData {
                name: "EnterStrategy",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, enter_strategy),
            },
            FieldInfoData {
                name: "ExitStyle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, exit_style),
            },
            FieldInfoData {
                name: "CoverHoverAnimationBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_animation_blocked),
            },
            FieldInfoData {
                name: "CoverEnableHover",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_enable_hover),
            },
            FieldInfoData {
                name: "CoverHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_height),
            },
            FieldInfoData {
                name: "CoverHoverLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_left),
            },
            FieldInfoData {
                name: "CoverHoverRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_right),
            },
            FieldInfoData {
                name: "CoverHoverInSidefly",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_in_sidefly),
            },
            FieldInfoData {
                name: "CoverHoverDone",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_done),
            },
            FieldInfoData {
                name: "TriggerStep",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, trigger_step),
            },
            FieldInfoData {
                name: "IsStepping",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, is_stepping),
            },
            FieldInfoData {
                name: "SideStepDirection",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, side_step_direction),
            },
            FieldInfoData {
                name: "SideStepFuturePose",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoCoverBinding, side_step_future_pose),
            },
        ],
    }),
    array_type: Some(AILOCOCOVERBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AILocoCoverBinding {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOCOVERBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AILOCOCOVERBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCoverBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoCoverBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AILocoVaultBinding {
    pub vault: super::ant::AntRef,
    pub distance_before_vault: super::ant::AntRef,
    pub height_before_vault: super::ant::AntRef,
    pub length_of_vaultable_object: super::ant::AntRef,
    pub height_after_vault: super::ant::AntRef,
    pub distance_after_vault: super::ant::AntRef,
    pub vault_type: super::ant::AntRef,
}

pub trait AILocoVaultBindingTrait: TypeObject {
    fn vault(&self) -> &super::ant::AntRef;
    fn vault_mut(&mut self) -> &mut super::ant::AntRef;
    fn distance_before_vault(&self) -> &super::ant::AntRef;
    fn distance_before_vault_mut(&mut self) -> &mut super::ant::AntRef;
    fn height_before_vault(&self) -> &super::ant::AntRef;
    fn height_before_vault_mut(&mut self) -> &mut super::ant::AntRef;
    fn length_of_vaultable_object(&self) -> &super::ant::AntRef;
    fn length_of_vaultable_object_mut(&mut self) -> &mut super::ant::AntRef;
    fn height_after_vault(&self) -> &super::ant::AntRef;
    fn height_after_vault_mut(&mut self) -> &mut super::ant::AntRef;
    fn distance_after_vault(&self) -> &super::ant::AntRef;
    fn distance_after_vault_mut(&mut self) -> &mut super::ant::AntRef;
    fn vault_type(&self) -> &super::ant::AntRef;
    fn vault_type_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AILocoVaultBindingTrait for AILocoVaultBinding {
    fn vault(&self) -> &super::ant::AntRef {
        &self.vault
    }
    fn vault_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vault
    }
    fn distance_before_vault(&self) -> &super::ant::AntRef {
        &self.distance_before_vault
    }
    fn distance_before_vault_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.distance_before_vault
    }
    fn height_before_vault(&self) -> &super::ant::AntRef {
        &self.height_before_vault
    }
    fn height_before_vault_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.height_before_vault
    }
    fn length_of_vaultable_object(&self) -> &super::ant::AntRef {
        &self.length_of_vaultable_object
    }
    fn length_of_vaultable_object_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.length_of_vaultable_object
    }
    fn height_after_vault(&self) -> &super::ant::AntRef {
        &self.height_after_vault
    }
    fn height_after_vault_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.height_after_vault
    }
    fn distance_after_vault(&self) -> &super::ant::AntRef {
        &self.distance_after_vault
    }
    fn distance_after_vault_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.distance_after_vault
    }
    fn vault_type(&self) -> &super::ant::AntRef {
        &self.vault_type
    }
    fn vault_type_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.vault_type
    }
}

pub static AILOCOVAULTBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoVaultBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoVaultBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Vault",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoVaultBinding, vault),
            },
            FieldInfoData {
                name: "DistanceBeforeVault",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoVaultBinding, distance_before_vault),
            },
            FieldInfoData {
                name: "HeightBeforeVault",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoVaultBinding, height_before_vault),
            },
            FieldInfoData {
                name: "LengthOfVaultableObject",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoVaultBinding, length_of_vaultable_object),
            },
            FieldInfoData {
                name: "HeightAfterVault",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoVaultBinding, height_after_vault),
            },
            FieldInfoData {
                name: "DistanceAfterVault",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoVaultBinding, distance_after_vault),
            },
            FieldInfoData {
                name: "VaultType",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoVaultBinding, vault_type),
            },
        ],
    }),
    array_type: Some(AILOCOVAULTBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AILocoVaultBinding {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOVAULTBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AILOCOVAULTBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoVaultBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoVaultBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AILocoBinding {
    pub loco_target: super::ant::AntRef,
    pub attention_state: super::ant::AntRef,
    pub no_initial_combat_reaction: super::ant::AntRef,
    pub end_pose_enum: super::ant::AntRef,
    pub current_pose_enum: super::ant::AntRef,
    pub enter_exit_pose_enum: super::ant::AntRef,
    pub run_style: super::ant::AntRef,
    pub target_waypoint_position: super::ant::AntRef,
    pub target_waypoint_radius: super::ant::AntRef,
    pub target_speed_level: super::ant::AntRef,
    pub cruise_speed_level: super::ant::AntRef,
    pub enable_procedural_head_aim: super::ant::AntRef,
    pub a_i_action: super::ant::AntRef,
    pub force_relative_aim_turn: super::ant::AntRef,
    pub force_relative_aim_turn_angle: super::ant::AntRef,
    pub stopping: super::ant::AntRef,
    pub enemy_target_distance: super::ant::AntRef,
}

pub trait AILocoBindingTrait: TypeObject {
    fn loco_target(&self) -> &super::ant::AntRef;
    fn loco_target_mut(&mut self) -> &mut super::ant::AntRef;
    fn attention_state(&self) -> &super::ant::AntRef;
    fn attention_state_mut(&mut self) -> &mut super::ant::AntRef;
    fn no_initial_combat_reaction(&self) -> &super::ant::AntRef;
    fn no_initial_combat_reaction_mut(&mut self) -> &mut super::ant::AntRef;
    fn end_pose_enum(&self) -> &super::ant::AntRef;
    fn end_pose_enum_mut(&mut self) -> &mut super::ant::AntRef;
    fn current_pose_enum(&self) -> &super::ant::AntRef;
    fn current_pose_enum_mut(&mut self) -> &mut super::ant::AntRef;
    fn enter_exit_pose_enum(&self) -> &super::ant::AntRef;
    fn enter_exit_pose_enum_mut(&mut self) -> &mut super::ant::AntRef;
    fn run_style(&self) -> &super::ant::AntRef;
    fn run_style_mut(&mut self) -> &mut super::ant::AntRef;
    fn target_waypoint_position(&self) -> &super::ant::AntRef;
    fn target_waypoint_position_mut(&mut self) -> &mut super::ant::AntRef;
    fn target_waypoint_radius(&self) -> &super::ant::AntRef;
    fn target_waypoint_radius_mut(&mut self) -> &mut super::ant::AntRef;
    fn target_speed_level(&self) -> &super::ant::AntRef;
    fn target_speed_level_mut(&mut self) -> &mut super::ant::AntRef;
    fn cruise_speed_level(&self) -> &super::ant::AntRef;
    fn cruise_speed_level_mut(&mut self) -> &mut super::ant::AntRef;
    fn enable_procedural_head_aim(&self) -> &super::ant::AntRef;
    fn enable_procedural_head_aim_mut(&mut self) -> &mut super::ant::AntRef;
    fn a_i_action(&self) -> &super::ant::AntRef;
    fn a_i_action_mut(&mut self) -> &mut super::ant::AntRef;
    fn force_relative_aim_turn(&self) -> &super::ant::AntRef;
    fn force_relative_aim_turn_mut(&mut self) -> &mut super::ant::AntRef;
    fn force_relative_aim_turn_angle(&self) -> &super::ant::AntRef;
    fn force_relative_aim_turn_angle_mut(&mut self) -> &mut super::ant::AntRef;
    fn stopping(&self) -> &super::ant::AntRef;
    fn stopping_mut(&mut self) -> &mut super::ant::AntRef;
    fn enemy_target_distance(&self) -> &super::ant::AntRef;
    fn enemy_target_distance_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AILocoBindingTrait for AILocoBinding {
    fn loco_target(&self) -> &super::ant::AntRef {
        &self.loco_target
    }
    fn loco_target_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.loco_target
    }
    fn attention_state(&self) -> &super::ant::AntRef {
        &self.attention_state
    }
    fn attention_state_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.attention_state
    }
    fn no_initial_combat_reaction(&self) -> &super::ant::AntRef {
        &self.no_initial_combat_reaction
    }
    fn no_initial_combat_reaction_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.no_initial_combat_reaction
    }
    fn end_pose_enum(&self) -> &super::ant::AntRef {
        &self.end_pose_enum
    }
    fn end_pose_enum_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.end_pose_enum
    }
    fn current_pose_enum(&self) -> &super::ant::AntRef {
        &self.current_pose_enum
    }
    fn current_pose_enum_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.current_pose_enum
    }
    fn enter_exit_pose_enum(&self) -> &super::ant::AntRef {
        &self.enter_exit_pose_enum
    }
    fn enter_exit_pose_enum_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enter_exit_pose_enum
    }
    fn run_style(&self) -> &super::ant::AntRef {
        &self.run_style
    }
    fn run_style_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.run_style
    }
    fn target_waypoint_position(&self) -> &super::ant::AntRef {
        &self.target_waypoint_position
    }
    fn target_waypoint_position_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.target_waypoint_position
    }
    fn target_waypoint_radius(&self) -> &super::ant::AntRef {
        &self.target_waypoint_radius
    }
    fn target_waypoint_radius_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.target_waypoint_radius
    }
    fn target_speed_level(&self) -> &super::ant::AntRef {
        &self.target_speed_level
    }
    fn target_speed_level_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.target_speed_level
    }
    fn cruise_speed_level(&self) -> &super::ant::AntRef {
        &self.cruise_speed_level
    }
    fn cruise_speed_level_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.cruise_speed_level
    }
    fn enable_procedural_head_aim(&self) -> &super::ant::AntRef {
        &self.enable_procedural_head_aim
    }
    fn enable_procedural_head_aim_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enable_procedural_head_aim
    }
    fn a_i_action(&self) -> &super::ant::AntRef {
        &self.a_i_action
    }
    fn a_i_action_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.a_i_action
    }
    fn force_relative_aim_turn(&self) -> &super::ant::AntRef {
        &self.force_relative_aim_turn
    }
    fn force_relative_aim_turn_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.force_relative_aim_turn
    }
    fn force_relative_aim_turn_angle(&self) -> &super::ant::AntRef {
        &self.force_relative_aim_turn_angle
    }
    fn force_relative_aim_turn_angle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.force_relative_aim_turn_angle
    }
    fn stopping(&self) -> &super::ant::AntRef {
        &self.stopping
    }
    fn stopping_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.stopping
    }
    fn enemy_target_distance(&self) -> &super::ant::AntRef {
        &self.enemy_target_distance
    }
    fn enemy_target_distance_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.enemy_target_distance
    }
}

pub static AILOCOBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AILocoBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LocoTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, loco_target),
            },
            FieldInfoData {
                name: "AttentionState",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, attention_state),
            },
            FieldInfoData {
                name: "NoInitialCombatReaction",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, no_initial_combat_reaction),
            },
            FieldInfoData {
                name: "EndPoseEnum",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, end_pose_enum),
            },
            FieldInfoData {
                name: "CurrentPoseEnum",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, current_pose_enum),
            },
            FieldInfoData {
                name: "EnterExitPoseEnum",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, enter_exit_pose_enum),
            },
            FieldInfoData {
                name: "RunStyle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, run_style),
            },
            FieldInfoData {
                name: "TargetWaypointPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, target_waypoint_position),
            },
            FieldInfoData {
                name: "TargetWaypointRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, target_waypoint_radius),
            },
            FieldInfoData {
                name: "TargetSpeedLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, target_speed_level),
            },
            FieldInfoData {
                name: "CruiseSpeedLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, cruise_speed_level),
            },
            FieldInfoData {
                name: "EnableProceduralHeadAim",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, enable_procedural_head_aim),
            },
            FieldInfoData {
                name: "AIAction",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, a_i_action),
            },
            FieldInfoData {
                name: "ForceRelativeAimTurn",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, force_relative_aim_turn),
            },
            FieldInfoData {
                name: "ForceRelativeAimTurnAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, force_relative_aim_turn_angle),
            },
            FieldInfoData {
                name: "Stopping",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, stopping),
            },
            FieldInfoData {
                name: "EnemyTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AILocoBinding, enemy_target_distance),
            },
        ],
    }),
    array_type: Some(AILOCOBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AILocoBinding {
    fn type_info(&self) -> &'static TypeInfo {
        AILOCOBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AILOCOBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIKillCounterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub alive_threshold: i32,
    pub run_once: bool,
}

pub trait AIKillCounterEntityDataTrait: super::entity::EntityDataTrait {
    fn alive_threshold(&self) -> &i32;
    fn alive_threshold_mut(&mut self) -> &mut i32;
    fn run_once(&self) -> &bool;
    fn run_once_mut(&mut self) -> &mut bool;
}

impl AIKillCounterEntityDataTrait for AIKillCounterEntityData {
    fn alive_threshold(&self) -> &i32 {
        &self.alive_threshold
    }
    fn alive_threshold_mut(&mut self) -> &mut i32 {
        &mut self.alive_threshold
    }
    fn run_once(&self) -> &bool {
        &self.run_once
    }
    fn run_once_mut(&mut self) -> &mut bool {
        &mut self.run_once
    }
}

impl super::entity::EntityDataTrait for AIKillCounterEntityData {
}

impl super::entity::GameObjectDataTrait for AIKillCounterEntityData {
}

impl super::core::DataBusPeerTrait for AIKillCounterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIKillCounterEntityData {
}

impl super::core::DataContainerTrait for AIKillCounterEntityData {
}

pub static AIKILLCOUNTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIKillCounterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIKillCounterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AliveThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AIKillCounterEntityData, alive_threshold),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIKillCounterEntityData, run_once),
            },
        ],
    }),
    array_type: Some(AIKILLCOUNTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIKillCounterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIKILLCOUNTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIKILLCOUNTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIKillCounterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIKillCounterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIEntryComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub target_position_override: super::core::Vec3,
    pub hold_fire: bool,
    pub allow_grenades: bool,
    pub send_fire_events: bool,
    pub force_press_fire: bool,
    pub suppression: f32,
    pub allow_occupant: bool,
    pub target_approach_max_angle: f32,
    pub target_approach_min_velocity: f32,
    pub friendly_player_max_distance: f32,
    pub enemy_player_max_distance: f32,
    pub enemy_player_forward_cone_max_angle: f32,
    pub enemy_player_forward_cone_max_distance: f32,
    pub is_in_player_frustum_check_interval: f32,
}

pub trait AIEntryComponentDataTrait: super::entity::GameComponentDataTrait {
    fn target_position_override(&self) -> &super::core::Vec3;
    fn target_position_override_mut(&mut self) -> &mut super::core::Vec3;
    fn hold_fire(&self) -> &bool;
    fn hold_fire_mut(&mut self) -> &mut bool;
    fn allow_grenades(&self) -> &bool;
    fn allow_grenades_mut(&mut self) -> &mut bool;
    fn send_fire_events(&self) -> &bool;
    fn send_fire_events_mut(&mut self) -> &mut bool;
    fn force_press_fire(&self) -> &bool;
    fn force_press_fire_mut(&mut self) -> &mut bool;
    fn suppression(&self) -> &f32;
    fn suppression_mut(&mut self) -> &mut f32;
    fn allow_occupant(&self) -> &bool;
    fn allow_occupant_mut(&mut self) -> &mut bool;
    fn target_approach_max_angle(&self) -> &f32;
    fn target_approach_max_angle_mut(&mut self) -> &mut f32;
    fn target_approach_min_velocity(&self) -> &f32;
    fn target_approach_min_velocity_mut(&mut self) -> &mut f32;
    fn friendly_player_max_distance(&self) -> &f32;
    fn friendly_player_max_distance_mut(&mut self) -> &mut f32;
    fn enemy_player_max_distance(&self) -> &f32;
    fn enemy_player_max_distance_mut(&mut self) -> &mut f32;
    fn enemy_player_forward_cone_max_angle(&self) -> &f32;
    fn enemy_player_forward_cone_max_angle_mut(&mut self) -> &mut f32;
    fn enemy_player_forward_cone_max_distance(&self) -> &f32;
    fn enemy_player_forward_cone_max_distance_mut(&mut self) -> &mut f32;
    fn is_in_player_frustum_check_interval(&self) -> &f32;
    fn is_in_player_frustum_check_interval_mut(&mut self) -> &mut f32;
}

impl AIEntryComponentDataTrait for AIEntryComponentData {
    fn target_position_override(&self) -> &super::core::Vec3 {
        &self.target_position_override
    }
    fn target_position_override_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_position_override
    }
    fn hold_fire(&self) -> &bool {
        &self.hold_fire
    }
    fn hold_fire_mut(&mut self) -> &mut bool {
        &mut self.hold_fire
    }
    fn allow_grenades(&self) -> &bool {
        &self.allow_grenades
    }
    fn allow_grenades_mut(&mut self) -> &mut bool {
        &mut self.allow_grenades
    }
    fn send_fire_events(&self) -> &bool {
        &self.send_fire_events
    }
    fn send_fire_events_mut(&mut self) -> &mut bool {
        &mut self.send_fire_events
    }
    fn force_press_fire(&self) -> &bool {
        &self.force_press_fire
    }
    fn force_press_fire_mut(&mut self) -> &mut bool {
        &mut self.force_press_fire
    }
    fn suppression(&self) -> &f32 {
        &self.suppression
    }
    fn suppression_mut(&mut self) -> &mut f32 {
        &mut self.suppression
    }
    fn allow_occupant(&self) -> &bool {
        &self.allow_occupant
    }
    fn allow_occupant_mut(&mut self) -> &mut bool {
        &mut self.allow_occupant
    }
    fn target_approach_max_angle(&self) -> &f32 {
        &self.target_approach_max_angle
    }
    fn target_approach_max_angle_mut(&mut self) -> &mut f32 {
        &mut self.target_approach_max_angle
    }
    fn target_approach_min_velocity(&self) -> &f32 {
        &self.target_approach_min_velocity
    }
    fn target_approach_min_velocity_mut(&mut self) -> &mut f32 {
        &mut self.target_approach_min_velocity
    }
    fn friendly_player_max_distance(&self) -> &f32 {
        &self.friendly_player_max_distance
    }
    fn friendly_player_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.friendly_player_max_distance
    }
    fn enemy_player_max_distance(&self) -> &f32 {
        &self.enemy_player_max_distance
    }
    fn enemy_player_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.enemy_player_max_distance
    }
    fn enemy_player_forward_cone_max_angle(&self) -> &f32 {
        &self.enemy_player_forward_cone_max_angle
    }
    fn enemy_player_forward_cone_max_angle_mut(&mut self) -> &mut f32 {
        &mut self.enemy_player_forward_cone_max_angle
    }
    fn enemy_player_forward_cone_max_distance(&self) -> &f32 {
        &self.enemy_player_forward_cone_max_distance
    }
    fn enemy_player_forward_cone_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.enemy_player_forward_cone_max_distance
    }
    fn is_in_player_frustum_check_interval(&self) -> &f32 {
        &self.is_in_player_frustum_check_interval
    }
    fn is_in_player_frustum_check_interval_mut(&mut self) -> &mut f32 {
        &mut self.is_in_player_frustum_check_interval
    }
}

impl super::entity::GameComponentDataTrait for AIEntryComponentData {
}

impl super::entity::ComponentDataTrait for AIEntryComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AIEntryComponentData {
}

impl super::core::DataBusPeerTrait for AIEntryComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIEntryComponentData {
}

impl super::core::DataContainerTrait for AIEntryComponentData {
}

pub static AIENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIEntryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIEntryComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetPositionOverride",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AIEntryComponentData, target_position_override),
            },
            FieldInfoData {
                name: "HoldFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIEntryComponentData, hold_fire),
            },
            FieldInfoData {
                name: "AllowGrenades",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIEntryComponentData, allow_grenades),
            },
            FieldInfoData {
                name: "SendFireEvents",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIEntryComponentData, send_fire_events),
            },
            FieldInfoData {
                name: "ForcePressFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIEntryComponentData, force_press_fire),
            },
            FieldInfoData {
                name: "Suppression",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIEntryComponentData, suppression),
            },
            FieldInfoData {
                name: "AllowOccupant",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIEntryComponentData, allow_occupant),
            },
            FieldInfoData {
                name: "TargetApproachMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIEntryComponentData, target_approach_max_angle),
            },
            FieldInfoData {
                name: "TargetApproachMinVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIEntryComponentData, target_approach_min_velocity),
            },
            FieldInfoData {
                name: "FriendlyPlayerMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIEntryComponentData, friendly_player_max_distance),
            },
            FieldInfoData {
                name: "EnemyPlayerMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIEntryComponentData, enemy_player_max_distance),
            },
            FieldInfoData {
                name: "EnemyPlayerForwardConeMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIEntryComponentData, enemy_player_forward_cone_max_angle),
            },
            FieldInfoData {
                name: "EnemyPlayerForwardConeMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIEntryComponentData, enemy_player_forward_cone_max_distance),
            },
            FieldInfoData {
                name: "IsInPlayerFrustumCheckInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIEntryComponentData, is_in_player_frustum_check_interval),
            },
        ],
    }),
    array_type: Some(AIENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIEntryComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIENTRYCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIEntryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIEntryComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIEncounterManagerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub save_state: bool,
    pub encounters: Vec<EncounterConfig>,
    pub event_count: u32,
    pub condition_a: bool,
    pub condition_b: bool,
}

pub trait AIEncounterManagerEntityDataTrait: super::entity::EntityDataTrait {
    fn save_state(&self) -> &bool;
    fn save_state_mut(&mut self) -> &mut bool;
    fn encounters(&self) -> &Vec<EncounterConfig>;
    fn encounters_mut(&mut self) -> &mut Vec<EncounterConfig>;
    fn event_count(&self) -> &u32;
    fn event_count_mut(&mut self) -> &mut u32;
    fn condition_a(&self) -> &bool;
    fn condition_a_mut(&mut self) -> &mut bool;
    fn condition_b(&self) -> &bool;
    fn condition_b_mut(&mut self) -> &mut bool;
}

impl AIEncounterManagerEntityDataTrait for AIEncounterManagerEntityData {
    fn save_state(&self) -> &bool {
        &self.save_state
    }
    fn save_state_mut(&mut self) -> &mut bool {
        &mut self.save_state
    }
    fn encounters(&self) -> &Vec<EncounterConfig> {
        &self.encounters
    }
    fn encounters_mut(&mut self) -> &mut Vec<EncounterConfig> {
        &mut self.encounters
    }
    fn event_count(&self) -> &u32 {
        &self.event_count
    }
    fn event_count_mut(&mut self) -> &mut u32 {
        &mut self.event_count
    }
    fn condition_a(&self) -> &bool {
        &self.condition_a
    }
    fn condition_a_mut(&mut self) -> &mut bool {
        &mut self.condition_a
    }
    fn condition_b(&self) -> &bool {
        &self.condition_b
    }
    fn condition_b_mut(&mut self) -> &mut bool {
        &mut self.condition_b
    }
}

impl super::entity::EntityDataTrait for AIEncounterManagerEntityData {
}

impl super::entity::GameObjectDataTrait for AIEncounterManagerEntityData {
}

impl super::core::DataBusPeerTrait for AIEncounterManagerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIEncounterManagerEntityData {
}

impl super::core::DataContainerTrait for AIEncounterManagerEntityData {
}

pub static AIENCOUNTERMANAGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIEncounterManagerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIEncounterManagerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SaveState",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIEncounterManagerEntityData, save_state),
            },
            FieldInfoData {
                name: "Encounters",
                flags: MemberInfoFlags::new(144),
                field_type: "EncounterConfig-Array",
                rust_offset: offset_of!(AIEncounterManagerEntityData, encounters),
            },
            FieldInfoData {
                name: "EventCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AIEncounterManagerEntityData, event_count),
            },
            FieldInfoData {
                name: "ConditionA",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIEncounterManagerEntityData, condition_a),
            },
            FieldInfoData {
                name: "ConditionB",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIEncounterManagerEntityData, condition_b),
            },
        ],
    }),
    array_type: Some(AIENCOUNTERMANAGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIEncounterManagerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIENCOUNTERMANAGERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIENCOUNTERMANAGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIEncounterManagerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIEncounterManagerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EncounterConfig {
    pub zones: Vec<EncounterZoneConfig>,
    pub max_engaging_count: u32,
    pub use_corridor_assignment: bool,
}

pub trait EncounterConfigTrait: TypeObject {
    fn zones(&self) -> &Vec<EncounterZoneConfig>;
    fn zones_mut(&mut self) -> &mut Vec<EncounterZoneConfig>;
    fn max_engaging_count(&self) -> &u32;
    fn max_engaging_count_mut(&mut self) -> &mut u32;
    fn use_corridor_assignment(&self) -> &bool;
    fn use_corridor_assignment_mut(&mut self) -> &mut bool;
}

impl EncounterConfigTrait for EncounterConfig {
    fn zones(&self) -> &Vec<EncounterZoneConfig> {
        &self.zones
    }
    fn zones_mut(&mut self) -> &mut Vec<EncounterZoneConfig> {
        &mut self.zones
    }
    fn max_engaging_count(&self) -> &u32 {
        &self.max_engaging_count
    }
    fn max_engaging_count_mut(&mut self) -> &mut u32 {
        &mut self.max_engaging_count
    }
    fn use_corridor_assignment(&self) -> &bool {
        &self.use_corridor_assignment
    }
    fn use_corridor_assignment_mut(&mut self) -> &mut bool {
        &mut self.use_corridor_assignment
    }
}

pub static ENCOUNTERCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EncounterConfig",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EncounterConfig as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Zones",
                flags: MemberInfoFlags::new(144),
                field_type: "EncounterZoneConfig-Array",
                rust_offset: offset_of!(EncounterConfig, zones),
            },
            FieldInfoData {
                name: "MaxEngagingCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EncounterConfig, max_engaging_count),
            },
            FieldInfoData {
                name: "UseCorridorAssignment",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EncounterConfig, use_corridor_assignment),
            },
        ],
    }),
    array_type: Some(ENCOUNTERCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EncounterConfig {
    fn type_info(&self) -> &'static TypeInfo {
        ENCOUNTERCONFIG_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENCOUNTERCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EncounterConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EncounterConfig"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EncounterZoneConfig {
    pub zone: u8,
    pub priority: u8,
    pub max_n_p_cs: u8,
    pub require_condition_a: bool,
    pub require_condition_b: bool,
    pub required_weapon1: super::soldier_shared::WeaponAnimBaseSetEnum,
    pub required_weapon2: super::soldier_shared::WeaponAnimBaseSetEnum,
    pub require_s_m_g: bool,
    pub prefer_cover: bool,
}

pub trait EncounterZoneConfigTrait: TypeObject {
    fn zone(&self) -> &u8;
    fn zone_mut(&mut self) -> &mut u8;
    fn priority(&self) -> &u8;
    fn priority_mut(&mut self) -> &mut u8;
    fn max_n_p_cs(&self) -> &u8;
    fn max_n_p_cs_mut(&mut self) -> &mut u8;
    fn require_condition_a(&self) -> &bool;
    fn require_condition_a_mut(&mut self) -> &mut bool;
    fn require_condition_b(&self) -> &bool;
    fn require_condition_b_mut(&mut self) -> &mut bool;
    fn required_weapon1(&self) -> &super::soldier_shared::WeaponAnimBaseSetEnum;
    fn required_weapon1_mut(&mut self) -> &mut super::soldier_shared::WeaponAnimBaseSetEnum;
    fn required_weapon2(&self) -> &super::soldier_shared::WeaponAnimBaseSetEnum;
    fn required_weapon2_mut(&mut self) -> &mut super::soldier_shared::WeaponAnimBaseSetEnum;
    fn require_s_m_g(&self) -> &bool;
    fn require_s_m_g_mut(&mut self) -> &mut bool;
    fn prefer_cover(&self) -> &bool;
    fn prefer_cover_mut(&mut self) -> &mut bool;
}

impl EncounterZoneConfigTrait for EncounterZoneConfig {
    fn zone(&self) -> &u8 {
        &self.zone
    }
    fn zone_mut(&mut self) -> &mut u8 {
        &mut self.zone
    }
    fn priority(&self) -> &u8 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut u8 {
        &mut self.priority
    }
    fn max_n_p_cs(&self) -> &u8 {
        &self.max_n_p_cs
    }
    fn max_n_p_cs_mut(&mut self) -> &mut u8 {
        &mut self.max_n_p_cs
    }
    fn require_condition_a(&self) -> &bool {
        &self.require_condition_a
    }
    fn require_condition_a_mut(&mut self) -> &mut bool {
        &mut self.require_condition_a
    }
    fn require_condition_b(&self) -> &bool {
        &self.require_condition_b
    }
    fn require_condition_b_mut(&mut self) -> &mut bool {
        &mut self.require_condition_b
    }
    fn required_weapon1(&self) -> &super::soldier_shared::WeaponAnimBaseSetEnum {
        &self.required_weapon1
    }
    fn required_weapon1_mut(&mut self) -> &mut super::soldier_shared::WeaponAnimBaseSetEnum {
        &mut self.required_weapon1
    }
    fn required_weapon2(&self) -> &super::soldier_shared::WeaponAnimBaseSetEnum {
        &self.required_weapon2
    }
    fn required_weapon2_mut(&mut self) -> &mut super::soldier_shared::WeaponAnimBaseSetEnum {
        &mut self.required_weapon2
    }
    fn require_s_m_g(&self) -> &bool {
        &self.require_s_m_g
    }
    fn require_s_m_g_mut(&mut self) -> &mut bool {
        &mut self.require_s_m_g
    }
    fn prefer_cover(&self) -> &bool {
        &self.prefer_cover
    }
    fn prefer_cover_mut(&mut self) -> &mut bool {
        &mut self.prefer_cover
    }
}

pub static ENCOUNTERZONECONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EncounterZoneConfig",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EncounterZoneConfig as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Zone",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(EncounterZoneConfig, zone),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(EncounterZoneConfig, priority),
            },
            FieldInfoData {
                name: "MaxNPCs",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(EncounterZoneConfig, max_n_p_cs),
            },
            FieldInfoData {
                name: "RequireConditionA",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EncounterZoneConfig, require_condition_a),
            },
            FieldInfoData {
                name: "RequireConditionB",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EncounterZoneConfig, require_condition_b),
            },
            FieldInfoData {
                name: "RequiredWeapon1",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponAnimBaseSetEnum",
                rust_offset: offset_of!(EncounterZoneConfig, required_weapon1),
            },
            FieldInfoData {
                name: "RequiredWeapon2",
                flags: MemberInfoFlags::new(0),
                field_type: "WeaponAnimBaseSetEnum",
                rust_offset: offset_of!(EncounterZoneConfig, required_weapon2),
            },
            FieldInfoData {
                name: "RequireSMG",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EncounterZoneConfig, require_s_m_g),
            },
            FieldInfoData {
                name: "PreferCover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EncounterZoneConfig, prefer_cover),
            },
        ],
    }),
    array_type: Some(ENCOUNTERZONECONFIG_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EncounterZoneConfig {
    fn type_info(&self) -> &'static TypeInfo {
        ENCOUNTERZONECONFIG_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ENCOUNTERZONECONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EncounterZoneConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EncounterZoneConfig"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ServerEncounterManagerRemovedMessage {
}

pub trait ServerEncounterManagerRemovedMessageTrait: TypeObject {
}

impl ServerEncounterManagerRemovedMessageTrait for ServerEncounterManagerRemovedMessage {
}

pub static SERVERENCOUNTERMANAGERREMOVEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerEncounterManagerRemovedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ServerEncounterManagerRemovedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ServerEncounterManagerRemovedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        SERVERENCOUNTERMANAGERREMOVEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct AIDynamicConcealmentComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub volume_origin: DynamicConcealmentOrigin,
    pub condition: DynamicConcealmentCondition,
    pub bounding_box_x_size: f32,
    pub bounding_box_y_size: f32,
    pub bounding_box_z_size: f32,
}

pub trait AIDynamicConcealmentComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn volume_origin(&self) -> &DynamicConcealmentOrigin;
    fn volume_origin_mut(&mut self) -> &mut DynamicConcealmentOrigin;
    fn condition(&self) -> &DynamicConcealmentCondition;
    fn condition_mut(&mut self) -> &mut DynamicConcealmentCondition;
    fn bounding_box_x_size(&self) -> &f32;
    fn bounding_box_x_size_mut(&mut self) -> &mut f32;
    fn bounding_box_y_size(&self) -> &f32;
    fn bounding_box_y_size_mut(&mut self) -> &mut f32;
    fn bounding_box_z_size(&self) -> &f32;
    fn bounding_box_z_size_mut(&mut self) -> &mut f32;
}

impl AIDynamicConcealmentComponentDataTrait for AIDynamicConcealmentComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn volume_origin(&self) -> &DynamicConcealmentOrigin {
        &self.volume_origin
    }
    fn volume_origin_mut(&mut self) -> &mut DynamicConcealmentOrigin {
        &mut self.volume_origin
    }
    fn condition(&self) -> &DynamicConcealmentCondition {
        &self.condition
    }
    fn condition_mut(&mut self) -> &mut DynamicConcealmentCondition {
        &mut self.condition
    }
    fn bounding_box_x_size(&self) -> &f32 {
        &self.bounding_box_x_size
    }
    fn bounding_box_x_size_mut(&mut self) -> &mut f32 {
        &mut self.bounding_box_x_size
    }
    fn bounding_box_y_size(&self) -> &f32 {
        &self.bounding_box_y_size
    }
    fn bounding_box_y_size_mut(&mut self) -> &mut f32 {
        &mut self.bounding_box_y_size
    }
    fn bounding_box_z_size(&self) -> &f32 {
        &self.bounding_box_z_size
    }
    fn bounding_box_z_size_mut(&mut self) -> &mut f32 {
        &mut self.bounding_box_z_size
    }
}

impl super::entity::GameComponentDataTrait for AIDynamicConcealmentComponentData {
}

impl super::entity::ComponentDataTrait for AIDynamicConcealmentComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AIDynamicConcealmentComponentData {
}

impl super::core::DataBusPeerTrait for AIDynamicConcealmentComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIDynamicConcealmentComponentData {
}

impl super::core::DataContainerTrait for AIDynamicConcealmentComponentData {
}

pub static AIDYNAMICCONCEALMENTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDynamicConcealmentComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIDynamicConcealmentComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, realm),
            },
            FieldInfoData {
                name: "VolumeOrigin",
                flags: MemberInfoFlags::new(0),
                field_type: "DynamicConcealmentOrigin",
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, volume_origin),
            },
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(0),
                field_type: "DynamicConcealmentCondition",
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, condition),
            },
            FieldInfoData {
                name: "BoundingBoxXSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, bounding_box_x_size),
            },
            FieldInfoData {
                name: "BoundingBoxYSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, bounding_box_y_size),
            },
            FieldInfoData {
                name: "BoundingBoxZSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, bounding_box_z_size),
            },
        ],
    }),
    array_type: Some(AIDYNAMICCONCEALMENTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIDynamicConcealmentComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIDYNAMICCONCEALMENTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIDYNAMICCONCEALMENTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDynamicConcealmentComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIDynamicConcealmentComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DynamicConcealmentCondition {
    #[default]
    DynamicConcealmentCondition_Inside = 0,
    DynamicConcealmentCondition_InsideOrBehind = 1,
}

pub static DYNAMICCONCEALMENTCONDITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicConcealmentCondition",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(DYNAMICCONCEALMENTCONDITION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DynamicConcealmentCondition {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICCONCEALMENTCONDITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DYNAMICCONCEALMENTCONDITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicConcealmentCondition-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DynamicConcealmentCondition"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DynamicConcealmentOrigin {
    #[default]
    DynamicConcealmentOrigin_Bottom = 0,
    DynamicConcealmentOrigin_Middle = 1,
}

pub static DYNAMICCONCEALMENTORIGIN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicConcealmentOrigin",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(DYNAMICCONCEALMENTORIGIN_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DynamicConcealmentOrigin {
    fn type_info(&self) -> &'static TypeInfo {
        DYNAMICCONCEALMENTORIGIN_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DYNAMICCONCEALMENTORIGIN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicConcealmentOrigin-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DynamicConcealmentOrigin"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleDriverComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub reach_waypoint_radius: f32,
    pub only_check_radius: bool,
    pub use_player_input: bool,
    pub player_input_in_world_space: bool,
    pub throttle_input_action: i32,
    pub strafe_input_action: i32,
    pub p_value: f32,
    pub i_value: f32,
    pub reference_point: super::core::Vec3,
    pub speed_multiplier: f32,
    pub use_animation: bool,
    pub use_channels: bool,
    pub driver_signals: SimpleDriverBinding,
    pub driver_channels: SimpleDriverChannelData,
    pub only_drive_forward: bool,
}

pub trait SimpleDriverComponentDataTrait: super::entity::GameComponentDataTrait {
    fn reach_waypoint_radius(&self) -> &f32;
    fn reach_waypoint_radius_mut(&mut self) -> &mut f32;
    fn only_check_radius(&self) -> &bool;
    fn only_check_radius_mut(&mut self) -> &mut bool;
    fn use_player_input(&self) -> &bool;
    fn use_player_input_mut(&mut self) -> &mut bool;
    fn player_input_in_world_space(&self) -> &bool;
    fn player_input_in_world_space_mut(&mut self) -> &mut bool;
    fn throttle_input_action(&self) -> &i32;
    fn throttle_input_action_mut(&mut self) -> &mut i32;
    fn strafe_input_action(&self) -> &i32;
    fn strafe_input_action_mut(&mut self) -> &mut i32;
    fn p_value(&self) -> &f32;
    fn p_value_mut(&mut self) -> &mut f32;
    fn i_value(&self) -> &f32;
    fn i_value_mut(&mut self) -> &mut f32;
    fn reference_point(&self) -> &super::core::Vec3;
    fn reference_point_mut(&mut self) -> &mut super::core::Vec3;
    fn speed_multiplier(&self) -> &f32;
    fn speed_multiplier_mut(&mut self) -> &mut f32;
    fn use_animation(&self) -> &bool;
    fn use_animation_mut(&mut self) -> &mut bool;
    fn use_channels(&self) -> &bool;
    fn use_channels_mut(&mut self) -> &mut bool;
    fn driver_signals(&self) -> &SimpleDriverBinding;
    fn driver_signals_mut(&mut self) -> &mut SimpleDriverBinding;
    fn driver_channels(&self) -> &SimpleDriverChannelData;
    fn driver_channels_mut(&mut self) -> &mut SimpleDriverChannelData;
    fn only_drive_forward(&self) -> &bool;
    fn only_drive_forward_mut(&mut self) -> &mut bool;
}

impl SimpleDriverComponentDataTrait for SimpleDriverComponentData {
    fn reach_waypoint_radius(&self) -> &f32 {
        &self.reach_waypoint_radius
    }
    fn reach_waypoint_radius_mut(&mut self) -> &mut f32 {
        &mut self.reach_waypoint_radius
    }
    fn only_check_radius(&self) -> &bool {
        &self.only_check_radius
    }
    fn only_check_radius_mut(&mut self) -> &mut bool {
        &mut self.only_check_radius
    }
    fn use_player_input(&self) -> &bool {
        &self.use_player_input
    }
    fn use_player_input_mut(&mut self) -> &mut bool {
        &mut self.use_player_input
    }
    fn player_input_in_world_space(&self) -> &bool {
        &self.player_input_in_world_space
    }
    fn player_input_in_world_space_mut(&mut self) -> &mut bool {
        &mut self.player_input_in_world_space
    }
    fn throttle_input_action(&self) -> &i32 {
        &self.throttle_input_action
    }
    fn throttle_input_action_mut(&mut self) -> &mut i32 {
        &mut self.throttle_input_action
    }
    fn strafe_input_action(&self) -> &i32 {
        &self.strafe_input_action
    }
    fn strafe_input_action_mut(&mut self) -> &mut i32 {
        &mut self.strafe_input_action
    }
    fn p_value(&self) -> &f32 {
        &self.p_value
    }
    fn p_value_mut(&mut self) -> &mut f32 {
        &mut self.p_value
    }
    fn i_value(&self) -> &f32 {
        &self.i_value
    }
    fn i_value_mut(&mut self) -> &mut f32 {
        &mut self.i_value
    }
    fn reference_point(&self) -> &super::core::Vec3 {
        &self.reference_point
    }
    fn reference_point_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.reference_point
    }
    fn speed_multiplier(&self) -> &f32 {
        &self.speed_multiplier
    }
    fn speed_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.speed_multiplier
    }
    fn use_animation(&self) -> &bool {
        &self.use_animation
    }
    fn use_animation_mut(&mut self) -> &mut bool {
        &mut self.use_animation
    }
    fn use_channels(&self) -> &bool {
        &self.use_channels
    }
    fn use_channels_mut(&mut self) -> &mut bool {
        &mut self.use_channels
    }
    fn driver_signals(&self) -> &SimpleDriverBinding {
        &self.driver_signals
    }
    fn driver_signals_mut(&mut self) -> &mut SimpleDriverBinding {
        &mut self.driver_signals
    }
    fn driver_channels(&self) -> &SimpleDriverChannelData {
        &self.driver_channels
    }
    fn driver_channels_mut(&mut self) -> &mut SimpleDriverChannelData {
        &mut self.driver_channels
    }
    fn only_drive_forward(&self) -> &bool {
        &self.only_drive_forward
    }
    fn only_drive_forward_mut(&mut self) -> &mut bool {
        &mut self.only_drive_forward
    }
}

impl super::entity::GameComponentDataTrait for SimpleDriverComponentData {
}

impl super::entity::ComponentDataTrait for SimpleDriverComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for SimpleDriverComponentData {
}

impl super::core::DataBusPeerTrait for SimpleDriverComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SimpleDriverComponentData {
}

impl super::core::DataContainerTrait for SimpleDriverComponentData {
}

pub static SIMPLEDRIVERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleDriverComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ReachWaypointRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDriverComponentData, reach_waypoint_radius),
            },
            FieldInfoData {
                name: "OnlyCheckRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleDriverComponentData, only_check_radius),
            },
            FieldInfoData {
                name: "UsePlayerInput",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleDriverComponentData, use_player_input),
            },
            FieldInfoData {
                name: "PlayerInputInWorldSpace",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleDriverComponentData, player_input_in_world_space),
            },
            FieldInfoData {
                name: "ThrottleInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleDriverComponentData, throttle_input_action),
            },
            FieldInfoData {
                name: "StrafeInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SimpleDriverComponentData, strafe_input_action),
            },
            FieldInfoData {
                name: "PValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDriverComponentData, p_value),
            },
            FieldInfoData {
                name: "IValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDriverComponentData, i_value),
            },
            FieldInfoData {
                name: "ReferencePoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SimpleDriverComponentData, reference_point),
            },
            FieldInfoData {
                name: "SpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SimpleDriverComponentData, speed_multiplier),
            },
            FieldInfoData {
                name: "UseAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleDriverComponentData, use_animation),
            },
            FieldInfoData {
                name: "UseChannels",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleDriverComponentData, use_channels),
            },
            FieldInfoData {
                name: "DriverSignals",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleDriverBinding",
                rust_offset: offset_of!(SimpleDriverComponentData, driver_signals),
            },
            FieldInfoData {
                name: "DriverChannels",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleDriverChannelData",
                rust_offset: offset_of!(SimpleDriverComponentData, driver_channels),
            },
            FieldInfoData {
                name: "OnlyDriveForward",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SimpleDriverComponentData, only_drive_forward),
            },
        ],
    }),
    array_type: Some(SIMPLEDRIVERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SimpleDriverComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEDRIVERCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEDRIVERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SimpleDriverComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleDriverChannelData {
    pub fwd: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub bwd: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub left: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub right: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub moving: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
    pub angle: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub speed_multiplier: Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>,
    pub is_a_i: Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>,
}

pub trait SimpleDriverChannelDataTrait: TypeObject {
    fn fwd(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn fwd_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn bwd(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn bwd_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn left(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn left_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn right(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn right_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn moving(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn moving_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn angle(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn angle_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn speed_multiplier(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn speed_multiplier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>>;
    fn is_a_i(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
    fn is_a_i_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>>;
}

impl SimpleDriverChannelDataTrait for SimpleDriverChannelData {
    fn fwd(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.fwd
    }
    fn fwd_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &mut self.fwd
    }
    fn bwd(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.bwd
    }
    fn bwd_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &mut self.bwd
    }
    fn left(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.left
    }
    fn left_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &mut self.left
    }
    fn right(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.right
    }
    fn right_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &mut self.right
    }
    fn moving(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.moving
    }
    fn moving_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &mut self.moving
    }
    fn angle(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &mut self.angle
    }
    fn speed_multiplier(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &self.speed_multiplier
    }
    fn speed_multiplier_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::FloatChannelDataTrait>>> {
        &mut self.speed_multiplier
    }
    fn is_a_i(&self) -> &Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &self.is_a_i
    }
    fn is_a_i_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::soldier_shared::BoolChannelDataTrait>>> {
        &mut self.is_a_i
    }
}

pub static SIMPLEDRIVERCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverChannelData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleDriverChannelData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Fwd",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(SimpleDriverChannelData, fwd),
            },
            FieldInfoData {
                name: "Bwd",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(SimpleDriverChannelData, bwd),
            },
            FieldInfoData {
                name: "Left",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(SimpleDriverChannelData, left),
            },
            FieldInfoData {
                name: "Right",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(SimpleDriverChannelData, right),
            },
            FieldInfoData {
                name: "Moving",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(SimpleDriverChannelData, moving),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(SimpleDriverChannelData, angle),
            },
            FieldInfoData {
                name: "SpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatChannelData",
                rust_offset: offset_of!(SimpleDriverChannelData, speed_multiplier),
            },
            FieldInfoData {
                name: "IsAI",
                flags: MemberInfoFlags::new(0),
                field_type: "BoolChannelData",
                rust_offset: offset_of!(SimpleDriverChannelData, is_a_i),
            },
        ],
    }),
    array_type: Some(SIMPLEDRIVERCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleDriverChannelData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEDRIVERCHANNELDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SIMPLEDRIVERCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SimpleDriverChannelData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleDriverBinding {
    pub fwd: super::ant::AntRef,
    pub bwd: super::ant::AntRef,
    pub left: super::ant::AntRef,
    pub right: super::ant::AntRef,
    pub moving: super::ant::AntRef,
    pub angle: super::ant::AntRef,
    pub speed_multiplier: super::ant::AntRef,
    pub is_a_i: super::ant::AntRef,
}

pub trait SimpleDriverBindingTrait: TypeObject {
    fn fwd(&self) -> &super::ant::AntRef;
    fn fwd_mut(&mut self) -> &mut super::ant::AntRef;
    fn bwd(&self) -> &super::ant::AntRef;
    fn bwd_mut(&mut self) -> &mut super::ant::AntRef;
    fn left(&self) -> &super::ant::AntRef;
    fn left_mut(&mut self) -> &mut super::ant::AntRef;
    fn right(&self) -> &super::ant::AntRef;
    fn right_mut(&mut self) -> &mut super::ant::AntRef;
    fn moving(&self) -> &super::ant::AntRef;
    fn moving_mut(&mut self) -> &mut super::ant::AntRef;
    fn angle(&self) -> &super::ant::AntRef;
    fn angle_mut(&mut self) -> &mut super::ant::AntRef;
    fn speed_multiplier(&self) -> &super::ant::AntRef;
    fn speed_multiplier_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_a_i(&self) -> &super::ant::AntRef;
    fn is_a_i_mut(&mut self) -> &mut super::ant::AntRef;
}

impl SimpleDriverBindingTrait for SimpleDriverBinding {
    fn fwd(&self) -> &super::ant::AntRef {
        &self.fwd
    }
    fn fwd_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.fwd
    }
    fn bwd(&self) -> &super::ant::AntRef {
        &self.bwd
    }
    fn bwd_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.bwd
    }
    fn left(&self) -> &super::ant::AntRef {
        &self.left
    }
    fn left_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.left
    }
    fn right(&self) -> &super::ant::AntRef {
        &self.right
    }
    fn right_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.right
    }
    fn moving(&self) -> &super::ant::AntRef {
        &self.moving
    }
    fn moving_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.moving
    }
    fn angle(&self) -> &super::ant::AntRef {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.angle
    }
    fn speed_multiplier(&self) -> &super::ant::AntRef {
        &self.speed_multiplier
    }
    fn speed_multiplier_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.speed_multiplier
    }
    fn is_a_i(&self) -> &super::ant::AntRef {
        &self.is_a_i
    }
    fn is_a_i_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_a_i
    }
}

pub static SIMPLEDRIVERBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleDriverBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Fwd",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SimpleDriverBinding, fwd),
            },
            FieldInfoData {
                name: "Bwd",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SimpleDriverBinding, bwd),
            },
            FieldInfoData {
                name: "Left",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SimpleDriverBinding, left),
            },
            FieldInfoData {
                name: "Right",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SimpleDriverBinding, right),
            },
            FieldInfoData {
                name: "Moving",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SimpleDriverBinding, moving),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SimpleDriverBinding, angle),
            },
            FieldInfoData {
                name: "SpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SimpleDriverBinding, speed_multiplier),
            },
            FieldInfoData {
                name: "IsAI",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(SimpleDriverBinding, is_a_i),
            },
        ],
    }),
    array_type: Some(SIMPLEDRIVERBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SimpleDriverBinding {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEDRIVERBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SIMPLEDRIVERBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SimpleDriverBinding"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIDebugProxyData {
    pub _glacier_base: super::entity::SpatialEntityData,
    pub proxy_name: String,
    pub test_cover_query: Option<Arc<Mutex<dyn CoverQueryDataTrait>>>,
    pub preferred_weapon_range: Option<Arc<Mutex<dyn PreferredRangeTrait>>>,
    pub preferred_cover_slot_index: u32,
    pub can_hover: bool,
    pub debug_path: bool,
    pub navmesh_layer: i32,
    pub path_corridor_radius: f32,
    pub force_active: bool,
}

pub trait AIDebugProxyDataTrait: super::entity::SpatialEntityDataTrait {
    fn proxy_name(&self) -> &String;
    fn proxy_name_mut(&mut self) -> &mut String;
    fn test_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn test_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>>;
    fn preferred_weapon_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
    fn preferred_weapon_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>>;
    fn preferred_cover_slot_index(&self) -> &u32;
    fn preferred_cover_slot_index_mut(&mut self) -> &mut u32;
    fn can_hover(&self) -> &bool;
    fn can_hover_mut(&mut self) -> &mut bool;
    fn debug_path(&self) -> &bool;
    fn debug_path_mut(&mut self) -> &mut bool;
    fn navmesh_layer(&self) -> &i32;
    fn navmesh_layer_mut(&mut self) -> &mut i32;
    fn path_corridor_radius(&self) -> &f32;
    fn path_corridor_radius_mut(&mut self) -> &mut f32;
    fn force_active(&self) -> &bool;
    fn force_active_mut(&mut self) -> &mut bool;
}

impl AIDebugProxyDataTrait for AIDebugProxyData {
    fn proxy_name(&self) -> &String {
        &self.proxy_name
    }
    fn proxy_name_mut(&mut self) -> &mut String {
        &mut self.proxy_name
    }
    fn test_cover_query(&self) -> &Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &self.test_cover_query
    }
    fn test_cover_query_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CoverQueryDataTrait>>> {
        &mut self.test_cover_query
    }
    fn preferred_weapon_range(&self) -> &Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &self.preferred_weapon_range
    }
    fn preferred_weapon_range_mut(&mut self) -> &mut Option<Arc<Mutex<dyn PreferredRangeTrait>>> {
        &mut self.preferred_weapon_range
    }
    fn preferred_cover_slot_index(&self) -> &u32 {
        &self.preferred_cover_slot_index
    }
    fn preferred_cover_slot_index_mut(&mut self) -> &mut u32 {
        &mut self.preferred_cover_slot_index
    }
    fn can_hover(&self) -> &bool {
        &self.can_hover
    }
    fn can_hover_mut(&mut self) -> &mut bool {
        &mut self.can_hover
    }
    fn debug_path(&self) -> &bool {
        &self.debug_path
    }
    fn debug_path_mut(&mut self) -> &mut bool {
        &mut self.debug_path
    }
    fn navmesh_layer(&self) -> &i32 {
        &self.navmesh_layer
    }
    fn navmesh_layer_mut(&mut self) -> &mut i32 {
        &mut self.navmesh_layer
    }
    fn path_corridor_radius(&self) -> &f32 {
        &self.path_corridor_radius
    }
    fn path_corridor_radius_mut(&mut self) -> &mut f32 {
        &mut self.path_corridor_radius
    }
    fn force_active(&self) -> &bool {
        &self.force_active
    }
    fn force_active_mut(&mut self) -> &mut bool {
        &mut self.force_active
    }
}

impl super::entity::SpatialEntityDataTrait for AIDebugProxyData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for AIDebugProxyData {
}

impl super::entity::GameObjectDataTrait for AIDebugProxyData {
}

impl super::core::DataBusPeerTrait for AIDebugProxyData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIDebugProxyData {
}

impl super::core::DataContainerTrait for AIDebugProxyData {
}

pub static AIDEBUGPROXYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDebugProxyData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::SPATIALENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIDebugProxyData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ProxyName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AIDebugProxyData, proxy_name),
            },
            FieldInfoData {
                name: "TestCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: "CoverQueryData",
                rust_offset: offset_of!(AIDebugProxyData, test_cover_query),
            },
            FieldInfoData {
                name: "PreferredWeaponRange",
                flags: MemberInfoFlags::new(0),
                field_type: "PreferredRange",
                rust_offset: offset_of!(AIDebugProxyData, preferred_weapon_range),
            },
            FieldInfoData {
                name: "PreferredCoverSlotIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AIDebugProxyData, preferred_cover_slot_index),
            },
            FieldInfoData {
                name: "CanHover",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIDebugProxyData, can_hover),
            },
            FieldInfoData {
                name: "DebugPath",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIDebugProxyData, debug_path),
            },
            FieldInfoData {
                name: "NavmeshLayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AIDebugProxyData, navmesh_layer),
            },
            FieldInfoData {
                name: "PathCorridorRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIDebugProxyData, path_corridor_radius),
            },
            FieldInfoData {
                name: "ForceActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIDebugProxyData, force_active),
            },
        ],
    }),
    array_type: Some(AIDEBUGPROXYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIDebugProxyData {
    fn type_info(&self) -> &'static TypeInfo {
        AIDEBUGPROXYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIDEBUGPROXYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDebugProxyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIDebugProxyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AICustomInputComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub realm: super::core::Realm,
    pub input_actions: Vec<AIInputAction>,
}

pub trait AICustomInputComponentDataTrait: super::entity::GameComponentDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn input_actions(&self) -> &Vec<AIInputAction>;
    fn input_actions_mut(&mut self) -> &mut Vec<AIInputAction>;
}

impl AICustomInputComponentDataTrait for AICustomInputComponentData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn input_actions(&self) -> &Vec<AIInputAction> {
        &self.input_actions
    }
    fn input_actions_mut(&mut self) -> &mut Vec<AIInputAction> {
        &mut self.input_actions
    }
}

impl super::entity::GameComponentDataTrait for AICustomInputComponentData {
}

impl super::entity::ComponentDataTrait for AICustomInputComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AICustomInputComponentData {
}

impl super::core::DataBusPeerTrait for AICustomInputComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AICustomInputComponentData {
}

impl super::core::DataContainerTrait for AICustomInputComponentData {
}

pub static AICUSTOMINPUTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICustomInputComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AICustomInputComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AICustomInputComponentData, realm),
            },
            FieldInfoData {
                name: "InputActions",
                flags: MemberInfoFlags::new(144),
                field_type: "AIInputAction-Array",
                rust_offset: offset_of!(AICustomInputComponentData, input_actions),
            },
        ],
    }),
    array_type: Some(AICUSTOMINPUTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AICustomInputComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AICUSTOMINPUTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AICUSTOMINPUTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICustomInputComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICustomInputComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIInputAction {
    pub name: String,
    pub actions: Vec<i32>,
    pub duration: f32,
}

pub trait AIInputActionTrait: TypeObject {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn actions(&self) -> &Vec<i32>;
    fn actions_mut(&mut self) -> &mut Vec<i32>;
    fn duration(&self) -> &f32;
    fn duration_mut(&mut self) -> &mut f32;
}

impl AIInputActionTrait for AIInputAction {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn actions(&self) -> &Vec<i32> {
        &self.actions
    }
    fn actions_mut(&mut self) -> &mut Vec<i32> {
        &mut self.actions
    }
    fn duration(&self) -> &f32 {
        &self.duration
    }
    fn duration_mut(&mut self) -> &mut f32 {
        &mut self.duration
    }
}

pub static AIINPUTACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIInputAction",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIInputAction as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AIInputAction, name),
            },
            FieldInfoData {
                name: "Actions",
                flags: MemberInfoFlags::new(144),
                field_type: "Int32-Array",
                rust_offset: offset_of!(AIInputAction, actions),
            },
            FieldInfoData {
                name: "Duration",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIInputAction, duration),
            },
        ],
    }),
    array_type: Some(AIINPUTACTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIInputAction {
    fn type_info(&self) -> &'static TypeInfo {
        AIINPUTACTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIINPUTACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIInputAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIInputAction"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TargetCoordinationGlobalSettings {
    pub fov_in_degrees: f32,
    pub max_distance: f32,
    pub out_of_fov_factor: f32,
    pub check_cross_fire: bool,
    pub cross_fire_radius: f32,
    pub visible_time_limit: f32,
    pub min_time_in_role_attack: f32,
}

pub trait TargetCoordinationGlobalSettingsTrait: TypeObject {
    fn fov_in_degrees(&self) -> &f32;
    fn fov_in_degrees_mut(&mut self) -> &mut f32;
    fn max_distance(&self) -> &f32;
    fn max_distance_mut(&mut self) -> &mut f32;
    fn out_of_fov_factor(&self) -> &f32;
    fn out_of_fov_factor_mut(&mut self) -> &mut f32;
    fn check_cross_fire(&self) -> &bool;
    fn check_cross_fire_mut(&mut self) -> &mut bool;
    fn cross_fire_radius(&self) -> &f32;
    fn cross_fire_radius_mut(&mut self) -> &mut f32;
    fn visible_time_limit(&self) -> &f32;
    fn visible_time_limit_mut(&mut self) -> &mut f32;
    fn min_time_in_role_attack(&self) -> &f32;
    fn min_time_in_role_attack_mut(&mut self) -> &mut f32;
}

impl TargetCoordinationGlobalSettingsTrait for TargetCoordinationGlobalSettings {
    fn fov_in_degrees(&self) -> &f32 {
        &self.fov_in_degrees
    }
    fn fov_in_degrees_mut(&mut self) -> &mut f32 {
        &mut self.fov_in_degrees
    }
    fn max_distance(&self) -> &f32 {
        &self.max_distance
    }
    fn max_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_distance
    }
    fn out_of_fov_factor(&self) -> &f32 {
        &self.out_of_fov_factor
    }
    fn out_of_fov_factor_mut(&mut self) -> &mut f32 {
        &mut self.out_of_fov_factor
    }
    fn check_cross_fire(&self) -> &bool {
        &self.check_cross_fire
    }
    fn check_cross_fire_mut(&mut self) -> &mut bool {
        &mut self.check_cross_fire
    }
    fn cross_fire_radius(&self) -> &f32 {
        &self.cross_fire_radius
    }
    fn cross_fire_radius_mut(&mut self) -> &mut f32 {
        &mut self.cross_fire_radius
    }
    fn visible_time_limit(&self) -> &f32 {
        &self.visible_time_limit
    }
    fn visible_time_limit_mut(&mut self) -> &mut f32 {
        &mut self.visible_time_limit
    }
    fn min_time_in_role_attack(&self) -> &f32 {
        &self.min_time_in_role_attack
    }
    fn min_time_in_role_attack_mut(&mut self) -> &mut f32 {
        &mut self.min_time_in_role_attack
    }
}

pub static TARGETCOORDINATIONGLOBALSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinationGlobalSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TargetCoordinationGlobalSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FovInDegrees",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, fov_in_degrees),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, max_distance),
            },
            FieldInfoData {
                name: "OutOfFovFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, out_of_fov_factor),
            },
            FieldInfoData {
                name: "CheckCrossFire",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, check_cross_fire),
            },
            FieldInfoData {
                name: "CrossFireRadius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, cross_fire_radius),
            },
            FieldInfoData {
                name: "VisibleTimeLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, visible_time_limit),
            },
            FieldInfoData {
                name: "MinTimeInRoleAttack",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, min_time_in_role_attack),
            },
        ],
    }),
    array_type: Some(TARGETCOORDINATIONGLOBALSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TargetCoordinationGlobalSettings {
    fn type_info(&self) -> &'static TypeInfo {
        TARGETCOORDINATIONGLOBALSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TARGETCOORDINATIONGLOBALSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinationGlobalSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetCoordinationGlobalSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AICollisionAvoidanceSetupEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub avoid_a_i_players: bool,
    pub avoid_human_players: bool,
    pub velocity_offset_stiffness: f32,
    pub velocity_offset_max_deflection: f32,
    pub look_ahead_time: f32,
    pub recompute_steering_threshold: f32,
    pub max_stationary_repulsion: f32,
    pub repulsion_gain_time: f32,
    pub repulsion_decay_time: f32,
    pub max_repulsion_distance: f32,
}

pub trait AICollisionAvoidanceSetupEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn avoid_a_i_players(&self) -> &bool;
    fn avoid_a_i_players_mut(&mut self) -> &mut bool;
    fn avoid_human_players(&self) -> &bool;
    fn avoid_human_players_mut(&mut self) -> &mut bool;
    fn velocity_offset_stiffness(&self) -> &f32;
    fn velocity_offset_stiffness_mut(&mut self) -> &mut f32;
    fn velocity_offset_max_deflection(&self) -> &f32;
    fn velocity_offset_max_deflection_mut(&mut self) -> &mut f32;
    fn look_ahead_time(&self) -> &f32;
    fn look_ahead_time_mut(&mut self) -> &mut f32;
    fn recompute_steering_threshold(&self) -> &f32;
    fn recompute_steering_threshold_mut(&mut self) -> &mut f32;
    fn max_stationary_repulsion(&self) -> &f32;
    fn max_stationary_repulsion_mut(&mut self) -> &mut f32;
    fn repulsion_gain_time(&self) -> &f32;
    fn repulsion_gain_time_mut(&mut self) -> &mut f32;
    fn repulsion_decay_time(&self) -> &f32;
    fn repulsion_decay_time_mut(&mut self) -> &mut f32;
    fn max_repulsion_distance(&self) -> &f32;
    fn max_repulsion_distance_mut(&mut self) -> &mut f32;
}

impl AICollisionAvoidanceSetupEntityDataTrait for AICollisionAvoidanceSetupEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn avoid_a_i_players(&self) -> &bool {
        &self.avoid_a_i_players
    }
    fn avoid_a_i_players_mut(&mut self) -> &mut bool {
        &mut self.avoid_a_i_players
    }
    fn avoid_human_players(&self) -> &bool {
        &self.avoid_human_players
    }
    fn avoid_human_players_mut(&mut self) -> &mut bool {
        &mut self.avoid_human_players
    }
    fn velocity_offset_stiffness(&self) -> &f32 {
        &self.velocity_offset_stiffness
    }
    fn velocity_offset_stiffness_mut(&mut self) -> &mut f32 {
        &mut self.velocity_offset_stiffness
    }
    fn velocity_offset_max_deflection(&self) -> &f32 {
        &self.velocity_offset_max_deflection
    }
    fn velocity_offset_max_deflection_mut(&mut self) -> &mut f32 {
        &mut self.velocity_offset_max_deflection
    }
    fn look_ahead_time(&self) -> &f32 {
        &self.look_ahead_time
    }
    fn look_ahead_time_mut(&mut self) -> &mut f32 {
        &mut self.look_ahead_time
    }
    fn recompute_steering_threshold(&self) -> &f32 {
        &self.recompute_steering_threshold
    }
    fn recompute_steering_threshold_mut(&mut self) -> &mut f32 {
        &mut self.recompute_steering_threshold
    }
    fn max_stationary_repulsion(&self) -> &f32 {
        &self.max_stationary_repulsion
    }
    fn max_stationary_repulsion_mut(&mut self) -> &mut f32 {
        &mut self.max_stationary_repulsion
    }
    fn repulsion_gain_time(&self) -> &f32 {
        &self.repulsion_gain_time
    }
    fn repulsion_gain_time_mut(&mut self) -> &mut f32 {
        &mut self.repulsion_gain_time
    }
    fn repulsion_decay_time(&self) -> &f32 {
        &self.repulsion_decay_time
    }
    fn repulsion_decay_time_mut(&mut self) -> &mut f32 {
        &mut self.repulsion_decay_time
    }
    fn max_repulsion_distance(&self) -> &f32 {
        &self.max_repulsion_distance
    }
    fn max_repulsion_distance_mut(&mut self) -> &mut f32 {
        &mut self.max_repulsion_distance
    }
}

impl super::entity::EntityDataTrait for AICollisionAvoidanceSetupEntityData {
}

impl super::entity::GameObjectDataTrait for AICollisionAvoidanceSetupEntityData {
}

impl super::core::DataBusPeerTrait for AICollisionAvoidanceSetupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AICollisionAvoidanceSetupEntityData {
}

impl super::core::DataContainerTrait for AICollisionAvoidanceSetupEntityData {
}

pub static AICOLLISIONAVOIDANCESETUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICollisionAvoidanceSetupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AICollisionAvoidanceSetupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, realm),
            },
            FieldInfoData {
                name: "AvoidAIPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, avoid_a_i_players),
            },
            FieldInfoData {
                name: "AvoidHumanPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, avoid_human_players),
            },
            FieldInfoData {
                name: "VelocityOffsetStiffness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, velocity_offset_stiffness),
            },
            FieldInfoData {
                name: "VelocityOffsetMaxDeflection",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, velocity_offset_max_deflection),
            },
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, look_ahead_time),
            },
            FieldInfoData {
                name: "RecomputeSteeringThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, recompute_steering_threshold),
            },
            FieldInfoData {
                name: "MaxStationaryRepulsion",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, max_stationary_repulsion),
            },
            FieldInfoData {
                name: "RepulsionGainTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, repulsion_gain_time),
            },
            FieldInfoData {
                name: "RepulsionDecayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, repulsion_decay_time),
            },
            FieldInfoData {
                name: "MaxRepulsionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, max_repulsion_distance),
            },
        ],
    }),
    array_type: Some(AICOLLISIONAVOIDANCESETUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICollisionAvoidanceSetupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AICOLLISIONAVOIDANCESETUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AICOLLISIONAVOIDANCESETUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICollisionAvoidanceSetupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICollisionAvoidanceSetupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIBucketSystemComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub use_evasive_bucket_settings: bool,
    pub use_human_player: bool,
    pub enabled: bool,
}

pub trait AIBucketSystemComponentDataTrait: super::entity::GameComponentDataTrait {
    fn use_evasive_bucket_settings(&self) -> &bool;
    fn use_evasive_bucket_settings_mut(&mut self) -> &mut bool;
    fn use_human_player(&self) -> &bool;
    fn use_human_player_mut(&mut self) -> &mut bool;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl AIBucketSystemComponentDataTrait for AIBucketSystemComponentData {
    fn use_evasive_bucket_settings(&self) -> &bool {
        &self.use_evasive_bucket_settings
    }
    fn use_evasive_bucket_settings_mut(&mut self) -> &mut bool {
        &mut self.use_evasive_bucket_settings
    }
    fn use_human_player(&self) -> &bool {
        &self.use_human_player
    }
    fn use_human_player_mut(&mut self) -> &mut bool {
        &mut self.use_human_player
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl super::entity::GameComponentDataTrait for AIBucketSystemComponentData {
}

impl super::entity::ComponentDataTrait for AIBucketSystemComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AIBucketSystemComponentData {
}

impl super::core::DataBusPeerTrait for AIBucketSystemComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIBucketSystemComponentData {
}

impl super::core::DataContainerTrait for AIBucketSystemComponentData {
}

pub static AIBUCKETSYSTEMCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBucketSystemComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIBucketSystemComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UseEvasiveBucketSettings",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIBucketSystemComponentData, use_evasive_bucket_settings),
            },
            FieldInfoData {
                name: "UseHumanPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIBucketSystemComponentData, use_human_player),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIBucketSystemComponentData, enabled),
            },
        ],
    }),
    array_type: Some(AIBUCKETSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIBucketSystemComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIBUCKETSYSTEMCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIBUCKETSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBucketSystemComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIBucketSystemComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIBlockerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub realm: super::core::Realm,
    pub enable_on_init: bool,
    pub slow_distance: f32,
    pub stop_distance: f32,
    pub bounds_expansion: super::core::Vec3,
    pub min_speed_for_bounds_expansion: f32,
    pub allow_movement_inside_bounds: bool,
}

pub trait AIBlockerEntityDataTrait: super::entity::EntityDataTrait {
    fn realm(&self) -> &super::core::Realm;
    fn realm_mut(&mut self) -> &mut super::core::Realm;
    fn enable_on_init(&self) -> &bool;
    fn enable_on_init_mut(&mut self) -> &mut bool;
    fn slow_distance(&self) -> &f32;
    fn slow_distance_mut(&mut self) -> &mut f32;
    fn stop_distance(&self) -> &f32;
    fn stop_distance_mut(&mut self) -> &mut f32;
    fn bounds_expansion(&self) -> &super::core::Vec3;
    fn bounds_expansion_mut(&mut self) -> &mut super::core::Vec3;
    fn min_speed_for_bounds_expansion(&self) -> &f32;
    fn min_speed_for_bounds_expansion_mut(&mut self) -> &mut f32;
    fn allow_movement_inside_bounds(&self) -> &bool;
    fn allow_movement_inside_bounds_mut(&mut self) -> &mut bool;
}

impl AIBlockerEntityDataTrait for AIBlockerEntityData {
    fn realm(&self) -> &super::core::Realm {
        &self.realm
    }
    fn realm_mut(&mut self) -> &mut super::core::Realm {
        &mut self.realm
    }
    fn enable_on_init(&self) -> &bool {
        &self.enable_on_init
    }
    fn enable_on_init_mut(&mut self) -> &mut bool {
        &mut self.enable_on_init
    }
    fn slow_distance(&self) -> &f32 {
        &self.slow_distance
    }
    fn slow_distance_mut(&mut self) -> &mut f32 {
        &mut self.slow_distance
    }
    fn stop_distance(&self) -> &f32 {
        &self.stop_distance
    }
    fn stop_distance_mut(&mut self) -> &mut f32 {
        &mut self.stop_distance
    }
    fn bounds_expansion(&self) -> &super::core::Vec3 {
        &self.bounds_expansion
    }
    fn bounds_expansion_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.bounds_expansion
    }
    fn min_speed_for_bounds_expansion(&self) -> &f32 {
        &self.min_speed_for_bounds_expansion
    }
    fn min_speed_for_bounds_expansion_mut(&mut self) -> &mut f32 {
        &mut self.min_speed_for_bounds_expansion
    }
    fn allow_movement_inside_bounds(&self) -> &bool {
        &self.allow_movement_inside_bounds
    }
    fn allow_movement_inside_bounds_mut(&mut self) -> &mut bool {
        &mut self.allow_movement_inside_bounds
    }
}

impl super::entity::EntityDataTrait for AIBlockerEntityData {
}

impl super::entity::GameObjectDataTrait for AIBlockerEntityData {
}

impl super::core::DataBusPeerTrait for AIBlockerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIBlockerEntityData {
}

impl super::core::DataContainerTrait for AIBlockerEntityData {
}

pub static AIBLOCKERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBlockerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIBlockerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: "Realm",
                rust_offset: offset_of!(AIBlockerEntityData, realm),
            },
            FieldInfoData {
                name: "EnableOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIBlockerEntityData, enable_on_init),
            },
            FieldInfoData {
                name: "SlowDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBlockerEntityData, slow_distance),
            },
            FieldInfoData {
                name: "StopDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBlockerEntityData, stop_distance),
            },
            FieldInfoData {
                name: "BoundsExpansion",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AIBlockerEntityData, bounds_expansion),
            },
            FieldInfoData {
                name: "MinSpeedForBoundsExpansion",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AIBlockerEntityData, min_speed_for_bounds_expansion),
            },
            FieldInfoData {
                name: "AllowMovementInsideBounds",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AIBlockerEntityData, allow_movement_inside_bounds),
            },
        ],
    }),
    array_type: Some(AIBLOCKERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIBlockerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        AIBLOCKERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIBLOCKERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBlockerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIBlockerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AIAnchorToPointComponentData {
    pub _glacier_base: super::entity::GameComponentData,
    pub anchor_to_point_binding: AnchorToPointBinding,
    pub target_position: super::core::Vec3,
}

pub trait AIAnchorToPointComponentDataTrait: super::entity::GameComponentDataTrait {
    fn anchor_to_point_binding(&self) -> &AnchorToPointBinding;
    fn anchor_to_point_binding_mut(&mut self) -> &mut AnchorToPointBinding;
    fn target_position(&self) -> &super::core::Vec3;
    fn target_position_mut(&mut self) -> &mut super::core::Vec3;
}

impl AIAnchorToPointComponentDataTrait for AIAnchorToPointComponentData {
    fn anchor_to_point_binding(&self) -> &AnchorToPointBinding {
        &self.anchor_to_point_binding
    }
    fn anchor_to_point_binding_mut(&mut self) -> &mut AnchorToPointBinding {
        &mut self.anchor_to_point_binding
    }
    fn target_position(&self) -> &super::core::Vec3 {
        &self.target_position
    }
    fn target_position_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.target_position
    }
}

impl super::entity::GameComponentDataTrait for AIAnchorToPointComponentData {
}

impl super::entity::ComponentDataTrait for AIAnchorToPointComponentData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn client_index(&self) -> &u8 {
        self._glacier_base.client_index()
    }
    fn client_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.client_index_mut()
    }
    fn server_index(&self) -> &u8 {
        self._glacier_base.server_index()
    }
    fn server_index_mut(&mut self) -> &mut u8 {
        self._glacier_base.server_index_mut()
    }
    fn excluded(&self) -> &bool {
        self._glacier_base.excluded()
    }
    fn excluded_mut(&mut self) -> &mut bool {
        self._glacier_base.excluded_mut()
    }
}

impl super::entity::GameObjectDataTrait for AIAnchorToPointComponentData {
}

impl super::core::DataBusPeerTrait for AIAnchorToPointComponentData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for AIAnchorToPointComponentData {
}

impl super::core::DataContainerTrait for AIAnchorToPointComponentData {
}

pub static AIANCHORTOPOINTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAnchorToPointComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::GAMECOMPONENTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AIAnchorToPointComponentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AnchorToPointBinding",
                flags: MemberInfoFlags::new(0),
                field_type: "AnchorToPointBinding",
                rust_offset: offset_of!(AIAnchorToPointComponentData, anchor_to_point_binding),
            },
            FieldInfoData {
                name: "TargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(AIAnchorToPointComponentData, target_position),
            },
        ],
    }),
    array_type: Some(AIANCHORTOPOINTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIAnchorToPointComponentData {
    fn type_info(&self) -> &'static TypeInfo {
        AIANCHORTOPOINTCOMPONENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIANCHORTOPOINTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAnchorToPointComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIAnchorToPointComponentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AIAnchorStateTransition {
    #[default]
    AIAnchorStateTransition_None = 0,
    AIAnchorStateTransition_Anchoring = 1,
    AIAnchorStateTransition_Anchored = 2,
    AIAnchorStateTransition_Unanchoring = 3,
    AIAnchorStateTransition_Count = 4,
}

pub static AIANCHORSTATETRANSITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAnchorStateTransition",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIANCHORSTATETRANSITION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIAnchorStateTransition {
    fn type_info(&self) -> &'static TypeInfo {
        AIANCHORSTATETRANSITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AIANCHORSTATETRANSITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAnchorStateTransition-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIAnchorStateTransition"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AnchorToPointBinding {
    pub anchor_to_point: super::ant::AntRef,
    pub skip_anchoring: super::ant::AntRef,
    pub is_anchored: super::ant::AntRef,
    pub is_anchor_active: super::ant::AntRef,
    pub anchor_aim_yaw: super::ant::AntRef,
    pub anchor_aim_pitch: super::ant::AntRef,
}

pub trait AnchorToPointBindingTrait: TypeObject {
    fn anchor_to_point(&self) -> &super::ant::AntRef;
    fn anchor_to_point_mut(&mut self) -> &mut super::ant::AntRef;
    fn skip_anchoring(&self) -> &super::ant::AntRef;
    fn skip_anchoring_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_anchored(&self) -> &super::ant::AntRef;
    fn is_anchored_mut(&mut self) -> &mut super::ant::AntRef;
    fn is_anchor_active(&self) -> &super::ant::AntRef;
    fn is_anchor_active_mut(&mut self) -> &mut super::ant::AntRef;
    fn anchor_aim_yaw(&self) -> &super::ant::AntRef;
    fn anchor_aim_yaw_mut(&mut self) -> &mut super::ant::AntRef;
    fn anchor_aim_pitch(&self) -> &super::ant::AntRef;
    fn anchor_aim_pitch_mut(&mut self) -> &mut super::ant::AntRef;
}

impl AnchorToPointBindingTrait for AnchorToPointBinding {
    fn anchor_to_point(&self) -> &super::ant::AntRef {
        &self.anchor_to_point
    }
    fn anchor_to_point_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.anchor_to_point
    }
    fn skip_anchoring(&self) -> &super::ant::AntRef {
        &self.skip_anchoring
    }
    fn skip_anchoring_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.skip_anchoring
    }
    fn is_anchored(&self) -> &super::ant::AntRef {
        &self.is_anchored
    }
    fn is_anchored_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_anchored
    }
    fn is_anchor_active(&self) -> &super::ant::AntRef {
        &self.is_anchor_active
    }
    fn is_anchor_active_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.is_anchor_active
    }
    fn anchor_aim_yaw(&self) -> &super::ant::AntRef {
        &self.anchor_aim_yaw
    }
    fn anchor_aim_yaw_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.anchor_aim_yaw
    }
    fn anchor_aim_pitch(&self) -> &super::ant::AntRef {
        &self.anchor_aim_pitch
    }
    fn anchor_aim_pitch_mut(&mut self) -> &mut super::ant::AntRef {
        &mut self.anchor_aim_pitch
    }
}

pub static ANCHORTOPOINTBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnchorToPointBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AnchorToPointBinding as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AnchorToPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnchorToPointBinding, anchor_to_point),
            },
            FieldInfoData {
                name: "SkipAnchoring",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnchorToPointBinding, skip_anchoring),
            },
            FieldInfoData {
                name: "IsAnchored",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnchorToPointBinding, is_anchored),
            },
            FieldInfoData {
                name: "IsAnchorActive",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnchorToPointBinding, is_anchor_active),
            },
            FieldInfoData {
                name: "AnchorAimYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnchorToPointBinding, anchor_aim_yaw),
            },
            FieldInfoData {
                name: "AnchorAimPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AntRef",
                rust_offset: offset_of!(AnchorToPointBinding, anchor_aim_pitch),
            },
        ],
    }),
    array_type: Some(ANCHORTOPOINTBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AnchorToPointBinding {
    fn type_info(&self) -> &'static TypeInfo {
        ANCHORTOPOINTBINDING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANCHORTOPOINTBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnchorToPointBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AnchorToPointBinding"),
    array_type: None,
    alignment: 8,
};


