use std::mem::offset_of;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData, TypeObject,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_battle_a_i_shared_types(registry: &mut TypeRegistry) {
    registry.register_type(AISOUNDENTITYDATA_TYPE_INFO);
    registry.register_type(AISOUNDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISOUNDDEFAULTS_TYPE_INFO);
    registry.register_type(AISOUNDDEFAULTS_ARRAY_TYPE_INFO);
    registry.register_type(AISOUND_TYPE_INFO);
    registry.register_type(AISOUND_ARRAY_TYPE_INFO);
    registry.register_type(AISOUNDTYPE_TYPE_INFO);
    registry.register_type(AISOUNDTYPE_ARRAY_TYPE_INFO);
    registry.register_type(AISOLDIERSPAWNTEMPLATEDATA_TYPE_INFO);
    registry.register_type(AISOLDIERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERMELEETYPE_TYPE_INFO);
    registry.register_type(SOLDIERMELEETYPE_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSLOCOSETTINGS_TYPE_INFO);
    registry.register_type(PHYSICSLOCOSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(TRACKTARGETSETTINGS_TYPE_INFO);
    registry.register_type(TRACKTARGETSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SOLDIERTACTICS_TYPE_INFO);
    registry.register_type(SOLDIERTACTICS_ARRAY_TYPE_INFO);
    registry.register_type(SECONDARYTHREATSETTINGS_TYPE_INFO);
    registry.register_type(SECONDARYTHREATSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESUPPRESSIONSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLESUPPRESSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONSUPPRESSIONSETTINGS_TYPE_INFO);
    registry.register_type(WEAPONSUPPRESSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(PICKWEAPONSETTINGS_TYPE_INFO);
    registry.register_type(PICKWEAPONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SLOTRANGE_TYPE_INFO);
    registry.register_type(SLOTRANGE_ARRAY_TYPE_INFO);
    registry.register_type(STEALTHSTATETYPE_TYPE_INFO);
    registry.register_type(STEALTHSTATETYPE_ARRAY_TYPE_INFO);
    registry.register_type(ENGAGESETTINGS_TYPE_INFO);
    registry.register_type(ENGAGESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SQUADENGAGESETTINGS_TYPE_INFO);
    registry.register_type(SQUADENGAGESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SQUADMOVEMENTSETTINGS_TYPE_INFO);
    registry.register_type(SQUADMOVEMENTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CLOSECOMBATSETTINGS_TYPE_INFO);
    registry.register_type(CLOSECOMBATSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(GOTOATTACKPOINTSETTINGS_TYPE_INFO);
    registry.register_type(GOTOATTACKPOINTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(EVADEBEHAVIORSETTINGS_TYPE_INFO);
    registry.register_type(EVADEBEHAVIORSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FLEESETTINGS_TYPE_INFO);
    registry.register_type(FLEESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FLEECOVERREQUESTSETTINGS_TYPE_INFO);
    registry.register_type(FLEECOVERREQUESTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(HIDESETTINGS_TYPE_INFO);
    registry.register_type(HIDESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(GOTOTARGETSETTINGS_TYPE_INFO);
    registry.register_type(GOTOTARGETSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWSETTINGS_TYPE_INFO);
    registry.register_type(FOLLOWSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWSTEALTHAVOIDANCESETTINGS_TYPE_INFO);
    registry.register_type(FOLLOWSTEALTHAVOIDANCESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWCOVERSETTINGS_TYPE_INFO);
    registry.register_type(FOLLOWCOVERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWMOVESETTINGS_TYPE_INFO);
    registry.register_type(FOLLOWMOVESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWPOSEPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWPOSEPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWSPEEDCONTROLPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWSPEEDCONTROLPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWMOVESPEEDSELECTIONPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWMOVESPEEDSELECTIONPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWREPATHPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWREPATHPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(ATTACKSETTINGS_TYPE_INFO);
    registry.register_type(ATTACKSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(ATTACKCOVERREQUESTSETTINGS_TYPE_INFO);
    registry.register_type(ATTACKCOVERREQUESTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_TYPE_INFO);
    registry.register_type(ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(EXECUTEACTIONSETTINGS_TYPE_INFO);
    registry.register_type(EXECUTEACTIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGS_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CLOSERANGEATTACKSETTINGS_TYPE_INFO);
    registry.register_type(CLOSERANGEATTACKSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(MELEECHARGESETTINGS_TYPE_INFO);
    registry.register_type(MELEECHARGESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICMELEECHARGETOKENSSETTINGS_TYPE_INFO);
    registry.register_type(DYNAMICMELEECHARGETOKENSSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(BERSERKSETTINGS_TYPE_INFO);
    registry.register_type(BERSERKSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(CHARGESETTINGS_TYPE_INFO);
    registry.register_type(CHARGESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLESETTINGS_TYPE_INFO);
    registry.register_type(VEHICLESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(AIMELEESETTINGS_TYPE_INFO);
    registry.register_type(AIMELEESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(PROJECTILESETTINGS_TYPE_INFO);
    registry.register_type(PROJECTILESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(POSESETTINGS_TYPE_INFO);
    registry.register_type(POSESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COVERCONTROLSETTINGS_TYPE_INFO);
    registry.register_type(COVERCONTROLSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COVERHOVERDATA_TYPE_INFO);
    registry.register_type(COVERHOVERDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERSIDESTEPDATA_TYPE_INFO);
    registry.register_type(COVERSIDESTEPDATA_ARRAY_TYPE_INFO);
    registry.register_type(CHECKTARGETINVEHICLE_TYPE_INFO);
    registry.register_type(CHECKTARGETINVEHICLE_ARRAY_TYPE_INFO);
    registry.register_type(AISPAWNDATA_TYPE_INFO);
    registry.register_type(AISPAWNDATA_ARRAY_TYPE_INFO);
    registry.register_type(TACTICS_TYPE_INFO);
    registry.register_type(TACTICS_ARRAY_TYPE_INFO);
    registry.register_type(AIRTARGETSELECTORENTITYDATA_TYPE_INFO);
    registry.register_type(AIRTARGETSELECTORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIREADINESSLEVEL_TYPE_INFO);
    registry.register_type(AIREADINESSLEVEL_ARRAY_TYPE_INFO);
    registry.register_type(AIRCOLLISIONAVOIDANCEENTITYDATA_TYPE_INFO);
    registry.register_type(AIRCOLLISIONAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPROXIMITYAIMINGSTATE_TYPE_INFO);
    registry.register_type(AIPROXIMITYAIMINGSTATE_ARRAY_TYPE_INFO);
    registry.register_type(AIPROXIMITYREACTIONSCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIPROXIMITYREACTIONSCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOOKATHUMAN_TYPE_INFO);
    registry.register_type(LOOKATHUMAN_ARRAY_TYPE_INFO);
    registry.register_type(AIPROXIMITYREACTIONSBINDING_TYPE_INFO);
    registry.register_type(AIPROXIMITYREACTIONSBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIALTFIREFROMANTSTATE_TYPE_INFO);
    registry.register_type(AIALTFIREFROMANTSTATE_ARRAY_TYPE_INFO);
    registry.register_type(AISTUNREACTIONANIMATIONTYPE_TYPE_INFO);
    registry.register_type(AISTUNREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(AIPROJECTILECOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIPROJECTILECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILEBINDING_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILEBINDING_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILE_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILE_ARRAY_TYPE_INFO);
    registry.register_type(DISPERSION_TYPE_INFO);
    registry.register_type(DISPERSION_ARRAY_TYPE_INFO);
    registry.register_type(GRENADETOKENTYPE_TYPE_INFO);
    registry.register_type(GRENADETOKENTYPE_ARRAY_TYPE_INFO);
    registry.register_type(GRENADETIMERTYPE_TYPE_INFO);
    registry.register_type(GRENADETIMERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(LINEARTIME_TYPE_INFO);
    registry.register_type(LINEARTIME_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILECURVETYPE_TYPE_INFO);
    registry.register_type(BATTLEAIPROJECTILECURVETYPE_ARRAY_TYPE_INFO);
    registry.register_type(AIPHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO);
    registry.register_type(AIPHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISHAREDBINDING_TYPE_INFO);
    registry.register_type(AISHAREDBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIPHYSICSDRIVENANIMATIONBINDING_TYPE_INFO);
    registry.register_type(AIPHYSICSDRIVENANIMATIONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENCOVERSTATE_TYPE_INFO);
    registry.register_type(PHYSICSDRIVENCOVERSTATE_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKUSAGETYPE_TYPE_INFO);
    registry.register_type(AIPATHLINKUSAGETYPE_ARRAY_TYPE_INFO);
    registry.register_type(AINAVOBSTACLEPENALTY_TYPE_INFO);
    registry.register_type(AINAVOBSTACLEPENALTY_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHFINDINGLAYER_TYPE_INFO);
    registry.register_type(AIPATHFINDINGLAYER_ARRAY_TYPE_INFO);
    registry.register_type(AISELFDESTRUCTENTITYDATA_TYPE_INFO);
    registry.register_type(AISELFDESTRUCTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOVERQUERYENTITYDATA_TYPE_INFO);
    registry.register_type(AICOVERQUERYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CLOAKINGMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(CLOAKINGMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISOUNDAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AISOUNDAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOMBATGROUPENTITYDATA_TYPE_INFO);
    registry.register_type(AICOMBATGROUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMBATCOVERMOVEMENTSETTINGS_TYPE_INFO);
    registry.register_type(COMBATCOVERMOVEMENTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COMBATPROPAGATIONSETTINGS_TYPE_INFO);
    registry.register_type(COMBATPROPAGATIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(AITACTICENTITYDATA_TYPE_INFO);
    registry.register_type(AITACTICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISHOOTATTARGETSENTITYDATA_TYPE_INFO);
    registry.register_type(AISHOOTATTARGETSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPOINTTARGETDATA_TYPE_INFO);
    registry.register_type(AIPOINTTARGETDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIUSEWAYPOINTSENTITYDATA_TYPE_INFO);
    registry.register_type(AIUSEWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIUSECOVERENTITYDATA_TYPE_INFO);
    registry.register_type(AIUSECOVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOVERZONESOVERRIDEENTITYDATA_TYPE_INFO);
    registry.register_type(AICOVERZONESOVERRIDEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIAWARENESSENTITYDATA_TYPE_INFO);
    registry.register_type(AIAWARENESSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIWEAPONSLOTOVERRIDEENTITYDATA_TYPE_INFO);
    registry.register_type(AIWEAPONSLOTOVERRIDEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIWEAPONOVERRIDEENTITYDATA_TYPE_INFO);
    registry.register_type(AIWEAPONOVERRIDEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLEBEHAVIORENTITYDATA_TYPE_INFO);
    registry.register_type(AIVEHICLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AITARGETINGENTITYDATA_TYPE_INFO);
    registry.register_type(AITARGETINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOMBATBEHAVIORENTITYDATA_TYPE_INFO);
    registry.register_type(AICOMBATBEHAVIORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFORBIDDENAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIFORBIDDENAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFRIENDLYAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIFRIENDLYAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFLANKINGCORRIDORENTITYDATA_TYPE_INFO);
    registry.register_type(AIFLANKINGCORRIDORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISEARCHAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AISEARCHAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIDEFENDAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIDEFENDAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AITARGETCOORDINATORFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(AITARGETCOORDINATORFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(TARGETCOORDINATORFILTER_TYPE_INFO);
    registry.register_type(TARGETCOORDINATORFILTER_ARRAY_TYPE_INFO);
    registry.register_type(TARGETCOORDINATORFILTERACTION_TYPE_INFO);
    registry.register_type(TARGETCOORDINATORFILTERACTION_ARRAY_TYPE_INFO);
    registry.register_type(AITARGETCOORDINATORENTITYDATA_TYPE_INFO);
    registry.register_type(AITARGETCOORDINATORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISTEALTHENTITYDATA_TYPE_INFO);
    registry.register_type(AISTEALTHENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIBUDDYFOLLOWENTITYDATA_TYPE_INFO);
    registry.register_type(AIBUDDYFOLLOWENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWPREFERREDSLOTARC_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWPREFERREDSLOTARC_ARRAY_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWSLOTSCORINGDATA_TYPE_INFO);
    registry.register_type(BUDDYFOLLOWSLOTSCORINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTENTITYDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTCONFIGASSET_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTCONFIGASSET_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTMOVEPARAMS_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTMOVEPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTSLOTCONFIG_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTSLOTCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTPREFERREDSLOTARC_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTPREFERREDSLOTARC_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTSLOTSCORINGDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWOBJECTSLOTSCORINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPREFERREDAREAENTITYDATA_TYPE_INFO);
    registry.register_type(AIPREFERREDAREAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIHEARINGPARAMETERENTITYDATA_TYPE_INFO);
    registry.register_type(AIHEARINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISENSINGPARAMETERENTITYDATA_TYPE_INFO);
    registry.register_type(AISENSINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIIDLEBEHAVIORENTITYDATA_TYPE_INFO);
    registry.register_type(AIIDLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO);
    registry.register_type(AIPARAMETERWITHSHAPEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPARAMETERENTITYDATA_TYPE_INFO);
    registry.register_type(AIPARAMETERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICANCELORDERENTITYDATA_TYPE_INFO);
    registry.register_type(AICANCELORDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIGOTOPLACEORDERENTITYDATA_TYPE_INFO);
    registry.register_type(AIGOTOPLACEORDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFOLLOWWAYPOINTSORDERENTITYDATA_TYPE_INFO);
    registry.register_type(AIFOLLOWWAYPOINTSORDERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIORDERENTITYBASEDATA_TYPE_INFO);
    registry.register_type(AIORDERENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TACTICSENUMERATION_TYPE_INFO);
    registry.register_type(TACTICSENUMERATION_ARRAY_TYPE_INFO);
    registry.register_type(AICOMBATINTENSITY_TYPE_INFO);
    registry.register_type(AICOMBATINTENSITY_ARRAY_TYPE_INFO);
    registry.register_type(EXECUTIONPRIORITY_TYPE_INFO);
    registry.register_type(EXECUTIONPRIORITY_ARRAY_TYPE_INFO);
    registry.register_type(AISHOOTTYPE_TYPE_INFO);
    registry.register_type(AISHOOTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(IDLEREADINESS_TYPE_INFO);
    registry.register_type(IDLEREADINESS_ARRAY_TYPE_INFO);
    registry.register_type(AIORDERCOORDINATORCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIORDERCOORDINATORCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MEMBERACTION_TYPE_INFO);
    registry.register_type(MEMBERACTION_ARRAY_TYPE_INFO);
    registry.register_type(LEADERACTION_TYPE_INFO);
    registry.register_type(LEADERACTION_ARRAY_TYPE_INFO);
    registry.register_type(LEADERACTIONBINDING_TYPE_INFO);
    registry.register_type(LEADERACTIONBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIOBSTACLECONTROLLERENTITYDATA_TYPE_INFO);
    registry.register_type(AIOBSTACLECONTROLLERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAINAVOBSTACLECOMPONENTDATA_TYPE_INFO);
    registry.register_type(BATTLEAINAVOBSTACLECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIMELEECOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIMELEECOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AITELEPORTENTITYDATA_TYPE_INFO);
    registry.register_type(AITELEPORTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAYPOINTSWALKERENTITYDATA_TYPE_INFO);
    registry.register_type(WAYPOINTSWALKERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFIREPATTERNENTITYDATA_TYPE_INFO);
    registry.register_type(AIFIREPATTERNENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEFIREPATTERNDATA_TYPE_INFO);
    registry.register_type(SIMPLEFIREPATTERNDATA_ARRAY_TYPE_INFO);
    registry.register_type(AITEMPLATEFILTERENTITYDATA_TYPE_INFO);
    registry.register_type(AITEMPLATEFILTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(POINTOFINTERESTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(POINTOFINTERESTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLAYERVEHICLEPROXIMITYENTITYDATA_TYPE_INFO);
    registry.register_type(PLAYERVEHICLEPROXIMITYENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(HEAVYPLANEPILOTENTITYDATA_TYPE_INFO);
    registry.register_type(HEAVYPLANEPILOTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PILOTENTITYDATA_TYPE_INFO);
    registry.register_type(PILOTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PILOTENTITYBASEDATA_TYPE_INFO);
    registry.register_type(PILOTENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PATHFINDINGOVERRIDEDATA_TYPE_INFO);
    registry.register_type(PATHFINDINGOVERRIDEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PATHFOLLOWINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(PATHFOLLOWINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWWAYPOINTSENTITYDATA_TYPE_INFO);
    registry.register_type(FOLLOWWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTENTITYDATA_TYPE_INFO);
    registry.register_type(FOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAYPOINTTRIGGERENTITYDATA_TYPE_INFO);
    registry.register_type(WAYPOINTTRIGGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PATHFINDINGSTREAMENTITYDATA_TYPE_INFO);
    registry.register_type(PATHFINDINGSTREAMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAIPATHLINKENTITYDATA_TYPE_INFO);
    registry.register_type(BATTLEAIPATHLINKENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANDARDMOVEPATHLINKDATA_TYPE_INFO);
    registry.register_type(STANDARDMOVEPATHLINKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCENARIOPATHLINKDATA_TYPE_INFO);
    registry.register_type(SCENARIOPATHLINKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKDATA_TYPE_INFO);
    registry.register_type(AIPATHLINKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKDIRECTION_TYPE_INFO);
    registry.register_type(AIPATHLINKDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKPENALTY_TYPE_INFO);
    registry.register_type(AIPATHLINKPENALTY_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKTYPE_TYPE_INFO);
    registry.register_type(AIPATHLINKTYPE_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHLINKGEOMETRYTYPE_TYPE_INFO);
    registry.register_type(AIPATHLINKGEOMETRYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MOVESETTINGS_TYPE_INFO);
    registry.register_type(MOVESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(STARTSTOPSETTINGS_TYPE_INFO);
    registry.register_type(STARTSTOPSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(WALKSETTINGS_TYPE_INFO);
    registry.register_type(WALKSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SPRINTSETTINGS_TYPE_INFO);
    registry.register_type(SPRINTSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(POSE_TYPE_INFO);
    registry.register_type(POSE_ARRAY_TYPE_INFO);
    registry.register_type(MOVESPEED_TYPE_INFO);
    registry.register_type(MOVESPEED_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGSOVERRIDEDATA_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGSOVERRIDEDATA_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATEOVERRIDETYPE_TYPE_INFO);
    registry.register_type(INVESTIGATEOVERRIDETYPE_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSCUSTOMIZATIONS_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSCUSTOMIZATIONS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSCUSTOMIZATION_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNS_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_TYPE_INFO);
    registry.register_type(INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATEENDCONDITIONS_TYPE_INFO);
    registry.register_type(INVESTIGATEENDCONDITIONS_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATEENDONAREACLEARED_TYPE_INFO);
    registry.register_type(INVESTIGATEENDONAREACLEARED_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSKNOWLEDGESHARING_TYPE_INFO);
    registry.register_type(INVESTIGATESETTIGNSKNOWLEDGESHARING_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKDATA_TYPE_INFO);
    registry.register_type(GAMETWEAKDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEAMSETTINGS_TYPE_INFO);
    registry.register_type(TEAMSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKBLINDEDBEHAVIOR_TYPE_INFO);
    registry.register_type(GAMETWEAKBLINDEDBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKPANICBEHAVIOR_TYPE_INFO);
    registry.register_type(GAMETWEAKPANICBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKSNIPER_TYPE_INFO);
    registry.register_type(GAMETWEAKSNIPER_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKBUCKETDAMAGE_TYPE_INFO);
    registry.register_type(GAMETWEAKBUCKETDAMAGE_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKAITARGETING_TYPE_INFO);
    registry.register_type(GAMETWEAKAITARGETING_ARRAY_TYPE_INFO);
    registry.register_type(EVASIVEBUCKETTIMESETTINGS_TYPE_INFO);
    registry.register_type(EVASIVEBUCKETTIMESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(ACCURACYPENALTYSETTINGS_TYPE_INFO);
    registry.register_type(ACCURACYPENALTYSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(GAMETWEAKCOMMON_TYPE_INFO);
    registry.register_type(GAMETWEAKCOMMON_ARRAY_TYPE_INFO);
    registry.register_type(CORPSEDATA_TYPE_INFO);
    registry.register_type(CORPSEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TEMPERATUREDATA_TYPE_INFO);
    registry.register_type(TEMPERATUREDATA_ARRAY_TYPE_INFO);
    registry.register_type(INVESTIGATEDATA_TYPE_INFO);
    registry.register_type(INVESTIGATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MELEECHARGEDATA_TYPE_INFO);
    registry.register_type(MELEECHARGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PASSIVITYDATA_TYPE_INFO);
    registry.register_type(PASSIVITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AWAREMODIFIERSETTINGS_TYPE_INFO);
    registry.register_type(AWAREMODIFIERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIER_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIERSETTINGS_TYPE_INFO);
    registry.register_type(SENSINGAREAMODIFIERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREA_TYPE_INFO);
    registry.register_type(SENSINGAREA_ARRAY_TYPE_INFO);
    registry.register_type(SENSINGAREAID_TYPE_INFO);
    registry.register_type(SENSINGAREAID_ARRAY_TYPE_INFO);
    registry.register_type(GRENADETOKENLIST_TYPE_INFO);
    registry.register_type(GRENADETOKENLIST_ARRAY_TYPE_INFO);
    registry.register_type(PIECEWISELINEARCURVE_TYPE_INFO);
    registry.register_type(PIECEWISELINEARCURVE_ARRAY_TYPE_INFO);
    registry.register_type(CURVEPOINT_TYPE_INFO);
    registry.register_type(CURVEPOINT_ARRAY_TYPE_INFO);
    registry.register_type(TINYPIECEWISELINEARCURVE_TYPE_INFO);
    registry.register_type(TINYPIECEWISELINEARCURVE_ARRAY_TYPE_INFO);
    registry.register_type(FIRINGPATTERNCOLLECTIONDATA_TYPE_INFO);
    registry.register_type(FIRINGPATTERNCOLLECTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(FIRINGPATTERNDATA_TYPE_INFO);
    registry.register_type(FIRINGPATTERNDATA_ARRAY_TYPE_INFO);
    registry.register_type(INTENSITYCLASS_TYPE_INFO);
    registry.register_type(INTENSITYCLASS_ARRAY_TYPE_INFO);
    registry.register_type(FIRINGWEAPONCLASS_TYPE_INFO);
    registry.register_type(FIRINGWEAPONCLASS_ARRAY_TYPE_INFO);
    registry.register_type(PROTECTBASEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(PROTECTBASEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(CREATEDISTANCEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(CREATEDISTANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SETWAYPOINTSENTITYDATA_TYPE_INFO);
    registry.register_type(SETWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWWAYPOINTSMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(FOLLOWWAYPOINTSMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLYTOMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(FLYTOMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STALLTURNMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(STALLTURNMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPINDESCENTMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(SPINDESCENTMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIDETOSIDEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(SIDETOSIDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(IMMELMANNMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(IMMELMANNMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BARRELROLLMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(BARRELROLLMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPLITSMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(SPLITSMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASICDEFENSIVEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(BASICDEFENSIVEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(STRAFERUNMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(STRAFERUNMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASICATTACKMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(BASICATTACKMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COLLISIONAVOIDANCEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(COLLISIONAVOIDANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENFORCEALTITUDEMANEUVERENTITYDATA_TYPE_INFO);
    registry.register_type(ENFORCEALTITUDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEFENSIVEMANEUVERSELECTORENTITYDATA_TYPE_INFO);
    registry.register_type(DEFENSIVEMANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MANEUVERSELECTORENTITYDATA_TYPE_INFO);
    registry.register_type(MANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SELECTORTYPE_TYPE_INFO);
    registry.register_type(SELECTORTYPE_ARRAY_TYPE_INFO);
    registry.register_type(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO);
    registry.register_type(DOGFIGHTMANEUVERENTITYBASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WSDOGFIGHTINGENTITYDATA_TYPE_INFO);
    registry.register_type(WSDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(BFDOGFIGHTINGENTITYDATA_TYPE_INFO);
    registry.register_type(BFDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DOGFIGHTINGENTITYDATA_TYPE_INFO);
    registry.register_type(DOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERENTITYDATA_TYPE_INFO);
    registry.register_type(COVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERPREVIEWANIMTYPE_TYPE_INFO);
    registry.register_type(COVERPREVIEWANIMTYPE_ARRAY_TYPE_INFO);
    registry.register_type(COVERSLOT_TYPE_INFO);
    registry.register_type(COVERSLOT_ARRAY_TYPE_INFO);
    registry.register_type(COVERTYPE_TYPE_INFO);
    registry.register_type(COVERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(OLDCOVERQUERYDATA_TYPE_INFO);
    registry.register_type(OLDCOVERQUERYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCOREDATA_TYPE_INFO);
    registry.register_type(COVERQUERYSCOREDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCORERUNTIME_TYPE_INFO);
    registry.register_type(COVERQUERYSCORERUNTIME_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCORERUNTIMEFLAGS_TYPE_INFO);
    registry.register_type(COVERQUERYSCORERUNTIMEFLAGS_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCOREBASE_TYPE_INFO);
    registry.register_type(COVERQUERYSCOREBASE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSCORESECONDARYDATA_TYPE_INFO);
    registry.register_type(COVERQUERYSCORESECONDARYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYDIRECTION_TYPE_INFO);
    registry.register_type(COVERQUERYDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSTYLE_TYPE_INFO);
    registry.register_type(COVERQUERYSTYLE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYCURVEXSOURCE_TYPE_INFO);
    registry.register_type(COVERQUERYCURVEXSOURCE_ARRAY_TYPE_INFO);
    registry.register_type(COVERVALIDATEDATA_TYPE_INFO);
    registry.register_type(COVERVALIDATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERVALIDATIONSCOREDATA_TYPE_INFO);
    registry.register_type(COVERVALIDATIONSCOREDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERVALIDATIONSTATUS_TYPE_INFO);
    registry.register_type(COVERVALIDATIONSTATUS_ARRAY_TYPE_INFO);
    registry.register_type(COVERSELECTDATA_TYPE_INFO);
    registry.register_type(COVERSELECTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERSCOREASSET_TYPE_INFO);
    registry.register_type(COVERSCOREASSET_ARRAY_TYPE_INFO);
    registry.register_type(COVERSCOREEXECUTIONPARAMS_TYPE_INFO);
    registry.register_type(COVERSCOREEXECUTIONPARAMS_ARRAY_TYPE_INFO);
    registry.register_type(COVERPATHSPEC_TYPE_INFO);
    registry.register_type(COVERPATHSPEC_ARRAY_TYPE_INFO);
    registry.register_type(COVERPATHMODE_TYPE_INFO);
    registry.register_type(COVERPATHMODE_ARRAY_TYPE_INFO);
    registry.register_type(COVERSCOREDATABASE_TYPE_INFO);
    registry.register_type(COVERSCOREDATABASE_ARRAY_TYPE_INFO);
    registry.register_type(COVEREXCLUSIONVOLUMESHAPEDATA_TYPE_INFO);
    registry.register_type(COVEREXCLUSIONVOLUMESHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERAUTOGENVOLUMESHAPEDATA_TYPE_INFO);
    registry.register_type(COVERAUTOGENVOLUMESHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICOVERSCOREMODIFIERREMOVEMESSAGE_TYPE_INFO);
    registry.register_type(AICOVERSCOREMODIFIERADDMESSAGE_TYPE_INFO);
    registry.register_type(COVERSCOREMODIFIERENTITYDATA_TYPE_INFO);
    registry.register_type(COVERSCOREMODIFIERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERGROUPENTITYDATA_TYPE_INFO);
    registry.register_type(COVERGROUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERDATA_TYPE_INFO);
    registry.register_type(COVERDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYDATA_TYPE_INFO);
    registry.register_type(COVERQUERYDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPATHENEMYAVOIDANCEDATA_TYPE_INFO);
    registry.register_type(COVERQUERYPATHENEMYAVOIDANCEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_TYPE_INFO);
    registry.register_type(COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPATHAVOIDANCEZONE_TYPE_INFO);
    registry.register_type(COVERQUERYPATHAVOIDANCEZONE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPATHAVOIDANCETYPE_TYPE_INFO);
    registry.register_type(COVERQUERYPATHAVOIDANCETYPE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYFILTER_TYPE_INFO);
    registry.register_type(COVERQUERYFILTER_ARRAY_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYWEAPONRANGE_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYWEAPONRANGE_ARRAY_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYDEFENDAREA_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYDEFENDAREA_ARRAY_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYRADIUS_TYPE_INFO);
    registry.register_type(FILTERCOVERSBYRADIUS_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYSPATIALBASE_TYPE_INFO);
    registry.register_type(COVERQUERYSPATIALBASE_ARRAY_TYPE_INFO);
    registry.register_type(COVERQUERYPOSITION_TYPE_INFO);
    registry.register_type(COVERQUERYPOSITION_ARRAY_TYPE_INFO);
    registry.register_type(COVERCONSTANTDATA_TYPE_INFO);
    registry.register_type(COVERCONSTANTDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROTECTIVECOVERWALLOCCLUSIONSETTINGS_TYPE_INFO);
    registry.register_type(PROTECTIVECOVERWALLOCCLUSIONSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(LEDGEJUMPDOWNPATHLINKCONFIG_TYPE_INFO);
    registry.register_type(LEDGEJUMPDOWNPATHLINKCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(VAULTOVERPATHLINKCONFIG_TYPE_INFO);
    registry.register_type(VAULTOVERPATHLINKCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(COVERZONES_TYPE_INFO);
    registry.register_type(COVERZONES_ARRAY_TYPE_INFO);
    registry.register_type(COVERZONEDEFINITION_TYPE_INFO);
    registry.register_type(COVERZONEDEFINITION_ARRAY_TYPE_INFO);
    registry.register_type(COVERZONE_TYPE_INFO);
    registry.register_type(COVERZONE_ARRAY_TYPE_INFO);
    registry.register_type(AICONCEALMENTVOLUMEENTITYDATA_TYPE_INFO);
    registry.register_type(AICONCEALMENTVOLUMEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIWEAPONDATA_TYPE_INFO);
    registry.register_type(AIWEAPONDATA_ARRAY_TYPE_INFO);
    registry.register_type(TARGETINGDATA_TYPE_INFO);
    registry.register_type(TARGETINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(DISTANCETOAWARECURVEOVERRIDE_TYPE_INFO);
    registry.register_type(DISTANCETOAWARECURVEOVERRIDE_ARRAY_TYPE_INFO);
    registry.register_type(SUPPRESSIONVALUES_TYPE_INFO);
    registry.register_type(SUPPRESSIONVALUES_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONHITPROBABILITY_TYPE_INFO);
    registry.register_type(WEAPONHITPROBABILITY_ARRAY_TYPE_INFO);
    registry.register_type(SPECIALBEHAVIOR_TYPE_INFO);
    registry.register_type(SPECIALBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(PREFERREDRANGE_TYPE_INFO);
    registry.register_type(PREFERREDRANGE_ARRAY_TYPE_INFO);
    registry.register_type(WEAPONRESTRICTIONS_TYPE_INFO);
    registry.register_type(WEAPONRESTRICTIONS_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIEREXTENDED_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIEREXTENDED_ARRAY_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIER_TYPE_INFO);
    registry.register_type(DAMAGEMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(SUPPRESSEDBEHAVIOR_TYPE_INFO);
    registry.register_type(SUPPRESSEDBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEINACCURACYSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLEINACCURACYSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(TARGETMODIFIER_TYPE_INFO);
    registry.register_type(TARGETMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(FLASHLIGHTMODIFIER_TYPE_INFO);
    registry.register_type(FLASHLIGHTMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(HEARINGMODIFIER_TYPE_INFO);
    registry.register_type(HEARINGMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(VISIONMODIFIER_TYPE_INFO);
    registry.register_type(VISIONMODIFIER_ARRAY_TYPE_INFO);
    registry.register_type(EVASIONVOLUME_TYPE_INFO);
    registry.register_type(EVASIONVOLUME_ARRAY_TYPE_INFO);
    registry.register_type(ACCURACYHITBOX_TYPE_INFO);
    registry.register_type(ACCURACYHITBOX_ARRAY_TYPE_INFO);
    registry.register_type(SPRAYPATTERN_TYPE_INFO);
    registry.register_type(SPRAYPATTERN_ARRAY_TYPE_INFO);
    registry.register_type(CREEPINGAIRBARRAGE_TYPE_INFO);
    registry.register_type(CREEPINGAIRBARRAGE_ARRAY_TYPE_INFO);
    registry.register_type(BURSTINTERVALPATTERN_TYPE_INFO);
    registry.register_type(BURSTINTERVALPATTERN_ARRAY_TYPE_INFO);
    registry.register_type(BURSTINTERVAL_TYPE_INFO);
    registry.register_type(BURSTINTERVAL_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGDATA_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSWEEPAREASETTINGS_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSWEEPAREASETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSTATE_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSTATE_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGFIRESTYLE_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGFIRESTYLE_ARRAY_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSWEEPAREASTATE_TYPE_INFO);
    registry.register_type(SUSTAINFIRINGSWEEPAREASTATE_ARRAY_TYPE_INFO);
    registry.register_type(FIRINGINTERVALPATTERN_TYPE_INFO);
    registry.register_type(FIRINGINTERVALPATTERN_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEAIMERSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLEAIMERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(INTERVAL_TYPE_INFO);
    registry.register_type(INTERVAL_ARRAY_TYPE_INFO);
    registry.register_type(VOPRIMARYFIRETYPE_TYPE_INFO);
    registry.register_type(VOPRIMARYFIRETYPE_ARRAY_TYPE_INFO);
    registry.register_type(COMBATENVIRONMENT_TYPE_INFO);
    registry.register_type(COMBATENVIRONMENT_ARRAY_TYPE_INFO);
    registry.register_type(TARGETPREFERENCE_TYPE_INFO);
    registry.register_type(TARGETPREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(VALIDAGAINST_TYPE_INFO);
    registry.register_type(VALIDAGAINST_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLECOMBATENTITYDATA_TYPE_INFO);
    registry.register_type(AIVEHICLECOMBATENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLECOMBATSETTINGS_TYPE_INFO);
    registry.register_type(VEHICLECOMBATSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEVSVEHICLE_TYPE_INFO);
    registry.register_type(VEHICLEVSVEHICLE_ARRAY_TYPE_INFO);
    registry.register_type(VEHICLEVSSOLDIER_TYPE_INFO);
    registry.register_type(VEHICLEVSSOLDIER_ARRAY_TYPE_INFO);
    registry.register_type(EVADESETTINGS_TYPE_INFO);
    registry.register_type(EVADESETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COMBATSETTINGS_TYPE_INFO);
    registry.register_type(COMBATSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(DISTANCES_TYPE_INFO);
    registry.register_type(DISTANCES_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLEAIMINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIVEHICLEAIMINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIVEHICLEAIMINGCONSTRAINTS_TYPE_INFO);
    registry.register_type(AIVEHICLEAIMINGCONSTRAINTS_ARRAY_TYPE_INFO);
    registry.register_type(AISERVERTARGETCOMPONENTTEAMCHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(AISERVERTARGETCOMPONENTDESTROYEDMESSAGE_TYPE_INFO);
    registry.register_type(AISERVERTARGETCOMPONENTSPAWNEDMESSAGE_TYPE_INFO);
    registry.register_type(AITARGETCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AITARGETCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISYSTEMENTITYDATA_TYPE_INFO);
    registry.register_type(AISYSTEMENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIPATHFINDINGREPATHREQUIREDMESSAGE_TYPE_INFO);
    registry.register_type(AIPATHFINDINGPATHFINDERSREGISTEREDMESSAGE_TYPE_INFO);
    registry.register_type(AIPATHFINDINGINITIALIZEDMESSAGE_TYPE_INFO);
    registry.register_type(BATTLEAISETTINGS_TYPE_INFO);
    registry.register_type(BATTLEAISETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(BATTLEAISYSTEMDATA_TYPE_INFO);
    registry.register_type(BATTLEAISYSTEMDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALERTNESSDATA_TYPE_INFO);
    registry.register_type(ALERTNESSDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROJECTILEDATA_TYPE_INFO);
    registry.register_type(PROJECTILEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AREABOOKINGSETTINGS_TYPE_INFO);
    registry.register_type(AREABOOKINGSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SQUADENGAGEDATA_TYPE_INFO);
    registry.register_type(SQUADENGAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SHOOTINGDATA_TYPE_INFO);
    registry.register_type(SHOOTINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISUPPRESSWEAPONFIRINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AISUPPRESSWEAPONFIRINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIGLOBALENGAGESTATE_TYPE_INFO);
    registry.register_type(AIGLOBALENGAGESTATE_ARRAY_TYPE_INFO);
    registry.register_type(AISTATEENTITYDATA_TYPE_INFO);
    registry.register_type(AISTATEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AISUPPRESSIONSTATE_TYPE_INFO);
    registry.register_type(AISUPPRESSIONSTATE_ARRAY_TYPE_INFO);
    registry.register_type(AISPOTTINGPOTENTIALMESSAGE_TYPE_INFO);
    registry.register_type(AISPOTTINGFOUNDMESSAGE_TYPE_INFO);
    registry.register_type(AISPOTTINGCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AISPOTTINGCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOCOMPACTIONSIGNALMESSAGE_TYPE_INFO);
    registry.register_type(AILOCOCOMPEXITANIMATIONMESSAGE_TYPE_INFO);
    registry.register_type(AILOCOCOMPENTERANIMATIONMESSAGE_TYPE_INFO);
    registry.register_type(AIWAYPOINTSSHAPEDATA_TYPE_INFO);
    registry.register_type(AIWAYPOINTSSHAPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AILOCOCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(STANDARDMOVEWAYPOINTDATA_TYPE_INFO);
    registry.register_type(STANDARDMOVEWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VAULTWAYPOINTDATA_TYPE_INFO);
    registry.register_type(VAULTWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERWAYPOINTDATA_TYPE_INFO);
    registry.register_type(COVERWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCENARIOWAYPOINTDATA_TYPE_INFO);
    registry.register_type(SCENARIOWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO);
    registry.register_type(ABSTRACTLOCOWAYPOINTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCENARIOTASKDATA_TYPE_INFO);
    registry.register_type(SCENARIOTASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOCOVERTASKDATA_TYPE_INFO);
    registry.register_type(AILOCOCOVERTASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVERSIDESTEPFUTUREPOSE_TYPE_INFO);
    registry.register_type(COVERSIDESTEPFUTUREPOSE_ARRAY_TYPE_INFO);
    registry.register_type(COVERSIDESTEPDIRECTION_TYPE_INFO);
    registry.register_type(COVERSIDESTEPDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(COVERHOVERDIRECTION_TYPE_INFO);
    registry.register_type(COVERHOVERDIRECTION_ARRAY_TYPE_INFO);
    registry.register_type(AIEXTRACOVERANIMATIONDATA_TYPE_INFO);
    registry.register_type(AIEXTRACOVERANIMATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(COVEREXITSTYLE_TYPE_INFO);
    registry.register_type(COVEREXITSTYLE_ARRAY_TYPE_INFO);
    registry.register_type(COVERENTERSTRATEGY_TYPE_INFO);
    registry.register_type(COVERENTERSTRATEGY_ARRAY_TYPE_INFO);
    registry.register_type(COVERIDLETYPE_TYPE_INFO);
    registry.register_type(COVERIDLETYPE_ARRAY_TYPE_INFO);
    registry.register_type(COVERPEEKTYPE_TYPE_INFO);
    registry.register_type(COVERPEEKTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ANTCOVERFIRETYPE_TYPE_INFO);
    registry.register_type(ANTCOVERFIRETYPE_ARRAY_TYPE_INFO);
    registry.register_type(COVERFIRETYPE_TYPE_INFO);
    registry.register_type(COVERFIRETYPE_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOBASETASKDATA_TYPE_INFO);
    registry.register_type(AILOCOBASETASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOMOVETASKDATA_TYPE_INFO);
    registry.register_type(AILOCOMOVETASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOVAULTTASKDATA_TYPE_INFO);
    registry.register_type(AILOCOVAULTTASKDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANTSPEEDLEVEL_TYPE_INFO);
    registry.register_type(ANTSPEEDLEVEL_ARRAY_TYPE_INFO);
    registry.register_type(ANTATTENTIONSTATEENUM_TYPE_INFO);
    registry.register_type(ANTATTENTIONSTATEENUM_ARRAY_TYPE_INFO);
    registry.register_type(ANTCOVERENUM_TYPE_INFO);
    registry.register_type(ANTCOVERENUM_ARRAY_TYPE_INFO);
    registry.register_type(ANTPOSEENUM_TYPE_INFO);
    registry.register_type(ANTPOSEENUM_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOCOVERBINDING_TYPE_INFO);
    registry.register_type(AILOCOCOVERBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOVAULTBINDING_TYPE_INFO);
    registry.register_type(AILOCOVAULTBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AILOCOBINDING_TYPE_INFO);
    registry.register_type(AILOCOBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIKILLCOUNTERENTITYDATA_TYPE_INFO);
    registry.register_type(AIKILLCOUNTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIENTRYCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIENTRYCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIENCOUNTERMANAGERENTITYDATA_TYPE_INFO);
    registry.register_type(AIENCOUNTERMANAGERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENCOUNTERCONFIG_TYPE_INFO);
    registry.register_type(ENCOUNTERCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(ENCOUNTERZONECONFIG_TYPE_INFO);
    registry.register_type(ENCOUNTERZONECONFIG_ARRAY_TYPE_INFO);
    registry.register_type(SERVERENCOUNTERMANAGERREMOVEDMESSAGE_TYPE_INFO);
    registry.register_type(AIDYNAMICCONCEALMENTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIDYNAMICCONCEALMENTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICCONCEALMENTCONDITION_TYPE_INFO);
    registry.register_type(DYNAMICCONCEALMENTCONDITION_ARRAY_TYPE_INFO);
    registry.register_type(DYNAMICCONCEALMENTORIGIN_TYPE_INFO);
    registry.register_type(DYNAMICCONCEALMENTORIGIN_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERCOMPONENTDATA_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERCHANNELDATA_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERCHANNELDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERBINDING_TYPE_INFO);
    registry.register_type(SIMPLEDRIVERBINDING_ARRAY_TYPE_INFO);
    registry.register_type(AIDEBUGPROXYDATA_TYPE_INFO);
    registry.register_type(AIDEBUGPROXYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AICUSTOMINPUTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AICUSTOMINPUTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIINPUTACTION_TYPE_INFO);
    registry.register_type(AIINPUTACTION_ARRAY_TYPE_INFO);
    registry.register_type(TARGETCOORDINATIONGLOBALSETTINGS_TYPE_INFO);
    registry.register_type(TARGETCOORDINATIONGLOBALSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(AICOLLISIONAVOIDANCESETUPENTITYDATA_TYPE_INFO);
    registry.register_type(AICOLLISIONAVOIDANCESETUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIBUCKETSYSTEMCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIBUCKETSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIBLOCKERENTITYDATA_TYPE_INFO);
    registry.register_type(AIBLOCKERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIANCHORTOPOINTCOMPONENTDATA_TYPE_INFO);
    registry.register_type(AIANCHORTOPOINTCOMPONENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIANCHORSTATETRANSITION_TYPE_INFO);
    registry.register_type(AIANCHORSTATETRANSITION_ARRAY_TYPE_INFO);
    registry.register_type(ANCHORTOPOINTBINDING_TYPE_INFO);
    registry.register_type(ANCHORTOPOINTBINDING_ARRAY_TYPE_INFO);
}

#[derive(Clone, PartialEq, Debug)]
pub struct AISoundEntityData {
    pub sound_params: AISound,
    pub send_once: bool,
}

pub const AISOUNDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SoundParams",
                flags: MemberInfoFlags::new(0),
                field_type: AISOUND_TYPE_INFO,
                rust_offset: offset_of!(AISoundEntityData, sound_params),
            },
            FieldInfoData {
                name: "SendOnce",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AISoundEntityData, send_once),
            },
        ],
    }),
    array_type: Some(AISOUNDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AISoundEntityData {
    fn type_info() -> &'static TypeInfo {
        AISOUNDENTITYDATA_TYPE_INFO
    }
}


pub const AISOUNDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoundEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AISoundDefaults {
    pub sounds: Vec<AISound>,
}

pub const AISOUNDDEFAULTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundDefaults",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Sounds",
                flags: MemberInfoFlags::new(144),
                field_type: AISOUND_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AISoundDefaults, sounds),
            },
        ],
    }),
    array_type: Some(AISOUNDDEFAULTS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISoundDefaults {
    fn type_info() -> &'static TypeInfo {
        AISOUNDDEFAULTS_TYPE_INFO
    }
}


pub const AISOUNDDEFAULTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundDefaults-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoundDefaults-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AISound {
    pub sound_type: AISoundType,
    pub radius: f32,
    pub occlusion_radius: f32,
    pub occlusion_factor: f32,
    pub temperature: u8,
    pub priority: u8,
    pub volume: u8,
    pub max_investigators: u8,
    pub temperature_distance: super::core::FloatCurve,
}

pub const AISOUND_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISound",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SoundType",
                flags: MemberInfoFlags::new(0),
                field_type: AISOUNDTYPE_TYPE_INFO,
                rust_offset: offset_of!(AISound, sound_type),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISound, radius),
            },
            FieldInfoData {
                name: "OcclusionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISound, occlusion_radius),
            },
            FieldInfoData {
                name: "OcclusionFactor",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISound, occlusion_factor),
            },
            FieldInfoData {
                name: "Temperature",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(AISound, temperature),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(AISound, priority),
            },
            FieldInfoData {
                name: "Volume",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(AISound, volume),
            },
            FieldInfoData {
                name: "MaxInvestigators",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(AISound, max_investigators),
            },
            FieldInfoData {
                name: "TemperatureDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(AISound, temperature_distance),
            },
        ],
    }),
    array_type: Some(AISOUND_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISound {
    fn type_info() -> &'static TypeInfo {
        AISOUND_TYPE_INFO
    }
}


pub const AISOUND_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISound-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISound-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AISoundType {
    #[default]
    AISoundType_Invalid = 0,
    AISoundType_None = 1,
    AISoundType_Gunshot = 2,
    AISoundType_Impact = 3,
    AISoundType_Background = 4,
    AISoundType_Distraction = 5,
    AISoundType_Pain = 6,
    AISoundType_Death = 7,
    AISoundType_Footstep = 8,
    AISoundType_Body = 9,
    AISoundType_FallImpact = 10,
    AISoundType_Explosion = 11,
    AISoundType_BrokenByShot = 12,
    AISoundType_FootstepQuiet = 13,
    AISoundType_Search = 14,
    AISoundType_Vehicle = 15,
    AISoundType_GunshotSilenced = 16,
    AISoundType_Noise = 17,
    AISoundType_VehicleQuiet = 18,
    AISoundType_Broadcast_Searching = 19,
    AISoundType_Broadcast_Alerted = 20,
    AISoundType_MaxTypes = 21,
}

pub const AISOUNDTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AISOUNDTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AISoundType {
    fn type_info() -> &'static TypeInfo {
        AISOUNDTYPE_TYPE_INFO
    }
}


pub const AISOUNDTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoundType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AISoldierSpawnTemplateData {
    pub tactics: SoldierTactics,
    pub projectile: super::gameplay_sim::AntEnumeration,
    pub melee: super::gameplay_sim::AntEnumeration,
    pub soldier_melee_type: SoldierMeleeType,
    pub allow_hover_from_cover: bool,
    pub cover_zones_override: CoverZones,
    pub fire_height_offset: f32,
    pub npc_unique_id: i32,
    pub alert_propagation_speed: f32,
    pub allow_a_i_alert_enemy_team: bool,
    pub target_lost_time: f32,
    pub extrapolate_after_l_o_s_lost_time: f32,
    pub allowed_to_be_melee_charge_target: bool,
    pub physics_loco_settings: PhysicsLocoSettings,
    pub character_customization_asset: super::game_shared::CharacterCustomizationAsset,
}

pub const AISOLDIERSPAWNTEMPLATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoldierSpawnTemplateData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHARACTERSPAWNTEMPLATEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Tactics",
                flags: MemberInfoFlags::new(0),
                field_type: SOLDIERTACTICS_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, tactics),
            },
            FieldInfoData {
                name: "Projectile",
                flags: MemberInfoFlags::new(0),
                field_type: ANTENUMERATION_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, projectile),
            },
            FieldInfoData {
                name: "Melee",
                flags: MemberInfoFlags::new(0),
                field_type: ANTENUMERATION_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, melee),
            },
            FieldInfoData {
                name: "SoldierMeleeType",
                flags: MemberInfoFlags::new(0),
                field_type: SOLDIERMELEETYPE_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, soldier_melee_type),
            },
            FieldInfoData {
                name: "AllowHoverFromCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, allow_hover_from_cover),
            },
            FieldInfoData {
                name: "CoverZonesOverride",
                flags: MemberInfoFlags::new(0),
                field_type: COVERZONES_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, cover_zones_override),
            },
            FieldInfoData {
                name: "FireHeightOffset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, fire_height_offset),
            },
            FieldInfoData {
                name: "NpcUniqueId",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, npc_unique_id),
            },
            FieldInfoData {
                name: "AlertPropagationSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, alert_propagation_speed),
            },
            FieldInfoData {
                name: "AllowAIAlertEnemyTeam",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, allow_a_i_alert_enemy_team),
            },
            FieldInfoData {
                name: "TargetLostTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, target_lost_time),
            },
            FieldInfoData {
                name: "ExtrapolateAfterLOSLostTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, extrapolate_after_l_o_s_lost_time),
            },
            FieldInfoData {
                name: "AllowedToBeMeleeChargeTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, allowed_to_be_melee_charge_target),
            },
            FieldInfoData {
                name: "PhysicsLocoSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PHYSICSLOCOSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, physics_loco_settings),
            },
            FieldInfoData {
                name: "CharacterCustomizationAsset",
                flags: MemberInfoFlags::new(0),
                field_type: CHARACTERCUSTOMIZATIONASSET_TYPE_INFO,
                rust_offset: offset_of!(AISoldierSpawnTemplateData, character_customization_asset),
            },
        ],
    }),
    array_type: Some(AISOLDIERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISoldierSpawnTemplateData {
    fn type_info() -> &'static TypeInfo {
        AISOLDIERSPAWNTEMPLATEDATA_TYPE_INFO
    }
}


pub const AISOLDIERSPAWNTEMPLATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoldierSpawnTemplateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoldierSpawnTemplateData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoldierMeleeType {
    #[default]
    SoldierMelee_Normal = 0,
    SoldierMelee_MeleeTrooper = 1,
    SoldierMelee_Creature = 2,
}

pub const SOLDIERMELEETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierMeleeType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SOLDIERMELEETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoldierMeleeType {
    fn type_info() -> &'static TypeInfo {
        SOLDIERMELEETYPE_TYPE_INFO
    }
}


pub const SOLDIERMELEETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierMeleeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SoldierMeleeType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PhysicsLocoSettings {
    pub mass: f32,
    pub walk_speed: f32,
    pub run_speed: f32,
    pub use_directional_run_speed_blending: bool,
    pub strafe_run_speed: f32,
    pub backward_run_speed: f32,
    pub sprint_multiplier: f32,
    pub track_target_settings: TrackTargetSettings,
}

pub const PHYSICSLOCOSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsLocoSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Mass",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PhysicsLocoSettings, mass),
            },
            FieldInfoData {
                name: "WalkSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PhysicsLocoSettings, walk_speed),
            },
            FieldInfoData {
                name: "RunSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PhysicsLocoSettings, run_speed),
            },
            FieldInfoData {
                name: "UseDirectionalRunSpeedBlending",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(PhysicsLocoSettings, use_directional_run_speed_blending),
            },
            FieldInfoData {
                name: "StrafeRunSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PhysicsLocoSettings, strafe_run_speed),
            },
            FieldInfoData {
                name: "BackwardRunSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PhysicsLocoSettings, backward_run_speed),
            },
            FieldInfoData {
                name: "SprintMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PhysicsLocoSettings, sprint_multiplier),
            },
            FieldInfoData {
                name: "TrackTargetSettings",
                flags: MemberInfoFlags::new(0),
                field_type: TRACKTARGETSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(PhysicsLocoSettings, track_target_settings),
            },
        ],
    }),
    array_type: Some(PHYSICSLOCOSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsLocoSettings {
    fn type_info() -> &'static TypeInfo {
        PHYSICSLOCOSETTINGS_TYPE_INFO
    }
}


pub const PHYSICSLOCOSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsLocoSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PhysicsLocoSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct TrackTargetSettings {
    pub require_line_of_sight: bool,
    pub lost_line_of_sight_stop_tracking_time: f32,
    pub start_tracking_distance_to_target: f32,
    pub stop_tracking_distance_to_target: f32,
}

pub const TRACKTARGETSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackTargetSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "RequireLineOfSight",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(TrackTargetSettings, require_line_of_sight),
            },
            FieldInfoData {
                name: "LostLineOfSightStopTrackingTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TrackTargetSettings, lost_line_of_sight_stop_tracking_time),
            },
            FieldInfoData {
                name: "StartTrackingDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TrackTargetSettings, start_tracking_distance_to_target),
            },
            FieldInfoData {
                name: "StopTrackingDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TrackTargetSettings, stop_tracking_distance_to_target),
            },
        ],
    }),
    array_type: Some(TRACKTARGETSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TrackTargetSettings {
    fn type_info() -> &'static TypeInfo {
        TRACKTARGETSETTINGS_TYPE_INFO
    }
}


pub const TRACKTARGETSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TrackTargetSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TrackTargetSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoldierTactics {
    pub vehicle: VehicleSettings,
    pub charge: ChargeSettings,
    pub berserk: BerserkSettings,
    pub melee_charge: MeleeChargeSettings,
    pub close_range_attack: CloseRangeAttackSettings,
    pub investigate: InvestigateSettings,
    pub combat_investigate: InvestigateSettings,
    pub combat_search_area: InvestigateSettings,
    pub search_area: InvestigateSettings,
    pub execute_idle_action: ExecuteActionSettings,
    pub execute_search_action: ExecuteActionSettings,
    pub execute_combat_action: ExecuteActionSettings,
    pub attack: AttackSettings,
    pub hide: HideSettings,
    pub flee: FleeSettings,
    pub evade: EvadeBehaviorSettings,
    pub go_to_attack_point: GoToAttackPointSettings,
    pub close_combat: CloseCombatSettings,
    pub follow: FollowSettings,
    pub go_to_target: GoToTargetSettings,
    pub squad_movement: SquadMovementSettings,
    pub squad_engage_settings: SquadEngageSettings,
    pub engage_settings: EngageSettings,
    pub pick_weapon_settings: PickWeaponSettings,
    pub weapon_suppression_settings: WeaponSuppressionSettings,
    pub vehicle_suppression_settings: VehicleSuppressionSettings,
    pub targeting_settings: TargetingData,
    pub secondary_threats: SecondaryThreatSettings,
}

pub const SOLDIERTACTICS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierTactics",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Vehicle",
                flags: MemberInfoFlags::new(0),
                field_type: VEHICLESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, vehicle),
            },
            FieldInfoData {
                name: "Charge",
                flags: MemberInfoFlags::new(0),
                field_type: CHARGESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, charge),
            },
            FieldInfoData {
                name: "Berserk",
                flags: MemberInfoFlags::new(0),
                field_type: BERSERKSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, berserk),
            },
            FieldInfoData {
                name: "MeleeCharge",
                flags: MemberInfoFlags::new(0),
                field_type: MELEECHARGESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, melee_charge),
            },
            FieldInfoData {
                name: "CloseRangeAttack",
                flags: MemberInfoFlags::new(0),
                field_type: CLOSERANGEATTACKSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, close_range_attack),
            },
            FieldInfoData {
                name: "Investigate",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, investigate),
            },
            FieldInfoData {
                name: "CombatInvestigate",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, combat_investigate),
            },
            FieldInfoData {
                name: "CombatSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, combat_search_area),
            },
            FieldInfoData {
                name: "SearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, search_area),
            },
            FieldInfoData {
                name: "ExecuteIdleAction",
                flags: MemberInfoFlags::new(0),
                field_type: EXECUTEACTIONSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, execute_idle_action),
            },
            FieldInfoData {
                name: "ExecuteSearchAction",
                flags: MemberInfoFlags::new(0),
                field_type: EXECUTEACTIONSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, execute_search_action),
            },
            FieldInfoData {
                name: "ExecuteCombatAction",
                flags: MemberInfoFlags::new(0),
                field_type: EXECUTEACTIONSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, execute_combat_action),
            },
            FieldInfoData {
                name: "Attack",
                flags: MemberInfoFlags::new(0),
                field_type: ATTACKSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, attack),
            },
            FieldInfoData {
                name: "Hide",
                flags: MemberInfoFlags::new(0),
                field_type: HIDESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, hide),
            },
            FieldInfoData {
                name: "Flee",
                flags: MemberInfoFlags::new(0),
                field_type: FLEESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, flee),
            },
            FieldInfoData {
                name: "Evade",
                flags: MemberInfoFlags::new(0),
                field_type: EVADEBEHAVIORSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, evade),
            },
            FieldInfoData {
                name: "GoToAttackPoint",
                flags: MemberInfoFlags::new(0),
                field_type: GOTOATTACKPOINTSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, go_to_attack_point),
            },
            FieldInfoData {
                name: "CloseCombat",
                flags: MemberInfoFlags::new(0),
                field_type: CLOSECOMBATSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, close_combat),
            },
            FieldInfoData {
                name: "Follow",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, follow),
            },
            FieldInfoData {
                name: "GoToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: GOTOTARGETSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, go_to_target),
            },
            FieldInfoData {
                name: "SquadMovement",
                flags: MemberInfoFlags::new(0),
                field_type: SQUADMOVEMENTSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, squad_movement),
            },
            FieldInfoData {
                name: "SquadEngageSettings",
                flags: MemberInfoFlags::new(0),
                field_type: SQUADENGAGESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, squad_engage_settings),
            },
            FieldInfoData {
                name: "EngageSettings",
                flags: MemberInfoFlags::new(0),
                field_type: ENGAGESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, engage_settings),
            },
            FieldInfoData {
                name: "PickWeaponSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PICKWEAPONSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, pick_weapon_settings),
            },
            FieldInfoData {
                name: "WeaponSuppressionSettings",
                flags: MemberInfoFlags::new(0),
                field_type: WEAPONSUPPRESSIONSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, weapon_suppression_settings),
            },
            FieldInfoData {
                name: "VehicleSuppressionSettings",
                flags: MemberInfoFlags::new(0),
                field_type: VEHICLESUPPRESSIONSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, vehicle_suppression_settings),
            },
            FieldInfoData {
                name: "TargetingSettings",
                flags: MemberInfoFlags::new(0),
                field_type: TARGETINGDATA_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, targeting_settings),
            },
            FieldInfoData {
                name: "SecondaryThreats",
                flags: MemberInfoFlags::new(0),
                field_type: SECONDARYTHREATSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SoldierTactics, secondary_threats),
            },
        ],
    }),
    array_type: Some(SOLDIERTACTICS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoldierTactics {
    fn type_info() -> &'static TypeInfo {
        SOLDIERTACTICS_TYPE_INFO
    }
}


pub const SOLDIERTACTICS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoldierTactics-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SoldierTactics-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SecondaryThreatSettings {
    pub max_distance_cover_to_enemy: f32,
    pub max_enemy_to_use_for_scoring: i32,
    pub secondary_enemies_score: CoverQueryScoreData,
}

pub const SECONDARYTHREATSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SecondaryThreatSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MaxDistanceCoverToEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SecondaryThreatSettings, max_distance_cover_to_enemy),
            },
            FieldInfoData {
                name: "MaxEnemyToUseForScoring",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SecondaryThreatSettings, max_enemy_to_use_for_scoring),
            },
            FieldInfoData {
                name: "SecondaryEnemiesScore",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYSCOREDATA_TYPE_INFO,
                rust_offset: offset_of!(SecondaryThreatSettings, secondary_enemies_score),
            },
        ],
    }),
    array_type: Some(SECONDARYTHREATSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SecondaryThreatSettings {
    fn type_info() -> &'static TypeInfo {
        SECONDARYTHREATSETTINGS_TYPE_INFO
    }
}


pub const SECONDARYTHREATSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SecondaryThreatSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SecondaryThreatSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VehicleSuppressionSettings {
    pub suppression_distance: f32,
    pub reevaluate_cover_distance: f32,
}

pub const VEHICLESUPPRESSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSuppressionSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SuppressionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleSuppressionSettings, suppression_distance),
            },
            FieldInfoData {
                name: "ReevaluateCoverDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleSuppressionSettings, reevaluate_cover_distance),
            },
        ],
    }),
    array_type: Some(VEHICLESUPPRESSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleSuppressionSettings {
    fn type_info() -> &'static TypeInfo {
        VEHICLESUPPRESSIONSETTINGS_TYPE_INFO
    }
}


pub const VEHICLESUPPRESSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSuppressionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleSuppressionSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WeaponSuppressionSettings {
    pub suppression_value: f32,
    pub continuous_suppression_time: f32,
    pub suppression_area_size: f32,
}

pub const WEAPONSUPPRESSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSuppressionSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SuppressionValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WeaponSuppressionSettings, suppression_value),
            },
            FieldInfoData {
                name: "ContinuousSuppressionTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WeaponSuppressionSettings, continuous_suppression_time),
            },
            FieldInfoData {
                name: "SuppressionAreaSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WeaponSuppressionSettings, suppression_area_size),
            },
        ],
    }),
    array_type: Some(WEAPONSUPPRESSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for WeaponSuppressionSettings {
    fn type_info() -> &'static TypeInfo {
        WEAPONSUPPRESSIONSETTINGS_TYPE_INFO
    }
}


pub const WEAPONSUPPRESSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponSuppressionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WeaponSuppressionSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PickWeaponSettings {
    pub slots: Vec<SlotRange>,
}

pub const PICKWEAPONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickWeaponSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Slots",
                flags: MemberInfoFlags::new(144),
                field_type: SLOTRANGE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(PickWeaponSettings, slots),
            },
        ],
    }),
    array_type: Some(PICKWEAPONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PickWeaponSettings {
    fn type_info() -> &'static TypeInfo {
        PICKWEAPONSETTINGS_TYPE_INFO
    }
}


pub const PICKWEAPONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PickWeaponSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PickWeaponSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SlotRange {
    pub slot: super::weapon_shared::WeaponSlot,
    pub min_range: f32,
    pub max_range: f32,
    pub only_if_weapon_is_available: bool,
    pub automatic_switch_back: bool,
    pub keep_until_unavailable: bool,
    pub only_when_in_open_cover: bool,
    pub only_when_alerted: bool,
    pub max_friendly_gadgets: i32,
    pub only_if_target_in_vehicle: CheckTargetInVehicle,
    pub stealth_state: StealthStateType,
}

pub const SLOTRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SlotRange",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Slot",
                flags: MemberInfoFlags::new(0),
                field_type: WEAPONSLOT_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, slot),
            },
            FieldInfoData {
                name: "MinRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, min_range),
            },
            FieldInfoData {
                name: "MaxRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, max_range),
            },
            FieldInfoData {
                name: "OnlyIfWeaponIsAvailable",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, only_if_weapon_is_available),
            },
            FieldInfoData {
                name: "AutomaticSwitchBack",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, automatic_switch_back),
            },
            FieldInfoData {
                name: "KeepUntilUnavailable",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, keep_until_unavailable),
            },
            FieldInfoData {
                name: "OnlyWhenInOpenCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, only_when_in_open_cover),
            },
            FieldInfoData {
                name: "OnlyWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, only_when_alerted),
            },
            FieldInfoData {
                name: "MaxFriendlyGadgets",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, max_friendly_gadgets),
            },
            FieldInfoData {
                name: "OnlyIfTargetInVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: CHECKTARGETINVEHICLE_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, only_if_target_in_vehicle),
            },
            FieldInfoData {
                name: "StealthState",
                flags: MemberInfoFlags::new(0),
                field_type: STEALTHSTATETYPE_TYPE_INFO,
                rust_offset: offset_of!(SlotRange, stealth_state),
            },
        ],
    }),
    array_type: Some(SLOTRANGE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SlotRange {
    fn type_info() -> &'static TypeInfo {
        SLOTRANGE_TYPE_INFO
    }
}


pub const SLOTRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SlotRange-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SlotRange-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum StealthStateType {
    #[default]
    StealthState_Any = 0,
    StealthState_InStealth = 1,
    StealthState_NotInStealth = 2,
}

pub const STEALTHSTATETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StealthStateType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(STEALTHSTATETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for StealthStateType {
    fn type_info() -> &'static TypeInfo {
        STEALTHSTATETYPE_TYPE_INFO
    }
}


pub const STEALTHSTATETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StealthStateType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StealthStateType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EngageSettings {
    pub distance_to_target: f32,
    pub suppression_value: f32,
}

pub const ENGAGESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EngageSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "DistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EngageSettings, distance_to_target),
            },
            FieldInfoData {
                name: "SuppressionValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EngageSettings, suppression_value),
            },
        ],
    }),
    array_type: Some(ENGAGESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EngageSettings {
    fn type_info() -> &'static TypeInfo {
        ENGAGESETTINGS_TYPE_INFO
    }
}


pub const ENGAGESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EngageSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EngageSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SquadEngageSettings {
    pub cover_query: CoverQueryData,
    pub move_settings: MoveSettings,
}

pub const SQUADENGAGESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadEngageSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageSettings, cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageSettings, move_settings),
            },
        ],
    }),
    array_type: Some(SQUADENGAGESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SquadEngageSettings {
    fn type_info() -> &'static TypeInfo {
        SQUADENGAGESETTINGS_TYPE_INFO
    }
}


pub const SQUADENGAGESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadEngageSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SquadEngageSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SquadMovementSettings {
    pub idle_cover_query: CoverQueryData,
    pub alerted_cover_query: CoverQueryData,
    pub friendly_area_cover_query: CoverQueryData,
    pub move_settings: MoveSettings,
    pub cover_settings: CoverControlSettings,
    pub max_acceptable_distance_to_human: f32,
    pub max_acceptable_height_difference_to_human: f32,
    pub invalidate_open_cover_if_alerted: bool,
    pub cover_compromised_timer: f32,
}

pub const SQUADMOVEMENTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadMovementSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "IdleCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(SquadMovementSettings, idle_cover_query),
            },
            FieldInfoData {
                name: "AlertedCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(SquadMovementSettings, alerted_cover_query),
            },
            FieldInfoData {
                name: "FriendlyAreaCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(SquadMovementSettings, friendly_area_cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SquadMovementSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COVERCONTROLSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SquadMovementSettings, cover_settings),
            },
            FieldInfoData {
                name: "MaxAcceptableDistanceToHuman",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadMovementSettings, max_acceptable_distance_to_human),
            },
            FieldInfoData {
                name: "MaxAcceptableHeightDifferenceToHuman",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadMovementSettings, max_acceptable_height_difference_to_human),
            },
            FieldInfoData {
                name: "InvalidateOpenCoverIfAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SquadMovementSettings, invalidate_open_cover_if_alerted),
            },
            FieldInfoData {
                name: "CoverCompromisedTimer",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadMovementSettings, cover_compromised_timer),
            },
        ],
    }),
    array_type: Some(SQUADMOVEMENTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SquadMovementSettings {
    fn type_info() -> &'static TypeInfo {
        SQUADMOVEMENTSETTINGS_TYPE_INFO
    }
}


pub const SQUADMOVEMENTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadMovementSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SquadMovementSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CloseCombatSettings {
    pub distance: f32,
    pub height_distance: f32,
    pub distance_limit: f32,
    pub lost_visibility_timeout: f32,
    pub ignore_line_of_fire_on_enter: bool,
    pub pose_settings: PoseSettings,
    pub move_settings: MoveSettings,
    pub melee_projectile_settings: ProjectileSettings,
}

pub const CLOSECOMBATSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloseCombatSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CloseCombatSettings, distance),
            },
            FieldInfoData {
                name: "HeightDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CloseCombatSettings, height_distance),
            },
            FieldInfoData {
                name: "DistanceLimit",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CloseCombatSettings, distance_limit),
            },
            FieldInfoData {
                name: "LostVisibilityTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CloseCombatSettings, lost_visibility_timeout),
            },
            FieldInfoData {
                name: "IgnoreLineOfFireOnEnter",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CloseCombatSettings, ignore_line_of_fire_on_enter),
            },
            FieldInfoData {
                name: "PoseSettings",
                flags: MemberInfoFlags::new(0),
                field_type: POSESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(CloseCombatSettings, pose_settings),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(CloseCombatSettings, move_settings),
            },
            FieldInfoData {
                name: "MeleeProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PROJECTILESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(CloseCombatSettings, melee_projectile_settings),
            },
        ],
    }),
    array_type: Some(CLOSECOMBATSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CloseCombatSettings {
    fn type_info() -> &'static TypeInfo {
        CLOSECOMBATSETTINGS_TYPE_INFO
    }
}


pub const CLOSECOMBATSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloseCombatSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CloseCombatSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GoToAttackPointSettings {
    pub move_settings: MoveSettings,
    pub min_time_no_l_o_s_before_move: f32,
    pub max_time_no_l_o_s_before_move: f32,
    pub min_time_out_of_range_before_move: f32,
    pub max_time_out_of_range_before_move: f32,
    pub move_on_shot_at: bool,
}

pub const GOTOATTACKPOINTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GoToAttackPointSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(GoToAttackPointSettings, move_settings),
            },
            FieldInfoData {
                name: "MinTimeNoLOSBeforeMove",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GoToAttackPointSettings, min_time_no_l_o_s_before_move),
            },
            FieldInfoData {
                name: "MaxTimeNoLOSBeforeMove",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GoToAttackPointSettings, max_time_no_l_o_s_before_move),
            },
            FieldInfoData {
                name: "MinTimeOutOfRangeBeforeMove",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GoToAttackPointSettings, min_time_out_of_range_before_move),
            },
            FieldInfoData {
                name: "MaxTimeOutOfRangeBeforeMove",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GoToAttackPointSettings, max_time_out_of_range_before_move),
            },
            FieldInfoData {
                name: "MoveOnShotAt",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GoToAttackPointSettings, move_on_shot_at),
            },
        ],
    }),
    array_type: Some(GOTOATTACKPOINTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GoToAttackPointSettings {
    fn type_info() -> &'static TypeInfo {
        GOTOATTACKPOINTSETTINGS_TYPE_INFO
    }
}


pub const GOTOATTACKPOINTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GoToAttackPointSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GoToAttackPointSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EvadeBehaviorSettings {
    pub move_settings: MoveSettings,
    pub min_evade_distance: f32,
    pub max_expansion_count: i32,
    pub post_evade_pause_duration: f32,
    pub evade_breakout_min_time: f32,
}

pub const EVADEBEHAVIORSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvadeBehaviorSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(EvadeBehaviorSettings, move_settings),
            },
            FieldInfoData {
                name: "MinEvadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeBehaviorSettings, min_evade_distance),
            },
            FieldInfoData {
                name: "MaxExpansionCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeBehaviorSettings, max_expansion_count),
            },
            FieldInfoData {
                name: "PostEvadePauseDuration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeBehaviorSettings, post_evade_pause_duration),
            },
            FieldInfoData {
                name: "EvadeBreakoutMinTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeBehaviorSettings, evade_breakout_min_time),
            },
        ],
    }),
    array_type: Some(EVADEBEHAVIORSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EvadeBehaviorSettings {
    fn type_info() -> &'static TypeInfo {
        EVADEBEHAVIORSETTINGS_TYPE_INFO
    }
}


pub const EVADEBEHAVIORSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvadeBehaviorSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EvadeBehaviorSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FleeSettings {
    pub cover_query: CoverQueryData,
    pub move_settings: MoveSettings,
    pub cover_settings: CoverControlSettings,
    pub cover_request_settings: FleeCoverRequestSettings,
}

pub const FLEESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FleeSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(FleeSettings, cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(FleeSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COVERCONTROLSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(FleeSettings, cover_settings),
            },
            FieldInfoData {
                name: "CoverRequestSettings",
                flags: MemberInfoFlags::new(0),
                field_type: FLEECOVERREQUESTSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(FleeSettings, cover_request_settings),
            },
        ],
    }),
    array_type: Some(FLEESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FleeSettings {
    fn type_info() -> &'static TypeInfo {
        FLEESETTINGS_TYPE_INFO
    }
}


pub const FLEESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FleeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FleeSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct FleeCoverRequestSettings {
    pub allow_exposed_covers: bool,
}

pub const FLEECOVERREQUESTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FleeCoverRequestSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AllowExposedCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FleeCoverRequestSettings, allow_exposed_covers),
            },
        ],
    }),
    array_type: Some(FLEECOVERREQUESTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FleeCoverRequestSettings {
    fn type_info() -> &'static TypeInfo {
        FLEECOVERREQUESTSETTINGS_TYPE_INFO
    }
}


pub const FLEECOVERREQUESTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FleeCoverRequestSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FleeCoverRequestSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct HideSettings {
    pub cover_query: CoverQueryData,
    pub move_settings: MoveSettings,
    pub cover_settings: CoverControlSettings,
    pub invalidate_cover_angle: f32,
    pub minimum_time_active: f32,
    pub maximum_time_active: f32,
}

pub const HIDESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HideSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(HideSettings, cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(HideSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COVERCONTROLSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(HideSettings, cover_settings),
            },
            FieldInfoData {
                name: "InvalidateCoverAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HideSettings, invalidate_cover_angle),
            },
            FieldInfoData {
                name: "MinimumTimeActive",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HideSettings, minimum_time_active),
            },
            FieldInfoData {
                name: "MaximumTimeActive",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HideSettings, maximum_time_active),
            },
        ],
    }),
    array_type: Some(HIDESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HideSettings {
    fn type_info() -> &'static TypeInfo {
        HIDESETTINGS_TYPE_INFO
    }
}


pub const HIDESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HideSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("HideSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GoToTargetSettings {
    pub only_go_if_inside_defend_area: bool,
    pub only_go_if_inside_preferred_area: bool,
    pub cooldown_time: f32,
    pub max_dist_from_go_to_pos: f32,
    pub path_recalculate_frequency: f32,
    pub path_recalculate_distance_threshold: f32,
    pub move_settings: MoveSettings,
}

pub const GOTOTARGETSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GoToTargetSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "OnlyGoIfInsideDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GoToTargetSettings, only_go_if_inside_defend_area),
            },
            FieldInfoData {
                name: "OnlyGoIfInsidePreferredArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GoToTargetSettings, only_go_if_inside_preferred_area),
            },
            FieldInfoData {
                name: "CooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GoToTargetSettings, cooldown_time),
            },
            FieldInfoData {
                name: "MaxDistFromGoToPos",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GoToTargetSettings, max_dist_from_go_to_pos),
            },
            FieldInfoData {
                name: "PathRecalculateFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GoToTargetSettings, path_recalculate_frequency),
            },
            FieldInfoData {
                name: "PathRecalculateDistanceThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GoToTargetSettings, path_recalculate_distance_threshold),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(GoToTargetSettings, move_settings),
            },
        ],
    }),
    array_type: Some(GOTOTARGETSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GoToTargetSettings {
    fn type_info() -> &'static TypeInfo {
        GOTOTARGETSETTINGS_TYPE_INFO
    }
}


pub const GOTOTARGETSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GoToTargetSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GoToTargetSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowSettings {
    pub move_settings: MoveSettings,
    pub follow_move_settings: FollowMoveSettings,
    pub stealth_cover_query: CoverQueryData,
    pub stealth_cover_to_cover_advance_query: CoverQueryData,
    pub stealth_protective_query: CoverQueryData,
    pub max_distance_from_follow_object_to_run_stealth_protective_query: f32,
    pub follow_stealth_avoidance_settings: FollowStealthAvoidanceSettings,
    pub follow_stealth_cover_settings: FollowCoverSettings,
    pub attack_cover_query: CoverQueryData,
    pub follow_attack_cover_settings: FollowCoverSettings,
    pub attack_cover_settings: CoverControlSettings,
}

pub const FOLLOWSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, move_settings),
            },
            FieldInfoData {
                name: "FollowMoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWMOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, follow_move_settings),
            },
            FieldInfoData {
                name: "StealthCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, stealth_cover_query),
            },
            FieldInfoData {
                name: "StealthCoverToCoverAdvanceQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, stealth_cover_to_cover_advance_query),
            },
            FieldInfoData {
                name: "StealthProtectiveQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, stealth_protective_query),
            },
            FieldInfoData {
                name: "MaxDistanceFromFollowObjectToRunStealthProtectiveQuery",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, max_distance_from_follow_object_to_run_stealth_protective_query),
            },
            FieldInfoData {
                name: "FollowStealthAvoidanceSettings",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWSTEALTHAVOIDANCESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, follow_stealth_avoidance_settings),
            },
            FieldInfoData {
                name: "FollowStealthCoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWCOVERSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, follow_stealth_cover_settings),
            },
            FieldInfoData {
                name: "AttackCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, attack_cover_query),
            },
            FieldInfoData {
                name: "FollowAttackCoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWCOVERSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, follow_attack_cover_settings),
            },
            FieldInfoData {
                name: "AttackCoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COVERCONTROLSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(FollowSettings, attack_cover_settings),
            },
        ],
    }),
    array_type: Some(FOLLOWSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowSettings {
    fn type_info() -> &'static TypeInfo {
        FOLLOWSETTINGS_TYPE_INFO
    }
}


pub const FOLLOWSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowStealthAvoidanceSettings {
    pub min_follow_object_distance: f32,
    pub max_follow_object_distance: f32,
    pub path_look_ahead_distance: f32,
    pub enemy_avoidance_distance: f32,
}

pub const FOLLOWSTEALTHAVOIDANCESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowStealthAvoidanceSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MinFollowObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowStealthAvoidanceSettings, min_follow_object_distance),
            },
            FieldInfoData {
                name: "MaxFollowObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowStealthAvoidanceSettings, max_follow_object_distance),
            },
            FieldInfoData {
                name: "PathLookAheadDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowStealthAvoidanceSettings, path_look_ahead_distance),
            },
            FieldInfoData {
                name: "EnemyAvoidanceDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowStealthAvoidanceSettings, enemy_avoidance_distance),
            },
        ],
    }),
    array_type: Some(FOLLOWSTEALTHAVOIDANCESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowStealthAvoidanceSettings {
    fn type_info() -> &'static TypeInfo {
        FOLLOWSTEALTHAVOIDANCESETTINGS_TYPE_INFO
    }
}


pub const FOLLOWSTEALTHAVOIDANCESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowStealthAvoidanceSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowStealthAvoidanceSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowCoverSettings {
    pub min_time_in_open_cover: f32,
    pub min_time_in_protected_cover: f32,
    pub min_time_between_cover_requests: f32,
    pub max_distance_to_enemy_to_enable_cover_in: f32,
    pub max_distance_to_enemy_to_enable_cover_out: f32,
    pub max_distance_to_visible_enemy_to_enable_cover: f32,
    pub max_time_since_visible_enemy_seen: f32,
}

pub const FOLLOWCOVERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowCoverSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MinTimeInOpenCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowCoverSettings, min_time_in_open_cover),
            },
            FieldInfoData {
                name: "MinTimeInProtectedCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowCoverSettings, min_time_in_protected_cover),
            },
            FieldInfoData {
                name: "MinTimeBetweenCoverRequests",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowCoverSettings, min_time_between_cover_requests),
            },
            FieldInfoData {
                name: "MaxDistanceToEnemyToEnableCoverIn",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowCoverSettings, max_distance_to_enemy_to_enable_cover_in),
            },
            FieldInfoData {
                name: "MaxDistanceToEnemyToEnableCoverOut",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowCoverSettings, max_distance_to_enemy_to_enable_cover_out),
            },
            FieldInfoData {
                name: "MaxDistanceToVisibleEnemyToEnableCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowCoverSettings, max_distance_to_visible_enemy_to_enable_cover),
            },
            FieldInfoData {
                name: "MaxTimeSinceVisibleEnemySeen",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowCoverSettings, max_time_since_visible_enemy_seen),
            },
        ],
    }),
    array_type: Some(FOLLOWCOVERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowCoverSettings {
    fn type_info() -> &'static TypeInfo {
        FOLLOWCOVERSETTINGS_TYPE_INFO
    }
}


pub const FOLLOWCOVERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowCoverSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowCoverSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowMoveSettings {
    pub speed_control_params: FollowSpeedControlParams,
    pub repath_params: FollowRepathParams,
    pub pose_params: FollowPoseParams,
    pub disable_canned_turns: bool,
}

pub const FOLLOWMOVESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowMoveSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SpeedControlParams",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWSPEEDCONTROLPARAMS_TYPE_INFO,
                rust_offset: offset_of!(FollowMoveSettings, speed_control_params),
            },
            FieldInfoData {
                name: "RepathParams",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWREPATHPARAMS_TYPE_INFO,
                rust_offset: offset_of!(FollowMoveSettings, repath_params),
            },
            FieldInfoData {
                name: "PoseParams",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWPOSEPARAMS_TYPE_INFO,
                rust_offset: offset_of!(FollowMoveSettings, pose_params),
            },
            FieldInfoData {
                name: "DisableCannedTurns",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FollowMoveSettings, disable_canned_turns),
            },
        ],
    }),
    array_type: Some(FOLLOWMOVESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowMoveSettings {
    fn type_info() -> &'static TypeInfo {
        FOLLOWMOVESETTINGS_TYPE_INFO
    }
}


pub const FOLLOWMOVESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowMoveSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowMoveSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowPoseParams {
    pub pose_matching_max_distance: f32,
    pub pose_match_min_delay: f32,
    pub pose_match_max_delay: f32,
}

pub const FOLLOWPOSEPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowPoseParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PoseMatchingMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowPoseParams, pose_matching_max_distance),
            },
            FieldInfoData {
                name: "PoseMatchMinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowPoseParams, pose_match_min_delay),
            },
            FieldInfoData {
                name: "PoseMatchMaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowPoseParams, pose_match_max_delay),
            },
        ],
    }),
    array_type: Some(FOLLOWPOSEPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowPoseParams {
    fn type_info() -> &'static TypeInfo {
        FOLLOWPOSEPARAMS_TYPE_INFO
    }
}


pub const FOLLOWPOSEPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowPoseParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowPoseParams-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowSpeedControlParams {
    pub default_speed_selection_params: FollowMoveSpeedSelectionParams,
    pub cautious_speed_selection_params: FollowMoveSpeedSelectionParams,
    pub catchup_speed_scaling_curve: super::core::FloatCurve,
    pub speed_matching_speed_scaling_curve: super::core::FloatCurve,
    pub rubberband_p_i_d: super::game_shared::PID,
    pub min_rubberband_speed_multiplier: f32,
    pub max_rubberband_speed_multiplier: f32,
}

pub const FOLLOWSPEEDCONTROLPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowSpeedControlParams",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "DefaultSpeedSelectionParams",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWMOVESPEEDSELECTIONPARAMS_TYPE_INFO,
                rust_offset: offset_of!(FollowSpeedControlParams, default_speed_selection_params),
            },
            FieldInfoData {
                name: "CautiousSpeedSelectionParams",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWMOVESPEEDSELECTIONPARAMS_TYPE_INFO,
                rust_offset: offset_of!(FollowSpeedControlParams, cautious_speed_selection_params),
            },
            FieldInfoData {
                name: "CatchupSpeedScalingCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(FollowSpeedControlParams, catchup_speed_scaling_curve),
            },
            FieldInfoData {
                name: "SpeedMatchingSpeedScalingCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(FollowSpeedControlParams, speed_matching_speed_scaling_curve),
            },
            FieldInfoData {
                name: "RubberbandPID",
                flags: MemberInfoFlags::new(0),
                field_type: PID_TYPE_INFO,
                rust_offset: offset_of!(FollowSpeedControlParams, rubberband_p_i_d),
            },
            FieldInfoData {
                name: "MinRubberbandSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowSpeedControlParams, min_rubberband_speed_multiplier),
            },
            FieldInfoData {
                name: "MaxRubberbandSpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowSpeedControlParams, max_rubberband_speed_multiplier),
            },
        ],
    }),
    array_type: Some(FOLLOWSPEEDCONTROLPARAMS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowSpeedControlParams {
    fn type_info() -> &'static TypeInfo {
        FOLLOWSPEEDCONTROLPARAMS_TYPE_INFO
    }
}


pub const FOLLOWSPEEDCONTROLPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowSpeedControlParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowSpeedControlParams-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowMoveSpeedSelectionParams {
    pub always_sprint_distance: f32,
    pub always_run_or_sprint_distance: f32,
    pub walk_run_transition_speed: f32,
    pub min_target_sustained_run_before_run_enabled: f32,
}

pub const FOLLOWMOVESPEEDSELECTIONPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowMoveSpeedSelectionParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AlwaysSprintDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowMoveSpeedSelectionParams, always_sprint_distance),
            },
            FieldInfoData {
                name: "AlwaysRunOrSprintDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowMoveSpeedSelectionParams, always_run_or_sprint_distance),
            },
            FieldInfoData {
                name: "WalkRunTransitionSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowMoveSpeedSelectionParams, walk_run_transition_speed),
            },
            FieldInfoData {
                name: "MinTargetSustainedRunBeforeRunEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowMoveSpeedSelectionParams, min_target_sustained_run_before_run_enabled),
            },
        ],
    }),
    array_type: Some(FOLLOWMOVESPEEDSELECTIONPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowMoveSpeedSelectionParams {
    fn type_info() -> &'static TypeInfo {
        FOLLOWMOVESPEEDSELECTIONPARAMS_TYPE_INFO
    }
}


pub const FOLLOWMOVESPEEDSELECTIONPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowMoveSpeedSelectionParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowMoveSpeedSelectionParams-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowRepathParams {
    pub repath_min_target_move_dist: f32,
    pub repath_max_target_move_dist: f32,
    pub target_proximity_for_max_repath_rate: f32,
    pub target_proximity_for_min_repath_rate: f32,
}

pub const FOLLOWREPATHPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowRepathParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "RepathMinTargetMoveDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowRepathParams, repath_min_target_move_dist),
            },
            FieldInfoData {
                name: "RepathMaxTargetMoveDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowRepathParams, repath_max_target_move_dist),
            },
            FieldInfoData {
                name: "TargetProximityForMaxRepathRate",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowRepathParams, target_proximity_for_max_repath_rate),
            },
            FieldInfoData {
                name: "TargetProximityForMinRepathRate",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowRepathParams, target_proximity_for_min_repath_rate),
            },
        ],
    }),
    array_type: Some(FOLLOWREPATHPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowRepathParams {
    fn type_info() -> &'static TypeInfo {
        FOLLOWREPATHPARAMS_TYPE_INFO
    }
}


pub const FOLLOWREPATHPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowRepathParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowRepathParams-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AttackSettings {
    pub goal_cover_query: CoverQueryData,
    pub protection_cover_query: CoverQueryData,
    pub hide_cover_query: CoverQueryData,
    pub valid_cover_query: CoverQueryData,
    pub forced_move_cover_query: CoverQueryData,
    pub move_settings: MoveSettings,
    pub cover_settings: CoverControlSettings,
    pub cover_request_settings: AttackCoverRequestSettings,
    pub indoor_cover_request_settings: AttackCoverRequestSettings,
    pub outdoor_cover_request_settings: AttackCoverRequestSettings,
    pub projectile_settings: ProjectileSettings,
    pub melee_projectile_settings: ProjectileSettings,
    pub combat_intensity: AICombatIntensity,
}

pub const ATTACKSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "GoalCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, goal_cover_query),
            },
            FieldInfoData {
                name: "ProtectionCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, protection_cover_query),
            },
            FieldInfoData {
                name: "HideCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, hide_cover_query),
            },
            FieldInfoData {
                name: "ValidCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, valid_cover_query),
            },
            FieldInfoData {
                name: "ForcedMoveCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, forced_move_cover_query),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COVERCONTROLSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, cover_settings),
            },
            FieldInfoData {
                name: "CoverRequestSettings",
                flags: MemberInfoFlags::new(0),
                field_type: ATTACKCOVERREQUESTSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, cover_request_settings),
            },
            FieldInfoData {
                name: "IndoorCoverRequestSettings",
                flags: MemberInfoFlags::new(0),
                field_type: ATTACKCOVERREQUESTSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, indoor_cover_request_settings),
            },
            FieldInfoData {
                name: "OutdoorCoverRequestSettings",
                flags: MemberInfoFlags::new(0),
                field_type: ATTACKCOVERREQUESTSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, outdoor_cover_request_settings),
            },
            FieldInfoData {
                name: "ProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PROJECTILESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, projectile_settings),
            },
            FieldInfoData {
                name: "MeleeProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PROJECTILESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, melee_projectile_settings),
            },
            FieldInfoData {
                name: "CombatIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: AICOMBATINTENSITY_TYPE_INFO,
                rust_offset: offset_of!(AttackSettings, combat_intensity),
            },
        ],
    }),
    array_type: Some(ATTACKSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AttackSettings {
    fn type_info() -> &'static TypeInfo {
        ATTACKSETTINGS_TYPE_INFO
    }
}


pub const ATTACKSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AttackSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AttackCoverRequestSettings {
    pub minimum_time_in_cover_to_request: f32,
    pub maximum_time_in_cover_to_request: f32,
    pub minimum_time_between_goal_cover_requests: f32,
    pub minimum_time_interval_to_request_protective_cover: f32,
    pub maximum_time_interval_to_request_protective_cover: f32,
    pub max_dist_outside_weapon_range_to_request_protective_cover: f32,
    pub min_path_dist_to_request_protective_cover: f32,
    pub minimum_time_interval_to_request_hide_cover: f32,
    pub maximum_time_interval_to_request_hide_cover: f32,
    pub target_lost_last_seen_distance_multiplier: super::core::FloatCurve,
    pub minimum_time_in_cover_after_target_lost: f32,
    pub maximum_time_in_cover_after_target_lost: f32,
    pub minimum_time_in_cover_after_target_l_o_f_lost: f32,
    pub maximum_time_in_cover_after_target_l_o_f_lost: f32,
    pub distance_to_target_compromised_threshold: f32,
    pub minimum_distance_to_target: f32,
    pub minimum_distance_to_target_vehicle: f32,
    pub time_required_after_shot_at_to_request_goal_cover: f32,
    pub ignore_shot_at_from_a_is: bool,
    pub minimum_initial_delay: TinyPiecewiseLinearCurve,
    pub maximum_initial_delay: TinyPiecewiseLinearCurve,
    pub advance_on_target_settings: AttackCoverRequestAdvanceOnTargetSettings,
    pub try_advance_even_if_already_in_weapon_range: bool,
    pub use_tactical_instead_of_valid_cover_when_having_been_in_combat: bool,
}

pub const ATTACKCOVERREQUESTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackCoverRequestSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MinimumTimeInCoverToRequest",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_in_cover_to_request),
            },
            FieldInfoData {
                name: "MaximumTimeInCoverToRequest",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_in_cover_to_request),
            },
            FieldInfoData {
                name: "MinimumTimeBetweenGoalCoverRequests",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_between_goal_cover_requests),
            },
            FieldInfoData {
                name: "MinimumTimeIntervalToRequestProtectiveCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_interval_to_request_protective_cover),
            },
            FieldInfoData {
                name: "MaximumTimeIntervalToRequestProtectiveCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_interval_to_request_protective_cover),
            },
            FieldInfoData {
                name: "MaxDistOutsideWeaponRangeToRequestProtectiveCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, max_dist_outside_weapon_range_to_request_protective_cover),
            },
            FieldInfoData {
                name: "MinPathDistToRequestProtectiveCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, min_path_dist_to_request_protective_cover),
            },
            FieldInfoData {
                name: "MinimumTimeIntervalToRequestHideCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_interval_to_request_hide_cover),
            },
            FieldInfoData {
                name: "MaximumTimeIntervalToRequestHideCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_interval_to_request_hide_cover),
            },
            FieldInfoData {
                name: "TargetLostLastSeenDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, target_lost_last_seen_distance_multiplier),
            },
            FieldInfoData {
                name: "MinimumTimeInCoverAfterTargetLost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_in_cover_after_target_lost),
            },
            FieldInfoData {
                name: "MaximumTimeInCoverAfterTargetLost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_in_cover_after_target_lost),
            },
            FieldInfoData {
                name: "MinimumTimeInCoverAfterTargetLOFLost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_time_in_cover_after_target_l_o_f_lost),
            },
            FieldInfoData {
                name: "MaximumTimeInCoverAfterTargetLOFLost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_time_in_cover_after_target_l_o_f_lost),
            },
            FieldInfoData {
                name: "DistanceToTargetCompromisedThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, distance_to_target_compromised_threshold),
            },
            FieldInfoData {
                name: "MinimumDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_distance_to_target),
            },
            FieldInfoData {
                name: "MinimumDistanceToTargetVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_distance_to_target_vehicle),
            },
            FieldInfoData {
                name: "TimeRequiredAfterShotAtToRequestGoalCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, time_required_after_shot_at_to_request_goal_cover),
            },
            FieldInfoData {
                name: "IgnoreShotAtFromAIs",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, ignore_shot_at_from_a_is),
            },
            FieldInfoData {
                name: "MinimumInitialDelay",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, minimum_initial_delay),
            },
            FieldInfoData {
                name: "MaximumInitialDelay",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, maximum_initial_delay),
            },
            FieldInfoData {
                name: "AdvanceOnTargetSettings",
                flags: MemberInfoFlags::new(0),
                field_type: ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, advance_on_target_settings),
            },
            FieldInfoData {
                name: "TryAdvanceEvenIfAlreadyInWeaponRange",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, try_advance_even_if_already_in_weapon_range),
            },
            FieldInfoData {
                name: "UseTacticalInsteadOfValidCoverWhenHavingBeenInCombat",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestSettings, use_tactical_instead_of_valid_cover_when_having_been_in_combat),
            },
        ],
    }),
    array_type: Some(ATTACKCOVERREQUESTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AttackCoverRequestSettings {
    fn type_info() -> &'static TypeInfo {
        ATTACKCOVERREQUESTSETTINGS_TYPE_INFO
    }
}


pub const ATTACKCOVERREQUESTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackCoverRequestSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AttackCoverRequestSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AttackCoverRequestAdvanceOnTargetSettings {
    pub minimum_time_in_cover_to_request: f32,
    pub maximum_time_in_cover_to_request: f32,
}

pub const ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackCoverRequestAdvanceOnTargetSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MinimumTimeInCoverToRequest",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestAdvanceOnTargetSettings, minimum_time_in_cover_to_request),
            },
            FieldInfoData {
                name: "MaximumTimeInCoverToRequest",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AttackCoverRequestAdvanceOnTargetSettings, maximum_time_in_cover_to_request),
            },
        ],
    }),
    array_type: Some(ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AttackCoverRequestAdvanceOnTargetSettings {
    fn type_info() -> &'static TypeInfo {
        ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_TYPE_INFO
    }
}


pub const ATTACKCOVERREQUESTADVANCEONTARGETSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AttackCoverRequestAdvanceOnTargetSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AttackCoverRequestAdvanceOnTargetSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ExecuteActionSettings {
    pub move_settings: MoveSettings,
    pub cooldown_time: f32,
    pub is_valid_for_during_scripted_path: bool,
}

pub const EXECUTEACTIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecuteActionSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(ExecuteActionSettings, move_settings),
            },
            FieldInfoData {
                name: "CooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ExecuteActionSettings, cooldown_time),
            },
            FieldInfoData {
                name: "IsValidForDuringScriptedPath",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ExecuteActionSettings, is_valid_for_during_scripted_path),
            },
        ],
    }),
    array_type: Some(EXECUTEACTIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExecuteActionSettings {
    fn type_info() -> &'static TypeInfo {
        EXECUTEACTIONSETTINGS_TYPE_INFO
    }
}


pub const EXECUTEACTIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecuteActionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ExecuteActionSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateSettings {
    pub move_settings: MoveSettings,
    pub make_investigations_part_of_active_search: bool,
    pub num_secondary_inspections: i32,
    pub secondary_inspect_min_dist: f32,
    pub secondary_inspect_max_dist: f32,
    pub time_spent_inspecting: f32,
    pub find_secondary_pos_from_current_pos: bool,
    pub keep_initial_reaction_state: bool,
    pub initial_reaction_time: f32,
    pub give_up_reaction_time: f32,
    pub stand_in_place_and_look_time: f32,
    pub min_dist_from_investigate_pos: f32,
    pub max_dist_from_investigate_pos: f32,
    pub fail_to_find_position_timeout: f32,
    pub cooldown_time: f32,
    pub stop_abruptly_duration: f32,
    pub secondary_inspect_wait_for_available_action_station: f32,
    pub perform_initial_inspect: bool,
    pub initial_inspect_count_as_secondary: bool,
    pub max_perform_initial_inspectors: i32,
    pub only_investigate_inside_defend_area: bool,
    pub snap_investigate_pos_to_defend_area: bool,
    pub stand_and_look_investigate_outside_defend_area: bool,
    pub restrict_secondary_points_to_defend_area: bool,
    pub only_investigate_inside_search_area: bool,
    pub snap_investigate_pos_to_search_area: bool,
    pub stand_and_look_investigate_outside_search_area: bool,
    pub restrict_secondary_points_to_search_area: bool,
    pub disregard_corpses: bool,
    pub remove_disregarded_corpse: bool,
    pub return_to_start_position: bool,
    pub angle_correction_wait_time: f32,
}

pub const INVESTIGATESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, move_settings),
            },
            FieldInfoData {
                name: "MakeInvestigationsPartOfActiveSearch",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, make_investigations_part_of_active_search),
            },
            FieldInfoData {
                name: "NumSecondaryInspections",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, num_secondary_inspections),
            },
            FieldInfoData {
                name: "SecondaryInspectMinDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, secondary_inspect_min_dist),
            },
            FieldInfoData {
                name: "SecondaryInspectMaxDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, secondary_inspect_max_dist),
            },
            FieldInfoData {
                name: "TimeSpentInspecting",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, time_spent_inspecting),
            },
            FieldInfoData {
                name: "FindSecondaryPosFromCurrentPos",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, find_secondary_pos_from_current_pos),
            },
            FieldInfoData {
                name: "KeepInitialReactionState",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, keep_initial_reaction_state),
            },
            FieldInfoData {
                name: "InitialReactionTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, initial_reaction_time),
            },
            FieldInfoData {
                name: "GiveUpReactionTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, give_up_reaction_time),
            },
            FieldInfoData {
                name: "StandInPlaceAndLookTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, stand_in_place_and_look_time),
            },
            FieldInfoData {
                name: "MinDistFromInvestigatePos",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, min_dist_from_investigate_pos),
            },
            FieldInfoData {
                name: "MaxDistFromInvestigatePos",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, max_dist_from_investigate_pos),
            },
            FieldInfoData {
                name: "FailToFindPositionTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, fail_to_find_position_timeout),
            },
            FieldInfoData {
                name: "CooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, cooldown_time),
            },
            FieldInfoData {
                name: "StopAbruptlyDuration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, stop_abruptly_duration),
            },
            FieldInfoData {
                name: "SecondaryInspectWaitForAvailableActionStation",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, secondary_inspect_wait_for_available_action_station),
            },
            FieldInfoData {
                name: "PerformInitialInspect",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, perform_initial_inspect),
            },
            FieldInfoData {
                name: "InitialInspectCountAsSecondary",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, initial_inspect_count_as_secondary),
            },
            FieldInfoData {
                name: "MaxPerformInitialInspectors",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, max_perform_initial_inspectors),
            },
            FieldInfoData {
                name: "OnlyInvestigateInsideDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, only_investigate_inside_defend_area),
            },
            FieldInfoData {
                name: "SnapInvestigatePosToDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, snap_investigate_pos_to_defend_area),
            },
            FieldInfoData {
                name: "StandAndLookInvestigateOutsideDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, stand_and_look_investigate_outside_defend_area),
            },
            FieldInfoData {
                name: "RestrictSecondaryPointsToDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, restrict_secondary_points_to_defend_area),
            },
            FieldInfoData {
                name: "OnlyInvestigateInsideSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, only_investigate_inside_search_area),
            },
            FieldInfoData {
                name: "SnapInvestigatePosToSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, snap_investigate_pos_to_search_area),
            },
            FieldInfoData {
                name: "StandAndLookInvestigateOutsideSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, stand_and_look_investigate_outside_search_area),
            },
            FieldInfoData {
                name: "RestrictSecondaryPointsToSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, restrict_secondary_points_to_search_area),
            },
            FieldInfoData {
                name: "DisregardCorpses",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, disregard_corpses),
            },
            FieldInfoData {
                name: "RemoveDisregardedCorpse",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, remove_disregarded_corpse),
            },
            FieldInfoData {
                name: "ReturnToStartPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, return_to_start_position),
            },
            FieldInfoData {
                name: "AngleCorrectionWaitTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettings, angle_correction_wait_time),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InvestigateSettings {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATESETTINGS_TYPE_INFO
    }
}


pub const INVESTIGATESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CloseRangeAttackSettings {
    pub move_settings: MoveSettings,
    pub cover_settings: CoverControlSettings,
    pub cover_query: CoverQueryData,
}

pub const CLOSERANGEATTACKSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloseRangeAttackSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(CloseRangeAttackSettings, move_settings),
            },
            FieldInfoData {
                name: "CoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COVERCONTROLSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(CloseRangeAttackSettings, cover_settings),
            },
            FieldInfoData {
                name: "CoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(CloseRangeAttackSettings, cover_query),
            },
        ],
    }),
    array_type: Some(CLOSERANGEATTACKSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CloseRangeAttackSettings {
    fn type_info() -> &'static TypeInfo {
        CLOSERANGEATTACKSETTINGS_TYPE_INFO
    }
}


pub const CLOSERANGEATTACKSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloseRangeAttackSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CloseRangeAttackSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MeleeChargeSettings {
    pub move_settings: MoveSettings,
    pub melee_projectile_settings: ProjectileSettings,
    pub dynamic_melee_charge_tokens_settings: DynamicMeleeChargeTokensSettings,
    pub min_melee_charge_distance: f32,
    pub max_melee_charge_distance: f32,
    pub time_stop_melee_charge_for_invalid_path: f32,
    pub min_time_in_player_view_to_charge: f32,
    pub max_time_in_player_view_to_charge: f32,
    pub bypass_token_requirement: bool,
    pub allow_charging_charged_target: bool,
    pub manual_token_release: bool,
    pub check_is_player_in_front: bool,
    pub disable_canned_starts: bool,
    pub disable_canned_stops: bool,
    pub disable_canned_turns: bool,
    pub disable_canned_animation_range: f32,
    pub warp_on_attack: bool,
    pub screaming_v_o_range: f32,
    pub complete_on_melee: bool,
    pub charge_cooldown: f32,
    pub off_navmesh_correction: f32,
}

pub const MELEECHARGESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeChargeSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, move_settings),
            },
            FieldInfoData {
                name: "MeleeProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PROJECTILESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, melee_projectile_settings),
            },
            FieldInfoData {
                name: "DynamicMeleeChargeTokensSettings",
                flags: MemberInfoFlags::new(0),
                field_type: DYNAMICMELEECHARGETOKENSSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, dynamic_melee_charge_tokens_settings),
            },
            FieldInfoData {
                name: "MinMeleeChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, min_melee_charge_distance),
            },
            FieldInfoData {
                name: "MaxMeleeChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, max_melee_charge_distance),
            },
            FieldInfoData {
                name: "TimeStopMeleeChargeForInvalidPath",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, time_stop_melee_charge_for_invalid_path),
            },
            FieldInfoData {
                name: "MinTimeInPlayerViewToCharge",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, min_time_in_player_view_to_charge),
            },
            FieldInfoData {
                name: "MaxTimeInPlayerViewToCharge",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, max_time_in_player_view_to_charge),
            },
            FieldInfoData {
                name: "BypassTokenRequirement",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, bypass_token_requirement),
            },
            FieldInfoData {
                name: "AllowChargingChargedTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, allow_charging_charged_target),
            },
            FieldInfoData {
                name: "ManualTokenRelease",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, manual_token_release),
            },
            FieldInfoData {
                name: "CheckIsPlayerInFront",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, check_is_player_in_front),
            },
            FieldInfoData {
                name: "DisableCannedStarts",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, disable_canned_starts),
            },
            FieldInfoData {
                name: "DisableCannedStops",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, disable_canned_stops),
            },
            FieldInfoData {
                name: "DisableCannedTurns",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, disable_canned_turns),
            },
            FieldInfoData {
                name: "DisableCannedAnimationRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, disable_canned_animation_range),
            },
            FieldInfoData {
                name: "WarpOnAttack",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, warp_on_attack),
            },
            FieldInfoData {
                name: "ScreamingVORange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, screaming_v_o_range),
            },
            FieldInfoData {
                name: "CompleteOnMelee",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, complete_on_melee),
            },
            FieldInfoData {
                name: "ChargeCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, charge_cooldown),
            },
            FieldInfoData {
                name: "OffNavmeshCorrection",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeSettings, off_navmesh_correction),
            },
        ],
    }),
    array_type: Some(MELEECHARGESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MeleeChargeSettings {
    fn type_info() -> &'static TypeInfo {
        MELEECHARGESETTINGS_TYPE_INFO
    }
}


pub const MELEECHARGESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeChargeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MeleeChargeSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DynamicMeleeChargeTokensSettings {
    pub trigger_refill_token_count: i32,
    pub refill_token_count: i32,
    pub force_melee_charge_distance: f32,
    pub time_force_melee_charge: f32,
    pub stop_melee_charge_distance: f32,
    pub time_stop_melee_charge_for_distance: f32,
}

pub const DYNAMICMELEECHARGETOKENSSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicMeleeChargeTokensSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "TriggerRefillTokenCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, trigger_refill_token_count),
            },
            FieldInfoData {
                name: "RefillTokenCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, refill_token_count),
            },
            FieldInfoData {
                name: "ForceMeleeChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, force_melee_charge_distance),
            },
            FieldInfoData {
                name: "TimeForceMeleeCharge",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, time_force_melee_charge),
            },
            FieldInfoData {
                name: "StopMeleeChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, stop_melee_charge_distance),
            },
            FieldInfoData {
                name: "TimeStopMeleeChargeForDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DynamicMeleeChargeTokensSettings, time_stop_melee_charge_for_distance),
            },
        ],
    }),
    array_type: Some(DYNAMICMELEECHARGETOKENSSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DynamicMeleeChargeTokensSettings {
    fn type_info() -> &'static TypeInfo {
        DYNAMICMELEECHARGETOKENSSETTINGS_TYPE_INFO
    }
}


pub const DYNAMICMELEECHARGETOKENSSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicMeleeChargeTokensSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DynamicMeleeChargeTokensSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BerserkSettings {
    pub only_scriptable: bool,
    pub move_settings: MoveSettings,
    pub berserk_cover_query: CoverQueryData,
    pub max_berserk_distance: f32,
    pub melee_projectile_settings: ProjectileSettings,
    pub projectile_settings: ProjectileSettings,
}

pub const BERSERKSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BerserkSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "OnlyScriptable",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BerserkSettings, only_scriptable),
            },
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(BerserkSettings, move_settings),
            },
            FieldInfoData {
                name: "BerserkCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(BerserkSettings, berserk_cover_query),
            },
            FieldInfoData {
                name: "MaxBerserkDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BerserkSettings, max_berserk_distance),
            },
            FieldInfoData {
                name: "MeleeProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PROJECTILESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(BerserkSettings, melee_projectile_settings),
            },
            FieldInfoData {
                name: "ProjectileSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PROJECTILESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(BerserkSettings, projectile_settings),
            },
        ],
    }),
    array_type: Some(BERSERKSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BerserkSettings {
    fn type_info() -> &'static TypeInfo {
        BERSERKSETTINGS_TYPE_INFO
    }
}


pub const BERSERKSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BerserkSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BerserkSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ChargeSettings {
    pub move_settings: MoveSettings,
    pub charge_cover_query: CoverQueryData,
    pub allowed_to_charge_distance: f32,
}

pub const CHARGESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChargeSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(ChargeSettings, move_settings),
            },
            FieldInfoData {
                name: "ChargeCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(ChargeSettings, charge_cover_query),
            },
            FieldInfoData {
                name: "AllowedToChargeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ChargeSettings, allowed_to_charge_distance),
            },
        ],
    }),
    array_type: Some(CHARGESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChargeSettings {
    fn type_info() -> &'static TypeInfo {
        CHARGESETTINGS_TYPE_INFO
    }
}


pub const CHARGESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChargeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ChargeSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VehicleSettings {
    pub move_settings: MoveSettings,
    pub distance_to_vehicle: f32,
    pub distance_vehicle_to_human: f32,
}

pub const VEHICLESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveSettings",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(VehicleSettings, move_settings),
            },
            FieldInfoData {
                name: "DistanceToVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleSettings, distance_to_vehicle),
            },
            FieldInfoData {
                name: "DistanceVehicleToHuman",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleSettings, distance_vehicle_to_human),
            },
        ],
    }),
    array_type: Some(VEHICLESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleSettings {
    fn type_info() -> &'static TypeInfo {
        VEHICLESETTINGS_TYPE_INFO
    }
}


pub const VEHICLESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIMeleeSettings {
    pub team_melee_attack_interval_time: f32,
    pub last_melee_timer: f32,
    pub player_health_takedown_threshold: f32,
    pub max_player_takedown_angle_deg: f32,
    pub check_animation_allows_fire: bool,
    pub charge_between_attacks: bool,
}

pub const AIMELEESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIMeleeSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "TeamMeleeAttackIntervalTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIMeleeSettings, team_melee_attack_interval_time),
            },
            FieldInfoData {
                name: "LastMeleeTimer",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIMeleeSettings, last_melee_timer),
            },
            FieldInfoData {
                name: "PlayerHealthTakedownThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIMeleeSettings, player_health_takedown_threshold),
            },
            FieldInfoData {
                name: "MaxPlayerTakedownAngleDeg",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIMeleeSettings, max_player_takedown_angle_deg),
            },
            FieldInfoData {
                name: "CheckAnimationAllowsFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIMeleeSettings, check_animation_allows_fire),
            },
            FieldInfoData {
                name: "ChargeBetweenAttacks",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIMeleeSettings, charge_between_attacks),
            },
        ],
    }),
    array_type: Some(AIMELEESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIMeleeSettings {
    fn type_info() -> &'static TypeInfo {
        AIMELEESETTINGS_TYPE_INFO
    }
}


pub const AIMELEESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIMeleeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIMeleeSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ProjectileSettings {
    pub is_continuous: bool,
    pub minimum_interval: f32,
    pub maximum_interval: f32,
    pub require_passive_damage: bool,
    pub require_passive_movement: bool,
    pub charge: bool,
    pub avoid_friendly_fire: bool,
    pub friendly_fire_radius: f32,
    pub lower: f32,
    pub upper: f32,
    pub valid_against: ValidAgainst,
    pub a_i_melee_settings: AIMeleeSettings,
}

pub const PROJECTILESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProjectileSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "IsContinuous",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, is_continuous),
            },
            FieldInfoData {
                name: "MinimumInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, minimum_interval),
            },
            FieldInfoData {
                name: "MaximumInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, maximum_interval),
            },
            FieldInfoData {
                name: "RequirePassiveDamage",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, require_passive_damage),
            },
            FieldInfoData {
                name: "RequirePassiveMovement",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, require_passive_movement),
            },
            FieldInfoData {
                name: "Charge",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, charge),
            },
            FieldInfoData {
                name: "AvoidFriendlyFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, avoid_friendly_fire),
            },
            FieldInfoData {
                name: "FriendlyFireRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, friendly_fire_radius),
            },
            FieldInfoData {
                name: "Lower",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, lower),
            },
            FieldInfoData {
                name: "Upper",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, upper),
            },
            FieldInfoData {
                name: "ValidAgainst",
                flags: MemberInfoFlags::new(0),
                field_type: VALIDAGAINST_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, valid_against),
            },
            FieldInfoData {
                name: "AIMeleeSettings",
                flags: MemberInfoFlags::new(0),
                field_type: AIMELEESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(ProjectileSettings, a_i_melee_settings),
            },
        ],
    }),
    array_type: Some(PROJECTILESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ProjectileSettings {
    fn type_info() -> &'static TypeInfo {
        PROJECTILESETTINGS_TYPE_INFO
    }
}


pub const PROJECTILESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProjectileSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ProjectileSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct PoseSettings {
    pub pose: Pose,
}

pub const POSESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Pose",
                flags: MemberInfoFlags::new(0),
                field_type: POSE_TYPE_INFO,
                rust_offset: offset_of!(PoseSettings, pose),
            },
        ],
    }),
    array_type: Some(POSESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PoseSettings {
    fn type_info() -> &'static TypeInfo {
        POSESETTINGS_TYPE_INFO
    }
}


pub const POSESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PoseSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PoseSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverControlSettings {
    pub firing_times: Vec<f32>,
    pub idle_times: Vec<f32>,
    pub allow_suppression: bool,
    pub suppression_threshold: f32,
    pub allow_open_cover_crouch: bool,
    pub cover_hover_settings: CoverHoverData,
    pub cover_side_step_settings: CoverSideStepData,
}

pub const COVERCONTROLSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverControlSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FiringTimes",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverControlSettings, firing_times),
            },
            FieldInfoData {
                name: "IdleTimes",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverControlSettings, idle_times),
            },
            FieldInfoData {
                name: "AllowSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverControlSettings, allow_suppression),
            },
            FieldInfoData {
                name: "SuppressionThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverControlSettings, suppression_threshold),
            },
            FieldInfoData {
                name: "AllowOpenCoverCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverControlSettings, allow_open_cover_crouch),
            },
            FieldInfoData {
                name: "CoverHoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COVERHOVERDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverControlSettings, cover_hover_settings),
            },
            FieldInfoData {
                name: "CoverSideStepSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COVERSIDESTEPDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverControlSettings, cover_side_step_settings),
            },
        ],
    }),
    array_type: Some(COVERCONTROLSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverControlSettings {
    fn type_info() -> &'static TypeInfo {
        COVERCONTROLSETTINGS_TYPE_INFO
    }
}


pub const COVERCONTROLSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverControlSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverControlSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverHoverData {
    pub max_distance_to_target: f32,
    pub min_hover_time: f32,
    pub max_hover_time: f32,
    pub min_hover_interval: f32,
    pub max_hover_interval: f32,
    pub cover_side_hover_settings: CoverSideStepData,
}

pub const COVERHOVERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverHoverData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MaxDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverHoverData, max_distance_to_target),
            },
            FieldInfoData {
                name: "MinHoverTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverHoverData, min_hover_time),
            },
            FieldInfoData {
                name: "MaxHoverTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverHoverData, max_hover_time),
            },
            FieldInfoData {
                name: "MinHoverInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverHoverData, min_hover_interval),
            },
            FieldInfoData {
                name: "MaxHoverInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverHoverData, max_hover_interval),
            },
            FieldInfoData {
                name: "CoverSideHoverSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COVERSIDESTEPDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverHoverData, cover_side_hover_settings),
            },
        ],
    }),
    array_type: Some(COVERHOVERDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverHoverData {
    fn type_info() -> &'static TypeInfo {
        COVERHOVERDATA_TYPE_INFO
    }
}


pub const COVERHOVERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverHoverData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverHoverData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverSideStepData {
    pub shot_at_step_chance: i32,
    pub aim_at_step_chance: i32,
    pub aim_at_step_interval: f32,
    pub idle_step_chance: i32,
    pub idle_step_interval: f32,
    pub side_step_initial_cooldown: f32,
    pub side_step_cooldown: f32,
    pub side_step_angle_threshold: i32,
}

pub const COVERSIDESTEPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "ShotAtStepChance",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverSideStepData, shot_at_step_chance),
            },
            FieldInfoData {
                name: "AimAtStepChance",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverSideStepData, aim_at_step_chance),
            },
            FieldInfoData {
                name: "AimAtStepInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverSideStepData, aim_at_step_interval),
            },
            FieldInfoData {
                name: "IdleStepChance",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverSideStepData, idle_step_chance),
            },
            FieldInfoData {
                name: "IdleStepInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverSideStepData, idle_step_interval),
            },
            FieldInfoData {
                name: "SideStepInitialCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverSideStepData, side_step_initial_cooldown),
            },
            FieldInfoData {
                name: "SideStepCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverSideStepData, side_step_cooldown),
            },
            FieldInfoData {
                name: "SideStepAngleThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverSideStepData, side_step_angle_threshold),
            },
        ],
    }),
    array_type: Some(COVERSIDESTEPDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverSideStepData {
    fn type_info() -> &'static TypeInfo {
        COVERSIDESTEPDATA_TYPE_INFO
    }
}


pub const COVERSIDESTEPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSideStepData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CheckTargetInVehicle {
    #[default]
    CheckTargetInVehicle_NoCheck = 0,
    CheckTargetInVehicle_InVehicle = 1,
    CheckTargetInVehicle_NotInVehicle = 2,
}

pub const CHECKTARGETINVEHICLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CheckTargetInVehicle",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(CHECKTARGETINVEHICLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CheckTargetInVehicle {
    fn type_info() -> &'static TypeInfo {
        CHECKTARGETINVEHICLE_TYPE_INFO
    }
}


pub const CHECKTARGETINVEHICLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CheckTargetInVehicle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CheckTargetInVehicle-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AISpawnData {
    pub despawn_distance: f32,
}

pub const AISPAWNDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpawnData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(EXTRASPAWNDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DespawnDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISpawnData, despawn_distance),
            },
        ],
    }),
    array_type: Some(AISPAWNDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISpawnData {
    fn type_info() -> &'static TypeInfo {
        AISPAWNDATA_TYPE_INFO
    }
}


pub const AISPAWNDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpawnData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISpawnData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum Tactics {
    #[default]
    NoTactic = 0,
    VehicleTactic = 1,
    ChargeTactic = 2,
    AttackTactic = 3,
    HideTactic = 4,
    FleeTactic = 5,
    CloseCombatTactic = 6,
    BerserkTactic = 7,
    CloseRangeAttackTactic = 8,
    SquadMovementTactic = 9,
    SquadEngageTactic = 10,
    InvestigateTactic = 11,
    CombatInvestigateTactic = 12,
    CombatSearchAreaTactic = 13,
    SearchAreaTactic = 14,
    ExecuteIdleActionTactic = 15,
    ExecuteSearchActionTactic = 16,
    ExecuteCombatActionTactic = 17,
    FollowTactic = 18,
    GoToTargetTactic = 19,
    EvadeTactic = 20,
    MeleeChargeTactic = 21,
    GoToAttackPointTactic = 22,
    TacticsCount = 23,
}

pub const TACTICS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Tactics",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(TACTICS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Tactics {
    fn type_info() -> &'static TypeInfo {
        TACTICS_TYPE_INFO
    }
}


pub const TACTICS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Tactics-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Tactics-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AirTargetSelectorEntityData {
    pub realm: super::core::Realm,
    pub search_radius: f32,
    pub target_lost_slack: f32,
    pub max_attacker_count_for_priority_to_count: i32,
    pub prioritize_attackers_from_behind: bool,
    pub max_aim_angle_fault: f32,
    pub max_angle_off_our_backwards_vector: f32,
    pub max_distance: f32,
    pub max_team1_human_attackers: i32,
    pub max_team2_human_attackers: i32,
    pub evenly_distribute_targets: bool,
    pub dont_attack_targets_being_chased_by_humans: bool,
    pub maximum_distance_to_human_to_drop_current_target: f32,
    pub prioritize_humans: bool,
    pub auto_activate: bool,
    pub max_entities_updated_per_frame: i32,
}

pub const AIRTARGETSELECTORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirTargetSelectorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, realm),
            },
            FieldInfoData {
                name: "SearchRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, search_radius),
            },
            FieldInfoData {
                name: "TargetLostSlack",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, target_lost_slack),
            },
            FieldInfoData {
                name: "MaxAttackerCountForPriorityToCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_attacker_count_for_priority_to_count),
            },
            FieldInfoData {
                name: "PrioritizeAttackersFromBehind",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, prioritize_attackers_from_behind),
            },
            FieldInfoData {
                name: "MaxAimAngleFault",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_aim_angle_fault),
            },
            FieldInfoData {
                name: "MaxAngleOffOurBackwardsVector",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_angle_off_our_backwards_vector),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_distance),
            },
            FieldInfoData {
                name: "MaxTeam1HumanAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_team1_human_attackers),
            },
            FieldInfoData {
                name: "MaxTeam2HumanAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_team2_human_attackers),
            },
            FieldInfoData {
                name: "EvenlyDistributeTargets",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, evenly_distribute_targets),
            },
            FieldInfoData {
                name: "DontAttackTargetsBeingChasedByHumans",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, dont_attack_targets_being_chased_by_humans),
            },
            FieldInfoData {
                name: "MaximumDistanceToHumanToDropCurrentTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, maximum_distance_to_human_to_drop_current_target),
            },
            FieldInfoData {
                name: "PrioritizeHumans",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, prioritize_humans),
            },
            FieldInfoData {
                name: "AutoActivate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, auto_activate),
            },
            FieldInfoData {
                name: "MaxEntitiesUpdatedPerFrame",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AirTargetSelectorEntityData, max_entities_updated_per_frame),
            },
        ],
    }),
    array_type: Some(AIRTARGETSELECTORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AirTargetSelectorEntityData {
    fn type_info() -> &'static TypeInfo {
        AIRTARGETSELECTORENTITYDATA_TYPE_INFO
    }
}


pub const AIRTARGETSELECTORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirTargetSelectorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AirTargetSelectorEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIReadinessLevel {
    #[default]
    RLPatrol = 0,
    RLReady = 1,
    RLCombat = 2,
    RLNone = 3,
}

pub const AIREADINESSLEVEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIReadinessLevel",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIREADINESSLEVEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIReadinessLevel {
    fn type_info() -> &'static TypeInfo {
        AIREADINESSLEVEL_TYPE_INFO
    }
}


pub const AIREADINESSLEVEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIReadinessLevel-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIReadinessLevel-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AirCollisionAvoidanceEntityData {
    pub realm: super::core::Realm,
    pub o_b_b_as_capsule: bool,
    pub player_scale: f32,
    pub o_b_b_scale: f32,
    pub large_o_b_b_scale_treshold: f32,
    pub entity_scale: f32,
    pub max_distance: f32,
    pub ray_length: f32,
    pub same_direction_test_uses_velocity: bool,
    pub ignore_same_direction_objects: bool,
    pub ray_length_same_direction: f32,
    pub prioritize_humans: bool,
    pub auto_activate: bool,
    pub player_extrapolation_time: f32,
    pub use_player_extrapolation: bool,
}

pub const AIRCOLLISIONAVOIDANCEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirCollisionAvoidanceEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, realm),
            },
            FieldInfoData {
                name: "OBBAsCapsule",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, o_b_b_as_capsule),
            },
            FieldInfoData {
                name: "PlayerScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, player_scale),
            },
            FieldInfoData {
                name: "OBBScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, o_b_b_scale),
            },
            FieldInfoData {
                name: "LargeOBBScaleTreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, large_o_b_b_scale_treshold),
            },
            FieldInfoData {
                name: "EntityScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, entity_scale),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, max_distance),
            },
            FieldInfoData {
                name: "RayLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, ray_length),
            },
            FieldInfoData {
                name: "SameDirectionTestUsesVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, same_direction_test_uses_velocity),
            },
            FieldInfoData {
                name: "IgnoreSameDirectionObjects",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, ignore_same_direction_objects),
            },
            FieldInfoData {
                name: "RayLengthSameDirection",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, ray_length_same_direction),
            },
            FieldInfoData {
                name: "PrioritizeHumans",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, prioritize_humans),
            },
            FieldInfoData {
                name: "AutoActivate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, auto_activate),
            },
            FieldInfoData {
                name: "PlayerExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, player_extrapolation_time),
            },
            FieldInfoData {
                name: "UsePlayerExtrapolation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AirCollisionAvoidanceEntityData, use_player_extrapolation),
            },
        ],
    }),
    array_type: Some(AIRCOLLISIONAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AirCollisionAvoidanceEntityData {
    fn type_info() -> &'static TypeInfo {
        AIRCOLLISIONAVOIDANCEENTITYDATA_TYPE_INFO
    }
}


pub const AIRCOLLISIONAVOIDANCEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AirCollisionAvoidanceEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AirCollisionAvoidanceEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIProximityAimingState {
    #[default]
    AIProximityConditionalState_NotAiming = 0,
    AIProximityConditionalState_AimingAtPosition = 1,
    AIProximityConditionalState_AimingAtEntity = 2,
}

pub const AIPROXIMITYAIMINGSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityAimingState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPROXIMITYAIMINGSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIProximityAimingState {
    fn type_info() -> &'static TypeInfo {
        AIPROXIMITYAIMINGSTATE_TYPE_INFO
    }
}


pub const AIPROXIMITYAIMINGSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityAimingState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIProximityAimingState-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIProximityReactionsComponentData {
    pub binding: AIProximityReactionsBinding,
    pub check_alerted_reaction_on_spot_radius: f32,
    pub check_navmesh_in_reaction_direction: bool,
    pub check_navmesh_length: f32,
    pub check_melee_forward_navmesh_length: f32,
    pub min_explosion_impulse_force: f32,
    pub max_explosion_look_distance: f32,
    pub fire_reaction_distance: f32,
    pub drastic_aim_yaw_amount: f32,
    pub allow_impulse_reaction_during_scenario_waypoint: bool,
    pub look_at_human_timing: Vec<LookAtHuman>,
    pub enabled: bool,
    pub enable_friendly_vehicle_kills: bool,
    pub has_available_bayonet: bool,
    pub animation_time_scale_override: f32,
}

pub const AIPROXIMITYREACTIONSCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityReactionsComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: AIPROXIMITYREACTIONSBINDING_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, binding),
            },
            FieldInfoData {
                name: "CheckAlertedReactionOnSpotRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, check_alerted_reaction_on_spot_radius),
            },
            FieldInfoData {
                name: "CheckNavmeshInReactionDirection",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, check_navmesh_in_reaction_direction),
            },
            FieldInfoData {
                name: "CheckNavmeshLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, check_navmesh_length),
            },
            FieldInfoData {
                name: "CheckMeleeForwardNavmeshLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, check_melee_forward_navmesh_length),
            },
            FieldInfoData {
                name: "MinExplosionImpulseForce",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, min_explosion_impulse_force),
            },
            FieldInfoData {
                name: "MaxExplosionLookDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, max_explosion_look_distance),
            },
            FieldInfoData {
                name: "FireReactionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, fire_reaction_distance),
            },
            FieldInfoData {
                name: "DrasticAimYawAmount",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, drastic_aim_yaw_amount),
            },
            FieldInfoData {
                name: "AllowImpulseReactionDuringScenarioWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, allow_impulse_reaction_during_scenario_waypoint),
            },
            FieldInfoData {
                name: "LookAtHumanTiming",
                flags: MemberInfoFlags::new(144),
                field_type: LOOKATHUMAN_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, look_at_human_timing),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, enabled),
            },
            FieldInfoData {
                name: "EnableFriendlyVehicleKills",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, enable_friendly_vehicle_kills),
            },
            FieldInfoData {
                name: "HasAvailableBayonet",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, has_available_bayonet),
            },
            FieldInfoData {
                name: "AnimationTimeScaleOverride",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsComponentData, animation_time_scale_override),
            },
        ],
    }),
    array_type: Some(AIPROXIMITYREACTIONSCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIProximityReactionsComponentData {
    fn type_info() -> &'static TypeInfo {
        AIPROXIMITYREACTIONSCOMPONENTDATA_TYPE_INFO
    }
}


pub const AIPROXIMITYREACTIONSCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityReactionsComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIProximityReactionsComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LookAtHuman {
    pub speed_level: AntSpeedLevel,
    pub delay_min: f32,
    pub delay_max: f32,
    pub length_min: f32,
    pub length_max: f32,
}

pub const LOOKATHUMAN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtHuman",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SpeedLevel",
                flags: MemberInfoFlags::new(0),
                field_type: ANTSPEEDLEVEL_TYPE_INFO,
                rust_offset: offset_of!(LookAtHuman, speed_level),
            },
            FieldInfoData {
                name: "DelayMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LookAtHuman, delay_min),
            },
            FieldInfoData {
                name: "DelayMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LookAtHuman, delay_max),
            },
            FieldInfoData {
                name: "LengthMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LookAtHuman, length_min),
            },
            FieldInfoData {
                name: "LengthMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LookAtHuman, length_max),
            },
        ],
    }),
    array_type: Some(LOOKATHUMAN_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LookAtHuman {
    fn type_info() -> &'static TypeInfo {
        LOOKATHUMAN_TYPE_INFO
    }
}


pub const LOOKATHUMAN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LookAtHuman-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LookAtHuman-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIProximityReactionsBinding {
    pub a_i_reaction: super::ant::AntRef,
    pub a_i_explosion_reaction: super::ant::AntRef,
    pub a_i_explosion_force: super::ant::AntRef,
    pub a_i_stun_reaction: super::ant::AntRef,
    pub a_i_stun_reaction_random_factor: super::ant::AntRef,
    pub a_i_reaction_on_the_spot: super::ant::AntRef,
    pub a_i_reaction_direction: super::ant::AntRef,
    pub is_panicking: super::ant::AntRef,
    pub fire_nearby: super::ant::AntRef,
    pub aim_up_and_down: super::ant::AntRef,
    pub focus_aim_scale: super::ant::AntRef,
    pub focus_aiming: super::ant::AntRef,
    pub enable_procedural_head_aim: super::ant::AntRef,
    pub kill_from_animation: super::ant::AntRef,
    pub player_animation_kill: super::ant::AntRef,
    pub player_initiated_ragdoll: super::ant::AntRef,
    pub a_i_suppressed: super::ant::AntRef,
    pub human_awareness: super::ant::AntRef,
    pub alerted_on_spot: super::ant::AntRef,
    pub human_is_close: super::ant::AntRef,
    pub human_target_yaw: super::ant::AntRef,
    pub human_target_yaw_world_rad: super::ant::AntRef,
    pub look_at_human: super::ant::AntRef,
    pub human_yaw_rad: super::ant::AntRef,
    pub human_pitch: super::ant::AntRef,
    pub retrigger_idle: super::ant::AntRef,
    pub has_wanted_precision: super::ant::AntRef,
    pub target_visible: super::ant::AntRef,
    pub wanted_aim_target_visible: super::ant::AntRef,
    pub target_spotted: super::ant::AntRef,
    pub target_distance: super::ant::AntRef,
    pub cruise_speed_level: super::ant::AntRef,
    pub drastic_aim_yaw_change: super::ant::AntRef,
    pub melee_attack: super::ant::AntRef,
    pub forward_distance_to_obstacle: super::ant::AntRef,
    pub investigate_state: super::ant::AntRef,
    pub new_investigation_started: super::ant::AntRef,
    pub is_investigating: super::ant::AntRef,
    pub is_searching: super::ant::AntRef,
    pub investigate_trigger_type: super::ant::AntRef,
    pub investigate_type: super::ant::AntRef,
    pub investigate_react: super::ant::AntRef,
    pub alerted_position_yaw_rad: super::ant::AntRef,
    pub sustained_fire_spin_up: super::ant::AntRef,
    pub player_is_current_target: super::ant::AntRef,
    pub a_i_allow_fire: super::ant::AntRef,
    pub a_i_alt_fire_from_ant: super::ant::AntRef,
}

pub const AIPROXIMITYREACTIONSBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityReactionsBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AIReaction",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_reaction),
            },
            FieldInfoData {
                name: "AIExplosionReaction",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_explosion_reaction),
            },
            FieldInfoData {
                name: "AIExplosionForce",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_explosion_force),
            },
            FieldInfoData {
                name: "AIStunReaction",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_stun_reaction),
            },
            FieldInfoData {
                name: "AIStunReactionRandomFactor",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_stun_reaction_random_factor),
            },
            FieldInfoData {
                name: "AIReactionOnTheSpot",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_reaction_on_the_spot),
            },
            FieldInfoData {
                name: "AIReactionDirection",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_reaction_direction),
            },
            FieldInfoData {
                name: "IsPanicking",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, is_panicking),
            },
            FieldInfoData {
                name: "FireNearby",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, fire_nearby),
            },
            FieldInfoData {
                name: "AimUpAndDown",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, aim_up_and_down),
            },
            FieldInfoData {
                name: "FocusAimScale",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, focus_aim_scale),
            },
            FieldInfoData {
                name: "FocusAiming",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, focus_aiming),
            },
            FieldInfoData {
                name: "EnableProceduralHeadAim",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, enable_procedural_head_aim),
            },
            FieldInfoData {
                name: "KillFromAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, kill_from_animation),
            },
            FieldInfoData {
                name: "PlayerAnimationKill",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, player_animation_kill),
            },
            FieldInfoData {
                name: "PlayerInitiatedRagdoll",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, player_initiated_ragdoll),
            },
            FieldInfoData {
                name: "AISuppressed",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_suppressed),
            },
            FieldInfoData {
                name: "HumanAwareness",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, human_awareness),
            },
            FieldInfoData {
                name: "AlertedOnSpot",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, alerted_on_spot),
            },
            FieldInfoData {
                name: "HumanIsClose",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, human_is_close),
            },
            FieldInfoData {
                name: "HumanTargetYaw",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, human_target_yaw),
            },
            FieldInfoData {
                name: "HumanTargetYawWorldRad",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, human_target_yaw_world_rad),
            },
            FieldInfoData {
                name: "LookAtHuman",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, look_at_human),
            },
            FieldInfoData {
                name: "HumanYawRad",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, human_yaw_rad),
            },
            FieldInfoData {
                name: "HumanPitch",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, human_pitch),
            },
            FieldInfoData {
                name: "RetriggerIdle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, retrigger_idle),
            },
            FieldInfoData {
                name: "HasWantedPrecision",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, has_wanted_precision),
            },
            FieldInfoData {
                name: "TargetVisible",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, target_visible),
            },
            FieldInfoData {
                name: "WantedAimTargetVisible",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, wanted_aim_target_visible),
            },
            FieldInfoData {
                name: "TargetSpotted",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, target_spotted),
            },
            FieldInfoData {
                name: "TargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, target_distance),
            },
            FieldInfoData {
                name: "CruiseSpeedLevel",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, cruise_speed_level),
            },
            FieldInfoData {
                name: "DrasticAimYawChange",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, drastic_aim_yaw_change),
            },
            FieldInfoData {
                name: "MeleeAttack",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, melee_attack),
            },
            FieldInfoData {
                name: "ForwardDistanceToObstacle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, forward_distance_to_obstacle),
            },
            FieldInfoData {
                name: "InvestigateState",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, investigate_state),
            },
            FieldInfoData {
                name: "NewInvestigationStarted",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, new_investigation_started),
            },
            FieldInfoData {
                name: "IsInvestigating",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, is_investigating),
            },
            FieldInfoData {
                name: "IsSearching",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, is_searching),
            },
            FieldInfoData {
                name: "InvestigateTriggerType",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, investigate_trigger_type),
            },
            FieldInfoData {
                name: "InvestigateType",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, investigate_type),
            },
            FieldInfoData {
                name: "InvestigateReact",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, investigate_react),
            },
            FieldInfoData {
                name: "AlertedPositionYawRad",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, alerted_position_yaw_rad),
            },
            FieldInfoData {
                name: "SustainedFireSpinUp",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, sustained_fire_spin_up),
            },
            FieldInfoData {
                name: "PlayerIsCurrentTarget",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, player_is_current_target),
            },
            FieldInfoData {
                name: "AIAllowFire",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_allow_fire),
            },
            FieldInfoData {
                name: "AIAltFireFromAnt",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIProximityReactionsBinding, a_i_alt_fire_from_ant),
            },
        ],
    }),
    array_type: Some(AIPROXIMITYREACTIONSBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIProximityReactionsBinding {
    fn type_info() -> &'static TypeInfo {
        AIPROXIMITYREACTIONSBINDING_TYPE_INFO
    }
}


pub const AIPROXIMITYREACTIONSBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProximityReactionsBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIProximityReactionsBinding-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIAltFireFromAntState {
    #[default]
    AltFireFromAntState_NoForcedFire = 0,
    AltFireFromAntState_Prepare = 1,
    AltFireFromAntState_ForceFire = 2,
}

pub const AIALTFIREFROMANTSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAltFireFromAntState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIALTFIREFROMANTSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIAltFireFromAntState {
    fn type_info() -> &'static TypeInfo {
        AIALTFIREFROMANTSTATE_TYPE_INFO
    }
}


pub const AIALTFIREFROMANTSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAltFireFromAntState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIAltFireFromAntState-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIStunReactionAnimationType {
    #[default]
    AIStunReactionAnimationType_1 = 0,
    AIStunReactionAnimationType_2 = 1,
    AIStunReactionAnimationType_3 = 2,
    AIStunReactionAnimationType_4 = 3,
    AIStunReactionAnimationType_5 = 4,
    AIStunReactionAnimationType_Count = 5,
}

pub const AISTUNREACTIONANIMATIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStunReactionAnimationType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AISTUNREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIStunReactionAnimationType {
    fn type_info() -> &'static TypeInfo {
        AISTUNREACTIONANIMATIONTYPE_TYPE_INFO
    }
}


pub const AISTUNREACTIONANIMATIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStunReactionAnimationType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIStunReactionAnimationType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIProjectileComponentData {
    pub projectiles: Vec<BattleAIProjectile>,
    pub projectile_gamestates: BattleAIProjectileBinding,
    pub melee_projectile: bool,
    pub use_pre_throw_target_position_as_fallback: bool,
    pub only_use_pre_throw_target_position: bool,
    pub fetch_target_pos_from_comp: bool,
    pub projectile_spawn_bone: super::entity::GameplayBones,
    pub target_position: super::core::Vec3,
    pub target_relative_yaw: f32,
    pub target_is_vulnerable: bool,
    pub projectile_spawn_transform: super::core::LinearTransform,
    pub projectile_index_override: i32,
}

pub const AIPROJECTILECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProjectileComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Projectiles",
                flags: MemberInfoFlags::new(144),
                field_type: BATTLEAIPROJECTILE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, projectiles),
            },
            FieldInfoData {
                name: "ProjectileGamestates",
                flags: MemberInfoFlags::new(0),
                field_type: BATTLEAIPROJECTILEBINDING_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, projectile_gamestates),
            },
            FieldInfoData {
                name: "MeleeProjectile",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, melee_projectile),
            },
            FieldInfoData {
                name: "UsePreThrowTargetPositionAsFallback",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, use_pre_throw_target_position_as_fallback),
            },
            FieldInfoData {
                name: "OnlyUsePreThrowTargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, only_use_pre_throw_target_position),
            },
            FieldInfoData {
                name: "FetchTargetPosFromComp",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, fetch_target_pos_from_comp),
            },
            FieldInfoData {
                name: "ProjectileSpawnBone",
                flags: MemberInfoFlags::new(0),
                field_type: GAMEPLAYBONES_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, projectile_spawn_bone),
            },
            FieldInfoData {
                name: "TargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, target_position),
            },
            FieldInfoData {
                name: "TargetRelativeYaw",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, target_relative_yaw),
            },
            FieldInfoData {
                name: "TargetIsVulnerable",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, target_is_vulnerable),
            },
            FieldInfoData {
                name: "ProjectileSpawnTransform",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, projectile_spawn_transform),
            },
            FieldInfoData {
                name: "ProjectileIndexOverride",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AIProjectileComponentData, projectile_index_override),
            },
        ],
    }),
    array_type: Some(AIPROJECTILECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIProjectileComponentData {
    fn type_info() -> &'static TypeInfo {
        AIPROJECTILECOMPONENTDATA_TYPE_INFO
    }
}


pub const AIPROJECTILECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIProjectileComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIProjectileComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct BattleAIProjectileBinding {
    pub fire_projectile: super::ant::AntRef,
}

pub const BATTLEAIPROJECTILEBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectileBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "FireProjectile",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectileBinding, fire_projectile),
            },
        ],
    }),
    array_type: Some(BATTLEAIPROJECTILEBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BattleAIProjectileBinding {
    fn type_info() -> &'static TypeInfo {
        BATTLEAIPROJECTILEBINDING_TYPE_INFO
    }
}


pub const BATTLEAIPROJECTILEBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectileBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAIProjectileBinding-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BattleAIProjectile {
    pub curve: BattleAIProjectileCurveType,
    pub minimum: LinearTime,
    pub maximum: LinearTime,
    pub dispersion: Dispersion,
    pub projectile: super::weapon_shared::ProjectileBlueprint,
    pub sound: super::audio::SoundAsset,
    pub timer_type: GrenadeTimerType,
    pub vulnerable_target_dispersion: Dispersion,
    pub dispersion_from_behind_angle: f32,
    pub to_target_distance_ratio: f32,
    pub force_min_distance_to_target: f32,
    pub target_prediction_lead_time: f32,
    pub use_target_position_for_lead_time: bool,
    pub max_pre_throw_correction_distance: f32,
    pub validate_trajectory_pre_throw: bool,
    pub validate_trajectory_throw: bool,
    pub use_last_known_position: bool,
    pub skip_range_check: bool,
    pub token_type: GrenadeTokenType,
    pub unlock_asset: super::weapon_shared::WeaponUnlockAsset,
}

pub const BATTLEAIPROJECTILE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectile",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(0),
                field_type: BATTLEAIPROJECTILECURVETYPE_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, curve),
            },
            FieldInfoData {
                name: "Minimum",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTIME_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, minimum),
            },
            FieldInfoData {
                name: "Maximum",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTIME_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, maximum),
            },
            FieldInfoData {
                name: "Dispersion",
                flags: MemberInfoFlags::new(0),
                field_type: DISPERSION_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, dispersion),
            },
            FieldInfoData {
                name: "Projectile",
                flags: MemberInfoFlags::new(0),
                field_type: PROJECTILEBLUEPRINT_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, projectile),
            },
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDASSET_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, sound),
            },
            FieldInfoData {
                name: "TimerType",
                flags: MemberInfoFlags::new(0),
                field_type: GRENADETIMERTYPE_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, timer_type),
            },
            FieldInfoData {
                name: "VulnerableTargetDispersion",
                flags: MemberInfoFlags::new(0),
                field_type: DISPERSION_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, vulnerable_target_dispersion),
            },
            FieldInfoData {
                name: "DispersionFromBehindAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, dispersion_from_behind_angle),
            },
            FieldInfoData {
                name: "ToTargetDistanceRatio",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, to_target_distance_ratio),
            },
            FieldInfoData {
                name: "ForceMinDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, force_min_distance_to_target),
            },
            FieldInfoData {
                name: "TargetPredictionLeadTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, target_prediction_lead_time),
            },
            FieldInfoData {
                name: "UseTargetPositionForLeadTime",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, use_target_position_for_lead_time),
            },
            FieldInfoData {
                name: "MaxPreThrowCorrectionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, max_pre_throw_correction_distance),
            },
            FieldInfoData {
                name: "ValidateTrajectoryPreThrow",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, validate_trajectory_pre_throw),
            },
            FieldInfoData {
                name: "ValidateTrajectoryThrow",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, validate_trajectory_throw),
            },
            FieldInfoData {
                name: "UseLastKnownPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, use_last_known_position),
            },
            FieldInfoData {
                name: "SkipRangeCheck",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, skip_range_check),
            },
            FieldInfoData {
                name: "TokenType",
                flags: MemberInfoFlags::new(0),
                field_type: GRENADETOKENTYPE_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, token_type),
            },
            FieldInfoData {
                name: "UnlockAsset",
                flags: MemberInfoFlags::new(0),
                field_type: WEAPONUNLOCKASSET_TYPE_INFO,
                rust_offset: offset_of!(BattleAIProjectile, unlock_asset),
            },
        ],
    }),
    array_type: Some(BATTLEAIPROJECTILE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BattleAIProjectile {
    fn type_info() -> &'static TypeInfo {
        BATTLEAIPROJECTILE_TYPE_INFO
    }
}


pub const BATTLEAIPROJECTILE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectile-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAIProjectile-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct Dispersion {
    pub minimum_horizontal: f32,
    pub maximum_horizontal: f32,
    pub minimum_vertical: f32,
    pub maximum_vertical: f32,
    pub scaling_distance: f32,
    pub scale_with_distance: bool,
}

pub const DISPERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Dispersion",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MinimumHorizontal",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(Dispersion, minimum_horizontal),
            },
            FieldInfoData {
                name: "MaximumHorizontal",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(Dispersion, maximum_horizontal),
            },
            FieldInfoData {
                name: "MinimumVertical",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(Dispersion, minimum_vertical),
            },
            FieldInfoData {
                name: "MaximumVertical",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(Dispersion, maximum_vertical),
            },
            FieldInfoData {
                name: "ScalingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(Dispersion, scaling_distance),
            },
            FieldInfoData {
                name: "ScaleWithDistance",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(Dispersion, scale_with_distance),
            },
        ],
    }),
    array_type: Some(DISPERSION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Dispersion {
    fn type_info() -> &'static TypeInfo {
        DISPERSION_TYPE_INFO
    }
}


pub const DISPERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Dispersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Dispersion-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum GrenadeTokenType {
    #[default]
    GrenadeTokenType_Frag = 0,
    GrenadeTokenType_AT = 1,
    GrenadeTokenType_Smoke = 2,
    GrenadeTokenType_Incendiary = 3,
    GrenadeTokenType_Gas = 4,
    GrenadeTokenType_Flash = 5,
}

pub const GRENADETOKENTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTokenType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(GRENADETOKENTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GrenadeTokenType {
    fn type_info() -> &'static TypeInfo {
        GRENADETOKENTYPE_TYPE_INFO
    }
}


pub const GRENADETOKENTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTokenType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GrenadeTokenType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum GrenadeTimerType {
    #[default]
    GrenadeTimerType_Grenade = 0,
    GrenadeTimerType_Smoke = 1,
}

pub const GRENADETIMERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTimerType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(GRENADETIMERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GrenadeTimerType {
    fn type_info() -> &'static TypeInfo {
        GRENADETIMERTYPE_TYPE_INFO
    }
}


pub const GRENADETIMERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTimerType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GrenadeTimerType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinearTime {
    pub distance: f32,
    pub time: f32,
}

pub const LINEARTIME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearTime",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LinearTime, distance),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LinearTime, time),
            },
        ],
    }),
    array_type: Some(LINEARTIME_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LinearTime {
    fn type_info() -> &'static TypeInfo {
        LINEARTIME_TYPE_INFO
    }
}


pub const LINEARTIME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearTime-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LinearTime-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum BattleAIProjectileCurveType {
    #[default]
    BattleAIProjectileType_Straight = 0,
    BattleAIProjectileType_Parabolic = 1,
}

pub const BATTLEAIPROJECTILECURVETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectileCurveType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(BATTLEAIPROJECTILECURVETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BattleAIProjectileCurveType {
    fn type_info() -> &'static TypeInfo {
        BATTLEAIPROJECTILECURVETYPE_TYPE_INFO
    }
}


pub const BATTLEAIPROJECTILECURVETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIProjectileCurveType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAIProjectileCurveType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIPhysicsDrivenAnimationEntityData {
    pub bindings: AIPhysicsDrivenAnimationBinding,
    pub loco_shared_bindings: AISharedBinding,
    pub enable: bool,
    pub force_set_transform: bool,
    pub move_speed_state: i32,
    pub target_position: super::core::Vec3,
    pub rotation_speed: f32,
    pub move_speed_scale: f32,
    pub rotation_speed_scale: f32,
    pub start_decel_distance: f32,
    pub stop_physics_loco_distance: f32,
    pub enable_target_tracking: bool,
    pub acceleration: f32,
    pub deceleration: f32,
    pub enter_cover_distance: f32,
    pub rotate_to_cover_distance: f32,
    pub rotate_to_scenario_distance: f32,
    pub face_next_waypoint_distance: f32,
}

pub const AIPHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPhysicsDrivenAnimationEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Bindings",
                flags: MemberInfoFlags::new(0),
                field_type: AIPHYSICSDRIVENANIMATIONBINDING_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, bindings),
            },
            FieldInfoData {
                name: "LocoSharedBindings",
                flags: MemberInfoFlags::new(0),
                field_type: AISHAREDBINDING_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, loco_shared_bindings),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, enable),
            },
            FieldInfoData {
                name: "ForceSetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, force_set_transform),
            },
            FieldInfoData {
                name: "MoveSpeedState",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, move_speed_state),
            },
            FieldInfoData {
                name: "TargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, target_position),
            },
            FieldInfoData {
                name: "RotationSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, rotation_speed),
            },
            FieldInfoData {
                name: "MoveSpeedScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, move_speed_scale),
            },
            FieldInfoData {
                name: "RotationSpeedScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, rotation_speed_scale),
            },
            FieldInfoData {
                name: "StartDecelDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, start_decel_distance),
            },
            FieldInfoData {
                name: "StopPhysicsLocoDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, stop_physics_loco_distance),
            },
            FieldInfoData {
                name: "EnableTargetTracking",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, enable_target_tracking),
            },
            FieldInfoData {
                name: "Acceleration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, acceleration),
            },
            FieldInfoData {
                name: "Deceleration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, deceleration),
            },
            FieldInfoData {
                name: "EnterCoverDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, enter_cover_distance),
            },
            FieldInfoData {
                name: "RotateToCoverDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, rotate_to_cover_distance),
            },
            FieldInfoData {
                name: "RotateToScenarioDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, rotate_to_scenario_distance),
            },
            FieldInfoData {
                name: "FaceNextWaypointDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationEntityData, face_next_waypoint_distance),
            },
        ],
    }),
    array_type: Some(AIPHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIPhysicsDrivenAnimationEntityData {
    fn type_info() -> &'static TypeInfo {
        AIPHYSICSDRIVENANIMATIONENTITYDATA_TYPE_INFO
    }
}


pub const AIPHYSICSDRIVENANIMATIONENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPhysicsDrivenAnimationEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPhysicsDrivenAnimationEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AISharedBinding {
    pub relative_aim: super::ant::AntRef,
    pub desired_steering: super::ant::AntRef,
}

pub const AISHAREDBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISharedBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "RelativeAim",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AISharedBinding, relative_aim),
            },
            FieldInfoData {
                name: "DesiredSteering",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AISharedBinding, desired_steering),
            },
        ],
    }),
    array_type: Some(AISHAREDBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AISharedBinding {
    fn type_info() -> &'static TypeInfo {
        AISHAREDBINDING_TYPE_INFO
    }
}


pub const AISHAREDBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISharedBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISharedBinding-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIPhysicsDrivenAnimationBinding {
    pub is_animation_controlled: super::ant::AntRef,
    pub ant_current_speed: super::ant::AntRef,
    pub translation: super::ant::AntRef,
    pub rotation_quat: super::ant::AntRef,
    pub out_movement_speed: super::ant::AntRef,
    pub out_move: super::ant::AntRef,
    pub out_relative_move: super::ant::AntRef,
    pub out_facing_angle: super::ant::AntRef,
    pub out_relative_facing_angle: super::ant::AntRef,
    pub is_physics_driven_behavior: super::ant::AntRef,
    pub enable_physics_motion: super::ant::AntRef,
    pub enable_steering: super::ant::AntRef,
    pub sprint: super::ant::AntRef,
    pub gun_down: super::ant::AntRef,
    pub gun_down_weight: super::ant::AntRef,
    pub aim_up_and_down: super::ant::AntRef,
    pub ground_normal: super::ant::AntRef,
}

pub const AIPHYSICSDRIVENANIMATIONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPhysicsDrivenAnimationBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "IsAnimationControlled",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, is_animation_controlled),
            },
            FieldInfoData {
                name: "AntCurrentSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, ant_current_speed),
            },
            FieldInfoData {
                name: "Translation",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, translation),
            },
            FieldInfoData {
                name: "RotationQuat",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, rotation_quat),
            },
            FieldInfoData {
                name: "OutMovementSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_movement_speed),
            },
            FieldInfoData {
                name: "OutMove",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_move),
            },
            FieldInfoData {
                name: "OutRelativeMove",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_relative_move),
            },
            FieldInfoData {
                name: "OutFacingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_facing_angle),
            },
            FieldInfoData {
                name: "OutRelativeFacingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, out_relative_facing_angle),
            },
            FieldInfoData {
                name: "IsPhysicsDrivenBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, is_physics_driven_behavior),
            },
            FieldInfoData {
                name: "EnablePhysicsMotion",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, enable_physics_motion),
            },
            FieldInfoData {
                name: "EnableSteering",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, enable_steering),
            },
            FieldInfoData {
                name: "Sprint",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, sprint),
            },
            FieldInfoData {
                name: "GunDown",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, gun_down),
            },
            FieldInfoData {
                name: "GunDownWeight",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, gun_down_weight),
            },
            FieldInfoData {
                name: "AimUpAndDown",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, aim_up_and_down),
            },
            FieldInfoData {
                name: "GroundNormal",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AIPhysicsDrivenAnimationBinding, ground_normal),
            },
        ],
    }),
    array_type: Some(AIPHYSICSDRIVENANIMATIONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIPhysicsDrivenAnimationBinding {
    fn type_info() -> &'static TypeInfo {
        AIPHYSICSDRIVENANIMATIONBINDING_TYPE_INFO
    }
}


pub const AIPHYSICSDRIVENANIMATIONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPhysicsDrivenAnimationBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPhysicsDrivenAnimationBinding-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum PhysicsDrivenCoverState {
    #[default]
    Inactive = 0,
    InCover = 1,
    MoveToCover = 2,
    GetInCover = 3,
}

pub const PHYSICSDRIVENCOVERSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenCoverState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(PHYSICSDRIVENCOVERSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PhysicsDrivenCoverState {
    fn type_info() -> &'static TypeInfo {
        PHYSICSDRIVENCOVERSTATE_TYPE_INFO
    }
}


pub const PHYSICSDRIVENCOVERSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsDrivenCoverState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PhysicsDrivenCoverState-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIPathlinkUsageType {
    #[default]
    AIPathlinkUsageType_Combat = 1,
    AIPathlinkUsageType_NonCombat = 2,
    AIPathlinkUsageType_Any = 65535,
}

pub const AIPATHLINKUSAGETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathlinkUsageType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKUSAGETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathlinkUsageType {
    fn type_info() -> &'static TypeInfo {
        AIPATHLINKUSAGETYPE_TYPE_INFO
    }
}


pub const AIPATHLINKUSAGETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathlinkUsageType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathlinkUsageType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AINavObstaclePenalty {
    #[default]
    AINavObstaclePenalty_None = 0,
    AINavObstaclePenalty_Light = 1,
    AINavObstaclePenalty_Moderate = 2,
    AINavObstaclePenalty_Heavy = 3,
    AINavObstaclePenalty_Max = 4,
    AINavObstaclePenalty_NumTypes = 5,
}

pub const AINAVOBSTACLEPENALTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AINavObstaclePenalty",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AINAVOBSTACLEPENALTY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AINavObstaclePenalty {
    fn type_info() -> &'static TypeInfo {
        AINAVOBSTACLEPENALTY_TYPE_INFO
    }
}


pub const AINAVOBSTACLEPENALTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AINavObstaclePenalty-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AINavObstaclePenalty-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIPathfindingLayer {
    #[default]
    AIPathfindingLayer_All = 4294967295,
    AIPathfindingLayer_Soldier_Default = 0,
    AIPathfindingLayer_Vehicle_Default = 1,
    AIPathfindingLayer_Count = 2,
}

pub const AIPATHFINDINGLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingLayer",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHFINDINGLAYER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathfindingLayer {
    fn type_info() -> &'static TypeInfo {
        AIPATHFINDINGLAYER_TYPE_INFO
    }
}


pub const AIPATHFINDINGLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathfindingLayer-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AISelfDestructEntityData {
    pub self_destruct_count: u32,
    pub self_destruct_delay: f32,
    pub self_destruct_no_l_o_s_delay: f32,
}

pub const AISELFDESTRUCTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISelfDestructEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SelfDestructCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AISelfDestructEntityData, self_destruct_count),
            },
            FieldInfoData {
                name: "SelfDestructDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISelfDestructEntityData, self_destruct_delay),
            },
            FieldInfoData {
                name: "SelfDestructNoLOSDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISelfDestructEntityData, self_destruct_no_l_o_s_delay),
            },
        ],
    }),
    array_type: Some(AISELFDESTRUCTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISelfDestructEntityData {
    fn type_info() -> &'static TypeInfo {
        AISELFDESTRUCTENTITYDATA_TYPE_INFO
    }
}


pub const AISELFDESTRUCTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISelfDestructEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISelfDestructEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AICoverQueryEntityData {
    pub priority: i32,
    pub attack_goal_cover_query: CoverQueryData,
    pub attack_protective_cover_query: CoverQueryData,
    pub attack_hide_cover_query: CoverQueryData,
    pub attack_valid_cover_query: CoverQueryData,
    pub attack_forced_move_cover_query: CoverQueryData,
}

pub const AICOVERQUERYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverQueryEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AICoverQueryEntityData, priority),
            },
            FieldInfoData {
                name: "AttackGoalCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AICoverQueryEntityData, attack_goal_cover_query),
            },
            FieldInfoData {
                name: "AttackProtectiveCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AICoverQueryEntityData, attack_protective_cover_query),
            },
            FieldInfoData {
                name: "AttackHideCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AICoverQueryEntityData, attack_hide_cover_query),
            },
            FieldInfoData {
                name: "AttackValidCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AICoverQueryEntityData, attack_valid_cover_query),
            },
            FieldInfoData {
                name: "AttackForcedMoveCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AICoverQueryEntityData, attack_forced_move_cover_query),
            },
        ],
    }),
    array_type: Some(AICOVERQUERYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICoverQueryEntityData {
    fn type_info() -> &'static TypeInfo {
        AICOVERQUERYENTITYDATA_TYPE_INFO
    }
}


pub const AICOVERQUERYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverQueryEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICoverQueryEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CloakingModifierEntityData {
    pub modifier: SensingAreaModifier,
}

pub const CLOAKINGMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloakingModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Modifier",
                flags: MemberInfoFlags::new(0),
                field_type: SENSINGAREAMODIFIER_TYPE_INFO,
                rust_offset: offset_of!(CloakingModifierEntityData, modifier),
            },
        ],
    }),
    array_type: Some(CLOAKINGMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CloakingModifierEntityData {
    fn type_info() -> &'static TypeInfo {
        CLOAKINGMODIFIERENTITYDATA_TYPE_INFO
    }
}


pub const CLOAKINGMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CloakingModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CloakingModifierEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SensingAreaModifierEntityData {
    pub modifier: SensingAreaModifier,
}

pub const SENSINGAREAMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Modifier",
                flags: MemberInfoFlags::new(0),
                field_type: SENSINGAREAMODIFIER_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierEntityData, modifier),
            },
        ],
    }),
    array_type: Some(SENSINGAREAMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SensingAreaModifierEntityData {
    fn type_info() -> &'static TypeInfo {
        SENSINGAREAMODIFIERENTITYDATA_TYPE_INFO
    }
}


pub const SENSINGAREAMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingAreaModifierEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AISoundAreaEntityData {
}

pub const AISOUNDAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AISOUNDAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISoundAreaEntityData {
    fn type_info() -> &'static TypeInfo {
        AISOUNDAREAENTITYDATA_TYPE_INFO
    }
}


pub const AISOUNDAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISoundAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISoundAreaEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AICombatGroupEntityData {
    pub auto_alert_on_activate: bool,
    pub scripted_alert_location: super::core::LinearTransform,
    pub share_targeting_info: bool,
    pub can_drop_alerted_state: bool,
    pub can_drop_alerted_state_with_alive_enemies: bool,
    pub use_alertness_temperature_settings: bool,
    pub combat_propagation: CombatPropagationSettings,
    pub cover_movement_settings: CombatCoverMovementSettings,
}

pub const AICOMBATGROUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatGroupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AutoAlertOnActivate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatGroupEntityData, auto_alert_on_activate),
            },
            FieldInfoData {
                name: "ScriptedAlertLocation",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(AICombatGroupEntityData, scripted_alert_location),
            },
            FieldInfoData {
                name: "ShareTargetingInfo",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatGroupEntityData, share_targeting_info),
            },
            FieldInfoData {
                name: "CanDropAlertedState",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatGroupEntityData, can_drop_alerted_state),
            },
            FieldInfoData {
                name: "CanDropAlertedStateWithAliveEnemies",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatGroupEntityData, can_drop_alerted_state_with_alive_enemies),
            },
            FieldInfoData {
                name: "UseAlertnessTemperatureSettings",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatGroupEntityData, use_alertness_temperature_settings),
            },
            FieldInfoData {
                name: "CombatPropagation",
                flags: MemberInfoFlags::new(0),
                field_type: COMBATPROPAGATIONSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AICombatGroupEntityData, combat_propagation),
            },
            FieldInfoData {
                name: "CoverMovementSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COMBATCOVERMOVEMENTSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AICombatGroupEntityData, cover_movement_settings),
            },
        ],
    }),
    array_type: Some(AICOMBATGROUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AICombatGroupEntityData {
    fn type_info() -> &'static TypeInfo {
        AICOMBATGROUPENTITYDATA_TYPE_INFO
    }
}


pub const AICOMBATGROUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatGroupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICombatGroupEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CombatCoverMovementSettings {
    pub movement_token_count: u32,
    pub min_token_cooldown: f32,
    pub max_token_cooldown: f32,
    pub soldier_move_global_token_cooldown_increment: f32,
    pub soldier_min_time_in_cover: f32,
}

pub const COMBATCOVERMOVEMENTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatCoverMovementSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MovementTokenCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(CombatCoverMovementSettings, movement_token_count),
            },
            FieldInfoData {
                name: "MinTokenCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatCoverMovementSettings, min_token_cooldown),
            },
            FieldInfoData {
                name: "MaxTokenCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatCoverMovementSettings, max_token_cooldown),
            },
            FieldInfoData {
                name: "SoldierMoveGlobalTokenCooldownIncrement",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatCoverMovementSettings, soldier_move_global_token_cooldown_increment),
            },
            FieldInfoData {
                name: "SoldierMinTimeInCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatCoverMovementSettings, soldier_min_time_in_cover),
            },
        ],
    }),
    array_type: Some(COMBATCOVERMOVEMENTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CombatCoverMovementSettings {
    fn type_info() -> &'static TypeInfo {
        COMBATCOVERMOVEMENTSETTINGS_TYPE_INFO
    }
}


pub const COMBATCOVERMOVEMENTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatCoverMovementSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CombatCoverMovementSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CombatPropagationSettings {
    pub default_sound: AISound,
    pub interpolated_sound: AISound,
    pub interpolation_start_time: f32,
    pub interpolation_time: f32,
}

pub const COMBATPROPAGATIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatPropagationSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DefaultSound",
                flags: MemberInfoFlags::new(0),
                field_type: AISOUND_TYPE_INFO,
                rust_offset: offset_of!(CombatPropagationSettings, default_sound),
            },
            FieldInfoData {
                name: "InterpolatedSound",
                flags: MemberInfoFlags::new(0),
                field_type: AISOUND_TYPE_INFO,
                rust_offset: offset_of!(CombatPropagationSettings, interpolated_sound),
            },
            FieldInfoData {
                name: "InterpolationStartTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatPropagationSettings, interpolation_start_time),
            },
            FieldInfoData {
                name: "InterpolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatPropagationSettings, interpolation_time),
            },
        ],
    }),
    array_type: Some(COMBATPROPAGATIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CombatPropagationSettings {
    fn type_info() -> &'static TypeInfo {
        COMBATPROPAGATIONSETTINGS_TYPE_INFO
    }
}


pub const COMBATPROPAGATIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatPropagationSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CombatPropagationSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AITacticEntityData {
    pub tactic: TacticsEnumeration,
}

pub const AITACTICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITacticEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Tactic",
                flags: MemberInfoFlags::new(0),
                field_type: TACTICSENUMERATION_TYPE_INFO,
                rust_offset: offset_of!(AITacticEntityData, tactic),
            },
        ],
    }),
    array_type: Some(AITACTICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITacticEntityData {
    fn type_info() -> &'static TypeInfo {
        AITACTICENTITYDATA_TYPE_INFO
    }
}


pub const AITACTICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITacticEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITacticEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIShootAtTargetsEntityData {
    pub shoot_type: AIShootType,
    pub cycle_targets: bool,
    pub random_target_order: bool,
    pub combat_intensity: AICombatIntensity,
    pub disable_on_soldier_engaged: bool,
    pub target_weight_multiplier: f32,
}

pub const AISHOOTATTARGETSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIShootAtTargetsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ShootType",
                flags: MemberInfoFlags::new(0),
                field_type: AISHOOTTYPE_TYPE_INFO,
                rust_offset: offset_of!(AIShootAtTargetsEntityData, shoot_type),
            },
            FieldInfoData {
                name: "CycleTargets",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIShootAtTargetsEntityData, cycle_targets),
            },
            FieldInfoData {
                name: "RandomTargetOrder",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIShootAtTargetsEntityData, random_target_order),
            },
            FieldInfoData {
                name: "CombatIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: AICOMBATINTENSITY_TYPE_INFO,
                rust_offset: offset_of!(AIShootAtTargetsEntityData, combat_intensity),
            },
            FieldInfoData {
                name: "DisableOnSoldierEngaged",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIShootAtTargetsEntityData, disable_on_soldier_engaged),
            },
            FieldInfoData {
                name: "TargetWeightMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIShootAtTargetsEntityData, target_weight_multiplier),
            },
        ],
    }),
    array_type: Some(AISHOOTATTARGETSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIShootAtTargetsEntityData {
    fn type_info() -> &'static TypeInfo {
        AISHOOTATTARGETSENTITYDATA_TYPE_INFO
    }
}


pub const AISHOOTATTARGETSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIShootAtTargetsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIShootAtTargetsEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIPointTargetData {
}

pub const AIPOINTTARGETDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPointTargetData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AIPOINTTARGETDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIPointTargetData {
    fn type_info() -> &'static TypeInfo {
        AIPOINTTARGETDATA_TYPE_INFO
    }
}


pub const AIPOINTTARGETDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPointTargetData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPointTargetData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIUseWaypointsEntityData {
    pub waypoint_transform: super::core::LinearTransform,
    pub type_of_route: super::pathfinding_shared::RouteType,
    pub start_at_geometrically_closest_waypoint: bool,
    pub path_finding: super::pathfinding_shared::PathfindingChoice,
    pub pathlink_usage_type: AIPathlinkUsageType,
    pub priority: ExecutionPriority,
    pub tactic_condition: TacticsEnumeration,
    pub allow_a_i_control_after_destination_reached: bool,
    pub use_physics_driven_locomotion: bool,
}

pub const AIUSEWAYPOINTSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIUseWaypointsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "WaypointTransform",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(AIUseWaypointsEntityData, waypoint_transform),
            },
            FieldInfoData {
                name: "TypeOfRoute",
                flags: MemberInfoFlags::new(0),
                field_type: ROUTETYPE_TYPE_INFO,
                rust_offset: offset_of!(AIUseWaypointsEntityData, type_of_route),
            },
            FieldInfoData {
                name: "StartAtGeometricallyClosestWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIUseWaypointsEntityData, start_at_geometrically_closest_waypoint),
            },
            FieldInfoData {
                name: "PathFinding",
                flags: MemberInfoFlags::new(0),
                field_type: PATHFINDINGCHOICE_TYPE_INFO,
                rust_offset: offset_of!(AIUseWaypointsEntityData, path_finding),
            },
            FieldInfoData {
                name: "PathlinkUsageType",
                flags: MemberInfoFlags::new(0),
                field_type: AIPATHLINKUSAGETYPE_TYPE_INFO,
                rust_offset: offset_of!(AIUseWaypointsEntityData, pathlink_usage_type),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: EXECUTIONPRIORITY_TYPE_INFO,
                rust_offset: offset_of!(AIUseWaypointsEntityData, priority),
            },
            FieldInfoData {
                name: "TacticCondition",
                flags: MemberInfoFlags::new(0),
                field_type: TACTICSENUMERATION_TYPE_INFO,
                rust_offset: offset_of!(AIUseWaypointsEntityData, tactic_condition),
            },
            FieldInfoData {
                name: "AllowAIControlAfterDestinationReached",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIUseWaypointsEntityData, allow_a_i_control_after_destination_reached),
            },
            FieldInfoData {
                name: "UsePhysicsDrivenLocomotion",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIUseWaypointsEntityData, use_physics_driven_locomotion),
            },
        ],
    }),
    array_type: Some(AIUSEWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIUseWaypointsEntityData {
    fn type_info() -> &'static TypeInfo {
        AIUSEWAYPOINTSENTITYDATA_TYPE_INFO
    }
}


pub const AIUSEWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIUseWaypointsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIUseWaypointsEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIUseCoverEntityData {
    pub cover_slot_index: i32,
    pub is_scripted_to_cover: bool,
    pub cover_transform: super::core::LinearTransform,
}

pub const AIUSECOVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIUseCoverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CoverSlotIndex",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AIUseCoverEntityData, cover_slot_index),
            },
            FieldInfoData {
                name: "IsScriptedToCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIUseCoverEntityData, is_scripted_to_cover),
            },
            FieldInfoData {
                name: "CoverTransform",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(AIUseCoverEntityData, cover_transform),
            },
        ],
    }),
    array_type: Some(AIUSECOVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIUseCoverEntityData {
    fn type_info() -> &'static TypeInfo {
        AIUSECOVERENTITYDATA_TYPE_INFO
    }
}


pub const AIUSECOVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIUseCoverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIUseCoverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AICoverZonesOverrideEntityData {
    pub cover_zones: CoverZones,
}

pub const AICOVERZONESOVERRIDEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverZonesOverrideEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CoverZones",
                flags: MemberInfoFlags::new(0),
                field_type: COVERZONES_TYPE_INFO,
                rust_offset: offset_of!(AICoverZonesOverrideEntityData, cover_zones),
            },
        ],
    }),
    array_type: Some(AICOVERZONESOVERRIDEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICoverZonesOverrideEntityData {
    fn type_info() -> &'static TypeInfo {
        AICOVERZONESOVERRIDEENTITYDATA_TYPE_INFO
    }
}


pub const AICOVERZONESOVERRIDEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverZonesOverrideEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICoverZonesOverrideEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIAwarenessEntityData {
    pub enable_alertness_states: bool,
    pub enable_sounds: bool,
}

pub const AIAWARENESSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAwarenessEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EnableAlertnessStates",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIAwarenessEntityData, enable_alertness_states),
            },
            FieldInfoData {
                name: "EnableSounds",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIAwarenessEntityData, enable_sounds),
            },
        ],
    }),
    array_type: Some(AIAWARENESSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIAwarenessEntityData {
    fn type_info() -> &'static TypeInfo {
        AIAWARENESSENTITYDATA_TYPE_INFO
    }
}


pub const AIAWARENESSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAwarenessEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIAwarenessEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIWeaponSlotOverrideEntityData {
    pub weapon_slot: i32,
}

pub const AIWEAPONSLOTOVERRIDEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponSlotOverrideEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "WeaponSlot",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponSlotOverrideEntityData, weapon_slot),
            },
        ],
    }),
    array_type: Some(AIWEAPONSLOTOVERRIDEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIWeaponSlotOverrideEntityData {
    fn type_info() -> &'static TypeInfo {
        AIWEAPONSLOTOVERRIDEENTITYDATA_TYPE_INFO
    }
}


pub const AIWEAPONSLOTOVERRIDEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponSlotOverrideEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIWeaponSlotOverrideEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIWeaponOverrideEntityData {
    pub weapon_data: super::gameplay_sim::GameAIWeaponData,
}

pub const AIWEAPONOVERRIDEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponOverrideEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "WeaponData",
                flags: MemberInfoFlags::new(0),
                field_type: GAMEAIWEAPONDATA_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponOverrideEntityData, weapon_data),
            },
        ],
    }),
    array_type: Some(AIWEAPONOVERRIDEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIWeaponOverrideEntityData {
    fn type_info() -> &'static TypeInfo {
        AIWEAPONOVERRIDEENTITYDATA_TYPE_INFO
    }
}


pub const AIWEAPONOVERRIDEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponOverrideEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIWeaponOverrideEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIVehicleBehaviorEntityData {
    pub prevent_vehicle_usage: bool,
}

pub const AIVEHICLEBEHAVIORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleBehaviorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "PreventVehicleUsage",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleBehaviorEntityData, prevent_vehicle_usage),
            },
        ],
    }),
    array_type: Some(AIVEHICLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIVehicleBehaviorEntityData {
    fn type_info() -> &'static TypeInfo {
        AIVEHICLEBEHAVIORENTITYDATA_TYPE_INFO
    }
}


pub const AIVEHICLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleBehaviorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIVehicleBehaviorEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AITargetingEntityData {
    pub human_target_preference: f32,
    pub threat_distance_multiplier: f32,
    pub is_target: bool,
}

pub const AITARGETINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "HumanTargetPreference",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AITargetingEntityData, human_target_preference),
            },
            FieldInfoData {
                name: "ThreatDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AITargetingEntityData, threat_distance_multiplier),
            },
            FieldInfoData {
                name: "IsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITargetingEntityData, is_target),
            },
        ],
    }),
    array_type: Some(AITARGETINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITargetingEntityData {
    fn type_info() -> &'static TypeInfo {
        AITARGETINGENTITYDATA_TYPE_INFO
    }
}


pub const AITARGETINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITargetingEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AICombatBehaviorEntityData {
    pub allow_fire: bool,
    pub allow_fire_during_scripted_animations: bool,
    pub allow_detect_players: bool,
    pub is_on_human_squad: bool,
    pub try_advance_even_if_already_in_weapon_range: bool,
    pub allow_targeting_unaware_enemies: bool,
    pub combat_environment: CombatEnvironment,
}

pub const AICOMBATBEHAVIORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatBehaviorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AllowFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatBehaviorEntityData, allow_fire),
            },
            FieldInfoData {
                name: "AllowFireDuringScriptedAnimations",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatBehaviorEntityData, allow_fire_during_scripted_animations),
            },
            FieldInfoData {
                name: "AllowDetectPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatBehaviorEntityData, allow_detect_players),
            },
            FieldInfoData {
                name: "IsOnHumanSquad",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatBehaviorEntityData, is_on_human_squad),
            },
            FieldInfoData {
                name: "TryAdvanceEvenIfAlreadyInWeaponRange",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatBehaviorEntityData, try_advance_even_if_already_in_weapon_range),
            },
            FieldInfoData {
                name: "AllowTargetingUnawareEnemies",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICombatBehaviorEntityData, allow_targeting_unaware_enemies),
            },
            FieldInfoData {
                name: "CombatEnvironment",
                flags: MemberInfoFlags::new(0),
                field_type: COMBATENVIRONMENT_TYPE_INFO,
                rust_offset: offset_of!(AICombatBehaviorEntityData, combat_environment),
            },
        ],
    }),
    array_type: Some(AICOMBATBEHAVIORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICombatBehaviorEntityData {
    fn type_info() -> &'static TypeInfo {
        AICOMBATBEHAVIORENTITYDATA_TYPE_INFO
    }
}


pub const AICOMBATBEHAVIORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatBehaviorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICombatBehaviorEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIForbiddenAreaEntityData {
}

pub const AIFORBIDDENAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIForbiddenAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AIFORBIDDENAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIForbiddenAreaEntityData {
    fn type_info() -> &'static TypeInfo {
        AIFORBIDDENAREAENTITYDATA_TYPE_INFO
    }
}


pub const AIFORBIDDENAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIForbiddenAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIForbiddenAreaEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIFollowAreaEntityData {
}

pub const AIFOLLOWAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AIFOLLOWAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFollowAreaEntityData {
    fn type_info() -> &'static TypeInfo {
        AIFOLLOWAREAENTITYDATA_TYPE_INFO
    }
}


pub const AIFOLLOWAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowAreaEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIFriendlyAreaEntityData {
}

pub const AIFRIENDLYAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFriendlyAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AIFRIENDLYAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFriendlyAreaEntityData {
    fn type_info() -> &'static TypeInfo {
        AIFRIENDLYAREAENTITYDATA_TYPE_INFO
    }
}


pub const AIFRIENDLYAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFriendlyAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFriendlyAreaEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIFlankingCorridorEntityData {
    pub advance_count: i32,
    pub advance_interval: f32,
    pub human_target_distance: f32,
    pub allow_leaving_flanking_corridor: bool,
}

pub const AIFLANKINGCORRIDORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFlankingCorridorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AdvanceCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AIFlankingCorridorEntityData, advance_count),
            },
            FieldInfoData {
                name: "AdvanceInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFlankingCorridorEntityData, advance_interval),
            },
            FieldInfoData {
                name: "HumanTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFlankingCorridorEntityData, human_target_distance),
            },
            FieldInfoData {
                name: "AllowLeavingFlankingCorridor",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIFlankingCorridorEntityData, allow_leaving_flanking_corridor),
            },
        ],
    }),
    array_type: Some(AIFLANKINGCORRIDORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFlankingCorridorEntityData {
    fn type_info() -> &'static TypeInfo {
        AIFLANKINGCORRIDORENTITYDATA_TYPE_INFO
    }
}


pub const AIFLANKINGCORRIDORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFlankingCorridorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFlankingCorridorEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AISearchAreaEntityData {
}

pub const AISEARCHAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISearchAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AISEARCHAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISearchAreaEntityData {
    fn type_info() -> &'static TypeInfo {
        AISEARCHAREAENTITYDATA_TYPE_INFO
    }
}


pub const AISEARCHAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISearchAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISearchAreaEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIDefendAreaEntityData {
    pub follow_object_attract_radius: f32,
}

pub const AIDEFENDAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDefendAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FollowObjectAttractRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIDefendAreaEntityData, follow_object_attract_radius),
            },
        ],
    }),
    array_type: Some(AIDEFENDAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIDefendAreaEntityData {
    fn type_info() -> &'static TypeInfo {
        AIDEFENDAREAENTITYDATA_TYPE_INFO
    }
}


pub const AIDEFENDAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDefendAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIDefendAreaEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AITargetCoordinatorFilterEntityData {
    pub template_filters: Vec<TargetCoordinatorFilter>,
}

pub const AITARGETCOORDINATORFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetCoordinatorFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "TemplateFilters",
                flags: MemberInfoFlags::new(144),
                field_type: TARGETCOORDINATORFILTER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AITargetCoordinatorFilterEntityData, template_filters),
            },
        ],
    }),
    array_type: Some(AITARGETCOORDINATORFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITargetCoordinatorFilterEntityData {
    fn type_info() -> &'static TypeInfo {
        AITARGETCOORDINATORFILTERENTITYDATA_TYPE_INFO
    }
}


pub const AITARGETCOORDINATORFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetCoordinatorFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITargetCoordinatorFilterEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct TargetCoordinatorFilter {
    pub template: super::game_shared::CharacterSpawnTemplateData,
    pub max_attackers: i32,
    pub action_on_filtered: TargetCoordinatorFilterAction,
}

pub const TARGETCOORDINATORFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinatorFilter",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Template",
                flags: MemberInfoFlags::new(0),
                field_type: CHARACTERSPAWNTEMPLATEDATA_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinatorFilter, template),
            },
            FieldInfoData {
                name: "MaxAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinatorFilter, max_attackers),
            },
            FieldInfoData {
                name: "ActionOnFiltered",
                flags: MemberInfoFlags::new(0),
                field_type: TARGETCOORDINATORFILTERACTION_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinatorFilter, action_on_filtered),
            },
        ],
    }),
    array_type: Some(TARGETCOORDINATORFILTER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TargetCoordinatorFilter {
    fn type_info() -> &'static TypeInfo {
        TARGETCOORDINATORFILTER_TYPE_INFO
    }
}


pub const TARGETCOORDINATORFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinatorFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetCoordinatorFilter-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum TargetCoordinatorFilterAction {
    #[default]
    TargetCoordinatorFilterAction_Miss = 0,
    TargetCoordinatorFilterAction_HoldFire = 1,
    TargetCoordinatorFilterAction_Hide = 2,
}

pub const TARGETCOORDINATORFILTERACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinatorFilterAction",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(TARGETCOORDINATORFILTERACTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TargetCoordinatorFilterAction {
    fn type_info() -> &'static TypeInfo {
        TARGETCOORDINATORFILTERACTION_TYPE_INFO
    }
}


pub const TARGETCOORDINATORFILTERACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinatorFilterAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetCoordinatorFilterAction-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AITargetCoordinatorEntityData {
    pub max_attackers: i32,
    pub max_attackers_deliberate_miss: i32,
    pub attacker_threshold: i32,
    pub use_fov: bool,
    pub use_enhanced_coordination: bool,
    pub attacker_randomness: f32,
    pub refuse_out_of_sight_attackers: bool,
}

pub const AITARGETCOORDINATORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetCoordinatorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MaxAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AITargetCoordinatorEntityData, max_attackers),
            },
            FieldInfoData {
                name: "MaxAttackersDeliberateMiss",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AITargetCoordinatorEntityData, max_attackers_deliberate_miss),
            },
            FieldInfoData {
                name: "AttackerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AITargetCoordinatorEntityData, attacker_threshold),
            },
            FieldInfoData {
                name: "UseFov",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITargetCoordinatorEntityData, use_fov),
            },
            FieldInfoData {
                name: "UseEnhancedCoordination",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITargetCoordinatorEntityData, use_enhanced_coordination),
            },
            FieldInfoData {
                name: "AttackerRandomness",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AITargetCoordinatorEntityData, attacker_randomness),
            },
            FieldInfoData {
                name: "RefuseOutOfSightAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITargetCoordinatorEntityData, refuse_out_of_sight_attackers),
            },
        ],
    }),
    array_type: Some(AITARGETCOORDINATORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITargetCoordinatorEntityData {
    fn type_info() -> &'static TypeInfo {
        AITARGETCOORDINATORENTITYDATA_TYPE_INFO
    }
}


pub const AITARGETCOORDINATORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetCoordinatorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITargetCoordinatorEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIStealthEntityData {
    pub enemey_too_close_distance: f32,
    pub extra_buffer_distance_to_resume_stealth: f32,
    pub only_be_stealthy_if_aware_of_enemies: bool,
    pub only_be_stealthy_if_target_not_alerted: bool,
    pub is_invisible_while_stealthy: bool,
}

pub const AISTEALTHENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStealthEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EnemeyTooCloseDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIStealthEntityData, enemey_too_close_distance),
            },
            FieldInfoData {
                name: "ExtraBufferDistanceToResumeStealth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIStealthEntityData, extra_buffer_distance_to_resume_stealth),
            },
            FieldInfoData {
                name: "OnlyBeStealthyIfAwareOfEnemies",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIStealthEntityData, only_be_stealthy_if_aware_of_enemies),
            },
            FieldInfoData {
                name: "OnlyBeStealthyIfTargetNotAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIStealthEntityData, only_be_stealthy_if_target_not_alerted),
            },
            FieldInfoData {
                name: "IsInvisibleWhileStealthy",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIStealthEntityData, is_invisible_while_stealthy),
            },
        ],
    }),
    array_type: Some(AISTEALTHENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIStealthEntityData {
    fn type_info() -> &'static TypeInfo {
        AISTEALTHENTITYDATA_TYPE_INFO
    }
}


pub const AISTEALTHENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStealthEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIStealthEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIBuddyFollowEntityData {
    pub slot_count: u32,
    pub follow_distance: f32,
    pub closest_distance: f32,
    pub start_moving_max_dist_outside_follow_dist: f32,
    pub start_moving_max_dist_from_slot: f32,
    pub reached_slot_distance: f32,
    pub max_slot_assignment_distance_in: f32,
    pub max_slot_assignment_distance_out: f32,
    pub max_slot_assignment_vertical_distance: f32,
    pub preferred_slot_arcs: Vec<BuddyFollowPreferredSlotArc>,
    pub use_velocity_for_forward_direction: bool,
    pub align_slots_with_forward_direction: bool,
    pub forward_direction_smoothing: BuddyFollowDirectionSmoothingData,
    pub slot_scoring_data: BuddyFollowSlotScoringData,
    pub pose_matching_max_distance: f32,
    pub pose_match_min_delay: f32,
    pub pose_match_max_delay: f32,
}

pub const AIBUDDYFOLLOWENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBuddyFollowEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SlotCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, slot_count),
            },
            FieldInfoData {
                name: "FollowDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, follow_distance),
            },
            FieldInfoData {
                name: "ClosestDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, closest_distance),
            },
            FieldInfoData {
                name: "StartMovingMaxDistOutsideFollowDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, start_moving_max_dist_outside_follow_dist),
            },
            FieldInfoData {
                name: "StartMovingMaxDistFromSlot",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, start_moving_max_dist_from_slot),
            },
            FieldInfoData {
                name: "ReachedSlotDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, reached_slot_distance),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentDistanceIn",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, max_slot_assignment_distance_in),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentDistanceOut",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, max_slot_assignment_distance_out),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentVerticalDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, max_slot_assignment_vertical_distance),
            },
            FieldInfoData {
                name: "PreferredSlotArcs",
                flags: MemberInfoFlags::new(144),
                field_type: BUDDYFOLLOWPREFERREDSLOTARC_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, preferred_slot_arcs),
            },
            FieldInfoData {
                name: "UseVelocityForForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, use_velocity_for_forward_direction),
            },
            FieldInfoData {
                name: "AlignSlotsWithForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, align_slots_with_forward_direction),
            },
            FieldInfoData {
                name: "ForwardDirectionSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, forward_direction_smoothing),
            },
            FieldInfoData {
                name: "SlotScoringData",
                flags: MemberInfoFlags::new(0),
                field_type: BUDDYFOLLOWSLOTSCORINGDATA_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, slot_scoring_data),
            },
            FieldInfoData {
                name: "PoseMatchingMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, pose_matching_max_distance),
            },
            FieldInfoData {
                name: "PoseMatchMinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, pose_match_min_delay),
            },
            FieldInfoData {
                name: "PoseMatchMaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBuddyFollowEntityData, pose_match_max_delay),
            },
        ],
    }),
    array_type: Some(AIBUDDYFOLLOWENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIBuddyFollowEntityData {
    fn type_info() -> &'static TypeInfo {
        AIBUDDYFOLLOWENTITYDATA_TYPE_INFO
    }
}


pub const AIBUDDYFOLLOWENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBuddyFollowEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIBuddyFollowEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BuddyFollowDirectionSmoothingData {
    pub linear_speed_to_angular_speed_max: f32,
    pub linear_speed_lower_threshold: f32,
    pub linear_speed_upper_threshold: f32,
    pub move_distance_to_angular_speed_max: f32,
    pub move_distance_lower_threshold: f32,
    pub move_distance_upper_threshold: f32,
}

pub const BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowDirectionSmoothingData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "LinearSpeedToAngularSpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, linear_speed_to_angular_speed_max),
            },
            FieldInfoData {
                name: "LinearSpeedLowerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, linear_speed_lower_threshold),
            },
            FieldInfoData {
                name: "LinearSpeedUpperThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, linear_speed_upper_threshold),
            },
            FieldInfoData {
                name: "MoveDistanceToAngularSpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, move_distance_to_angular_speed_max),
            },
            FieldInfoData {
                name: "MoveDistanceLowerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, move_distance_lower_threshold),
            },
            FieldInfoData {
                name: "MoveDistanceUpperThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowDirectionSmoothingData, move_distance_upper_threshold),
            },
        ],
    }),
    array_type: Some(BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BuddyFollowDirectionSmoothingData {
    fn type_info() -> &'static TypeInfo {
        BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_TYPE_INFO
    }
}


pub const BUDDYFOLLOWDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowDirectionSmoothingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BuddyFollowDirectionSmoothingData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BuddyFollowPreferredSlotArc {
    pub center: f32,
    pub extent: f32,
    pub cost: f32,
}

pub const BUDDYFOLLOWPREFERREDSLOTARC_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowPreferredSlotArc",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowPreferredSlotArc, center),
            },
            FieldInfoData {
                name: "Extent",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowPreferredSlotArc, extent),
            },
            FieldInfoData {
                name: "Cost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowPreferredSlotArc, cost),
            },
        ],
    }),
    array_type: Some(BUDDYFOLLOWPREFERREDSLOTARC_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BuddyFollowPreferredSlotArc {
    fn type_info() -> &'static TypeInfo {
        BUDDYFOLLOWPREFERREDSLOTARC_TYPE_INFO
    }
}


pub const BUDDYFOLLOWPREFERREDSLOTARC_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowPreferredSlotArc-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BuddyFollowPreferredSlotArc-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BuddyFollowSlotScoringData {
    pub slot_distance_max_cost: f32,
    pub future_occluded_cost: f32,
    pub future_colliding_cost: f32,
    pub distance_to_slot_cost_per_meter: f32,
    pub slot_stickyness_cost: f32,
}

pub const BUDDYFOLLOWSLOTSCORINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowSlotScoringData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SlotDistanceMaxCost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowSlotScoringData, slot_distance_max_cost),
            },
            FieldInfoData {
                name: "FutureOccludedCost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowSlotScoringData, future_occluded_cost),
            },
            FieldInfoData {
                name: "FutureCollidingCost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowSlotScoringData, future_colliding_cost),
            },
            FieldInfoData {
                name: "DistanceToSlotCostPerMeter",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowSlotScoringData, distance_to_slot_cost_per_meter),
            },
            FieldInfoData {
                name: "SlotStickynessCost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BuddyFollowSlotScoringData, slot_stickyness_cost),
            },
        ],
    }),
    array_type: Some(BUDDYFOLLOWSLOTSCORINGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BuddyFollowSlotScoringData {
    fn type_info() -> &'static TypeInfo {
        BUDDYFOLLOWSLOTSCORINGDATA_TYPE_INFO
    }
}


pub const BUDDYFOLLOWSLOTSCORINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BuddyFollowSlotScoringData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BuddyFollowSlotScoringData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIFollowObjectEntityData {
    pub go_to_position: super::core::LinearTransform,
    pub config: AIFollowObjectConfigAsset,
}

pub const AIFOLLOWOBJECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "GoToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectEntityData, go_to_position),
            },
            FieldInfoData {
                name: "Config",
                flags: MemberInfoFlags::new(0),
                field_type: AIFOLLOWOBJECTCONFIGASSET_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectEntityData, config),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIFollowObjectEntityData {
    fn type_info() -> &'static TypeInfo {
        AIFOLLOWOBJECTENTITYDATA_TYPE_INFO
    }
}


pub const AIFOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIFollowObjectConfigAsset {
    pub slot_config: FollowObjectSlotConfig,
    pub move_params: FollowObjectMoveParams,
    pub sustained_movement_params: FollowObjectSustainedMovementParams,
    pub reticle_avoidance_params: FollowObjectReticleAvoidanceParams,
    pub min_follower_dist_to_check_teleport: f32,
}

pub const AIFOLLOWOBJECTCONFIGASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectConfigAsset",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINERPOLICYASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SlotConfig",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWOBJECTSLOTCONFIG_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectConfigAsset, slot_config),
            },
            FieldInfoData {
                name: "MoveParams",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWOBJECTMOVEPARAMS_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectConfigAsset, move_params),
            },
            FieldInfoData {
                name: "SustainedMovementParams",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectConfigAsset, sustained_movement_params),
            },
            FieldInfoData {
                name: "ReticleAvoidanceParams",
                flags: MemberInfoFlags::new(0),
                field_type: FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectConfigAsset, reticle_avoidance_params),
            },
            FieldInfoData {
                name: "MinFollowerDistToCheckTeleport",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectConfigAsset, min_follower_dist_to_check_teleport),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTCONFIGASSET_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIFollowObjectConfigAsset {
    fn type_info() -> &'static TypeInfo {
        AIFOLLOWOBJECTCONFIGASSET_TYPE_INFO
    }
}


pub const AIFOLLOWOBJECTCONFIGASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectConfigAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectConfigAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowObjectReticleAvoidanceParams {
    pub enabled: bool,
    pub max_aim_angle_to_enemy: f32,
    pub min_aim_cos_angle_to_enemy: f32,
    pub max_distance_to_enemy: f32,
    pub max_distance_to_follower: f32,
    pub follower_bounds_expansion: super::core::Vec3,
    pub predict_future_blocking_look_ahead_time: f32,
}

pub const FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectReticleAvoidanceParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, enabled),
            },
            FieldInfoData {
                name: "MaxAimAngleToEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, max_aim_angle_to_enemy),
            },
            FieldInfoData {
                name: "MinAimCosAngleToEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, min_aim_cos_angle_to_enemy),
            },
            FieldInfoData {
                name: "MaxDistanceToEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, max_distance_to_enemy),
            },
            FieldInfoData {
                name: "MaxDistanceToFollower",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, max_distance_to_follower),
            },
            FieldInfoData {
                name: "FollowerBoundsExpansion",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, follower_bounds_expansion),
            },
            FieldInfoData {
                name: "PredictFutureBlockingLookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectReticleAvoidanceParams, predict_future_blocking_look_ahead_time),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FollowObjectReticleAvoidanceParams {
    fn type_info() -> &'static TypeInfo {
        FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_TYPE_INFO
    }
}


pub const FOLLOWOBJECTRETICLEAVOIDANCEPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectReticleAvoidanceParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectReticleAvoidanceParams-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowObjectSustainedMovementParams {
    pub min_move_speed_sustain: f32,
    pub max_move_speed_release: f32,
    pub min_sustain_time: f32,
    pub min_release_time: f32,
}

pub const FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectSustainedMovementParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MinMoveSpeedSustain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSustainedMovementParams, min_move_speed_sustain),
            },
            FieldInfoData {
                name: "MaxMoveSpeedRelease",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSustainedMovementParams, max_move_speed_release),
            },
            FieldInfoData {
                name: "MinSustainTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSustainedMovementParams, min_sustain_time),
            },
            FieldInfoData {
                name: "MinReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSustainedMovementParams, min_release_time),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowObjectSustainedMovementParams {
    fn type_info() -> &'static TypeInfo {
        FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_TYPE_INFO
    }
}


pub const FOLLOWOBJECTSUSTAINEDMOVEMENTPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectSustainedMovementParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectSustainedMovementParams-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowObjectMoveParams {
    pub start_moving_max_dist_outside_follow_range: f32,
    pub start_moving_max_dist_from_slot: f32,
    pub start_moving_min_delay: f32,
    pub start_moving_max_delay: f32,
    pub min_time_follow_object_not_moving_for_idle: f32,
    pub reached_slot_distance: f32,
    pub unassigned_max_distance: f32,
    pub unassigned_closest_distance_idle: f32,
    pub unassigned_closest_distance_moving: f32,
    pub force_crouch_max_follow_object_speed: f32,
    pub force_crouch_max_follow_object_distance: f32,
    pub force_crouch_max_target_dist: f32,
    pub force_crouch_max_time_since_target_seen: f32,
    pub target_min_speed_for_run: f32,
}

pub const FOLLOWOBJECTMOVEPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectMoveParams",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "StartMovingMaxDistOutsideFollowRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, start_moving_max_dist_outside_follow_range),
            },
            FieldInfoData {
                name: "StartMovingMaxDistFromSlot",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, start_moving_max_dist_from_slot),
            },
            FieldInfoData {
                name: "StartMovingMinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, start_moving_min_delay),
            },
            FieldInfoData {
                name: "StartMovingMaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, start_moving_max_delay),
            },
            FieldInfoData {
                name: "MinTimeFollowObjectNotMovingForIdle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, min_time_follow_object_not_moving_for_idle),
            },
            FieldInfoData {
                name: "ReachedSlotDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, reached_slot_distance),
            },
            FieldInfoData {
                name: "UnassignedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, unassigned_max_distance),
            },
            FieldInfoData {
                name: "UnassignedClosestDistanceIdle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, unassigned_closest_distance_idle),
            },
            FieldInfoData {
                name: "UnassignedClosestDistanceMoving",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, unassigned_closest_distance_moving),
            },
            FieldInfoData {
                name: "ForceCrouchMaxFollowObjectSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, force_crouch_max_follow_object_speed),
            },
            FieldInfoData {
                name: "ForceCrouchMaxFollowObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, force_crouch_max_follow_object_distance),
            },
            FieldInfoData {
                name: "ForceCrouchMaxTargetDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, force_crouch_max_target_dist),
            },
            FieldInfoData {
                name: "ForceCrouchMaxTimeSinceTargetSeen",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, force_crouch_max_time_since_target_seen),
            },
            FieldInfoData {
                name: "TargetMinSpeedForRun",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectMoveParams, target_min_speed_for_run),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTMOVEPARAMS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for FollowObjectMoveParams {
    fn type_info() -> &'static TypeInfo {
        FOLLOWOBJECTMOVEPARAMS_TYPE_INFO
    }
}


pub const FOLLOWOBJECTMOVEPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectMoveParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectMoveParams-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowObjectSlotConfig {
    pub slot_count: u32,
    pub normal_slot_distance: f32,
    pub closest_slot_distance: f32,
    pub max_slot_assignment_distance_in: f32,
    pub max_slot_assignment_distance_out: f32,
    pub max_slot_assignment_vertical_distance: f32,
    pub preferred_slot_arcs: Vec<AIFollowObjectPreferredSlotArc>,
    pub use_velocity_for_forward_direction: bool,
    pub align_slots_with_forward_direction: bool,
    pub forward_direction_smoothing: AIFollowObjectDirectionSmoothingData,
    pub slot_scoring_data: AIFollowObjectSlotScoringData,
    pub forbidden_path_radius_around_target: f32,
    pub forbidden_path_rear_wedge_angle: f32,
    pub forbidden_path_rear_wedge_radius: f32,
    pub no_crossing_penalty_max_angle: f32,
    pub slot_switching_delay_normal: f32,
    pub slot_switching_delay_critical: f32,
    pub slot_extrapolate_target_speed_factor: f32,
    pub slot_extrapolate_min_dist: f32,
    pub slot_extrapolate_max_dist: f32,
}

pub const FOLLOWOBJECTSLOTCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectSlotConfig",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SlotCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_count),
            },
            FieldInfoData {
                name: "NormalSlotDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, normal_slot_distance),
            },
            FieldInfoData {
                name: "ClosestSlotDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, closest_slot_distance),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentDistanceIn",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, max_slot_assignment_distance_in),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentDistanceOut",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, max_slot_assignment_distance_out),
            },
            FieldInfoData {
                name: "MaxSlotAssignmentVerticalDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, max_slot_assignment_vertical_distance),
            },
            FieldInfoData {
                name: "PreferredSlotArcs",
                flags: MemberInfoFlags::new(144),
                field_type: AIFOLLOWOBJECTPREFERREDSLOTARC_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, preferred_slot_arcs),
            },
            FieldInfoData {
                name: "UseVelocityForForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, use_velocity_for_forward_direction),
            },
            FieldInfoData {
                name: "AlignSlotsWithForwardDirection",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, align_slots_with_forward_direction),
            },
            FieldInfoData {
                name: "ForwardDirectionSmoothing",
                flags: MemberInfoFlags::new(0),
                field_type: AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, forward_direction_smoothing),
            },
            FieldInfoData {
                name: "SlotScoringData",
                flags: MemberInfoFlags::new(0),
                field_type: AIFOLLOWOBJECTSLOTSCORINGDATA_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_scoring_data),
            },
            FieldInfoData {
                name: "ForbiddenPathRadiusAroundTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, forbidden_path_radius_around_target),
            },
            FieldInfoData {
                name: "ForbiddenPathRearWedgeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, forbidden_path_rear_wedge_angle),
            },
            FieldInfoData {
                name: "ForbiddenPathRearWedgeRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, forbidden_path_rear_wedge_radius),
            },
            FieldInfoData {
                name: "NoCrossingPenaltyMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, no_crossing_penalty_max_angle),
            },
            FieldInfoData {
                name: "SlotSwitchingDelayNormal",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_switching_delay_normal),
            },
            FieldInfoData {
                name: "SlotSwitchingDelayCritical",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_switching_delay_critical),
            },
            FieldInfoData {
                name: "SlotExtrapolateTargetSpeedFactor",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_extrapolate_target_speed_factor),
            },
            FieldInfoData {
                name: "SlotExtrapolateMinDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_extrapolate_min_dist),
            },
            FieldInfoData {
                name: "SlotExtrapolateMaxDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectSlotConfig, slot_extrapolate_max_dist),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTSLOTCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowObjectSlotConfig {
    fn type_info() -> &'static TypeInfo {
        FOLLOWOBJECTSLOTCONFIG_TYPE_INFO
    }
}


pub const FOLLOWOBJECTSLOTCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectSlotConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectSlotConfig-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIFollowObjectDirectionSmoothingData {
    pub linear_speed_to_angular_speed_max: f32,
    pub linear_speed_lower_threshold: f32,
    pub linear_speed_upper_threshold: f32,
    pub move_distance_to_angular_speed_max: f32,
    pub move_distance_lower_threshold: f32,
    pub move_distance_upper_threshold: f32,
}

pub const AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectDirectionSmoothingData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "LinearSpeedToAngularSpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, linear_speed_to_angular_speed_max),
            },
            FieldInfoData {
                name: "LinearSpeedLowerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, linear_speed_lower_threshold),
            },
            FieldInfoData {
                name: "LinearSpeedUpperThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, linear_speed_upper_threshold),
            },
            FieldInfoData {
                name: "MoveDistanceToAngularSpeedMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, move_distance_to_angular_speed_max),
            },
            FieldInfoData {
                name: "MoveDistanceLowerThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, move_distance_lower_threshold),
            },
            FieldInfoData {
                name: "MoveDistanceUpperThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectDirectionSmoothingData, move_distance_upper_threshold),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIFollowObjectDirectionSmoothingData {
    fn type_info() -> &'static TypeInfo {
        AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_TYPE_INFO
    }
}


pub const AIFOLLOWOBJECTDIRECTIONSMOOTHINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectDirectionSmoothingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectDirectionSmoothingData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIFollowObjectPreferredSlotArc {
    pub center: f32,
    pub extent: f32,
    pub cost: f32,
}

pub const AIFOLLOWOBJECTPREFERREDSLOTARC_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectPreferredSlotArc",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectPreferredSlotArc, center),
            },
            FieldInfoData {
                name: "Extent",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectPreferredSlotArc, extent),
            },
            FieldInfoData {
                name: "Cost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectPreferredSlotArc, cost),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTPREFERREDSLOTARC_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIFollowObjectPreferredSlotArc {
    fn type_info() -> &'static TypeInfo {
        AIFOLLOWOBJECTPREFERREDSLOTARC_TYPE_INFO
    }
}


pub const AIFOLLOWOBJECTPREFERREDSLOTARC_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectPreferredSlotArc-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectPreferredSlotArc-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIFollowObjectSlotScoringData {
    pub slot_distance_adjust_cost_curve: super::core::FloatCurve,
    pub future_occluded_cost: f32,
    pub future_colliding_cost: f32,
    pub path_dist_to_slot_cost_curve: super::core::FloatCurve,
    pub distance_from_assigned_slot_cost_curve: super::core::FloatCurve,
    pub cross_front_of_target_cost: f32,
    pub cross_behind_target_cost: f32,
}

pub const AIFOLLOWOBJECTSLOTSCORINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectSlotScoringData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SlotDistanceAdjustCostCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, slot_distance_adjust_cost_curve),
            },
            FieldInfoData {
                name: "FutureOccludedCost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, future_occluded_cost),
            },
            FieldInfoData {
                name: "FutureCollidingCost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, future_colliding_cost),
            },
            FieldInfoData {
                name: "PathDistToSlotCostCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, path_dist_to_slot_cost_curve),
            },
            FieldInfoData {
                name: "DistanceFromAssignedSlotCostCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, distance_from_assigned_slot_cost_curve),
            },
            FieldInfoData {
                name: "CrossFrontOfTargetCost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, cross_front_of_target_cost),
            },
            FieldInfoData {
                name: "CrossBehindTargetCost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIFollowObjectSlotScoringData, cross_behind_target_cost),
            },
        ],
    }),
    array_type: Some(AIFOLLOWOBJECTSLOTSCORINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFollowObjectSlotScoringData {
    fn type_info() -> &'static TypeInfo {
        AIFOLLOWOBJECTSLOTSCORINGDATA_TYPE_INFO
    }
}


pub const AIFOLLOWOBJECTSLOTSCORINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowObjectSlotScoringData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowObjectSlotScoringData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIPreferredAreaEntityData {
    pub follow_object_attract_radius: f32,
    pub influence_distance_outside_shape: f32,
    pub use_own_last_position_as_origin: bool,
    pub score: f32,
}

pub const AIPREFERREDAREAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPreferredAreaEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FollowObjectAttractRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPreferredAreaEntityData, follow_object_attract_radius),
            },
            FieldInfoData {
                name: "InfluenceDistanceOutsideShape",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPreferredAreaEntityData, influence_distance_outside_shape),
            },
            FieldInfoData {
                name: "UseOwnLastPositionAsOrigin",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIPreferredAreaEntityData, use_own_last_position_as_origin),
            },
            FieldInfoData {
                name: "Score",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPreferredAreaEntityData, score),
            },
        ],
    }),
    array_type: Some(AIPREFERREDAREAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIPreferredAreaEntityData {
    fn type_info() -> &'static TypeInfo {
        AIPREFERREDAREAENTITYDATA_TYPE_INFO
    }
}


pub const AIPREFERREDAREAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPreferredAreaEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPreferredAreaEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIHearingParameterEntityData {
    pub sensing_shot_fired_distance: f32,
    pub sensing_human_driven_vehicle_distance: f32,
    pub sensing_explosion_distance: f32,
    pub sensing_grenade_distance: f32,
}

pub const AIHEARINGPARAMETERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIHearingParameterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SensingShotFiredDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIHearingParameterEntityData, sensing_shot_fired_distance),
            },
            FieldInfoData {
                name: "SensingHumanDrivenVehicleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIHearingParameterEntityData, sensing_human_driven_vehicle_distance),
            },
            FieldInfoData {
                name: "SensingExplosionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIHearingParameterEntityData, sensing_explosion_distance),
            },
            FieldInfoData {
                name: "SensingGrenadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIHearingParameterEntityData, sensing_grenade_distance),
            },
        ],
    }),
    array_type: Some(AIHEARINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIHearingParameterEntityData {
    fn type_info() -> &'static TypeInfo {
        AIHEARINGPARAMETERENTITYDATA_TYPE_INFO
    }
}


pub const AIHEARINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIHearingParameterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIHearingParameterEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AISensingParameterEntityData {
    pub include_terrain: bool,
    pub allow_investigations: bool,
}

pub const AISENSINGPARAMETERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISensingParameterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "IncludeTerrain",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AISensingParameterEntityData, include_terrain),
            },
            FieldInfoData {
                name: "AllowInvestigations",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AISensingParameterEntityData, allow_investigations),
            },
        ],
    }),
    array_type: Some(AISENSINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISensingParameterEntityData {
    fn type_info() -> &'static TypeInfo {
        AISENSINGPARAMETERENTITYDATA_TYPE_INFO
    }
}


pub const AISENSINGPARAMETERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISensingParameterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISensingParameterEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIIdleBehaviorEntityData {
    pub idle_readiness: IdleReadiness,
    pub allow_aiming_while_scripted: bool,
    pub aiming_target_distance: f32,
}

pub const AIIDLEBEHAVIORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIIdleBehaviorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "IdleReadiness",
                flags: MemberInfoFlags::new(0),
                field_type: IDLEREADINESS_TYPE_INFO,
                rust_offset: offset_of!(AIIdleBehaviorEntityData, idle_readiness),
            },
            FieldInfoData {
                name: "AllowAimingWhileScripted",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIIdleBehaviorEntityData, allow_aiming_while_scripted),
            },
            FieldInfoData {
                name: "AimingTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIIdleBehaviorEntityData, aiming_target_distance),
            },
        ],
    }),
    array_type: Some(AIIDLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIIdleBehaviorEntityData {
    fn type_info() -> &'static TypeInfo {
        AIIDLEBEHAVIORENTITYDATA_TYPE_INFO
    }
}


pub const AIIDLEBEHAVIORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIIdleBehaviorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIIdleBehaviorEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIParameterWithShapeEntityData {
    pub ignore_rotation: bool,
}

pub const AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIParameterWithShapeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPARAMETERENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "IgnoreRotation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIParameterWithShapeEntityData, ignore_rotation),
            },
        ],
    }),
    array_type: Some(AIPARAMETERWITHSHAPEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AIParameterWithShapeEntityData {
    fn type_info() -> &'static TypeInfo {
        AIPARAMETERWITHSHAPEENTITYDATA_TYPE_INFO
    }
}


pub const AIPARAMETERWITHSHAPEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIParameterWithShapeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIParameterWithShapeEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIParameterEntityData {
    pub auto_activate: bool,
}

pub const AIPARAMETERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIParameterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AutoActivate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIParameterEntityData, auto_activate),
            },
        ],
    }),
    array_type: Some(AIPARAMETERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for AIParameterEntityData {
    fn type_info() -> &'static TypeInfo {
        AIPARAMETERENTITYDATA_TYPE_INFO
    }
}


pub const AIPARAMETERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIParameterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIParameterEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AICancelOrderEntityData {
}

pub const AICANCELORDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICancelOrderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIORDERENTITYBASEDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AICANCELORDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICancelOrderEntityData {
    fn type_info() -> &'static TypeInfo {
        AICANCELORDERENTITYDATA_TYPE_INFO
    }
}


pub const AICANCELORDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICancelOrderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICancelOrderEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIGotoPlaceOrderEntityData {
    pub max_distance: f32,
    pub min_distance: f32,
    pub go_to_position: super::core::LinearTransform,
    pub randomize_destination: bool,
    pub change_of_destination_distance_tolerance: f32,
    pub move_settings_alerted: MoveSettings,
    pub move_settings_not_alerted: MoveSettings,
}

pub const AIGOTOPLACEORDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIGotoPlaceOrderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIORDERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, max_distance),
            },
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, min_distance),
            },
            FieldInfoData {
                name: "GoToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, go_to_position),
            },
            FieldInfoData {
                name: "RandomizeDestination",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, randomize_destination),
            },
            FieldInfoData {
                name: "ChangeOfDestinationDistanceTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, change_of_destination_distance_tolerance),
            },
            FieldInfoData {
                name: "MoveSettingsAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, move_settings_alerted),
            },
            FieldInfoData {
                name: "MoveSettingsNotAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AIGotoPlaceOrderEntityData, move_settings_not_alerted),
            },
        ],
    }),
    array_type: Some(AIGOTOPLACEORDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIGotoPlaceOrderEntityData {
    fn type_info() -> &'static TypeInfo {
        AIGOTOPLACEORDERENTITYDATA_TYPE_INFO
    }
}


pub const AIGOTOPLACEORDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIGotoPlaceOrderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIGotoPlaceOrderEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIFollowWaypointsOrderEntityData {
    pub waypoint_transform: super::core::LinearTransform,
    pub type_of_route: super::pathfinding_shared::RouteType,
    pub start_at_geometrically_closest_waypoint: bool,
    pub use_physics_driven_locomotion: bool,
    pub path_finding: super::pathfinding_shared::PathfindingChoice,
    pub pathlink_usage_type: AIPathlinkUsageType,
}

pub const AIFOLLOWWAYPOINTSORDERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowWaypointsOrderEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIORDERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "WaypointTransform",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, waypoint_transform),
            },
            FieldInfoData {
                name: "TypeOfRoute",
                flags: MemberInfoFlags::new(0),
                field_type: ROUTETYPE_TYPE_INFO,
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, type_of_route),
            },
            FieldInfoData {
                name: "StartAtGeometricallyClosestWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, start_at_geometrically_closest_waypoint),
            },
            FieldInfoData {
                name: "UsePhysicsDrivenLocomotion",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, use_physics_driven_locomotion),
            },
            FieldInfoData {
                name: "PathFinding",
                flags: MemberInfoFlags::new(0),
                field_type: PATHFINDINGCHOICE_TYPE_INFO,
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, path_finding),
            },
            FieldInfoData {
                name: "PathlinkUsageType",
                flags: MemberInfoFlags::new(0),
                field_type: AIPATHLINKUSAGETYPE_TYPE_INFO,
                rust_offset: offset_of!(AIFollowWaypointsOrderEntityData, pathlink_usage_type),
            },
        ],
    }),
    array_type: Some(AIFOLLOWWAYPOINTSORDERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIFollowWaypointsOrderEntityData {
    fn type_info() -> &'static TypeInfo {
        AIFOLLOWWAYPOINTSORDERENTITYDATA_TYPE_INFO
    }
}


pub const AIFOLLOWWAYPOINTSORDERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFollowWaypointsOrderEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFollowWaypointsOrderEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIOrderEntityBaseData {
}

pub const AIORDERENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIOrderEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AIORDERENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIOrderEntityBaseData {
    fn type_info() -> &'static TypeInfo {
        AIORDERENTITYBASEDATA_TYPE_INFO
    }
}


pub const AIORDERENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIOrderEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIOrderEntityBaseData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum TacticsEnumeration {
    #[default]
    TacticsEnumeration_None = 0,
    TacticsEnumeration_Vehicle = 1,
    TacticsEnumeration_Charge = 2,
    TacticsEnumeration_Attack = 3,
    TacticsEnumeration_Hide = 4,
    TacticsEnumeration_Flee = 5,
    TacticsEnumeration_CloseCombat = 6,
    TacticsEnumeration_Berserk = 7,
    TacticsEnumeration_CloseRangeAttack = 8,
    TacticsEnumeration_SquadMovement = 9,
    TacticsEnumeration_SquadEngage = 10,
    TacticsEnumeration_Investigate = 11,
    TacticsEnumeration_CombatInvestigate = 12,
    TacticsEnumeration_CombatSearchArea = 13,
    TacticsEnumeration_SearchAreaTactic = 14,
}

pub const TACTICSENUMERATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TacticsEnumeration",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(TACTICSENUMERATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TacticsEnumeration {
    fn type_info() -> &'static TypeInfo {
        TACTICSENUMERATION_TYPE_INFO
    }
}


pub const TACTICSENUMERATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TacticsEnumeration-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TacticsEnumeration-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AICombatIntensity {
    #[default]
    AICombatIntensity_None = 0,
    AICombatIntensity_Low = 1,
    AICombatIntensity_Medium = 2,
    AICombatIntensity_High = 3,
}

pub const AICOMBATINTENSITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatIntensity",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AICOMBATINTENSITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AICombatIntensity {
    fn type_info() -> &'static TypeInfo {
        AICOMBATINTENSITY_TYPE_INFO
    }
}


pub const AICOMBATINTENSITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICombatIntensity-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICombatIntensity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum ExecutionPriority {
    #[default]
    ExecutionPriority_All = 0,
    ExecutionPriority_Idle = 1,
    ExecutionPriority_Combat = 2,
}

pub const EXECUTIONPRIORITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecutionPriority",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(EXECUTIONPRIORITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ExecutionPriority {
    fn type_info() -> &'static TypeInfo {
        EXECUTIONPRIORITY_TYPE_INFO
    }
}


pub const EXECUTIONPRIORITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExecutionPriority-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ExecutionPriority-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIShootType {
    #[default]
    AIShootType_OneBurstPerTarget = 0,
    AIShootType_Continuous = 1,
    AIShootType_HVT = 2,
}

pub const AISHOOTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIShootType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AISHOOTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIShootType {
    fn type_info() -> &'static TypeInfo {
        AISHOOTTYPE_TYPE_INFO
    }
}


pub const AISHOOTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIShootType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIShootType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum IdleReadiness {
    #[default]
    IdleReadiness_Relaxed = 0,
    IdleReadiness_Ready = 1,
}

pub const IDLEREADINESS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IdleReadiness",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(IDLEREADINESS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for IdleReadiness {
    fn type_info() -> &'static TypeInfo {
        IDLEREADINESS_TYPE_INFO
    }
}


pub const IDLEREADINESS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IdleReadiness-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("IdleReadiness-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIOrderCoordinatorComponentData {
    pub realm: super::core::Realm,
    pub is_active: bool,
    pub is_leader: bool,
    pub use_combat_group: bool,
    pub must_be_alerted: bool,
    pub must_be_in_cover: bool,
    pub must_have_seen_enemy: bool,
    pub must_have_seen_enemy_for_self_orders: bool,
    pub order_abort_and_reset_action_cooldown: bool,
    pub self_order_cooldown: f32,
    pub self_order_buffer_time: f32,
    pub order_freq_min: f32,
    pub order_freq_max: f32,
    pub order_buffer_time: f32,
    pub leader_binding: LeaderActionBinding,
    pub leader_actions: Vec<LeaderAction>,
    pub random_weight: f32,
    pub can_see_weight: f32,
    pub is_in_front_of_leader_weight: f32,
    pub forward_leader_angle_threshold: f32,
    pub member_actions: Vec<MemberAction>,
}

pub const AIORDERCOORDINATORCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIOrderCoordinatorComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, realm),
            },
            FieldInfoData {
                name: "IsActive",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, is_active),
            },
            FieldInfoData {
                name: "IsLeader",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, is_leader),
            },
            FieldInfoData {
                name: "UseCombatGroup",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, use_combat_group),
            },
            FieldInfoData {
                name: "MustBeAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, must_be_alerted),
            },
            FieldInfoData {
                name: "MustBeInCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, must_be_in_cover),
            },
            FieldInfoData {
                name: "MustHaveSeenEnemy",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, must_have_seen_enemy),
            },
            FieldInfoData {
                name: "MustHaveSeenEnemyForSelfOrders",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, must_have_seen_enemy_for_self_orders),
            },
            FieldInfoData {
                name: "OrderAbortAndResetActionCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, order_abort_and_reset_action_cooldown),
            },
            FieldInfoData {
                name: "SelfOrderCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, self_order_cooldown),
            },
            FieldInfoData {
                name: "SelfOrderBufferTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, self_order_buffer_time),
            },
            FieldInfoData {
                name: "OrderFreqMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, order_freq_min),
            },
            FieldInfoData {
                name: "OrderFreqMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, order_freq_max),
            },
            FieldInfoData {
                name: "OrderBufferTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, order_buffer_time),
            },
            FieldInfoData {
                name: "LeaderBinding",
                flags: MemberInfoFlags::new(0),
                field_type: LEADERACTIONBINDING_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, leader_binding),
            },
            FieldInfoData {
                name: "LeaderActions",
                flags: MemberInfoFlags::new(144),
                field_type: LEADERACTION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, leader_actions),
            },
            FieldInfoData {
                name: "RandomWeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, random_weight),
            },
            FieldInfoData {
                name: "CanSeeWeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, can_see_weight),
            },
            FieldInfoData {
                name: "IsInFrontOfLeaderWeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, is_in_front_of_leader_weight),
            },
            FieldInfoData {
                name: "ForwardLeaderAngleThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, forward_leader_angle_threshold),
            },
            FieldInfoData {
                name: "MemberActions",
                flags: MemberInfoFlags::new(144),
                field_type: MEMBERACTION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIOrderCoordinatorComponentData, member_actions),
            },
        ],
    }),
    array_type: Some(AIORDERCOORDINATORCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIOrderCoordinatorComponentData {
    fn type_info() -> &'static TypeInfo {
        AIORDERCOORDINATORCOMPONENTDATA_TYPE_INFO
    }
}


pub const AIORDERCOORDINATORCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIOrderCoordinatorComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIOrderCoordinatorComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MemberAction {
    pub name: String,
    pub index: i32,
    pub must_be_in_cover: bool,
    pub min_distance: f32,
    pub max_distance: f32,
    pub min_distance_to_target: f32,
    pub max_distance_to_target: f32,
    pub score: f32,
    pub cooldown: f32,
    pub templates: Vec<String>,
}

pub const MEMBERACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemberAction",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, name),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, index),
            },
            FieldInfoData {
                name: "MustBeInCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, must_be_in_cover),
            },
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, min_distance),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, max_distance),
            },
            FieldInfoData {
                name: "MinDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, min_distance_to_target),
            },
            FieldInfoData {
                name: "MaxDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, max_distance_to_target),
            },
            FieldInfoData {
                name: "Score",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, score),
            },
            FieldInfoData {
                name: "Cooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, cooldown),
            },
            FieldInfoData {
                name: "Templates",
                flags: MemberInfoFlags::new(144),
                field_type: CSTRING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MemberAction, templates),
            },
        ],
    }),
    array_type: Some(MEMBERACTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MemberAction {
    fn type_info() -> &'static TypeInfo {
        MEMBERACTION_TYPE_INFO
    }
}


pub const MEMBERACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MemberAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MemberAction-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LeaderAction {
    pub name: String,
    pub index: i32,
    pub cooldown: f32,
    pub ant_game_state: super::game_shared::WriteAntGameStateData,
}

pub const LEADERACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LeaderAction",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(LeaderAction, name),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(LeaderAction, index),
            },
            FieldInfoData {
                name: "Cooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LeaderAction, cooldown),
            },
            FieldInfoData {
                name: "AntGameState",
                flags: MemberInfoFlags::new(0),
                field_type: WRITEANTGAMESTATEDATA_TYPE_INFO,
                rust_offset: offset_of!(LeaderAction, ant_game_state),
            },
        ],
    }),
    array_type: Some(LEADERACTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LeaderAction {
    fn type_info() -> &'static TypeInfo {
        LEADERACTION_TYPE_INFO
    }
}


pub const LEADERACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LeaderAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LeaderAction-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct LeaderActionBinding {
    pub leader_to_member_angle: super::ant::AntRef,
    pub send_order_ack: super::ant::AntRef,
}

pub const LEADERACTIONBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LeaderActionBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "LeaderToMemberAngle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(LeaderActionBinding, leader_to_member_angle),
            },
            FieldInfoData {
                name: "SendOrderAck",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(LeaderActionBinding, send_order_ack),
            },
        ],
    }),
    array_type: Some(LEADERACTIONBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for LeaderActionBinding {
    fn type_info() -> &'static TypeInfo {
        LEADERACTIONBINDING_TYPE_INFO
    }
}


pub const LEADERACTIONBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LeaderActionBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LeaderActionBinding-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIObstacleControllerEntityData {
    pub enabled_at_start: bool,
    pub penalty: AINavObstaclePenalty,
    pub affected_layers: Vec<AIPathfindingLayer>,
    pub entity_box_override: super::core::AxisAlignedBox,
}

pub const AIOBSTACLECONTROLLERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIObstacleControllerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EnabledAtStart",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIObstacleControllerEntityData, enabled_at_start),
            },
            FieldInfoData {
                name: "Penalty",
                flags: MemberInfoFlags::new(0),
                field_type: AINAVOBSTACLEPENALTY_TYPE_INFO,
                rust_offset: offset_of!(AIObstacleControllerEntityData, penalty),
            },
            FieldInfoData {
                name: "AffectedLayers",
                flags: MemberInfoFlags::new(144),
                field_type: AIPATHFINDINGLAYER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIObstacleControllerEntityData, affected_layers),
            },
            FieldInfoData {
                name: "EntityBoxOverride",
                flags: MemberInfoFlags::new(0),
                field_type: AXISALIGNEDBOX_TYPE_INFO,
                rust_offset: offset_of!(AIObstacleControllerEntityData, entity_box_override),
            },
        ],
    }),
    array_type: Some(AIOBSTACLECONTROLLERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIObstacleControllerEntityData {
    fn type_info() -> &'static TypeInfo {
        AIOBSTACLECONTROLLERENTITYDATA_TYPE_INFO
    }
}


pub const AIOBSTACLECONTROLLERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIObstacleControllerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIObstacleControllerEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BattleAINavObstacleComponentData {
    pub enable_on_init: bool,
    pub is_pathfinding: bool,
    pub enable_tracking: bool,
    pub enable_track_rotation: bool,
    pub penalty: AINavObstaclePenalty,
    pub bounding_volume_offset: super::core::Vec3,
    pub bounding_volume_extent_override: super::core::Vec3,
    pub affected_layers: Vec<AIPathfindingLayer>,
    pub enable_movement_obstacle: bool,
    pub extrapolate_distance: f32,
    pub replace_distance: f32,
    pub replace_angle: f32,
}

pub const BATTLEAINAVOBSTACLECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAINavObstacleComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EnableOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, enable_on_init),
            },
            FieldInfoData {
                name: "IsPathfinding",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, is_pathfinding),
            },
            FieldInfoData {
                name: "EnableTracking",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, enable_tracking),
            },
            FieldInfoData {
                name: "EnableTrackRotation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, enable_track_rotation),
            },
            FieldInfoData {
                name: "Penalty",
                flags: MemberInfoFlags::new(0),
                field_type: AINAVOBSTACLEPENALTY_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, penalty),
            },
            FieldInfoData {
                name: "BoundingVolumeOffset",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, bounding_volume_offset),
            },
            FieldInfoData {
                name: "BoundingVolumeExtentOverride",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, bounding_volume_extent_override),
            },
            FieldInfoData {
                name: "AffectedLayers",
                flags: MemberInfoFlags::new(144),
                field_type: AIPATHFINDINGLAYER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, affected_layers),
            },
            FieldInfoData {
                name: "EnableMovementObstacle",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, enable_movement_obstacle),
            },
            FieldInfoData {
                name: "ExtrapolateDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, extrapolate_distance),
            },
            FieldInfoData {
                name: "ReplaceDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, replace_distance),
            },
            FieldInfoData {
                name: "ReplaceAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BattleAINavObstacleComponentData, replace_angle),
            },
        ],
    }),
    array_type: Some(BATTLEAINAVOBSTACLECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BattleAINavObstacleComponentData {
    fn type_info() -> &'static TypeInfo {
        BATTLEAINAVOBSTACLECOMPONENTDATA_TYPE_INFO
    }
}


pub const BATTLEAINAVOBSTACLECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAINavObstacleComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAINavObstacleComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIMeleeComponentData {
    pub realm: super::core::Realm,
}

pub const AIMELEECOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIMeleeComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AIMeleeComponentData, realm),
            },
        ],
    }),
    array_type: Some(AIMELEECOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIMeleeComponentData {
    fn type_info() -> &'static TypeInfo {
        AIMELEECOMPONENTDATA_TYPE_INFO
    }
}


pub const AIMELEECOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIMeleeComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIMeleeComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AITeleportEntityData {
    pub check_below_ground: bool,
    pub new_position: super::core::LinearTransform,
}

pub const AITELEPORTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITeleportEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CheckBelowGround",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITeleportEntityData, check_below_ground),
            },
            FieldInfoData {
                name: "NewPosition",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(AITeleportEntityData, new_position),
            },
        ],
    }),
    array_type: Some(AITELEPORTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AITeleportEntityData {
    fn type_info() -> &'static TypeInfo {
        AITELEPORTENTITYDATA_TYPE_INFO
    }
}


pub const AITELEPORTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITeleportEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITeleportEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WaypointsWalkerEntityData {
    pub realm: super::core::Realm,
    pub circular: bool,
    pub speed: f32,
}

pub const WAYPOINTSWALKERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointsWalkerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(WaypointsWalkerEntityData, realm),
            },
            FieldInfoData {
                name: "Circular",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(WaypointsWalkerEntityData, circular),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WaypointsWalkerEntityData, speed),
            },
        ],
    }),
    array_type: Some(WAYPOINTSWALKERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaypointsWalkerEntityData {
    fn type_info() -> &'static TypeInfo {
        WAYPOINTSWALKERENTITYDATA_TYPE_INFO
    }
}


pub const WAYPOINTSWALKERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointsWalkerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WaypointsWalkerEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIFirePatternEntityData {
    pub realm: super::core::Realm,
    pub wants_to_fire: bool,
    pub simple_patterns: Vec<SimpleFirePatternData>,
    pub pattern_to_use: i32,
}

pub const AIFIREPATTERNENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFirePatternEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AIFirePatternEntityData, realm),
            },
            FieldInfoData {
                name: "WantsToFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIFirePatternEntityData, wants_to_fire),
            },
            FieldInfoData {
                name: "SimplePatterns",
                flags: MemberInfoFlags::new(144),
                field_type: SIMPLEFIREPATTERNDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIFirePatternEntityData, simple_patterns),
            },
            FieldInfoData {
                name: "PatternToUse",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AIFirePatternEntityData, pattern_to_use),
            },
        ],
    }),
    array_type: Some(AIFIREPATTERNENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIFirePatternEntityData {
    fn type_info() -> &'static TypeInfo {
        AIFIREPATTERNENTITYDATA_TYPE_INFO
    }
}


pub const AIFIREPATTERNENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIFirePatternEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIFirePatternEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SimpleFirePatternData {
    pub min_fire_interval: f32,
    pub max_fire_interval: f32,
    pub min_interval_between_fire: f32,
    pub max_interval_between_fire: f32,
}

pub const SIMPLEFIREPATTERNDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleFirePatternData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MinFireInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleFirePatternData, min_fire_interval),
            },
            FieldInfoData {
                name: "MaxFireInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleFirePatternData, max_fire_interval),
            },
            FieldInfoData {
                name: "MinIntervalBetweenFire",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleFirePatternData, min_interval_between_fire),
            },
            FieldInfoData {
                name: "MaxIntervalBetweenFire",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleFirePatternData, max_interval_between_fire),
            },
        ],
    }),
    array_type: Some(SIMPLEFIREPATTERNDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SimpleFirePatternData {
    fn type_info() -> &'static TypeInfo {
        SIMPLEFIREPATTERNDATA_TYPE_INFO
    }
}


pub const SIMPLEFIREPATTERNDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleFirePatternData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SimpleFirePatternData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AITemplateFilterEntityData {
    pub realm: super::core::Realm,
    pub templates: Vec<String>,
}

pub const AITEMPLATEFILTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITemplateFilterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AITemplateFilterEntityData, realm),
            },
            FieldInfoData {
                name: "Templates",
                flags: MemberInfoFlags::new(144),
                field_type: CSTRING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AITemplateFilterEntityData, templates),
            },
        ],
    }),
    array_type: Some(AITEMPLATEFILTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AITemplateFilterEntityData {
    fn type_info() -> &'static TypeInfo {
        AITEMPLATEFILTERENTITYDATA_TYPE_INFO
    }
}


pub const AITEMPLATEFILTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITemplateFilterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITemplateFilterEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PointOfInterestComponentData {
    pub detection_radius: f32,
    pub time_to_live: f32,
}

pub const POINTOFINTERESTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointOfInterestComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DetectionRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PointOfInterestComponentData, detection_radius),
            },
            FieldInfoData {
                name: "TimeToLive",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PointOfInterestComponentData, time_to_live),
            },
        ],
    }),
    array_type: Some(POINTOFINTERESTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PointOfInterestComponentData {
    fn type_info() -> &'static TypeInfo {
        POINTOFINTERESTCOMPONENTDATA_TYPE_INFO
    }
}


pub const POINTOFINTERESTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointOfInterestComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PointOfInterestComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PlayerVehicleProximityEntityData {
    pub enter_close_proximity_range: f32,
    pub exit_close_proximity_range: f32,
    pub player_previous_vehicle_range: f32,
}

pub const PLAYERVEHICLEPROXIMITYENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerVehicleProximityEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EnterCloseProximityRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PlayerVehicleProximityEntityData, enter_close_proximity_range),
            },
            FieldInfoData {
                name: "ExitCloseProximityRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PlayerVehicleProximityEntityData, exit_close_proximity_range),
            },
            FieldInfoData {
                name: "PlayerPreviousVehicleRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PlayerVehicleProximityEntityData, player_previous_vehicle_range),
            },
        ],
    }),
    array_type: Some(PLAYERVEHICLEPROXIMITYENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlayerVehicleProximityEntityData {
    fn type_info() -> &'static TypeInfo {
        PLAYERVEHICLEPROXIMITYENTITYDATA_TYPE_INFO
    }
}


pub const PLAYERVEHICLEPROXIMITYENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlayerVehicleProximityEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PlayerVehicleProximityEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct HeavyPlanePilotEntityData {
    pub max_roll_angle: f32,
    pub yaw_angle_diff_for_max_roll_angle: f32,
    pub squared_roll_angle_curve: bool,
}

pub const HEAVYPLANEPILOTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HeavyPlanePilotEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PILOTENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MaxRollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HeavyPlanePilotEntityData, max_roll_angle),
            },
            FieldInfoData {
                name: "YawAngleDiffForMaxRollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HeavyPlanePilotEntityData, yaw_angle_diff_for_max_roll_angle),
            },
            FieldInfoData {
                name: "SquaredRollAngleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(HeavyPlanePilotEntityData, squared_roll_angle_curve),
            },
        ],
    }),
    array_type: Some(HEAVYPLANEPILOTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HeavyPlanePilotEntityData {
    fn type_info() -> &'static TypeInfo {
        HEAVYPLANEPILOTENTITYDATA_TYPE_INFO
    }
}


pub const HEAVYPLANEPILOTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HeavyPlanePilotEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("HeavyPlanePilotEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PilotEntityData {
    pub pitch_p_i_d: super::game_shared::PID,
    pub yaw_p_i_d: super::game_shared::PID,
    pub roll_p_i_d: super::game_shared::PID,
    pub throttle_p_i_d: super::game_shared::PID,
    pub auto_level_out_roll: bool,
    pub max_pitch_angle_diff: f32,
    pub max_yaw_angle_diff: f32,
    pub min_distance: f32,
    pub maximum_pitch_velocity: f32,
    pub maximum_yaw_velocity: f32,
    pub dist0: f32,
    pub y_offset0: f32,
    pub dist1: f32,
    pub y_offset1: f32,
    pub dist2: f32,
    pub y_offset2: f32,
}

pub const PILOTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PilotEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PILOTENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "PitchPID",
                flags: MemberInfoFlags::new(0),
                field_type: PID_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, pitch_p_i_d),
            },
            FieldInfoData {
                name: "YawPID",
                flags: MemberInfoFlags::new(0),
                field_type: PID_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, yaw_p_i_d),
            },
            FieldInfoData {
                name: "RollPID",
                flags: MemberInfoFlags::new(0),
                field_type: PID_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, roll_p_i_d),
            },
            FieldInfoData {
                name: "ThrottlePID",
                flags: MemberInfoFlags::new(0),
                field_type: PID_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, throttle_p_i_d),
            },
            FieldInfoData {
                name: "AutoLevelOutRoll",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, auto_level_out_roll),
            },
            FieldInfoData {
                name: "MaxPitchAngleDiff",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, max_pitch_angle_diff),
            },
            FieldInfoData {
                name: "MaxYawAngleDiff",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, max_yaw_angle_diff),
            },
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, min_distance),
            },
            FieldInfoData {
                name: "MaximumPitchVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, maximum_pitch_velocity),
            },
            FieldInfoData {
                name: "MaximumYawVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, maximum_yaw_velocity),
            },
            FieldInfoData {
                name: "Dist0",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, dist0),
            },
            FieldInfoData {
                name: "YOffset0",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, y_offset0),
            },
            FieldInfoData {
                name: "Dist1",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, dist1),
            },
            FieldInfoData {
                name: "YOffset1",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, y_offset1),
            },
            FieldInfoData {
                name: "Dist2",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, dist2),
            },
            FieldInfoData {
                name: "YOffset2",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityData, y_offset2),
            },
        ],
    }),
    array_type: Some(PILOTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PilotEntityData {
    fn type_info() -> &'static TypeInfo {
        PILOTENTITYDATA_TYPE_INFO
    }
}


pub const PILOTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PilotEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PilotEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct PilotEntityBaseData {
    pub realm: super::core::Realm,
}

pub const PILOTENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PilotEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(PilotEntityBaseData, realm),
            },
        ],
    }),
    array_type: Some(PILOTENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PilotEntityBaseData {
    fn type_info() -> &'static TypeInfo {
        PILOTENTITYBASEDATA_TYPE_INFO
    }
}


pub const PILOTENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PilotEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PilotEntityBaseData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PathfindingOverrideData {
    pub realm: super::core::Realm,
    pub apply_from_start: bool,
    pub path_sharing_penalty: f32,
    pub max_path_sharing_penalty: f32,
}

pub const PATHFINDINGOVERRIDEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingOverrideData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(PathfindingOverrideData, realm),
            },
            FieldInfoData {
                name: "ApplyFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(PathfindingOverrideData, apply_from_start),
            },
            FieldInfoData {
                name: "PathSharingPenalty",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PathfindingOverrideData, path_sharing_penalty),
            },
            FieldInfoData {
                name: "MaxPathSharingPenalty",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PathfindingOverrideData, max_path_sharing_penalty),
            },
        ],
    }),
    array_type: Some(PATHFINDINGOVERRIDEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PathfindingOverrideData {
    fn type_info() -> &'static TypeInfo {
        PATHFINDINGOVERRIDEDATA_TYPE_INFO
    }
}


pub const PATHFINDINGOVERRIDEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingOverrideData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PathfindingOverrideData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PathFollowingComponentData {
}

pub const PATHFOLLOWINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathFollowingComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PATHFOLLOWINGCOMPONENTBASEDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(PATHFOLLOWINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for PathFollowingComponentData {
    fn type_info() -> &'static TypeInfo {
        PATHFOLLOWINGCOMPONENTDATA_TYPE_INFO
    }
}


pub const PATHFOLLOWINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathFollowingComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PathFollowingComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct FollowWaypointsEntityData {
}

pub const FOLLOWWAYPOINTSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowWaypointsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(FOLLOWWAYPOINTSENTITYBASEDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(FOLLOWWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowWaypointsEntityData {
    fn type_info() -> &'static TypeInfo {
        FOLLOWWAYPOINTSENTITYDATA_TYPE_INFO
    }
}


pub const FOLLOWWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowWaypointsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowWaypointsEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowObjectEntityData {
    pub offset: super::core::Vec3,
    pub radius: f32,
    pub local_offset: bool,
    pub use_path_finding: bool,
    pub target_transform: super::core::LinearTransform,
}

pub const FOLLOWOBJECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectEntityData, offset),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectEntityData, radius),
            },
            FieldInfoData {
                name: "LocalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectEntityData, local_offset),
            },
            FieldInfoData {
                name: "UsePathFinding",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectEntityData, use_path_finding),
            },
            FieldInfoData {
                name: "TargetTransform",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(FollowObjectEntityData, target_transform),
            },
        ],
    }),
    array_type: Some(FOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FollowObjectEntityData {
    fn type_info() -> &'static TypeInfo {
        FOLLOWOBJECTENTITYDATA_TYPE_INFO
    }
}


pub const FOLLOWOBJECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowObjectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowObjectEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct WaypointTriggerEntityData {
    pub realm: super::core::Realm,
}

pub const WAYPOINTTRIGGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointTriggerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WAYPOINTTRIGGERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(WaypointTriggerEntityData, realm),
            },
        ],
    }),
    array_type: Some(WAYPOINTTRIGGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaypointTriggerEntityData {
    fn type_info() -> &'static TypeInfo {
        WAYPOINTTRIGGERENTITYDATA_TYPE_INFO
    }
}


pub const WAYPOINTTRIGGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaypointTriggerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WaypointTriggerEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct PathfindingStreamEntityData {
}

pub const PATHFINDINGSTREAMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingStreamEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(PATHFINDINGSTREAMENTITYBASEDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(PATHFINDINGSTREAMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PathfindingStreamEntityData {
    fn type_info() -> &'static TypeInfo {
        PATHFINDINGSTREAMENTITYDATA_TYPE_INFO
    }
}


pub const PATHFINDINGSTREAMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PathfindingStreamEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PathfindingStreamEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BattleAIPathLinkEntityData {
    pub points: Vec<super::core::Vec3>,
    pub enable_on_init: bool,
    pub direction: AIPathLinkDirection,
    pub link_data: AIPathLinkData,
}

pub const BATTLEAIPATHLINKENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIPathLinkEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Points",
                flags: MemberInfoFlags::new(144),
                field_type: VEC3_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(BattleAIPathLinkEntityData, points),
            },
            FieldInfoData {
                name: "EnableOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAIPathLinkEntityData, enable_on_init),
            },
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: AIPATHLINKDIRECTION_TYPE_INFO,
                rust_offset: offset_of!(BattleAIPathLinkEntityData, direction),
            },
            FieldInfoData {
                name: "LinkData",
                flags: MemberInfoFlags::new(0),
                field_type: AIPATHLINKDATA_TYPE_INFO,
                rust_offset: offset_of!(BattleAIPathLinkEntityData, link_data),
            },
        ],
    }),
    array_type: Some(BATTLEAIPATHLINKENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for BattleAIPathLinkEntityData {
    fn type_info() -> &'static TypeInfo {
        BATTLEAIPATHLINKENTITYDATA_TYPE_INFO
    }
}


pub const BATTLEAIPATHLINKENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAIPathLinkEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAIPathLinkEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct StandardMovePathlinkData {
    pub move_data: AILocoMoveTaskData,
}

pub const STANDARDMOVEPATHLINKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StandardMovePathlinkData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPATHLINKDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveData",
                flags: MemberInfoFlags::new(0),
                field_type: AILOCOMOVETASKDATA_TYPE_INFO,
                rust_offset: offset_of!(StandardMovePathlinkData, move_data),
            },
        ],
    }),
    array_type: Some(STANDARDMOVEPATHLINKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StandardMovePathlinkData {
    fn type_info() -> &'static TypeInfo {
        STANDARDMOVEPATHLINKDATA_TYPE_INFO
    }
}


pub const STANDARDMOVEPATHLINKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StandardMovePathlinkData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StandardMovePathlinkData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ScenarioPathlinkData {
    pub play_animation: super::game_shared::PlayAnimationData,
    pub scenario_task: ScenarioTaskData,
}

pub const SCENARIOPATHLINKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioPathlinkData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AIPATHLINKDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "PlayAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: PLAYANIMATIONDATA_TYPE_INFO,
                rust_offset: offset_of!(ScenarioPathlinkData, play_animation),
            },
            FieldInfoData {
                name: "ScenarioTask",
                flags: MemberInfoFlags::new(0),
                field_type: SCENARIOTASKDATA_TYPE_INFO,
                rust_offset: offset_of!(ScenarioPathlinkData, scenario_task),
            },
        ],
    }),
    array_type: Some(SCENARIOPATHLINKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScenarioPathlinkData {
    fn type_info() -> &'static TypeInfo {
        SCENARIOPATHLINKDATA_TYPE_INFO
    }
}


pub const SCENARIOPATHLINKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioPathlinkData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ScenarioPathlinkData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIPathLinkData {
    pub affected_layers: Vec<AIPathfindingLayer>,
    pub link_usage_flags: AIPathlinkUsageType,
    pub penalty: AIPathLinkPenalty,
    pub max_snap_dist: f32,
    pub may_use_dist: f32,
    pub must_use_dist: f32,
    pub stop_to_use_link: bool,
    pub max_simultaneous: u32,
    pub base_data: AILocoBaseTaskData,
}

pub const AIPATHLINKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AffectedLayers",
                flags: MemberInfoFlags::new(144),
                field_type: AIPATHFINDINGLAYER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIPathLinkData, affected_layers),
            },
            FieldInfoData {
                name: "LinkUsageFlags",
                flags: MemberInfoFlags::new(0),
                field_type: AIPATHLINKUSAGETYPE_TYPE_INFO,
                rust_offset: offset_of!(AIPathLinkData, link_usage_flags),
            },
            FieldInfoData {
                name: "Penalty",
                flags: MemberInfoFlags::new(0),
                field_type: AIPATHLINKPENALTY_TYPE_INFO,
                rust_offset: offset_of!(AIPathLinkData, penalty),
            },
            FieldInfoData {
                name: "MaxSnapDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPathLinkData, max_snap_dist),
            },
            FieldInfoData {
                name: "MayUseDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPathLinkData, may_use_dist),
            },
            FieldInfoData {
                name: "MustUseDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIPathLinkData, must_use_dist),
            },
            FieldInfoData {
                name: "StopToUseLink",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIPathLinkData, stop_to_use_link),
            },
            FieldInfoData {
                name: "MaxSimultaneous",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AIPathLinkData, max_simultaneous),
            },
            FieldInfoData {
                name: "BaseData",
                flags: MemberInfoFlags::new(0),
                field_type: AILOCOBASETASKDATA_TYPE_INFO,
                rust_offset: offset_of!(AIPathLinkData, base_data),
            },
        ],
    }),
    array_type: Some(AIPATHLINKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIPathLinkData {
    fn type_info() -> &'static TypeInfo {
        AIPATHLINKDATA_TYPE_INFO
    }
}


pub const AIPATHLINKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIPathLinkDirection {
    #[default]
    PathLinkDirection_Forward = 0,
    PathLinkDirection_Backward = 1,
    PathLinkDirection_Both = 2,
}

pub const AIPATHLINKDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkDirection",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathLinkDirection {
    fn type_info() -> &'static TypeInfo {
        AIPATHLINKDIRECTION_TYPE_INFO
    }
}


pub const AIPATHLINKDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkDirection-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkDirection-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIPathLinkPenalty {
    #[default]
    PathLinkPenalty_None = 0,
    PathLinkPenalty_StronglyPrefer = 1,
    PathLinkPenalty_Prefer = 2,
    PathLinkPenalty_Light = 3,
    PathLinkPenalty_Moderate = 4,
    PathLinkPenalty_Heavy = 5,
    PathLinkPenalty_Max = 6,
    PathLinkPenalty_NumTypes = 7,
}

pub const AIPATHLINKPENALTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkPenalty",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKPENALTY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathLinkPenalty {
    fn type_info() -> &'static TypeInfo {
        AIPATHLINKPENALTY_TYPE_INFO
    }
}


pub const AIPATHLINKPENALTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkPenalty-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkPenalty-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIPathLinkType {
    #[default]
    PathLinkType_None = 0,
    PathLinkType_Move = 1,
    PathLinkType_Vault = 2,
    PathLinkType_Scenario = 3,
}

pub const AIPATHLINKTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathLinkType {
    fn type_info() -> &'static TypeInfo {
        AIPATHLINKTYPE_TYPE_INFO
    }
}


pub const AIPATHLINKTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIPathLinkGeometryType {
    #[default]
    PathLinkGeometryType_Line = 0,
    PathLinkGeometryType_4Sides = 1,
    PathLinkGeometryType_Rectangular = 2,
}

pub const AIPATHLINKGEOMETRYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkGeometryType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIPATHLINKGEOMETRYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIPathLinkGeometryType {
    fn type_info() -> &'static TypeInfo {
        AIPATHLINKGEOMETRYTYPE_TYPE_INFO
    }
}


pub const AIPATHLINKGEOMETRYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathLinkGeometryType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIPathLinkGeometryType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MoveSettings {
    pub move_style: super::gameplay_sim::AntEnumeration,
    pub move_speed: MoveSpeed,
    pub fire: bool,
    pub fire_target_distance: f32,
    pub aim_distance_outside_fire_target_distance: f32,
    pub walk: WalkSettings,
    pub sprint: SprintSettings,
    pub start_stop: StartStopSettings,
    pub is_evasive: bool,
    pub is_physics_driven_loco: bool,
    pub start_evasive_threshold: f32,
    pub stop_evasive_threshold: f32,
}

pub const MOVESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveStyle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTENUMERATION_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, move_style),
            },
            FieldInfoData {
                name: "MoveSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: MOVESPEED_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, move_speed),
            },
            FieldInfoData {
                name: "Fire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, fire),
            },
            FieldInfoData {
                name: "FireTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, fire_target_distance),
            },
            FieldInfoData {
                name: "AimDistanceOutsideFireTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, aim_distance_outside_fire_target_distance),
            },
            FieldInfoData {
                name: "Walk",
                flags: MemberInfoFlags::new(0),
                field_type: WALKSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, walk),
            },
            FieldInfoData {
                name: "Sprint",
                flags: MemberInfoFlags::new(0),
                field_type: SPRINTSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, sprint),
            },
            FieldInfoData {
                name: "StartStop",
                flags: MemberInfoFlags::new(0),
                field_type: STARTSTOPSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, start_stop),
            },
            FieldInfoData {
                name: "IsEvasive",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, is_evasive),
            },
            FieldInfoData {
                name: "IsPhysicsDrivenLoco",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, is_physics_driven_loco),
            },
            FieldInfoData {
                name: "StartEvasiveThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, start_evasive_threshold),
            },
            FieldInfoData {
                name: "StopEvasiveThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MoveSettings, stop_evasive_threshold),
            },
        ],
    }),
    array_type: Some(MOVESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MoveSettings {
    fn type_info() -> &'static TypeInfo {
        MOVESETTINGS_TYPE_INFO
    }
}


pub const MOVESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MoveSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct StartStopSettings {
    pub upper_range: f32,
    pub lower_range: f32,
    pub ideal_range: f32,
    pub line_of_sight_time: f32,
    pub stop_pose: Pose,
}

pub const STARTSTOPSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartStopSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "UpperRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StartStopSettings, upper_range),
            },
            FieldInfoData {
                name: "LowerRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StartStopSettings, lower_range),
            },
            FieldInfoData {
                name: "IdealRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StartStopSettings, ideal_range),
            },
            FieldInfoData {
                name: "LineOfSightTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StartStopSettings, line_of_sight_time),
            },
            FieldInfoData {
                name: "StopPose",
                flags: MemberInfoFlags::new(0),
                field_type: POSE_TYPE_INFO,
                rust_offset: offset_of!(StartStopSettings, stop_pose),
            },
        ],
    }),
    array_type: Some(STARTSTOPSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StartStopSettings {
    fn type_info() -> &'static TypeInfo {
        STARTSTOPSETTINGS_TYPE_INFO
    }
}


pub const STARTSTOPSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StartStopSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StartStopSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WalkSettings {
    pub start_walking_distance: f32,
    pub stop_walking_distance: f32,
    pub require_line_of_sight: bool,
}

pub const WALKSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WalkSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "StartWalkingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WalkSettings, start_walking_distance),
            },
            FieldInfoData {
                name: "StopWalkingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WalkSettings, stop_walking_distance),
            },
            FieldInfoData {
                name: "RequireLineOfSight",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(WalkSettings, require_line_of_sight),
            },
        ],
    }),
    array_type: Some(WALKSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WalkSettings {
    fn type_info() -> &'static TypeInfo {
        WALKSETTINGS_TYPE_INFO
    }
}


pub const WALKSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WalkSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WalkSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SprintSettings {
    pub start_sprinting_threshold: f32,
    pub stop_sprinting_threshold: f32,
    pub stop_sprinting_distance_to_target: f32,
    pub start_sprinting_distance_to_target: f32,
}

pub const SPRINTSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SprintSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "StartSprintingThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SprintSettings, start_sprinting_threshold),
            },
            FieldInfoData {
                name: "StopSprintingThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SprintSettings, stop_sprinting_threshold),
            },
            FieldInfoData {
                name: "StopSprintingDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SprintSettings, stop_sprinting_distance_to_target),
            },
            FieldInfoData {
                name: "StartSprintingDistanceToTarget",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SprintSettings, start_sprinting_distance_to_target),
            },
        ],
    }),
    array_type: Some(SPRINTSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SprintSettings {
    fn type_info() -> &'static TypeInfo {
        SPRINTSETTINGS_TYPE_INFO
    }
}


pub const SPRINTSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SprintSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SprintSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum Pose {
    #[default]
    Pose_Stand = 0,
    Pose_Crouch = 1,
    Pose_NoPreference = 2,
}

pub const POSE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pose",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(POSE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Pose {
    fn type_info() -> &'static TypeInfo {
        POSE_TYPE_INFO
    }
}


pub const POSE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pose-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Pose-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MoveSpeed {
    #[default]
    MoveSpeed_Walk = 0,
    MoveSpeed_Run = 1,
    MoveSpeed_Sprint = 2,
}

pub const MOVESPEED_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveSpeed",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(MOVESPEED_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MoveSpeed {
    fn type_info() -> &'static TypeInfo {
        MOVESPEED_TYPE_INFO
    }
}


pub const MOVESPEED_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MoveSpeed-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MoveSpeed-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateSettingsOverrideData {
    pub realm: super::core::Realm,
    pub apply_from_start: bool,
    pub investigate_type: InvestigateOverrideType,
    pub min_dist_from_investigate_pos: f32,
    pub max_dist_from_investigate_pos: f32,
    pub secondary_inspect_min_dist: f32,
    pub secondary_inspect_max_dist: f32,
}

pub const INVESTIGATESETTINGSOVERRIDEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettingsOverrideData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsOverrideData, realm),
            },
            FieldInfoData {
                name: "ApplyFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsOverrideData, apply_from_start),
            },
            FieldInfoData {
                name: "InvestigateType",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATEOVERRIDETYPE_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsOverrideData, investigate_type),
            },
            FieldInfoData {
                name: "MinDistFromInvestigatePos",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsOverrideData, min_dist_from_investigate_pos),
            },
            FieldInfoData {
                name: "MaxDistFromInvestigatePos",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsOverrideData, max_dist_from_investigate_pos),
            },
            FieldInfoData {
                name: "SecondaryInspectMinDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsOverrideData, secondary_inspect_min_dist),
            },
            FieldInfoData {
                name: "SecondaryInspectMaxDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsOverrideData, secondary_inspect_max_dist),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTINGSOVERRIDEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for InvestigateSettingsOverrideData {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATESETTINGSOVERRIDEDATA_TYPE_INFO
    }
}


pub const INVESTIGATESETTINGSOVERRIDEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettingsOverrideData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettingsOverrideData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum InvestigateOverrideType {
    #[default]
    InvestigateOverrideType_IdleInvestigate = 0,
    InvestigateOverrideType_CombatInvestigate = 1,
    InvestigateOverrideType_CombatSearchArea = 2,
    InvestigateOverrideType_SearchArea = 3,
    InvestigateOverrideType_Count = 4,
}

pub const INVESTIGATEOVERRIDETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateOverrideType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(INVESTIGATEOVERRIDETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for InvestigateOverrideType {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATEOVERRIDETYPE_TYPE_INFO
    }
}


pub const INVESTIGATEOVERRIDETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateOverrideType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateOverrideType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateSettignsCustomizations {
    pub enabled: bool,
    pub multiple_investigators_settings: InvestigateSettingsMultipleInvestigators,
    pub idle: InvestigateSettignsCustomization,
    pub combat: InvestigateSettignsCustomization,
    pub combat_search_area: InvestigateSettignsCustomization,
    pub search_area: InvestigateSettignsCustomization,
}

pub const INVESTIGATESETTIGNSCUSTOMIZATIONS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsCustomizations",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsCustomizations, enabled),
            },
            FieldInfoData {
                name: "MultipleInvestigatorsSettings",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsCustomizations, multiple_investigators_settings),
            },
            FieldInfoData {
                name: "Idle",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsCustomizations, idle),
            },
            FieldInfoData {
                name: "Combat",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsCustomizations, combat),
            },
            FieldInfoData {
                name: "CombatSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsCustomizations, combat_search_area),
            },
            FieldInfoData {
                name: "SearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsCustomizations, search_area),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTIGNSCUSTOMIZATIONS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettignsCustomizations {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATESETTIGNSCUSTOMIZATIONS_TYPE_INFO
    }
}


pub const INVESTIGATESETTIGNSCUSTOMIZATIONS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsCustomizations-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettignsCustomizations-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateSettignsCustomization {
    pub enabled: bool,
    pub min_time_before_reinvestigating_same_position: f32,
    pub settings: InvestigateSettigns,
}

pub const INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsCustomization",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsCustomization, enabled),
            },
            FieldInfoData {
                name: "MinTimeBeforeReinvestigatingSamePosition",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsCustomization, min_time_before_reinvestigating_same_position),
            },
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTIGNS_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsCustomization, settings),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTIGNSCUSTOMIZATION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettignsCustomization {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATESETTIGNSCUSTOMIZATION_TYPE_INFO
    }
}


pub const INVESTIGATESETTIGNSCUSTOMIZATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsCustomization-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettignsCustomization-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateSettigns {
    pub max_investigators: i32,
    pub can_stand_in_place_and_look: bool,
    pub can_get_closer_if_obstructed: bool,
    pub min_dist_if_obstruscted: f32,
    pub knowledge_share: InvestigateSettignsKnowledgeSharing,
    pub end_conditions: InvestigateEndConditions,
}

pub const INVESTIGATESETTIGNS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettigns",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MaxInvestigators",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettigns, max_investigators),
            },
            FieldInfoData {
                name: "CanStandInPlaceAndLook",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettigns, can_stand_in_place_and_look),
            },
            FieldInfoData {
                name: "CanGetCloserIfObstructed",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettigns, can_get_closer_if_obstructed),
            },
            FieldInfoData {
                name: "MinDistIfObstruscted",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettigns, min_dist_if_obstruscted),
            },
            FieldInfoData {
                name: "KnowledgeShare",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTIGNSKNOWLEDGESHARING_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettigns, knowledge_share),
            },
            FieldInfoData {
                name: "EndConditions",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATEENDCONDITIONS_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettigns, end_conditions),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTIGNS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettigns {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATESETTIGNS_TYPE_INFO
    }
}


pub const INVESTIGATESETTIGNS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettigns-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettigns-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateSettingsMultipleInvestigators {
    pub max_distance_from_investigate_point: f32,
    pub max_attempts: i32,
    pub dist_tolerance: f32,
}

pub const INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettingsMultipleInvestigators",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MaxDistanceFromInvestigatePoint",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsMultipleInvestigators, max_distance_from_investigate_point),
            },
            FieldInfoData {
                name: "MaxAttempts",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsMultipleInvestigators, max_attempts),
            },
            FieldInfoData {
                name: "DistTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettingsMultipleInvestigators, dist_tolerance),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettingsMultipleInvestigators {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_TYPE_INFO
    }
}


pub const INVESTIGATESETTINGSMULTIPLEINVESTIGATORS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettingsMultipleInvestigators-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettingsMultipleInvestigators-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateEndConditions {
    pub end_on_area_cleared: InvestigateEndOnAreaCleared,
}

pub const INVESTIGATEENDCONDITIONS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateEndConditions",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "EndOnAreaCleared",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATEENDONAREACLEARED_TYPE_INFO,
                rust_offset: offset_of!(InvestigateEndConditions, end_on_area_cleared),
            },
        ],
    }),
    array_type: Some(INVESTIGATEENDCONDITIONS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateEndConditions {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATEENDCONDITIONS_TYPE_INFO
    }
}


pub const INVESTIGATEENDCONDITIONS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateEndConditions-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateEndConditions-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateEndOnAreaCleared {
    pub enable: bool,
    pub time_since_area_cleared: f32,
}

pub const INVESTIGATEENDONAREACLEARED_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateEndOnAreaCleared",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateEndOnAreaCleared, enable),
            },
            FieldInfoData {
                name: "TimeSinceAreaCleared",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateEndOnAreaCleared, time_since_area_cleared),
            },
        ],
    }),
    array_type: Some(INVESTIGATEENDONAREACLEARED_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateEndOnAreaCleared {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATEENDONAREACLEARED_TYPE_INFO
    }
}


pub const INVESTIGATEENDONAREACLEARED_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateEndOnAreaCleared-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateEndOnAreaCleared-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateSettignsKnowledgeSharing {
    pub enabled: bool,
    pub max_share_distance: f32,
}

pub const INVESTIGATESETTIGNSKNOWLEDGESHARING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsKnowledgeSharing",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsKnowledgeSharing, enabled),
            },
            FieldInfoData {
                name: "MaxShareDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateSettignsKnowledgeSharing, max_share_distance),
            },
        ],
    }),
    array_type: Some(INVESTIGATESETTIGNSKNOWLEDGESHARING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateSettignsKnowledgeSharing {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATESETTIGNSKNOWLEDGESHARING_TYPE_INFO
    }
}


pub const INVESTIGATESETTIGNSKNOWLEDGESHARING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateSettignsKnowledgeSharing-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateSettignsKnowledgeSharing-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GameTweakData {
    pub common: GameTweakCommon,
    pub a_i_targeting: GameTweakAITargeting,
    pub bucket_damage_ai_vs_human: GameTweakBucketDamage,
    pub bucket_damage_ai_vs_ai: GameTweakBucketDamage,
    pub sniper: GameTweakSniper,
    pub panic: GameTweakPanicBehavior,
    pub blinded: GameTweakBlindedBehavior,
    pub a_i_sound_defaults: AISoundDefaults,
    pub team_settings: Vec<TeamSettings>,
}

pub const GAMETWEAKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEAIDIFFICULTYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Common",
                flags: MemberInfoFlags::new(0),
                field_type: GAMETWEAKCOMMON_TYPE_INFO,
                rust_offset: offset_of!(GameTweakData, common),
            },
            FieldInfoData {
                name: "AITargeting",
                flags: MemberInfoFlags::new(0),
                field_type: GAMETWEAKAITARGETING_TYPE_INFO,
                rust_offset: offset_of!(GameTweakData, a_i_targeting),
            },
            FieldInfoData {
                name: "BucketDamageAiVsHuman",
                flags: MemberInfoFlags::new(0),
                field_type: GAMETWEAKBUCKETDAMAGE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakData, bucket_damage_ai_vs_human),
            },
            FieldInfoData {
                name: "BucketDamageAiVsAi",
                flags: MemberInfoFlags::new(0),
                field_type: GAMETWEAKBUCKETDAMAGE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakData, bucket_damage_ai_vs_ai),
            },
            FieldInfoData {
                name: "Sniper",
                flags: MemberInfoFlags::new(0),
                field_type: GAMETWEAKSNIPER_TYPE_INFO,
                rust_offset: offset_of!(GameTweakData, sniper),
            },
            FieldInfoData {
                name: "Panic",
                flags: MemberInfoFlags::new(0),
                field_type: GAMETWEAKPANICBEHAVIOR_TYPE_INFO,
                rust_offset: offset_of!(GameTweakData, panic),
            },
            FieldInfoData {
                name: "Blinded",
                flags: MemberInfoFlags::new(0),
                field_type: GAMETWEAKBLINDEDBEHAVIOR_TYPE_INFO,
                rust_offset: offset_of!(GameTweakData, blinded),
            },
            FieldInfoData {
                name: "AISoundDefaults",
                flags: MemberInfoFlags::new(0),
                field_type: AISOUNDDEFAULTS_TYPE_INFO,
                rust_offset: offset_of!(GameTweakData, a_i_sound_defaults),
            },
            FieldInfoData {
                name: "TeamSettings",
                flags: MemberInfoFlags::new(144),
                field_type: TEAMSETTINGS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(GameTweakData, team_settings),
            },
        ],
    }),
    array_type: Some(GAMETWEAKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameTweakData {
    fn type_info() -> &'static TypeInfo {
        GAMETWEAKDATA_TYPE_INFO
    }
}


pub const GAMETWEAKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct TeamSettings {
    pub team: super::gameplay_sim::TeamId,
    pub enemies: Vec<super::gameplay_sim::TeamId>,
    pub lightweight: bool,
}

pub const TEAMSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Team",
                flags: MemberInfoFlags::new(0),
                field_type: TEAMID_TYPE_INFO,
                rust_offset: offset_of!(TeamSettings, team),
            },
            FieldInfoData {
                name: "Enemies",
                flags: MemberInfoFlags::new(144),
                field_type: TEAMID_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(TeamSettings, enemies),
            },
            FieldInfoData {
                name: "Lightweight",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(TeamSettings, lightweight),
            },
        ],
    }),
    array_type: Some(TEAMSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TeamSettings {
    fn type_info() -> &'static TypeInfo {
        TEAMSETTINGS_TYPE_INFO
    }
}


pub const TEAMSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TeamSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TeamSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GameTweakBlindedBehavior {
    pub blinded_time: f32,
    pub blinded_radius: f32,
}

pub const GAMETWEAKBLINDEDBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakBlindedBehavior",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "BlindedTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakBlindedBehavior, blinded_time),
            },
            FieldInfoData {
                name: "BlindedRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakBlindedBehavior, blinded_radius),
            },
        ],
    }),
    array_type: Some(GAMETWEAKBLINDEDBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GameTweakBlindedBehavior {
    fn type_info() -> &'static TypeInfo {
        GAMETWEAKBLINDEDBEHAVIOR_TYPE_INFO
    }
}


pub const GAMETWEAKBLINDEDBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakBlindedBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakBlindedBehavior-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GameTweakPanicBehavior {
    pub pre_panic_time_min: f32,
    pub pre_panic_time_max: f32,
    pub total_panic_time: f32,
    pub panic_blast_radius_percentage: f32,
    pub panic_on_grenade: bool,
    pub panic_on_weapon_suppression: bool,
    pub panic_on_vehicle_suppression: bool,
}

pub const GAMETWEAKPANICBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakPanicBehavior",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PrePanicTimeMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakPanicBehavior, pre_panic_time_min),
            },
            FieldInfoData {
                name: "PrePanicTimeMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakPanicBehavior, pre_panic_time_max),
            },
            FieldInfoData {
                name: "TotalPanicTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakPanicBehavior, total_panic_time),
            },
            FieldInfoData {
                name: "PanicBlastRadiusPercentage",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakPanicBehavior, panic_blast_radius_percentage),
            },
            FieldInfoData {
                name: "PanicOnGrenade",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakPanicBehavior, panic_on_grenade),
            },
            FieldInfoData {
                name: "PanicOnWeaponSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakPanicBehavior, panic_on_weapon_suppression),
            },
            FieldInfoData {
                name: "PanicOnVehicleSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakPanicBehavior, panic_on_vehicle_suppression),
            },
        ],
    }),
    array_type: Some(GAMETWEAKPANICBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GameTweakPanicBehavior {
    fn type_info() -> &'static TypeInfo {
        GAMETWEAKPANICBEHAVIOR_TYPE_INFO
    }
}


pub const GAMETWEAKPANICBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakPanicBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakPanicBehavior-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GameTweakSniper {
    pub glint_to_shot_fired_delay: f32,
    pub hide_after_shot_delay: f32,
    pub time_up_before_scope_glint: f32,
    pub time_hidden: f32,
}

pub const GAMETWEAKSNIPER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakSniper",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "GlintToShotFiredDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakSniper, glint_to_shot_fired_delay),
            },
            FieldInfoData {
                name: "HideAfterShotDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakSniper, hide_after_shot_delay),
            },
            FieldInfoData {
                name: "TimeUpBeforeScopeGlint",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakSniper, time_up_before_scope_glint),
            },
            FieldInfoData {
                name: "TimeHidden",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakSniper, time_hidden),
            },
        ],
    }),
    array_type: Some(GAMETWEAKSNIPER_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GameTweakSniper {
    fn type_info() -> &'static TypeInfo {
        GAMETWEAKSNIPER_TYPE_INFO
    }
}


pub const GAMETWEAKSNIPER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakSniper-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakSniper-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GameTweakBucketDamage {
    pub player_damage_bucket_times: Vec<f32>,
    pub evasive_bucket_time_settings: EvasiveBucketTimeSettings,
    pub damage_multiplier: f32,
}

pub const GAMETWEAKBUCKETDAMAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakBucketDamage",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PlayerDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(GameTweakBucketDamage, player_damage_bucket_times),
            },
            FieldInfoData {
                name: "EvasiveBucketTimeSettings",
                flags: MemberInfoFlags::new(0),
                field_type: EVASIVEBUCKETTIMESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(GameTweakBucketDamage, evasive_bucket_time_settings),
            },
            FieldInfoData {
                name: "DamageMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakBucketDamage, damage_multiplier),
            },
        ],
    }),
    array_type: Some(GAMETWEAKBUCKETDAMAGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameTweakBucketDamage {
    fn type_info() -> &'static TypeInfo {
        GAMETWEAKBUCKETDAMAGE_TYPE_INFO
    }
}


pub const GAMETWEAKBUCKETDAMAGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakBucketDamage-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakBucketDamage-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GameTweakAITargeting {
    pub firing_delay_after_aquiring_target: TinyPiecewiseLinearCurve,
    pub reaquire_target_distance_threshold: f32,
    pub firing_delay_after_reaquiring_target: TinyPiecewiseLinearCurve,
    pub time_until_damage_from_start_of_first_burst: TinyPiecewiseLinearCurve,
    pub time_until_damage_time_is_fully_restored: TinyPiecewiseLinearCurve,
    pub time_until_accurate_from_start_of_first_damage: TinyPiecewiseLinearCurve,
    pub time_until_accurate_time_is_fully_restored: TinyPiecewiseLinearCurve,
    pub accuracy_penalty_settings: AccuracyPenaltySettings,
    pub aiming_at_angle_threshold: i32,
    pub max_attackers_frequency_modifier: f32,
}

pub const GAMETWEAKAITARGETING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakAITargeting",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "FiringDelayAfterAquiringTarget",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, firing_delay_after_aquiring_target),
            },
            FieldInfoData {
                name: "ReaquireTargetDistanceThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, reaquire_target_distance_threshold),
            },
            FieldInfoData {
                name: "FiringDelayAfterReaquiringTarget",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, firing_delay_after_reaquiring_target),
            },
            FieldInfoData {
                name: "TimeUntilDamageFromStartOfFirstBurst",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, time_until_damage_from_start_of_first_burst),
            },
            FieldInfoData {
                name: "TimeUntilDamageTimeIsFullyRestored",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, time_until_damage_time_is_fully_restored),
            },
            FieldInfoData {
                name: "TimeUntilAccurateFromStartOfFirstDamage",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, time_until_accurate_from_start_of_first_damage),
            },
            FieldInfoData {
                name: "TimeUntilAccurateTimeIsFullyRestored",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, time_until_accurate_time_is_fully_restored),
            },
            FieldInfoData {
                name: "AccuracyPenaltySettings",
                flags: MemberInfoFlags::new(0),
                field_type: ACCURACYPENALTYSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, accuracy_penalty_settings),
            },
            FieldInfoData {
                name: "AimingAtAngleThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, aiming_at_angle_threshold),
            },
            FieldInfoData {
                name: "MaxAttackersFrequencyModifier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakAITargeting, max_attackers_frequency_modifier),
            },
        ],
    }),
    array_type: Some(GAMETWEAKAITARGETING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GameTweakAITargeting {
    fn type_info() -> &'static TypeInfo {
        GAMETWEAKAITARGETING_TYPE_INFO
    }
}


pub const GAMETWEAKAITARGETING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakAITargeting-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakAITargeting-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EvasiveBucketTimeSettings {
    pub sprint_damage_bucket_times: Vec<f32>,
    pub crouch_damage_bucket_times: Vec<f32>,
    pub prone_damage_bucket_times: Vec<f32>,
    pub moving_vehicle_damage_bucket_times: Vec<f32>,
    pub vehicle_still_damage_bucket_times: Vec<f32>,
    pub sprint_speed: f32,
    pub moving_vehicle_speed: f32,
}

pub const EVASIVEBUCKETTIMESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvasiveBucketTimeSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SprintDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EvasiveBucketTimeSettings, sprint_damage_bucket_times),
            },
            FieldInfoData {
                name: "CrouchDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EvasiveBucketTimeSettings, crouch_damage_bucket_times),
            },
            FieldInfoData {
                name: "ProneDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EvasiveBucketTimeSettings, prone_damage_bucket_times),
            },
            FieldInfoData {
                name: "MovingVehicleDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EvasiveBucketTimeSettings, moving_vehicle_damage_bucket_times),
            },
            FieldInfoData {
                name: "VehicleStillDamageBucketTimes",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EvasiveBucketTimeSettings, vehicle_still_damage_bucket_times),
            },
            FieldInfoData {
                name: "SprintSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvasiveBucketTimeSettings, sprint_speed),
            },
            FieldInfoData {
                name: "MovingVehicleSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvasiveBucketTimeSettings, moving_vehicle_speed),
            },
        ],
    }),
    array_type: Some(EVASIVEBUCKETTIMESETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EvasiveBucketTimeSettings {
    fn type_info() -> &'static TypeInfo {
        EVASIVEBUCKETTIMESETTINGS_TYPE_INFO
    }
}


pub const EVASIVEBUCKETTIMESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvasiveBucketTimeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EvasiveBucketTimeSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AccuracyPenaltySettings {
    pub sprint_multiplier: f32,
    pub crouch_multiplier: f32,
    pub prone_multiplier: f32,
    pub moving_vehicle_multiplier: f32,
    pub vehicle_still_multiplier: f32,
    pub sprint_speed: f32,
    pub moving_vehicle_speed: f32,
}

pub const ACCURACYPENALTYSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AccuracyPenaltySettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SprintMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyPenaltySettings, sprint_multiplier),
            },
            FieldInfoData {
                name: "CrouchMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyPenaltySettings, crouch_multiplier),
            },
            FieldInfoData {
                name: "ProneMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyPenaltySettings, prone_multiplier),
            },
            FieldInfoData {
                name: "MovingVehicleMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyPenaltySettings, moving_vehicle_multiplier),
            },
            FieldInfoData {
                name: "VehicleStillMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyPenaltySettings, vehicle_still_multiplier),
            },
            FieldInfoData {
                name: "SprintSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyPenaltySettings, sprint_speed),
            },
            FieldInfoData {
                name: "MovingVehicleSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyPenaltySettings, moving_vehicle_speed),
            },
        ],
    }),
    array_type: Some(ACCURACYPENALTYSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AccuracyPenaltySettings {
    fn type_info() -> &'static TypeInfo {
        ACCURACYPENALTYSETTINGS_TYPE_INFO
    }
}


pub const ACCURACYPENALTYSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AccuracyPenaltySettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AccuracyPenaltySettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GameTweakCommon {
    pub use_new_sensing_areas: bool,
    pub sensing_areas: Vec<SensingArea>,
    pub sensing_areas_alerted_modifier: SensingAreaModifier,
    pub sensing_cone_range: f32,
    pub sensing_cone_range_when_alerted: f32,
    pub sensing_cone_angle: f32,
    pub sensing_cone_angle_when_alerted: f32,
    pub sensing_cone_angle_above: f32,
    pub sensing_cone_angle_below: f32,
    pub sensing_shot_fired_distance: f32,
    pub sensing_human_driven_vehicle_distance: f32,
    pub sensing_explosion_distance: f32,
    pub sensing_grenade_distance: f32,
    pub sensing_static_target_object_distance: f32,
    pub sensing_moving_target_object_distance: f32,
    pub distance_to_aware_time_curve_central: TinyPiecewiseLinearCurve,
    pub aware_curve_central_angle: f32,
    pub distance_to_aware_time_curve_peripheral: TinyPiecewiseLinearCurve,
    pub aware_standing_penalty_multiplier: f32,
    pub aware_to_alert_time: f32,
    pub corpse: CorpseData,
    pub enable_visibility_acummulation: bool,
    pub visibility_acummulation_time: f32,
    pub high_intensity_radius: f32,
    pub investigate_seen_enemy_alert_percent: f32,
    pub ignore_sound_when_alerted: bool,
    pub concealment_cool_down_time: f32,
    pub concealment_disable_at_distance: f32,
    pub passivity: PassivityData,
    pub grenade_tokens: Vec<GrenadeTokenList>,
    pub melee_charge: MeleeChargeData,
    pub creature_melee_charge: MeleeChargeData,
    pub simultaneous_vehicle_usage: i32,
    pub min_vehicle_booking_delay_on_token_available: f32,
    pub max_vehicle_booking_delay_on_token_available: f32,
    pub min_vehicle_entry_available_delay_after_death: f32,
    pub max_vehicle_entry_available_delay_after_death: f32,
    pub enemy_min_time_in_medium_intensity: f32,
    pub investigate: InvestigateData,
    pub include_terrain_in_vision_tests: bool,
    pub use_cover_approx_fire_position_for_vision: bool,
    pub teams_with_awareness: Vec<super::gameplay_sim::TeamId>,
    pub enable_last_known_position_sharing: bool,
    pub max_last_known_position_share_distance: f32,
    pub alerted_by_friendly_combat_actions: bool,
    pub being_charged_causes_alert: bool,
    pub being_charged_detect_distance: f32,
    pub being_charged_angle_limit: f32,
    pub use_visible_l_k_p_sharing: bool,
    pub use_sound_l_k_p_update: bool,
    pub aim_at_l_k_p_when_target_lost: bool,
    pub max_last_seen_distance_for_l_k_p_lost: f32,
    pub min_reaction_time_for_l_k_p_reaqcuire: f32,
    pub max_reaction_time_for_l_k_p_reaqcuire: f32,
    pub target_coordination: TargetCoordinationGlobalSettings,
    pub temperature: TemperatureData,
}

pub const GAMETWEAKCOMMON_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakCommon",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "UseNewSensingAreas",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, use_new_sensing_areas),
            },
            FieldInfoData {
                name: "SensingAreas",
                flags: MemberInfoFlags::new(144),
                field_type: SENSINGAREA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_areas),
            },
            FieldInfoData {
                name: "SensingAreasAlertedModifier",
                flags: MemberInfoFlags::new(0),
                field_type: SENSINGAREAMODIFIER_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_areas_alerted_modifier),
            },
            FieldInfoData {
                name: "SensingConeRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_range),
            },
            FieldInfoData {
                name: "SensingConeRangeWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_range_when_alerted),
            },
            FieldInfoData {
                name: "SensingConeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_angle),
            },
            FieldInfoData {
                name: "SensingConeAngleWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_angle_when_alerted),
            },
            FieldInfoData {
                name: "SensingConeAngleAbove",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_angle_above),
            },
            FieldInfoData {
                name: "SensingConeAngleBelow",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_cone_angle_below),
            },
            FieldInfoData {
                name: "SensingShotFiredDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_shot_fired_distance),
            },
            FieldInfoData {
                name: "SensingHumanDrivenVehicleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_human_driven_vehicle_distance),
            },
            FieldInfoData {
                name: "SensingExplosionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_explosion_distance),
            },
            FieldInfoData {
                name: "SensingGrenadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_grenade_distance),
            },
            FieldInfoData {
                name: "SensingStaticTargetObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_static_target_object_distance),
            },
            FieldInfoData {
                name: "SensingMovingTargetObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, sensing_moving_target_object_distance),
            },
            FieldInfoData {
                name: "DistanceToAwareTimeCurveCentral",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, distance_to_aware_time_curve_central),
            },
            FieldInfoData {
                name: "AwareCurveCentralAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, aware_curve_central_angle),
            },
            FieldInfoData {
                name: "DistanceToAwareTimeCurvePeripheral",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, distance_to_aware_time_curve_peripheral),
            },
            FieldInfoData {
                name: "AwareStandingPenaltyMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, aware_standing_penalty_multiplier),
            },
            FieldInfoData {
                name: "AwareToAlertTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, aware_to_alert_time),
            },
            FieldInfoData {
                name: "Corpse",
                flags: MemberInfoFlags::new(0),
                field_type: CORPSEDATA_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, corpse),
            },
            FieldInfoData {
                name: "EnableVisibilityAcummulation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, enable_visibility_acummulation),
            },
            FieldInfoData {
                name: "VisibilityAcummulationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, visibility_acummulation_time),
            },
            FieldInfoData {
                name: "HighIntensityRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, high_intensity_radius),
            },
            FieldInfoData {
                name: "InvestigateSeenEnemyAlertPercent",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, investigate_seen_enemy_alert_percent),
            },
            FieldInfoData {
                name: "IgnoreSoundWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, ignore_sound_when_alerted),
            },
            FieldInfoData {
                name: "ConcealmentCoolDownTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, concealment_cool_down_time),
            },
            FieldInfoData {
                name: "ConcealmentDisableAtDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, concealment_disable_at_distance),
            },
            FieldInfoData {
                name: "Passivity",
                flags: MemberInfoFlags::new(0),
                field_type: PASSIVITYDATA_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, passivity),
            },
            FieldInfoData {
                name: "GrenadeTokens",
                flags: MemberInfoFlags::new(144),
                field_type: GRENADETOKENLIST_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, grenade_tokens),
            },
            FieldInfoData {
                name: "MeleeCharge",
                flags: MemberInfoFlags::new(0),
                field_type: MELEECHARGEDATA_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, melee_charge),
            },
            FieldInfoData {
                name: "CreatureMeleeCharge",
                flags: MemberInfoFlags::new(0),
                field_type: MELEECHARGEDATA_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, creature_melee_charge),
            },
            FieldInfoData {
                name: "SimultaneousVehicleUsage",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, simultaneous_vehicle_usage),
            },
            FieldInfoData {
                name: "MinVehicleBookingDelayOnTokenAvailable",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, min_vehicle_booking_delay_on_token_available),
            },
            FieldInfoData {
                name: "MaxVehicleBookingDelayOnTokenAvailable",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, max_vehicle_booking_delay_on_token_available),
            },
            FieldInfoData {
                name: "MinVehicleEntryAvailableDelayAfterDeath",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, min_vehicle_entry_available_delay_after_death),
            },
            FieldInfoData {
                name: "MaxVehicleEntryAvailableDelayAfterDeath",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, max_vehicle_entry_available_delay_after_death),
            },
            FieldInfoData {
                name: "EnemyMinTimeInMediumIntensity",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, enemy_min_time_in_medium_intensity),
            },
            FieldInfoData {
                name: "Investigate",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATEDATA_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, investigate),
            },
            FieldInfoData {
                name: "IncludeTerrainInVisionTests",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, include_terrain_in_vision_tests),
            },
            FieldInfoData {
                name: "UseCoverApproxFirePositionForVision",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, use_cover_approx_fire_position_for_vision),
            },
            FieldInfoData {
                name: "TeamsWithAwareness",
                flags: MemberInfoFlags::new(144),
                field_type: TEAMID_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, teams_with_awareness),
            },
            FieldInfoData {
                name: "EnableLastKnownPositionSharing",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, enable_last_known_position_sharing),
            },
            FieldInfoData {
                name: "MaxLastKnownPositionShareDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, max_last_known_position_share_distance),
            },
            FieldInfoData {
                name: "AlertedByFriendlyCombatActions",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, alerted_by_friendly_combat_actions),
            },
            FieldInfoData {
                name: "BeingChargedCausesAlert",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, being_charged_causes_alert),
            },
            FieldInfoData {
                name: "BeingChargedDetectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, being_charged_detect_distance),
            },
            FieldInfoData {
                name: "BeingChargedAngleLimit",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, being_charged_angle_limit),
            },
            FieldInfoData {
                name: "UseVisibleLKPSharing",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, use_visible_l_k_p_sharing),
            },
            FieldInfoData {
                name: "UseSoundLKPUpdate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, use_sound_l_k_p_update),
            },
            FieldInfoData {
                name: "AimAtLKPWhenTargetLost",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, aim_at_l_k_p_when_target_lost),
            },
            FieldInfoData {
                name: "MaxLastSeenDistanceForLKPLost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, max_last_seen_distance_for_l_k_p_lost),
            },
            FieldInfoData {
                name: "MinReactionTimeForLKPReaqcuire",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, min_reaction_time_for_l_k_p_reaqcuire),
            },
            FieldInfoData {
                name: "MaxReactionTimeForLKPReaqcuire",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, max_reaction_time_for_l_k_p_reaqcuire),
            },
            FieldInfoData {
                name: "TargetCoordination",
                flags: MemberInfoFlags::new(0),
                field_type: TARGETCOORDINATIONGLOBALSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, target_coordination),
            },
            FieldInfoData {
                name: "Temperature",
                flags: MemberInfoFlags::new(0),
                field_type: TEMPERATUREDATA_TYPE_INFO,
                rust_offset: offset_of!(GameTweakCommon, temperature),
            },
        ],
    }),
    array_type: Some(GAMETWEAKCOMMON_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GameTweakCommon {
    fn type_info() -> &'static TypeInfo {
        GAMETWEAKCOMMON_TYPE_INFO
    }
}


pub const GAMETWEAKCOMMON_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GameTweakCommon-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GameTweakCommon-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CorpseData {
    pub instantly_alerted_by_corpse: bool,
    pub corpse_alert_distance: f32,
    pub allow_multiple_corpse_investigators: bool,
    pub corpses_cause_alertness_increase: bool,
    pub corpses_trigger_search_area: bool,
}

pub const CORPSEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorpseData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "InstantlyAlertedByCorpse",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CorpseData, instantly_alerted_by_corpse),
            },
            FieldInfoData {
                name: "CorpseAlertDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CorpseData, corpse_alert_distance),
            },
            FieldInfoData {
                name: "AllowMultipleCorpseInvestigators",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CorpseData, allow_multiple_corpse_investigators),
            },
            FieldInfoData {
                name: "CorpsesCauseAlertnessIncrease",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CorpseData, corpses_cause_alertness_increase),
            },
            FieldInfoData {
                name: "CorpsesTriggerSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CorpseData, corpses_trigger_search_area),
            },
        ],
    }),
    array_type: Some(CORPSEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CorpseData {
    fn type_info() -> &'static TypeInfo {
        CORPSEDATA_TYPE_INFO
    }
}


pub const CORPSEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CorpseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CorpseData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct TemperatureData {
    pub use_temperature_settings: bool,
    pub search_threshold: f32,
    pub alert_threshold: f32,
    pub cooldown_timer: f32,
    pub cooldown_per_second: f32,
    pub broadcast_react_cooldown: f32,
    pub visual_temperature: u8,
    pub aware_modifier: AwareModifierSettings,
}

pub const TEMPERATUREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TemperatureData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "UseTemperatureSettings",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(TemperatureData, use_temperature_settings),
            },
            FieldInfoData {
                name: "SearchThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TemperatureData, search_threshold),
            },
            FieldInfoData {
                name: "AlertThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TemperatureData, alert_threshold),
            },
            FieldInfoData {
                name: "CooldownTimer",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TemperatureData, cooldown_timer),
            },
            FieldInfoData {
                name: "CooldownPerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TemperatureData, cooldown_per_second),
            },
            FieldInfoData {
                name: "BroadcastReactCooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TemperatureData, broadcast_react_cooldown),
            },
            FieldInfoData {
                name: "VisualTemperature",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(TemperatureData, visual_temperature),
            },
            FieldInfoData {
                name: "AwareModifier",
                flags: MemberInfoFlags::new(0),
                field_type: AWAREMODIFIERSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(TemperatureData, aware_modifier),
            },
        ],
    }),
    array_type: Some(TEMPERATUREDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TemperatureData {
    fn type_info() -> &'static TypeInfo {
        TEMPERATUREDATA_TYPE_INFO
    }
}


pub const TEMPERATUREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TemperatureData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TemperatureData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct InvestigateData {
    pub max_time_since_enemy_lost_to_start_combat_investigate: f32,
    pub max_time_since_enemy_lost_to_search: f32,
    pub combat_investigate_can_exceed_max_search_time: bool,
    pub min_time_to_stay_alert_when_alerted_by_something_other_than_sighting: f32,
    pub area_search_without_combat_investigate: bool,
    pub investigate_latest_sound: bool,
    pub fallback_to_search_area_when_never_seen_enemy_time: f32,
    pub min_time_from_recent_threat_to_search_area: f32,
    pub use_investigation_priorities: bool,
    pub investigate_customization: InvestigateSettignsCustomizations,
}

pub const INVESTIGATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MaxTimeSinceEnemyLostToStartCombatInvestigate",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, max_time_since_enemy_lost_to_start_combat_investigate),
            },
            FieldInfoData {
                name: "MaxTimeSinceEnemyLostToSearch",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, max_time_since_enemy_lost_to_search),
            },
            FieldInfoData {
                name: "CombatInvestigateCanExceedMaxSearchTime",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, combat_investigate_can_exceed_max_search_time),
            },
            FieldInfoData {
                name: "MinTimeToStayAlertWhenAlertedBySomethingOtherThanSighting",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, min_time_to_stay_alert_when_alerted_by_something_other_than_sighting),
            },
            FieldInfoData {
                name: "AreaSearchWithoutCombatInvestigate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, area_search_without_combat_investigate),
            },
            FieldInfoData {
                name: "InvestigateLatestSound",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, investigate_latest_sound),
            },
            FieldInfoData {
                name: "FallbackToSearchAreaWhenNeverSeenEnemyTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, fallback_to_search_area_when_never_seen_enemy_time),
            },
            FieldInfoData {
                name: "MinTimeFromRecentThreatToSearchArea",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, min_time_from_recent_threat_to_search_area),
            },
            FieldInfoData {
                name: "UseInvestigationPriorities",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, use_investigation_priorities),
            },
            FieldInfoData {
                name: "InvestigateCustomization",
                flags: MemberInfoFlags::new(0),
                field_type: INVESTIGATESETTIGNSCUSTOMIZATIONS_TYPE_INFO,
                rust_offset: offset_of!(InvestigateData, investigate_customization),
            },
        ],
    }),
    array_type: Some(INVESTIGATEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for InvestigateData {
    fn type_info() -> &'static TypeInfo {
        INVESTIGATEDATA_TYPE_INFO
    }
}


pub const INVESTIGATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "InvestigateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("InvestigateData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MeleeChargeData {
    pub melee_slot_count: i32,
    pub melee_slot_radius: f32,
    pub melee_slot_extrapolate_distance: f32,
    pub melee_charge_token_minimum_time: f32,
    pub melee_charge_token_maximum_time: f32,
    pub melee_charge_token_count: i32,
    pub melee_charge_minimum_cooldown_timer: f32,
    pub simultaneous_charge_count: i32,
}

pub const MELEECHARGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeChargeData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MeleeSlotCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeData, melee_slot_count),
            },
            FieldInfoData {
                name: "MeleeSlotRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeData, melee_slot_radius),
            },
            FieldInfoData {
                name: "MeleeSlotExtrapolateDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeData, melee_slot_extrapolate_distance),
            },
            FieldInfoData {
                name: "MeleeChargeTokenMinimumTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeData, melee_charge_token_minimum_time),
            },
            FieldInfoData {
                name: "MeleeChargeTokenMaximumTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeData, melee_charge_token_maximum_time),
            },
            FieldInfoData {
                name: "MeleeChargeTokenCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeData, melee_charge_token_count),
            },
            FieldInfoData {
                name: "MeleeChargeMinimumCooldownTimer",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeData, melee_charge_minimum_cooldown_timer),
            },
            FieldInfoData {
                name: "SimultaneousChargeCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(MeleeChargeData, simultaneous_charge_count),
            },
        ],
    }),
    array_type: Some(MELEECHARGEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MeleeChargeData {
    fn type_info() -> &'static TypeInfo {
        MELEECHARGEDATA_TYPE_INFO
    }
}


pub const MELEECHARGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MeleeChargeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("MeleeChargeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PassivityData {
    pub passive_damage_time: PiecewiseLinearCurve,
    pub passive_movement_time: PiecewiseLinearCurve,
    pub passive_movement_dist: f32,
}

pub const PASSIVITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PassivityData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PassiveDamageTime",
                flags: MemberInfoFlags::new(0),
                field_type: PIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(PassivityData, passive_damage_time),
            },
            FieldInfoData {
                name: "PassiveMovementTime",
                flags: MemberInfoFlags::new(0),
                field_type: PIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(PassivityData, passive_movement_time),
            },
            FieldInfoData {
                name: "PassiveMovementDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PassivityData, passive_movement_dist),
            },
        ],
    }),
    array_type: Some(PASSIVITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PassivityData {
    fn type_info() -> &'static TypeInfo {
        PASSIVITYDATA_TYPE_INFO
    }
}


pub const PASSIVITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PassivityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PassivityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AwareModifierSettings {
    pub curve: PiecewiseLinearCurve,
}

pub const AWAREMODIFIERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwareModifierSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(0),
                field_type: PIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(AwareModifierSettings, curve),
            },
        ],
    }),
    array_type: Some(AWAREMODIFIERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AwareModifierSettings {
    fn type_info() -> &'static TypeInfo {
        AWAREMODIFIERSETTINGS_TYPE_INFO
    }
}


pub const AWAREMODIFIERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AwareModifierSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AwareModifierSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SensingAreaModifier {
    pub settings: Vec<SensingAreaModifierSettings>,
}

pub const SENSINGAREAMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifier",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(144),
                field_type: SENSINGAREAMODIFIERSETTINGS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifier, settings),
            },
        ],
    }),
    array_type: Some(SENSINGAREAMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SensingAreaModifier {
    fn type_info() -> &'static TypeInfo {
        SENSINGAREAMODIFIER_TYPE_INFO
    }
}


pub const SENSINGAREAMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingAreaModifier-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SensingAreaModifierSettings {
    pub affected_areas: Vec<SensingAreaId>,
    pub required_tactics: Vec<Tactics>,
    pub set_enabled: bool,
    pub set_disabled: bool,
    pub range_scale: f32,
    pub angle_scale: f32,
    pub angle_above_scale: f32,
    pub angle_below_scale: f32,
    pub time_scale: f32,
}

pub const SENSINGAREAMODIFIERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifierSettings",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AffectedAreas",
                flags: MemberInfoFlags::new(144),
                field_type: SENSINGAREAID_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierSettings, affected_areas),
            },
            FieldInfoData {
                name: "RequiredTactics",
                flags: MemberInfoFlags::new(144),
                field_type: TACTICS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierSettings, required_tactics),
            },
            FieldInfoData {
                name: "SetEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierSettings, set_enabled),
            },
            FieldInfoData {
                name: "SetDisabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierSettings, set_disabled),
            },
            FieldInfoData {
                name: "RangeScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierSettings, range_scale),
            },
            FieldInfoData {
                name: "AngleScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierSettings, angle_scale),
            },
            FieldInfoData {
                name: "AngleAboveScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierSettings, angle_above_scale),
            },
            FieldInfoData {
                name: "AngleBelowScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierSettings, angle_below_scale),
            },
            FieldInfoData {
                name: "TimeScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaModifierSettings, time_scale),
            },
        ],
    }),
    array_type: Some(SENSINGAREAMODIFIERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SensingAreaModifierSettings {
    fn type_info() -> &'static TypeInfo {
        SENSINGAREAMODIFIERSETTINGS_TYPE_INFO
    }
}


pub const SENSINGAREAMODIFIERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaModifierSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingAreaModifierSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SensingArea {
    pub area_id: SensingAreaId,
    pub enabled: bool,
    pub range: f32,
    pub angle: f32,
    pub angle_above: f32,
    pub angle_below: f32,
    pub aware_time_distance_curve: super::core::FloatCurve,
    pub aware_time_angle_curve: super::core::FloatCurve,
    pub time_scale: f32,
    pub enabled_ref_count: i32,
}

pub const SENSINGAREA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingArea",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AreaId",
                flags: MemberInfoFlags::new(0),
                field_type: SENSINGAREAID_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, area_id),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, enabled),
            },
            FieldInfoData {
                name: "Range",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, range),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, angle),
            },
            FieldInfoData {
                name: "AngleAbove",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, angle_above),
            },
            FieldInfoData {
                name: "AngleBelow",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, angle_below),
            },
            FieldInfoData {
                name: "AwareTimeDistanceCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, aware_time_distance_curve),
            },
            FieldInfoData {
                name: "AwareTimeAngleCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, aware_time_angle_curve),
            },
            FieldInfoData {
                name: "TimeScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, time_scale),
            },
            FieldInfoData {
                name: "EnabledRefCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SensingArea, enabled_ref_count),
            },
        ],
    }),
    array_type: Some(SENSINGAREA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SensingArea {
    fn type_info() -> &'static TypeInfo {
        SENSINGAREA_TYPE_INFO
    }
}


pub const SENSINGAREA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingArea-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingArea-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SensingAreaId {
    pub area_category: i32,
    pub area_type: i32,
}

pub const SENSINGAREAID_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaId",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AreaCategory",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaId, area_category),
            },
            FieldInfoData {
                name: "AreaType",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SensingAreaId, area_type),
            },
        ],
    }),
    array_type: Some(SENSINGAREAID_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SensingAreaId {
    fn type_info() -> &'static TypeInfo {
        SENSINGAREAID_TYPE_INFO
    }
}


pub const SENSINGAREAID_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SensingAreaId-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SensingAreaId-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GrenadeTokenList {
    pub token_type: GrenadeTokenType,
    pub grenade_minimum_time: f32,
    pub grenade_maximum_time: f32,
    pub max_simultaneous_grenades: i32,
}

pub const GRENADETOKENLIST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTokenList",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "TokenType",
                flags: MemberInfoFlags::new(0),
                field_type: GRENADETOKENTYPE_TYPE_INFO,
                rust_offset: offset_of!(GrenadeTokenList, token_type),
            },
            FieldInfoData {
                name: "GrenadeMinimumTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GrenadeTokenList, grenade_minimum_time),
            },
            FieldInfoData {
                name: "GrenadeMaximumTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(GrenadeTokenList, grenade_maximum_time),
            },
            FieldInfoData {
                name: "MaxSimultaneousGrenades",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(GrenadeTokenList, max_simultaneous_grenades),
            },
        ],
    }),
    array_type: Some(GRENADETOKENLIST_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for GrenadeTokenList {
    fn type_info() -> &'static TypeInfo {
        GRENADETOKENLIST_TYPE_INFO
    }
}


pub const GRENADETOKENLIST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GrenadeTokenList-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("GrenadeTokenList-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PiecewiseLinearCurve {
    pub points: Vec<CurvePoint>,
    pub interpolate_curve: bool,
}

pub const PIECEWISELINEARCURVE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PiecewiseLinearCurve",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Points",
                flags: MemberInfoFlags::new(144),
                field_type: CURVEPOINT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(PiecewiseLinearCurve, points),
            },
            FieldInfoData {
                name: "InterpolateCurve",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(PiecewiseLinearCurve, interpolate_curve),
            },
        ],
    }),
    array_type: Some(PIECEWISELINEARCURVE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PiecewiseLinearCurve {
    fn type_info() -> &'static TypeInfo {
        PIECEWISELINEARCURVE_TYPE_INFO
    }
}


pub const PIECEWISELINEARCURVE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PiecewiseLinearCurve-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PiecewiseLinearCurve-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CurvePoint {
    pub x: f32,
    pub y: f32,
}

pub const CURVEPOINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CurvePoint",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CurvePoint, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CurvePoint, y),
            },
        ],
    }),
    array_type: Some(CURVEPOINT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CurvePoint {
    fn type_info() -> &'static TypeInfo {
        CURVEPOINT_TYPE_INFO
    }
}


pub const CURVEPOINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CurvePoint-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CurvePoint-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct TinyPiecewiseLinearCurve {
    pub x0: f32,
    pub y0: f32,
    pub x1: f32,
    pub y1: f32,
}

pub const TINYPIECEWISELINEARCURVE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TinyPiecewiseLinearCurve",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "X0",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TinyPiecewiseLinearCurve, x0),
            },
            FieldInfoData {
                name: "Y0",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TinyPiecewiseLinearCurve, y0),
            },
            FieldInfoData {
                name: "X1",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TinyPiecewiseLinearCurve, x1),
            },
            FieldInfoData {
                name: "Y1",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TinyPiecewiseLinearCurve, y1),
            },
        ],
    }),
    array_type: Some(TINYPIECEWISELINEARCURVE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TinyPiecewiseLinearCurve {
    fn type_info() -> &'static TypeInfo {
        TINYPIECEWISELINEARCURVE_TYPE_INFO
    }
}


pub const TINYPIECEWISELINEARCURVE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TinyPiecewiseLinearCurve-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TinyPiecewiseLinearCurve-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct FiringPatternCollectionData {
    pub patterns: Vec<FiringPatternData>,
}

pub const FIRINGPATTERNCOLLECTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringPatternCollectionData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Patterns",
                flags: MemberInfoFlags::new(144),
                field_type: FIRINGPATTERNDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(FiringPatternCollectionData, patterns),
            },
        ],
    }),
    array_type: Some(FIRINGPATTERNCOLLECTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FiringPatternCollectionData {
    fn type_info() -> &'static TypeInfo {
        FIRINGPATTERNCOLLECTIONDATA_TYPE_INFO
    }
}


pub const FIRINGPATTERNCOLLECTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringPatternCollectionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FiringPatternCollectionData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct FiringPatternData {
    pub id: i32,
    pub pattern: u64,
    pub single_shot: bool,
    pub weapon_class: FiringWeaponClass,
    pub intensity: IntensityClass,
    pub delay: i32,
}

pub const FIRINGPATTERNDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringPatternData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(FiringPatternData, id),
            },
            FieldInfoData {
                name: "Pattern",
                flags: MemberInfoFlags::new(0),
                field_type: UINT64_TYPE_INFO,
                rust_offset: offset_of!(FiringPatternData, pattern),
            },
            FieldInfoData {
                name: "SingleShot",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FiringPatternData, single_shot),
            },
            FieldInfoData {
                name: "WeaponClass",
                flags: MemberInfoFlags::new(0),
                field_type: FIRINGWEAPONCLASS_TYPE_INFO,
                rust_offset: offset_of!(FiringPatternData, weapon_class),
            },
            FieldInfoData {
                name: "Intensity",
                flags: MemberInfoFlags::new(0),
                field_type: INTENSITYCLASS_TYPE_INFO,
                rust_offset: offset_of!(FiringPatternData, intensity),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(FiringPatternData, delay),
            },
        ],
    }),
    array_type: Some(FIRINGPATTERNDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FiringPatternData {
    fn type_info() -> &'static TypeInfo {
        FIRINGPATTERNDATA_TYPE_INFO
    }
}


pub const FIRINGPATTERNDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringPatternData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FiringPatternData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum IntensityClass {
    #[default]
    IntensityClass_Low = 0,
    IntensityClass_Medium = 1,
    IntensityClass_High = 2,
    IntensityClass_Engaging = 3,
}

pub const INTENSITYCLASS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntensityClass",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(INTENSITYCLASS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for IntensityClass {
    fn type_info() -> &'static TypeInfo {
        INTENSITYCLASS_TYPE_INFO
    }
}


pub const INTENSITYCLASS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IntensityClass-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("IntensityClass-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum FiringWeaponClass {
    #[default]
    WeaponClass_AssaultRifle = 0,
    WeaponClass_MachineGun = 1,
    WeaponClass_Pistol = 2,
    WeaponClass_SniperRifle = 3,
    WeaponClass_SMG = 4,
    WeaponClass_Shotgun = 5,
}

pub const FIRINGWEAPONCLASS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringWeaponClass",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(FIRINGWEAPONCLASS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FiringWeaponClass {
    fn type_info() -> &'static TypeInfo {
        FIRINGWEAPONCLASS_TYPE_INFO
    }
}


pub const FIRINGWEAPONCLASS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringWeaponClass-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FiringWeaponClass-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ProtectBaseManeuverEntityData {
    pub base_position: super::core::Vec3,
    pub radius: f32,
}

pub const PROTECTBASEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProtectBaseManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "BasePosition",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(ProtectBaseManeuverEntityData, base_position),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProtectBaseManeuverEntityData, radius),
            },
        ],
    }),
    array_type: Some(PROTECTBASEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ProtectBaseManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        PROTECTBASEMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const PROTECTBASEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProtectBaseManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ProtectBaseManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CreateDistanceManeuverEntityData {
    pub distance: f32,
    pub min_distance_to_break_out: f32,
    pub min_altitude: f32,
}

pub const CREATEDISTANCEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateDistanceManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CreateDistanceManeuverEntityData, distance),
            },
            FieldInfoData {
                name: "MinDistanceToBreakOut",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CreateDistanceManeuverEntityData, min_distance_to_break_out),
            },
            FieldInfoData {
                name: "MinAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CreateDistanceManeuverEntityData, min_altitude),
            },
        ],
    }),
    array_type: Some(CREATEDISTANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CreateDistanceManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        CREATEDISTANCEMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const CREATEDISTANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreateDistanceManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CreateDistanceManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SetWaypointsEntityData {
    pub realm: super::core::Realm,
    pub speed: f32,
    pub looping: bool,
    pub start_at_geometrically_closest_waypoint: bool,
}

pub const SETWAYPOINTSENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetWaypointsEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(SetWaypointsEntityData, realm),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SetWaypointsEntityData, speed),
            },
            FieldInfoData {
                name: "Looping",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SetWaypointsEntityData, looping),
            },
            FieldInfoData {
                name: "StartAtGeometricallyClosestWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SetWaypointsEntityData, start_at_geometrically_closest_waypoint),
            },
        ],
    }),
    array_type: Some(SETWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SetWaypointsEntityData {
    fn type_info() -> &'static TypeInfo {
        SETWAYPOINTSENTITYDATA_TYPE_INFO
    }
}


pub const SETWAYPOINTSENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SetWaypointsEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SetWaypointsEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowWaypointsManeuverEntityData {
    pub look_ahead_time: f32,
    pub physics_extrapolation_time: f32,
    pub extrapolate_rotation: bool,
}

pub const FOLLOWWAYPOINTSMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowWaypointsManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowWaypointsManeuverEntityData, look_ahead_time),
            },
            FieldInfoData {
                name: "PhysicsExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowWaypointsManeuverEntityData, physics_extrapolation_time),
            },
            FieldInfoData {
                name: "ExtrapolateRotation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FollowWaypointsManeuverEntityData, extrapolate_rotation),
            },
        ],
    }),
    array_type: Some(FOLLOWWAYPOINTSMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowWaypointsManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        FOLLOWWAYPOINTSMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const FOLLOWWAYPOINTSMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowWaypointsManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FollowWaypointsManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FlyToManeuverEntityData {
    pub destination: super::core::Vec3,
    pub arrived_distance: f32,
    pub speed: f32,
    pub should_chase_destination: bool,
    pub extrapolation_time: f32,
    pub extrapolation_delta_time: f32,
    pub extrapolate_rotation: bool,
    pub extrapolate_target_position: bool,
    pub chase_distance: f32,
    pub throttle_p_i_d: super::game_shared::PID,
}

pub const FLYTOMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlyToManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Destination",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, destination),
            },
            FieldInfoData {
                name: "ArrivedDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, arrived_distance),
            },
            FieldInfoData {
                name: "Speed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, speed),
            },
            FieldInfoData {
                name: "ShouldChaseDestination",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, should_chase_destination),
            },
            FieldInfoData {
                name: "ExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, extrapolation_time),
            },
            FieldInfoData {
                name: "ExtrapolationDeltaTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, extrapolation_delta_time),
            },
            FieldInfoData {
                name: "ExtrapolateRotation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, extrapolate_rotation),
            },
            FieldInfoData {
                name: "ExtrapolateTargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, extrapolate_target_position),
            },
            FieldInfoData {
                name: "ChaseDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, chase_distance),
            },
            FieldInfoData {
                name: "ThrottlePID",
                flags: MemberInfoFlags::new(0),
                field_type: PID_TYPE_INFO,
                rust_offset: offset_of!(FlyToManeuverEntityData, throttle_p_i_d),
            },
        ],
    }),
    array_type: Some(FLYTOMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for FlyToManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        FLYTOMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const FLYTOMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlyToManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FlyToManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct StallTurnManeuverEntityData {
    pub max_altitude_to_run: f32,
    pub climb: f32,
    pub substate_duration_scale: f32,
}

pub const STALLTURNMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StallTurnManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MaxAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StallTurnManeuverEntityData, max_altitude_to_run),
            },
            FieldInfoData {
                name: "Climb",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StallTurnManeuverEntityData, climb),
            },
            FieldInfoData {
                name: "SubstateDurationScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StallTurnManeuverEntityData, substate_duration_scale),
            },
        ],
    }),
    array_type: Some(STALLTURNMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StallTurnManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        STALLTURNMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const STALLTURNMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StallTurnManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StallTurnManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SpinDescentManeuverEntityData {
    pub min_altitude_to_run: f32,
    pub break_out_altitude: f32,
    pub break_out_on_collision_avoidance: bool,
    pub max_duration: f32,
    pub local_fly_to_pos: super::core::Vec3,
}

pub const SPINDESCENTMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpinDescentManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MinAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SpinDescentManeuverEntityData, min_altitude_to_run),
            },
            FieldInfoData {
                name: "BreakOutAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SpinDescentManeuverEntityData, break_out_altitude),
            },
            FieldInfoData {
                name: "BreakOutOnCollisionAvoidance",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SpinDescentManeuverEntityData, break_out_on_collision_avoidance),
            },
            FieldInfoData {
                name: "MaxDuration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SpinDescentManeuverEntityData, max_duration),
            },
            FieldInfoData {
                name: "LocalFlyToPos",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(SpinDescentManeuverEntityData, local_fly_to_pos),
            },
        ],
    }),
    array_type: Some(SPINDESCENTMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SpinDescentManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        SPINDESCENTMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const SPINDESCENTMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpinDescentManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SpinDescentManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SideToSideManeuverEntityData {
    pub duration: f32,
    pub oscillation_frequency: f32,
}

pub const SIDETOSIDEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SideToSideManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Duration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SideToSideManeuverEntityData, duration),
            },
            FieldInfoData {
                name: "OscillationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SideToSideManeuverEntityData, oscillation_frequency),
            },
        ],
    }),
    array_type: Some(SIDETOSIDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SideToSideManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        SIDETOSIDEMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const SIDETOSIDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SideToSideManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SideToSideManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ImmelmannManeuverEntityData {
    pub max_altitude_to_run: f32,
    pub substate_duration_scale: f32,
}

pub const IMMELMANNMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImmelmannManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MaxAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ImmelmannManeuverEntityData, max_altitude_to_run),
            },
            FieldInfoData {
                name: "SubstateDurationScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ImmelmannManeuverEntityData, substate_duration_scale),
            },
        ],
    }),
    array_type: Some(IMMELMANNMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ImmelmannManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        IMMELMANNMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const IMMELMANNMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImmelmannManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ImmelmannManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BarrelRollManeuverEntityData {
    pub duration: f32,
    pub radius: f32,
    pub distance: f32,
    pub rotation_velocity: f32,
    pub min_altitude_to_run: f32,
    pub max_altitude_to_run: f32,
}

pub const BARRELROLLMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BarrelRollManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Duration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BarrelRollManeuverEntityData, duration),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BarrelRollManeuverEntityData, radius),
            },
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BarrelRollManeuverEntityData, distance),
            },
            FieldInfoData {
                name: "RotationVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BarrelRollManeuverEntityData, rotation_velocity),
            },
            FieldInfoData {
                name: "MinAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BarrelRollManeuverEntityData, min_altitude_to_run),
            },
            FieldInfoData {
                name: "MaxAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BarrelRollManeuverEntityData, max_altitude_to_run),
            },
        ],
    }),
    array_type: Some(BARRELROLLMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BarrelRollManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        BARRELROLLMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const BARRELROLLMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BarrelRollManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BarrelRollManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SplitSManeuverEntityData {
    pub climb: f32,
    pub max_altitude_to_run: f32,
    pub min_altitude_to_run: f32,
    pub substate_duration_scale: f32,
}

pub const SPLITSMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SplitSManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Climb",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SplitSManeuverEntityData, climb),
            },
            FieldInfoData {
                name: "MaxAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SplitSManeuverEntityData, max_altitude_to_run),
            },
            FieldInfoData {
                name: "MinAltitudeToRun",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SplitSManeuverEntityData, min_altitude_to_run),
            },
            FieldInfoData {
                name: "SubstateDurationScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SplitSManeuverEntityData, substate_duration_scale),
            },
        ],
    }),
    array_type: Some(SPLITSMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SplitSManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        SPLITSMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const SPLITSMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SplitSManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SplitSManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BasicDefensiveManeuverEntityData {
    pub target_max_distance: f32,
    pub target_max_distance_slack: f32,
    pub fly_straight_time: f32,
    pub oscillate_time: f32,
    pub oscillation_frequency: f32,
    pub sharp_turn_time: f32,
    pub dive_time: f32,
    pub looping_time: f32,
}

pub const BASICDEFENSIVEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicDefensiveManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "TargetMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, target_max_distance),
            },
            FieldInfoData {
                name: "TargetMaxDistanceSlack",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, target_max_distance_slack),
            },
            FieldInfoData {
                name: "FlyStraightTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, fly_straight_time),
            },
            FieldInfoData {
                name: "OscillateTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, oscillate_time),
            },
            FieldInfoData {
                name: "OscillationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, oscillation_frequency),
            },
            FieldInfoData {
                name: "SharpTurnTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, sharp_turn_time),
            },
            FieldInfoData {
                name: "DiveTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, dive_time),
            },
            FieldInfoData {
                name: "LoopingTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicDefensiveManeuverEntityData, looping_time),
            },
        ],
    }),
    array_type: Some(BASICDEFENSIVEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicDefensiveManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        BASICDEFENSIVEMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const BASICDEFENSIVEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicDefensiveManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BasicDefensiveManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct StrafeRunManeuverEntityData {
    pub altitude_difference_to_attack: f32,
    pub dive_angle: f32,
    pub attack_speed: f32,
    pub break_off_angle: f32,
    pub break_off_at_time_to_collision: f32,
    pub break_off_height_difference: f32,
    pub bullet_speed: f32,
    pub extrapolate_target_rotation: bool,
    pub extrapolation_delta_time: f32,
}

pub const STRAFERUNMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StrafeRunManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AltitudeDifferenceToAttack",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StrafeRunManeuverEntityData, altitude_difference_to_attack),
            },
            FieldInfoData {
                name: "DiveAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StrafeRunManeuverEntityData, dive_angle),
            },
            FieldInfoData {
                name: "AttackSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StrafeRunManeuverEntityData, attack_speed),
            },
            FieldInfoData {
                name: "BreakOffAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StrafeRunManeuverEntityData, break_off_angle),
            },
            FieldInfoData {
                name: "BreakOffAtTimeToCollision",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StrafeRunManeuverEntityData, break_off_at_time_to_collision),
            },
            FieldInfoData {
                name: "BreakOffHeightDifference",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StrafeRunManeuverEntityData, break_off_height_difference),
            },
            FieldInfoData {
                name: "BulletSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StrafeRunManeuverEntityData, bullet_speed),
            },
            FieldInfoData {
                name: "ExtrapolateTargetRotation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(StrafeRunManeuverEntityData, extrapolate_target_rotation),
            },
            FieldInfoData {
                name: "ExtrapolationDeltaTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(StrafeRunManeuverEntityData, extrapolation_delta_time),
            },
        ],
    }),
    array_type: Some(STRAFERUNMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StrafeRunManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        STRAFERUNMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const STRAFERUNMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StrafeRunManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StrafeRunManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BasicAttackManeuverEntityData {
    pub distance_for_max_extrapolation_time: f32,
    pub distance_for_no_extrapolation_time: f32,
    pub max_extrapolation_time: f32,
    pub physics_extrapolation_time: f32,
    pub extrapolation_delta_time: f32,
    pub extrapolate_rotation: bool,
    pub max_roll_angle_against_slow_targets: f32,
    pub wanted_distance: f32,
    pub wanted_distance_offset_between_multiple_attackers: f32,
    pub throttle_p_i_d: super::game_shared::PID,
}

pub const BASICATTACKMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicAttackManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DistanceForMaxExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, distance_for_max_extrapolation_time),
            },
            FieldInfoData {
                name: "DistanceForNoExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, distance_for_no_extrapolation_time),
            },
            FieldInfoData {
                name: "MaxExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, max_extrapolation_time),
            },
            FieldInfoData {
                name: "PhysicsExtrapolationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, physics_extrapolation_time),
            },
            FieldInfoData {
                name: "ExtrapolationDeltaTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, extrapolation_delta_time),
            },
            FieldInfoData {
                name: "ExtrapolateRotation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, extrapolate_rotation),
            },
            FieldInfoData {
                name: "MaxRollAngleAgainstSlowTargets",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, max_roll_angle_against_slow_targets),
            },
            FieldInfoData {
                name: "WantedDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, wanted_distance),
            },
            FieldInfoData {
                name: "WantedDistanceOffsetBetweenMultipleAttackers",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, wanted_distance_offset_between_multiple_attackers),
            },
            FieldInfoData {
                name: "ThrottlePID",
                flags: MemberInfoFlags::new(0),
                field_type: PID_TYPE_INFO,
                rust_offset: offset_of!(BasicAttackManeuverEntityData, throttle_p_i_d),
            },
        ],
    }),
    array_type: Some(BASICATTACKMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicAttackManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        BASICATTACKMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const BASICATTACKMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicAttackManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BasicAttackManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CollisionAvoidanceManeuverEntityData {
    pub min_altitude: f32,
    pub look_ahead_time: f32,
    pub near_collision_time: f32,
    pub near_collision_throttle: f32,
    pub ignore_target: bool,
    pub ignore_all_collisions_except_humans: bool,
    pub ignore_humans: bool,
    pub use_velocity_dir_for_raycast: bool,
    pub keep_heading_time_after_hit: f32,
}

pub const COLLISIONAVOIDANCEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionAvoidanceManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MinAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, min_altitude),
            },
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, look_ahead_time),
            },
            FieldInfoData {
                name: "NearCollisionTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, near_collision_time),
            },
            FieldInfoData {
                name: "NearCollisionThrottle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, near_collision_throttle),
            },
            FieldInfoData {
                name: "IgnoreTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, ignore_target),
            },
            FieldInfoData {
                name: "IgnoreAllCollisionsExceptHumans",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, ignore_all_collisions_except_humans),
            },
            FieldInfoData {
                name: "IgnoreHumans",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, ignore_humans),
            },
            FieldInfoData {
                name: "UseVelocityDirForRaycast",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, use_velocity_dir_for_raycast),
            },
            FieldInfoData {
                name: "KeepHeadingTimeAfterHit",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CollisionAvoidanceManeuverEntityData, keep_heading_time_after_hit),
            },
        ],
    }),
    array_type: Some(COLLISIONAVOIDANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CollisionAvoidanceManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        COLLISIONAVOIDANCEMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const COLLISIONAVOIDANCEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CollisionAvoidanceManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CollisionAvoidanceManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EnforceAltitudeManeuverEntityData {
    pub min_altitude: f32,
    pub max_altitude: f32,
    pub look_ahead_time: f32,
    pub safety_distance: f32,
}

pub const ENFORCEALTITUDEMANEUVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnforceAltitudeManeuverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MinAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EnforceAltitudeManeuverEntityData, min_altitude),
            },
            FieldInfoData {
                name: "MaxAltitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EnforceAltitudeManeuverEntityData, max_altitude),
            },
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EnforceAltitudeManeuverEntityData, look_ahead_time),
            },
            FieldInfoData {
                name: "SafetyDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EnforceAltitudeManeuverEntityData, safety_distance),
            },
        ],
    }),
    array_type: Some(ENFORCEALTITUDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnforceAltitudeManeuverEntityData {
    fn type_info() -> &'static TypeInfo {
        ENFORCEALTITUDEMANEUVERENTITYDATA_TYPE_INFO
    }
}


pub const ENFORCEALTITUDEMANEUVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnforceAltitudeManeuverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EnforceAltitudeManeuverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DefensiveManeuverSelectorEntityData {
    pub minimum_target_velocity: f32,
    pub target_max_distance: f32,
    pub target_max_distance_slack: f32,
}

pub const DEFENSIVEMANEUVERSELECTORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefensiveManeuverSelectorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MANEUVERSELECTORENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MinimumTargetVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DefensiveManeuverSelectorEntityData, minimum_target_velocity),
            },
            FieldInfoData {
                name: "TargetMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DefensiveManeuverSelectorEntityData, target_max_distance),
            },
            FieldInfoData {
                name: "TargetMaxDistanceSlack",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DefensiveManeuverSelectorEntityData, target_max_distance_slack),
            },
        ],
    }),
    array_type: Some(DEFENSIVEMANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DefensiveManeuverSelectorEntityData {
    fn type_info() -> &'static TypeInfo {
        DEFENSIVEMANEUVERSELECTORENTITYDATA_TYPE_INFO
    }
}


pub const DEFENSIVEMANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DefensiveManeuverSelectorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DefensiveManeuverSelectorEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ManeuverSelectorEntityData {
    pub selector_type: SelectorType,
}

pub const MANEUVERSELECTORENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ManeuverSelectorEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SelectorType",
                flags: MemberInfoFlags::new(0),
                field_type: SELECTORTYPE_TYPE_INFO,
                rust_offset: offset_of!(ManeuverSelectorEntityData, selector_type),
            },
        ],
    }),
    array_type: Some(MANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ManeuverSelectorEntityData {
    fn type_info() -> &'static TypeInfo {
        MANEUVERSELECTORENTITYDATA_TYPE_INFO
    }
}


pub const MANEUVERSELECTORENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ManeuverSelectorEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ManeuverSelectorEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SelectorType {
    #[default]
    SelectorType_Random = 0,
    SelectorType_Priority = 1,
    SelectorType_Sequential = 2,
}

pub const SELECTORTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectorType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SELECTORTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SelectorType {
    fn type_info() -> &'static TypeInfo {
        SELECTORTYPE_TYPE_INFO
    }
}


pub const SELECTORTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SelectorType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SelectorType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DogFightManeuverEntityBaseData {
    pub realm: super::core::Realm,
    pub enabled: bool,
    pub max_roll_angle: f32,
}

pub const DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DogFightManeuverEntityBaseData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(DogFightManeuverEntityBaseData, realm),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DogFightManeuverEntityBaseData, enabled),
            },
            FieldInfoData {
                name: "MaxRollAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DogFightManeuverEntityBaseData, max_roll_angle),
            },
        ],
    }),
    array_type: Some(DOGFIGHTMANEUVERENTITYBASEDATA_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for DogFightManeuverEntityBaseData {
    fn type_info() -> &'static TypeInfo {
        DOGFIGHTMANEUVERENTITYBASEDATA_TYPE_INFO
    }
}


pub const DOGFIGHTMANEUVERENTITYBASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DogFightManeuverEntityBaseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DogFightManeuverEntityBaseData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WSDogFightingEntityData {
}

pub const WSDOGFIGHTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WSDogFightingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTINGENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(WSDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WSDogFightingEntityData {
    fn type_info() -> &'static TypeInfo {
        WSDOGFIGHTINGENTITYDATA_TYPE_INFO
    }
}


pub const WSDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WSDogFightingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WSDogFightingEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BFDogFightingEntityData {
}

pub const BFDOGFIGHTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BFDogFightingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DOGFIGHTINGENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(BFDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BFDogFightingEntityData {
    fn type_info() -> &'static TypeInfo {
        BFDOGFIGHTINGENTITYDATA_TYPE_INFO
    }
}


pub const BFDOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BFDogFightingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BFDogFightingEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DogFightingEntityData {
    pub realm: super::core::Realm,
    pub take_control_entry_index: i32,
    pub draw_debug_info: bool,
    pub max_target_distance_to_fire: f32,
    pub max_aim_angle_fault_to_fire: f32,
    pub default_speed: f32,
    pub max_speed: f32,
    pub collision_radius_modifier: f32,
    pub most_agile_speed: f32,
    pub should_select_target: bool,
    pub is_target: bool,
    pub priority_as_target: i32,
}

pub const DOGFIGHTINGENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DogFightingEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, realm),
            },
            FieldInfoData {
                name: "TakeControlEntryIndex",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, take_control_entry_index),
            },
            FieldInfoData {
                name: "DrawDebugInfo",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, draw_debug_info),
            },
            FieldInfoData {
                name: "MaxTargetDistanceToFire",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, max_target_distance_to_fire),
            },
            FieldInfoData {
                name: "MaxAimAngleFaultToFire",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, max_aim_angle_fault_to_fire),
            },
            FieldInfoData {
                name: "DefaultSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, default_speed),
            },
            FieldInfoData {
                name: "MaxSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, max_speed),
            },
            FieldInfoData {
                name: "CollisionRadiusModifier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, collision_radius_modifier),
            },
            FieldInfoData {
                name: "MostAgileSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, most_agile_speed),
            },
            FieldInfoData {
                name: "ShouldSelectTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, should_select_target),
            },
            FieldInfoData {
                name: "IsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, is_target),
            },
            FieldInfoData {
                name: "PriorityAsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(DogFightingEntityData, priority_as_target),
            },
        ],
    }),
    array_type: Some(DOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DogFightingEntityData {
    fn type_info() -> &'static TypeInfo {
        DOGFIGHTINGENTITYDATA_TYPE_INFO
    }
}


pub const DOGFIGHTINGENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DogFightingEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DogFightingEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DamageModifierEntityData {
    pub realm: super::core::Realm,
    pub enable_from_start: bool,
    pub damage_multiplier_a_ivs_human: f32,
}

pub const DAMAGEMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(DamageModifierEntityData, realm),
            },
            FieldInfoData {
                name: "EnableFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DamageModifierEntityData, enable_from_start),
            },
            FieldInfoData {
                name: "DamageMultiplierAIvsHuman",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DamageModifierEntityData, damage_multiplier_a_ivs_human),
            },
        ],
    }),
    array_type: Some(DAMAGEMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DamageModifierEntityData {
    fn type_info() -> &'static TypeInfo {
        DAMAGEMODIFIERENTITYDATA_TYPE_INFO
    }
}


pub const DAMAGEMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DamageModifierEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverEntityData {
    pub min_hover_height: f32,
    pub max_hover_height: f32,
    pub max_side_step_radius: f32,
    pub covers: Vec<CoverData>,
}

pub const COVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MinHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverEntityData, min_hover_height),
            },
            FieldInfoData {
                name: "MaxHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverEntityData, max_hover_height),
            },
            FieldInfoData {
                name: "MaxSideStepRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverEntityData, max_side_step_radius),
            },
            FieldInfoData {
                name: "Covers",
                flags: MemberInfoFlags::new(144),
                field_type: COVERDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverEntityData, covers),
            },
        ],
    }),
    array_type: Some(COVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CoverEntityData {
    fn type_info() -> &'static TypeInfo {
        COVERENTITYDATA_TYPE_INFO
    }
}


pub const COVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverPreviewAnimType {
    #[default]
    CoverPreviewAnimType_Stand_Left = 0,
    CoverPreviewAnimType_Stand_Right = 1,
    CoverPreviewAnimType_Crouch_Left = 2,
    CoverPreviewAnimType_Crouch_Right = 3,
    CoverPreviewAnimType_Count = 4,
}

pub const COVERPREVIEWANIMTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPreviewAnimType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERPREVIEWANIMTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverPreviewAnimType {
    fn type_info() -> &'static TypeInfo {
        COVERPREVIEWANIMTYPE_TYPE_INFO
    }
}


pub const COVERPREVIEWANIMTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPreviewAnimType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverPreviewAnimType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverSlot {
    pub position: super::core::Vec3,
}

pub const COVERSLOT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSlot",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(CoverSlot, position),
            },
        ],
    }),
    array_type: Some(COVERSLOT_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CoverSlot {
    fn type_info() -> &'static TypeInfo {
        COVERSLOT_TYPE_INFO
    }
}


pub const COVERSLOT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSlot-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSlot-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverType {
    #[default]
    CoverType_Stand = 0,
    CoverType_Medium = 1,
    CoverType_Crouch = 2,
    CoverType_Prone = 3,
    CoverType_Open = 4,
    CoverType_OpenDirectional = 5,
}

pub const COVERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverType {
    fn type_info() -> &'static TypeInfo {
        COVERTYPE_TYPE_INFO
    }
}


pub const COVERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct OldCoverQueryData {
    pub line_of_fire_score: f32,
    pub max_target_distance_for_rejected_by_line_of_fire: f32,
    pub navigation_score: f32,
    pub pathfinding_score: f32,
    pub distance_to_target: Vec<f32>,
    pub pathfinding_thresholds: Vec<f32>,
    pub default_pathfinding_threshold: f32,
    pub pathfinding_lower_limit: f32,
    pub pathfinding_upper_limit: f32,
    pub reject_invalid_paths: bool,
    pub reject_unreachable_covers: bool,
    pub cover_query_path_enemy_avoidance: CoverQueryPathEnemyAvoidanceData,
    pub max_rejected_time: f32,
    pub min_count_for_secondary_filter: i32,
    pub spatial_filter: CoverQuerySpatialBase,
    pub secondary_spatial_filter: CoverQuerySpatialBase,
    pub scores: Vec<CoverQueryScoreBase>,
    pub runtime_scores: Vec<CoverQueryScoreRuntime>,
}

pub const OLDCOVERQUERYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldCoverQueryData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "LineOfFireScore",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, line_of_fire_score),
            },
            FieldInfoData {
                name: "MaxTargetDistanceForRejectedByLineOfFire",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, max_target_distance_for_rejected_by_line_of_fire),
            },
            FieldInfoData {
                name: "NavigationScore",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, navigation_score),
            },
            FieldInfoData {
                name: "PathfindingScore",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, pathfinding_score),
            },
            FieldInfoData {
                name: "DistanceToTarget",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, distance_to_target),
            },
            FieldInfoData {
                name: "PathfindingThresholds",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, pathfinding_thresholds),
            },
            FieldInfoData {
                name: "DefaultPathfindingThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, default_pathfinding_threshold),
            },
            FieldInfoData {
                name: "PathfindingLowerLimit",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, pathfinding_lower_limit),
            },
            FieldInfoData {
                name: "PathfindingUpperLimit",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, pathfinding_upper_limit),
            },
            FieldInfoData {
                name: "RejectInvalidPaths",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, reject_invalid_paths),
            },
            FieldInfoData {
                name: "RejectUnreachableCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, reject_unreachable_covers),
            },
            FieldInfoData {
                name: "CoverQueryPathEnemyAvoidance",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPATHENEMYAVOIDANCEDATA_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, cover_query_path_enemy_avoidance),
            },
            FieldInfoData {
                name: "MaxRejectedTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, max_rejected_time),
            },
            FieldInfoData {
                name: "MinCountForSecondaryFilter",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, min_count_for_secondary_filter),
            },
            FieldInfoData {
                name: "SpatialFilter",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYSPATIALBASE_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, spatial_filter),
            },
            FieldInfoData {
                name: "SecondarySpatialFilter",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYSPATIALBASE_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, secondary_spatial_filter),
            },
            FieldInfoData {
                name: "Scores",
                flags: MemberInfoFlags::new(144),
                field_type: COVERQUERYSCOREBASE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, scores),
            },
            FieldInfoData {
                name: "RuntimeScores",
                flags: MemberInfoFlags::new(144),
                field_type: COVERQUERYSCORERUNTIME_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(OldCoverQueryData, runtime_scores),
            },
        ],
    }),
    array_type: Some(OLDCOVERQUERYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OldCoverQueryData {
    fn type_info() -> &'static TypeInfo {
        OLDCOVERQUERYDATA_TYPE_INFO
    }
}


pub const OLDCOVERQUERYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OldCoverQueryData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("OldCoverQueryData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverQueryScoreData {
    pub scores: Vec<CoverQueryScoreBase>,
    pub runtime_scores: Vec<CoverQueryScoreRuntime>,
}

pub const COVERQUERYSCOREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Scores",
                flags: MemberInfoFlags::new(144),
                field_type: COVERQUERYSCOREBASE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreData, scores),
            },
            FieldInfoData {
                name: "RuntimeScores",
                flags: MemberInfoFlags::new(144),
                field_type: COVERQUERYSCORERUNTIME_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreData, runtime_scores),
            },
        ],
    }),
    array_type: Some(COVERQUERYSCOREDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQueryScoreData {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYSCOREDATA_TYPE_INFO
    }
}


pub const COVERQUERYSCOREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverQueryScoreRuntime {
    pub relation_mask: i32,
    pub flags: i32,
    pub filter: i32,
    pub x_style: CoverQueryStyle,
    pub from_position: CoverQueryPosition,
    pub to_position: CoverQueryPosition,
    pub reference_direction: CoverQueryDirection,
    pub secondary_parameters: CoverQueryScoreSecondaryData,
    pub curve_x_source: CoverQueryCurveXSource,
    pub curve: Vec<f32>,
    pub base_score_index: u32,
}

pub const COVERQUERYSCORERUNTIME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreRuntime",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "RelationMask",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, relation_mask),
            },
            FieldInfoData {
                name: "Flags",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, flags),
            },
            FieldInfoData {
                name: "Filter",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, filter),
            },
            FieldInfoData {
                name: "XStyle",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYSTYLE_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, x_style),
            },
            FieldInfoData {
                name: "FromPosition",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPOSITION_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, from_position),
            },
            FieldInfoData {
                name: "ToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPOSITION_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, to_position),
            },
            FieldInfoData {
                name: "ReferenceDirection",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDIRECTION_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, reference_direction),
            },
            FieldInfoData {
                name: "SecondaryParameters",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYSCORESECONDARYDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, secondary_parameters),
            },
            FieldInfoData {
                name: "CurveXSource",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYCURVEXSOURCE_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, curve_x_source),
            },
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, curve),
            },
            FieldInfoData {
                name: "BaseScoreIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreRuntime, base_score_index),
            },
        ],
    }),
    array_type: Some(COVERQUERYSCORERUNTIME_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQueryScoreRuntime {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYSCORERUNTIME_TYPE_INFO
    }
}


pub const COVERQUERYSCORERUNTIME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreRuntime-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreRuntime-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverQueryScoreRuntimeFlags {
    #[default]
    CoverQueryScoreRuntimeFlags_NeedTarget = 1,
    CoverQueryScoreRuntimeFlags_NeedSquad = 2,
}

pub const COVERQUERYSCORERUNTIMEFLAGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreRuntimeFlags",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYSCORERUNTIMEFLAGS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryScoreRuntimeFlags {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYSCORERUNTIMEFLAGS_TYPE_INFO
    }
}


pub const COVERQUERYSCORERUNTIMEFLAGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreRuntimeFlags-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreRuntimeFlags-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverQueryScoreBase {
    pub enabled: bool,
    pub filter: CoverQueryFilter,
    pub x_style: CoverQueryStyle,
    pub from_position: CoverQueryPosition,
    pub to_position: CoverQueryPosition,
    pub reference_direction: CoverQueryDirection,
    pub secondary_parameters: CoverQueryScoreSecondaryData,
    pub curve_x_source: CoverQueryCurveXSource,
    pub x: Vec<f32>,
    pub score: Vec<f32>,
}

pub const COVERQUERYSCOREBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreBase",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, enabled),
            },
            FieldInfoData {
                name: "Filter",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYFILTER_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, filter),
            },
            FieldInfoData {
                name: "XStyle",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYSTYLE_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, x_style),
            },
            FieldInfoData {
                name: "FromPosition",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPOSITION_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, from_position),
            },
            FieldInfoData {
                name: "ToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPOSITION_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, to_position),
            },
            FieldInfoData {
                name: "ReferenceDirection",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDIRECTION_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, reference_direction),
            },
            FieldInfoData {
                name: "SecondaryParameters",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYSCORESECONDARYDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, secondary_parameters),
            },
            FieldInfoData {
                name: "CurveXSource",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYCURVEXSOURCE_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, curve_x_source),
            },
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, x),
            },
            FieldInfoData {
                name: "Score",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreBase, score),
            },
        ],
    }),
    array_type: Some(COVERQUERYSCOREBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQueryScoreBase {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYSCOREBASE_TYPE_INFO
    }
}


pub const COVERQUERYSCOREBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreBase-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct CoverQueryScoreSecondaryData {
    pub from_position: CoverQueryPosition,
    pub to_position: CoverQueryPosition,
    pub reference_direction: CoverQueryDirection,
}

pub const COVERQUERYSCORESECONDARYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreSecondaryData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "FromPosition",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPOSITION_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreSecondaryData, from_position),
            },
            FieldInfoData {
                name: "ToPosition",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPOSITION_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreSecondaryData, to_position),
            },
            FieldInfoData {
                name: "ReferenceDirection",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDIRECTION_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryScoreSecondaryData, reference_direction),
            },
        ],
    }),
    array_type: Some(COVERQUERYSCORESECONDARYDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverQueryScoreSecondaryData {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYSCORESECONDARYDATA_TYPE_INFO
    }
}


pub const COVERQUERYSCORESECONDARYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryScoreSecondaryData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryScoreSecondaryData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverQueryDirection {
    #[default]
    CoverQueryDirection_CoverDirection = 0,
    CoverQueryDirection_WorldUpDirection = 1,
    CoverQueryDirection_ActorToHumanDirection = 2,
    CoverQueryDirection_HumanToActorDirection = 3,
    CoverQueryDirection_SquadToHumanDirection = 4,
    CoverQueryDirection_HumanToSquadDirection = 5,
    CoverQueryDirection_ActorToTargetDirection = 6,
    CoverQueryDirection_TargetToActorDirection = 7,
    CoverQueryDirection_ActorFacingDirection = 8,
    CoverQueryDirection_TargetFacingDirection = 9,
    CoverQueryDirection_ActorMoveDirection = 10,
    CoverQueryDirection_TargetMoveDirection = 11,
}

pub const COVERQUERYDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryDirection",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryDirection {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYDIRECTION_TYPE_INFO
    }
}


pub const COVERQUERYDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryDirection-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryDirection-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverQueryStyle {
    #[default]
    CoverQueryStyle_Distance = 0,
    CoverQueryStyle_ProjectedDistance = 1,
    CoverQueryStyle_Angle = 2,
    CoverQueryStyle_DistanceDelta = 3,
}

pub const COVERQUERYSTYLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryStyle",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYSTYLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryStyle {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYSTYLE_TYPE_INFO
    }
}


pub const COVERQUERYSTYLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryStyle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryStyle-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverQueryCurveXSource {
    #[default]
    CoverQueryCurveXSource_Custom = 0,
    CoverQueryCurveXSource_WeaponPreferredRange = 1,
}

pub const COVERQUERYCURVEXSOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryCurveXSource",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYCURVEXSOURCE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryCurveXSource {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYCURVEXSOURCE_TYPE_INFO
    }
}


pub const COVERQUERYCURVEXSOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryCurveXSource-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryCurveXSource-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverValidateData {
    pub validators: Vec<CoverValidationScoreData>,
    pub execution_params: CoverScoreExecutionParams,
}

pub const COVERVALIDATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidateData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Validators",
                flags: MemberInfoFlags::new(144),
                field_type: COVERVALIDATIONSCOREDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverValidateData, validators),
            },
            FieldInfoData {
                name: "ExecutionParams",
                flags: MemberInfoFlags::new(0),
                field_type: COVERSCOREEXECUTIONPARAMS_TYPE_INFO,
                rust_offset: offset_of!(CoverValidateData, execution_params),
            },
        ],
    }),
    array_type: Some(COVERVALIDATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverValidateData {
    fn type_info() -> &'static TypeInfo {
        COVERVALIDATEDATA_TYPE_INFO
    }
}


pub const COVERVALIDATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverValidateData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverValidationScoreData {
    pub scorer: CoverScoreDataBase,
    pub active_when_moving_to_cover: bool,
    pub active_when_reached_cover: bool,
    pub active_when_target_l_k_p_lost: bool,
    pub min_time_to_invalidate: f32,
    pub invalidation_reason: CoverValidationStatus,
    pub exit_invalidated_cover: bool,
}

pub const COVERVALIDATIONSCOREDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidationScoreData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Scorer",
                flags: MemberInfoFlags::new(0),
                field_type: COVERSCOREDATABASE_TYPE_INFO,
                rust_offset: offset_of!(CoverValidationScoreData, scorer),
            },
            FieldInfoData {
                name: "ActiveWhenMovingToCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverValidationScoreData, active_when_moving_to_cover),
            },
            FieldInfoData {
                name: "ActiveWhenReachedCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverValidationScoreData, active_when_reached_cover),
            },
            FieldInfoData {
                name: "ActiveWhenTargetLKPLost",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverValidationScoreData, active_when_target_l_k_p_lost),
            },
            FieldInfoData {
                name: "MinTimeToInvalidate",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverValidationScoreData, min_time_to_invalidate),
            },
            FieldInfoData {
                name: "InvalidationReason",
                flags: MemberInfoFlags::new(0),
                field_type: COVERVALIDATIONSTATUS_TYPE_INFO,
                rust_offset: offset_of!(CoverValidationScoreData, invalidation_reason),
            },
            FieldInfoData {
                name: "ExitInvalidatedCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverValidationScoreData, exit_invalidated_cover),
            },
        ],
    }),
    array_type: Some(COVERVALIDATIONSCOREDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverValidationScoreData {
    fn type_info() -> &'static TypeInfo {
        COVERVALIDATIONSCOREDATA_TYPE_INFO
    }
}


pub const COVERVALIDATIONSCOREDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidationScoreData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverValidationScoreData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverValidationStatus {
    #[default]
    CoverValidationStatus_Valid = 0,
    CoverValidationStatus_Invalidated = 1,
    CoverValidationStatus_Compromised = 2,
}

pub const COVERVALIDATIONSTATUS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidationStatus",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERVALIDATIONSTATUS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverValidationStatus {
    fn type_info() -> &'static TypeInfo {
        COVERVALIDATIONSTATUS_TYPE_INFO
    }
}


pub const COVERVALIDATIONSTATUS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverValidationStatus-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverValidationStatus-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverSelectData {
    pub restrict_to_defend_area: bool,
    pub spatial_filter: CoverQuerySpatialBase,
    pub include_fully_blocked_covers: bool,
    pub common_scores: CoverScoreAsset,
    pub scores: Vec<CoverScoreDataBase>,
    pub execution_params: CoverScoreExecutionParams,
}

pub const COVERSELECTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSelectData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "RestrictToDefendArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverSelectData, restrict_to_defend_area),
            },
            FieldInfoData {
                name: "SpatialFilter",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYSPATIALBASE_TYPE_INFO,
                rust_offset: offset_of!(CoverSelectData, spatial_filter),
            },
            FieldInfoData {
                name: "IncludeFullyBlockedCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverSelectData, include_fully_blocked_covers),
            },
            FieldInfoData {
                name: "CommonScores",
                flags: MemberInfoFlags::new(0),
                field_type: COVERSCOREASSET_TYPE_INFO,
                rust_offset: offset_of!(CoverSelectData, common_scores),
            },
            FieldInfoData {
                name: "Scores",
                flags: MemberInfoFlags::new(144),
                field_type: COVERSCOREDATABASE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverSelectData, scores),
            },
            FieldInfoData {
                name: "ExecutionParams",
                flags: MemberInfoFlags::new(0),
                field_type: COVERSCOREEXECUTIONPARAMS_TYPE_INFO,
                rust_offset: offset_of!(CoverSelectData, execution_params),
            },
        ],
    }),
    array_type: Some(COVERSELECTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverSelectData {
    fn type_info() -> &'static TypeInfo {
        COVERSELECTDATA_TYPE_INFO
    }
}


pub const COVERSELECTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSelectData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSelectData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct CoverScoreAsset {
    pub scores: Vec<CoverScoreDataBase>,
}

pub const COVERSCOREASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreAsset",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Scores",
                flags: MemberInfoFlags::new(144),
                field_type: COVERSCOREDATABASE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreAsset, scores),
            },
        ],
    }),
    array_type: Some(COVERSCOREASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverScoreAsset {
    fn type_info() -> &'static TypeInfo {
        COVERSCOREASSET_TYPE_INFO
    }
}


pub const COVERSCOREASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverScoreAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverScoreExecutionParams {
    pub fact_mask: u32,
    pub path_spec_type_mask: u32,
    pub path_specs: Vec<CoverPathSpec>,
    pub post_path_request_start_idx: u32,
    pub high_cost_scorer_start_idx: u32,
    pub max_score_from_high_cost_scorers: f32,
    pub has_line_of_fire_rejection: bool,
}

pub const COVERSCOREEXECUTIONPARAMS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreExecutionParams",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "FactMask",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreExecutionParams, fact_mask),
            },
            FieldInfoData {
                name: "PathSpecTypeMask",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreExecutionParams, path_spec_type_mask),
            },
            FieldInfoData {
                name: "PathSpecs",
                flags: MemberInfoFlags::new(144),
                field_type: COVERPATHSPEC_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreExecutionParams, path_specs),
            },
            FieldInfoData {
                name: "PostPathRequestStartIdx",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreExecutionParams, post_path_request_start_idx),
            },
            FieldInfoData {
                name: "HighCostScorerStartIdx",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreExecutionParams, high_cost_scorer_start_idx),
            },
            FieldInfoData {
                name: "MaxScoreFromHighCostScorers",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreExecutionParams, max_score_from_high_cost_scorers),
            },
            FieldInfoData {
                name: "HasLineOfFireRejection",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreExecutionParams, has_line_of_fire_rejection),
            },
        ],
    }),
    array_type: Some(COVERSCOREEXECUTIONPARAMS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverScoreExecutionParams {
    fn type_info() -> &'static TypeInfo {
        COVERSCOREEXECUTIONPARAMS_TYPE_INFO
    }
}


pub const COVERSCOREEXECUTIONPARAMS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreExecutionParams-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverScoreExecutionParams-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverPathSpec {
    pub path_mode: CoverPathMode,
    pub max_search_dist: f32,
    pub precise_path: bool,
    pub store_path: bool,
}

pub const COVERPATHSPEC_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPathSpec",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PathMode",
                flags: MemberInfoFlags::new(0),
                field_type: COVERPATHMODE_TYPE_INFO,
                rust_offset: offset_of!(CoverPathSpec, path_mode),
            },
            FieldInfoData {
                name: "MaxSearchDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverPathSpec, max_search_dist),
            },
            FieldInfoData {
                name: "PrecisePath",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverPathSpec, precise_path),
            },
            FieldInfoData {
                name: "StorePath",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverPathSpec, store_path),
            },
        ],
    }),
    array_type: Some(COVERPATHSPEC_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverPathSpec {
    fn type_info() -> &'static TypeInfo {
        COVERPATHSPEC_TYPE_INFO
    }
}


pub const COVERPATHSPEC_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPathSpec-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverPathSpec-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverPathMode {
    #[default]
    CoverPathMode_None = 0,
    CoverPathMode_CheckReachable = 1,
    CoverPathMode_FindPath = 2,
}

pub const COVERPATHMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPathMode",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERPATHMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverPathMode {
    fn type_info() -> &'static TypeInfo {
        COVERPATHMODE_TYPE_INFO
    }
}


pub const COVERPATHMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPathMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverPathMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct CoverScoreDataBase {
    pub id: u32,
    pub runtime_filter: u32,
}

pub const COVERSCOREDATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreDataBase",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreDataBase, id),
            },
            FieldInfoData {
                name: "RuntimeFilter",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreDataBase, runtime_filter),
            },
        ],
    }),
    array_type: Some(COVERSCOREDATABASE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for CoverScoreDataBase {
    fn type_info() -> &'static TypeInfo {
        COVERSCOREDATABASE_TYPE_INFO
    }
}


pub const COVERSCOREDATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreDataBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverScoreDataBase-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverExclusionVolumeShapeData {
}

pub const COVEREXCLUSIONVOLUMESHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverExclusionVolumeShapeData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOLUMEVECTORSHAPEDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(COVEREXCLUSIONVOLUMESHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverExclusionVolumeShapeData {
    fn type_info() -> &'static TypeInfo {
        COVEREXCLUSIONVOLUMESHAPEDATA_TYPE_INFO
    }
}


pub const COVEREXCLUSIONVOLUMESHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverExclusionVolumeShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverExclusionVolumeShapeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverAutoGenVolumeShapeData {
    pub generate_open_covers: bool,
    pub generate_real_covers: bool,
    pub generate_ledge_covers: bool,
    pub generate_vault_over_links: bool,
    pub generate_ledge_jump_down_links: bool,
    pub open_cover_placement_step_override: f32,
    pub open_cover_voxel_erosion_distance_override: f32,
}

pub const COVERAUTOGENVOLUMESHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverAutoGenVolumeShapeData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOLUMEVECTORSHAPEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "GenerateOpenCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_open_covers),
            },
            FieldInfoData {
                name: "GenerateRealCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_real_covers),
            },
            FieldInfoData {
                name: "GenerateLedgeCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_ledge_covers),
            },
            FieldInfoData {
                name: "GenerateVaultOverLinks",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_vault_over_links),
            },
            FieldInfoData {
                name: "GenerateLedgeJumpDownLinks",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, generate_ledge_jump_down_links),
            },
            FieldInfoData {
                name: "OpenCoverPlacementStepOverride",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, open_cover_placement_step_override),
            },
            FieldInfoData {
                name: "OpenCoverVoxelErosionDistanceOverride",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverAutoGenVolumeShapeData, open_cover_voxel_erosion_distance_override),
            },
        ],
    }),
    array_type: Some(COVERAUTOGENVOLUMESHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverAutoGenVolumeShapeData {
    fn type_info() -> &'static TypeInfo {
        COVERAUTOGENVOLUMESHAPEDATA_TYPE_INFO
    }
}


pub const COVERAUTOGENVOLUMESHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverAutoGenVolumeShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverAutoGenVolumeShapeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AICoverScoreModifierRemoveMessage {
}

pub const AICOVERSCOREMODIFIERREMOVEMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverScoreModifierRemoveMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AICoverScoreModifierRemoveMessage {
    fn type_info() -> &'static TypeInfo {
        AICOVERSCOREMODIFIERREMOVEMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AICoverScoreModifierAddMessage {
}

pub const AICOVERSCOREMODIFIERADDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICoverScoreModifierAddMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for AICoverScoreModifierAddMessage {
    fn type_info() -> &'static TypeInfo {
        AICOVERSCOREMODIFIERADDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Debug)]
pub struct CoverScoreModifierEntityData {
    pub score_buff: f32,
    pub sphere_radius: f32,
}

pub const COVERSCOREMODIFIERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreModifierEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ScoreBuff",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreModifierEntityData, score_buff),
            },
            FieldInfoData {
                name: "SphereRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverScoreModifierEntityData, sphere_radius),
            },
        ],
    }),
    array_type: Some(COVERSCOREMODIFIERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverScoreModifierEntityData {
    fn type_info() -> &'static TypeInfo {
        COVERSCOREMODIFIERENTITYDATA_TYPE_INFO
    }
}


pub const COVERSCOREMODIFIERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverScoreModifierEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverScoreModifierEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverGroupEntityData {
    pub covers: Vec<CoverData>,
}

pub const COVERGROUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverGroupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Covers",
                flags: MemberInfoFlags::new(144),
                field_type: COVERDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverGroupEntityData, covers),
            },
        ],
    }),
    array_type: Some(COVERGROUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverGroupEntityData {
    fn type_info() -> &'static TypeInfo {
        COVERGROUPENTITYDATA_TYPE_INFO
    }
}


pub const COVERGROUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverGroupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverGroupEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverData {
    pub pos_and_extra0: super::core::Vec4,
    pub direction_and_extra1: super::core::Vec4,
    pub min_hover_height: f32,
    pub max_hover_height: f32,
    pub max_side_step_radius: f32,
}

pub const COVERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PosAndExtra0",
                flags: MemberInfoFlags::new(0),
                field_type: VEC4_TYPE_INFO,
                rust_offset: offset_of!(CoverData, pos_and_extra0),
            },
            FieldInfoData {
                name: "DirectionAndExtra1",
                flags: MemberInfoFlags::new(0),
                field_type: VEC4_TYPE_INFO,
                rust_offset: offset_of!(CoverData, direction_and_extra1),
            },
            FieldInfoData {
                name: "MinHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverData, min_hover_height),
            },
            FieldInfoData {
                name: "MaxHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverData, max_hover_height),
            },
            FieldInfoData {
                name: "MaxSideStepRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverData, max_side_step_radius),
            },
        ],
    }),
    array_type: Some(COVERDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CoverData {
    fn type_info() -> &'static TypeInfo {
        COVERDATA_TYPE_INFO
    }
}


pub const COVERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverQueryData {
    pub selection_data: CoverSelectData,
    pub validation_data: CoverValidateData,
}

pub const COVERQUERYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINERPOLICYASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SelectionData",
                flags: MemberInfoFlags::new(0),
                field_type: COVERSELECTDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryData, selection_data),
            },
            FieldInfoData {
                name: "ValidationData",
                flags: MemberInfoFlags::new(0),
                field_type: COVERVALIDATEDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryData, validation_data),
            },
        ],
    }),
    array_type: Some(COVERQUERYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQueryData {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYDATA_TYPE_INFO
    }
}


pub const COVERQUERYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverQueryPathEnemyAvoidanceData {
    pub avoid_humans: CoverQueryPathEnemyAvoidanceByTypeData,
    pub avoid_a_i: CoverQueryPathEnemyAvoidanceByTypeData,
    pub inner_zone_score: f32,
    pub outer_zone_score: f32,
    pub not_passing_avoidance_area_score: f32,
}

pub const COVERQUERYPATHENEMYAVOIDANCEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathEnemyAvoidanceData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AvoidHumans",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, avoid_humans),
            },
            FieldInfoData {
                name: "AvoidAI",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, avoid_a_i),
            },
            FieldInfoData {
                name: "InnerZoneScore",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, inner_zone_score),
            },
            FieldInfoData {
                name: "OuterZoneScore",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, outer_zone_score),
            },
            FieldInfoData {
                name: "NotPassingAvoidanceAreaScore",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceData, not_passing_avoidance_area_score),
            },
        ],
    }),
    array_type: Some(COVERQUERYPATHENEMYAVOIDANCEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverQueryPathEnemyAvoidanceData {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYPATHENEMYAVOIDANCEDATA_TYPE_INFO
    }
}


pub const COVERQUERYPATHENEMYAVOIDANCEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathEnemyAvoidanceData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPathEnemyAvoidanceData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverQueryPathEnemyAvoidanceByTypeData {
    pub avoidance_type: CoverQueryPathAvoidanceType,
    pub enabled: bool,
    pub avoidance_inner_radius: f32,
    pub avoidance_outer_radius: f32,
    pub avoidance_height: f32,
    pub look_ahead_distance: f32,
    pub check_nav_raycast: bool,
}

pub const COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathEnemyAvoidanceByTypeData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AvoidanceType",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPATHAVOIDANCETYPE_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, avoidance_type),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, enabled),
            },
            FieldInfoData {
                name: "AvoidanceInnerRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, avoidance_inner_radius),
            },
            FieldInfoData {
                name: "AvoidanceOuterRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, avoidance_outer_radius),
            },
            FieldInfoData {
                name: "AvoidanceHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, avoidance_height),
            },
            FieldInfoData {
                name: "LookAheadDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, look_ahead_distance),
            },
            FieldInfoData {
                name: "CheckNavRaycast",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryPathEnemyAvoidanceByTypeData, check_nav_raycast),
            },
        ],
    }),
    array_type: Some(COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverQueryPathEnemyAvoidanceByTypeData {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_TYPE_INFO
    }
}


pub const COVERQUERYPATHENEMYAVOIDANCEBYTYPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathEnemyAvoidanceByTypeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPathEnemyAvoidanceByTypeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverQueryPathAvoidanceZone {
    #[default]
    CoverQueryPathAvoidanceZone_Inner = 0,
    CoverQueryPathAvoidanceZone_Outer = 1,
    CoverQueryPathAvoidanceZone_None = 2,
    CoverQueryPathAvoidanceZone_Count = 3,
}

pub const COVERQUERYPATHAVOIDANCEZONE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathAvoidanceZone",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYPATHAVOIDANCEZONE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryPathAvoidanceZone {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYPATHAVOIDANCEZONE_TYPE_INFO
    }
}


pub const COVERQUERYPATHAVOIDANCEZONE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathAvoidanceZone-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPathAvoidanceZone-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverQueryPathAvoidanceType {
    #[default]
    CoverQueryPathAvoidanceType_AIEnemy = 0,
    CoverQueryPathAvoidanceType_AIFriendly = 1,
    CoverQueryPathAvoidanceType_HumanEnemy = 2,
    CoverQueryPathAvoidanceType_HumanFriendly = 3,
    CoverQueryPathAvoidanceType_CriticalThreat = 4,
    CoverQueryPathAvoidanceType_Count = 5,
}

pub const COVERQUERYPATHAVOIDANCETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathAvoidanceType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYPATHAVOIDANCETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryPathAvoidanceType {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYPATHAVOIDANCETYPE_TYPE_INFO
    }
}


pub const COVERQUERYPATHAVOIDANCETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPathAvoidanceType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPathAvoidanceType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct CoverQueryFilter {
    pub left_blocked: bool,
    pub left_not_blocked: bool,
    pub right_blocked: bool,
    pub right_not_blocked: bool,
    pub top_blocked: bool,
    pub top_not_blocked: bool,
    pub crouch_blocked: bool,
    pub crouch_not_blocked: bool,
    pub hover_blocked: bool,
    pub hover_not_blocked: bool,
    pub stand_covers: bool,
    pub medium_covers: bool,
    pub crouch_covers: bool,
    pub prone_covers: bool,
    pub open_covers: bool,
    pub open_directional_covers: bool,
}

pub const COVERQUERYFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryFilter",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "LeftBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, left_blocked),
            },
            FieldInfoData {
                name: "LeftNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, left_not_blocked),
            },
            FieldInfoData {
                name: "RightBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, right_blocked),
            },
            FieldInfoData {
                name: "RightNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, right_not_blocked),
            },
            FieldInfoData {
                name: "TopBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, top_blocked),
            },
            FieldInfoData {
                name: "TopNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, top_not_blocked),
            },
            FieldInfoData {
                name: "CrouchBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, crouch_blocked),
            },
            FieldInfoData {
                name: "CrouchNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, crouch_not_blocked),
            },
            FieldInfoData {
                name: "HoverBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, hover_blocked),
            },
            FieldInfoData {
                name: "HoverNotBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, hover_not_blocked),
            },
            FieldInfoData {
                name: "StandCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, stand_covers),
            },
            FieldInfoData {
                name: "MediumCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, medium_covers),
            },
            FieldInfoData {
                name: "CrouchCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, crouch_covers),
            },
            FieldInfoData {
                name: "ProneCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, prone_covers),
            },
            FieldInfoData {
                name: "OpenCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, open_covers),
            },
            FieldInfoData {
                name: "OpenDirectionalCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverQueryFilter, open_directional_covers),
            },
        ],
    }),
    array_type: Some(COVERQUERYFILTER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryFilter {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYFILTER_TYPE_INFO
    }
}


pub const COVERQUERYFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryFilter-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FilterCoversByWeaponRange {
    pub target: CoverQueryPosition,
    pub height_tolerance: f32,
}

pub const FILTERCOVERSBYWEAPONRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByWeaponRange",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COVERQUERYSPATIALBASE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPOSITION_TYPE_INFO,
                rust_offset: offset_of!(FilterCoversByWeaponRange, target),
            },
            FieldInfoData {
                name: "HeightTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FilterCoversByWeaponRange, height_tolerance),
            },
        ],
    }),
    array_type: Some(FILTERCOVERSBYWEAPONRANGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FilterCoversByWeaponRange {
    fn type_info() -> &'static TypeInfo {
        FILTERCOVERSBYWEAPONRANGE_TYPE_INFO
    }
}


pub const FILTERCOVERSBYWEAPONRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByWeaponRange-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FilterCoversByWeaponRange-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct FilterCoversByDefendArea {
    pub reference: CoverQueryPosition,
}

pub const FILTERCOVERSBYDEFENDAREA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByDefendArea",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COVERQUERYSPATIALBASE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Reference",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPOSITION_TYPE_INFO,
                rust_offset: offset_of!(FilterCoversByDefendArea, reference),
            },
        ],
    }),
    array_type: Some(FILTERCOVERSBYDEFENDAREA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FilterCoversByDefendArea {
    fn type_info() -> &'static TypeInfo {
        FILTERCOVERSBYDEFENDAREA_TYPE_INFO
    }
}


pub const FILTERCOVERSBYDEFENDAREA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByDefendArea-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FilterCoversByDefendArea-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FilterCoversByRadius {
    pub center: CoverQueryPosition,
    pub radius: f32,
    pub height_tolerance: f32,
}

pub const FILTERCOVERSBYRADIUS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByRadius",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(COVERQUERYSPATIALBASE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYPOSITION_TYPE_INFO,
                rust_offset: offset_of!(FilterCoversByRadius, center),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FilterCoversByRadius, radius),
            },
            FieldInfoData {
                name: "HeightTolerance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FilterCoversByRadius, height_tolerance),
            },
        ],
    }),
    array_type: Some(FILTERCOVERSBYRADIUS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FilterCoversByRadius {
    fn type_info() -> &'static TypeInfo {
        FILTERCOVERSBYRADIUS_TYPE_INFO
    }
}


pub const FILTERCOVERSBYRADIUS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FilterCoversByRadius-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FilterCoversByRadius-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct CoverQuerySpatialBase {
}

pub const COVERQUERYSPATIALBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQuerySpatialBase",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(COVERQUERYSPATIALBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverQuerySpatialBase {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYSPATIALBASE_TYPE_INFO
    }
}


pub const COVERQUERYSPATIALBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQuerySpatialBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQuerySpatialBase-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverQueryPosition {
    #[default]
    CoverQueryPosition_ActorPosition = 0,
    CoverQueryPosition_CoverPosition = 1,
    CoverQueryPosition_SquadPosition = 2,
    CoverQueryPosition_HumanPosition = 3,
    CoverQueryPosition_FollowObjectPosition = 4,
    CoverQueryPosition_TargetPosition = 5,
    CoverQueryPosition_Count = 6,
}

pub const COVERQUERYPOSITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPosition",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERQUERYPOSITION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverQueryPosition {
    fn type_info() -> &'static TypeInfo {
        COVERQUERYPOSITION_TYPE_INFO
    }
}


pub const COVERQUERYPOSITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverQueryPosition-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverQueryPosition-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverConstantData {
    pub slot_size: f32,
    pub slot_spacing: f32,
    pub slot_edge_distance: f32,
    pub slot_blocked_edge_distance: f32,
    pub minimum_protected_cover_width: f32,
    pub prone_allow_fire_height: f32,
    pub open_allow_fire_height: f32,
    pub crouch_height: f32,
    pub crouch_allow_fire_height: f32,
    pub medium_height: f32,
    pub medium_allow_fire_height: f32,
    pub stand_height: f32,
    pub fire_height_prone: f32,
    pub fire_height_open: f32,
    pub fire_height_crouch: f32,
    pub fire_height_medium: f32,
    pub fire_height_standing: f32,
    pub min_free_shoot_dist: f32,
    pub fire_step_out_dist: f32,
    pub max_fire_side_test_angle: f32,
    pub fire_side_sample_count: i32,
    pub pathfinding_reference_layer: i32,
    pub terrain_height_sampling_step: f32,
    pub chunk_size: f32,
    pub voxel_size: f32,
    pub voxel_height: f32,
    pub voxel_span_merge_threshold: i32,
    pub voxel_span_merging_max_separation: i32,
    pub max_step_height_override: f32,
    pub min_island_surface_area_extra: f32,
    pub contour_simplification_max_area_delta: f32,
    pub contour_simplification_x_z_error_in: f32,
    pub contour_simplification_x_z_error_out: f32,
    pub contour_simplification_y_error: f32,
    pub open_cover_min_spacing_dist: f32,
    pub open_cover_voxel_sampling_step: i32,
    pub open_cover_voxel_erosion_distance: f32,
    pub open_cover_min_dist_to_manual_cover: f32,
    pub min_hover_clearance: f32,
    pub hovering_min_dist_to_ceiling: f32,
    pub max_real_cover_contour_slope: f32,
    pub edge_probe_sample_spacing: f32,
    pub crouch_cover_occlusion_settings: ProtectiveCoverWallOcclusionSettings,
    pub stand_cover_occlusion_settings: ProtectiveCoverWallOcclusionSettings,
    pub free_shoot_height_range: f32,
    pub generate_fully_blocked_covers: bool,
    pub fully_blocked_cover_max_dist_from_valid_cover: f32,
    pub ledge_forward_clearance_dist: f32,
    pub ledge_downward_clearance_dist: f32,
    pub ledge_downward_clearance_test_range: f32,
    pub ledge_cover_placement_start_dist_on_edge: f32,
    pub ledge_cover_placement_step: f32,
    pub ledge_cover_placement_dist_from_ledge: f32,
    pub vault_over_path_link_config: VaultOverPathLinkConfig,
    pub ledge_jump_down_path_link_config: LedgeJumpDownPathLinkConfig,
    pub max_covers_in_memory: i32,
    pub cover_zones: CoverZones,
}

pub const COVERCONSTANTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverConstantData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SlotSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, slot_size),
            },
            FieldInfoData {
                name: "SlotSpacing",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, slot_spacing),
            },
            FieldInfoData {
                name: "SlotEdgeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, slot_edge_distance),
            },
            FieldInfoData {
                name: "SlotBlockedEdgeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, slot_blocked_edge_distance),
            },
            FieldInfoData {
                name: "MinimumProtectedCoverWidth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, minimum_protected_cover_width),
            },
            FieldInfoData {
                name: "ProneAllowFireHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, prone_allow_fire_height),
            },
            FieldInfoData {
                name: "OpenAllowFireHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, open_allow_fire_height),
            },
            FieldInfoData {
                name: "CrouchHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, crouch_height),
            },
            FieldInfoData {
                name: "CrouchAllowFireHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, crouch_allow_fire_height),
            },
            FieldInfoData {
                name: "MediumHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, medium_height),
            },
            FieldInfoData {
                name: "MediumAllowFireHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, medium_allow_fire_height),
            },
            FieldInfoData {
                name: "StandHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, stand_height),
            },
            FieldInfoData {
                name: "FireHeightProne",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, fire_height_prone),
            },
            FieldInfoData {
                name: "FireHeightOpen",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, fire_height_open),
            },
            FieldInfoData {
                name: "FireHeightCrouch",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, fire_height_crouch),
            },
            FieldInfoData {
                name: "FireHeightMedium",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, fire_height_medium),
            },
            FieldInfoData {
                name: "FireHeightStanding",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, fire_height_standing),
            },
            FieldInfoData {
                name: "MinFreeShootDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, min_free_shoot_dist),
            },
            FieldInfoData {
                name: "FireStepOutDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, fire_step_out_dist),
            },
            FieldInfoData {
                name: "MaxFireSideTestAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, max_fire_side_test_angle),
            },
            FieldInfoData {
                name: "FireSideSampleCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, fire_side_sample_count),
            },
            FieldInfoData {
                name: "PathfindingReferenceLayer",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, pathfinding_reference_layer),
            },
            FieldInfoData {
                name: "TerrainHeightSamplingStep",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, terrain_height_sampling_step),
            },
            FieldInfoData {
                name: "ChunkSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, chunk_size),
            },
            FieldInfoData {
                name: "VoxelSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, voxel_size),
            },
            FieldInfoData {
                name: "VoxelHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, voxel_height),
            },
            FieldInfoData {
                name: "voxelSpanMergeThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, voxel_span_merge_threshold),
            },
            FieldInfoData {
                name: "VoxelSpanMergingMaxSeparation",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, voxel_span_merging_max_separation),
            },
            FieldInfoData {
                name: "MaxStepHeightOverride",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, max_step_height_override),
            },
            FieldInfoData {
                name: "MinIslandSurfaceAreaExtra",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, min_island_surface_area_extra),
            },
            FieldInfoData {
                name: "ContourSimplificationMaxAreaDelta",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, contour_simplification_max_area_delta),
            },
            FieldInfoData {
                name: "ContourSimplificationXZErrorIn",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, contour_simplification_x_z_error_in),
            },
            FieldInfoData {
                name: "ContourSimplificationXZErrorOut",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, contour_simplification_x_z_error_out),
            },
            FieldInfoData {
                name: "ContourSimplificationYError",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, contour_simplification_y_error),
            },
            FieldInfoData {
                name: "OpenCoverMinSpacingDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, open_cover_min_spacing_dist),
            },
            FieldInfoData {
                name: "OpenCoverVoxelSamplingStep",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, open_cover_voxel_sampling_step),
            },
            FieldInfoData {
                name: "OpenCoverVoxelErosionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, open_cover_voxel_erosion_distance),
            },
            FieldInfoData {
                name: "OpenCoverMinDistToManualCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, open_cover_min_dist_to_manual_cover),
            },
            FieldInfoData {
                name: "MinHoverClearance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, min_hover_clearance),
            },
            FieldInfoData {
                name: "HoveringMinDistToCeiling",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, hovering_min_dist_to_ceiling),
            },
            FieldInfoData {
                name: "MaxRealCoverContourSlope",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, max_real_cover_contour_slope),
            },
            FieldInfoData {
                name: "EdgeProbeSampleSpacing",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, edge_probe_sample_spacing),
            },
            FieldInfoData {
                name: "CrouchCoverOcclusionSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PROTECTIVECOVERWALLOCCLUSIONSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, crouch_cover_occlusion_settings),
            },
            FieldInfoData {
                name: "StandCoverOcclusionSettings",
                flags: MemberInfoFlags::new(0),
                field_type: PROTECTIVECOVERWALLOCCLUSIONSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, stand_cover_occlusion_settings),
            },
            FieldInfoData {
                name: "FreeShootHeightRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, free_shoot_height_range),
            },
            FieldInfoData {
                name: "GenerateFullyBlockedCovers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, generate_fully_blocked_covers),
            },
            FieldInfoData {
                name: "FullyBlockedCoverMaxDistFromValidCover",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, fully_blocked_cover_max_dist_from_valid_cover),
            },
            FieldInfoData {
                name: "LedgeForwardClearanceDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, ledge_forward_clearance_dist),
            },
            FieldInfoData {
                name: "LedgeDownwardClearanceDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, ledge_downward_clearance_dist),
            },
            FieldInfoData {
                name: "LedgeDownwardClearanceTestRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, ledge_downward_clearance_test_range),
            },
            FieldInfoData {
                name: "LedgeCoverPlacementStartDistOnEdge",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, ledge_cover_placement_start_dist_on_edge),
            },
            FieldInfoData {
                name: "LedgeCoverPlacementStep",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, ledge_cover_placement_step),
            },
            FieldInfoData {
                name: "LedgeCoverPlacementDistFromLedge",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, ledge_cover_placement_dist_from_ledge),
            },
            FieldInfoData {
                name: "VaultOverPathLinkConfig",
                flags: MemberInfoFlags::new(0),
                field_type: VAULTOVERPATHLINKCONFIG_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, vault_over_path_link_config),
            },
            FieldInfoData {
                name: "LedgeJumpDownPathLinkConfig",
                flags: MemberInfoFlags::new(0),
                field_type: LEDGEJUMPDOWNPATHLINKCONFIG_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, ledge_jump_down_path_link_config),
            },
            FieldInfoData {
                name: "MaxCoversInMemory",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, max_covers_in_memory),
            },
            FieldInfoData {
                name: "CoverZones",
                flags: MemberInfoFlags::new(0),
                field_type: COVERZONES_TYPE_INFO,
                rust_offset: offset_of!(CoverConstantData, cover_zones),
            },
        ],
    }),
    array_type: Some(COVERCONSTANTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverConstantData {
    fn type_info() -> &'static TypeInfo {
        COVERCONSTANTDATA_TYPE_INFO
    }
}


pub const COVERCONSTANTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverConstantData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverConstantData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ProtectiveCoverWallOcclusionSettings {
    pub occlusion_check_dist: f32,
    pub min_occlusion_ratio: f32,
    pub max_hole_size: f32,
    pub occlusion_checking_ground_distance_offset: f32,
}

pub const PROTECTIVECOVERWALLOCCLUSIONSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProtectiveCoverWallOcclusionSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "OcclusionCheckDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProtectiveCoverWallOcclusionSettings, occlusion_check_dist),
            },
            FieldInfoData {
                name: "MinOcclusionRatio",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProtectiveCoverWallOcclusionSettings, min_occlusion_ratio),
            },
            FieldInfoData {
                name: "MaxHoleSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProtectiveCoverWallOcclusionSettings, max_hole_size),
            },
            FieldInfoData {
                name: "OcclusionCheckingGroundDistanceOffset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ProtectiveCoverWallOcclusionSettings, occlusion_checking_ground_distance_offset),
            },
        ],
    }),
    array_type: Some(PROTECTIVECOVERWALLOCCLUSIONSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ProtectiveCoverWallOcclusionSettings {
    fn type_info() -> &'static TypeInfo {
        PROTECTIVECOVERWALLOCCLUSIONSETTINGS_TYPE_INFO
    }
}


pub const PROTECTIVECOVERWALLOCCLUSIONSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProtectiveCoverWallOcclusionSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ProtectiveCoverWallOcclusionSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LedgeJumpDownPathLinkConfig {
    pub floor_clearance_dist_top: f32,
    pub forward_clearance_dist: f32,
    pub forward_clearance_range: f32,
    pub forward_jump_dist: f32,
    pub min_drop_distance: f32,
    pub max_drop_distance: f32,
    pub clearance_offset_from_ground: f32,
    pub max_ground_height_delta_at_base: f32,
    pub min_link_width: f32,
    pub path_link_data: AIPathLinkData,
}

pub const LEDGEJUMPDOWNPATHLINKCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LedgeJumpDownPathLinkConfig",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "FloorClearanceDistTop",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, floor_clearance_dist_top),
            },
            FieldInfoData {
                name: "ForwardClearanceDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, forward_clearance_dist),
            },
            FieldInfoData {
                name: "ForwardClearanceRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, forward_clearance_range),
            },
            FieldInfoData {
                name: "ForwardJumpDist",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, forward_jump_dist),
            },
            FieldInfoData {
                name: "MinDropDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, min_drop_distance),
            },
            FieldInfoData {
                name: "MaxDropDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, max_drop_distance),
            },
            FieldInfoData {
                name: "ClearanceOffsetFromGround",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, clearance_offset_from_ground),
            },
            FieldInfoData {
                name: "MaxGroundHeightDeltaAtBase",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, max_ground_height_delta_at_base),
            },
            FieldInfoData {
                name: "minLinkWidth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, min_link_width),
            },
            FieldInfoData {
                name: "PathLinkData",
                flags: MemberInfoFlags::new(0),
                field_type: AIPATHLINKDATA_TYPE_INFO,
                rust_offset: offset_of!(LedgeJumpDownPathLinkConfig, path_link_data),
            },
        ],
    }),
    array_type: Some(LEDGEJUMPDOWNPATHLINKCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LedgeJumpDownPathLinkConfig {
    fn type_info() -> &'static TypeInfo {
        LEDGEJUMPDOWNPATHLINKCONFIG_TYPE_INFO
    }
}


pub const LEDGEJUMPDOWNPATHLINKCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LedgeJumpDownPathLinkConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("LedgeJumpDownPathLinkConfig-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VaultOverPathLinkConfig {
    pub vault_start_distance: f32,
    pub vault_end_distance: f32,
    pub extra_clearance_distance: f32,
    pub max_cover_panel_slope: f32,
    pub max_cover_panel_separation: f32,
    pub max_cover_panel_alignment_angle: f32,
    pub max_ground_height_deviation: f32,
    pub max_ground_height_step_between_wall_sides: f32,
    pub min_path_link_width: f32,
    pub edge_retraction_distance: f32,
    pub clearance_dist_above_wall: f32,
    pub path_link_data: AIPathLinkData,
}

pub const VAULTOVERPATHLINKCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultOverPathLinkConfig",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "VaultStartDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, vault_start_distance),
            },
            FieldInfoData {
                name: "VaultEndDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, vault_end_distance),
            },
            FieldInfoData {
                name: "ExtraClearanceDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, extra_clearance_distance),
            },
            FieldInfoData {
                name: "MaxCoverPanelSlope",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_cover_panel_slope),
            },
            FieldInfoData {
                name: "MaxCoverPanelSeparation",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_cover_panel_separation),
            },
            FieldInfoData {
                name: "MaxCoverPanelAlignmentAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_cover_panel_alignment_angle),
            },
            FieldInfoData {
                name: "MaxGroundHeightDeviation",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_ground_height_deviation),
            },
            FieldInfoData {
                name: "MaxGroundHeightStepBetweenWallSides",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, max_ground_height_step_between_wall_sides),
            },
            FieldInfoData {
                name: "MinPathLinkWidth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, min_path_link_width),
            },
            FieldInfoData {
                name: "EdgeRetractionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, edge_retraction_distance),
            },
            FieldInfoData {
                name: "ClearanceDistAboveWall",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, clearance_dist_above_wall),
            },
            FieldInfoData {
                name: "PathLinkData",
                flags: MemberInfoFlags::new(0),
                field_type: AIPATHLINKDATA_TYPE_INFO,
                rust_offset: offset_of!(VaultOverPathLinkConfig, path_link_data),
            },
        ],
    }),
    array_type: Some(VAULTOVERPATHLINKCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VaultOverPathLinkConfig {
    fn type_info() -> &'static TypeInfo {
        VAULTOVERPATHLINKCONFIG_TYPE_INFO
    }
}


pub const VAULTOVERPATHLINKCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultOverPathLinkConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VaultOverPathLinkConfig-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverZones {
    pub cover_zones_over_and_out: CoverZoneDefinition,
    pub cover_zones_over: CoverZoneDefinition,
    pub cover_zones_out: CoverZoneDefinition,
    pub cover_zones_open: CoverZoneDefinition,
    pub cover_zones_open_directional: CoverZoneDefinition,
}

pub const COVERZONES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZones",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CoverZonesOverAndOut",
                flags: MemberInfoFlags::new(0),
                field_type: COVERZONEDEFINITION_TYPE_INFO,
                rust_offset: offset_of!(CoverZones, cover_zones_over_and_out),
            },
            FieldInfoData {
                name: "CoverZonesOver",
                flags: MemberInfoFlags::new(0),
                field_type: COVERZONEDEFINITION_TYPE_INFO,
                rust_offset: offset_of!(CoverZones, cover_zones_over),
            },
            FieldInfoData {
                name: "CoverZonesOut",
                flags: MemberInfoFlags::new(0),
                field_type: COVERZONEDEFINITION_TYPE_INFO,
                rust_offset: offset_of!(CoverZones, cover_zones_out),
            },
            FieldInfoData {
                name: "CoverZonesOpen",
                flags: MemberInfoFlags::new(0),
                field_type: COVERZONEDEFINITION_TYPE_INFO,
                rust_offset: offset_of!(CoverZones, cover_zones_open),
            },
            FieldInfoData {
                name: "CoverZonesOpenDirectional",
                flags: MemberInfoFlags::new(0),
                field_type: COVERZONEDEFINITION_TYPE_INFO,
                rust_offset: offset_of!(CoverZones, cover_zones_open_directional),
            },
        ],
    }),
    array_type: Some(COVERZONES_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverZones {
    fn type_info() -> &'static TypeInfo {
        COVERZONES_TYPE_INFO
    }
}


pub const COVERZONES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZones-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverZones-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverZoneDefinition {
    pub zones: Vec<CoverZone>,
}

pub const COVERZONEDEFINITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZoneDefinition",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Zones",
                flags: MemberInfoFlags::new(144),
                field_type: COVERZONE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(CoverZoneDefinition, zones),
            },
        ],
    }),
    array_type: Some(COVERZONEDEFINITION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CoverZoneDefinition {
    fn type_info() -> &'static TypeInfo {
        COVERZONEDEFINITION_TYPE_INFO
    }
}


pub const COVERZONEDEFINITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZoneDefinition-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverZoneDefinition-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverZone {
    pub first_angle: f32,
    pub second_angle: f32,
    pub close_distance: f32,
    pub far_distance: f32,
    pub peek: bool,
    pub over: bool,
    pub out: bool,
    pub flanked: bool,
    pub always_request_cover: bool,
    pub request_cover_if_under_fire: bool,
    pub force_out_firing: bool,
    pub trigger_flanked: bool,
    pub suppressed_by_enemy_bullets: bool,
    pub allow_projectile_fire: bool,
    pub allow_hover_fire: bool,
}

pub const COVERZONE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZone",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "FirstAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, first_angle),
            },
            FieldInfoData {
                name: "SecondAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, second_angle),
            },
            FieldInfoData {
                name: "CloseDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, close_distance),
            },
            FieldInfoData {
                name: "FarDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, far_distance),
            },
            FieldInfoData {
                name: "Peek",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, peek),
            },
            FieldInfoData {
                name: "Over",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, over),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, out),
            },
            FieldInfoData {
                name: "Flanked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, flanked),
            },
            FieldInfoData {
                name: "AlwaysRequestCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, always_request_cover),
            },
            FieldInfoData {
                name: "RequestCoverIfUnderFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, request_cover_if_under_fire),
            },
            FieldInfoData {
                name: "ForceOutFiring",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, force_out_firing),
            },
            FieldInfoData {
                name: "TriggerFlanked",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, trigger_flanked),
            },
            FieldInfoData {
                name: "SuppressedByEnemyBullets",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, suppressed_by_enemy_bullets),
            },
            FieldInfoData {
                name: "AllowProjectileFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, allow_projectile_fire),
            },
            FieldInfoData {
                name: "AllowHoverFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CoverZone, allow_hover_fire),
            },
        ],
    }),
    array_type: Some(COVERZONE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CoverZone {
    fn type_info() -> &'static TypeInfo {
        COVERZONE_TYPE_INFO
    }
}


pub const COVERZONE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverZone-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverZone-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIConcealmentVolumeEntityData {
}

pub const AICONCEALMENTVOLUMEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIConcealmentVolumeEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AICONCEALMENTVOLUMEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIConcealmentVolumeEntityData {
    fn type_info() -> &'static TypeInfo {
        AICONCEALMENTVOLUMEENTITYDATA_TYPE_INFO
    }
}


pub const AICONCEALMENTVOLUMEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIConcealmentVolumeEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIConcealmentVolumeEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIWeaponData {
    pub firing_weapon_class: FiringWeaponClass,
    pub vo_primary_fire_type: VoPrimaryFireType,
    pub weapon_range: f32,
    pub minimum_usage_distance: f32,
    pub maximum_usage_distance: f32,
    pub vehicle_max_target_l_o_s_lost: f32,
    pub min_enter_vehicle_distance: f32,
    pub exit_vehicle_disable_time: f32,
    pub use_target_extrapolation: bool,
    pub causes_evasion_on_fire: bool,
    pub create_evasion_nav_obstacle: bool,
    pub evasion_volume: EvasionVolume,
    pub preferred_range: PreferredRange,
    pub indoor_preferred_range: PreferredRange,
    pub outdoor_preferred_range: PreferredRange,
    pub firing_interval_pattern: FiringIntervalPattern,
    pub sustain_firing_data: SustainFiringData,
    pub burst_interval_pattern: BurstIntervalPattern,
    pub creeping_air_barrage: CreepingAirBarrage,
    pub spray_pattern: SprayPattern,
    pub accuracy_hit_box: AccuracyHitBox,
    pub vehicle_aimer_settings: VehicleAimerSettings,
    pub vision_modifier: VisionModifier,
    pub hearing_modifier: HearingModifier,
    pub target_modifier: TargetModifier,
    pub targeting_settings_override: TargetingData,
    pub vehicle_inaccuracy_settings: VehicleInaccuracySettings,
    pub suppressed_behavior: SuppressedBehavior,
    pub damage_modifier: DamageModifier,
    pub damage_modifier_extended: DamageModifierExtended,
    pub friendly_weapon_restrictions: WeaponRestrictions,
    pub enemy_weapon_restrictions: WeaponRestrictions,
    pub special_behavior: SpecialBehavior,
    pub human_target_hit_probability: WeaponHitProbability,
    pub distance_to_aware_curve_override: DistanceToAwareCurveOverride,
    pub valid_against: ValidAgainst,
    pub target_preference: TargetPreference,
    pub use_shootspace_for_vision: bool,
    pub target_coordination_priority: f32,
    pub exclude_from_target_coordinator: bool,
    pub force_use_target_position: bool,
    pub require_line_of_fire: bool,
    pub min_precision_to_fire: f32,
    pub consider_explosion_rounds: bool,
    pub aim_high_for_explosion_rounds: bool,
    pub consider_target_offset: bool,
    pub cancel_explosion_round_if_out_of_range: bool,
    pub weapon_threat_scale: f32,
    pub valid_weapon_scale: f32,
    pub in_valid_weapon_scale: f32,
}

pub const AIWEAPONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEAIWEAPONDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FiringWeaponClass",
                flags: MemberInfoFlags::new(0),
                field_type: FIRINGWEAPONCLASS_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, firing_weapon_class),
            },
            FieldInfoData {
                name: "VoPrimaryFireType",
                flags: MemberInfoFlags::new(0),
                field_type: VOPRIMARYFIRETYPE_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, vo_primary_fire_type),
            },
            FieldInfoData {
                name: "WeaponRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, weapon_range),
            },
            FieldInfoData {
                name: "MinimumUsageDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, minimum_usage_distance),
            },
            FieldInfoData {
                name: "MaximumUsageDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, maximum_usage_distance),
            },
            FieldInfoData {
                name: "VehicleMaxTargetLOSLost",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, vehicle_max_target_l_o_s_lost),
            },
            FieldInfoData {
                name: "MinEnterVehicleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, min_enter_vehicle_distance),
            },
            FieldInfoData {
                name: "ExitVehicleDisableTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, exit_vehicle_disable_time),
            },
            FieldInfoData {
                name: "UseTargetExtrapolation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, use_target_extrapolation),
            },
            FieldInfoData {
                name: "CausesEvasionOnFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, causes_evasion_on_fire),
            },
            FieldInfoData {
                name: "CreateEvasionNavObstacle",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, create_evasion_nav_obstacle),
            },
            FieldInfoData {
                name: "EvasionVolume",
                flags: MemberInfoFlags::new(0),
                field_type: EVASIONVOLUME_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, evasion_volume),
            },
            FieldInfoData {
                name: "PreferredRange",
                flags: MemberInfoFlags::new(0),
                field_type: PREFERREDRANGE_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, preferred_range),
            },
            FieldInfoData {
                name: "IndoorPreferredRange",
                flags: MemberInfoFlags::new(0),
                field_type: PREFERREDRANGE_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, indoor_preferred_range),
            },
            FieldInfoData {
                name: "OutdoorPreferredRange",
                flags: MemberInfoFlags::new(0),
                field_type: PREFERREDRANGE_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, outdoor_preferred_range),
            },
            FieldInfoData {
                name: "FiringIntervalPattern",
                flags: MemberInfoFlags::new(0),
                field_type: FIRINGINTERVALPATTERN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, firing_interval_pattern),
            },
            FieldInfoData {
                name: "SustainFiringData",
                flags: MemberInfoFlags::new(0),
                field_type: SUSTAINFIRINGDATA_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, sustain_firing_data),
            },
            FieldInfoData {
                name: "BurstIntervalPattern",
                flags: MemberInfoFlags::new(0),
                field_type: BURSTINTERVALPATTERN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, burst_interval_pattern),
            },
            FieldInfoData {
                name: "CreepingAirBarrage",
                flags: MemberInfoFlags::new(0),
                field_type: CREEPINGAIRBARRAGE_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, creeping_air_barrage),
            },
            FieldInfoData {
                name: "SprayPattern",
                flags: MemberInfoFlags::new(0),
                field_type: SPRAYPATTERN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, spray_pattern),
            },
            FieldInfoData {
                name: "AccuracyHitBox",
                flags: MemberInfoFlags::new(0),
                field_type: ACCURACYHITBOX_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, accuracy_hit_box),
            },
            FieldInfoData {
                name: "VehicleAimerSettings",
                flags: MemberInfoFlags::new(0),
                field_type: VEHICLEAIMERSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, vehicle_aimer_settings),
            },
            FieldInfoData {
                name: "VisionModifier",
                flags: MemberInfoFlags::new(0),
                field_type: VISIONMODIFIER_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, vision_modifier),
            },
            FieldInfoData {
                name: "HearingModifier",
                flags: MemberInfoFlags::new(0),
                field_type: HEARINGMODIFIER_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, hearing_modifier),
            },
            FieldInfoData {
                name: "TargetModifier",
                flags: MemberInfoFlags::new(0),
                field_type: TARGETMODIFIER_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, target_modifier),
            },
            FieldInfoData {
                name: "TargetingSettingsOverride",
                flags: MemberInfoFlags::new(0),
                field_type: TARGETINGDATA_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, targeting_settings_override),
            },
            FieldInfoData {
                name: "VehicleInaccuracySettings",
                flags: MemberInfoFlags::new(0),
                field_type: VEHICLEINACCURACYSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, vehicle_inaccuracy_settings),
            },
            FieldInfoData {
                name: "SuppressedBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: SUPPRESSEDBEHAVIOR_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, suppressed_behavior),
            },
            FieldInfoData {
                name: "DamageModifier",
                flags: MemberInfoFlags::new(0),
                field_type: DAMAGEMODIFIER_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, damage_modifier),
            },
            FieldInfoData {
                name: "DamageModifierExtended",
                flags: MemberInfoFlags::new(0),
                field_type: DAMAGEMODIFIEREXTENDED_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, damage_modifier_extended),
            },
            FieldInfoData {
                name: "FriendlyWeaponRestrictions",
                flags: MemberInfoFlags::new(0),
                field_type: WEAPONRESTRICTIONS_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, friendly_weapon_restrictions),
            },
            FieldInfoData {
                name: "EnemyWeaponRestrictions",
                flags: MemberInfoFlags::new(0),
                field_type: WEAPONRESTRICTIONS_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, enemy_weapon_restrictions),
            },
            FieldInfoData {
                name: "SpecialBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: SPECIALBEHAVIOR_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, special_behavior),
            },
            FieldInfoData {
                name: "HumanTargetHitProbability",
                flags: MemberInfoFlags::new(0),
                field_type: WEAPONHITPROBABILITY_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, human_target_hit_probability),
            },
            FieldInfoData {
                name: "DistanceToAwareCurveOverride",
                flags: MemberInfoFlags::new(0),
                field_type: DISTANCETOAWARECURVEOVERRIDE_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, distance_to_aware_curve_override),
            },
            FieldInfoData {
                name: "ValidAgainst",
                flags: MemberInfoFlags::new(0),
                field_type: VALIDAGAINST_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, valid_against),
            },
            FieldInfoData {
                name: "TargetPreference",
                flags: MemberInfoFlags::new(0),
                field_type: TARGETPREFERENCE_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, target_preference),
            },
            FieldInfoData {
                name: "UseShootspaceForVision",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, use_shootspace_for_vision),
            },
            FieldInfoData {
                name: "TargetCoordinationPriority",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, target_coordination_priority),
            },
            FieldInfoData {
                name: "ExcludeFromTargetCoordinator",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, exclude_from_target_coordinator),
            },
            FieldInfoData {
                name: "ForceUseTargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, force_use_target_position),
            },
            FieldInfoData {
                name: "RequireLineOfFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, require_line_of_fire),
            },
            FieldInfoData {
                name: "MinPrecisionToFire",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, min_precision_to_fire),
            },
            FieldInfoData {
                name: "ConsiderExplosionRounds",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, consider_explosion_rounds),
            },
            FieldInfoData {
                name: "AimHighForExplosionRounds",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, aim_high_for_explosion_rounds),
            },
            FieldInfoData {
                name: "ConsiderTargetOffset",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, consider_target_offset),
            },
            FieldInfoData {
                name: "CancelExplosionRoundIfOutOfRange",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, cancel_explosion_round_if_out_of_range),
            },
            FieldInfoData {
                name: "WeaponThreatScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, weapon_threat_scale),
            },
            FieldInfoData {
                name: "ValidWeaponScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, valid_weapon_scale),
            },
            FieldInfoData {
                name: "InValidWeaponScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIWeaponData, in_valid_weapon_scale),
            },
        ],
    }),
    array_type: Some(AIWEAPONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIWeaponData {
    fn type_info() -> &'static TypeInfo {
        AIWEAPONDATA_TYPE_INFO
    }
}


pub const AIWEAPONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWeaponData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIWeaponData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct TargetingData {
    pub aim_offset_y: f32,
    pub visible_target_limit: f32,
    pub target_lost_timer: f32,
    pub target_distance_evaluation: TinyPiecewiseLinearCurve,
    pub suppression_score: SuppressionValues,
    pub human_suppression_score_multiplier: f32,
    pub suppression_time_limit: f32,
    pub aquired_timer: f32,
    pub aquired_object_timer: f32,
    pub aquired_dist_scale: f32,
    pub target_aiming_timer: f32,
    pub current_human_target_aiming_dist_scale: f32,
    pub low_health_percentage: f32,
    pub current_human_target_low_health_dist_scale: f32,
    pub elevation_above_threshold: f32,
    pub elevation_dist_scale_y: f32,
    pub current_target_dist_scale: f32,
    pub target_visible_dist_scale: f32,
    pub human_preference_scale: f32,
    pub target_object_dist_scale: f32,
    pub balance_distribution: bool,
    pub enable_target_coordinator: bool,
}

pub const TARGETINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetingData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AimOffsetY",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, aim_offset_y),
            },
            FieldInfoData {
                name: "VisibleTargetLimit",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, visible_target_limit),
            },
            FieldInfoData {
                name: "TargetLostTimer",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, target_lost_timer),
            },
            FieldInfoData {
                name: "TargetDistanceEvaluation",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, target_distance_evaluation),
            },
            FieldInfoData {
                name: "SuppressionScore",
                flags: MemberInfoFlags::new(0),
                field_type: SUPPRESSIONVALUES_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, suppression_score),
            },
            FieldInfoData {
                name: "HumanSuppressionScoreMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, human_suppression_score_multiplier),
            },
            FieldInfoData {
                name: "SuppressionTimeLimit",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, suppression_time_limit),
            },
            FieldInfoData {
                name: "AquiredTimer",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, aquired_timer),
            },
            FieldInfoData {
                name: "AquiredObjectTimer",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, aquired_object_timer),
            },
            FieldInfoData {
                name: "AquiredDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, aquired_dist_scale),
            },
            FieldInfoData {
                name: "TargetAimingTimer",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, target_aiming_timer),
            },
            FieldInfoData {
                name: "CurrentHumanTargetAimingDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, current_human_target_aiming_dist_scale),
            },
            FieldInfoData {
                name: "LowHealthPercentage",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, low_health_percentage),
            },
            FieldInfoData {
                name: "CurrentHumanTargetLowHealthDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, current_human_target_low_health_dist_scale),
            },
            FieldInfoData {
                name: "ElevationAboveThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, elevation_above_threshold),
            },
            FieldInfoData {
                name: "ElevationDistScaleY",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, elevation_dist_scale_y),
            },
            FieldInfoData {
                name: "CurrentTargetDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, current_target_dist_scale),
            },
            FieldInfoData {
                name: "TargetVisibleDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, target_visible_dist_scale),
            },
            FieldInfoData {
                name: "HumanPreferenceScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, human_preference_scale),
            },
            FieldInfoData {
                name: "TargetObjectDistScale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, target_object_dist_scale),
            },
            FieldInfoData {
                name: "BalanceDistribution",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, balance_distribution),
            },
            FieldInfoData {
                name: "EnableTargetCoordinator",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(TargetingData, enable_target_coordinator),
            },
        ],
    }),
    array_type: Some(TARGETINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TargetingData {
    fn type_info() -> &'static TypeInfo {
        TARGETINGDATA_TYPE_INFO
    }
}


pub const TARGETINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetingData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DistanceToAwareCurveOverride {
    pub distance_to_aware_time_curve_central: TinyPiecewiseLinearCurve,
    pub distance_to_aware_time_curve_peripheral: TinyPiecewiseLinearCurve,
}

pub const DISTANCETOAWARECURVEOVERRIDE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistanceToAwareCurveOverride",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DistanceToAwareTimeCurveCentral",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(DistanceToAwareCurveOverride, distance_to_aware_time_curve_central),
            },
            FieldInfoData {
                name: "DistanceToAwareTimeCurvePeripheral",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(DistanceToAwareCurveOverride, distance_to_aware_time_curve_peripheral),
            },
        ],
    }),
    array_type: Some(DISTANCETOAWARECURVEOVERRIDE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DistanceToAwareCurveOverride {
    fn type_info() -> &'static TypeInfo {
        DISTANCETOAWARECURVEOVERRIDE_TYPE_INFO
    }
}


pub const DISTANCETOAWARECURVEOVERRIDE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistanceToAwareCurveOverride-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DistanceToAwareCurveOverride-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SuppressionValues {
    pub front: f32,
    pub back: f32,
}

pub const SUPPRESSIONVALUES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionValues",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Front",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SuppressionValues, front),
            },
            FieldInfoData {
                name: "Back",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SuppressionValues, back),
            },
        ],
    }),
    array_type: Some(SUPPRESSIONVALUES_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SuppressionValues {
    fn type_info() -> &'static TypeInfo {
        SUPPRESSIONVALUES_TYPE_INFO
    }
}


pub const SUPPRESSIONVALUES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressionValues-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SuppressionValues-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WeaponHitProbability {
    pub distance_to_target: Vec<f32>,
    pub distance_probability: Vec<f32>,
    pub target_visibility: Vec<f32>,
    pub visible_probability: Vec<f32>,
}

pub const WEAPONHITPROBABILITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponHitProbability",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DistanceToTarget",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(WeaponHitProbability, distance_to_target),
            },
            FieldInfoData {
                name: "DistanceProbability",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(WeaponHitProbability, distance_probability),
            },
            FieldInfoData {
                name: "TargetVisibility",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(WeaponHitProbability, target_visibility),
            },
            FieldInfoData {
                name: "VisibleProbability",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(WeaponHitProbability, visible_probability),
            },
        ],
    }),
    array_type: Some(WEAPONHITPROBABILITY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponHitProbability {
    fn type_info() -> &'static TypeInfo {
        WEAPONHITPROBABILITY_TYPE_INFO
    }
}


pub const WEAPONHITPROBABILITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponHitProbability-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WeaponHitProbability-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SpecialBehavior {
    pub allow_fire_while_target_is_hidden: bool,
}

pub const SPECIALBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpecialBehavior",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AllowFireWhileTargetIsHidden",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SpecialBehavior, allow_fire_while_target_is_hidden),
            },
        ],
    }),
    array_type: Some(SPECIALBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpecialBehavior {
    fn type_info() -> &'static TypeInfo {
        SPECIALBEHAVIOR_TYPE_INFO
    }
}


pub const SPECIALBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpecialBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SpecialBehavior-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PreferredRange {
    pub start: f32,
    pub ideal: f32,
    pub end: f32,
}

pub const PREFERREDRANGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PreferredRange",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PreferredRange, start),
            },
            FieldInfoData {
                name: "Ideal",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PreferredRange, ideal),
            },
            FieldInfoData {
                name: "End",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PreferredRange, end),
            },
        ],
    }),
    array_type: Some(PREFERREDRANGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PreferredRange {
    fn type_info() -> &'static TypeInfo {
        PREFERREDRANGE_TYPE_INFO
    }
}


pub const PREFERREDRANGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PreferredRange-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("PreferredRange-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WeaponRestrictions {
    pub fire_delay_min: f32,
    pub fire_delay_max: f32,
}

pub const WEAPONRESTRICTIONS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponRestrictions",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FireDelayMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WeaponRestrictions, fire_delay_min),
            },
            FieldInfoData {
                name: "FireDelayMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WeaponRestrictions, fire_delay_max),
            },
        ],
    }),
    array_type: Some(WEAPONRESTRICTIONS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WeaponRestrictions {
    fn type_info() -> &'static TypeInfo {
        WEAPONRESTRICTIONS_TYPE_INFO
    }
}


pub const WEAPONRESTRICTIONS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WeaponRestrictions-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("WeaponRestrictions-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DamageModifierExtended {
    pub damage: PiecewiseLinearCurve,
}

pub const DAMAGEMODIFIEREXTENDED_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifierExtended",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Damage",
                flags: MemberInfoFlags::new(0),
                field_type: PIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(DamageModifierExtended, damage),
            },
        ],
    }),
    array_type: Some(DAMAGEMODIFIEREXTENDED_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DamageModifierExtended {
    fn type_info() -> &'static TypeInfo {
        DAMAGEMODIFIEREXTENDED_TYPE_INFO
    }
}


pub const DAMAGEMODIFIEREXTENDED_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifierExtended-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DamageModifierExtended-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DamageModifier {
    pub damage: TinyPiecewiseLinearCurve,
}

pub const DAMAGEMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Damage",
                flags: MemberInfoFlags::new(0),
                field_type: TINYPIECEWISELINEARCURVE_TYPE_INFO,
                rust_offset: offset_of!(DamageModifier, damage),
            },
        ],
    }),
    array_type: Some(DAMAGEMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DamageModifier {
    fn type_info() -> &'static TypeInfo {
        DAMAGEMODIFIER_TYPE_INFO
    }
}


pub const DAMAGEMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DamageModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DamageModifier-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SuppressedBehavior {
    pub suppressed_time: f32,
    pub target_squad_time: f32,
}

pub const SUPPRESSEDBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressedBehavior",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SuppressedTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SuppressedBehavior, suppressed_time),
            },
            FieldInfoData {
                name: "TargetSquadTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SuppressedBehavior, target_squad_time),
            },
        ],
    }),
    array_type: Some(SUPPRESSEDBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SuppressedBehavior {
    fn type_info() -> &'static TypeInfo {
        SUPPRESSEDBEHAVIOR_TYPE_INFO
    }
}


pub const SUPPRESSEDBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SuppressedBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SuppressedBehavior-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VehicleInaccuracySettings {
    pub reset_on_re_target: bool,
    pub min_aim_angle: f32,
    pub max_aim_angle: f32,
    pub accuracy_increase_speed: f32,
    pub accuracy_decrease_speed: f32,
}

pub const VEHICLEINACCURACYSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleInaccuracySettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ResetOnReTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VehicleInaccuracySettings, reset_on_re_target),
            },
            FieldInfoData {
                name: "MinAimAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleInaccuracySettings, min_aim_angle),
            },
            FieldInfoData {
                name: "MaxAimAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleInaccuracySettings, max_aim_angle),
            },
            FieldInfoData {
                name: "AccuracyIncreaseSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleInaccuracySettings, accuracy_increase_speed),
            },
            FieldInfoData {
                name: "AccuracyDecreaseSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleInaccuracySettings, accuracy_decrease_speed),
            },
        ],
    }),
    array_type: Some(VEHICLEINACCURACYSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleInaccuracySettings {
    fn type_info() -> &'static TypeInfo {
        VEHICLEINACCURACYSETTINGS_TYPE_INFO
    }
}


pub const VEHICLEINACCURACYSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleInaccuracySettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleInaccuracySettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct TargetModifier {
    pub squad_suppression: bool,
    pub always_target_human: bool,
}

pub const TARGETMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SquadSuppression",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(TargetModifier, squad_suppression),
            },
            FieldInfoData {
                name: "AlwaysTargetHuman",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(TargetModifier, always_target_human),
            },
        ],
    }),
    array_type: Some(TARGETMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TargetModifier {
    fn type_info() -> &'static TypeInfo {
        TARGETMODIFIER_TYPE_INFO
    }
}


pub const TARGETMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetModifier-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FlashlightModifier {
    pub flashlight_cone_range: f32,
    pub flashlight_cone_angle: f32,
}

pub const FLASHLIGHTMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlashlightModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FlashlightConeRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlashlightModifier, flashlight_cone_range),
            },
            FieldInfoData {
                name: "FlashlightConeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlashlightModifier, flashlight_cone_angle),
            },
        ],
    }),
    array_type: Some(FLASHLIGHTMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FlashlightModifier {
    fn type_info() -> &'static TypeInfo {
        FLASHLIGHTMODIFIER_TYPE_INFO
    }
}


pub const FLASHLIGHTMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlashlightModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FlashlightModifier-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct HearingModifier {
    pub sensing_shot_fired_distance: f32,
    pub sensing_human_driven_vehicle_distance: f32,
    pub sensing_explosion_distance: f32,
    pub sensing_grenade_distance: f32,
}

pub const HEARINGMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HearingModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SensingShotFiredDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HearingModifier, sensing_shot_fired_distance),
            },
            FieldInfoData {
                name: "SensingHumanDrivenVehicleDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HearingModifier, sensing_human_driven_vehicle_distance),
            },
            FieldInfoData {
                name: "SensingExplosionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HearingModifier, sensing_explosion_distance),
            },
            FieldInfoData {
                name: "SensingGrenadeDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HearingModifier, sensing_grenade_distance),
            },
        ],
    }),
    array_type: Some(HEARINGMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HearingModifier {
    fn type_info() -> &'static TypeInfo {
        HEARINGMODIFIER_TYPE_INFO
    }
}


pub const HEARINGMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HearingModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("HearingModifier-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VisionModifier {
    pub sensing_cone_range: f32,
    pub sensing_cone_range_when_alerted: f32,
    pub sensing_cone_angle: f32,
    pub sensing_cone_angle_when_alerted: f32,
    pub sensing_cone_angle_above: f32,
    pub sensing_cone_angle_below: f32,
    pub always_see_human: bool,
    pub sensing_static_target_object_distance: f32,
    pub sensing_moving_target_object_distance: f32,
    pub flashlight_modifier: FlashlightModifier,
}

pub const VISIONMODIFIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisionModifier",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SensingConeRange",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, sensing_cone_range),
            },
            FieldInfoData {
                name: "SensingConeRangeWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, sensing_cone_range_when_alerted),
            },
            FieldInfoData {
                name: "SensingConeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, sensing_cone_angle),
            },
            FieldInfoData {
                name: "SensingConeAngleWhenAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, sensing_cone_angle_when_alerted),
            },
            FieldInfoData {
                name: "SensingConeAngleAbove",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, sensing_cone_angle_above),
            },
            FieldInfoData {
                name: "SensingConeAngleBelow",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, sensing_cone_angle_below),
            },
            FieldInfoData {
                name: "AlwaysSeeHuman",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, always_see_human),
            },
            FieldInfoData {
                name: "SensingStaticTargetObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, sensing_static_target_object_distance),
            },
            FieldInfoData {
                name: "SensingMovingTargetObjectDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, sensing_moving_target_object_distance),
            },
            FieldInfoData {
                name: "FlashlightModifier",
                flags: MemberInfoFlags::new(0),
                field_type: FLASHLIGHTMODIFIER_TYPE_INFO,
                rust_offset: offset_of!(VisionModifier, flashlight_modifier),
            },
        ],
    }),
    array_type: Some(VISIONMODIFIER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VisionModifier {
    fn type_info() -> &'static TypeInfo {
        VISIONMODIFIER_TYPE_INFO
    }
}


pub const VISIONMODIFIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VisionModifier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VisionModifier-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EvasionVolume {
    pub volume_width: f32,
    pub volume_height: f32,
    pub volume_depth: f32,
    pub offset_from_center: super::core::Vec3,
}

pub const EVASIONVOLUME_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvasionVolume",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "VolumeWidth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvasionVolume, volume_width),
            },
            FieldInfoData {
                name: "VolumeHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvasionVolume, volume_height),
            },
            FieldInfoData {
                name: "VolumeDepth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvasionVolume, volume_depth),
            },
            FieldInfoData {
                name: "OffsetFromCenter",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(EvasionVolume, offset_from_center),
            },
        ],
    }),
    array_type: Some(EVASIONVOLUME_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for EvasionVolume {
    fn type_info() -> &'static TypeInfo {
        EVASIONVOLUME_TYPE_INFO
    }
}


pub const EVASIONVOLUME_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvasionVolume-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EvasionVolume-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AccuracyHitBox {
    pub aim_box_dist_min: f32,
    pub aim_box_dist_max: f32,
    pub aim_box_dist_far_start: f32,
    pub aim_box_dist_far_end: f32,
    pub aim_box_width_min_dist_min: f32,
    pub aim_box_width_max_dist_min: f32,
    pub aim_box_height_min_dist_min: f32,
    pub aim_box_height_max_dist_min: f32,
    pub aim_box_width_min_dist_max: f32,
    pub aim_box_width_max_dist_max: f32,
    pub aim_box_height_min_dist_max: f32,
    pub aim_box_height_max_dist_max: f32,
    pub aim_box_width_min_dist_far: f32,
    pub aim_box_width_max_dist_far: f32,
    pub aim_box_height_min_dist_far: f32,
    pub aim_box_height_max_dist_far: f32,
}

pub const ACCURACYHITBOX_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AccuracyHitBox",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AimBoxDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_dist_min),
            },
            FieldInfoData {
                name: "AimBoxDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_dist_max),
            },
            FieldInfoData {
                name: "AimBoxDistFarStart",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_dist_far_start),
            },
            FieldInfoData {
                name: "AimBoxDistFarEnd",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_dist_far_end),
            },
            FieldInfoData {
                name: "AimBoxWidthMinDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_min_dist_min),
            },
            FieldInfoData {
                name: "AimBoxWidthMaxDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_max_dist_min),
            },
            FieldInfoData {
                name: "AimBoxHeightMinDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_min_dist_min),
            },
            FieldInfoData {
                name: "AimBoxHeightMaxDistMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_max_dist_min),
            },
            FieldInfoData {
                name: "AimBoxWidthMinDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_min_dist_max),
            },
            FieldInfoData {
                name: "AimBoxWidthMaxDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_max_dist_max),
            },
            FieldInfoData {
                name: "AimBoxHeightMinDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_min_dist_max),
            },
            FieldInfoData {
                name: "AimBoxHeightMaxDistMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_max_dist_max),
            },
            FieldInfoData {
                name: "AimBoxWidthMinDistFar",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_min_dist_far),
            },
            FieldInfoData {
                name: "AimBoxWidthMaxDistFar",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_width_max_dist_far),
            },
            FieldInfoData {
                name: "AimBoxHeightMinDistFar",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_min_dist_far),
            },
            FieldInfoData {
                name: "AimBoxHeightMaxDistFar",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AccuracyHitBox, aim_box_height_max_dist_far),
            },
        ],
    }),
    array_type: Some(ACCURACYHITBOX_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AccuracyHitBox {
    fn type_info() -> &'static TypeInfo {
        ACCURACYHITBOX_TYPE_INFO
    }
}


pub const ACCURACYHITBOX_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AccuracyHitBox-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AccuracyHitBox-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SprayPattern {
    pub area_height: f32,
    pub sweep_time_pitch: f32,
    pub area_width: f32,
    pub sweep_time_yaw: f32,
}

pub const SPRAYPATTERN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SprayPattern",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AreaHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SprayPattern, area_height),
            },
            FieldInfoData {
                name: "SweepTimePitch",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SprayPattern, sweep_time_pitch),
            },
            FieldInfoData {
                name: "AreaWidth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SprayPattern, area_width),
            },
            FieldInfoData {
                name: "SweepTimeYaw",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SprayPattern, sweep_time_yaw),
            },
        ],
    }),
    array_type: Some(SPRAYPATTERN_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SprayPattern {
    fn type_info() -> &'static TypeInfo {
        SPRAYPATTERN_TYPE_INFO
    }
}


pub const SPRAYPATTERN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SprayPattern-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SprayPattern-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CreepingAirBarrage {
    pub start_distance: f32,
    pub time_to_interception_point: f32,
    pub time_at_interception_point: f32,
    pub cooldown: f32,
    pub ahead_of_player_multiplier: f32,
}

pub const CREEPINGAIRBARRAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreepingAirBarrage",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "StartDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CreepingAirBarrage, start_distance),
            },
            FieldInfoData {
                name: "TimeToInterceptionPoint",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CreepingAirBarrage, time_to_interception_point),
            },
            FieldInfoData {
                name: "TimeAtInterceptionPoint",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CreepingAirBarrage, time_at_interception_point),
            },
            FieldInfoData {
                name: "Cooldown",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CreepingAirBarrage, cooldown),
            },
            FieldInfoData {
                name: "AheadOfPlayerMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CreepingAirBarrage, ahead_of_player_multiplier),
            },
        ],
    }),
    array_type: Some(CREEPINGAIRBARRAGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CreepingAirBarrage {
    fn type_info() -> &'static TypeInfo {
        CREEPINGAIRBARRAGE_TYPE_INFO
    }
}


pub const CREEPINGAIRBARRAGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CreepingAirBarrage-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CreepingAirBarrage-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BurstIntervalPattern {
    pub burst_interval: Vec<BurstInterval>,
}

pub const BURSTINTERVALPATTERN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BurstIntervalPattern",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "BurstInterval",
                flags: MemberInfoFlags::new(144),
                field_type: BURSTINTERVAL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(BurstIntervalPattern, burst_interval),
            },
        ],
    }),
    array_type: Some(BURSTINTERVALPATTERN_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BurstIntervalPattern {
    fn type_info() -> &'static TypeInfo {
        BURSTINTERVALPATTERN_TYPE_INFO
    }
}


pub const BURSTINTERVALPATTERN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BurstIntervalPattern-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BurstIntervalPattern-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BurstInterval {
    pub burst_length: f32,
    pub burst_length_variation: f32,
    pub time_between_bursts: f32,
    pub time_between_bursts_variation: f32,
}

pub const BURSTINTERVAL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BurstInterval",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "BurstLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BurstInterval, burst_length),
            },
            FieldInfoData {
                name: "BurstLengthVariation",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BurstInterval, burst_length_variation),
            },
            FieldInfoData {
                name: "TimeBetweenBursts",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BurstInterval, time_between_bursts),
            },
            FieldInfoData {
                name: "TimeBetweenBurstsVariation",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BurstInterval, time_between_bursts_variation),
            },
        ],
    }),
    array_type: Some(BURSTINTERVAL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for BurstInterval {
    fn type_info() -> &'static TypeInfo {
        BURSTINTERVAL_TYPE_INFO
    }
}


pub const BURSTINTERVAL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BurstInterval-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BurstInterval-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SustainFiringData {
    pub fire_style: SustainFiringFireStyle,
    pub spin_up_duration: f32,
    pub sustain_fire_time_min: f32,
    pub sustain_fire_time_max: f32,
    pub cooldown_duration_min: f32,
    pub cooldown_duration_max: f32,
    pub tracking_rate: f32,
    pub sweep_area_settings: SustainFiringSweepAreaSettings,
    pub stop_sustain_fire_when_shot_at: bool,
    pub is_allowed_to_move: bool,
}

pub const SUSTAINFIRINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FireStyle",
                flags: MemberInfoFlags::new(0),
                field_type: SUSTAINFIRINGFIRESTYLE_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, fire_style),
            },
            FieldInfoData {
                name: "SpinUpDuration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, spin_up_duration),
            },
            FieldInfoData {
                name: "SustainFireTimeMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, sustain_fire_time_min),
            },
            FieldInfoData {
                name: "SustainFireTimeMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, sustain_fire_time_max),
            },
            FieldInfoData {
                name: "CooldownDurationMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, cooldown_duration_min),
            },
            FieldInfoData {
                name: "CooldownDurationMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, cooldown_duration_max),
            },
            FieldInfoData {
                name: "TrackingRate",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, tracking_rate),
            },
            FieldInfoData {
                name: "SweepAreaSettings",
                flags: MemberInfoFlags::new(0),
                field_type: SUSTAINFIRINGSWEEPAREASETTINGS_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, sweep_area_settings),
            },
            FieldInfoData {
                name: "StopSustainFireWhenShotAt",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, stop_sustain_fire_when_shot_at),
            },
            FieldInfoData {
                name: "IsAllowedToMove",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringData, is_allowed_to_move),
            },
        ],
    }),
    array_type: Some(SUSTAINFIRINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SustainFiringData {
    fn type_info() -> &'static TypeInfo {
        SUSTAINFIRINGDATA_TYPE_INFO
    }
}


pub const SUSTAINFIRINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SustainFiringSweepAreaSettings {
    pub sweep_arc_width: f32,
    pub minimum_sweep_movement: f32,
    pub sweep_rate: f32,
    pub post_sweep_pause_duration: f32,
    pub start_sweep_from_edge_of_arc: bool,
}

pub const SUSTAINFIRINGSWEEPAREASETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringSweepAreaSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SweepArcWidth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, sweep_arc_width),
            },
            FieldInfoData {
                name: "MinimumSweepMovement",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, minimum_sweep_movement),
            },
            FieldInfoData {
                name: "SweepRate",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, sweep_rate),
            },
            FieldInfoData {
                name: "PostSweepPauseDuration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, post_sweep_pause_duration),
            },
            FieldInfoData {
                name: "StartSweepFromEdgeOfArc",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SustainFiringSweepAreaSettings, start_sweep_from_edge_of_arc),
            },
        ],
    }),
    array_type: Some(SUSTAINFIRINGSWEEPAREASETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SustainFiringSweepAreaSettings {
    fn type_info() -> &'static TypeInfo {
        SUSTAINFIRINGSWEEPAREASETTINGS_TYPE_INFO
    }
}


pub const SUSTAINFIRINGSWEEPAREASETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringSweepAreaSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringSweepAreaSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SustainFiringState {
    #[default]
    SustainFiringState_Ready = 0,
    SustainFiringState_SpinUp = 1,
    SustainFiringState_BeginFiring = 2,
    SustainFiringState_Sustain = 3,
    SustainFiringState_Cooldown = 4,
}

pub const SUSTAINFIRINGSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SUSTAINFIRINGSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SustainFiringState {
    fn type_info() -> &'static TypeInfo {
        SUSTAINFIRINGSTATE_TYPE_INFO
    }
}


pub const SUSTAINFIRINGSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringState-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SustainFiringFireStyle {
    #[default]
    SustainFiringFireStyle_TrackTarget = 0,
    SustainFiringFireStyle_SweepArea = 1,
}

pub const SUSTAINFIRINGFIRESTYLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringFireStyle",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SUSTAINFIRINGFIRESTYLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SustainFiringFireStyle {
    fn type_info() -> &'static TypeInfo {
        SUSTAINFIRINGFIRESTYLE_TYPE_INFO
    }
}


pub const SUSTAINFIRINGFIRESTYLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringFireStyle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringFireStyle-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SustainFiringSweepAreaState {
    #[default]
    SweepAreaState_Init = 0,
    SweepAreaState_Ready = 1,
    SweepAreaState_Begin = 2,
    SweepAreaState_Moving = 3,
}

pub const SUSTAINFIRINGSWEEPAREASTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringSweepAreaState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(SUSTAINFIRINGSWEEPAREASTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SustainFiringSweepAreaState {
    fn type_info() -> &'static TypeInfo {
        SUSTAINFIRINGSWEEPAREASTATE_TYPE_INFO
    }
}


pub const SUSTAINFIRINGSWEEPAREASTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SustainFiringSweepAreaState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SustainFiringSweepAreaState-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FiringIntervalPattern {
    pub interval: Vec<Interval>,
}

pub const FIRINGINTERVALPATTERN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringIntervalPattern",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Interval",
                flags: MemberInfoFlags::new(144),
                field_type: INTERVAL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(FiringIntervalPattern, interval),
            },
        ],
    }),
    array_type: Some(FIRINGINTERVALPATTERN_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FiringIntervalPattern {
    fn type_info() -> &'static TypeInfo {
        FIRINGINTERVALPATTERN_TYPE_INFO
    }
}


pub const FIRINGINTERVALPATTERN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FiringIntervalPattern-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("FiringIntervalPattern-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VehicleAimerSettings {
    pub is_parabolic: bool,
    pub aim_high: bool,
    pub min_precision_to_fire: f32,
    pub track_towards_target: bool,
    pub track_beyond_target: bool,
}

pub const VEHICLEAIMERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleAimerSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "IsParabolic",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VehicleAimerSettings, is_parabolic),
            },
            FieldInfoData {
                name: "AimHigh",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VehicleAimerSettings, aim_high),
            },
            FieldInfoData {
                name: "MinPrecisionToFire",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleAimerSettings, min_precision_to_fire),
            },
            FieldInfoData {
                name: "TrackTowardsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VehicleAimerSettings, track_towards_target),
            },
            FieldInfoData {
                name: "TrackBeyondTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VehicleAimerSettings, track_beyond_target),
            },
        ],
    }),
    array_type: Some(VEHICLEAIMERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleAimerSettings {
    fn type_info() -> &'static TypeInfo {
        VEHICLEAIMERSETTINGS_TYPE_INFO
    }
}


pub const VEHICLEAIMERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleAimerSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleAimerSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct Interval {
    pub minimum_time: f32,
    pub maximum_time: f32,
}

pub const INTERVAL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Interval",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MinimumTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(Interval, minimum_time),
            },
            FieldInfoData {
                name: "MaximumTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(Interval, maximum_time),
            },
        ],
    }),
    array_type: Some(INTERVAL_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Interval {
    fn type_info() -> &'static TypeInfo {
        INTERVAL_TYPE_INFO
    }
}


pub const INTERVAL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Interval-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Interval-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoPrimaryFireType {
    #[default]
    VoPrimaryFireType_AssaultRifle = 4294967295,
    VoPrimaryFireType_MachineGun = 4294967294,
    VoPrimaryFireType_Pistol = 4294967293,
    VoPrimaryFireType_SniperRifle = 4294967292,
    VoPrimaryFireType_SMG = 4294967291,
}

pub const VOPRIMARYFIRETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoPrimaryFireType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(VOPRIMARYFIRETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoPrimaryFireType {
    fn type_info() -> &'static TypeInfo {
        VOPRIMARYFIRETYPE_TYPE_INFO
    }
}


pub const VOPRIMARYFIRETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoPrimaryFireType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VoPrimaryFireType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CombatEnvironment {
    #[default]
    CombatEnvironment_Default = 0,
    CombatEnvironment_Indoor = 1,
    CombatEnvironment_Outdoor = 2,
}

pub const COMBATENVIRONMENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatEnvironment",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COMBATENVIRONMENT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CombatEnvironment {
    fn type_info() -> &'static TypeInfo {
        COMBATENVIRONMENT_TYPE_INFO
    }
}


pub const COMBATENVIRONMENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatEnvironment-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CombatEnvironment-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum TargetPreference {
    #[default]
    TargetPreference_Soldiers = 0,
    TargetPreference_Vehicles = 1,
}

pub const TARGETPREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetPreference",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(TARGETPREFERENCE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TargetPreference {
    fn type_info() -> &'static TypeInfo {
        TARGETPREFERENCE_TYPE_INFO
    }
}


pub const TARGETPREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetPreference-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetPreference-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum ValidAgainst {
    #[default]
    ValidAgainst_Nothing = 0,
    ValidAgainst_Soldiers = 1,
    ValidAgainst_SoldiersAndUnshieldedVehicles = 2,
    ValidAgainst_UnshieldedVehicles = 3,
    ValidAgainst_ShieldedVehicles = 4,
    ValidAgainst_AllVehicles = 5,
    ValidAgainst_All = 6,
    ValidAgainst_HumanSoldiers = 7,
}

pub const VALIDAGAINST_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidAgainst",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(VALIDAGAINST_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ValidAgainst {
    fn type_info() -> &'static TypeInfo {
        VALIDAGAINST_TYPE_INFO
    }
}


pub const VALIDAGAINST_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValidAgainst-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ValidAgainst-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIVehicleCombatEntityData {
    pub use_path_finding: bool,
    pub exclusive_combat_zones: bool,
    pub settings: VehicleCombatSettings,
    pub is_alerted: bool,
    pub occupying_ai_id: i32,
    pub last_known_location: super::core::Vec3,
    pub actual_location: super::core::Vec3,
    pub time_since_visible: f32,
    pub best_target_angle: f32,
    pub is_vehicle_target: bool,
    pub patrol_speed: f32,
    pub combat_speed: f32,
    pub allow_fire_while_following: bool,
}

pub const AIVEHICLECOMBATENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleCombatEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "UsePathFinding",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, use_path_finding),
            },
            FieldInfoData {
                name: "ExclusiveCombatZones",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, exclusive_combat_zones),
            },
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(0),
                field_type: VEHICLECOMBATSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, settings),
            },
            FieldInfoData {
                name: "IsAlerted",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, is_alerted),
            },
            FieldInfoData {
                name: "OccupyingAiId",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, occupying_ai_id),
            },
            FieldInfoData {
                name: "LastKnownLocation",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, last_known_location),
            },
            FieldInfoData {
                name: "ActualLocation",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, actual_location),
            },
            FieldInfoData {
                name: "TimeSinceVisible",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, time_since_visible),
            },
            FieldInfoData {
                name: "BestTargetAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, best_target_angle),
            },
            FieldInfoData {
                name: "IsVehicleTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, is_vehicle_target),
            },
            FieldInfoData {
                name: "PatrolSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, patrol_speed),
            },
            FieldInfoData {
                name: "CombatSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, combat_speed),
            },
            FieldInfoData {
                name: "AllowFireWhileFollowing",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleCombatEntityData, allow_fire_while_following),
            },
        ],
    }),
    array_type: Some(AIVEHICLECOMBATENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIVehicleCombatEntityData {
    fn type_info() -> &'static TypeInfo {
        AIVEHICLECOMBATENTITYDATA_TYPE_INFO
    }
}


pub const AIVEHICLECOMBATENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleCombatEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIVehicleCombatEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VehicleCombatSettings {
    pub use_simple_behavior: bool,
    pub distances: Distances,
    pub never_lose_interest_distance: f32,
    pub lose_interest_time: f32,
    pub sixth_sense_radius: f32,
    pub forget_target_distance: f32,
    pub interrupt_on_damage: bool,
    pub stop_and_fire_timeout: f32,
    pub move_timeout: f32,
    pub combat_settings: CombatSettings,
    pub evade_settings: EvadeSettings,
    pub vehicle_vs_vehicle: VehicleVsVehicle,
    pub vehicle_vs_soldier: VehicleVsSoldier,
    pub turn_to_align_weapons: bool,
}

pub const VEHICLECOMBATSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCombatSettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "UseSimpleBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, use_simple_behavior),
            },
            FieldInfoData {
                name: "Distances",
                flags: MemberInfoFlags::new(0),
                field_type: DISTANCES_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, distances),
            },
            FieldInfoData {
                name: "NeverLoseInterestDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, never_lose_interest_distance),
            },
            FieldInfoData {
                name: "LoseInterestTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, lose_interest_time),
            },
            FieldInfoData {
                name: "SixthSenseRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, sixth_sense_radius),
            },
            FieldInfoData {
                name: "ForgetTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, forget_target_distance),
            },
            FieldInfoData {
                name: "InterruptOnDamage",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, interrupt_on_damage),
            },
            FieldInfoData {
                name: "StopAndFireTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, stop_and_fire_timeout),
            },
            FieldInfoData {
                name: "MoveTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, move_timeout),
            },
            FieldInfoData {
                name: "CombatSettings",
                flags: MemberInfoFlags::new(0),
                field_type: COMBATSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, combat_settings),
            },
            FieldInfoData {
                name: "EvadeSettings",
                flags: MemberInfoFlags::new(0),
                field_type: EVADESETTINGS_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, evade_settings),
            },
            FieldInfoData {
                name: "VehicleVsVehicle",
                flags: MemberInfoFlags::new(0),
                field_type: VEHICLEVSVEHICLE_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, vehicle_vs_vehicle),
            },
            FieldInfoData {
                name: "VehicleVsSoldier",
                flags: MemberInfoFlags::new(0),
                field_type: VEHICLEVSSOLDIER_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, vehicle_vs_soldier),
            },
            FieldInfoData {
                name: "TurnToAlignWeapons",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VehicleCombatSettings, turn_to_align_weapons),
            },
        ],
    }),
    array_type: Some(VEHICLECOMBATSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VehicleCombatSettings {
    fn type_info() -> &'static TypeInfo {
        VEHICLECOMBATSETTINGS_TYPE_INFO
    }
}


pub const VEHICLECOMBATSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleCombatSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleCombatSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VehicleVsVehicle {
    pub distances: Distances,
    pub search_time: f32,
    pub keep_focus_while_searching_time: f32,
}

pub const VEHICLEVSVEHICLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVsVehicle",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Distances",
                flags: MemberInfoFlags::new(0),
                field_type: DISTANCES_TYPE_INFO,
                rust_offset: offset_of!(VehicleVsVehicle, distances),
            },
            FieldInfoData {
                name: "SearchTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleVsVehicle, search_time),
            },
            FieldInfoData {
                name: "KeepFocusWhileSearchingTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleVsVehicle, keep_focus_while_searching_time),
            },
        ],
    }),
    array_type: Some(VEHICLEVSVEHICLE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleVsVehicle {
    fn type_info() -> &'static TypeInfo {
        VEHICLEVSVEHICLE_TYPE_INFO
    }
}


pub const VEHICLEVSVEHICLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVsVehicle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleVsVehicle-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VehicleVsSoldier {
    pub distances: Distances,
    pub num_repositions: i32,
    pub flush_out_time: f32,
}

pub const VEHICLEVSSOLDIER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVsSoldier",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Distances",
                flags: MemberInfoFlags::new(0),
                field_type: DISTANCES_TYPE_INFO,
                rust_offset: offset_of!(VehicleVsSoldier, distances),
            },
            FieldInfoData {
                name: "NumRepositions",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleVsSoldier, num_repositions),
            },
            FieldInfoData {
                name: "FlushOutTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VehicleVsSoldier, flush_out_time),
            },
        ],
    }),
    array_type: Some(VEHICLEVSSOLDIER_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VehicleVsSoldier {
    fn type_info() -> &'static TypeInfo {
        VEHICLEVSSOLDIER_TYPE_INFO
    }
}


pub const VEHICLEVSSOLDIER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VehicleVsSoldier-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VehicleVsSoldier-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EvadeSettings {
    pub hold_evade_time: f32,
    pub max_evade_search_time: f32,
    pub iteration_count: i32,
    pub angle_step: f32,
    pub test_length: f32,
    pub straight_only: bool,
    pub evade_speed: f32,
}

pub const EVADESETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvadeSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "HoldEvadeTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeSettings, hold_evade_time),
            },
            FieldInfoData {
                name: "MaxEvadeSearchTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeSettings, max_evade_search_time),
            },
            FieldInfoData {
                name: "IterationCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeSettings, iteration_count),
            },
            FieldInfoData {
                name: "AngleStep",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeSettings, angle_step),
            },
            FieldInfoData {
                name: "TestLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeSettings, test_length),
            },
            FieldInfoData {
                name: "StraightOnly",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(EvadeSettings, straight_only),
            },
            FieldInfoData {
                name: "EvadeSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EvadeSettings, evade_speed),
            },
        ],
    }),
    array_type: Some(EVADESETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EvadeSettings {
    fn type_info() -> &'static TypeInfo {
        EVADESETTINGS_TYPE_INFO
    }
}


pub const EVADESETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EvadeSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EvadeSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CombatSettings {
    pub move_time: f32,
    pub update_time: f32,
    pub iteration_count: i32,
    pub angle_step: f32,
    pub test_length: f32,
    pub straight_only: bool,
}

pub const COMBATSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MoveTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatSettings, move_time),
            },
            FieldInfoData {
                name: "UpdateTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatSettings, update_time),
            },
            FieldInfoData {
                name: "IterationCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(CombatSettings, iteration_count),
            },
            FieldInfoData {
                name: "AngleStep",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatSettings, angle_step),
            },
            FieldInfoData {
                name: "TestLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CombatSettings, test_length),
            },
            FieldInfoData {
                name: "StraightOnly",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(CombatSettings, straight_only),
            },
        ],
    }),
    array_type: Some(COMBATSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for CombatSettings {
    fn type_info() -> &'static TypeInfo {
        COMBATSETTINGS_TYPE_INFO
    }
}


pub const COMBATSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CombatSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CombatSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct Distances {
    pub min: f32,
    pub max: f32,
}

pub const DISTANCES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Distances",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(Distances, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(Distances, max),
            },
        ],
    }),
    array_type: Some(DISTANCES_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for Distances {
    fn type_info() -> &'static TypeInfo {
        DISTANCES_TYPE_INFO
    }
}


pub const DISTANCES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Distances-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("Distances-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIVehicleAimingComponentData {
    pub weapon_rotation_world_transform: super::core::LinearTransform,
    pub weapon_pitch_local_offset: super::core::Vec3,
    pub pitch_constraints: AIVehicleAimingConstraints,
    pub yaw_constraints: AIVehicleAimingConstraints,
    pub use_target_position_override: bool,
    pub target_position_override: super::core::Vec3,
    pub lose_interest_time: f32,
    pub pitch_offset: f32,
    pub yaw_offset: f32,
    pub use_child_components: bool,
    pub pitch_velocity: f32,
    pub yaw_velocity: f32,
    pub max_pitch: f32,
    pub max_yaw: f32,
}

pub const AIVEHICLEAIMINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleAimingComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "WeaponRotationWorldTransform",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, weapon_rotation_world_transform),
            },
            FieldInfoData {
                name: "WeaponPitchLocalOffset",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, weapon_pitch_local_offset),
            },
            FieldInfoData {
                name: "PitchConstraints",
                flags: MemberInfoFlags::new(0),
                field_type: AIVEHICLEAIMINGCONSTRAINTS_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, pitch_constraints),
            },
            FieldInfoData {
                name: "YawConstraints",
                flags: MemberInfoFlags::new(0),
                field_type: AIVEHICLEAIMINGCONSTRAINTS_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, yaw_constraints),
            },
            FieldInfoData {
                name: "UseTargetPositionOverride",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, use_target_position_override),
            },
            FieldInfoData {
                name: "TargetPositionOverride",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, target_position_override),
            },
            FieldInfoData {
                name: "LoseInterestTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, lose_interest_time),
            },
            FieldInfoData {
                name: "PitchOffset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, pitch_offset),
            },
            FieldInfoData {
                name: "YawOffset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, yaw_offset),
            },
            FieldInfoData {
                name: "UseChildComponents",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, use_child_components),
            },
            FieldInfoData {
                name: "PitchVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, pitch_velocity),
            },
            FieldInfoData {
                name: "YawVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, yaw_velocity),
            },
            FieldInfoData {
                name: "MaxPitch",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, max_pitch),
            },
            FieldInfoData {
                name: "MaxYaw",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingComponentData, max_yaw),
            },
        ],
    }),
    array_type: Some(AIVEHICLEAIMINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIVehicleAimingComponentData {
    fn type_info() -> &'static TypeInfo {
        AIVEHICLEAIMINGCOMPONENTDATA_TYPE_INFO
    }
}


pub const AIVEHICLEAIMINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleAimingComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIVehicleAimingComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIVehicleAimingConstraints {
    pub min_angle: f32,
    pub max_angle: f32,
    pub offset: f32,
    pub max_delta: f32,
}

pub const AIVEHICLEAIMINGCONSTRAINTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleAimingConstraints",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "MinAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingConstraints, min_angle),
            },
            FieldInfoData {
                name: "MaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingConstraints, max_angle),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingConstraints, offset),
            },
            FieldInfoData {
                name: "MaxDelta",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIVehicleAimingConstraints, max_delta),
            },
        ],
    }),
    array_type: Some(AIVEHICLEAIMINGCONSTRAINTS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIVehicleAimingConstraints {
    fn type_info() -> &'static TypeInfo {
        AIVEHICLEAIMINGCONSTRAINTS_TYPE_INFO
    }
}


pub const AIVEHICLEAIMINGCONSTRAINTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIVehicleAimingConstraints-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIVehicleAimingConstraints-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIServerTargetComponentTeamChangedMessage {
}

pub const AISERVERTARGETCOMPONENTTEAMCHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIServerTargetComponentTeamChangedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIServerTargetComponentTeamChangedMessage {
    fn type_info() -> &'static TypeInfo {
        AISERVERTARGETCOMPONENTTEAMCHANGEDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIServerTargetComponentDestroyedMessage {
}

pub const AISERVERTARGETCOMPONENTDESTROYEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIServerTargetComponentDestroyedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIServerTargetComponentDestroyedMessage {
    fn type_info() -> &'static TypeInfo {
        AISERVERTARGETCOMPONENTDESTROYEDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIServerTargetComponentSpawnedMessage {
}

pub const AISERVERTARGETCOMPONENTSPAWNEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIServerTargetComponentSpawnedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIServerTargetComponentSpawnedMessage {
    fn type_info() -> &'static TypeInfo {
        AISERVERTARGETCOMPONENTSPAWNEDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Debug)]
pub struct AITargetComponentData {
    pub realm: super::core::Realm,
    pub register_as_target: bool,
    pub register_as_stand_alone: bool,
    pub stand_alone_team: super::gameplay_sim::TeamId,
    pub human_target_preference: f32,
    pub accept_immortal_target: bool,
    pub threat_distance_multiplier: f32,
    pub hit_box_distance_multiplier: f32,
    pub is_target: bool,
    pub book_area: bool,
    pub target_object_locomotion_sound: AISoundType,
}

pub const AITARGETCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, realm),
            },
            FieldInfoData {
                name: "RegisterAsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, register_as_target),
            },
            FieldInfoData {
                name: "RegisterAsStandAlone",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, register_as_stand_alone),
            },
            FieldInfoData {
                name: "StandAloneTeam",
                flags: MemberInfoFlags::new(0),
                field_type: TEAMID_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, stand_alone_team),
            },
            FieldInfoData {
                name: "HumanTargetPreference",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, human_target_preference),
            },
            FieldInfoData {
                name: "AcceptImmortalTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, accept_immortal_target),
            },
            FieldInfoData {
                name: "ThreatDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, threat_distance_multiplier),
            },
            FieldInfoData {
                name: "HitBoxDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, hit_box_distance_multiplier),
            },
            FieldInfoData {
                name: "IsTarget",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, is_target),
            },
            FieldInfoData {
                name: "BookArea",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, book_area),
            },
            FieldInfoData {
                name: "TargetObjectLocomotionSound",
                flags: MemberInfoFlags::new(0),
                field_type: AISOUNDTYPE_TYPE_INFO,
                rust_offset: offset_of!(AITargetComponentData, target_object_locomotion_sound),
            },
        ],
    }),
    array_type: Some(AITARGETCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AITargetComponentData {
    fn type_info() -> &'static TypeInfo {
        AITARGETCOMPONENTDATA_TYPE_INFO
    }
}


pub const AITARGETCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AITargetComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AITargetComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AISystemEntityData {
}

pub const AISYSTEMENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISystemEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AISYSTEMENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AISystemEntityData {
    fn type_info() -> &'static TypeInfo {
        AISYSTEMENTITYDATA_TYPE_INFO
    }
}


pub const AISYSTEMENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISystemEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISystemEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIPathfindingRepathRequiredMessage {
}

pub const AIPATHFINDINGREPATHREQUIREDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingRepathRequiredMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 16,
};

impl TypeObject for AIPathfindingRepathRequiredMessage {
    fn type_info() -> &'static TypeInfo {
        AIPATHFINDINGREPATHREQUIREDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIPathfindingPathfindersRegisteredMessage {
}

pub const AIPATHFINDINGPATHFINDERSREGISTEREDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingPathfindersRegisteredMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIPathfindingPathfindersRegisteredMessage {
    fn type_info() -> &'static TypeInfo {
        AIPATHFINDINGPATHFINDERSREGISTEREDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIPathfindingInitializedMessage {
}

pub const AIPATHFINDINGINITIALIZEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIPathfindingInitializedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AIPathfindingInitializedMessage {
    fn type_info() -> &'static TypeInfo {
        AIPATHFINDINGINITIALIZEDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct BattleAISettings {
    pub use_nav_power_fixed_heap: bool,
    pub nav_power_fixed_heap_size_kb: u32,
}

pub const BATTLEAISETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAISettings",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SYSTEMSETTINGS_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "UseNavPowerFixedHeap",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(BattleAISettings, use_nav_power_fixed_heap),
            },
            FieldInfoData {
                name: "NavPowerFixedHeapSizeKb",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(BattleAISettings, nav_power_fixed_heap_size_kb),
            },
        ],
    }),
    array_type: Some(BATTLEAISETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BattleAISettings {
    fn type_info() -> &'static TypeInfo {
        BATTLEAISETTINGS_TYPE_INFO
    }
}


pub const BATTLEAISETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAISettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAISettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BattleAISystemData {
    pub cover_constants: CoverConstantData,
    pub firing_pattern_collection: FiringPatternCollectionData,
    pub targeting: TargetingData,
    pub shooting: ShootingData,
    pub squad_engage_data: SquadEngageData,
    pub area_booking_settings: AreaBookingSettings,
    pub projectile_data: ProjectileData,
    pub alertness_data: AlertnessData,
    pub preferred_range: PreferredRange,
}

pub const BATTLEAISYSTEMDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAISystemData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMEAISYSTEM_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CoverConstants",
                flags: MemberInfoFlags::new(0),
                field_type: COVERCONSTANTDATA_TYPE_INFO,
                rust_offset: offset_of!(BattleAISystemData, cover_constants),
            },
            FieldInfoData {
                name: "FiringPatternCollection",
                flags: MemberInfoFlags::new(0),
                field_type: FIRINGPATTERNCOLLECTIONDATA_TYPE_INFO,
                rust_offset: offset_of!(BattleAISystemData, firing_pattern_collection),
            },
            FieldInfoData {
                name: "Targeting",
                flags: MemberInfoFlags::new(0),
                field_type: TARGETINGDATA_TYPE_INFO,
                rust_offset: offset_of!(BattleAISystemData, targeting),
            },
            FieldInfoData {
                name: "Shooting",
                flags: MemberInfoFlags::new(0),
                field_type: SHOOTINGDATA_TYPE_INFO,
                rust_offset: offset_of!(BattleAISystemData, shooting),
            },
            FieldInfoData {
                name: "SquadEngageData",
                flags: MemberInfoFlags::new(0),
                field_type: SQUADENGAGEDATA_TYPE_INFO,
                rust_offset: offset_of!(BattleAISystemData, squad_engage_data),
            },
            FieldInfoData {
                name: "AreaBookingSettings",
                flags: MemberInfoFlags::new(0),
                field_type: AREABOOKINGSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(BattleAISystemData, area_booking_settings),
            },
            FieldInfoData {
                name: "ProjectileData",
                flags: MemberInfoFlags::new(0),
                field_type: PROJECTILEDATA_TYPE_INFO,
                rust_offset: offset_of!(BattleAISystemData, projectile_data),
            },
            FieldInfoData {
                name: "AlertnessData",
                flags: MemberInfoFlags::new(0),
                field_type: ALERTNESSDATA_TYPE_INFO,
                rust_offset: offset_of!(BattleAISystemData, alertness_data),
            },
            FieldInfoData {
                name: "PreferredRange",
                flags: MemberInfoFlags::new(0),
                field_type: PREFERREDRANGE_TYPE_INFO,
                rust_offset: offset_of!(BattleAISystemData, preferred_range),
            },
        ],
    }),
    array_type: Some(BATTLEAISYSTEMDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BattleAISystemData {
    fn type_info() -> &'static TypeInfo {
        BATTLEAISYSTEMDATA_TYPE_INFO
    }
}


pub const BATTLEAISYSTEMDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BattleAISystemData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("BattleAISystemData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AlertnessData {
    pub enable_alertness_states: bool,
    pub enable_alert_by_suppression: bool,
}

pub const ALERTNESSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlertnessData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "EnableAlertnessStates",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AlertnessData, enable_alertness_states),
            },
            FieldInfoData {
                name: "EnableAlertBySuppression",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AlertnessData, enable_alert_by_suppression),
            },
        ],
    }),
    array_type: Some(ALERTNESSDATA_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AlertnessData {
    fn type_info() -> &'static TypeInfo {
        ALERTNESSDATA_TYPE_INFO
    }
}


pub const ALERTNESSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AlertnessData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AlertnessData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct ProjectileData {
    pub enable_flee_from_friendly_grenades: bool,
}

pub const PROJECTILEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProjectileData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "EnableFleeFromFriendlyGrenades",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ProjectileData, enable_flee_from_friendly_grenades),
            },
        ],
    }),
    array_type: Some(PROJECTILEDATA_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ProjectileData {
    fn type_info() -> &'static TypeInfo {
        PROJECTILEDATA_TYPE_INFO
    }
}


pub const PROJECTILEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProjectileData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ProjectileData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AreaBookingSettings {
    pub enemy_team_booking_radius: f32,
    pub friendly_team_booking_radius: f32,
    pub corpse_booking_time: f32,
}

pub const AREABOOKINGSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaBookingSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "EnemyTeamBookingRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AreaBookingSettings, enemy_team_booking_radius),
            },
            FieldInfoData {
                name: "FriendlyTeamBookingRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AreaBookingSettings, friendly_team_booking_radius),
            },
            FieldInfoData {
                name: "CorpseBookingTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AreaBookingSettings, corpse_booking_time),
            },
        ],
    }),
    array_type: Some(AREABOOKINGSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AreaBookingSettings {
    fn type_info() -> &'static TypeInfo {
        AREABOOKINGSETTINGS_TYPE_INFO
    }
}


pub const AREABOOKINGSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AreaBookingSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AreaBookingSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SquadEngageData {
    pub engage_time: f32,
    pub find_cover_time: f32,
    pub failure_cooldown_time: f32,
    pub cooldown_time: f32,
    pub secondary_target_radius: f32,
    pub cover_fire_target_radius: f32,
    pub allowed_target_hidden_time: f32,
    pub waiting_to_fire_time: f32,
    pub enable_a_i_record_system: bool,
}

pub const SQUADENGAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadEngageData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "EngageTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageData, engage_time),
            },
            FieldInfoData {
                name: "FindCoverTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageData, find_cover_time),
            },
            FieldInfoData {
                name: "FailureCooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageData, failure_cooldown_time),
            },
            FieldInfoData {
                name: "CooldownTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageData, cooldown_time),
            },
            FieldInfoData {
                name: "SecondaryTargetRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageData, secondary_target_radius),
            },
            FieldInfoData {
                name: "CoverFireTargetRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageData, cover_fire_target_radius),
            },
            FieldInfoData {
                name: "AllowedTargetHiddenTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageData, allowed_target_hidden_time),
            },
            FieldInfoData {
                name: "WaitingToFireTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageData, waiting_to_fire_time),
            },
            FieldInfoData {
                name: "EnableAIRecordSystem",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SquadEngageData, enable_a_i_record_system),
            },
        ],
    }),
    array_type: Some(SQUADENGAGEDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SquadEngageData {
    fn type_info() -> &'static TypeInfo {
        SQUADENGAGEDATA_TYPE_INFO
    }
}


pub const SQUADENGAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SquadEngageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SquadEngageData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ShootingData {
    pub keep_firing_at_player_time: f32,
    pub keep_firing_at_a_i_time: f32,
}

pub const SHOOTINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShootingData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "KeepFiringAtPlayerTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ShootingData, keep_firing_at_player_time),
            },
            FieldInfoData {
                name: "KeepFiringAtAITime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ShootingData, keep_firing_at_a_i_time),
            },
        ],
    }),
    array_type: Some(SHOOTINGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ShootingData {
    fn type_info() -> &'static TypeInfo {
        SHOOTINGDATA_TYPE_INFO
    }
}


pub const SHOOTINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ShootingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ShootingData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AISuppressWeaponFiringComponentData {
    pub radius: f32,
}

pub const AISUPPRESSWEAPONFIRINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISuppressWeaponFiringComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISuppressWeaponFiringComponentData, radius),
            },
        ],
    }),
    array_type: Some(AISUPPRESSWEAPONFIRINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AISuppressWeaponFiringComponentData {
    fn type_info() -> &'static TypeInfo {
        AISUPPRESSWEAPONFIRINGCOMPONENTDATA_TYPE_INFO
    }
}


pub const AISUPPRESSWEAPONFIRINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISuppressWeaponFiringComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISuppressWeaponFiringComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIGlobalEngageState {
    #[default]
    AIGlobalEngageState_Unavailable = 0,
    AIGlobalEngageState_Ready = 1,
    AIGlobalEngageState_Active = 2,
    AIGlobalEngageState_Cooldown = 3,
}

pub const AIGLOBALENGAGESTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIGlobalEngageState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIGLOBALENGAGESTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIGlobalEngageState {
    fn type_info() -> &'static TypeInfo {
        AIGLOBALENGAGESTATE_TYPE_INFO
    }
}


pub const AIGLOBALENGAGESTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIGlobalEngageState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIGlobalEngageState-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIStateEntityData {
}

pub const AISTATEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStateEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AISTATEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIStateEntityData {
    fn type_info() -> &'static TypeInfo {
        AISTATEENTITYDATA_TYPE_INFO
    }
}


pub const AISTATEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIStateEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIStateEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AISuppressionState {
    #[default]
    AISuppressionState_None = 0,
    AISuppressionState_Active = 1,
    AISuppressionState_Potential = 2,
    AISuppressionState_CoolDown = 3,
    AISuppressionState_Count = 4,
}

pub const AISUPPRESSIONSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISuppressionState",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AISUPPRESSIONSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AISuppressionState {
    fn type_info() -> &'static TypeInfo {
        AISUPPRESSIONSTATE_TYPE_INFO
    }
}


pub const AISUPPRESSIONSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISuppressionState-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISuppressionState-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AISpottingPotentialMessage {
}

pub const AISPOTTINGPOTENTIALMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpottingPotentialMessage",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AISpottingPotentialMessage {
    fn type_info() -> &'static TypeInfo {
        AISPOTTINGPOTENTIALMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AISpottingFoundMessage {
}

pub const AISPOTTINGFOUNDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpottingFoundMessage",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AISpottingFoundMessage {
    fn type_info() -> &'static TypeInfo {
        AISPOTTINGFOUNDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Debug)]
pub struct AISpottingComponentData {
    pub enabled: bool,
    pub spotting_fov: f32,
    pub spotting_distance: f32,
    pub visor_equip_hold_time: f32,
    pub visor_weapon_index: i32,
}

pub const AISPOTTINGCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpottingComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AISpottingComponentData, enabled),
            },
            FieldInfoData {
                name: "SpottingFov",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISpottingComponentData, spotting_fov),
            },
            FieldInfoData {
                name: "SpottingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISpottingComponentData, spotting_distance),
            },
            FieldInfoData {
                name: "VisorEquipHoldTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AISpottingComponentData, visor_equip_hold_time),
            },
            FieldInfoData {
                name: "VisorWeaponIndex",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AISpottingComponentData, visor_weapon_index),
            },
        ],
    }),
    array_type: Some(AISPOTTINGCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AISpottingComponentData {
    fn type_info() -> &'static TypeInfo {
        AISPOTTINGCOMPONENTDATA_TYPE_INFO
    }
}


pub const AISPOTTINGCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AISpottingComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AISpottingComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AILocoCompActionSignalMessage {
}

pub const AILOCOCOMPACTIONSIGNALMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCompActionSignalMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AILocoCompActionSignalMessage {
    fn type_info() -> &'static TypeInfo {
        AILOCOCOMPACTIONSIGNALMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AILocoCompExitAnimationMessage {
}

pub const AILOCOCOMPEXITANIMATIONMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCompExitAnimationMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AILocoCompExitAnimationMessage {
    fn type_info() -> &'static TypeInfo {
        AILOCOCOMPEXITANIMATIONMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AILocoCompEnterAnimationMessage {
}

pub const AILOCOCOMPENTERANIMATIONMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCompEnterAnimationMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for AILocoCompEnterAnimationMessage {
    fn type_info() -> &'static TypeInfo {
        AILOCOCOMPENTERANIMATIONMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Debug)]
pub struct AIWaypointsShapeData {
}

pub const AIWAYPOINTSSHAPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWaypointsShapeData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WAYPOINTSSHAPEDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AIWAYPOINTSSHAPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIWaypointsShapeData {
    fn type_info() -> &'static TypeInfo {
        AIWAYPOINTSSHAPEDATA_TYPE_INFO
    }
}


pub const AIWAYPOINTSSHAPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIWaypointsShapeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIWaypointsShapeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AILocoComponentData {
    pub binding: AILocoBinding,
    pub vault_binding: AILocoVaultBinding,
    pub cover_binding: AILocoCoverBinding,
    pub animation_entity_space_priority: i32,
    pub aim_with_fifa_loco: bool,
    pub fetch_target_from_comp: bool,
    pub canned_turns_check_distance: f32,
    pub wanted_yaw: f32,
    pub wanted_pitch: f32,
    pub facing_target_position: super::core::Vec3,
    pub enable_hover: bool,
}

pub const AILOCOCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Binding",
                flags: MemberInfoFlags::new(0),
                field_type: AILOCOBINDING_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, binding),
            },
            FieldInfoData {
                name: "VaultBinding",
                flags: MemberInfoFlags::new(0),
                field_type: AILOCOVAULTBINDING_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, vault_binding),
            },
            FieldInfoData {
                name: "CoverBinding",
                flags: MemberInfoFlags::new(0),
                field_type: AILOCOCOVERBINDING_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, cover_binding),
            },
            FieldInfoData {
                name: "AnimationEntitySpacePriority",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, animation_entity_space_priority),
            },
            FieldInfoData {
                name: "AimWithFifaLoco",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, aim_with_fifa_loco),
            },
            FieldInfoData {
                name: "FetchTargetFromComp",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, fetch_target_from_comp),
            },
            FieldInfoData {
                name: "CannedTurnsCheckDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, canned_turns_check_distance),
            },
            FieldInfoData {
                name: "WantedYaw",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, wanted_yaw),
            },
            FieldInfoData {
                name: "WantedPitch",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, wanted_pitch),
            },
            FieldInfoData {
                name: "FacingTargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, facing_target_position),
            },
            FieldInfoData {
                name: "EnableHover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoComponentData, enable_hover),
            },
        ],
    }),
    array_type: Some(AILOCOCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AILocoComponentData {
    fn type_info() -> &'static TypeInfo {
        AILOCOCOMPONENTDATA_TYPE_INFO
    }
}


pub const AILOCOCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct StandardMoveWaypointData {
    pub move_task: AILocoMoveTaskData,
}

pub const STANDARDMOVEWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StandardMoveWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MoveTask",
                flags: MemberInfoFlags::new(0),
                field_type: AILOCOMOVETASKDATA_TYPE_INFO,
                rust_offset: offset_of!(StandardMoveWaypointData, move_task),
            },
        ],
    }),
    array_type: Some(STANDARDMOVEWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for StandardMoveWaypointData {
    fn type_info() -> &'static TypeInfo {
        STANDARDMOVEWAYPOINTDATA_TYPE_INFO
    }
}


pub const STANDARDMOVEWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StandardMoveWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("StandardMoveWaypointData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VaultWaypointData {
    pub vault_task: AILocoVaultTaskData,
}

pub const VAULTWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "VaultTask",
                flags: MemberInfoFlags::new(0),
                field_type: AILOCOVAULTTASKDATA_TYPE_INFO,
                rust_offset: offset_of!(VaultWaypointData, vault_task),
            },
        ],
    }),
    array_type: Some(VAULTWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VaultWaypointData {
    fn type_info() -> &'static TypeInfo {
        VAULTWAYPOINTDATA_TYPE_INFO
    }
}


pub const VAULTWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VaultWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("VaultWaypointData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CoverWaypointData {
    pub cover_task: AILocoCoverTaskData,
}

pub const COVERWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CoverTask",
                flags: MemberInfoFlags::new(0),
                field_type: AILOCOCOVERTASKDATA_TYPE_INFO,
                rust_offset: offset_of!(CoverWaypointData, cover_task),
            },
        ],
    }),
    array_type: Some(COVERWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for CoverWaypointData {
    fn type_info() -> &'static TypeInfo {
        COVERWAYPOINTDATA_TYPE_INFO
    }
}


pub const COVERWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverWaypointData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ScenarioWaypointData {
    pub play_animation: super::game_shared::PlayAnimationData,
    pub scenario_ant_ref: super::ant::AntRef,
    pub scenario_task: ScenarioTaskData,
}

pub const SCENARIOWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "PlayAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: PLAYANIMATIONDATA_TYPE_INFO,
                rust_offset: offset_of!(ScenarioWaypointData, play_animation),
            },
            FieldInfoData {
                name: "ScenarioAntRef",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(ScenarioWaypointData, scenario_ant_ref),
            },
            FieldInfoData {
                name: "ScenarioTask",
                flags: MemberInfoFlags::new(0),
                field_type: SCENARIOTASKDATA_TYPE_INFO,
                rust_offset: offset_of!(ScenarioWaypointData, scenario_task),
            },
        ],
    }),
    array_type: Some(SCENARIOWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScenarioWaypointData {
    fn type_info() -> &'static TypeInfo {
        SCENARIOWAYPOINTDATA_TYPE_INFO
    }
}


pub const SCENARIOWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ScenarioWaypointData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AbstractLocoWaypointData {
    pub base_task: AILocoBaseTaskData,
}

pub const ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractLocoWaypointData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(WAYPOINTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "BaseTask",
                flags: MemberInfoFlags::new(0),
                field_type: AILOCOBASETASKDATA_TYPE_INFO,
                rust_offset: offset_of!(AbstractLocoWaypointData, base_task),
            },
        ],
    }),
    array_type: Some(ABSTRACTLOCOWAYPOINTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AbstractLocoWaypointData {
    fn type_info() -> &'static TypeInfo {
        ABSTRACTLOCOWAYPOINTDATA_TYPE_INFO
    }
}


pub const ABSTRACTLOCOWAYPOINTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AbstractLocoWaypointData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AbstractLocoWaypointData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ScenarioTaskData {
    pub play_animation: super::game_shared::PlayAnimationData,
    pub world_angle: f32,
    pub start_point: super::core::Vec3,
    pub scenario_id: i32,
    pub actor_id: i32,
    pub part_id: i32,
    pub level_id: i32,
    pub connect_transforms: Vec<super::core::LinearTransform>,
    pub end_point_world_offset: super::core::Vec3,
    pub trigger_scenario: bool,
    pub start_turn_distance: f32,
    pub start_timer_distance: f32,
    pub trigger_scenario_delay: f32,
    pub still_turn_precision: f32,
    pub use_client_position: bool,
    pub force_wait_for_animation: bool,
    pub overshoot_waypoint: bool,
    pub animation_guid: super::core::Guid,
    pub animation_is_looping: bool,
    pub animation_blend_in_time: f32,
    pub animation_blend_out_time: f32,
}

pub const SCENARIOTASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioTaskData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PlayAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: PLAYANIMATIONDATA_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, play_animation),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, world_angle),
            },
            FieldInfoData {
                name: "StartPoint",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, start_point),
            },
            FieldInfoData {
                name: "ScenarioId",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, scenario_id),
            },
            FieldInfoData {
                name: "ActorId",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, actor_id),
            },
            FieldInfoData {
                name: "PartId",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, part_id),
            },
            FieldInfoData {
                name: "LevelId",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, level_id),
            },
            FieldInfoData {
                name: "ConnectTransforms",
                flags: MemberInfoFlags::new(144),
                field_type: LINEARTRANSFORM_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, connect_transforms),
            },
            FieldInfoData {
                name: "EndPointWorldOffset",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, end_point_world_offset),
            },
            FieldInfoData {
                name: "TriggerScenario",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, trigger_scenario),
            },
            FieldInfoData {
                name: "StartTurnDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, start_turn_distance),
            },
            FieldInfoData {
                name: "StartTimerDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, start_timer_distance),
            },
            FieldInfoData {
                name: "TriggerScenarioDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, trigger_scenario_delay),
            },
            FieldInfoData {
                name: "StillTurnPrecision",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, still_turn_precision),
            },
            FieldInfoData {
                name: "UseClientPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, use_client_position),
            },
            FieldInfoData {
                name: "ForceWaitForAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, force_wait_for_animation),
            },
            FieldInfoData {
                name: "OvershootWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, overshoot_waypoint),
            },
            FieldInfoData {
                name: "AnimationGuid",
                flags: MemberInfoFlags::new(0),
                field_type: GUID_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, animation_guid),
            },
            FieldInfoData {
                name: "AnimationIsLooping",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, animation_is_looping),
            },
            FieldInfoData {
                name: "AnimationBlendInTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, animation_blend_in_time),
            },
            FieldInfoData {
                name: "AnimationBlendOutTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScenarioTaskData, animation_blend_out_time),
            },
        ],
    }),
    array_type: Some(SCENARIOTASKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ScenarioTaskData {
    fn type_info() -> &'static TypeInfo {
        SCENARIOTASKDATA_TYPE_INFO
    }
}


pub const SCENARIOTASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScenarioTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("ScenarioTaskData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AILocoCoverTaskData {
    pub cover_type: AntCoverEnum,
    pub cover_pose: AntPoseEnum,
    pub wait_time: f32,
    pub world_angle: f32,
    pub peek_out: CoverPeekType,
    pub idle_behavior: CoverIdleType,
    pub exit_pose: AntPoseEnum,
    pub offset_length: f32,
    pub enter_strategy: CoverEnterStrategy,
    pub exit_angle: f32,
    pub distance_to_next_waypoint: f32,
    pub wanted_pos: super::core::Vec3,
    pub extra_params: AIExtraCoverAnimationData,
    pub align_offset_along: f32,
    pub align_offset_perpendicular: f32,
    pub threat_position: super::core::Vec3,
    pub force_exit_cover: bool,
    pub exit_style: CoverExitStyle,
    pub prepare_fire_type: CoverFireType,
    pub use_client_position: bool,
    pub side_step_direction: CoverSideStepDirection,
    pub hover_direction: CoverHoverDirection,
}

pub const AILOCOCOVERTASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCoverTaskData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "CoverType",
                flags: MemberInfoFlags::new(0),
                field_type: ANTCOVERENUM_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, cover_type),
            },
            FieldInfoData {
                name: "CoverPose",
                flags: MemberInfoFlags::new(0),
                field_type: ANTPOSEENUM_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, cover_pose),
            },
            FieldInfoData {
                name: "WaitTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, wait_time),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, world_angle),
            },
            FieldInfoData {
                name: "PeekOut",
                flags: MemberInfoFlags::new(0),
                field_type: COVERPEEKTYPE_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, peek_out),
            },
            FieldInfoData {
                name: "IdleBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: COVERIDLETYPE_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, idle_behavior),
            },
            FieldInfoData {
                name: "ExitPose",
                flags: MemberInfoFlags::new(0),
                field_type: ANTPOSEENUM_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, exit_pose),
            },
            FieldInfoData {
                name: "OffsetLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, offset_length),
            },
            FieldInfoData {
                name: "EnterStrategy",
                flags: MemberInfoFlags::new(0),
                field_type: COVERENTERSTRATEGY_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, enter_strategy),
            },
            FieldInfoData {
                name: "ExitAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, exit_angle),
            },
            FieldInfoData {
                name: "DistanceToNextWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, distance_to_next_waypoint),
            },
            FieldInfoData {
                name: "WantedPos",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, wanted_pos),
            },
            FieldInfoData {
                name: "ExtraParams",
                flags: MemberInfoFlags::new(0),
                field_type: AIEXTRACOVERANIMATIONDATA_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, extra_params),
            },
            FieldInfoData {
                name: "AlignOffsetAlong",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, align_offset_along),
            },
            FieldInfoData {
                name: "AlignOffsetPerpendicular",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, align_offset_perpendicular),
            },
            FieldInfoData {
                name: "ThreatPosition",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, threat_position),
            },
            FieldInfoData {
                name: "ForceExitCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, force_exit_cover),
            },
            FieldInfoData {
                name: "ExitStyle",
                flags: MemberInfoFlags::new(0),
                field_type: COVEREXITSTYLE_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, exit_style),
            },
            FieldInfoData {
                name: "PrepareFireType",
                flags: MemberInfoFlags::new(0),
                field_type: COVERFIRETYPE_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, prepare_fire_type),
            },
            FieldInfoData {
                name: "UseClientPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, use_client_position),
            },
            FieldInfoData {
                name: "SideStepDirection",
                flags: MemberInfoFlags::new(0),
                field_type: COVERSIDESTEPDIRECTION_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, side_step_direction),
            },
            FieldInfoData {
                name: "HoverDirection",
                flags: MemberInfoFlags::new(0),
                field_type: COVERHOVERDIRECTION_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverTaskData, hover_direction),
            },
        ],
    }),
    array_type: Some(AILOCOCOVERTASKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AILocoCoverTaskData {
    fn type_info() -> &'static TypeInfo {
        AILOCOCOVERTASKDATA_TYPE_INFO
    }
}


pub const AILOCOCOVERTASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCoverTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoCoverTaskData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverSideStepFuturePose {
    #[default]
    CoverSideStepFuturePose_Stand = 0,
    CoverSideStepFuturePose_Crouch = 1,
}

pub const COVERSIDESTEPFUTUREPOSE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepFuturePose",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERSIDESTEPFUTUREPOSE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverSideStepFuturePose {
    fn type_info() -> &'static TypeInfo {
        COVERSIDESTEPFUTUREPOSE_TYPE_INFO
    }
}


pub const COVERSIDESTEPFUTUREPOSE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepFuturePose-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSideStepFuturePose-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverSideStepDirection {
    #[default]
    CoverSideStepDirection_None = 0,
    CoverSideStepDirection_Left_1m = 1,
    CoverSideStepDirection_Right_1m = 2,
    CoverSideStepDirection_Left_2m = 3,
    CoverSideStepDirection_Right_2m = 4,
    CoverSideStepDirection_Offset_Crouch = 5,
    CoverSideStepDirection_Left_1m_Crouch = 6,
    CoverSideStepDirection_Right_1m_Crouch = 7,
    CoverSideStepDirection_Left_2m_Crouch = 8,
    CoverSideStepDirection_Right_2m_Crouch = 9,
}

pub const COVERSIDESTEPDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepDirection",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERSIDESTEPDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverSideStepDirection {
    fn type_info() -> &'static TypeInfo {
        COVERSIDESTEPDIRECTION_TYPE_INFO
    }
}


pub const COVERSIDESTEPDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverSideStepDirection-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverSideStepDirection-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverHoverDirection {
    #[default]
    CoverHoverDirection_None = 0,
    CoverHoverDirection_Left = 1,
    CoverHoverDirection_Right = 2,
}

pub const COVERHOVERDIRECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverHoverDirection",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERHOVERDIRECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverHoverDirection {
    fn type_info() -> &'static TypeInfo {
        COVERHOVERDIRECTION_TYPE_INFO
    }
}


pub const COVERHOVERDIRECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverHoverDirection-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverHoverDirection-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIExtraCoverAnimationData {
    pub animation_time: f32,
    pub animation_height: f32,
}

pub const AIEXTRACOVERANIMATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIExtraCoverAnimationData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AnimationTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIExtraCoverAnimationData, animation_time),
            },
            FieldInfoData {
                name: "AnimationHeight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIExtraCoverAnimationData, animation_height),
            },
        ],
    }),
    array_type: Some(AIEXTRACOVERANIMATIONDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AIExtraCoverAnimationData {
    fn type_info() -> &'static TypeInfo {
        AIEXTRACOVERANIMATIONDATA_TYPE_INFO
    }
}


pub const AIEXTRACOVERANIMATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIExtraCoverAnimationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIExtraCoverAnimationData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverExitStyle {
    #[default]
    CoverExitStyle_ExitCover = 0,
    CoverExitStyle_VaultFromCrouchCover = 1,
    CoverExitStyle_StrafeFire = 2,
    CoverExitStyle_Surprised = 3,
    CoverExitStyle_Sprint = 4,
}

pub const COVEREXITSTYLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverExitStyle",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVEREXITSTYLE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverExitStyle {
    fn type_info() -> &'static TypeInfo {
        COVEREXITSTYLE_TYPE_INFO
    }
}


pub const COVEREXITSTYLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverExitStyle-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverExitStyle-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverEnterStrategy {
    #[default]
    CoverEnterStrategy_EnterNormally = 0,
    CoverEnterStrategy_SkipEnterButAlign = 1,
    CoverEnterStrategy_SkipEnterDontAlign = 2,
}

pub const COVERENTERSTRATEGY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverEnterStrategy",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERENTERSTRATEGY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverEnterStrategy {
    fn type_info() -> &'static TypeInfo {
        COVERENTERSTRATEGY_TYPE_INFO
    }
}


pub const COVERENTERSTRATEGY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverEnterStrategy-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverEnterStrategy-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverIdleType {
    #[default]
    CoverIdleType_Calm = 0,
    CoverIdleType_SearchForEnemy = 1,
    CoverIdleType_PeekOut = 2,
    CoverIdleType_PeekOver = 3,
    CoverIdleType_UnderFire = 4,
    CoverIdleType_Suppressed = 5,
}

pub const COVERIDLETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverIdleType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERIDLETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverIdleType {
    fn type_info() -> &'static TypeInfo {
        COVERIDLETYPE_TYPE_INFO
    }
}


pub const COVERIDLETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverIdleType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverIdleType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverPeekType {
    #[default]
    CoverPeekType_Out = 0,
    CoverPeekType_Over = 1,
    CoverPeekType_None = 2,
}

pub const COVERPEEKTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPeekType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERPEEKTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverPeekType {
    fn type_info() -> &'static TypeInfo {
        COVERPEEKTYPE_TYPE_INFO
    }
}


pub const COVERPEEKTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverPeekType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverPeekType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AntCoverFireType {
    #[default]
    AntCoverFireType_PeekFire = 0,
    AntCoverFireType_FireStepOut = 1,
    AntCoverFireType_FireOver = 2,
    AntCoverFireType_BlindFireAround = 3,
    AntCoverFireType_BlindFireOver = 4,
    AntCoverFireType_FlankedWhileFiring = 8,
    AntCoverFireType_FireStepOutSlow = 10,
    AntCoverFireType_FireStepOutUrgent = 11,
    AntCoverFireType_FireStepOut_Crouched = 12,
    AntCoverFireType_FireLmg = 13,
    AntCoverFireType_FireFromHipStepOut = 14,
}

pub const ANTCOVERFIRETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntCoverFireType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTCOVERFIRETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntCoverFireType {
    fn type_info() -> &'static TypeInfo {
        ANTCOVERFIRETYPE_TYPE_INFO
    }
}


pub const ANTCOVERFIRETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntCoverFireType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntCoverFireType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CoverFireType {
    #[default]
    CoverFireType_NoFire = 7,
    CoverFireType_Peek = 0,
    CoverFireType_Out = 1,
    CoverFireType_Over = 2,
    CoverFireType_BlindOut = 3,
    CoverFireType_BlindOver = 4,
    CoverFireType_GrenadeOut = 5,
    CoverFireType_GrenadeBlindOver = 6,
    CoverFireType_Flanked = 8,
    CoverFireType_OutSlow = 10,
    CoverFireType_OutUrgent = 11,
    CoverFireType_OutStandToCrouch = 12,
    CoverFireType_Lmg = 13,
    CoverFireType_OutFireFromHip = 14,
    CoverFireType_FlankedSurprised = 15,
    CoverFireType_Hover = 16,
}

pub const COVERFIRETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverFireType",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(COVERFIRETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CoverFireType {
    fn type_info() -> &'static TypeInfo {
        COVERFIRETYPE_TYPE_INFO
    }
}


pub const COVERFIRETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CoverFireType-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("CoverFireType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AILocoBaseTaskData {
    pub pose_change_moving_towards: AntPoseEnum,
    pub attention_change_moving_towards: AntAttentionStateEnum,
    pub speed_change_moving_towards: AntSpeedLevel,
    pub pose_change: AntPoseEnum,
    pub attention_state_change: AntAttentionStateEnum,
    pub speed_level_change: AntSpeedLevel,
    pub is_scripted: bool,
    pub disable_canned_turn_by_environment: bool,
    pub radius: f32,
}

pub const AILOCOBASETASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoBaseTaskData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PoseChangeMovingTowards",
                flags: MemberInfoFlags::new(0),
                field_type: ANTPOSEENUM_TYPE_INFO,
                rust_offset: offset_of!(AILocoBaseTaskData, pose_change_moving_towards),
            },
            FieldInfoData {
                name: "AttentionChangeMovingTowards",
                flags: MemberInfoFlags::new(0),
                field_type: ANTATTENTIONSTATEENUM_TYPE_INFO,
                rust_offset: offset_of!(AILocoBaseTaskData, attention_change_moving_towards),
            },
            FieldInfoData {
                name: "SpeedChangeMovingTowards",
                flags: MemberInfoFlags::new(0),
                field_type: ANTSPEEDLEVEL_TYPE_INFO,
                rust_offset: offset_of!(AILocoBaseTaskData, speed_change_moving_towards),
            },
            FieldInfoData {
                name: "PoseChange",
                flags: MemberInfoFlags::new(0),
                field_type: ANTPOSEENUM_TYPE_INFO,
                rust_offset: offset_of!(AILocoBaseTaskData, pose_change),
            },
            FieldInfoData {
                name: "AttentionStateChange",
                flags: MemberInfoFlags::new(0),
                field_type: ANTATTENTIONSTATEENUM_TYPE_INFO,
                rust_offset: offset_of!(AILocoBaseTaskData, attention_state_change),
            },
            FieldInfoData {
                name: "SpeedLevelChange",
                flags: MemberInfoFlags::new(0),
                field_type: ANTSPEEDLEVEL_TYPE_INFO,
                rust_offset: offset_of!(AILocoBaseTaskData, speed_level_change),
            },
            FieldInfoData {
                name: "IsScripted",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoBaseTaskData, is_scripted),
            },
            FieldInfoData {
                name: "DisableCannedTurnByEnvironment",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoBaseTaskData, disable_canned_turn_by_environment),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoBaseTaskData, radius),
            },
        ],
    }),
    array_type: Some(AILOCOBASETASKDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AILocoBaseTaskData {
    fn type_info() -> &'static TypeInfo {
        AILOCOBASETASKDATA_TYPE_INFO
    }
}


pub const AILOCOBASETASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoBaseTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoBaseTaskData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AILocoMoveTaskData {
    pub wait_time: f32,
    pub world_angle: f32,
    pub override_angle: bool,
    pub still_turn_precision: f32,
    pub enter_pose: AntPoseEnum,
    pub exit_pose: AntPoseEnum,
    pub wanted_pos: super::core::Vec3,
    pub use_client_position: bool,
    pub only_signal_almost_finished_when_moving_towards_waypoint: bool,
    pub almost_finished_distance: f32,
    pub align_to_end: bool,
}

pub const AILOCOMOVETASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoMoveTaskData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "WaitTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, wait_time),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, world_angle),
            },
            FieldInfoData {
                name: "OverrideAngle",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, override_angle),
            },
            FieldInfoData {
                name: "StillTurnPrecision",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, still_turn_precision),
            },
            FieldInfoData {
                name: "EnterPose",
                flags: MemberInfoFlags::new(0),
                field_type: ANTPOSEENUM_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, enter_pose),
            },
            FieldInfoData {
                name: "ExitPose",
                flags: MemberInfoFlags::new(0),
                field_type: ANTPOSEENUM_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, exit_pose),
            },
            FieldInfoData {
                name: "WantedPos",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, wanted_pos),
            },
            FieldInfoData {
                name: "UseClientPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, use_client_position),
            },
            FieldInfoData {
                name: "OnlySignalAlmostFinishedWhenMovingTowardsWaypoint",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, only_signal_almost_finished_when_moving_towards_waypoint),
            },
            FieldInfoData {
                name: "AlmostFinishedDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, almost_finished_distance),
            },
            FieldInfoData {
                name: "AlignToEnd",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoMoveTaskData, align_to_end),
            },
        ],
    }),
    array_type: Some(AILOCOMOVETASKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AILocoMoveTaskData {
    fn type_info() -> &'static TypeInfo {
        AILOCOMOVETASKDATA_TYPE_INFO
    }
}


pub const AILOCOMOVETASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoMoveTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoMoveTaskData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AILocoVaultTaskData {
    pub distance_before_vault: f32,
    pub height_before_vault: f32,
    pub length_of_vaultable_object: f32,
    pub height_after_vault: f32,
    pub distance_after_vault: f32,
    pub world_angle: f32,
    pub start_point: super::core::Vec3,
    pub use_client_position: bool,
    pub vault_type: super::ant::WaypointVaultType,
}

pub const AILOCOVAULTTASKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoVaultTaskData",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "DistanceBeforeVault",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultTaskData, distance_before_vault),
            },
            FieldInfoData {
                name: "HeightBeforeVault",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultTaskData, height_before_vault),
            },
            FieldInfoData {
                name: "LengthOfVaultableObject",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultTaskData, length_of_vaultable_object),
            },
            FieldInfoData {
                name: "HeightAfterVault",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultTaskData, height_after_vault),
            },
            FieldInfoData {
                name: "DistanceAfterVault",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultTaskData, distance_after_vault),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultTaskData, world_angle),
            },
            FieldInfoData {
                name: "StartPoint",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultTaskData, start_point),
            },
            FieldInfoData {
                name: "UseClientPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultTaskData, use_client_position),
            },
            FieldInfoData {
                name: "VaultType",
                flags: MemberInfoFlags::new(0),
                field_type: WAYPOINTVAULTTYPE_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultTaskData, vault_type),
            },
        ],
    }),
    array_type: Some(AILOCOVAULTTASKDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AILocoVaultTaskData {
    fn type_info() -> &'static TypeInfo {
        AILOCOVAULTTASKDATA_TYPE_INFO
    }
}


pub const AILOCOVAULTTASKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoVaultTaskData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoVaultTaskData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AntSpeedLevel {
    #[default]
    AntSpeedLevel_Still = 0,
    AntSpeedLevel_Walk = 1,
    AntSpeedLevel_Jog = 2,
    AntSpeedLevel_Sneak = 3,
    AntSpeedLevel_Run = 4,
    AntSpeedLevel_Sprint = 5,
    AntSpeedLevel_Stairs_Walk_Up = 6,
    AntSpeedLevel_Stairs_Walk_Down = 7,
    AntSpeedLevel_Stairs_Run_Up = 8,
    AntSpeedLevel_Stairs_Run_Down = 9,
    AntSpeedLevel_Stairs_Sprint_Up = 10,
    AntSpeedLevel_Stairs_Sprint_Down = 11,
    AntSpeedLevel_AntEnumCount = 12,
    AntSpeedLevel_NoChange = 13,
    AntSpeedLevel_Count = 14,
}

pub const ANTSPEEDLEVEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntSpeedLevel",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTSPEEDLEVEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntSpeedLevel {
    fn type_info() -> &'static TypeInfo {
        ANTSPEEDLEVEL_TYPE_INFO
    }
}


pub const ANTSPEEDLEVEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntSpeedLevel-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntSpeedLevel-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AntAttentionStateEnum {
    #[default]
    AntAttentionStateEnum_Patrol = 0,
    AntAttentionStateEnum_Ready = 1,
    AntAttentionStateEnum_Combat = 2,
    AntAttentionStateEnum_Evasive = 3,
    AntAttentionStateEnum_AntEnumCount = 4,
    AntAttentionStateEnum_NoChange = 5,
    AntAttentionStateEnum_Count = 6,
    AntAttentionStateEnum_Dummy1 = 7,
}

pub const ANTATTENTIONSTATEENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntAttentionStateEnum",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTATTENTIONSTATEENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntAttentionStateEnum {
    fn type_info() -> &'static TypeInfo {
        ANTATTENTIONSTATEENUM_TYPE_INFO
    }
}


pub const ANTATTENTIONSTATEENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntAttentionStateEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntAttentionStateEnum-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AntCoverEnum {
    #[default]
    AntCoverEnum_RightCover = 0,
    AntCoverEnum_LeftCover = 1,
    AntCoverEnum_MiddleCover = 2,
    AntCoverEnum_MediumLeftCover = 3,
    AntCoverEnum_MediumRightCover = 4,
    AntCoverEnum_Prone = 5,
    AntCoverEnum_OpenCover = 6,
    AntCoverEnum_Count = 7,
}

pub const ANTCOVERENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntCoverEnum",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTCOVERENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntCoverEnum {
    fn type_info() -> &'static TypeInfo {
        ANTCOVERENUM_TYPE_INFO
    }
}


pub const ANTCOVERENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntCoverEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntCoverEnum-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AntPoseEnum {
    #[default]
    AntPoseEnum_Stand = 0,
    AntPoseEnum_Crouch = 1,
    AntPoseEnum_AntEnumCount = 2,
    AntPoseEnum_NoChange = 3,
    AntPoseEnum_Count = 4,
}

pub const ANTPOSEENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntPoseEnum",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(ANTPOSEENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AntPoseEnum {
    fn type_info() -> &'static TypeInfo {
        ANTPOSEENUM_TYPE_INFO
    }
}


pub const ANTPOSEENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AntPoseEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AntPoseEnum-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AILocoCoverBinding {
    pub prepare_fire: super::ant::AntRef,
    pub prepare_changed_to_true: super::ant::AntRef,
    pub throw_grenade: super::ant::AntRef,
    pub peek_out: super::ant::AntRef,
    pub idle_behind_cover: super::ant::AntRef,
    pub peek_type: super::ant::AntRef,
    pub idle_type_previous: super::ant::AntRef,
    pub idle_type: super::ant::AntRef,
    pub idle_type_changed: super::ant::AntRef,
    pub cover_type_enum: super::ant::AntRef,
    pub cover_fire_style: super::ant::AntRef,
    pub enter_cover: super::ant::AntRef,
    pub exit_cover: super::ant::AntRef,
    pub cover_distance_small: super::ant::AntRef,
    pub cover_distance_medium: super::ant::AntRef,
    pub distance_scale: super::ant::AntRef,
    pub absolute_distance: super::ant::AntRef,
    pub angle_to_normal: super::ant::AntRef,
    pub direction_to_cover_vs_a_i_trajectory: super::ant::AntRef,
    pub cover_normal_vs_a_i_trajectory: super::ant::AntRef,
    pub out_angle: super::ant::AntRef,
    pub exit_cover_distance: super::ant::AntRef,
    pub threat_angle: super::ant::AntRef,
    pub stop_exit_cover_out_around: super::ant::AntRef,
    pub enter_strategy: super::ant::AntRef,
    pub exit_style: super::ant::AntRef,
    pub cover_hover_animation_blocked: super::ant::AntRef,
    pub cover_enable_hover: super::ant::AntRef,
    pub cover_hover_height: super::ant::AntRef,
    pub cover_hover_left: super::ant::AntRef,
    pub cover_hover_right: super::ant::AntRef,
    pub cover_hover_in_sidefly: super::ant::AntRef,
    pub cover_hover_done: super::ant::AntRef,
    pub trigger_step: super::ant::AntRef,
    pub is_stepping: super::ant::AntRef,
    pub side_step_direction: super::ant::AntRef,
    pub side_step_future_pose: super::ant::AntRef,
}

pub const AILOCOCOVERBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCoverBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PrepareFire",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, prepare_fire),
            },
            FieldInfoData {
                name: "PrepareChangedToTrue",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, prepare_changed_to_true),
            },
            FieldInfoData {
                name: "ThrowGrenade",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, throw_grenade),
            },
            FieldInfoData {
                name: "PeekOut",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, peek_out),
            },
            FieldInfoData {
                name: "IdleBehindCover",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, idle_behind_cover),
            },
            FieldInfoData {
                name: "PeekType",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, peek_type),
            },
            FieldInfoData {
                name: "IdleTypePrevious",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, idle_type_previous),
            },
            FieldInfoData {
                name: "IdleType",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, idle_type),
            },
            FieldInfoData {
                name: "IdleTypeChanged",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, idle_type_changed),
            },
            FieldInfoData {
                name: "CoverTypeEnum",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_type_enum),
            },
            FieldInfoData {
                name: "CoverFireStyle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_fire_style),
            },
            FieldInfoData {
                name: "EnterCover",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, enter_cover),
            },
            FieldInfoData {
                name: "ExitCover",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, exit_cover),
            },
            FieldInfoData {
                name: "CoverDistanceSmall",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_distance_small),
            },
            FieldInfoData {
                name: "CoverDistanceMedium",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_distance_medium),
            },
            FieldInfoData {
                name: "DistanceScale",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, distance_scale),
            },
            FieldInfoData {
                name: "AbsoluteDistance",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, absolute_distance),
            },
            FieldInfoData {
                name: "AngleToNormal",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, angle_to_normal),
            },
            FieldInfoData {
                name: "DirectionToCoverVsAITrajectory",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, direction_to_cover_vs_a_i_trajectory),
            },
            FieldInfoData {
                name: "CoverNormalVsAITrajectory",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_normal_vs_a_i_trajectory),
            },
            FieldInfoData {
                name: "OutAngle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, out_angle),
            },
            FieldInfoData {
                name: "ExitCoverDistance",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, exit_cover_distance),
            },
            FieldInfoData {
                name: "ThreatAngle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, threat_angle),
            },
            FieldInfoData {
                name: "StopExitCoverOutAround",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, stop_exit_cover_out_around),
            },
            FieldInfoData {
                name: "EnterStrategy",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, enter_strategy),
            },
            FieldInfoData {
                name: "ExitStyle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, exit_style),
            },
            FieldInfoData {
                name: "CoverHoverAnimationBlocked",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_animation_blocked),
            },
            FieldInfoData {
                name: "CoverEnableHover",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_enable_hover),
            },
            FieldInfoData {
                name: "CoverHoverHeight",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_height),
            },
            FieldInfoData {
                name: "CoverHoverLeft",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_left),
            },
            FieldInfoData {
                name: "CoverHoverRight",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_right),
            },
            FieldInfoData {
                name: "CoverHoverInSidefly",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_in_sidefly),
            },
            FieldInfoData {
                name: "CoverHoverDone",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, cover_hover_done),
            },
            FieldInfoData {
                name: "TriggerStep",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, trigger_step),
            },
            FieldInfoData {
                name: "IsStepping",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, is_stepping),
            },
            FieldInfoData {
                name: "SideStepDirection",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, side_step_direction),
            },
            FieldInfoData {
                name: "SideStepFuturePose",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoCoverBinding, side_step_future_pose),
            },
        ],
    }),
    array_type: Some(AILOCOCOVERBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AILocoCoverBinding {
    fn type_info() -> &'static TypeInfo {
        AILOCOCOVERBINDING_TYPE_INFO
    }
}


pub const AILOCOCOVERBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoCoverBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoCoverBinding-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AILocoVaultBinding {
    pub vault: super::ant::AntRef,
    pub distance_before_vault: super::ant::AntRef,
    pub height_before_vault: super::ant::AntRef,
    pub length_of_vaultable_object: super::ant::AntRef,
    pub height_after_vault: super::ant::AntRef,
    pub distance_after_vault: super::ant::AntRef,
    pub vault_type: super::ant::AntRef,
}

pub const AILOCOVAULTBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoVaultBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Vault",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultBinding, vault),
            },
            FieldInfoData {
                name: "DistanceBeforeVault",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultBinding, distance_before_vault),
            },
            FieldInfoData {
                name: "HeightBeforeVault",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultBinding, height_before_vault),
            },
            FieldInfoData {
                name: "LengthOfVaultableObject",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultBinding, length_of_vaultable_object),
            },
            FieldInfoData {
                name: "HeightAfterVault",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultBinding, height_after_vault),
            },
            FieldInfoData {
                name: "DistanceAfterVault",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultBinding, distance_after_vault),
            },
            FieldInfoData {
                name: "VaultType",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoVaultBinding, vault_type),
            },
        ],
    }),
    array_type: Some(AILOCOVAULTBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AILocoVaultBinding {
    fn type_info() -> &'static TypeInfo {
        AILOCOVAULTBINDING_TYPE_INFO
    }
}


pub const AILOCOVAULTBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoVaultBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoVaultBinding-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AILocoBinding {
    pub loco_target: super::ant::AntRef,
    pub attention_state: super::ant::AntRef,
    pub no_initial_combat_reaction: super::ant::AntRef,
    pub end_pose_enum: super::ant::AntRef,
    pub current_pose_enum: super::ant::AntRef,
    pub enter_exit_pose_enum: super::ant::AntRef,
    pub run_style: super::ant::AntRef,
    pub target_waypoint_position: super::ant::AntRef,
    pub target_waypoint_radius: super::ant::AntRef,
    pub target_speed_level: super::ant::AntRef,
    pub cruise_speed_level: super::ant::AntRef,
    pub enable_procedural_head_aim: super::ant::AntRef,
    pub a_i_action: super::ant::AntRef,
    pub force_relative_aim_turn: super::ant::AntRef,
    pub force_relative_aim_turn_angle: super::ant::AntRef,
    pub stopping: super::ant::AntRef,
    pub enemy_target_distance: super::ant::AntRef,
}

pub const AILOCOBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "LocoTarget",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, loco_target),
            },
            FieldInfoData {
                name: "AttentionState",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, attention_state),
            },
            FieldInfoData {
                name: "NoInitialCombatReaction",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, no_initial_combat_reaction),
            },
            FieldInfoData {
                name: "EndPoseEnum",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, end_pose_enum),
            },
            FieldInfoData {
                name: "CurrentPoseEnum",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, current_pose_enum),
            },
            FieldInfoData {
                name: "EnterExitPoseEnum",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, enter_exit_pose_enum),
            },
            FieldInfoData {
                name: "RunStyle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, run_style),
            },
            FieldInfoData {
                name: "TargetWaypointPosition",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, target_waypoint_position),
            },
            FieldInfoData {
                name: "TargetWaypointRadius",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, target_waypoint_radius),
            },
            FieldInfoData {
                name: "TargetSpeedLevel",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, target_speed_level),
            },
            FieldInfoData {
                name: "CruiseSpeedLevel",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, cruise_speed_level),
            },
            FieldInfoData {
                name: "EnableProceduralHeadAim",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, enable_procedural_head_aim),
            },
            FieldInfoData {
                name: "AIAction",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, a_i_action),
            },
            FieldInfoData {
                name: "ForceRelativeAimTurn",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, force_relative_aim_turn),
            },
            FieldInfoData {
                name: "ForceRelativeAimTurnAngle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, force_relative_aim_turn_angle),
            },
            FieldInfoData {
                name: "Stopping",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, stopping),
            },
            FieldInfoData {
                name: "EnemyTargetDistance",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AILocoBinding, enemy_target_distance),
            },
        ],
    }),
    array_type: Some(AILOCOBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AILocoBinding {
    fn type_info() -> &'static TypeInfo {
        AILOCOBINDING_TYPE_INFO
    }
}


pub const AILOCOBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AILocoBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AILocoBinding-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIKillCounterEntityData {
    pub alive_threshold: i32,
    pub run_once: bool,
}

pub const AIKILLCOUNTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIKillCounterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AliveThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AIKillCounterEntityData, alive_threshold),
            },
            FieldInfoData {
                name: "RunOnce",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIKillCounterEntityData, run_once),
            },
        ],
    }),
    array_type: Some(AIKILLCOUNTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIKillCounterEntityData {
    fn type_info() -> &'static TypeInfo {
        AIKILLCOUNTERENTITYDATA_TYPE_INFO
    }
}


pub const AIKILLCOUNTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIKillCounterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIKillCounterEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIEntryComponentData {
    pub target_position_override: super::core::Vec3,
    pub hold_fire: bool,
    pub allow_grenades: bool,
    pub send_fire_events: bool,
    pub force_press_fire: bool,
    pub suppression: f32,
    pub allow_occupant: bool,
    pub target_approach_max_angle: f32,
    pub target_approach_min_velocity: f32,
    pub friendly_player_max_distance: f32,
    pub enemy_player_max_distance: f32,
    pub enemy_player_forward_cone_max_angle: f32,
    pub enemy_player_forward_cone_max_distance: f32,
    pub is_in_player_frustum_check_interval: f32,
}

pub const AIENTRYCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIEntryComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "TargetPositionOverride",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, target_position_override),
            },
            FieldInfoData {
                name: "HoldFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, hold_fire),
            },
            FieldInfoData {
                name: "AllowGrenades",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, allow_grenades),
            },
            FieldInfoData {
                name: "SendFireEvents",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, send_fire_events),
            },
            FieldInfoData {
                name: "ForcePressFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, force_press_fire),
            },
            FieldInfoData {
                name: "Suppression",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, suppression),
            },
            FieldInfoData {
                name: "AllowOccupant",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, allow_occupant),
            },
            FieldInfoData {
                name: "TargetApproachMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, target_approach_max_angle),
            },
            FieldInfoData {
                name: "TargetApproachMinVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, target_approach_min_velocity),
            },
            FieldInfoData {
                name: "FriendlyPlayerMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, friendly_player_max_distance),
            },
            FieldInfoData {
                name: "EnemyPlayerMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, enemy_player_max_distance),
            },
            FieldInfoData {
                name: "EnemyPlayerForwardConeMaxAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, enemy_player_forward_cone_max_angle),
            },
            FieldInfoData {
                name: "EnemyPlayerForwardConeMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, enemy_player_forward_cone_max_distance),
            },
            FieldInfoData {
                name: "IsInPlayerFrustumCheckInterval",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIEntryComponentData, is_in_player_frustum_check_interval),
            },
        ],
    }),
    array_type: Some(AIENTRYCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIEntryComponentData {
    fn type_info() -> &'static TypeInfo {
        AIENTRYCOMPONENTDATA_TYPE_INFO
    }
}


pub const AIENTRYCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIEntryComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIEntryComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AIEncounterManagerEntityData {
    pub save_state: bool,
    pub encounters: Vec<EncounterConfig>,
    pub event_count: u32,
    pub condition_a: bool,
    pub condition_b: bool,
}

pub const AIENCOUNTERMANAGERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIEncounterManagerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SaveState",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIEncounterManagerEntityData, save_state),
            },
            FieldInfoData {
                name: "Encounters",
                flags: MemberInfoFlags::new(144),
                field_type: ENCOUNTERCONFIG_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIEncounterManagerEntityData, encounters),
            },
            FieldInfoData {
                name: "EventCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AIEncounterManagerEntityData, event_count),
            },
            FieldInfoData {
                name: "ConditionA",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIEncounterManagerEntityData, condition_a),
            },
            FieldInfoData {
                name: "ConditionB",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIEncounterManagerEntityData, condition_b),
            },
        ],
    }),
    array_type: Some(AIENCOUNTERMANAGERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIEncounterManagerEntityData {
    fn type_info() -> &'static TypeInfo {
        AIENCOUNTERMANAGERENTITYDATA_TYPE_INFO
    }
}


pub const AIENCOUNTERMANAGERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIEncounterManagerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIEncounterManagerEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct EncounterConfig {
    pub zones: Vec<EncounterZoneConfig>,
    pub max_engaging_count: u32,
    pub use_corridor_assignment: bool,
}

pub const ENCOUNTERCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EncounterConfig",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Zones",
                flags: MemberInfoFlags::new(144),
                field_type: ENCOUNTERZONECONFIG_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EncounterConfig, zones),
            },
            FieldInfoData {
                name: "MaxEngagingCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(EncounterConfig, max_engaging_count),
            },
            FieldInfoData {
                name: "UseCorridorAssignment",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(EncounterConfig, use_corridor_assignment),
            },
        ],
    }),
    array_type: Some(ENCOUNTERCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EncounterConfig {
    fn type_info() -> &'static TypeInfo {
        ENCOUNTERCONFIG_TYPE_INFO
    }
}


pub const ENCOUNTERCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EncounterConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EncounterConfig-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct EncounterZoneConfig {
    pub zone: u8,
    pub priority: u8,
    pub max_n_p_cs: u8,
    pub require_condition_a: bool,
    pub require_condition_b: bool,
    pub required_weapon1: super::soldier_shared::WeaponAnimBaseSetEnum,
    pub required_weapon2: super::soldier_shared::WeaponAnimBaseSetEnum,
    pub require_s_m_g: bool,
    pub prefer_cover: bool,
}

pub const ENCOUNTERZONECONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EncounterZoneConfig",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Zone",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(EncounterZoneConfig, zone),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(EncounterZoneConfig, priority),
            },
            FieldInfoData {
                name: "MaxNPCs",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(EncounterZoneConfig, max_n_p_cs),
            },
            FieldInfoData {
                name: "RequireConditionA",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(EncounterZoneConfig, require_condition_a),
            },
            FieldInfoData {
                name: "RequireConditionB",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(EncounterZoneConfig, require_condition_b),
            },
            FieldInfoData {
                name: "RequiredWeapon1",
                flags: MemberInfoFlags::new(0),
                field_type: WEAPONANIMBASESETENUM_TYPE_INFO,
                rust_offset: offset_of!(EncounterZoneConfig, required_weapon1),
            },
            FieldInfoData {
                name: "RequiredWeapon2",
                flags: MemberInfoFlags::new(0),
                field_type: WEAPONANIMBASESETENUM_TYPE_INFO,
                rust_offset: offset_of!(EncounterZoneConfig, required_weapon2),
            },
            FieldInfoData {
                name: "RequireSMG",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(EncounterZoneConfig, require_s_m_g),
            },
            FieldInfoData {
                name: "PreferCover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(EncounterZoneConfig, prefer_cover),
            },
        ],
    }),
    array_type: Some(ENCOUNTERZONECONFIG_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for EncounterZoneConfig {
    fn type_info() -> &'static TypeInfo {
        ENCOUNTERZONECONFIG_TYPE_INFO
    }
}


pub const ENCOUNTERZONECONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EncounterZoneConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("EncounterZoneConfig-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct ServerEncounterManagerRemovedMessage {
}

pub const SERVERENCOUNTERMANAGERREMOVEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ServerEncounterManagerRemovedMessage",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for ServerEncounterManagerRemovedMessage {
    fn type_info() -> &'static TypeInfo {
        SERVERENCOUNTERMANAGERREMOVEDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Debug)]
pub struct AIDynamicConcealmentComponentData {
    pub realm: super::core::Realm,
    pub volume_origin: DynamicConcealmentOrigin,
    pub condition: DynamicConcealmentCondition,
    pub bounding_box_x_size: f32,
    pub bounding_box_y_size: f32,
    pub bounding_box_z_size: f32,
}

pub const AIDYNAMICCONCEALMENTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDynamicConcealmentComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, realm),
            },
            FieldInfoData {
                name: "VolumeOrigin",
                flags: MemberInfoFlags::new(0),
                field_type: DYNAMICCONCEALMENTORIGIN_TYPE_INFO,
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, volume_origin),
            },
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(0),
                field_type: DYNAMICCONCEALMENTCONDITION_TYPE_INFO,
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, condition),
            },
            FieldInfoData {
                name: "BoundingBoxXSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, bounding_box_x_size),
            },
            FieldInfoData {
                name: "BoundingBoxYSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, bounding_box_y_size),
            },
            FieldInfoData {
                name: "BoundingBoxZSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIDynamicConcealmentComponentData, bounding_box_z_size),
            },
        ],
    }),
    array_type: Some(AIDYNAMICCONCEALMENTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIDynamicConcealmentComponentData {
    fn type_info() -> &'static TypeInfo {
        AIDYNAMICCONCEALMENTCOMPONENTDATA_TYPE_INFO
    }
}


pub const AIDYNAMICCONCEALMENTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDynamicConcealmentComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIDynamicConcealmentComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum DynamicConcealmentCondition {
    #[default]
    DynamicConcealmentCondition_Inside = 0,
    DynamicConcealmentCondition_InsideOrBehind = 1,
}

pub const DYNAMICCONCEALMENTCONDITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicConcealmentCondition",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(DYNAMICCONCEALMENTCONDITION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DynamicConcealmentCondition {
    fn type_info() -> &'static TypeInfo {
        DYNAMICCONCEALMENTCONDITION_TYPE_INFO
    }
}


pub const DYNAMICCONCEALMENTCONDITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicConcealmentCondition-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DynamicConcealmentCondition-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum DynamicConcealmentOrigin {
    #[default]
    DynamicConcealmentOrigin_Bottom = 0,
    DynamicConcealmentOrigin_Middle = 1,
}

pub const DYNAMICCONCEALMENTORIGIN_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicConcealmentOrigin",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(DYNAMICCONCEALMENTORIGIN_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DynamicConcealmentOrigin {
    fn type_info() -> &'static TypeInfo {
        DYNAMICCONCEALMENTORIGIN_TYPE_INFO
    }
}


pub const DYNAMICCONCEALMENTORIGIN_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DynamicConcealmentOrigin-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("DynamicConcealmentOrigin-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SimpleDriverComponentData {
    pub reach_waypoint_radius: f32,
    pub only_check_radius: bool,
    pub use_player_input: bool,
    pub player_input_in_world_space: bool,
    pub throttle_input_action: i32,
    pub strafe_input_action: i32,
    pub p_value: f32,
    pub i_value: f32,
    pub reference_point: super::core::Vec3,
    pub speed_multiplier: f32,
    pub use_animation: bool,
    pub use_channels: bool,
    pub driver_signals: SimpleDriverBinding,
    pub driver_channels: SimpleDriverChannelData,
    pub only_drive_forward: bool,
}

pub const SIMPLEDRIVERCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ReachWaypointRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, reach_waypoint_radius),
            },
            FieldInfoData {
                name: "OnlyCheckRadius",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, only_check_radius),
            },
            FieldInfoData {
                name: "UsePlayerInput",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, use_player_input),
            },
            FieldInfoData {
                name: "PlayerInputInWorldSpace",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, player_input_in_world_space),
            },
            FieldInfoData {
                name: "ThrottleInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, throttle_input_action),
            },
            FieldInfoData {
                name: "StrafeInputAction",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, strafe_input_action),
            },
            FieldInfoData {
                name: "PValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, p_value),
            },
            FieldInfoData {
                name: "IValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, i_value),
            },
            FieldInfoData {
                name: "ReferencePoint",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, reference_point),
            },
            FieldInfoData {
                name: "SpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, speed_multiplier),
            },
            FieldInfoData {
                name: "UseAnimation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, use_animation),
            },
            FieldInfoData {
                name: "UseChannels",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, use_channels),
            },
            FieldInfoData {
                name: "DriverSignals",
                flags: MemberInfoFlags::new(0),
                field_type: SIMPLEDRIVERBINDING_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, driver_signals),
            },
            FieldInfoData {
                name: "DriverChannels",
                flags: MemberInfoFlags::new(0),
                field_type: SIMPLEDRIVERCHANNELDATA_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, driver_channels),
            },
            FieldInfoData {
                name: "OnlyDriveForward",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverComponentData, only_drive_forward),
            },
        ],
    }),
    array_type: Some(SIMPLEDRIVERCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SimpleDriverComponentData {
    fn type_info() -> &'static TypeInfo {
        SIMPLEDRIVERCOMPONENTDATA_TYPE_INFO
    }
}


pub const SIMPLEDRIVERCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SimpleDriverComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SimpleDriverChannelData {
    pub fwd: super::soldier_shared::BoolChannelData,
    pub bwd: super::soldier_shared::BoolChannelData,
    pub left: super::soldier_shared::BoolChannelData,
    pub right: super::soldier_shared::BoolChannelData,
    pub moving: super::soldier_shared::BoolChannelData,
    pub angle: super::soldier_shared::FloatChannelData,
    pub speed_multiplier: super::soldier_shared::FloatChannelData,
    pub is_a_i: super::soldier_shared::BoolChannelData,
}

pub const SIMPLEDRIVERCHANNELDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverChannelData",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Fwd",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLCHANNELDATA_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverChannelData, fwd),
            },
            FieldInfoData {
                name: "Bwd",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLCHANNELDATA_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverChannelData, bwd),
            },
            FieldInfoData {
                name: "Left",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLCHANNELDATA_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverChannelData, left),
            },
            FieldInfoData {
                name: "Right",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLCHANNELDATA_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverChannelData, right),
            },
            FieldInfoData {
                name: "Moving",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLCHANNELDATA_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverChannelData, moving),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCHANNELDATA_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverChannelData, angle),
            },
            FieldInfoData {
                name: "SpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCHANNELDATA_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverChannelData, speed_multiplier),
            },
            FieldInfoData {
                name: "IsAI",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLCHANNELDATA_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverChannelData, is_a_i),
            },
        ],
    }),
    array_type: Some(SIMPLEDRIVERCHANNELDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleDriverChannelData {
    fn type_info() -> &'static TypeInfo {
        SIMPLEDRIVERCHANNELDATA_TYPE_INFO
    }
}


pub const SIMPLEDRIVERCHANNELDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverChannelData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SimpleDriverChannelData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SimpleDriverBinding {
    pub fwd: super::ant::AntRef,
    pub bwd: super::ant::AntRef,
    pub left: super::ant::AntRef,
    pub right: super::ant::AntRef,
    pub moving: super::ant::AntRef,
    pub angle: super::ant::AntRef,
    pub speed_multiplier: super::ant::AntRef,
    pub is_a_i: super::ant::AntRef,
}

pub const SIMPLEDRIVERBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Fwd",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverBinding, fwd),
            },
            FieldInfoData {
                name: "Bwd",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverBinding, bwd),
            },
            FieldInfoData {
                name: "Left",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverBinding, left),
            },
            FieldInfoData {
                name: "Right",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverBinding, right),
            },
            FieldInfoData {
                name: "Moving",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverBinding, moving),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverBinding, angle),
            },
            FieldInfoData {
                name: "SpeedMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverBinding, speed_multiplier),
            },
            FieldInfoData {
                name: "IsAI",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(SimpleDriverBinding, is_a_i),
            },
        ],
    }),
    array_type: Some(SIMPLEDRIVERBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SimpleDriverBinding {
    fn type_info() -> &'static TypeInfo {
        SIMPLEDRIVERBINDING_TYPE_INFO
    }
}


pub const SIMPLEDRIVERBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleDriverBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("SimpleDriverBinding-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIDebugProxyData {
    pub proxy_name: String,
    pub test_cover_query: CoverQueryData,
    pub preferred_weapon_range: PreferredRange,
    pub preferred_cover_slot_index: u32,
    pub can_hover: bool,
    pub debug_path: bool,
    pub navmesh_layer: i32,
    pub path_corridor_radius: f32,
    pub force_active: bool,
}

pub const AIDEBUGPROXYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDebugProxyData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ProxyName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(AIDebugProxyData, proxy_name),
            },
            FieldInfoData {
                name: "TestCoverQuery",
                flags: MemberInfoFlags::new(0),
                field_type: COVERQUERYDATA_TYPE_INFO,
                rust_offset: offset_of!(AIDebugProxyData, test_cover_query),
            },
            FieldInfoData {
                name: "PreferredWeaponRange",
                flags: MemberInfoFlags::new(0),
                field_type: PREFERREDRANGE_TYPE_INFO,
                rust_offset: offset_of!(AIDebugProxyData, preferred_weapon_range),
            },
            FieldInfoData {
                name: "PreferredCoverSlotIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AIDebugProxyData, preferred_cover_slot_index),
            },
            FieldInfoData {
                name: "CanHover",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIDebugProxyData, can_hover),
            },
            FieldInfoData {
                name: "DebugPath",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIDebugProxyData, debug_path),
            },
            FieldInfoData {
                name: "NavmeshLayer",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AIDebugProxyData, navmesh_layer),
            },
            FieldInfoData {
                name: "PathCorridorRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIDebugProxyData, path_corridor_radius),
            },
            FieldInfoData {
                name: "ForceActive",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIDebugProxyData, force_active),
            },
        ],
    }),
    array_type: Some(AIDEBUGPROXYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIDebugProxyData {
    fn type_info() -> &'static TypeInfo {
        AIDEBUGPROXYDATA_TYPE_INFO
    }
}


pub const AIDEBUGPROXYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIDebugProxyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIDebugProxyData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AICustomInputComponentData {
    pub realm: super::core::Realm,
    pub input_actions: Vec<AIInputAction>,
}

pub const AICUSTOMINPUTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICustomInputComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AICustomInputComponentData, realm),
            },
            FieldInfoData {
                name: "InputActions",
                flags: MemberInfoFlags::new(144),
                field_type: AIINPUTACTION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AICustomInputComponentData, input_actions),
            },
        ],
    }),
    array_type: Some(AICUSTOMINPUTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AICustomInputComponentData {
    fn type_info() -> &'static TypeInfo {
        AICUSTOMINPUTCOMPONENTDATA_TYPE_INFO
    }
}


pub const AICUSTOMINPUTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICustomInputComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICustomInputComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIInputAction {
    pub name: String,
    pub actions: Vec<i32>,
    pub duration: f32,
}

pub const AIINPUTACTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIInputAction",
    flags: MemberInfoFlags::new(73),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(AIInputAction, name),
            },
            FieldInfoData {
                name: "Actions",
                flags: MemberInfoFlags::new(144),
                field_type: INT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AIInputAction, actions),
            },
            FieldInfoData {
                name: "Duration",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIInputAction, duration),
            },
        ],
    }),
    array_type: Some(AIINPUTACTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AIInputAction {
    fn type_info() -> &'static TypeInfo {
        AIINPUTACTION_TYPE_INFO
    }
}


pub const AIINPUTACTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIInputAction-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIInputAction-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct TargetCoordinationGlobalSettings {
    pub fov_in_degrees: f32,
    pub max_distance: f32,
    pub out_of_fov_factor: f32,
    pub check_cross_fire: bool,
    pub cross_fire_radius: f32,
    pub visible_time_limit: f32,
    pub min_time_in_role_attack: f32,
}

pub const TARGETCOORDINATIONGLOBALSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinationGlobalSettings",
    flags: MemberInfoFlags::new(36937),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "FovInDegrees",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, fov_in_degrees),
            },
            FieldInfoData {
                name: "MaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, max_distance),
            },
            FieldInfoData {
                name: "OutOfFovFactor",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, out_of_fov_factor),
            },
            FieldInfoData {
                name: "CheckCrossFire",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, check_cross_fire),
            },
            FieldInfoData {
                name: "CrossFireRadius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, cross_fire_radius),
            },
            FieldInfoData {
                name: "VisibleTimeLimit",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, visible_time_limit),
            },
            FieldInfoData {
                name: "MinTimeInRoleAttack",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TargetCoordinationGlobalSettings, min_time_in_role_attack),
            },
        ],
    }),
    array_type: Some(TARGETCOORDINATIONGLOBALSETTINGS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for TargetCoordinationGlobalSettings {
    fn type_info() -> &'static TypeInfo {
        TARGETCOORDINATIONGLOBALSETTINGS_TYPE_INFO
    }
}


pub const TARGETCOORDINATIONGLOBALSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TargetCoordinationGlobalSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("TargetCoordinationGlobalSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AICollisionAvoidanceSetupEntityData {
    pub realm: super::core::Realm,
    pub avoid_a_i_players: bool,
    pub avoid_human_players: bool,
    pub velocity_offset_stiffness: f32,
    pub velocity_offset_max_deflection: f32,
    pub look_ahead_time: f32,
    pub recompute_steering_threshold: f32,
    pub max_stationary_repulsion: f32,
    pub repulsion_gain_time: f32,
    pub repulsion_decay_time: f32,
    pub max_repulsion_distance: f32,
}

pub const AICOLLISIONAVOIDANCESETUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICollisionAvoidanceSetupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, realm),
            },
            FieldInfoData {
                name: "AvoidAIPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, avoid_a_i_players),
            },
            FieldInfoData {
                name: "AvoidHumanPlayers",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, avoid_human_players),
            },
            FieldInfoData {
                name: "VelocityOffsetStiffness",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, velocity_offset_stiffness),
            },
            FieldInfoData {
                name: "VelocityOffsetMaxDeflection",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, velocity_offset_max_deflection),
            },
            FieldInfoData {
                name: "LookAheadTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, look_ahead_time),
            },
            FieldInfoData {
                name: "RecomputeSteeringThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, recompute_steering_threshold),
            },
            FieldInfoData {
                name: "MaxStationaryRepulsion",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, max_stationary_repulsion),
            },
            FieldInfoData {
                name: "RepulsionGainTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, repulsion_gain_time),
            },
            FieldInfoData {
                name: "RepulsionDecayTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, repulsion_decay_time),
            },
            FieldInfoData {
                name: "MaxRepulsionDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AICollisionAvoidanceSetupEntityData, max_repulsion_distance),
            },
        ],
    }),
    array_type: Some(AICOLLISIONAVOIDANCESETUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AICollisionAvoidanceSetupEntityData {
    fn type_info() -> &'static TypeInfo {
        AICOLLISIONAVOIDANCESETUPENTITYDATA_TYPE_INFO
    }
}


pub const AICOLLISIONAVOIDANCESETUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AICollisionAvoidanceSetupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AICollisionAvoidanceSetupEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIBucketSystemComponentData {
    pub use_evasive_bucket_settings: bool,
    pub use_human_player: bool,
    pub enabled: bool,
}

pub const AIBUCKETSYSTEMCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBucketSystemComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "UseEvasiveBucketSettings",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIBucketSystemComponentData, use_evasive_bucket_settings),
            },
            FieldInfoData {
                name: "UseHumanPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIBucketSystemComponentData, use_human_player),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIBucketSystemComponentData, enabled),
            },
        ],
    }),
    array_type: Some(AIBUCKETSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIBucketSystemComponentData {
    fn type_info() -> &'static TypeInfo {
        AIBUCKETSYSTEMCOMPONENTDATA_TYPE_INFO
    }
}


pub const AIBUCKETSYSTEMCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBucketSystemComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIBucketSystemComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIBlockerEntityData {
    pub realm: super::core::Realm,
    pub enable_on_init: bool,
    pub slow_distance: f32,
    pub stop_distance: f32,
    pub bounds_expansion: super::core::Vec3,
    pub min_speed_for_bounds_expansion: f32,
    pub allow_movement_inside_bounds: bool,
}

pub const AIBLOCKERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBlockerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Realm",
                flags: MemberInfoFlags::new(0),
                field_type: REALM_TYPE_INFO,
                rust_offset: offset_of!(AIBlockerEntityData, realm),
            },
            FieldInfoData {
                name: "EnableOnInit",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIBlockerEntityData, enable_on_init),
            },
            FieldInfoData {
                name: "SlowDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBlockerEntityData, slow_distance),
            },
            FieldInfoData {
                name: "StopDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBlockerEntityData, stop_distance),
            },
            FieldInfoData {
                name: "BoundsExpansion",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AIBlockerEntityData, bounds_expansion),
            },
            FieldInfoData {
                name: "MinSpeedForBoundsExpansion",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AIBlockerEntityData, min_speed_for_bounds_expansion),
            },
            FieldInfoData {
                name: "AllowMovementInsideBounds",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AIBlockerEntityData, allow_movement_inside_bounds),
            },
        ],
    }),
    array_type: Some(AIBLOCKERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIBlockerEntityData {
    fn type_info() -> &'static TypeInfo {
        AIBLOCKERENTITYDATA_TYPE_INFO
    }
}


pub const AIBLOCKERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIBlockerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIBlockerEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AIAnchorToPointComponentData {
    pub anchor_to_point_binding: AnchorToPointBinding,
    pub target_position: super::core::Vec3,
}

pub const AIANCHORTOPOINTCOMPONENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAnchorToPointComponentData",
    flags: MemberInfoFlags::new(101),
    module: "BattleAIShared",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(GAMECOMPONENTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AnchorToPointBinding",
                flags: MemberInfoFlags::new(0),
                field_type: ANCHORTOPOINTBINDING_TYPE_INFO,
                rust_offset: offset_of!(AIAnchorToPointComponentData, anchor_to_point_binding),
            },
            FieldInfoData {
                name: "TargetPosition",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(AIAnchorToPointComponentData, target_position),
            },
        ],
    }),
    array_type: Some(AIANCHORTOPOINTCOMPONENTDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for AIAnchorToPointComponentData {
    fn type_info() -> &'static TypeInfo {
        AIANCHORTOPOINTCOMPONENTDATA_TYPE_INFO
    }
}


pub const AIANCHORTOPOINTCOMPONENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAnchorToPointComponentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIAnchorToPointComponentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AIAnchorStateTransition {
    #[default]
    AIAnchorStateTransition_None = 0,
    AIAnchorStateTransition_Anchoring = 1,
    AIAnchorStateTransition_Anchored = 2,
    AIAnchorStateTransition_Unanchoring = 3,
    AIAnchorStateTransition_Count = 4,
}

pub const AIANCHORSTATETRANSITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAnchorStateTransition",
    flags: MemberInfoFlags::new(49429),
    module: "BattleAIShared",
    data: TypeInfoData::Enum,
    array_type: Some(AIANCHORSTATETRANSITION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AIAnchorStateTransition {
    fn type_info() -> &'static TypeInfo {
        AIANCHORSTATETRANSITION_TYPE_INFO
    }
}


pub const AIANCHORSTATETRANSITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AIAnchorStateTransition-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AIAnchorStateTransition-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AnchorToPointBinding {
    pub anchor_to_point: super::ant::AntRef,
    pub skip_anchoring: super::ant::AntRef,
    pub is_anchored: super::ant::AntRef,
    pub is_anchor_active: super::ant::AntRef,
    pub anchor_aim_yaw: super::ant::AntRef,
    pub anchor_aim_pitch: super::ant::AntRef,
}

pub const ANCHORTOPOINTBINDING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnchorToPointBinding",
    flags: MemberInfoFlags::new(32841),
    module: "BattleAIShared",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "AnchorToPoint",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AnchorToPointBinding, anchor_to_point),
            },
            FieldInfoData {
                name: "SkipAnchoring",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AnchorToPointBinding, skip_anchoring),
            },
            FieldInfoData {
                name: "IsAnchored",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AnchorToPointBinding, is_anchored),
            },
            FieldInfoData {
                name: "IsAnchorActive",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AnchorToPointBinding, is_anchor_active),
            },
            FieldInfoData {
                name: "AnchorAimYaw",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AnchorToPointBinding, anchor_aim_yaw),
            },
            FieldInfoData {
                name: "AnchorAimPitch",
                flags: MemberInfoFlags::new(0),
                field_type: ANTREF_TYPE_INFO,
                rust_offset: offset_of!(AnchorToPointBinding, anchor_aim_pitch),
            },
        ],
    }),
    array_type: Some(ANCHORTOPOINTBINDING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AnchorToPointBinding {
    fn type_info() -> &'static TypeInfo {
        ANCHORTOPOINTBINDING_TYPE_INFO
    }
}


pub const ANCHORTOPOINTBINDING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AnchorToPointBinding-Array",
    flags: MemberInfoFlags::new(145),
    module: "BattleAIShared",
    data: TypeInfoData::Array("AnchorToPointBinding-Array"),
    array_type: None,
    alignment: 8,
};


